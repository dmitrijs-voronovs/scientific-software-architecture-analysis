quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Security,"// If the load is volatile, we only want to change the load type if the; // resulting load is legal. Otherwise we might increase the number of; // memory accesses. We don't care if the original type was legal or not; // as we assume software couldn't rely on the number of accesses of an; // illegal type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:154,access,accesses,154,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['access'],['accesses']
Security,"// If the load of the hash table is more than 3/4, or if fewer than 1/8 of; // the buckets are empty (meaning that many are filled with tombstones),; // grow the table.; //; // The later case is tricky. For example, if we had one empty bucket with; // tons of tombstones, failing lookups (e.g. for insertion) would have to; // probe almost the entire table until it found the empty bucket. If the; // table completely filled with tombstones, no lookup would ever succeed,; // causing infinite loops in lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:22,hash,hash,22,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,1,['hash'],['hash']
Security,"// If the loop iterates a fixed number of times, we can refine the access size; // to be exactly the size of the memset, which is (BECount+1)*StoreSize",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:67,access,access,67,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['access'],['access']
Security,"// If the loop iterates a fixed number of times, we can refine the access; // size to be exactly the size of the memset, which is (BECount+1)*StoreSize",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:67,access,access,67,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,1,['access'],['access']
Security,"// If the main file name provided is identical to the input file name, and; // if the input file is a preprocessed source, use the module name for; // debug info. The module name comes from the name specified in the first; // linemarker if the input is a preprocessed source. In this case we don't; // know the content to compute a checksum.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:332,checksum,checksum,332,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['checksum'],['checksum']
Security,"// If the member was explicitly marked as nontemporal, mark it as; // nontemporal. If the base lvalue is marked as nontemporal, mark access; // to children as nontemporal too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:133,access,access,133,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['access'],['access']
Security,"// If the model has a default entry, use the value pointers from the entry in the entry managed by the; // processor. This way, the pointers returned by RNTupleModel::MakeField can be used in the processor loop to; // access the corresponding field values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleProcessor.cxx:218,access,access,218,tree/ntuple/v7/src/RNTupleProcessor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleProcessor.cxx,1,['access'],['access']
Security,"// If the null pointer is undefined, then a access sequence which would; // otherwise access it can be assumed not to unsigned wrap. Note that this; // assumes the object in memory is aligned to the natural alignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:44,access,access,44,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,2,['access'],['access']
Security,// If the number of bitmap bytes doesn't match we either have bad data; // or a hash collision.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp:80,hash,hash,80,interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,1,['hash'],['hash']
Security,// If the number of counters doesn't match we either have bad data; // or a hash collision.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp:76,hash,hash,76,interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,1,['hash'],['hash']
Security,// If the object has kernel lifetime we can ignore accesses only reachable; // by other kernels. For now we only skip accesses *in* other kernels.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:51,access,accesses,51,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,2,['access'],['accesses']
Security,"// If the objects noalias, they are distinct, accesses are independent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:46,access,accesses,46,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['access'],['accesses']
Security,"// If the offset doesn't fit, put the low bits into the offset field and; // add the rest.; //; // For a FLAT instruction the hardware decides whether to access; // global/scratch/shared memory based on the high bits of vaddr,; // ignoring the offset field, so we have to ensure that when we add; // remainder to vaddr it still points into the same underlying object.; // The easiest way to do that is to make sure that we split the offset; // into two pieces that are both >= 0 or both <= 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp:154,access,access,154,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,1,['access'],['access']
Security,"// If the original import came from a file explicitly generated by the user,; // don't check the diagnostic mappings.; // FIXME: currently this is approximated by checking whether this is not a; // module import of an implicitly-loaded module file.; // Note: ModuleMgr.rbegin() may not be the current module, but it must be in; // the transitive closure of its imports, since unrelated modules cannot be; // imported until after this module finishes validation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:450,validat,validation,450,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['validat'],['validation']
Security,"// If the other operand is a TLS address, we should fold it instead.; // This produces; // movl %gs:0, %eax; // leal i@NTPOFF(%eax), %eax; // instead of; // movl $i@NTPOFF, %eax; // addl %gs:0, %eax; // if the block also has an access to a second TLS address this will save; // a load.; // FIXME: This is probably also true for non-TLS addresses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:228,access,access,228,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['access'],['access']
Security,"// If the parameter is a c++ class type and it has to be destructed in the; // callee function, declare the destructor so that it can be called by the; // callee function. Do not perform any direct access check on the dtor here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:198,access,access,198,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['access'],['access']
Security,"// If the pointer overflow sanitizer isn't enabled, do nothing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:27,sanitiz,sanitizer,27,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['sanitiz'],['sanitizer']
Security,"// If the register list contains any high registers, or if the writeback; // doesn't match what tLDMIA can do, we need to use the 32-bit encoding; // instead if we're in Thumb2. Otherwise, this should have generated; // an error in validateInstruction().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:232,validat,validateInstruction,232,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['validat'],['validateInstruction']
Security,"// If the register list contains any high registers, we need to use; // the 32-bit encoding instead if we're in Thumb2. Otherwise, this; // should have generated an error in validateInstruction().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:174,validat,validateInstruction,174,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,2,['validat'],['validateInstruction']
Security,"// If the scope is a DICompositeType, then this must be a method. Member; // function types take some special handling, and require access to the; // subprogram.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:132,access,access,132,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,1,['access'],['access']
Security,"// If the second token is a hashhash token, then we need to translate it to; // unknown so the token lexer doesn't try to perform token pasting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:28,hash,hashhash,28,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['hash'],['hashhash']
Security,// If the shift amount is larger than the input type then we're not; // accessing any of the loaded bytes. If the load was a zextload/extload; // then the result of the shift+trunc is zero/undef (handled elsewhere).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:72,access,accessing,72,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['access'],['accessing']
Security,// If the shift amount is larger than the memory type then we're not; // accessing any of the loaded bytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:73,access,accessing,73,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['access'],['accessing']
Security,"// If the signed integer truncation sanitizer is enabled,; // and this is a truncation from signed type, then no check is needed.; // Because here sign change check is interchangeable with truncation check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:36,sanitiz,sanitizer,36,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['sanitiz'],['sanitizer']
Security,"// If the signed integer truncation sanitizer was enabled,; // and we are truncating from larger unsigned type to smaller signed type,; // let's handle the case we skipped in that check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:36,sanitiz,sanitizer,36,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['sanitiz'],['sanitizer']
Security,"// If the signed-integer-overflow sanitizer is enabled, emit a call to its; // runtime. Otherwise, this is a -ftrapv check, so just emit a trap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:34,sanitiz,sanitizer,34,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['sanitiz'],['sanitizer']
Security,"// If the sink is accessed before src, swap src/sink.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:18,access,accessed,18,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['access'],['accessed']
Security,"// If the size is zero, there won't be any actual memory access, so; // just bind the return value to the buffer and return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:57,access,access,57,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,1,['access'],['access']
Security,"// If the size is zero, there won't be any actual memory access, so; // just bind the return value to the destination buffer and return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:57,access,access,57,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,1,['access'],['access']
Security,"// If the size is zero, there won't be any actual memory access,; // In this case we just return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:57,access,access,57,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,1,['access'],['access']
Security,"// If the size of memory access is unknown, do not use it to analysis.; // One example of unknown size memory access is to load/store scalable; // vector objects on the stack.; // BasePtr1 is PtrDiff away from BasePtr0. They alias if none of the; // following situations arise:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGAddressAnalysis.cpp:25,access,access,25,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGAddressAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGAddressAnalysis.cpp,2,['access'],['access']
Security,"// If the size of memory access is unknown, do not use it to do analysis.; // One example of unknown size memory access is to load/store scalable; // vector objects on the stack.; // BasePtr1 is PtrDiff away from BasePtr0. They alias if none of the; // following situations arise:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:25,access,access,25,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,2,['access'],['access']
Security,"// If the size of one access is larger than the entire object on the other; // side, then we know such behavior is undefined and can assume no alias.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:22,access,access,22,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,1,['access'],['access']
Security,"// If the source integer type is not the intptr_t type for this target, do a; // trunc or zext to the intptr_t type, then inttoptr of it. This allows the; // cast to be exposed to other transforms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:169,expose,exposed,169,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['expose'],['exposed']
Security,"// If the stack is not accessible by other threads, the ""must-free"" logic; // doesn't apply as the pointer could be shared and needs to be places in; // ""shareable"" memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:23,access,accessible,23,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['access'],['accessible']
Security,"// If the statement type \p N is nestable, and its nesting impacts profile; // stability, define a custom traversal which tracks the end of the statement; // in the hash (provided we're not using the V1 hash).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp:165,hash,hash,165,interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,2,['hash'],['hash']
Security,"// If the store fails, our buffer is full and ready to hash. We have to; // either initialize the hash state (on the first full buffer) or mix; // this buffer into the existing hash state. Length tracks the *hashed*; // length, not the buffered length.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:55,hash,hash,55,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,4,['hash'],"['hash', 'hashed']"
Security,"// If the store is volatile, we only want to change the store type if the; // resulting store is legal. Otherwise we might increase the number of; // memory accesses. We don't care if the original type was legal or not; // as we assume software couldn't rely on the number of accesses of an; // illegal type.; // TODO: May be able to relax for unordered atomics (see D66309)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:157,access,accesses,157,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['access'],['accesses']
Security,"// If the target happens to be one of the previous declarations, we; // don't have a conflict.; //; // FIXME: but we might be increasing its access, in which case we; // should redeclare it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:141,access,access,141,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['access'],['access']
Security,"// If the target is M Class then need to validate that the register string; // is an acceptable value, so check that a mask can be constructed from the; // string.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:41,validat,validate,41,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['validat'],['validate']
Security,// If the target was M Class then need to validate the special register value; // and retrieve the mask for use in the instruction node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:42,validat,validate,42,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['validat'],['validate']
Security,"// If the terminator is a free-like call, all accesses to the underlying; // object can be considered terminated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:46,access,accesses,46,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,1,['access'],['accesses']
Security,"// If the true/false operands are swapped and the conditions are compares; // with inverted predicates, the selects are equal:; // select (icmp Pred, X, Y), A, B <--> select (icmp InvPred, X, Y), B, A; //; // This also handles patterns with a double-negation in the sense of not +; // inverse, because we looked through a 'not' in the matching function and; // swapped A/B:; // select (cmp Pred, X, Y), A, B <--> select (not (cmp InvPred, X, Y)), B, A; //; // This intentionally does NOT handle patterns with a double-negation in; // the sense of not + not, because doing so could result in values; // comparing; // as equal that hash differently in the min/max cases like:; // select (cmp slt, X, Y), X, Y <--> select (not (not (cmp slt, X, Y))), X, Y; // ^ hashes as min ^ would not hash as min; // In the context of the EarlyCSE pass, however, such cases never reach; // this code, as we simplify the double-negation before hashing the second; // select (and so still succeed at CSEing them).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:630,hash,hash,630,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,4,['hash'],"['hash', 'hashes', 'hashing']"
Security,"// If the type hash matches an invalid pattern, mask the value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:15,hash,hash,15,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,1,['hash'],['hash']
Security,"// If the type is scalable and the constant is not zero (vscale * n * 0 =; // 0) bailout.; // TODO: If the runtime value is accessible at any point before DWARF; // emission, then we could potentially keep a forward reference to it; // in the debug value to be filled in later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Operator.cpp:124,access,accessible,124,interpreter/llvm-project/llvm/lib/IR/Operator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Operator.cpp,1,['access'],['accessible']
Security,"// If the type of the nested name specifier is the same as the; // injected class name of the named class template, we're entering; // into that class template definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:67,inject,injected,67,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,1,['inject'],['injected']
Security,// If the unresolved member functions were found in a 'naming class' that is; // related (either the same or derived from) to the class that contains the; // member function that itself contained the implicit member access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:216,access,access,216,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['access'],['access']
Security,"// If the use of the pointer will be a scalar use, and all users of the; // pointer are memory accesses, place the pointer in ScalarPtrs. Otherwise,; // place the pointer in PossibleNonScalarPtrs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:95,access,accesses,95,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['access'],['accesses']
Security,"// If the user wants to use the extended "".help scopeName"" command to access; // the online reference guide, we first check if the command starts correctly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:70,access,access,70,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['access'],['access']
Security,"// If the va_arg address cannot alias the pointer in question, then the; // specified memory cannot be accessed by the va_arg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:103,access,accessed,103,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,1,['access'],['accessed']
Security,"// If the variable might have been accessed by its initializer, we; // might have to initialize with a barrier. We have to do this for; // both __weak and __strong, but __weak got filtered out above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:35,access,accessed,35,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,1,['access'],['accessed']
Security,"// If the verify is done following an optimization, it's possible that; // ClobberAt was a conservative clobbering, that we can now infer is not a; // true clobbering access. Don't fail the verify if that's the case.; // We do have accesses that claim they're optimized, but could be optimized; // further. Updating all these can be expensive, so allow it for now (FIXME).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:167,access,access,167,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,2,['access'],"['access', 'accesses']"
Security,"// If there are accesses in the current basic block, find the first one; // that does not come before NewS. The new memory access is inserted; // after the found access or before the terminator if no such access is; // found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:16,access,accesses,16,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,4,['access'],"['access', 'accesses']"
Security,"// If there are any bytes in the chunk state, finalize that chunk and do a; // roll-up merge between that chunk hash and every subtree in the stack. In; // this case, the extra merge loop at the end of blake3_hasher_update; // guarantees that none of the subtrees in the stack need to be merged with; // each other first. Otherwise, if there are no bytes in the chunk state,; // then the top of the stack is a chunk hash, and we start the merge from; // that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c:112,hash,hash,112,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,2,['hash'],['hash']
Security,"// If there are interfering Uses (i.e. their defining access is in the; // loop), or ordered loads (stored as Defs!), don't move this store.; // Could do better here, but this is conservatively correct.; // TODO: Cache set of Uses on the first walk in runOnLoop, update when; // moving accesses. Can also extend to dominating uses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:54,access,access,54,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,2,['access'],"['access', 'accesses']"
Security,"// If there are more accesses than the Promotion cap, then give up as we're; // not walking a list that long.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:21,access,accesses,21,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['access'],['accesses']
Security,"// If there are more operands that weren't in the DAG, they have to; // be operands that have default values, or we have an error. Currently,; // Operands that are a subclass of OperandWithDefaultOp have default values.; // Validate that each result pattern argument has a matching (by name); // argument in the source instruction, in either the (outs) or (ins) list.; // Also check that the type of the arguments match.; //; // Record the mapping of the source to result arguments for use by; // the lowering emitter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/PseudoLoweringEmitter.cpp:224,Validat,Validate,224,interpreter/llvm-project/llvm/utils/TableGen/PseudoLoweringEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/PseudoLoweringEmitter.cpp,1,['Validat'],['Validate']
Security,"// If there are no arguments specified, warn with -Wformat-security, otherwise; // warn only with -Wformat-nonliteral.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:59,secur,security,59,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['secur'],['security']
Security,"// If there are no invalidation methods, there is no ivar validation work; // to be done.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:58,validat,validation,58,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,1,['validat'],['validation']
Security,"// If there are no loads or stores, the access is dead. We mark that as; // a size zero access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:40,access,access,40,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,2,['access'],['access']
Security,// If there are no memory operands then conservatively assume the flat; // operation may access LDS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:89,access,access,89,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['access'],['access']
Security,// If there are no memory operands then conservatively assume the flat; // operation may access VMEM.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:89,access,access,89,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['access'],['access']
Security,// If there are no memory operands then conservatively assume the flat; // operation may access scratch.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:89,access,access,89,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['access'],['access']
Security,"// If there are scalar reductions and TTI has enabled aggressive; // interleaving for reductions, we will interleave to expose ILP.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:120,expose,expose,120,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['expose'],['expose']
Security,// If there is a possibility that flat instruction access scratch memory; // then we need to use the same legalization rules we use for private.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:51,access,access,51,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,2,['access'],['access']
Security,"// If there is a static runtime with no dynamic list, force all the symbols; // to be dynamic to be sure we export sanitizer interface functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:115,sanitiz,sanitizer,115,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,1,['sanitiz'],['sanitizer']
Security,// If there is memory accessing to promise alloca before CoroBegin;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:22,access,accessing,22,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['access'],['accessing']
Security,"// If there is no access type or the access type is the root node, then; // we don't have any useful access tag to return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:18,access,access,18,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,3,['access'],['access']
Security,"// If there is no obvious reason to prefer the left-hand side over the; // right-hand side, ensure the longest lived term is on the right-hand side,; // so the shortest lived term will be replaced by the longest lived.; // This tends to expose more simplifications.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:237,expose,expose,237,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['expose'],['expose']
Security,// If there is no upwards exposed use and an entry for the swifterror in; // the def map for this value we don't need to do anything: We already; // have a downward def for this basic block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:26,expose,exposed,26,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,1,['expose'],['exposed']
Security,// If there is no upwards exposed used and we don't need a phi just; // forward the swifterror vreg from the predecessor(s).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:26,expose,exposed,26,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,1,['expose'],['exposed']
Security,"// If there is overlap between the found cluster and the authorized range; // update the cache data members with the information about the current cluster.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:57,authoriz,authorized,57,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['authoriz'],['authorized']
Security,"// If there was no explicit access control, provide the default for the tag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:28,access,access,28,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,1,['access'],['access']
Security,"// If there's a virtual step, we can sometimes ""devirtualize"" it.; // For now, that's limited to when the derived type is final.; // TODO: ""devirtualize"" this for accesses to known-complete objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:163,access,accesses,163,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,1,['access'],['accesses']
Security,"// If this causes an SCC to split apart into multiple smaller SCCs, there; // is a subtle risk we need to prepare for. Other transformations may; // expose an ""infinite inlining"" opportunity later, and because of the SCC; // mutation, we will revisit this function and potentially re-inline. If we; // do, and that re-inlining also has the potentially to mutate the SCC; // structure, the infinite inlining problem can manifest through infinite; // SCC splits and merges. To avoid this, we capture the originating caller; // node and the SCC containing the call edge. This is a slight over; // approximation of the possible inlining decisions that must be avoided,; // but is relatively efficient to store. We use C != OldC to know when; // a new SCC is generated and the original SCC may be generated via merge; // in later iterations.; //; // It is also possible that even if no new SCC is generated; // (i.e., C == OldC), the original SCC could be split and then merged; // into the same one as itself. and the original SCC will be added into; // UR.CWorklist again, we want to catch such cases too.; //; // FIXME: This seems like a very heavyweight way of retaining the inline; // history, we should look for a more efficient way of tracking it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:149,expose,expose,149,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,1,['expose'],['expose']
Security,"// If this class contains MemoryDefs or MemoryPhis, this is the leading memory; // access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:83,access,access,83,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['access'],['access']
Security,"// If this declaration injected a name into a context different from its; // lexical context, and that context is an imported namespace, we need to; // update its visible declarations to include this name.; //; // This happens when we instantiate a class with a friend declaration or a; // function with a local extern declaration, for instance.; //; // FIXME: Can we handle this in AddedVisibleDecl instead?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:23,inject,injected,23,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,1,['inject'],['injected']
Security,"// If this function has uses aligned stack and also has variable sized stack; // objects, then we need to map all spill slots to fixed positions, so that; // they can be accessed through FP. Otherwise they would have to be accessed; // via AP, which may not be available at the particular place in the program.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:170,access,accessed,170,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,2,['access'],['accessed']
Security,"// If this function is ignored for any of the enabled sanitizers,; // disable the sanitizer for the function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:54,sanitiz,sanitizers,54,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,2,['sanitiz'],"['sanitizer', 'sanitizers']"
Security,"// If this inst is a memory op, get the pointer it accessed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:51,access,accessed,51,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['access'],['accessed']
Security,// If this instruction accesses memory make sure it doesn't access beyond; // the bounds of the allocated object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:23,access,accesses,23,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,2,['access'],"['access', 'accesses']"
Security,"// If this instruction is not guaranteed to execute, and we haven't seen a; // load or store at this offset before (or it had lower alignment), then we; // need to remember that requirement.; // Note that skipping instructions of previously seen offsets is only; // correct because we only allow a single type for a given offset, which; // also means that the number of accessed bytes will be the same.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:370,access,accessed,370,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,1,['access'],['accessed']
Security,"// If this is a declaration inside an ODR type, only hash the type and the; // name. Otherwise the hash will be stronger than; // MDNodeSubsetEqualImpl::isDeclarationOfODRMember().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:53,hash,hash,53,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,2,['hash'],['hash']
Security,"// If this is a first class global and has only one accessing function and; // this function is non-recursive, we replace the global with a local alloca; // in this function.; //; // NOTE: It doesn't make sense to promote non-single-value types since we; // are just replacing static memory to stack memory.; //; // If the global is in different address space, don't bring it to stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:52,access,accessing,52,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['access'],['accessing']
Security,"// If this is a member inside an ODR type, only hash the type and the name.; // Otherwise the hash will be stronger than; // MDNodeSubsetEqualImpl::isODRMember().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:48,hash,hash,48,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,2,['hash'],['hash']
Security,"// If this is a multiply expression, turn any internal negations into; // multiplies by -1 so they can be reassociated. Add any users of the; // newly created multiplication by -1 to the redo list, so any; // reassociation opportunities that are exposed will be reassociated; // further.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:246,expose,exposed,246,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['expose'],['exposed']
Security,"// If this is an ""immutable"" type, the access is not observable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:39,access,access,39,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,1,['access'],['access']
Security,"// If this is an accessible, non-textual header of M's top-level module; // that transitively includes the given location and makes the; // corresponding module visible, this is the thing to #include.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:17,access,accessible,17,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['access'],['accessible']
Security,"// If this is an allocation, and if we know that the accessed pointer is to; // the allocation, return Def. This means that there is no dependence and; // the access can be optimized based on that. For example, a load could; // turn into undef. Note that we can bypass the allocation itself when; // looking for a clobber in many cases; that's an alias property and is; // handled by BasicAA.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:53,access,accessed,53,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,2,['access'],"['access', 'accessed']"
Security,"// If this is an already optimized use or def, return the optimized result.; // Note: Currently, we store the optimized def result in a separate field,; // since we can't use the defining access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:188,access,access,188,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['access'],['access']
Security,"// If this is an archive, we might have either the object or the archive; // cached. In this case we can load it without accessing the file system.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp:121,access,accessing,121,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.cpp,1,['access'],['accessing']
Security,"// If this is an explicit specialization, inject it into cling, too, such that it can have; // externalLexicalStorage, see TCling.cxx's ExtVisibleStorageAdder::VisitClassTemplateSpecializationDecl.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:42,inject,inject,42,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['inject'],['inject']
Security,"// If this is an extension from the dest type, we can eliminate it,; // even if it has multiple users. Thus, update the DesiredBitWidth and; // validate all extension instructions agrees on same DesiredBitWidth.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:144,validat,validate,144,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,1,['validat'],['validate']
Security,"// If this is an implicit member access, use a different set of; // diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:33,access,access,33,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['access'],['access']
Security,"// If this is an indirect operand, the operand is a pointer to the; // accessed type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp:71,access,accessed,71,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,1,['access'],['accessed']
Security,"// If this is known to be an instance access, go ahead and build an; // implicit 'this' expression now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:38,access,access,38,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['access'],['access']
Security,"// If this is not a named PSTATE, just continue without validating, as this; // will be lowered to an ""MSR (register)"" instruction directly",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:56,validat,validating,56,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['validat'],['validating']
Security,"// If this is not an instance member, convert to a non-member access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:62,access,access,62,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['access'],['access']
Security,"// If this is private inheritance, then a public member of the; // base will not have any access in classes derived from Cur.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:90,access,access,90,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['access'],['access']
Security,"// If this is the first use of this swifterror value in this basic block,; // create a new virtual register.; // After we processed all basic blocks we will satisfy this ""upwards exposed; // use"" by inserting a copy or phi at the beginning of this block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:179,expose,exposed,179,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,1,['expose'],['exposed']
Security,"// If this is the last Def in the block, we may need additional Phis.; // Compute IDF in all cases, as renaming needs to be done even when MD is; // not the last access, because it can introduce a new access past which a; // previous access was optimized; that access needs to be reoptimized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:162,access,access,162,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,4,['access'],['access']
Security,"// If this is the last bucket, it consists of all hash records until the end; // of the HashRecords array.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/GlobalsStream.cpp:50,hash,hash,50,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/GlobalsStream.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/GlobalsStream.cpp,2,"['Hash', 'hash']","['HashRecords', 'hash']"
Security,"// If this is true, the PDB contents are hashed and this hash is used as; // PDB GUID and as Signature. The age is always 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/InfoStreamBuilder.h:41,hash,hashed,41,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/InfoStreamBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/InfoStreamBuilder.h,2,['hash'],"['hash', 'hashed']"
Security,"// If this is: (X >> C3) & C2 != C1 (where any shift and any compare could; // exist), turn it into (X & (C2 << C3)) != (C1 << C3). This happens a LOT in; // code produced by the clang front-end, for bitfield access.; // This seemingly simple opportunity to fold away a shift turns out to be; // rather complicated. See PR17827 for details.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:209,access,access,209,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['access'],['access']
Security,"// If this isn't a ""real"" access (eg, if it's just accessing the type; // info), allow it. We assume the type doesn't change dynamically for; // subobjects of constexpr objects (even though we'd hit UB here if it; // did). FIXME: Is this right?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:26,access,access,26,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,2,['access'],"['access', 'accessing']"
Security,"// If this memory access can be shown to *statically* extend outside the; // bounds of the allocation, it's behavior is undefined, so simply; // ignore it. Note that this is more strict than the generic clamping; // behavior of insertUse. We also try to handle cases which might run the; // risk of overflow.; // FIXME: We should instead consider the pointer to have escaped if this; // function is being instrumented for addressing bugs or race conditions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:18,access,access,18,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['access'],['access']
Security,"// If this module has already been finalized in the ModuleCache, we're stuck; // with it; we can only load a single version of each module.; //; // This can happen when a module is imported in two contexts: in one, as a; // user module; in another, as a system module (due to an import from; // another module marked with the [system] flag). It usually indicates a; // bug in the module map: this module should also be marked with [system].; //; // If -Wno-system-headers (the default), and the first import is as a; // system module, then validation will fail during the as-user import,; // since -Werror flags won't have been validated. However, it's reasonable; // to treat this consistently as a system module.; //; // If -Wsystem-headers, the PCM on disk was built with; // -Wno-system-headers, and the first import is as a user module, then; // validation will fail during the as-system import since the PCM on disk; // doesn't guarantee that -Werror was respected. However, the -Werror; // flags were checked during the initial as-user import.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:540,validat,validation,540,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,3,['validat'],"['validated', 'validation']"
Security,"// If this node has a single predecessor which ends in a conditional branch,; // we can infer the value of the branch condition given that we took this; // path. We need the single predecessor to ensure there's not another path; // which reaches this block where the condition might hold a different; // value. Since we're adding this to the scoped hash table (like any other; // def), it will have been popped if we encounter a future merge block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:349,hash,hash,349,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['hash'],['hash']
Security,"// If this starts with a '#', this may be a cpp; // hash directive and otherwise a line comment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmLexer.cpp:52,hash,hash,52,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmLexer.cpp,1,['hash'],['hash']
Security,"// If this successor was reached through a branch rather than fallthrough,; // we might have *broken* fallthrough and so need to inject a new; // unconditional branch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:129,inject,inject,129,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['inject'],['inject']
Security,// If this target takes alignments in bytes (not log) validate and convert.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:54,validat,validate,54,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,2,['validat'],['validate']
Security,"// If this type was written as an injected-class-name, it can be used as a; // template template argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:34,inject,injected-class-name,34,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['inject'],['injected-class-name']
Security,"// If this type was written as an injected-class-name, it may have been; // converted to a RecordType during instantiation. If the RecordType is; // *not* wrapped in a TemplateSpecializationType and denotes a class; // template specialization, it must have come from an injected-class-name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:34,inject,injected-class-name,34,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,2,['inject'],['injected-class-name']
Security,"// If this was private inheritance, but we don't have access to; // the deriving class, we're done.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:54,access,access,54,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['access'],['access']
Security,// If this worklist walks back to the original memory access (and the; // pointer is not guarenteed loop invariant) then we cannot assume that a; // store kills itself.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:54,access,access,54,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,1,['access'],['access']
Security,// If true indicates that this global variable might be accessed; // purely by non-volatile load instructions. This in turn means; // it can be internalized in source and destination modules during; // thin LTO import because it neither modified nor its address; // is taken.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:56,access,accessed,56,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['access'],['accessed']
Security,"// If true, an LLVM IR value might point to this object.; // Normally, spill slots and fixed-offset objects don't alias IR-accessible; // objects, but there are exceptions (on PowerPC, for example, some byval; // arguments have ABI-prescribed offsets).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:123,access,accessible,123,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,1,['access'],['accessible']
Security,"// If two modules, share the same LLVMContext, different threads must; // not access them concurrently without locking the associated LLVMContext; // this implementation follows this contract.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp:78,access,access,78,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp,1,['access'],['access']
Security,"// If v.cnt < 6 then we have a class with a version that used to be zero and so there is no checksum.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx:92,checksum,checksum,92,io/io/src/TBufferFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx,1,['checksum'],['checksum']
Security,"// If validation is enabled, upgrade visibility only when all vtables; // have typeinfos.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:6,validat,validation,6,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,2,['validat'],['validation']
Security,"// If we *don't* protect the user from escaped allocas, don't bother; // validating the instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:73,validat,validating,73,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,1,['validat'],['validating']
Security,"// If we access outside memory outside the record, than bail out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp:9,access,access,9,interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp,1,['access'],['access']
Security,"// If we already know which single declaration is referenced, just annotate; // that declaration directly. Defer resolving even non-overloaded class; // member accesses, as we need to defer certain access checks until we know; // the context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:160,access,accesses,160,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['access'],"['access', 'accesses']"
Security,"// If we are extracting from an insert into a larger vector, replace with a; // smaller insert if we don't access less than the original subvector. Don't; // do this for i1 vectors.; // TODO: Relax the matching indices requirement?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:107,access,access,107,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['access'],['access']
Security,"// If we are rewriting an alloca partition which can be written as pure; // vector operations, we stash extra information here. When VecTy is; // non-null, we have some strict guarantees about the rewritten alloca:; // - The new alloca is exactly the size of the vector type here.; // - The accesses all either map to the entire vector or to a single; // element.; // - The set of accessing instructions is only one of those handled above; // in isVectorPromotionViable. Generally these are the same access kinds; // which are promotable via mem2reg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:291,access,accesses,291,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,3,['access'],"['access', 'accesses', 'accessing']"
Security,"// If we are talking to a recent proofd send over a buffer with the; // remaining authentication related stuff",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TRootAuth.cxx:82,authenticat,authentication,82,net/auth/src/TRootAuth.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TRootAuth.cxx,1,['authenticat'],['authentication']
Security,"// If we are using App Extension restrictions, pass a flag to the linker; // telling it that the compiled code has been audited.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:120,audit,audited,120,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,1,['audit'],['audited']
Security,"// If we broke out of the loop, we still need to wait for everything to; // avoid race access to the chunk set.; //; // TODO: Create a way to kill remaining items we're ignoring; they could; // take a long time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/Delta.cpp:87,access,access,87,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/Delta.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/Delta.cpp,1,['access'],['access']
Security,"// If we can go arbitrarily backwards we will eventually reach an entry point; // that can reach ToI. Only if a set of blocks through which we cannot go is; // provided, or once we track internal functions not accessible from the; // outside, it makes sense to perform backwards analysis in the absence of a; // GoBackwardsCB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:210,access,accessible,210,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['access'],['accessible']
Security,"// If we can prove that; // (**) |Dist| > BackedgeTakenCount * Step; // where Step is the absolute stride of the memory accesses in bytes,; // then there is no dependence.; //; // Rationale:; // We basically want to check if the absolute distance (|Dist/Step|); // is >= the loop iteration count (or > BackedgeTakenCount).; // This is equivalent to the Strong SIV Test (Practical Dependence Testing,; // Section 4.2.1); Note, that for vectorization it is sufficient to prove; // that the dependence distance is >= VF; This is checked elsewhere.; // But in some cases we can prune dependence distances early, and; // even before selecting the VF, and without a runtime test, by comparing; // the distance against the loop iteration count. Since the vectorized code; // will be executed only if LoopCount >= VF, proving distance >= LoopCount; // also guarantees that distance >= VF.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:120,access,accesses,120,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['access'],['accesses']
Security,"// If we can't promote the alloca, iterate on it to check for new; // refinements exposed by splitting the current alloca. Don't iterate on an; // alloca which didn't actually change and didn't get promoted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:82,expose,exposed,82,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['expose'],['exposed']
Security,"// If we cannot access that entry, mark the iterator invalid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h:16,access,access,16,tree/treeplayer/inc/TTreeReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h,1,['access'],['access']
Security,"// If we didn't Rehash before, we might have to do it; // now, due to a non-perfect hash function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/THashTable.cxx:84,hash,hash,84,core/cont/src/THashTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/THashTable.cxx,1,['hash'],['hash']
Security,"// If we didn't encounter a memory access in the expression tree, or if we; // gave up for some reason, just return the width of V. Otherwise, return the; // maximum width we found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,access,access,35,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['access'],['access']
Security,"// If we didn't find a use of this identifier, and if the identifier; // corresponds to a compiler builtin, create the decl object for the builtin; // now, injecting it into translation unit scope, and return it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:156,inject,injecting,156,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,2,['inject'],['injecting']
Security,"// If we didn't find any pair that has at least MinCommonTailLength; // instructions in common, remove all blocks with this hash code and retry.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:124,hash,hash,124,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['hash'],['hash']
Security,"// If we distinguish volatile accesses and if either the read or write; // is volatile, do not omit any instrumentation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:30,access,accesses,30,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,1,['access'],['accesses']
Security,"// If we do not reserve stack space for outgoing arguments in prologue,; // we will adjust the stack pointer before call instruction. After the; // adjustment, we can not use SP to access the stack objects for the; // arguments. Instead, use BP to access these stack objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:181,access,access,181,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,2,['access'],['access']
Security,"// If we don't already have something with the form of an identifier,; // create a buffer with the sanitized name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:99,sanitiz,sanitized,99,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,1,['sanitiz'],['sanitized']
Security,"// If we don't have a constraining base, the access failure must be; // due to the original declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:45,access,access,45,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['access'],['access']
Security,// If we don't have a forward ref we can't compute the hash of it from the; // full record because it requires hashing the entire buffer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/TpiHashing.cpp:55,hash,hash,55,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/TpiHashing.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/TpiHashing.cpp,2,['hash'],"['hash', 'hashing']"
Security,// If we don't have access to NEON instructions then we won't be able; // to swizzle anything to the NEON domain. Check to make sure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:20,access,access,20,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['access'],['access']
Security,"// If we don't have duplicate context ids, then we can assign all the; // context ids computed for the original node sequence to this call.; // If there are duplicate calls with the same stack ids then we synthesize; // new context ids that are duplicates of the originals. These are; // assigned to SavedContextIds, which is a reference into the map entry; // for this call, allowing us to access these ids later on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:391,access,access,391,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['access'],['access']
Security,// If we don't need a phi create a copy to the upward exposed vreg.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:54,expose,exposed,54,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,1,['expose'],['exposed']
Security,"// If we find 0, it means the item isn't in the hash table.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBStringTable.cpp:48,hash,hash,48,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBStringTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBStringTable.cpp,1,['hash'],['hash']
Security,"// If we found a metadata index, let's verify that we had an offset; // before and validate its forward reference offset was correct!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp:83,validat,validate,83,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp,1,['validat'],['validate']
Security,"// If we found a module hash, let's verify that it matches!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp:24,hash,hash,24,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp,1,['hash'],['hash']
Security,"// If we found both an unordered atomic instruction and a non-atomic memory; // access, bail. We can't blindly promote non-atomic to atomic since we; // might not be able to lower the result. We can't downgrade since that; // would violate memory model. Also, align 0 is an error for atomics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:80,access,access,80,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['access'],['access']
Security,"// If we get here, it's because we're calling a member function; // that is named without a member access expression (e.g.,; // ""this->f"") that was either written explicitly or created; // implicitly. This can happen with a qualified call to a member; // function, e.g., X::f(). We use an empty type for the implied; // object argument (C++ [over.call.func]p3), and the acting context; // is irrelevant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:99,access,access,99,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['access'],['access']
Security,"// If we get here, then this source is importing from a temporary ASTContext; // that also has another ExternalASTMerger attached. It could be; // possible that the current ExternalASTMerger and the temporary ASTContext; // share a common ImporterSource, which means that the temporary; // AST could contain declarations that were imported from a source; // that this ExternalASTMerger can access directly. Instead of importing; // such declarations from the temporary ASTContext, they should instead; // be directly imported by this ExternalASTMerger from the original; // source. This way the ExternalASTMerger can safely do a minimal import; // without creating incomplete declarations originated from a temporary; // ASTContext. If we would try to complete such declarations later on, we; // would fail to do so as their temporary AST could be deleted (which means; // that the missing parts of the minimally imported declaration in that; // ASTContext were also deleted).; //; // The following code tracks back any declaration that needs to be; // imported from the temporary ASTContext to a persistent ASTContext.; // Then the ExternalASTMerger tries to import from the persistent; // ASTContext directly by using the associated ASTImporter. If that; // succeeds, this ASTImporter just maps the declarations imported by; // the other (persistent) ASTImporter to this (temporary) ASTImporter.; // The steps can be visualized like this:; //; // Target AST <--- 3. Indirect import --- Persistent AST; // ^ of persistent decl ^; // | |; // 1. Current import 2. Tracking back to persistent decl; // 4. Map persistent decl |; // & pretend we imported. |; // | |; // Temporary AST -------------------------------'; // First, ask the ExternalASTMerger of the source where the temporary; // declaration originated from.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:390,access,access,390,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,1,['access'],['access']
Security,// If we give up and indicate a pessimistic fixpoint this instruction will; // become an access for all potential access kinds:; // TODO: Add pointers for argmemonly and globals to improve the results of; // checkForAllAccessesToMemoryKind.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:89,access,access,89,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,2,['access'],['access']
Security,"// If we had valid trailing '=' characters strip the right number of bytes; // from the end of the output buffer. We already know that the Input length; // it a multiple of 4 and is not zero, so direct character access is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Base64.cpp:212,access,access,212,interpreter/llvm-project/llvm/lib/Support/Base64.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Base64.cpp,1,['access'],['access']
Security,"// If we have a '#' or '$', it's an immediate offset, else assume it's a; // register offset. Be friendly and also accept a plain integer or expression; // (without a leading hash) for gas compatibility.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:175,hash,hash,175,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['hash'],['hash']
Security,"// If we have a column number, validate it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SourceMgr.cpp:31,validat,validate,31,interpreter/llvm-project/llvm/lib/Support/SourceMgr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SourceMgr.cpp,1,['validat'],['validate']
Security,"// If we have a combined directive that combines 'distribute', 'for' or; // 'simd' we need to be able to access the bounds of the schedule of the; // enclosing region. E.g. in 'distribute parallel for' the bounds obtained; // by scheduling 'distribute' have to be passed to the schedule of 'for'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:105,access,access,105,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['access'],['access']
Security,"// If we have a constant index, we can use the exact offset of the; // element we're accessing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:85,access,accessing,85,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['access'],['accessing']
Security,"// If we have a frame pointer, we assume arguments will be accessed; // relative to the frame pointer. Check whether fp-relative accesses to; // arguments require scavenging.; //; // We could do slightly better on Thumb1; in some cases, an sp-relative; // offset would be legal even though an fp-relative offset is not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp:59,access,accessed,59,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,2,['access'],"['accessed', 'accesses']"
Security,"// If we have a pow() library call (accesses memory) and we can't guarantee; // that the base is not an infinity, give up:; // pow(-Inf, 0.5) is optionally required to have a result of +Inf (not setting; // errno), but sqrt(-Inf) is required by various standards to set errno.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:36,access,accesses,36,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['access'],['accesses']
Security,"// If we have an aggregate, we try to promote it to memset regardless; // of opportunity for merging as it can expose optimization opportunities; // in subsequent passes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:111,expose,expose,111,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,1,['expose'],['expose']
Security,"// If we have an integer seteq/setne, turn it into a compare against zero; // by xor'ing the rhs with the lhs, which is faster than setting a; // condition register, reading it back out, and masking the correct bit. The; // normal approach here uses sub to do this instead of xor. Using xor exposes; // the result to other bit-twiddling opportunities.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:291,expose,exposes,291,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['expose'],['exposes']
Security,"// If we have an integral or boolean property (or the user has provided; // an integral or boolean return type), add the accessor -(type)isKey.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:121,access,accessor,121,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['access'],['accessor']
Security,"// If we have an object type, it's because we are in a; // pseudo-destructor-expression or a member access expression, and; // we know what type we're looking for.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:100,access,access,100,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['access'],['access']
Security,"// If we have both a builtin and system version of the file, the; // builtin version may want to inject macros into the system header, so; // force the system header to be treated as a textual header in this; // case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:97,inject,inject,97,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,1,['inject'],['inject']
Security,"// If we have declared a member function template or static data member; // template, set the access of the templated declaration as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:94,access,access,94,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['access'],['access']
Security,"// If we have dereferenceability information we know a lower bound for the; // extent as accesses for a lower offset would be valid. We need to exclude; // the ""or null"" part if null is a valid pointer. We can ignore frees, as an; // access after free would be undefined behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:89,access,accesses,89,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,2,['access'],"['access', 'accesses']"
Security,"// If we have loads being hardened and we've asked for call and ret edges to; // get a full fence-based mitigation, inject that fence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:116,inject,inject,116,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['inject'],['inject']
Security,// If we have not parsed a cpp hash line filename comment or the source; // manager changed or buffer changed (like in a nested include) then just; // print the normal diagnostic using its Filename and LineNo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:31,hash,hash,31,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,2,['hash'],['hash']
Security,"// If we have stack realignment and VLAs, we have no pointer to use to; // access the stack. If we have stack realignment, and a large call frame,; // we have no place to allocate the emergency spill slot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.cpp:75,access,access,75,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.cpp,1,['access'],['access']
Security,"// If we haven't been provided a hint, use the target type for now.; //; // TODO: Take a look at potentially removing this: This is *slightly* wrong; // as it's possible to have a GEP with a foldable target type but a memory; // access that isn't foldable. For example, this load isn't foldable on; // RISC-V:; //; // %p = getelementptr i32, ptr %base, i32 42; // %x = load <2 x i32>, ptr %p",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:229,access,access,229,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,1,['access'],['access']
Security,"// If we know required SrcValue1 and SrcValue2 have relatively large; // alignment compared to the size and offset of the access, we may be able; // to prove they do not alias. This check is conservative for now to catch; // cases created by splitting vector types, it only works when the offsets are; // multiples of the size of the data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:122,access,access,122,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['access'],['access']
Security,"// If we know that the call does not access memory, then we'll still; // know that about the inlined clone of this call site, and we don't; // need to add metadata.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:37,access,access,37,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['access'],['access']
Security,"// If we need dynamic stack realignment, do it here. Be paranoid and make; // sure if we also have VLAs, we have a base pointer for frame access.; // If aligned NEON registers were spilled, the stack has already been; // realigned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp:138,access,access,138,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,1,['access'],['access']
Security,"// If we need to check two pointers to the same underlying object; // with a non-constant difference, we shouldn't perform any pointer; // grouping with those pointers. This is because we can easily get; // into cases where the resulting check would return false, even when; // the accesses are safe.; //; // The following example shows this:; // for (i = 0; i < 1000; ++i); // a[5000 + i * m] = a[i] + a[i + 9000]; //; // Here grouping gives a check of (5000, 5000 + 1000 * m) against; // (0, 10000) which is always false. However, if m is 1, there is no; // dependence. Not grouping the checks for a[i] and a[i + 9000] allows; // us to perform an accurate check in this case.; //; // The above case requires that we have an UnknownDependence between; // accesses to the same underlying object. This cannot happen unless; // FoundNonConstantDistanceDependence is set, and therefore UseDependencies; // is also false. In this case we will use the fallback path and create; // separate checking groups for all pointers.; // If we don't have the dependency partitions, construct a new; // checking pointer group for each pointer. This is also required; // for correctness, because in this case we can have checking between; // pointers to the same underlying object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:282,access,accesses,282,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,2,['access'],['accesses']
Security,"// If we own the diagnostic client, destroy it first so that it can access the; // engine from its destructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:68,access,access,68,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,1,['access'],['access']
Security,"// If we point to before the start of the object, there are no accessible; // bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:63,access,accessible,63,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['access'],['accessible']
Security,// If we previously parsed a cpp hash file line comment then make sure the; // current Dwarf File is for the CppHashFilename if not then emit the; // Dwarf File table for it and adjust the line number for the .loc.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:33,hash,hash,33,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,2,['hash'],['hash']
Security,"// If we reach here, we know we have an instruction; // that accesses memory through a pointer operand,; // for which getPointerOperand() should give it to us.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:61,access,accesses,61,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['access'],['accesses']
Security,"// If we replaced an argument, we may now also access a global (currently; // classified as ""other"" memory). Update memory attribute to reflect this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp:47,access,access,47,interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SCCP.cpp,1,['access'],['access']
Security,"// If we required an hash check that we got it; // (the client sends the passwd if the crypt version is different)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:21,hash,hash,21,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['hash'],['hash']
Security,"// If we still might be affected by the write of the access but there are; // dominating writes in the function of the instruction; // (HasBeenWrittenTo), we can try to reason that the access is overwritten; // by them. This would have happend above if they are all in the same; // function, so we only check the inter-procedural case. Effectively, we; // want to show that there is no call after the dominting write that might; // reach the access, and when it returns reach the instruction with the; // updated value. To this end, we iterate all call sites, check if they; // might reach the instruction without going through another access; // (ExclusionSet) and at the same time might reach the access. However,; // that is all part of AAInterFnReachability.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:53,access,access,53,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,5,['access'],['access']
Security,"// If we used the V1 hash, use the default traversal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp:21,hash,hash,21,interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,1,['hash'],['hash']
Security,"// If we want to validate the selection only, we just quit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:17,validat,validate,17,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['validat'],['validate']
Security,"// If we work with data members, we have to append a hashed with MD5 text, consisting of:; // ""Type ClassName::DataMemberNameDataMemberName(arguments)"".; // We first get the type of the data member.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:53,hash,hashed,53,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['hash'],['hashed']
Security,"// If we're a single vector consumer of a double producer, set subreg bit; // based on if we're accessing the lower or upper register component",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp:96,access,accessing,96,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.cpp,1,['access'],['accessing']
Security,"// If we're building an implicit module with a context hash, the importer is; // guaranteed to have the same macros defined on the command line. Skip; // writing them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:55,hash,hash,55,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['hash'],['hash']
Security,"// If we're comparing for equality to zero, expose the fact that this is; // implemented as a ctlz/srl pair on ppc, so that the dag combiner can; // fold the new nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:44,expose,expose,44,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['expose'],['expose']
Security,"// If we're currently parsing a declaration, we may need to delay; // access control checking, because our effective context might be; // different based on what the declaration comes out as.; //; // For example, we might be parsing a declaration with a scope; // specifier, like this:; // A::private_type A::foo() { ... }; //; // Or we might be parsing something that will turn out to be a friend:; // void foo(A::private_type);; // void B::foo(A::private_type);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:70,access,access,70,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['access'],['access']
Security,"// If we're declaring or defining a tag in function prototype scope in C,; // note that this type can only be used within the function and add it to; // the list of decls to inject into the function definition scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:174,inject,inject,174,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['inject'],['inject']
Security,"// If we're directly folding the addend from an addi instruction, then:; // 1. In general, the offset on the memory access must be zero.; // 2. If the addend is a constant, then it can be combined with a; // non-zero offset, but only if the result meets the encoding; // requirements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:116,access,access,116,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['access'],['access']
Security,"// If we're filling in a static method where we used to have an; // implicit member access, rewrite to a simple decl ref.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:84,access,access,84,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['access'],['access']
Security,"// If we're implicitly loading a module, the base directory can't; // change between the build and use.; // Don't emit module relocation error if we have -fno-validate-pch",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:159,validat,validate-pch,159,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['validat'],['validate-pch']
Security,"// If we're in a CompoundStmt, we hash all possible combinations of child; // statements to find clones in those subsequences.; // We first go through every possible starting position of a subsequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:34,hash,hash,34,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,1,['hash'],['hash']
Security,"// If we're indexing into an object with a variable index for the memory; // access, but the object has only one element, we can assume that the index; // will always be zero. If we replace the GEP, return it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:77,access,access,77,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,1,['access'],['access']
Security,"// If we're not accessing anything in this constant, the result is undefined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:16,access,accessing,16,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,2,['access'],['accessing']
Security,"// If we're not atomic, just use expression accesses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:44,access,accesses,44,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['access'],['accesses']
Security,"// If we're permuting the upper 256-bits subvectors of a concatenation, then; // see if we can peek through and access the subvector directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:112,access,access,112,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['access'],['access']
Security,"// If we're scheduling a lowered CALLSEQ_END, find the corresponding; // CALLSEQ_BEGIN. Inject an artificial physical register dependence between; // these nodes, to prevent other calls from being interscheduled with them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:88,Inject,Inject,88,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['Inject'],['Inject']
Security,"// If we're supposed to ignore this macro for the purposes of modules,; // don't put it into the hash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:97,hash,hash,97,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['hash'],['hash']
Security,"// If we're using the deferred access set, then it contains only; // reads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:31,access,access,31,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['access'],['access']
Security,"// If we're validating, get the vtable symbols that should not be; // upgraded because they correspond to typeIDs outside of index-based; // WPD info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:12,validat,validating,12,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['validat'],['validating']
Security,"// If we've outside the end of the object, then we can always access; // exactly 0 bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:62,access,access,62,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,1,['access'],['access']
Security,"// If writable cannot access fMmallocDesc anymore since; // it points to the just unmapped memory region. Any further; // access to this TMapFile will cause a crash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx:22,access,access,22,io/io/src/TMapFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx,2,['access'],['access']
Security,"// If yes, we consider all types to be non-nullable unless otherwise noted.; // If this flag is not set, the pointer types are considered to have; // unknown nullability.; /// Whether the signature has been audited with respect to nullability.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/Types.h:207,audit,audited,207,interpreter/llvm-project/clang/include/clang/APINotes/Types.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/Types.h,1,['audit'],['audited']
Security,"// If/when we have access to a copy constructor (or better to a move; // constructor), this function should also perform the data move.; // For now we just information the repository.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:19,access,access,19,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['access'],['access']
Security,"// Ignore access control bits, we don't need them for redeclaration checking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:10,access,access,10,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['access'],['access']
Security,"// Ignore access control bits, we don't need them for redeclaration; // checking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:10,access,access,10,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['access'],['access']
Security,// Ignore access information; it doesn't figure into redeclaration checking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:10,access,access,10,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['access'],['access']
Security,// Ignore accesses to known-invariant or local memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:10,access,accesses,10,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,1,['access'],['accesses']
Security,"// Ignore additional defs of the same lanes in one instruction. This can; // happen because lanemasks are shared for targets with too many; // subregisters. We also use some representration tricks/hacks where we; // add super-register defs/uses, to imply that although we only access parts; // of the reg we care about the full one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:277,access,access,277,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['access'],['access']
Security,"// Ignore any callees that aren't actually functions. This could happen; // in the case of GUID hash collisions. It could also happen in theory; // for SamplePGO profiles collected on old versions of the code after; // renaming, since we synthesize edges to any inlined callees appearing; // in the profile.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:96,hash,hash,96,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,1,['hash'],['hash']
Security,// Ignore attributes that don't validate or can't apply to the; // function type. We'll diagnose the failure to apply them in; // handleFunctionTypeAttr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:32,validat,validate,32,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['validat'],['validate']
Security,// Ignore chain deps (they are validated by; // HandleMergeInputChains) and immediate uses,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:31,validat,validated,31,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,1,['validat'],['validated']
Security,// Ignore chains (they are validated by HandleMergeInputChains),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:27,validat,validated,27,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,1,['validat'],['validated']
Security,// Ignore empty type buffers. There should be no hashes or sizes in this case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/TpiStreamBuilder.cpp:49,hash,hashes,49,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/TpiStreamBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/TpiStreamBuilder.cpp,1,['hash'],['hashes']
Security,"// Ignore opportunities to avoid placing safepoints on backedges, useful for; // validation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:81,validat,validation,81,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,1,['validat'],['validation']
Security,// Ignore the SymbolName field to avoid a string compare. Comparing the; // function hash serves the same purpose.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h:85,hash,hash,85,interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h,1,['hash'],['hash']
Security,"// Immediate case, with optional leading hash:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:41,hash,hash,41,interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,1,['hash'],['hash']
Security,"// Implementation notes:; // 1) LOCK prefix creates a full read/write reordering barrier for memory; // operations issued by the current processor. As such, the location; // referenced is not relevant for the ordering properties of the instruction.; // See: Intel® 64 and IA-32 ArchitecturesSoftware Developer’s Manual,; // 8.2.3.9 Loads and Stores Are Not Reordered with Locked Instructions; // 2) Using an immediate operand appears to be the best encoding choice; // here since it doesn't require an extra register.; // 3) OR appears to be very slightly faster than ADD. (Though, the difference; // is small enough it might just be measurement noise.); // 4) When choosing offsets, there are several contributing factors:; // a) If there's no redzone, we default to TOS. (We could allocate a cache; // line aligned stack object to improve this case.); // b) To minimize our chances of introducing a false dependence, we prefer; // to offset the stack usage from TOS slightly.; // c) To minimize concerns about cross thread stack usage - in particular,; // the idiomatic MyThreadPool.run([&StackVars]() {...}) pattern which; // captures state in the TOS frame and accesses it from many threads -; // we want to use an offset such that the offset is in a distinct cache; // line from the TOS frame.; //; // For a general discussion of the tradeoffs and benchmark results, see:; // https://shipilev.net/blog/2014/on-the-fence-with-dependencies/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:1165,access,accesses,1165,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['access'],['accesses']
Security,// Implementation of StringRef hashing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringRef.cpp:31,hash,hashing,31,interpreter/llvm-project/llvm/lib/Support/StringRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringRef.cpp,1,['hash'],['hashing']
Security,// Implicit member accesses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:19,access,accesses,19,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['access'],['accesses']
Security,"// In C++14, we can't safely access any mutable state when we might be; // evaluating after an unmodeled side effect. Parameters are modeled as state; // in the caller, but aren't visible once the call returns, so they can be; // modified in a speculatively-evaluated call.; //; // FIXME: Not all local state is mutable. Allow local constant subobjects; // to be read here (but take care with 'mutable' fields).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:29,access,access,29,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['access'],['access']
Security,"// In C, find all the tag declarations from the prototype and move them; // into the function DeclContext. Remove them from the surrounding tag; // injection context of the function, which is typically but not always; // the TU.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:148,inject,injection,148,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['inject'],['injection']
Security,"// In CUDA/HIP device compilation, a lambda may capture a reference variable; // referencing a global host variable by copy. In this case the lambda should; // make a copy of the value of the global host variable. The DRE of the; // captured reference variable cannot be emitted as load from the host; // global variable as compile time constant, since the host variable is not; // accessible on device. The DRE of the captured reference variable has to be; // loaded from captures.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:382,access,accessible,382,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['access'],['accessible']
Security,"// In HLSL, unspecified class access is public rather than private.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:30,access,access,30,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['access'],['access']
Security,"// In Linux PIC model, there are 4 cases about value/label addressing:; //; // 1: Function call or Label jmp inside the module.; // 2: Data access (such as global variable, static variable) inside module.; // 3: Function call or Label jmp outside the module.; // 4: Data access (such as global variable) outside the module.; //; // Due to current llvm inline asm architecture designed to not ""recognize""; // the asm code, there are quite troubles for us to treat mem addressing; // differently for same value/adress used in different instuctions.; // For example, in pic model, call a func may in plt way or direclty; // pc-related, but lea/mov a function adress may use got.; //; // Here we try to ""recognize"" function call for the case 1 and case 3 in; // inline asm. And try to adjust the constraint for them.; //; // TODO: Due to current inline asm didn't encourage to jmp to the outsider; // label, so here we don't handle jmp function label now, but we need to; // enhance it (especilly in PIC model) if we meet meaningful requirements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:140,access,access,140,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,2,['access'],['access']
Security,// In Uops mode validate() may not be enough.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp:16,validat,validate,16,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Analysis.cpp,1,['validat'],['validate']
Security,"// In a PDB, a type index may refer to a type (TPI) or an item ID (IPI).; // In a COFF or PDB (/Z7), the type index always refer to a type (TPI).; // When creating logical elements, we must access the correct element; // table, while searching for a type index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.h:190,access,access,190,interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.h,1,['access'],['access']
Security,"// In a debug build, check that the instruction that we are modifying is; // inside the expected live range. If the instruction is not inside; // the calculated range then it means that the alloca usage moved; // outside of the lifetime markers, or that the user has a bug.; // NOTE: Alloca address calculations which happen outside the lifetime; // zone are okay, despite the fact that we don't have a good way; // for validating all of the usages of the calculation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:420,validat,validating,420,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,1,['validat'],['validating']
Security,// In a record describing a template the type should be an; // InjectedClassNameType (see Sema::CheckClassTemplate). Update the; // previously set type to the correct value here (ToDescribed is not; // available at record create).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:63,Inject,InjectedClassNameType,63,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['Inject'],['InjectedClassNameType']
Security,"// In a relocatable object, the target's section must reside in; // the same section as the call instruction or it is accessed; // through a relocation.; //; // In a non-relocatable object, the target may be in any section.; // In that case, locate the section(s) containing the target; // address and find the symbol in one of those, if possible.; //; // N.B. Except for XCOFF, we don't walk the relocations in the; // relocatable case yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp:118,access,accessed,118,interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,1,['access'],['accessed']
Security,"// In a synthesized accessor, the effective retain count is +0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:20,access,accessor,20,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,1,['access'],['accessor']
Security,"// In addition to knowing that the call does not access src in some; // unexpected manner, for example via a global, which we deduce from; // the use analysis, we also need to know that it does not sneakily; // access dest. We rely on AA to figure this out for us.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:49,access,access,49,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,2,['access'],['access']
Security,"// In both the ARM64EC varargs convention and the thunk convention,; // arguments on the stack are accessed relative to x4, not sp. In; // the thunk convention, there's an additional offset of 32 bytes; // to account for the shadow store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:99,access,accessed,99,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['access'],['accessed']
Security,"// In case somebody else access it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/THashList.cxx:25,access,access,25,core/cont/src/THashList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/THashList.cxx,1,['access'],['access']
Security,"// In compiled files, consider the first #include to be the main #include of; // the file if it is not a system #include. This ensures that the header; // doesn't have hidden dependencies; // (http://llvm.org/docs/CodingStandards.html#include-style).; //; // FIXME: Do some validation, e.g. edit distance of the base name, to fix; // cases where the first #include is unlikely to be the main header.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:274,validat,validation,274,interpreter/llvm-project/clang/lib/Format/Format.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp,1,['validat'],['validation']
Security,"// In normal ""call dllimport func"" instruction (non-inlineasm) it force; // indirect access by specifing call opcode. And usually specially print; // asm with indirect symbol (i.g: ""*"") according to opcode. Inline asm can; // not do in this way now. (In fact, this is similar with ""Data Access""; // action). So here we ignore dllimport function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:85,access,access,85,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,2,"['Access', 'access']","['Access', 'access']"
Security,// In order to ensure that we don't read a partial record at the end of; // the section we validate for a multiple of the entry size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnit.cpp:91,validat,validate,91,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnit.cpp,1,['validat'],['validate']
Security,"// In order to provide direct access to remote sqlite files through HTTP and HTTPS, this datasource provides a custom; // ""SQlite VFS module"" that uses Davix for data access. The SQlite VFS modules are roughly what TSystem is; // for ROOT -- an abstraction of the operating system interface.; //; // SQlite allows for registering custom VFS modules, which are a set of C callback functions that SQlite invokes when; // it needs to read from a file, write to a file, etc. More information is available under https://sqlite.org/vfs.html; //; // In the context of a data source, SQlite will only ever call reading functions from the VFS module, the sqlite; // files are not modified. Therefore, only a subset of the callback functions provide a non-trivial implementation.; // The custom VFS module uses a RRawFile for the byte access, thereby it can access local and remote files.; ////////////////////////////////////////////////////////////////////////////; /// SQlite VFS modules are identified by string names. The name has to be unique for the entire application.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:30,access,access,30,tree/dataframe/src/RSqliteDS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx,4,['access'],['access']
Security,"// In order to provide random access into the Descriptors array, we iterate it; // once up front to find the offsets of the individual items and store them in; // this array.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/DbiModuleList.h:30,access,access,30,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/DbiModuleList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/DbiModuleList.h,1,['access'],['access']
Security,"// In practice we'll never use this, since all SVE types are sugared; // via TypedefTypes rather than exposed directly as BuiltinTypes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:102,expose,exposed,102,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['expose'],['exposed']
Security,"// In principle we could have a member access expression that; // accesses an anonymous struct/union that's a static member of; // the base object's class. However, under the current standard,; // static data members cannot be anonymous structs or unions.; // Supporting this is as easy as building a MemberExpr here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:39,access,access,39,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,2,['access'],"['access', 'accesses']"
Security,// In principle we do not need to reserve SGPR pair used for flat_scratch if; // we know flat instructions do not access the stack anywhere in the; // program. For now assume it's needed if we have flat instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp:114,access,access,114,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,1,['access'],['access']
Security,"// In rare cases, there are trivial arithmetic ops in source operands. Sink; // this assert down to source operands so that those arithmetic ops could be; // exposed to the DAG combining.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:158,expose,exposed,158,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['expose'],['exposed']
Security,"// In rare occasion, the symbol used to initialize GlobalRes has a different; // IRName from the inspected Symbol. This can happen on macOS + iOS, when a; // symbol is referenced through its mangled name, say @""\01_symbol"" while; // the IRName is @symbol (the prefix underscore comes from MachO mangling).; // In that case, we have the same actual Symbol that can get two different; // GUID, leading to some invalid internalization. Workaround this by marking; // the GlobalRes external.; // FIXME: instead of this check, it would be desirable to compute GUIDs; // based on mangled name, but this requires an access to the Target Triple; // and would be relatively invasive on the codebase.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:609,access,access,609,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['access'],['access']
Security,"// In reference_impl.rs, we merge the new CV with existing CVs from the stack; // before pushing it. We can do that because we know more input is coming, so; // we know none of the merges are root.; //; // This setting is different. We want to feed as much input as possible to; // compress_subtree_wide(), without setting aside anything for the chunk_state.; // If the user gives us 64 KiB, we want to parallelize over all 64 KiB at once; // as a single subtree, if at all possible.; //; // This leads to two problems:; // 1) This 64 KiB input might be the only call that ever gets made to update.; // In this case, the root node of the 64 KiB subtree would be the root node; // of the whole tree, and it would need to be ROOT finalized. We can't; // compress it until we know.; // 2) This 64 KiB input might complete a larger tree, whose root node is; // similarly going to be the the root of the whole tree. For example, maybe; // we have 196 KiB (that is, 128 + 64) hashed so far. We can't compress the; // node at the root of the 256 KiB subtree until we know how to finalize it.; //; // The second problem is solved with ""lazy merging"". That is, when we're about; // to add a CV to the stack, we don't merge it with anything first, as the; // reference impl does. Instead we do merges using the *previous* CV that was; // added, which is sitting on top of the stack, and we put the new CV; // (unmerged) on top of the stack afterwards. This guarantees that we never; // merge the root node until finalize().; //; // Solving the first problem requires an additional tool,; // compress_subtree_to_parent_node(). That function always returns the top; // *two* chaining values of the subtree it's compressing. We then do lazy; // merging with each of them separately, so that the second CV will always; // remain unmerged. (That also helps us support extendable output when we're; // hashing an input all-at-once.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c:970,hash,hashed,970,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,2,['hash'],"['hashed', 'hashing']"
Security,"// In some instances of old files (v5.17 and less), some StreamerInfo for; // an abstract class where not written correctly, and add no; // data member listed. If in addition one of the data member; // was declared using a typedef _and_ the current class definition; // uses a different typedef, we are unable to recalculate the; // checksum as it was, because the information is missing from; // the StreamerInfo, and for the same reason CompareContent can; // not know whether this is okay or not ...; //; // Since this is such an unlikely scenario, let's complain; // about it anyway (The class layout *may* have changed, we; // don't know).; // if (this has only base classes) {; // match = kTRUE;; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:333,checksum,checksum,333,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,1,['checksum'],['checksum']
Security,"// In some instances of old files (v5.17 and less), some StreamerInfo for; // an abstract class where not written correctly, and add no; // data member listed. If in addition one of the data member; // was declared using a typedef _and_ the current class definition; // uses a different typedef, we are unable to recalculate the; // checksum as it was, because the information is missing from; // the StreamerInfo, and for the same reason CompareContent can; // not know whether this is okay or not ...; //; // Since this is such an unlikely scenario, let's complain; // about it anyway (The class layout *may* have changed, we; // don't know).; // if (this has only base classes) {; // warn = kFALSE;; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:333,checksum,checksum,333,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,1,['checksum'],['checksum']
Security,"// In some rare cases, call instruction could be changed after being pushed; // into inline candidate queue, this is because earlier inlining may expose; // constant propagation which can change indirect call to direct call. When; // this happens, we may fail to find matching function samples for the; // candidate later, even if a match was found when the candidate was enqueued.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:146,expose,expose,146,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['expose'],['expose']
Security,"// In some rare cases, there might be records with forward references in the; // stream. Several passes might be needed to fully hash each record in the; // Type stream. However this occurs on very small OBJs generated by MASM,; // with a dozen records at most. Therefore this codepath isn't; // time-critical, as it isn't taken in 99% of cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeHashing.h:129,hash,hash,129,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeHashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeHashing.h,1,['hash'],['hash']
Security,"// In the case of type streams which we don't know the number of records of,; // it's possible to search for a type index triggering a full scan, but then; // later additional records are added since we didn't know how many there; // would be until we did a full visitation, then you try to access the new; // type triggering another full scan. To avoid this, we assume that if the; // database has some records, this must be what's going on. We can also; // assume that this index must be larger than the largest type index we've; // visited, so we start from there and scan forward.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/LazyRandomTypeCollection.cpp:291,access,access,291,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/LazyRandomTypeCollection.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/LazyRandomTypeCollection.cpp,1,['access'],['access']
Security,"// In the case where the read-in TStreamerInfo does not; // match in the 'current' in memory TStreamerInfo for; // a non foreign class (we can not get here if this is; // a foreign class so we do not need to test it),; // we need to add this one more test since the CINT behaviour; // with enums changed over time, so verify the checksum ignoring; // members of type enum. We also used to not count the //[xyz] comment; // in the checksum, so test for that too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:329,checksum,checksum,329,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,4,['checksum'],['checksum']
Security,"// In the cases below we havn't found a way to produce an artifact that will; // result in a stable hash, in most cases because they are pointers. We want; // stable hashes because we want the hash to be the same run to run.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:100,hash,hash,100,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,3,['hash'],"['hash', 'hashes']"
Security,"// In the original implementation of this library, the evaluation was done; // multi-threaded in implicit multi-threading was enabled in ROOT with; // ROOT::EnableImplicitMT().; //; // However, this multithreaded mode was not carefully validated and is; // therefore not production ready. One would first have to study the; // overhead for different numbers of cores, number of events, and model; // complexity. The, we should only consider implicit multithreading here if; // there is no performance penalty for any scenario, to not surprise the; // users with unexpected slowdows!; //; // Note that the priority of investigating this is not high, because RooFit; // R & D efforts currently go in the direction of parallelization at the; // level of the gradient components, or achieving single-threaded speedup; // with automatic differentiation. Furthermore, the single-threaded; // performance of the new CPU evaluation backend with the RooBatchCompute; // library, is generally much faster than the legacy evaluation backend; // already, even if the latter uses multi-threading.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/RooBatchCompute.cxx:236,validat,validated,236,roofit/batchcompute/src/RooBatchCompute.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/RooBatchCompute.cxx,1,['validat'],['validated']
Security,"// In the presence of variable sized objects or funclets, if the fixed stack; // size is large enough that referencing from the FP won't result in things; // being in range relatively often, we can use a base pointer to allow access; // from the other direction like the SP normally works.; //; // Furthermore, if both variable sized objects are present, and the; // stack needs to be dynamically re-aligned, the base pointer is the only; // reliable way to reference the locals.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp:226,access,access,226,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp,1,['access'],['access']
Security,"// In the reference implementation, this uses; // HASH Hasher<ULONG*, USHORT*>::hashPbCb(PB pb, size_t cb, ULONG ulMod).; // Here, the type HASH is a typedef of unsigned short.; // ** It is not a bug that we truncate the result of hashStringV1, in fact; // it is a bug if we do not! **; // See NMTNI::hash() in the reference implementation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/NamedStreamMap.cpp:50,HASH,HASH,50,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/NamedStreamMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/NamedStreamMap.cpp,5,"['HASH', 'Hash', 'hash']","['HASH', 'Hasher', 'hash', 'hashPbCb']"
Security,"// In theory we might now need a write hazard, but actually it's; // unnecessary because there's no local-accessing code between; // the try's write hazard and here.; //Hazards.emitWriteHazard();; // Extract the new exception and save it to the; // propagating-exception slot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:106,access,accessing,106,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['access'],['accessing']
Security,"// In this analysis two array references are considered to exhibit temporal; // reuse if they access either the same memory location, or a memory location; // with distance smaller than a configurable threshold.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:94,access,access,94,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,1,['access'],['access']
Security,"// In this version, the frontend PGO stable hash algorithm defaults to V2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h:44,hash,hash,44,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,1,['hash'],['hash']
Security,"// In this version, the frontend PGO stable hash algorithm got fixed and; // may produce hashes different from Version5.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h:44,hash,hash,44,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,2,['hash'],"['hash', 'hashes']"
Security,"// In threadgroup split mode the waves of a work-group can be executing on; // different CUs. Therefore need to wait for global or GDS memory operations; // to complete to ensure they are visible to waves in the other CUs.; // Otherwise in non-threadgroup split mode all waves of a work-group are on; // the same CU, so no need to wait for global memory as all waves in the; // work-group access the same the L1, nor wait for GDS as access are ordered; // on a CU.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp:389,access,access,389,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,2,['access'],['access']
Security,"// In unevaluated contexts, an expression supposed to be a member access; // might reference a member in an unrelated class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:66,access,access,66,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['access'],['access']
Security,"// Include files; /**; \defgroup MatRep SMatrix Storage Representation; \ingroup SMatrixGroup. Classes MatRepStd and MatRepSym for generic and symmetric matrix; data storage and manipulation. Define data storage and access, plus; operators =, +=, -=, ==. \author Juan Palacios; \date 2006-01-15; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/MatrixRepresentationsStatic.h:216,access,access,216,math/smatrix/inc/Math/MatrixRepresentationsStatic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/MatrixRepresentationsStatic.h,1,['access'],['access']
Security,// Include index in hash to make sure same value as different; // alternatives don't collide.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfoVariant.h:20,hash,hash,20,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfoVariant.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfoVariant.h,1,['hash'],['hash']
Security,// Include the DWO file name in the hash if there's more than one CU.; // This handles ThinLTO's situation where imported CUs may very easily be; // duplicate with the same CU partially imported into another ThinLTO unit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:36,hash,hash,36,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,1,['hash'],['hash']
Security,// Include the hash for all type identifiers used by this module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:15,hash,hash,15,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['hash'],['hash']
Security,"// Include the hash for every module we import functions from. The set of; // imported symbols for each module may affect code generation and is; // sensitive to link order, so include that as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:15,hash,hash,15,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['hash'],['hash']
Security,// Include the hash for the current module,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:15,hash,hash,15,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['hash'],['hash']
Security,"// Include the hash for the linkage type to reflect internalization and weak; // resolution, and collect any used type identifier resolutions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:15,hash,hash,15,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['hash'],['hash']
Security,// Include the hash for the resolved ODR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:15,hash,hash,15,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['hash'],['hash']
Security,// Incomplete types are not valid base access types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp:39,access,access,39,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp,1,['access'],['access']
Security,// Increase the alignment of LDS globals if necessary to maximise the chance; // that we can use aligned LDS instructions to access them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:125,access,access,125,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['access'],['access']
Security,// Indent preprocessor directives after the hash if required.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:44,hash,hash,44,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,1,['hash'],['hash']
Security,// Index of the first symbol in the dynamic symbol table; // included in the hash table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjectYAML/ELFYAML.h:77,hash,hash,77,interpreter/llvm-project/llvm/include/llvm/ObjectYAML/ELFYAML.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjectYAML/ELFYAML.h,1,['hash'],['hash']
Security,// Indexed and unordered accessors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:25,access,accessors,25,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['access'],['accessors']
Security,"// Indicate that we are performing a member access, and the cv-qualifiers; // for the base object type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:44,access,access,44,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['access'],['access']
Security,// Indicate that we want cross-DSO control flow integrity checks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:48,integrity,integrity,48,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['integrity'],['integrity']
Security,// Indicate whether to validate types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h:23,validat,validate,23,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,1,['validat'],['validate']
Security,// Indirect access memory instruction count,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.h:12,access,access,12,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.h,1,['access'],['access']
Security,// Indirect accessors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/CGFunctionInfo.h:12,access,accessors,12,interpreter/llvm-project/clang/include/clang/CodeGen/CGFunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/CGFunctionInfo.h,1,['access'],['accessors']
Security,// Indirect operand accesses access memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:20,access,accesses,20,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,2,['access'],"['access', 'accesses']"
Security,"// Indirect tail calls cannot be optimized for Thumb1 if the args; // to the call take up r0-r3. The reason is that there are no legal registers; // left to hold the pointer to the function to be called.; // Similarly, if the function uses return address sign and authentication,; // r12 is needed to hold the PAC and is not available to hold the callee; // address.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:264,authenticat,authentication,264,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['authenticat'],['authentication']
Security,"// Infer as many types as possible. Don't worry about it if we don't infer; // all of them, some may depend on the inputs of the pattern. Also, don't; // validate type sets; validation may cause spurious failures e.g. if a; // fragment needs floating-point types but the current target does not have; // any (this is only an error if that fragment is ever used!).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:154,validat,validate,154,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,2,['validat'],"['validate', 'validation']"
Security,// Infer the access attributes given the new nocapture one,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:13,access,access,13,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,1,['access'],['access']
Security,// Information about the addressing mode for a memory access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:54,access,access,54,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['access'],['access']
Security,// Information on REP string instructions that require manual mitigation can; // be found here:; // https://software.intel.com/security-software-guidance/insights/deep-dive-load-value-injection#specialinstructions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:127,secur,security-software-guidance,127,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,2,"['inject', 'secur']","['injection', 'security-software-guidance']"
Security,// Information on control-flow instructions that require manual mitigation can; // be found here:; // https://software.intel.com/security-software-guidance/insights/deep-dive-load-value-injection#specialinstructions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:129,secur,security-software-guidance,129,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,2,"['inject', 'secur']","['injection', 'security-software-guidance']"
Security,// Inherit access appropriately.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,access,access,11,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['access'],['access']
Security,"// Init Session (get protocol, run authentication, ...); // type of authentication:; // 0 (new), 1 (existing), 2 (updated offset)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/DaemonUtils.cxx:35,authenticat,authentication,35,net/rpdutils/src/DaemonUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/DaemonUtils.cxx,2,['authenticat'],['authentication']
Security,"// Init authentication",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TRootAuth.cxx:8,authenticat,authentication,8,net/auth/src/TRootAuth.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TRootAuth.cxx,1,['authenticat'],['authentication']
Security,"// Initial construction must not access the cache, since it must be done; // atomically.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/SymbolCache.h:33,access,access,33,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/SymbolCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/SymbolCache.h,1,['access'],['access']
Security,// Initialize SanitizerSections.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SanitizerSpecialCaseList.h:14,Sanitiz,SanitizerSections,14,interpreter/llvm-project/clang/include/clang/Basic/SanitizerSpecialCaseList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SanitizerSpecialCaseList.h,1,['Sanitiz'],['SanitizerSections']
Security,"// Initialize the escape sequence hash table",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx:34,hash,hash,34,gui/guihtml/src/TGHtmlParse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx,2,['hash'],['hash']
Security,"// Initialize the slot mapping.; // Because by this point we've parsed and validated everything, we can ""steal""; // the mapping from LLParser as it doesn't need it anymore.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:75,validat,validated,75,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,1,['validat'],['validated']
Security,"// Inject - empty slots will be 0, 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp:3,Inject,Inject,3,interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp,1,['Inject'],['Inject']
Security,"// Inject a number of symbols that may be in libc_nonshared.a where they are; // not found automatically. Before DefinitionGenerators in ORCv2, this used; // to be done by RTDyldMemoryManager::getSymbolAddressInProcess See also the; // upstream issue https://github.com/llvm/llvm-project/issues/61289.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp:3,Inject,Inject,3,interpreter/cling/lib/Interpreter/IncrementalJIT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp,1,['Inject'],['Inject']
Security,"// Inject a special marker:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ForwardDeclPrinter.cpp:3,Inject,Inject,3,interpreter/cling/lib/Interpreter/ForwardDeclPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ForwardDeclPrinter.cpp,1,['Inject'],['Inject']
Security,"// Inject all lines of FileName.; // Intentionally ignore fMaxDepth",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/History.cpp:3,Inject,Inject,3,core/textinput/src/textinput/History.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/History.cpp,1,['Inject'],['Inject']
Security,// Inject byval arguments initialization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Inject,Inject,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['Inject'],['Inject']
Security,// Inject libfuzzer dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:3,Inject,Inject,3,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,1,['Inject'],['Inject']
Security,// Inject loads into all of the pred blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:3,Inject,Inject,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['Inject'],['Inject']
Security,// Inject stylesheet if we haven't done that yet,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,Inject,Inject,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['Inject'],['Inject']
Security,// Inject template fragments before class fragments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/ExtractAPIVisitor.h:3,Inject,Inject,3,interpreter/llvm-project/clang/include/clang/ExtractAPI/ExtractAPIVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/ExtractAPIVisitor.h,1,['Inject'],['Inject']
Security,// Inject template fragments before var fragments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/ExtractAPIVisitor.h:3,Inject,Inject,3,interpreter/llvm-project/clang/include/clang/ExtractAPI/ExtractAPIVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/ExtractAPIVisitor.h,1,['Inject'],['Inject']
Security,// Inject the VBPointer at the injection site.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:3,Inject,Inject,3,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,2,"['Inject', 'inject']","['Inject', 'injection']"
Security,// Inject the ending and a new line,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp:3,Inject,Inject,3,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerManager.cpp,1,['Inject'],['Inject']
Security,// Inject the members of the anonymous struct into the current; // context and into the identifier resolver chain for name lookup; // purposes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Inject,Inject,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Inject'],['Inject']
Security,// Inject the members of the anonymous struct/union into the owning; // context and into the identifier resolver chain for name lookup; // purposes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Inject,Inject,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Inject'],['Inject']
Security,// Injected class names are not considered nested records.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:3,Inject,Injected,3,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['Inject'],['Injected']
Security,"// Inline access to Field() method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoGlobalMagField.h:10,access,access,10,geom/geom/inc/TGeoGlobalMagField.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoGlobalMagField.h,1,['access'],['access']
Security,// InlineSavingsMultiplier overrides per TTI multipliers iff it is; // specified explicitly in command line options. This option is exposed; // for tuning and testing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:132,expose,exposed,132,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['expose'],['exposed']
Security,// InlineSavingsProfitableMultiplier overrides per TTI multipliers iff it is; // specified explicitly in command line options. This option is exposed; // for tuning and testing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:142,expose,exposed,142,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['expose'],['exposed']
Security,"// Inner loop processes consecutive accesses (x, x+1... in the example)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:36,access,accesses,36,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,1,['access'],['accesses']
Security,// Insert or remove empty line after access specifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:37,access,access,37,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,1,['access'],['access']
Security,// Insert or remove empty line before access specifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:38,access,access,38,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,1,['access'],['access']
Security,// Insert the Store and a hash number of the store address and the stored; // value in VNtoStores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:26,hash,hash,26,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['hash'],['hash']
Security,// Insert the key (func hash) and value (memprof record).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp:24,hash,hash,24,interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,1,['hash'],['hash']
Security,"// Insert the node into the new bucket, after recomputing the hash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FoldingSet.cpp:62,hash,hash,62,interpreter/llvm-project/llvm/lib/Support/FoldingSet.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FoldingSet.cpp,1,['hash'],['hash']
Security,// Insertation was successful -- CmdLineOption's constructor will validate; // whether values received from plugins or TableGen files are correct.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp:66,validat,validate,66,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/CheckerRegistry.cpp,1,['validat'],['validate']
Security,"// Inserts Constant Islands. Block sizes cannot be increased after this point,; // as this may push the branch ranges and load offsets of accessing constant; // pools out of range..",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp:138,access,accessing,138,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp,1,['access'],['accessing']
Security,"// Inspect the initializer of the variable declaration which is; // being referenced prior to its initialization. We emit; // specialized diagnostics for self-initialization, and we; // specifically avoid warning about self references which take the; // form of:; //; // int x = x;; //; // This is used to indicate to GCC that 'x' is intentionally left; // uninitialized. Proven code paths which access 'x' in; // an uninitialized state after this will still warn.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:396,access,access,396,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,1,['access'],['access']
Security,"// Inspect the last argument of the nontemporal builtin. This should always; // be a pointer type, from which we imply the type of the memory access.; // Because it is a pointer type, we don't have to worry about any implicit; // casts here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:142,access,access,142,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['access'],['access']
Security,"// Install argument in static data member to be accessed below through static CINT interface functions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx:48,access,accessed,48,roofit/roofitcore/src/RooFactoryWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx,1,['access'],['accessed']
Security,"// Instead of explictly marking kernels that access dynamic variables; // using special case metadata, annotate with min-lds == max-lds, i.e.; // that there is no more space available for allocating more static; // LDS variables. That is the right condition to prevent allocating; // more variables which would collide with the addresses assigned to; // dynamic variables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:45,access,access,45,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['access'],['access']
Security,"// Instead of using barriers, atomic accesses on these subtargets use; // libcalls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:37,access,accesses,37,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['access'],['accesses']
Security,"// Instruction ranges, specifying where IV is accessible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:46,access,accessible,46,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,2,['access'],['accessible']
Security,"// Instrument a 1-, 2-, 4-, 8-, or 16- byte access with one check; // if the data is properly aligned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:44,access,access,44,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['access'],['access']
Security,// Instrument accesses from different address spaces only for AMDGPU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:14,access,accesses,14,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['access'],['accesses']
Security,// Instrument atomic memory accesses in any case (they can be used to; // implement synchronization).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:28,access,accesses,28,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,1,['access'],['accesses']
Security,// Instrument function entry/exit points if there were instrumented accesses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:68,access,accesses,68,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,1,['access'],['accesses']
Security,"// Instrument unusual size or unusual alignment.; // We can not do it with a single check, so we do 1-byte check for the first; // and the last bytes. We call __asan_report_*_n(addr, real_size) to be able; // to report the actual access size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:230,access,access,230,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['access'],['access']
Security,"// Instrumenting some of the accesses may be proven redundant.; // Currently handled:; // - read-before-write (within same BB, no calls between); // - not captured variables; //; // We do not handle some of the patterns that should not survive; // after the classic compiler optimizations.; // E.g. two reads from the same temp should be eliminated by CSE,; // two writes should be eliminated by DSE, etc.; //; // 'Local' is a vector of insns within the same BB (no calls between).; // 'All' is a vector of insns that will be instrumented.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:29,access,accesses,29,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,1,['access'],['accesses']
Security,"// Integrity check in case this array changes its size at some point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:3,Integrity,Integrity,3,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['Integrity'],['Integrity']
Security,"// Intentionally computes the hash on a subset of the operands for; // performance reason. The subset has to be significant enough to avoid; // collision ""most of the time"". There is no correctness issue in case of; // collision because of the full check above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:30,hash,hash,30,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,4,['hash'],['hash']
Security,// Interleave-store-group with gaps is implemented using masked wide store.; // Remove interleaved store groups with gaps if; // masked-interleaved-accesses are not enabled by the target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:148,access,accesses,148,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['access'],['accesses']
Security,"// Internal data accessors - for GL API",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h:17,access,accessors,17,graf3d/gl/inc/TGLUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h,2,['access'],['accessors']
Security,// Interpret an access group as a list containing itself.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:16,access,access,16,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['access'],['access']
Security,"// Intrinsics, like any other synchronizing function, can make effects; // of other threads visible. Without nosync we know nothing really.; // Similarly, if `nocallback` is missing the function, or intrinsic,; // can call into the module arbitrarily. If both are set the function; // has an effect but will not interact with accesses of internal; // globals inside the module. We are conservative here for optnone; // functions, might not be necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:326,access,accesses,326,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,1,['access'],['accesses']
Security,// Irregular split. Provide direct access to all elements for artifact; // combiner using unmerge to elements. Then build vectors with NumElts; // elements. Remaining element(s) will be (used to build vector) Leftover.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp:35,access,access,35,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Utils.cpp,1,['access'],['access']
Security,"// Irrespective of whether we are compiling for a fragile or non-fragile ABI,; // we emit a symbol containing the offset for each ivar in the class. This; // allows code compiled for the non-Fragile ABI to inherit from code compiled; // for the legacy ABI, without causing problems. The converse is also; // possible, but causes all ivar accesses to be fragile.; // Offset pointer for getting at the correct field in the ivar list when; // setting up the alias. These are: The base address for the global, the; // ivar array (second field), the ivar in this list (set for each ivar), and; // the offset (third field in ivar structure)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:338,access,accesses,338,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['access'],['accesses']
Security,"// Is a FLAT encoded instruction which accesses a specific segment,; // i.e. global_* or scratch_*.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.h:39,access,accesses,39,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.h,1,['access'],['accesses']
Security,"// Is the access size is longer than the L1 cache line, skip the check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:10,access,access,10,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['access'],['access']
Security,"// Is the entity accessible when named in the deriving class, as; // modified by the base specifier?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:17,access,accessible,17,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['access'],['accessible']
Security,"// Is this a stack pointer-relative access? We could in general try to; // use ""is this the same register and is it unchanged?"", but the; // memory operand tracking is highly likely to have already found that.; // What we're after here is bank conflicts between different objects in; // the stack frame.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMHazardRecognizer.cpp:36,access,access,36,interpreter/llvm-project/llvm/lib/Target/ARM/ARMHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMHazardRecognizer.cpp,1,['access'],['access']
Security,// Is this a virtual file (injected)?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/RawTypes.h:27,inject,injected,27,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/RawTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/RawTypes.h,1,['inject'],['injected']
Security,"// It doesn't make sense to access one global value using another globals; // values address, so we can assume that there is no aliasing in case of; // two different globals (unless we have symbols that may indirectly point; // to each other).; // FIXME: This is perhaps a bit too defensive. We could try to follow the; // chain with aliasee information for GlobalAlias variables to find out if; // we indirect symbols may alias or not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGAddressAnalysis.cpp:28,access,access,28,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGAddressAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGAddressAnalysis.cpp,1,['access'],['access']
Security,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:273,access,access,273,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,2,['access'],['access']
Security,"// It is perfectly fine to refer to an 'unavailable' Objective-C method; // when it is referenced from within the @implementation itself. In this; // context, we interpret unavailable as a form of access control.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:197,access,access,197,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,1,['access'],['access']
Security,"// It is possible that the default destination is the destination of; // some cases. We cannot perform difference for those cases.; // We know Condition != CaseValue in BBTo. In some cases we can use; // this to infer Val == f(Condition) is != f(CaseValue). For now, we; // only do this when f is identity (i.e. Val == Condition), but we; // should be able to do this for any injective f.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:376,inject,injective,376,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,1,['inject'],['injective']
Security,"// It is possible that the type of the base expression after; // IgnoreParenCasts is incomplete, even though the type of the base; // expression before IgnoreParenCasts is complete (see PR39746 for an; // example). In this case we have no information about whether the array; // access exceeds the array bounds. However we can still diagnose an array; // access which precedes the array bounds.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:279,access,access,279,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,2,['access'],['access']
Security,"// It is possible to have a non-standard definition of memset. Validate; // we have enough arguments, and if not, abort further checking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:63,Validat,Validate,63,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['Validat'],['Validate']
Security,// It must be either an access scope itself...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:24,access,access,24,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['access'],['access']
Security,// It must be in the form of X-Y.; // Validate it and then interpret the range.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/GlobPattern.cpp:38,Validat,Validate,38,interpreter/llvm-project/llvm/lib/Support/GlobPattern.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/GlobPattern.cpp,1,['Validat'],['Validate']
Security,"// It's not vectorizable if the distance is smaller than the minimum distance; // needed for a vectroized/unrolled version. Vectorizing one iteration in; // front needs TypeByteSize * Stride. Vectorizing the last iteration needs; // TypeByteSize (No need to plus the last gap distance).; //; // E.g. Assume one char is 1 byte in memory and one int is 4 bytes.; // foo(int *A) {; // int *B = (int *)((char *)A + 14);; // for (i = 0 ; i < 1024 ; i += 2); // B[i] = A[i] + 1;; // }; //; // Two accesses in memory (stride is 2):; // | A[0] | | A[2] | | A[4] | | A[6] | |; // | B[0] | | B[2] | | B[4] |; //; // Distance needs for vectorizing iterations except the last iteration:; // 4 * 2 * (MinNumIter - 1). Distance needs for the last iteration: 4.; // So the minimum distance needed is: 4 * 2 * (MinNumIter - 1) + 4.; //; // If MinNumIter is 2, it is vectorizable as the minimum distance needed is; // 12, which is less than distance.; //; // If MinNumIter is 4 (Say if a user forces the vectorization factor to be 4),; // the minimum distance needed is 28, which is greater than distance. It is; // not safe to do vectorization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:491,access,accesses,491,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['access'],['accesses']
Security,"// It's possible for checksums and strings to even appear in different debug$S; // sections, so we have to make this a stateful function that can build up; // the strings and checksums field over multiple iterations.; // File Checksums require the string table, but may become before it, so we; // have to scan for strings first, then scan for checksums again from the; // beginning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/CodeViewYAMLDebugSections.cpp:21,checksum,checksums,21,interpreter/llvm-project/llvm/lib/ObjectYAML/CodeViewYAMLDebugSections.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/CodeViewYAMLDebugSections.cpp,4,"['Checksum', 'checksum']","['Checksums', 'checksums']"
Security,"// It's safe to go with the first one we find, because CodeGenInstAlias; // validates that all operands with the same name have the same record.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp:76,validat,validates,76,interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,1,['validat'],['validates']
Security,"// It's theoretically possible for a thing to hash to zero. In that case,; // we will just compute the hash a few extra times, which is no worse that; // we did before, which was to compute it always.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVNExpression.h:46,hash,hash,46,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVNExpression.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVNExpression.h,2,['hash'],['hash']
Security,// Iterate all .debug$S sections looking for the checksums and string table.; // Exit as soon as both sections are found.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/obj2yaml/coff2yaml.cpp:49,checksum,checksums,49,interpreter/llvm-project/llvm/tools/obj2yaml/coff2yaml.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/obj2yaml/coff2yaml.cpp,1,['checksum'],['checksums']
Security,"// Iterate over all new instructions in the map; for all memory-access; // instructions, add the alias scope metadata.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:64,access,access,64,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['access'],['access']
Security,"// Iterate over blocks and initialize BlockInfoVec entries, count; // instructions to size the InstInfo hash table.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:104,hash,hash,104,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,1,['hash'],['hash']
Security,// Iteration over A accesses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:20,access,accesses,20,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['access'],['accesses']
Security,// Iteration over B accesses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:20,access,accesses,20,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['access'],['accesses']
Security,"// Iterator access to field members. The field iterator only visits; // the non-static data members of this class, ignoring any static; // data members, functions, constructors, destructors, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:12,access,access,12,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['access'],['access']
Security,// Iterator access to formal parameters and their types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h:12,access,access,12,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h,1,['access'],['access']
Security,// Iterator access to formal parameters.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:12,access,access,12,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,3,['access'],['access']
Security,// Iterator access to instance/class methods.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:12,access,access,12,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,1,['access'],['access']
Security,// Iterator access to instance/class properties.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:12,access,access,12,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,1,['access'],['access']
Security,// Iterator access to parameter types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:12,access,access,12,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,1,['access'],['access']
Security,// Iterator access to properties.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:12,access,access,12,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,1,['access'],['access']
Security,// Iterator access to the designators.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:12,access,access,12,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['access'],['access']
Security,// Iterator access to the elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h:12,access,access,12,interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h,1,['access'],['access']
Security,// Jobs and Actions look very different depending on whether the Clang tool; // injected -fsyntax-only or not. Try to handle both cases here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp:80,inject,injected,80,interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Tooling.cpp,1,['inject'],['injected']
Security,// JumpTable and BlockAddress are accessed as got-indirect.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:34,access,accessed,34,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['access'],['accessed']
Security,// Just drop invalid accessors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:21,access,accessors,21,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['access'],['accessors']
Security,"// Keep only the highest cycle number for each key for mergeable objects. They are stored; // in the (hash) list consecutively and in decreasing order of cycles, so we can continue; // until the name changes. We flag the case here and we act consequently later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileMerger.cxx:102,hash,hash,102,io/io/src/TFileMerger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileMerger.cxx,1,['hash'],['hash']
Security,// Keep processing accessors until we run out.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:19,access,accessors,19,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['access'],['accessors']
Security,// Keep this set to the latest hash version.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp:31,hash,hash,31,interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,1,['hash'],['hash']
Security,"// Keep track if we have a memory access before an SP pre-increment, in this; // case we need to validate later that the update amount respects the red; // zone.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp:34,access,access,34,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,2,"['access', 'validat']","['access', 'validate']"
Security,"// Keep track of whether any or all files have an MD5 checksum.; // If any files have embedded source, they all must.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:54,checksum,checksum,54,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,1,['checksum'],['checksum']
Security,// Keep track of which additional locations are accessed if the SCC; // turns out to access argmem.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:48,access,accessed,48,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,2,['access'],"['access', 'accessed']"
Security,// Keep track of which types of access we see,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:32,access,access,32,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['access'],['access']
Security,"// LEA doesn't actually access memory, and its arithmetic is constant time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:24,access,access,24,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['access'],['access']
Security,// LLVM Dwarf parser is not thread-safe and we need to parse all DWARF up; // front before we start accessing any DIEs since there might be; // cross compile unit references in the DWARF. If we don't do this we can; // end up crashing.; // We need to call getAbbreviations sequentially first so that getUnitDIE(); // only works with its local data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp:100,access,accessing,100,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp,1,['access'],['accessing']
Security,"// LLVM register Num, which has kind Kind. In some ways it might be; // easier for this class to have a register bank (general, floating-point; // or access) and a raw register number (0-15). This would postpone the; // interpretation of the operand to the add*() methods and avoid the need; // for context-dependent parsing. However, we do things the current way; // because of the virtual getReg() method, which needs to distinguish; // between (say) %r0 used as a single register and %r0 used as a pair.; // Context-dependent parsing can also give us slightly better error; // messages when invalid pairs like %r1 are used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:150,access,access,150,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,1,['access'],['access']
Security,// LLVMs equivalent of a hash function,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp:25,hash,hash,25,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,1,['hash'],['hash']
Security,"// LM: use hash tables for larger lists; // if (_serverList.GetSize() > 999 && _serverList.getHashTableSize() == 0) _serverList.setHashTableSize(1000);; // if (server._clientList.GetSize() > 999 && server._clientList.getHashTableSize() == 0) server._clientList.setHashTableSize(1000);; // if (server._clientListValue.GetSize() > 999 && server._clientListValue.getHashTableSize() == 0) server._clientListValue.setHashTableSize(1000);; // Add server link to given server",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:11,hash,hash,11,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,1,['hash'],['hash']
Security,"// LR authentication is after the CFI instructions, below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:6,authenticat,authentication,6,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['authenticat'],['authentication']
Security,"// Large GlobalValues use GOTOFF, otherwise use RIP-rel access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86Subtarget.cpp:56,access,access,56,interpreter/llvm-project/llvm/lib/Target/X86/X86Subtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86Subtarget.cpp,1,['access'],['access']
Security,// Last memory access info,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.cpp:15,access,access,15,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.cpp,1,['access'],['access']
Security,// Layout of hash value:; // 0 8 16 24 32 40; // | Log2LMUL + 3 | BT | Proto.PT | Proto.TM | Proto.VTM |,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp:13,hash,hash,13,interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Support/RISCVVIntrinsicUtils.cpp,1,['hash'],['hash']
Security,// Lazily initialize RawText using the accessor before using it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RawCommentList.cpp:39,access,accessor,39,interpreter/llvm-project/clang/lib/AST/RawCommentList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RawCommentList.cpp,2,['access'],['accessor']
Security,"// Lazy computing of hash value, write back to the table to cache it. Only; // compute the context's hash value if it is being referenced for the first; // time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp:21,hash,hash,21,interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp,2,['hash'],['hash']
Security,"// LazyRandomTypeCollection doesn't appear to expose the number of records, so; // just iterate up front to find out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-pdbutil/TypeReferenceTracker.cpp:46,expose,expose,46,interpreter/llvm-project/llvm/tools/llvm-pdbutil/TypeReferenceTracker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-pdbutil/TypeReferenceTracker.cpp,1,['expose'],['expose']
Security,// Leaf accessors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:8,access,accessors,8,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,1,['access'],['accessors']
Security,"// Leave lifetime markers for the static alloca's, scoping them to the; // function we just inlined.; // We need to insert lifetime intrinsics even at O0 to avoid invalid; // access caused by multithreaded coroutines. The check; // `Caller->isPresplitCoroutine()` would affect AlwaysInliner at O0 only.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:175,access,access,175,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['access'],['access']
Security,"// Legacy access key",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TS3WebFile.cxx:10,access,access,10,net/net/src/TS3WebFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TS3WebFile.cxx,1,['access'],['access']
Security,"// Legalize MIMG/VIMAGE/VSAMPLE and MUBUF/MTBUF for shaders.; //; // Shaders only generate MUBUF/MTBUF instructions via intrinsics or via; // scratch memory access. In both cases, the legalization never involves; // conversion to the addr64 form.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:157,access,access,157,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['access'],['access']
Security,"// Length of the password buffer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:17,password,password,17,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['password'],['password']
Security,// Let BackendConsumer access LinkModule.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/CodeGenAction.h:23,access,access,23,interpreter/llvm-project/clang/include/clang/CodeGen/CodeGenAction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/CodeGenAction.h,1,['access'],['access']
Security,// Let MCSectionMachO validate this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:22,validat,validate,22,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['validat'],['validate']
Security,// Let further validation happen when compress()/uncompress() functions are; // invoked.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp:15,validat,validation,15,interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp,1,['validat'],['validation']
Security,// Let the target decide if memory accesses cannot possibly overlap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:35,access,accesses,35,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,1,['access'],['accesses']
Security,"// Let's inject it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp:9,inject,inject,9,interpreter/cling/lib/Interpreter/IncrementalJIT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp,1,['inject'],['inject']
Security,"// Let's now attack regular properties",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:13,attack,attack,13,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['attack'],['attack']
Security,"// Let's pretend a 0 shift right has been performed.; // The resulting code will be at least as good as the original one; // plus it may expose more opportunities for bitfield insert pattern.; // FIXME: Currently we limit this to the bigger pattern, because; // some optimizations expect AND and not UBFM.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:137,expose,expose,137,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['expose'],['expose']
Security,// Lexical DeclContext and Semantic DeclContext; // is always the same for the accessSpec.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:79,access,accessSpec,79,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['access'],['accessSpec']
Security,"// Lexically forward.; //; // FIXME: If we only have loop-independent forward dependences (e.g. a; // read and write of A[i]), LAA will locally deem the dependence ""safe""; // without querying the MemoryDepChecker. Therefore we can miss; // enumerating loop-independent forward dependences in; // getDependences. Note that as soon as there are different; // indices used to access the same array, the MemoryDepChecker *is*; // queried and the dependence list is complete.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:373,access,access,373,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['access'],['access']
Security,// Likewise for calls on an object accessed by a (non-reference) pointer to; // member access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:35,access,accessed,35,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,2,['access'],"['access', 'accessed']"
Security,// Limit this to being an access modifier that follows.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:26,access,access,26,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,1,['access'],['access']
Security,"// Linearizing the control flow by placing TRY / END_TRY markers can create; // mismatches in unwind destinations for throwing instructions, such as calls.; //; // We use the 'delegate' instruction to fix the unwind mismatches. 'delegate'; // instruction delegates an exception to an outer 'catch'. It can target not; // only 'catch' but all block-like structures including another 'delegate',; // but with slightly different semantics than branches. When it targets a; // 'catch', it will delegate the exception to that catch. It is being; // discussed how to define the semantics when 'delegate''s target is a non-try; // block: it will either be a validation failure or it will target the next; // outer try-catch. But anyway our LLVM backend currently does not generate; // such code. The example below illustrates where the 'delegate' instruction; // in the middle will delegate the exception to, depending on the value of N.; // try; // try; // block; // try; // try; // call @foo; // delegate N ;; Where will this delegate to?; // catch ;; N == 0; // end; // end ;; N == 1 (invalid; will not be generated); // delegate ;; N == 2; // catch ;; N == 3; // end; // ;; N == 4 (to caller); // 1. When an instruction may throw, but the EH pad it will unwind to can be; // different from the original CFG.; //; // Example: we have the following CFG:; // bb0:; // call @foo ; if it throws, unwind to bb2; // bb1:; // call @bar ; if it throws, unwind to bb3; // bb2 (ehpad):; // catch; // ...; // bb3 (ehpad); // catch; // ...; //; // And the CFG is sorted in this order. Then after placing TRY markers, it; // will look like: (BB markers are omitted); // try; // try; // call @foo; // call @bar ;; if it throws, unwind to bb3; // catch ;; ehpad (bb2); // ...; // end_try; // catch ;; ehpad (bb3); // ...; // end_try; //; // Now if bar() throws, it is going to end up ip in bb2, not bb3, where it; // is supposed to end up. We solve this problem by wrapping the mismatching; // call with an inner try-del",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:651,validat,validation,651,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,1,['validat'],['validation']
Security,// Linearly probe the hash table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:22,hash,hash,22,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,1,['hash'],['hash']
Security,"// Link is hashed by contents and may change slot in hash table",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooLinkedList.cxx:11,hash,hashed,11,roofit/roofitcore/src/RooLinkedList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooLinkedList.cxx,2,['hash'],"['hash', 'hashed']"
Security,// Link the type of the injected-class-name to that of the outer class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:24,inject,injected-class-name,24,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['inject'],['injected-class-name']
Security,// List of call stack ids computed from the location hashes on debug; // locations (leaf to inlined at root).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:53,hash,hashes,53,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,1,['hash'],['hashes']
Security,"// List of calls which pass address as an argument.; // Value is offset range of address from base address (alloca or calling; // function argument). Range should never set to empty-set, that is an invalid; // access range that can cause empty-set to be propagated with; // ConstantRange::add",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:210,access,access,210,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,1,['access'],['access']
Security,"// List of default authentication methods",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:19,authenticat,authentication,19,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['authenticat'],['authentication']
Security,// List of memory access instructions from src and dst nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:18,access,access,18,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,1,['access'],['access']
Security,"// List of unique stack ids (hashes). We use a 4B index of the id in the; // stack id lists on the alloc and callsite summaries for memory savings,; // since the number of unique ids is in practice much smaller than the; // number of stack id references in the summaries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:29,hash,hashes,29,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['hash'],['hashes']
Security,"// List of visited <Access, Location> pairs; we can skip paths already; // visited with the same memory location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:20,Access,Access,20,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['Access'],['Access']
Security,// List the pair of accesses need run-time checks to prove independence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:20,access,accesses,20,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['access'],['accesses']
Security,// Load Value Injection (LVI) Mitigations for machine code,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:14,Inject,Injection,14,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,1,['Inject'],['Injection']
Security,// Load address for TLS access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h:24,access,access,24,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h,1,['access'],['access']
Security,"// Load libraries needed for (server) authentication ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TServerSocket.cxx:38,authenticat,authentication,38,net/net/src/TServerSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TServerSocket.cxx,3,['authenticat'],['authentication']
Security,// Load the expected 32-bit type hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:33,hash,hash,33,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,1,['hash'],['hash']
Security,// Load the expected type hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp:26,hash,hash,26,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp,1,['hash'],['hash']
Security,// Load the target function type hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp:33,hash,hash,33,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp,2,['hash'],['hash']
Security,// Load/store operations may access the stack indirectly when we previously; // computed an address to a stack location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:29,access,access,29,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,1,['access'],['access']
Security,"// Loading the training and validation datasets",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx:28,validat,validation,28,tmva/tmva/src/MethodDL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx,1,['validat'],['validation']
Security,// Local hashing entry points,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeStreamMerger.cpp:9,hash,hashing,9,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeStreamMerger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeStreamMerger.cpp,2,['hash'],['hashing']
Security,"// Local-dynamic accesses proceed in two phases. A general-dynamic TLS; // descriptor call against the special symbol _TLS_MODULE_BASE_ to calculate; // the beginning of the module's TLS region, followed by a DTPREL offset; // calculation.; // These accesses will need deduplicating if there's more than one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:17,access,accesses,17,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['access'],['accesses']
Security,"// Lock mutex for guarding access to fWindowList",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/src/TRecorder.cxx:27,access,access,27,gui/recorder/src/TRecorder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/src/TRecorder.cxx,2,['access'],['access']
Security,// Log_2 of the memory access size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:23,access,access,23,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,1,['access'],['access']
Security,// Long integer divisions are often used in hashtable implementations. It's; // not worth bypassing such divisions because hash values are extremely; // unlikely to have enough leading zeros. The call below tries to detect; // values that are unlikely to fit BypassType (including hashes).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:44,hash,hashtable,44,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,3,['hash'],"['hash', 'hashes', 'hashtable']"
Security,"// Look for an existing security context matching this request",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:24,secur,security,24,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['secur'],['security']
Security,"// Look for any identifiers that were named while processing the; // headers, but are otherwise not needed. We add these to the hash; // table to enable checking of the predefines buffer in the case; // where the user adds new macro definitions when building the AST; // file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:128,hash,hash,128,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['hash'],['hash']
Security,// Look for one of the two cases with InjectedClassNameTypes; // and check whether it's the same template.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:38,Inject,InjectedClassNameTypes,38,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['Inject'],['InjectedClassNameTypes']
Security,// Look for properties accessed with method syntax ([foo setBar:...]).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:23,access,accessed,23,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,1,['access'],['accessed']
Security,// Look for properties accessed with property syntax (foo.bar = ...),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:23,access,accessed,23,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,1,['access'],['accessed']
Security,// Look in the on-disk hash table for an entry for this file name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:23,hash,hash,23,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['hash'],['hash']
Security,"// Look in the options string for the authentication information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TS3WebFile.cxx:38,authenticat,authentication,38,net/net/src/TS3WebFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TS3WebFile.cxx,1,['authenticat'],['authentication']
Security,// Look into the base of a field access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp:33,access,access,33,interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,1,['access'],['access']
Security,// Look the hash up in our cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:12,hash,hash,12,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['hash'],['hash']
Security,// Look through phi accesses. Recursively scan all phi accesses by; // adding them to a worklist. Bail when we run into a memory def that; // does not match LoadAccess.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:20,access,accesses,20,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,2,['access'],['accesses']
Security,"// Look through selects and PHIs to find if the pointer is; // conditionally accessed. Make sure we only visit an instruction; // once; otherwise, we can get infinite recursion or exponential; // compile time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp:77,access,accessed,77,interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp,1,['access'],['accessed']
Security,"// Look up the cache entry. Since we're working with the first; // declaration, its parent must be the class definition, which is; // the correct key for the KeyFunctions hash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:171,hash,hash,171,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['hash'],['hash']
Security,"// Look up the function records in the given file. Due to hash collisions on; // the filename, we may get back some records that are not in the file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp:58,hash,hash,58,interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp,2,['hash'],['hash']
Security,// Lookup BinaryFunctions using the function name's MD5 hash. Needed if the; // profile is using MD5.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.h:56,hash,hash,56,interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.h,1,['hash'],['hash']
Security,"// Lookup the copy canstructor and check its accessiblity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp:45,access,accessiblity,45,interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp,1,['access'],['accessiblity']
Security,"// Lookup the markup name in the hash table",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx:33,hash,hash,33,gui/guihtml/src/TGHtmlParse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx,1,['hash'],['hash']
Security,"// Loop back through the sequence and validate elements we might have skipped; // while waiting for a valid step. While doing this, log any sequence addend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:38,validat,validate,38,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['validat'],['validate']
Security,"// Loop over all uses of the Last LEA to check that its def register is; // used only as address base for memory accesses. If so, it can be; // replaced, otherwise - no.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp:113,access,accesses,113,interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,1,['access'],['accesses']
Security,"// Loop passes are designed to run inside of a loop pass manager which means; // that any function analyses they require must be required by the first loop; // pass in the manager (so that it is computed before the loop pass manager; // runs) and preserved by all loop pasess in the manager. To make this; // reasonably robust, the set needed for most loop passes is maintained here.; // If your loop pass requires an analysis not listed here, you will need to; // carefully audit the loop pass manager nesting structure that results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:475,audit,audit,475,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,1,['audit'],['audit']
Security,// Low-level access,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManagerInternals.h:13,access,access,13,interpreter/llvm-project/clang/include/clang/Basic/SourceManagerInternals.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManagerInternals.h,1,['access'],['access']
Security,// Low-level accessor,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:13,access,accessor,13,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,1,['access'],['accessor']
Security,"// Low-level accessor. If you just want the type defined by this node,; // check out ASTContext::getTypeDeclType or one of; // ASTContext::getTypedefType, ASTContext::getRecordType, etc. if you; // already know the specific kind of node this is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:13,access,accessor,13,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['access'],['accessor']
Security,// Low-level accessors; /// Mark that there are external lexical declarations that we need; /// to include in our lookup table (and that are not available as external; /// visible lookups). These extra lookup results will be found by walking; /// the lexical declarations of this context. This should be used only if; /// setHasExternalLexicalStorage() has been called on any decl context for; /// which this is the primary context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:13,access,accessors,13,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['access'],['accessors']
Security,// Lower bound on average lifetime accesses density (total life time access; // density / alloc count) for marking an allocation hot.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:35,access,accesses,35,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,2,['access'],"['access', 'accesses']"
Security,// Lower bound on lifetime to mark an allocation cold (in addition to accesses; // per byte per sec above). This is to avoid pessimizing short lived objects.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:70,access,accesses,70,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,1,['access'],['accesses']
Security,// Lower type metadata and the type.test intrinsic. This pass supports; // clang's control flow integrity mechanisms (-fsanitize=cfi*) and needs; // to be run at link time if CFI is enabled. This pass does nothing if; // CFI is disabled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:96,integrity,integrity,96,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['integrity'],['integrity']
Security,// Lower zero cost accesses to the kernel instances just created,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:19,access,accesses,19,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['access'],['accesses']
Security,// Lowers this interleaved access group into X86-specific; // instructions/intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:27,access,access,27,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,1,['access'],['access']
Security,"// MD5 cryptographic hash functions with a 128 bit output",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TMD5.h:21,hash,hash,21,core/base/inc/TMD5.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TMD5.h,1,['hash'],['hash']
Security,// MDNode for the kernel argument access qualifiers (images only).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:34,access,access,34,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['access'],['access']
Security,"// MD_prof nodes have the following layout; //; // In general:; // { String name, Array of i32 }; //; // In terms of Types:; // { MDString, [i32, i32, ...]}; //; // Concretely for Branch Weights; // { ""branch_weights"", [i32 1, i32 10000]}; //; // We maintain some constants here to ensure that we access the branch weights; // correctly, and can change the behavior in the future if the layout changes; // The index at which the weights vector starts",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ProfDataUtils.cpp:297,access,access,297,interpreter/llvm-project/llvm/lib/IR/ProfDataUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ProfDataUtils.cpp,1,['access'],['access']
Security,// MIPS32r6 does not have alignment restrictions for memory access.; // For MIPS32r5 and older memory access must be naturally-aligned i.e. aligned; // to at least a multiple of its own size. There is however a two instruction; // combination that performs 4 byte unaligned access (lwr/lwl and swl/swr); // therefore 4 byte load and store are legal and will use NoAlignRequirements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:60,access,access,60,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,3,['access'],['access']
Security,"// MIPS32r6/MIPS64r6 is required to support unaligned access. It's; // implementation defined whether this is handled by hardware, software, or; // a hybrid of the two but it's expected that most implementations will; // handle the majority of cases in hardware.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:54,access,access,54,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,1,['access'],['access']
Security,// MOPSMemorySetTaggingPseudo has two defs; the intrinsic call has only one.; // Therefore an additional virtual register is requried for the updated size; // operand. This value is not accessible via the semantics of the intrinsic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:186,access,accessible,186,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['access'],['accessible']
Security,// MSSA determined that CI does not access memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:36,access,access,36,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['access'],['access']
Security,// MSVC CRT has a function to validate security cookie.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:30,validat,validate,30,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,12,"['secur', 'validat']","['security', 'validate']"
Security,// MSVC CRT has a global variable holding security cookie.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:42,secur,security,42,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,6,['secur'],['security']
Security,// MSVC allows explicit template specialization at class scope:; // 2 CXXMethodDecls referring to the same function will be injected.; // We don't want a redeclaration error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:124,inject,injected,124,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['inject'],['injected']
Security,"// MSan: Workaround for PR16386.; // ASan: This is mainly to help LSan with cases such as; // https://github.com/google/sanitizers/issues/373; // We can't make this conditional on -fsanitize=leak, as that flag shouldn't; // affect compilation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:120,sanitiz,sanitizers,120,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['sanitiz'],['sanitizers']
Security,// MUBUF and FLAT LDS DMA operations need a wait on vmcnt before LDS; // written can be accessed. A load from LDS to VMEM does not need a wait.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:88,access,accessed,88,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['access'],['accessed']
Security,// MUBUF and MTBUF can access the same addresses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:23,access,access,23,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['access'],['access']
Security,"// MachO still uses GOT for large code-model accesses, but ELF requires; // movz/movk sequences, which FastISel doesn't handle yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp:45,access,accesses,45,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,1,['access'],['accesses']
Security,// MachineIRBuilder::DebugLoc can outlive the DILocation it holds. Clear it; // to avoid accessing free’d memory (in runOnMachineFunction) and to avoid; // destroying it twice (in ~IRTranslator() and ~LLVMContext()),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:89,access,accessing,89,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,1,['access'],['accessing']
Security,// MachineSanitizerBinaryMetadata - appends/finalizes sanitizer binary; // metadata after llvm SanitizerBinaryMetadata pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:54,sanitiz,sanitizer,54,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,2,"['Sanitiz', 'sanitiz']","['SanitizerBinaryMetadata', 'sanitizer']"
Security,"// Machinery to build an MRU-hashtable of Chains.; //; // (Ideally this could be done with MapVector, but as currently implemented,; // moving an element to the front of a MapVector is O(n).)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:29,hash,hashtable,29,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,1,['hash'],['hashtable']
Security,// Maintain backwards compatibility with the old internal representation of; // CSK_None in ChecksumKind by writing nulls here when Checksum is None.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:92,Checksum,ChecksumKind,92,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,2,['Checksum'],"['Checksum', 'ChecksumKind']"
Security,"// Make a second pass over the PHINodes now that all of them have been; // remapped into the new function, simplifying the PHINode and performing any; // recursive simplifications exposed. This will transparently update the; // WeakTrackingVH in the VMap. Notably, we rely on that so that if we coalesce; // two PHINodes, the iteration over the old PHIs remains valid, and the; // mapping will just map us to the new node (which may not even be a PHI; // node).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:180,expose,exposed,180,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,1,['expose'],['exposed']
Security,// Make internal constraint solver entities friends so they can access the; // overconstrained-related functions. We want to keep this API inaccessible; // for Checkers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h:64,access,access,64,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h,1,['access'],['access']
Security,// Make it a friend so it can access getNextOperandForReg().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:30,access,access,30,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,1,['access'],['access']
Security,// Make it accessible only to CSEMIRBuilder.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:11,access,accessible,11,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,1,['access'],['accessible']
Security,// Make it possible for subclasses to access these fields without making them; // public.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:38,access,access,38,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,1,['access'],['access']
Security,// Make sure it's a local dynamic access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CleanupLocalDynamicTLSPass.cpp:34,access,access,34,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CleanupLocalDynamicTLSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CleanupLocalDynamicTLSPass.cpp,1,['access'],['access']
Security,"// Make sure that all CoroFree reference the coro.id intrinsic.; // Token type is not exposed through coroutine C/C++ builtins to plain C, so; // we allow specifying none and fixing it up here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp:86,expose,exposed,86,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroEarly.cpp,1,['expose'],['exposed']
Security,"// Make sure that each function is defined, does not access memory, takes at; // least one argument, does not use its first argument (which we assume is; // 'this'), and has the same return type.; //; // Note that we test whether this copy of the function is readnone, rather; // than testing function attributes, which must hold for any copy of the; // function, even a less optimized version substituted at link time. This is; // sound because the virtual constant propagation optimizations effectively; // inline all implementations of the virtual function into each call site,; // rather than using function attributes to perform local optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:53,access,access,53,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['access'],['access']
Security,"// Make sure that every module has an entry in the ExportLists, ImportList,; // GVSummary and ResolvedODR maps to enable threaded access to these maps; // below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:130,access,access,130,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,1,['access'],['access']
Security,// Make sure that loop-simplify form is preserved. We want to simplify; // at least one layer outside of the loop that was unrolled so that any; // changes to the parent loop exposed by the unrolling are considered.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:175,expose,exposed,175,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,1,['expose'],['exposed']
Security,"// Make sure that nothing can observe cpyDest being written early. There are; // a number of cases to consider:; // 1. cpyDest cannot be accessed between C and cpyStore as a precondition of; // the transform.; // 2. C itself may not access cpyDest (prior to the transform). This is; // checked further below.; // 3. If cpyDest is accessible to the caller of this function (potentially; // captured and not based on an alloca), we need to ensure that we cannot; // unwind between C and cpyStore. This is checked here.; // 4. If cpyDest is potentially captured, there may be accesses to it from; // another thread. In this case, we need to check that cpyStore is; // guaranteed to be executed if C is. As it is a non-atomic access, it; // renders accesses from other threads undefined.; // TODO: This is currently not checked.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:137,access,accessed,137,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,6,['access'],"['access', 'accessed', 'accesses', 'accessible']"
Security,// Make sure that the instructions do not access the same memory location in; // the next iteration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:42,access,access,42,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['access'],['access']
Security,"// Make sure the associated call site argument has the same type at all call; // sites and it is an allocation we know is safe to privatize, for now that; // means we only allow alloca instructions.; // TODO: We can additionally analyze the accesses in the callee to create; // the type from that information instead. That is a little more; // involved and will be done in a follow up patch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:241,access,accesses,241,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['access'],['accesses']
Security,"// Make sure the cache is clear. It is important to clear it here, because; // the cache might be invalid even when just the firstPOI was changed, for which; // no accessor has to be called. (Fixes a bug when ToyMCSampler is; // used with the Neyman Construction)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ToyMCSampler.cxx:164,access,accessor,164,roofit/roostats/src/ToyMCSampler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ToyMCSampler.cxx,1,['access'],['accessor']
Security,"// Make sure the file is closed, mostly for Windows FS, also when; // accessing it from a Linux VM via a shared folder",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:70,access,accessing,70,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,2,['access'],['accessing']
Security,// Make sure the linker consider all object files from the static lib.; // This is necessary because instrumented dlls need access to all the; // interface exported by the static lib in the main executable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp:124,access,access,124,interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp,1,['access'],['access']
Security,"// Make sure the offset is inside the object, or we might fail to; // allocate an emergency spill slot. (An out-of-range access is UB, but; // it could show up anyway.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:121,access,access,121,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['access'],['access']
Security,"// Make sure this is not a spill slot: spill slots cannot be aligned; // if there are variable-sized objects on the stack. They must be; // accessible via FP (which is not aligned), because SP is unknown,; // and AP may not be available at the location of the load/store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp:140,access,accessible,140,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp,1,['access'],['accessible']
Security,// Make sure we can access the PCH file even if we're using a VFS,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:20,access,access,20,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,1,['access'],['access']
Security,// Make synthesized accessor stub functions visible.; // ActOnPropertyImplDecl() creates them as not visible in case; // they are overridden by an explicit method that is encountered; // later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:20,access,accessor,20,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['access'],['accessor']
Security,"// Make the typedef-expanded -> original hash table entries.; // There may be several entries for any given key.; // We only make entries if the typedef-expanded name; // is different from the original name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:41,hash,hash,41,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['hash'],['hash']
Security,// Make this std::unordered_map for speed of accessing elements.; // Map: Register (physical or virtual) -> DefStack,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h:45,access,accessing,45,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,1,['access'],['accessing']
Security,"// MallocOverflowSecurityChecker.cpp - Check for malloc overflows -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker detects a common memory allocation security flaw.; // Suppose 'unsigned int n' comes from an untrusted source. If the; // code looks like 'malloc (n * 4)', and an attacker can make 'n' be; // say MAX_UINT/4+2, then instead of allocating the correct 'n' 4-byte; // elements, this will actually allocate only two because of overflow.; // Then when the rest of the program attempts to store values past the; // second element, these values will actually overwrite other items in; // the heap, probably allowing the attacker to execute arbitrary code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:431,secur,security,431,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,3,"['attack', 'secur']","['attacker', 'security']"
Security,"// Mangle injected class name types as if the user had written the; // specialization out fully. It may not actually be possible to see; // this mangling, though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:10,inject,injected,10,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['inject'],['injected']
Security,"// Manually add back the original store to the worklist now, so it will; // be processed after the operands of the removed store, as this may; // expose additional DSE opportunities.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:146,expose,expose,146,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,1,['expose'],['expose']
Security,// Map a hash of the filenames region to the filename range associated; // with this coverage header.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp:9,hash,hash,9,interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp,1,['hash'],['hash']
Security,// Map access methods.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:7,access,access,7,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,1,['access'],['access']
Security,"// Map an image type name to its 3 access-qualified types (RO, WO, RW).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:35,access,access-qualified,35,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,1,['access'],['access-qualified']
Security,// Map from id (recorded from sanitizer stack depot) to virtual addresses for; // each program counter address in the callstack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/RawMemProfReader.h:30,sanitiz,sanitizer,30,interpreter/llvm-project/llvm/include/llvm/ProfileData/RawMemProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/RawMemProfReader.h,1,['sanitiz'],['sanitizer']
Security,// Map from tuples of Probe id and inline stack hash code to distribution; // factors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h:48,hash,hash,48,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h,1,['hash'],['hash']
Security,// Map indirect call target name hash to name string.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h:33,hash,hash,33,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,2,['hash'],['hash']
Security,"// Map of classes hashes and headers associated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.h:18,hash,hashes,18,core/metacling/src/TCling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.h,1,['hash'],['hashes']
Security,// Map of pointers to last access encountered.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:27,access,access,27,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['access'],['access']
Security,"// Map output paths that affect behaviour to ""-"" so their existence is in the; // context hash. The final path will be computed in addOutputPaths.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:90,hash,hash,90,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,1,['hash'],['hash']
Security,// Map the opened file into memory and use a StringRef to access it later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:58,access,access,58,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,1,['access'],['access']
Security,// Maps VMEM access types to their corresponding WaitEventType.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:13,access,access,13,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['access'],['access']
Security,// Maps a hash of the filenames in a TU to a \c FileRange. The range; // specifies the location of the hashed filenames in \c Filenames.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp:10,hash,hash,10,interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp,2,['hash'],"['hash', 'hashed']"
Security,"// Maps page checksums to the first sealed page with that checksum",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorage.cxx:13,checksum,checksums,13,tree/ntuple/v7/src/RPageStorage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorage.cxx,2,['checksum'],"['checksum', 'checksums']"
Security,"// Mark size as unknown, if the location is not guaranteed to be; // loop-invariant for any possible loop in the function. Setting the size; // to unknown guarantees that any memory accesses that access locations; // after the pointer are considered as clobbers, which is important to; // catch loop carried dependences.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:182,access,accesses,182,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,2,['access'],"['access', 'accesses']"
Security,"// Mask of all sanitizers ever enabled by; // -fsanitize= flags (directly or via group; // expansion), some of which may be disabled; // later. Used to carefully prune; // unused-argument diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:15,sanitiz,sanitizers,15,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['sanitiz'],['sanitizers']
Security,"// Masked gather and scatter - load and store operations for a vector of; // random addresses with additional mask operand that prevents memory; // accesses to the masked-off lanes.; //; // Val, OutChain = GATHER(InChain, PassThru, Mask, BasePtr, Index, Scale); // OutChain = SCATTER(InChain, Value, Mask, BasePtr, Index, Scale); //; // The Index operand can have more vector elements than the other operands; // due to type legalization. The extra elements are ignored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:148,access,accesses,148,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['access'],['accesses']
Security,"// Masked load and store - consecutive vector load and store operations; // with additional mask operand that prevents memory accesses to the; // masked-off lanes.; //; // Val, OutChain = MLOAD(BasePtr, Mask, PassThru); // OutChain = MSTORE(Value, BasePtr, Mask)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:126,access,accesses,126,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['access'],['accesses']
Security,"// Masks for authentication methods",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:13,authenticat,authentication,13,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['authenticat'],['authentication']
Security,// Masks out the bits for the access model.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:30,access,access,30,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,1,['access'],['access']
Security,"// Match (GA) or (C) or (GA+C) or (GA-C) or ((GA+C)+C) or (((GA+C)+C)+C),; // etc., since getelementpointer is variadic. We can't use; // SelectionDAG::FoldSymbolOffset because it expects the GA to be accessible; // while in this case the GA may be furthest from the root node which is; // likely an ISD::ADD.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:201,access,accessible,201,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['access'],['accessible']
Security,// Match -fno-sanitize-ignorelist.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:14,sanitiz,sanitize-ignorelist,14,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['sanitiz'],['sanitize-ignorelist']
Security,"// Match canonical forms of min/max. We are not using ValueTracking's; // more powerful matchSelectPattern() because it may rely on instruction flags; // such as ""nsw"". That would be incompatible with the current hashing; // mechanism that may remove flags to increase the likelihood of CSE.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:213,hash,hashing,213,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['hash'],['hashing']
Security,// Match interleaved memory accesses to ldN/stN intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp:28,access,accesses,28,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp,2,['access'],['accesses']
Security,"// MaterializeTemporaryExpr may appear out of place, after a few field and; // base-class accesses have been made to the object, even though semantically; // it is the whole object that gets materialized and lifetime-extended.; //; // For example:; //; // `-MaterializeTemporaryExpr; // `-MemberExpr; // `-CXXTemporaryObjectExpr; //; // instead of the more natural; //; // `-MemberExpr; // `-MaterializeTemporaryExpr; // `-CXXTemporaryObjectExpr; //; // Use the usual methods for obtaining the expression of the base object,; // and record the adjustments that we need to make to obtain the sub-object; // that the whole expression 'Ex' refers to. This trick is usual,; // in the sense that CodeGen takes a similar route.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:90,access,accesses,90,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,1,['access'],['accesses']
Security,"// Matrix types in memory are represented by arrays, but accessed through; // vector pointers, with the alignment specified on the access operation.; // For inline assembly, update pointer arguments to use vector pointers.; // Otherwise there will be a mis-match if the matrix is also an; // input-argument which is represented as vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp:57,access,accessed,57,interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,2,['access'],"['access', 'accessed']"
Security,"// Maximum of 3 bytes left. Hash a 2 byte word if possible, then hash the; // possibly remaining 1 byte.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/Hash.cpp:28,Hash,Hash,28,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/Hash.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/Hash.cpp,2,"['Hash', 'hash']","['Hash', 'hash']"
Security,// Member access is complex.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:10,access,access,10,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,1,['access'],['access']
Security,// Member access lhs @ rhs,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h:10,access,access,10,interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h,1,['access'],['access']
Security,// Member access: lhs @ rhs,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h:10,access,access,10,interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h,1,['access'],['access']
Security,"// Member accesses have four cases:; // 1: non-array member via ""->"": dereferences; // 2: non-array member via ""."": nothing interesting happens; // 3: array member access via ""->"": nothing interesting happens; // (this returns an array lvalue and does not actually dereference memory); // 4: array member access via ""."": *adds* a layer of indirection",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:10,access,accesses,10,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,3,['access'],"['access', 'accesses']"
Security,// Memory accesses should only be reduced and can not be increased since AA; // just might return better results as a result of some transformations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:10,access,accesses,10,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['access'],['accesses']
Security,// Memory accesses via the stack pointer do not have a requirement for; // either of the registers to be compressible and can take a larger offset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:10,access,accesses,10,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,1,['access'],['accesses']
Security,"// Memory check:; // Transform phase will generate a versioned loop and also a runtime check to; // ensure the pointers are independent and they don’t alias.; // In version variant of loop, alias meta data asserts that all access are; // mutually independent.; //; // Pointers aliasing in alias domain are avoided because with multiple; // aliasing domains we may not be able to hoist potential loop invariant; // access out of the loop.; //; // Iterate over alias tracker sets, and confirm AliasSets doesn't have any; // must alias set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:223,access,access,223,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,2,['access'],['access']
Security,"// Memory constraint codes.; // Addresses are included here as they need to be treated the same by the; // backend, the only difference is that they are not used to actaully; // access memory by the instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InlineAsm.h:178,access,access,178,interpreter/llvm-project/llvm/include/llvm/IR/InlineAsm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InlineAsm.h,1,['access'],['access']
Security,"// Memory operand. Note that on PowerPC targets, m can; // include addresses that update the base register. It; // is therefore only safe to use `m' in an asm statement; // if that asm statement accesses the operand exactly once.; // The asm statement must also use `%U<opno>' as a; // placeholder for the ""update"" flag in the corresponding; // load or store instruction. For example:; // asm (""st%U0 %1,%0"" : ""=m"" (mem) : ""r"" (val));; // is correct but:; // asm (""st %1,%0"" : ""=m"" (mem) : ""r"" (val));; // is not. Use es rather than m if you don't want the base; // register to be updated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:195,access,accesses,195,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,1,['access'],['accesses']
Security,// Memory operations without memory operands may access anything. Be; // conservative and assume `MayAlias`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:49,access,access,49,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,1,['access'],['access']
Security,// MemoryUse are read-only accesses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:27,access,accesses,27,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,1,['access'],['accesses']
Security,"// Memtag sanitization works differently: sanitization is requested by clang; // when `-fsanitize=memtag-globals` is provided, and the request can be; // denied (and the attribute removed) by the AArch64 global tagging pass if; // it can't be fulfilled (e.g. the global variable is a TLS variable).; // Memtag sanitization has to interact with other parts of LLVM (like; // supressing certain optimisations, emitting assembly directives, or; // creating special relocation sections).; //; // Use `GlobalValue::isTagged()` to check whether tagging should be enabled; // for a global variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h:10,sanitiz,sanitization,10,interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,3,['sanitiz'],['sanitization']
Security,// Merge in bits from the operand if easy. We can't use MachineOperand's; // hash_code here because it's not deterministic and we sort by hash value; // later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:138,hash,hash,138,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['hash'],['hash']
Security,// Metadata associated with the return value from a recorded property access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:70,access,access,70,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,1,['access'],['access']
Security,"// MethodCuts redefines some of the evaluation variables and histograms -> must access private members",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBase.h:80,access,access,80,tmva/tmva/inc/TMVA/MethodBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBase.h,1,['access'],['access']
Security,// Methods to access block successors -- dereferencing to our wrapper class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:14,access,access,14,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['access'],['access']
Security,"// Mimic the logic of TTreeProcessorMT::MakeClusters: merge entry ranges together such that we; // run around TTreeProcessorMT::GetTasksPerWorkerHint tasks per worker thread.; // TODO it would be better to expose TTreeProcessorMT's actual logic and call the exact same method from here",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/inc/ReadSpeed.hxx:206,expose,expose,206,tree/readspeed/inc/ReadSpeed.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/inc/ReadSpeed.hxx,2,['expose'],['expose']
Security,// Misaligned accesses of any size are always allowed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:14,access,accesses,14,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['access'],['accesses']
Security,"// Module Hash, 160 bits SHA1. Optionally, emitted after each MST_CODE_ENTRY.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:10,Hash,Hash,10,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,1,['Hash'],['Hash']
Security,// Module needs access to the add/removeModule methods.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h:16,access,access,16,interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,1,['access'],['access']
Security,"// Most TLS accesses are not RIP relative, even on x86-64. One exception is; // initialexec.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:12,access,accesses,12,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['access'],['accesses']
Security,"// Most architectures are going to legalize <s8 loads into at least a 1 byte; // load, and the MMOs can only describe memory accesses in multiples of bytes.; // If we try to perform extload combining on those, we can end up with; // %a(s8) = extload %ptr (load 1 byte from %ptr); // ... which is an illegal extload instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:125,access,accesses,125,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['access'],['accesses']
Security,"// Most architectures require memory to fit within a single cache; // line, so the alignment has to be at least the size of the access.; // Otherwise we have to grab a lock.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:128,access,access,128,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['access'],['access']
Security,"// Move MemoryAccesses still tracked in Old, but part of New now.; // Update accesses in successor blocks accordingly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:77,access,accesses,77,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,2,['access'],['accesses']
Security,"// Move What before Where in the IR. The end result is that What will belong to; // the right lists and have the right Block set, but will not otherwise be; // correct. It will not have the right defining access, and if it is a def,; // things below it will not properly be updated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:205,access,access,205,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['access'],['access']
Security,"// Move all memory accesses from `From` to `To` starting at `Start`.; // Restrictions apply, see public wrappers of this method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:19,access,accesses,19,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,1,['access'],['accesses']
Security,// Movement within the same loop does not break LCSSA (the equality check is; // to avoid doing a hashtable lookup in case of intra-block movement).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:98,hash,hashtable,98,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,1,['hash'],['hashtable']
Security,"// Multiple vertices accessors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLBoundingBox.h:21,access,accessors,21,graf3d/gl/inc/TGLBoundingBox.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLBoundingBox.h,1,['access'],['accessors']
Security,// Murmur-inspired hashing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:19,hash,hashing,19,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,1,['hash'],['hashing']
Security,"// MurmurHash3 - a blazingly fast public domain hash!; // See http://code.google.com/p/smhasher/; // There are two versions, one optimized for 32 bit and one for 64 bit.; // They give different hash results!; // We use only the 64 bit version which also works on 32 bit.; //-----------------------------------------------------------------------------; // MurmurHash3 was written by Austin Appleby, and is placed in the public; // domain. The author hereby disclaims copyright to this source code.; // Note - The x86 and x64 versions do _not_ produce the same results, as the; // algorithms are optimized for their respective platforms. You can still; // compile and run any of them on any platform, but your performance with the; // non-native version will be less than optimal.; //-----------------------------------------------------------------------------; // Platform-specific functions and macros; // From MurmurHash.h:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TString.cxx:48,hash,hash,48,core/base/src/TString.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TString.cxx,2,['hash'],['hash']
Security,"// Must come after ""linking"" section in order to validate reloc indexes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Wasm.h:49,validat,validate,49,interpreter/llvm-project/llvm/include/llvm/Object/Wasm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Wasm.h,1,['validat'],['validate']
Security,// Must have been promoted (possibly conservatively). Find original; // name so that we can access the correct summary and see if it can; // be internalized again.; // FIXME: Eventually we should control promotion instead of promoting; // and internalizing again.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:92,access,access,92,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,1,['access'],['access']
Security,"// Must provide:; // static void mapping(IO &io, T &fields);; // Optionally may provide:; // static std::string validate(IO &io, T &fields);; // static void enumInput(IO &io, T &value);; //; // The optional flow flag will cause generated YAML to use a flow mapping; // (e.g. { a: 0, b: 1 }):; // static const bool flow = true;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h:112,validat,validate,112,interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,1,['validat'],['validate']
Security,"// Must provide:; // static void mapping(IO &io, T &fields, Context &Ctx);; // Optionally may provide:; // static std::string validate(IO &io, T &fields, Context &Ctx);; //; // The optional flow flag will cause generated YAML to use a flow mapping; // (e.g. { a: 0, b: 1 }):; // static const bool flow = true;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h:126,validat,validate,126,interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,1,['validat'],['validate']
Security,"// Must use API version 1. Google Storage API v2 only; // accepts OAuth authentication.; // This header is not strictly needed but if used for computing; // the signature, the request must contain it as a header; // (see method MakeAuthHeader); // Ref: https://developers.google.com/storage/docs/reference/v1/apiversion1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TS3HTTPRequest.cxx:72,authenticat,authentication,72,net/net/src/TS3HTTPRequest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TS3HTTPRequest.cxx,1,['authenticat'],['authentication']
Security,// Mutable indexed accessors; // - (void)insertObject:(type *)object inKeyAtIndex:(NSUInteger)index,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:19,access,accessors,19,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['access'],['accessors']
Security,// Mutable unordered accessors; // - (void)addKeyObject:(type *)object,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:21,access,accessors,21,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['access'],['accessors']
Security,"// Mutex for protection of concurrent gROOT access",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:44,access,access,44,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['access'],['access']
Security,// N.B. liveOnEntry has a null defining access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:40,access,access,40,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,1,['access'],['access']
Security,// N64 relocation type accessors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCELFObjectWriter.h:23,access,accessors,23,interpreter/llvm-project/llvm/include/llvm/MC/MCELFObjectWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCELFObjectWriter.h,1,['access'],['accessors']
Security,// NO CONSTRUCTOR - we don't want static constructor ordering to mess; // with the registry.; // Accessors.; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassRegistry.h:97,Access,Accessors,97,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassRegistry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassRegistry.h,1,['Access'],['Accessors']
Security,"// NOTE: As of now, we only have one free access function: std::data.; // If we add more functions like this in the list, hardcoded; // argument index should be changed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp:42,access,access,42,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/InnerPointerChecker.cpp,1,['access'],['access']
Security,"// NOTE: Instead of using ProgramState::assumeInBound(), we are prototyping; // some new logic here that reasons directly about memory region extents.; // Once that logic is more mature, we can bring it back to assumeInBound(); // for all clients to use.; //; // The algorithm we are using here for bounds checking is to see if the; // memory access is within the extent of the base region. Since we; // have some flexibility in defining the base region, we can achieve; // various levels of conservatism in our buffer overflow checking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp:343,access,access,343,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,1,['access'],['access']
Security,// NOTE: PtrTy is a vector to signal `TTI::getAddressComputationCost`; // that it is being called from this specific place.; // Figure out whether the access is strided and get the stride value; // if it's known in compile time,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:151,access,access,151,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['access'],['access']
Security,"// NOTE: Since this function validates against another TDSetElement,; // if the other TDSetElement (elem) did not use -1 to request all; // entries, this TDSetElement may get less than all entries if it; // requests all (with -1). For the application it was developed for; // (TProofSuperMaster::ValidateDSet) it works, since the design was; // to send the elements to their mass storage domain and let them; // look at the file and send the info back to the supermaster. The; // ability to set fValid was also required to be only exist in; // TDSetElement through certain function and not be set externally.; // TDSetElement may need to be extended for more general applications.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDSet.cxx:29,validat,validates,29,proof/proof/src/TDSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDSet.cxx,2,"['Validat', 'validat']","['ValidateDSet', 'validates']"
Security,"// NOTE: This CodeSignature section behaviour must be kept in sync with that; // performed in LLD's CodeSignatureSection::write /; // CodeSignatureSection::writeHashes. Furthermore, this call must occur only; // after the rest of the binary has already been written to the buffer. This; // is because the buffer is read from to perform the necessary hashing.; // The CodeSignature section is the last section in the MachO binary and; // contains a hash of all content in the binary before it. Since llvm-objcopy; // has likely modified the target binary, the hash must be regenerated; // entirely. To generate this hash, we must read from the start of the binary; // (HashReadStart) to just before the start of the CodeSignature section; // (HashReadEnd).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOWriter.cpp:350,hash,hashing,350,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOWriter.cpp,6,"['Hash', 'hash']","['HashReadEnd', 'HashReadStart', 'hash', 'hashing']"
Security,"// NOTE: This bailout should be an assert instead. However, asserting; // the condition here exposes a case where LoopFusion is querying SCEV; // with malformed loop information during the midst of the transform.; // There doesn't appear to be an obvious fix, so for the moment bailout; // until the caller issue can be fixed. PR49566 tracks the bug.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:93,expose,exposes,93,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['expose'],['exposes']
Security,"// NOTE: VC++ treats enums as signed, avoid using the AccessControl enum",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:54,Access,AccessControl,54,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,1,['Access'],['AccessControl']
Security,// NOTE: We may write this as an InstAlias if it's only used by AsmParser. See; // validateTargetOperandClass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86EncodingOptimization.cpp:83,validat,validateTargetOperandClass,83,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86EncodingOptimization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86EncodingOptimization.cpp,1,['validat'],['validateTargetOperandClass']
Security,"// NOTE: When replacing the mutex by a ReadWrite mutex, we **must**; // put in place the Read/Write part here. Keeping the write lock; // here is 'catasptrophic' for scaling as it means that ALL calls; // to RecursiveRemove will take the write lock and performance; // of many threads trying to access the write lock at the same; // time is relatively bad.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:295,access,access,295,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['access'],['access']
Security,"// NOTE: this uses `GetDecl()`, to capture the access of the UsingShadowDecl,; // which is defined in the derived class and might differ from the access of fd; // in the base class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingMethodInfo.cxx:47,access,access,47,core/metacling/src/TClingMethodInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingMethodInfo.cxx,2,['access'],['access']
Security,"// NVPTX doesn't currently support sanitizers. Bailing out here means; // that e.g. -fsanitize=address applies only to host code, which is what we; // want for now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:35,sanitiz,sanitizers,35,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['sanitiz'],['sanitizers']
Security,"// Name mismatch. We need a redirect. First grab the actual entry we want; // to return.; //; // This redirection logic intentionally leaks the external name of a; // redirected file that uses 'use-external-name' in \a; // vfs::RedirectionFileSystem. This allows clang to report the external; // name to users (in diagnostics) and to tools that don't have access to; // the VFS (in debug info and dependency '.d' files).; //; // FIXME: This is pretty complex and has some very complicated interactions; // with the rest of clang. It's also inconsistent with how ""real""; // filesystems behave and confuses parts of clang expect to see the; // name-as-accessed on the \a FileEntryRef.; //; // A potential plan to remove this is as follows -; // - Update callers such as `HeaderSearch::findUsableModuleForHeader()`; // to explicitly use the `getNameAsRequested()` rather than just using; // `getName()`.; // - Add a `FileManager::getExternalPath` API for explicitly getting the; // remapped external filename when there is one available. Adopt it in; // callers like diagnostics/deps reporting instead of calling; // `getName()` directly.; // - Switch the meaning of `FileEntryRef::getName()` to get the requested; // name, not the external name. Once that sticks, revert callers that; // want the requested name back to calling `getName()`.; // - Update the VFS to always return the requested name. This could also; // return the external name, or just have an API to request it; // lazily. The latter has the benefit of making accesses of the; // external path easily tracked, but may also require extra work than; // just returning up front.; // - (Optionally) Add an API to VFS to get the external filename lazily; // and update `FileManager::getExternalPath()` to use it instead. This; // has the benefit of making such accesses easily tracked, though isn't; // necessarily required (and could cause extra work than just adding to; // eg. `vfs::Status` up front).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:356,access,access,356,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,4,['access'],"['access', 'accessed', 'accesses']"
Security,"// Namespace with helper functions that have STL stuff that we don't want to expose to CINT",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx:77,expose,expose,77,roofit/roofitcore/src/RooProduct.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx,1,['expose'],['expose']
Security,"// Naming class to use for access check. In most cases it was provided; // explicitly (e.g. member access (lhs.foo) or qualified lookup (X::)),; // for unqualified lookup we fallback to the \p Ctx in which we found the; // member.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:27,access,access,27,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,2,['access'],['access']
Security,// NamingClass and BaseType are used for access-checking. See; // Sema::IsSimplyAccessible for details.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:41,access,access-checking,41,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['access'],['access-checking']
Security,"// Naturally aligned access is fastest. However, also report it is Fast; // if memory is aligned less than DWORD. A narrow load or store will be; // be equally slow as a single ds_read_b128/ds_write_b128, but there; // will be more of them, so overall we will pay less penalty issuing a; // single instruction.; // See comment on the values above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:21,access,access,21,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['access'],['access']
Security,"// Naturally aligned access is fastest. However, also report it is Fast; // if memory is aligned less than DWORD. A narrow load or store will be; // be equally slow as a single ds_read_b96/ds_write_b96, but there will; // be more of them, so overall we will pay less penalty issuing a single; // instruction.; // See comment on the values above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:21,access,access,21,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['access'],['access']
Security,"// Need accesses with constant stride. We don't want to vectorize; // ""A[B[i]] += ..."" and similar code or pointer arithmetic that could wrap; // in the address space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:8,access,accesses,8,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['access'],['accesses']
Security,"// Need queue_ptr anyway. But under V5, we also need implicitarg_ptr to access; // queue_ptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAttributor.cpp:72,access,access,72,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAttributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAttributor.cpp,1,['access'],['access']
Security,// Need to be accessed from MachineInstr::setDesc.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:14,access,accessed,14,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['access'],['accessed']
Security,"// Need to lock access to TROOT::GetListOfClasses so the cloning happens atomically",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:16,access,access,16,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['access'],['access']
Security,"// Need to open ourselves, because we need to hand the FD to OpenMarker() and; // raw_fd_ostream doesn't expose the FD.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderPerf.cpp:105,expose,expose,105,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderPerf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderPerf.cpp,2,['expose'],['expose']
Security,// Needs accesses where the addresses of the accessed underlying objects do; // not change within the loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:9,access,accesses,9,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,2,['access'],"['accessed', 'accesses']"
Security,"// Needs direct access to private members to initialize its four states.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/RanluxppEngineImpl.cxx:16,access,access,16,math/mathcore/src/RanluxppEngineImpl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/RanluxppEngineImpl.cxx,1,['access'],['access']
Security,// New Access should not have more power than template access,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:7,Access,Access,7,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,2,"['Access', 'access']","['Access', 'access']"
Security,"// New authentication: Fill a SecContext for cleanup; // in case of interrupt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/DaemonUtils.cxx:7,authenticat,authentication,7,net/rpdutils/src/DaemonUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/DaemonUtils.cxx,1,['authenticat'],['authentication']
Security,"// New or changed file: validate",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofPerfAnalysis.cxx:24,validat,validate,24,proof/proofbench/src/TProofPerfAnalysis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofPerfAnalysis.cxx,1,['validat'],['validate']
Security,// Newer PPC supports unaligned memory access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:39,access,access,39,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,1,['access'],['access']
Security,"// Next sequence with the same hash on zName",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx:31,hash,hash,31,gui/guihtml/src/TGHtmlParse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx,1,['hash'],['hash']
Security,"// Next, check if there are any MemoryDefs that are on the path through; // the loop (in the Seen set) and they may-alias any of the locations in; // AccessedLocs. If that is the case, they may modify the condition and; // partial unswitching is not possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:150,Access,AccessedLocs,150,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,1,['Access'],['AccessedLocs']
Security,"// Next, delete all memory accesses in each block",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:27,access,accesses,27,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['access'],['accesses']
Security,"// Next, we want to figure out all of the sets to which we might belong.; // We might belong to a set if the noalias argument is in the set of; // underlying objects. If there is some non-noalias argument in our list; // of underlying objects, then we cannot add a scope because the fact; // that some access does not alias with any set of our noalias arguments; // cannot itself guarantee that it does not alias with this access; // (because there is some pointer of unknown origin involved and the; // other access might also depend on this pointer). We also cannot add; // scopes to arbitrary functions unless we know they don't access any; // non-parameter pointer-values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:302,access,access,302,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,4,['access'],['access']
Security,"// No Hash Table, We need to search through all names in the Name Index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFAcceleratorTable.cpp:6,Hash,Hash,6,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFAcceleratorTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFAcceleratorTable.cpp,1,['Hash'],['Hash']
Security,// No additional validation required.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:17,validat,validation,17,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['validat'],['validation']
Security,"// No authentication available for re-use",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:6,authenticat,authentication,6,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['authenticat'],['authentication']
Security,"// No contiguous memory, but resize is possible; // Hence accessing objects using At(i) should be not too much an overhead",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TGenCollectionStreamer.cxx:58,access,accessing,58,io/io/src/TGenCollectionStreamer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TGenCollectionStreamer.cxx,3,['access'],['accessing']
Security,"// No dependence if the scaled distance is not multiple of the stride.; // E.g.; // for (i = 0; i < 1024 ; i += 4); // A[i+2] = A[i] + 1;; //; // Two accesses in memory (scaled distance is 2, stride is 4):; // | A[0] | | | | A[4] | | | |; // | | | A[2] | | | | A[6] | |; //; // E.g.; // for (i = 0; i < 1024 ; i += 3); // A[i+4] = A[i] + 1;; //; // Two accesses in memory (scaled distance is 4, stride is 3):; // | A[0] | | | A[3] | | | A[6] | | |; // | | | | | A[4] | | | A[7] | |",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:150,access,accesses,150,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,2,['access'],['accesses']
Security,// No flat_scr on SI.; // On GFX10Plus flat scratch is not a valid register operand and can only be; // accessed with s_setreg/s_getreg.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:104,access,accessed,104,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,1,['access'],['accessed']
Security,"// No hash entry, no caching!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:6,hash,hash,6,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,1,['hash'],['hash']
Security,"// No hash table present",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooLinkedList.cxx:6,hash,hash,6,roofit/roofitcore/src/RooLinkedList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooLinkedList.cxx,1,['hash'],['hash']
Security,// No meaningful validation to do here for llvm.coro.id.unique.once.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/Coroutines.cpp:17,validat,validation,17,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/Coroutines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/Coroutines.cpp,1,['validat'],['validation']
Security,"// No need to keep track of the class in write mode; // fClassMap->Add(hash, (Long_t)obj, (Long_t)((TObject*)obj)->IsA());",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx:71,hash,hash,71,io/io/src/TBufferFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx,1,['hash'],['hash']
Security,"// No need to keep track of the class in write mode; // fClassMap->Add(hash, (Longptr_t)obj, (Longptr_t)((TObject*)obj)->IsA());",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferIO.cxx:71,hash,hash,71,io/io/src/TBufferIO.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferIO.cxx,1,['hash'],['hash']
Security,"// No need to keep track of the class in write mode; // fClassMap->Add(hash, (Longptr_t)obj, (Longptr_t)cl);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferIO.cxx:71,hash,hash,71,io/io/src/TBufferIO.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferIO.cxx,1,['hash'],['hash']
Security,"// No need to validate the address here, if we are a member of a split ClonesArray,; // fID is positive; // ValidateAddress();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:14,validat,validate,14,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,2,"['Validat', 'validat']","['ValidateAddress', 'validate']"
Security,// No other validation to perform.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:12,validat,validation,12,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['validat'],['validation']
Security,// No pattern validation check possible for values of fixed immediate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp:14,validat,validation,14,interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp,1,['validat'],['validation']
Security,// No point folding accesses if there isn't at least two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CleanupLocalDynamicTLSPass.cpp:20,access,accesses,20,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CleanupLocalDynamicTLSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CleanupLocalDynamicTLSPass.cpp,3,['access'],['accesses']
Security,// No v6M core supports unaligned memory access (v6M ARM ARM A3.2).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:41,access,access,41,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,1,['access'],['access']
Security,// No validation necessary for now.; // No cleanup to do for now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprConstant.cpp:6,validat,validation,6,interpreter/llvm-project/clang/lib/CodeGen/CGExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprConstant.cpp,1,['validat'],['validation']
Security,"// No-one ever wants a using-declaration to name an injected-class-name; // of a base class, unless they're declaring an inheriting constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:52,inject,injected-class-name,52,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['inject'],['injected-class-name']
Security,// Node accessors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:8,access,accessors,8,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,1,['access'],['accessors']
Security,"// Nodes are named objects in a THashList.; // We must update the hashlist if we change the name",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TNode.cxx:66,hash,hashlist,66,graf3d/g3d/src/TNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TNode.cxx,2,['hash'],['hashlist']
Security,// Non aliasing stores to different objects don't overlap. Note that; // if the killing store is known to overwrite whole object (out of; // bounds access overwrites whole object as well) then it is assumed to; // completely overwrite any store to the same object even if they don't; // actually alias (see next check).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:148,access,access,148,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,1,['access'],['access']
Security,// Non power of two memory access is never legal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp:27,access,access,27,interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsLegalizerInfo.cpp,1,['access'],['access']
Security,// Non-PIC code defaults to -fdirect-access-external-data while PIC code; // defaults to -fno-direct-access-external-data. Pass the option if different; // from the default.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:37,access,access-external-data,37,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,2,['access'],['access-external-data']
Security,"// Non-entry functions have no special inputs for now, other registers; // required for scratch access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp:96,access,access,96,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.cpp,1,['access'],['access']
Security,// Normal floats need their exponent and significand hashed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:53,hash,hashed,53,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['hash'],['hashed']
Security,// Normal property access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:19,access,access,19,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['access'],['access']
Security,"// Normally you can't use a MappedBlockStream without having fully parsed the; // PDB file, because it accesses the directory and various other things, which; // is exactly what we are attempting to parse. By specifying a custom; // subclass of IPDBStreamData which only accesses the fields that have already; // been parsed, we can avoid this and reuse MappedBlockStream.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBFile.cpp:103,access,accesses,103,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBFile.cpp,2,['access'],['accesses']
Security,// Not a bitfield.; // validate II.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:23,validat,validate,23,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['validat'],['validate']
Security,"// Not a command: sanitize string",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TProofProgressLog.cxx:18,sanitiz,sanitize,18,gui/sessionviewer/src/TProofProgressLog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TProofProgressLog.cxx,1,['sanitiz'],['sanitize']
Security,// Not a pointer access,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:17,access,access,17,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['access'],['access']
Security,"// Not all the transforms below are correct for non-integral pointers, bail; // until we've audited the individual pieces.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:92,audit,audited,92,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,1,['audit'],['audited']
Security,"// Not owning lists, don't call Delete(); // But this still need to be done first because the TList destructor; // does access the object contained (via GetObject()->TestBit(kCanDelete))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:120,access,access,120,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['access'],['access']
Security,// Not preserve stack space within prologue for outgoing variables when the; // function contains variable size objects or there are vector objects accessed; // by the frame pointer.; // Let eliminateCallFramePseudoInstr preserve stack space for it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:148,access,accessed,148,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['access'],['accessed']
Security,"// Note that AccessPathName returns FALSE if the dir DOES exist",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/test/TChainParsing.cxx:13,Access,AccessPathName,13,tree/tree/test/TChainParsing.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/test/TChainParsing.cxx,1,['Access'],['AccessPathName']
Security,// Note that Fuchsia never needs to link in sanitizer runtime deps. Any; // sanitizer runtimes with system dependencies use the `.deplibs` feature; // instead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Fuchsia.cpp:44,sanitiz,sanitizer,44,interpreter/llvm-project/clang/lib/Driver/ToolChains/Fuchsia.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Fuchsia.cpp,2,['sanitiz'],['sanitizer']
Security,"// Note that LC_ENCRYPTION_INFO.cryptoff despite its name and the comment in; // <mach-o/loader.h> is not an offset in the binary file, instead, it is a; // relative virtual address. At the moment modification of the __TEXT; // segment of executables isn't supported anyway (e.g. data in code entries; // are not recalculated). Moreover, in general; // LC_ENCRYPT_INFO/LC_ENCRYPTION_INFO_64 are nontrivial to update because; // without making additional assumptions (e.g. that the entire __TEXT; // segment should be encrypted) we do not know how to recalculate the; // boundaries of the encrypted part. For now just copy over these load; // commands until we encounter a real world usecase where; // LC_ENCRYPT_INFO/LC_ENCRYPTION_INFO_64 need to be adjusted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOLayoutBuilder.cpp:517,encrypt,encrypted,517,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOLayoutBuilder.cpp,2,['encrypt'],['encrypted']
Security,"// Note that besides deserialization, this also performs the conversion for; // indirect call targets. The function pointers from the raw profile are; // remapped into function name hashes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp:182,hash,hashes,182,interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp,1,['hash'],['hashes']
Security,"// Note that each TChainElement returned by TChain::GetListOfFiles has a name; // equal to the tree name of this TChain and a title equal to the filename.; // Accessing the information like this ensures that we get the correct; // filenames and treenames if the treename is given as part of the filename; // via chain.AddFile(file.root/myTree) and as well if the tree name is given; // in the constructor via TChain(myTree) and a file is added later by chain.AddFile(file.root).; // Caveat: The chain may be made of sub-trees with different names. All; // tree names need to be retrieved separately, see below.; // Get filelist of the current chain",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx:159,Access,Accessing,159,tree/tree/src/InternalTreeUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx,1,['Access'],['Accessing']
Security,"// Note that even though we use the live on entry def as a representative; // MemoryAccess, it is *not* the same as the actual live on entry def. We; // have no real equivalent to poison for MemoryAccesses, and so we really; // should be checking whether the MemoryAccess is top if we want to know if it; // is equivalent to everything. Otherwise, what this really signifies is that; // the access ""it reaches all the way back to the beginning of the function""; // Initialize all other instructions to be in TOP class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:391,access,access,391,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['access'],['access']
Security,"// Note that every Access object corresponds to a unique Value, and only; // accesses to the same Value are merged. Hence we assume that all ranges; // are the same size. If ranges can be different size, then the contents; // must be dropped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:19,Access,Access,19,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,2,"['Access', 'access']","['Access', 'accesses']"
Security,"// Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; // However, direct access to fClassVersion should be replaced by calls to GetClassVersion to set fVersionUsed.; // Even with such a change the code here and in these functions need to be reviewed as a cursory look seem; // to indicates they are not yet properly protection against mutli-thread access.; //; // However, the use of these functions is rare and mostly done at library loading time which should; // in almost all cases preceeds the possibility of GetStreamerInfo being called from multiple thread; // on that same TClass object.; //; // Summary: need careful review but risk of problem is extremely low.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:17,access,access,17,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,3,['access'],['access']
Security,"// Note that the fInFlightClusters is accessed concurrently only by the I/O thread. The I/O thread; // never changes the structure of the in-flight clusters array (it does not add, remove, or swap elements).; // Therefore, it is safe to access the element pointed to by itr here even after fLockWorkQueue; // is released. We need to release the lock before potentially blocking on the cluster future.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:38,access,accessed,38,tree/ntuple/v7/src/RClusterPool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx,2,['access'],"['access', 'accessed']"
Security,"// Note that we do not check access along this path; other than that,; // this is the same as shouldDeleteForSubobjectCall(Base, BaseCtor, false);; // FIXME: Check that the base has a usable destructor! Sink this into; // shouldDeleteForClassSubobject.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:29,access,access,29,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['access'],['access']
Security,// Note that we modify the path's Access field to the; // friend-modified access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:34,Access,Access,34,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,2,"['Access', 'access']","['Access', 'access']"
Security,"// Note the hash is recalculated potentially multiple times, but it is cheap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:12,hash,hash,12,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,1,['hash'],['hash']
Security,"// Note the order here, the Usr access might change the map, CurPtr is; // already in it though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:32,access,access,32,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,2,['access'],['access']
Security,"// Note, deque is being used here because there is significant performance; // gains over vector when the container becomes very large due to the; // specific access patterns. For more information see the mailing list; // discussion on this:; // http://lists.llvm.org/pipermail/llvm-commits/Week-of-Mon-20120116/135228.html",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:159,access,access,159,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['access'],['access']
Security,"// Note: C++ [expr.mptr.oper]p2-3 says that the class type into which the; // member pointer points must be completely-defined. However, there is no; // reason for this semantic distinction, and the rule is not enforced by; // other compilers. Therefore, we do not check this property, as it is; // likely to be considered a defect.; // C++ 5.5p2; // [...] to its first operand, which shall be of class T or of a class of; // which T is an unambiguous and accessible base class. [p3: a pointer to; // such a class]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:456,access,accessible,456,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['access'],['accessible']
Security,"// Note: For QoI reasons, the things we use as a hash here should all be; // dumped via the -module-info flag.; // Start the signature with the compiler version.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:49,hash,hash,49,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['hash'],['hash']
Security,// Note: Keeping the following as multiple 'if' statements rather than; // merging to a single expression for readability.; //; // Argument access should always use the FP.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:140,access,access,140,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['access'],['access']
Security,"// Note: No fusion-preventing memory dependencies are expected in either; // region. Such dependencies should be rejected during earlier dependence; // checks, which guarantee accesses can be re-ordered for vectorization.; //; // Move recipes to the successor region.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:176,access,accesses,176,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,1,['access'],['accesses']
Security,"// Note: Originally an fPackageLock->Unlock() call was made; // after the if-else statement below. With multilevel masters,; // submasters still check to make sure the package exists with; // the correct md5 checksum and need to do a read lock there.; // As yet locking is not that sophisicated so the lock must; // be released below before the call to fProof->UploadPackage().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:208,checksum,checksum,208,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['checksum'],['checksum']
Security,// Note: The SystemZLDCleanupPass will remove redundant computations; // of the module base offset. Count total number of local-dynamic; // accesses to trigger execution of that pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:140,access,accesses,140,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['access'],['accesses']
Security,// Note: This function is exposed externally by AtomicExpandUtils.h,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:26,expose,exposed,26,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,1,['expose'],['exposed']
Security,"// Note: This may invalidate `dst_node` so has to happen after any access to it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/bvh.h:67,access,access,67,geom/geom/inc/bvh/v2/bvh.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/bvh.h,1,['access'],['access']
Security,"// Note: We lower an unmasked unaligned vector access to an equally sized; // e8 element type access. Given this, we effectively support all unmasked; // misaligned accesses. TODO: Work through the codegen implications of; // allowing such accesses to be formed, and considered fast.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:47,access,access,47,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,4,['access'],"['access', 'accesses']"
Security,"// Note: as an egregious but useful hack we use the real path here, because; // frameworks moving between top-level frameworks to embedded frameworks tend; // to be symlinked, and we base the logical structure of modules on the; // physical layout. In particular, we need to deal with crazy includes like; //; // #include <Foo/Frameworks/Bar.framework/Headers/Wibble.h>; //; // where 'Bar' used to be embedded in 'Foo', is now a top-level framework; // which one should access with, e.g.,; //; // #include <Bar/Wibble.h>; //; // Similar issues occur when a top-level framework has moved into an; // embedded framework.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:470,access,access,470,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,1,['access'],['access']
Security,"// Note: getStrideFromPointer is a *profitability* heuristic. We; // could broaden the scope of values returned here - to anything; // which happens to be loop invariant and contributes to the; // computation of an interesting IV - but we chose not to as we; // don't have a cost model here, and broadening the scope exposes; // far too many unprofitable cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:317,expose,exposes,317,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['expose'],['exposes']
Security,"// Note: this adds pointers to the hash using sizes and endianness that; // depend on the host. It doesn't matter, however, because hashing on; // pointer values is inherently unstable. Nothing should depend on the; // ordering of nodes in the folding set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:35,hash,hash,35,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,2,['hash'],"['hash', 'hashing']"
Security,// Nothing to do if the access uses the desired; // container width and is naturally aligned.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp:24,access,access,24,interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp,1,['access'],['access']
Security,// Nothing to promote...; // Discard any sets for which there is an aliasing non-promotable access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:92,access,access,92,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['access'],['access']
Security,"// Notify authentication to client ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:10,authenticat,authentication,10,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,2,['authenticat'],['authentication']
Security,"// Now access entry or scan over entries",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:7,access,access,7,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,2,['access'],['access']
Security,// Now adjust things to handle the lane access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:40,access,access,40,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['access'],['access']
Security,"// Now all relevant types are complete, check the destructors are accessible; // and non-deleted, and annotate them on the temporaries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:66,access,accessible,66,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['access'],['accessible']
Security,"// Now clean up any handle-access instructions; // This is needed in debug mode when code cleanup passes are not executed,; // but we need the handle access to be eliminated because they are not; // valid instructions when image handles are disabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp:27,access,access,27,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp,2,['access'],['access']
Security,"// Now for all defs in BlocksWithDefsToReplace, if there are uses they no; // longer dominate, replace those with the closest dominating def.; // This will also update optimized accesses, as they're also uses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:178,access,accesses,178,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['access'],['accesses']
Security,"// Now get the password either from prompt or from memory, if saved already",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:15,password,password,15,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['password'],['password']
Security,// Now handle argument memory if it might be accessed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:45,access,accessed,45,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['access'],['accessed']
Security,// Now handle global memory if it might be accessed. This is slightly tricky; // as NO_GLOBAL_MEM has multiple bits set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:43,access,accessed,43,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['access'],['accessed']
Security,"// Now look at the instruction opcode. If it is a memory access; // instruction, update the upper-bound of the appropriate counter's; // bracket and the destination operand scores.; // TODO: Use the (TSFlags & SIInstrFlags::DS_CNT) property everywhere.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:57,access,access,57,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['access'],['access']
Security,"// Now modify the original list to represent the final order that; // we want. The order will depend on whether we're going to access them; // from the stack pointer or the frame pointer. For SP, the list should; // end up with the END containing objects that we want with smaller offsets.; // For FP, it should be flipped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:127,access,access,127,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['access'],['access']
Security,// Now populate the list of newly exposed call sites.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:34,expose,exposed,34,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['expose'],['exposed']
Security,"// Now push the high registers; // There are no store instructions that can access high registers directly,; // so we have to move them to low registers, and push them.; // This might take multiple pushes, as it is possible for there to; // be fewer low registers available than high registers which need saving.; // Find the first register to save.; // Registers must be processed in reverse order so that in case we need to use; // multiple PUSH instructions, the order of the registers on the stack still; // matches the unwind info. They need to be swicthed back to ascending order; // before adding to the PUSH instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp:76,access,access,76,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,1,['access'],['access']
Security,"// Now that the extend is gone, we want to expose it's uses for potential; // further simplification. We don't need to directly inform SimplifyIVUsers; // of the new users, because their parent IV will be processed later as a; // new loop phi. If we preserved IVUsers analysis, we would also want to; // push the uses of WideDef here.; // No further widening is needed. The deceased [sz]ext had done it for us.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:43,expose,expose,43,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,1,['expose'],['expose']
Security,"// Now that we have the GVNs for the incoming values, we are going to combine; // them with the GVN of the incoming bock, and the output location of the; // PHINode to generate a hash value representing this instance of the PHINode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:179,hash,hash,179,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,1,['hash'],['hash']
Security,"// Now the chunk_state is clear, and we have more input. If there's more than; // a single chunk (so, definitely not the root chunk), hash the largest whole; // subtree we can, with the full benefits of SIMD (and maybe in the future,; // multi-threading) parallelism. Two restrictions:; // - The subtree has to be a power-of-2 number of chunks. Only subtrees along; // the right edge can be incomplete, and we don't know where the right edge; // is going to be until we get to finalize().; // - The subtree must evenly divide the total number of chunks up until this; // point (if total is not 0). If the current incomplete subtree is only; // waiting for 1 more chunk, we can't hash a subtree of 4 chunks. We have; // to complete the current subtree first.; // Because we might need to break up the input to form powers of 2, or to; // evenly divide what we already have, this part runs in a loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c:134,hash,hash,134,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,2,['hash'],['hash']
Security,// Now update the active member of the union to be the actual pointer-typed; // member so that accessing it indirectly through the returned address is; // valid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h:95,access,accessing,95,interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,1,['access'],['accessing']
Security,// Now validate any DPValues in the marker.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:7,validat,validate,7,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,1,['validat'],['validate']
Security,"// Now we know that each predecessor of this block has a value in; // AvailablePreds, sort them for efficient access as we're walking the preds.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:110,access,access,110,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['access'],['access']
Security,"// Now we need to insert the results for each name into the hash table. For; // constructor names and conversion function names, we actually need to merge; // all of the results for them into one list of results each and insert; // those.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:60,hash,hash,60,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['hash'],['hash']
Security,"// Now we only support PPC64, Medium code model and P9 with vector.; // We have immutable pattern to access const pool. See function; // shouldReduceRegisterPressure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:101,access,access,101,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['access'],['access']
Security,"// Now we send authentication details to access, e.g., data servers; // not in the proof cluster and to be propagated to slaves.; // This is triggered by the 'proofserv <dserv1> <dserv2> ...'; // line in .rootauthrc",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:15,authenticat,authentication,15,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,2,"['access', 'authenticat']","['access', 'authentication']"
Security,"// Now we're done adding entries, resize the bucket list if it's; // significantly too large. (This only happens if the number of; // entries is small and we're within our initial allocation of; // 64 buckets.) We aim for an occupancy ratio in [3/8, 3/4).; //; // As a special case, if there are two or fewer entries, just; // form a single bucket. A linear scan is fine in that case, and; // this is very common in C++ class lookup tables. This also; // guarantees we produce at least one bucket for an empty table.; //; // FIXME: Try computing a perfect hash function at this point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h:556,hash,hash,556,interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h,1,['hash'],['hash']
Security,"// Now, finally validate the sign-extending magic.; // `select` itself may be appropriately extended, look past that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:16,validat,validate,16,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['validat'],['validate']
Security,// Number of bits in data that are used for the sanitizer kind. Needs to match; // __sanitizer::kKindBits in compiler-rt/lib/stats/stats.h,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SanitizerStats.h:48,sanitiz,sanitizer,48,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SanitizerStats.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SanitizerStats.h,1,['sanitiz'],['sanitizer']
Security,// Number of bits in hash mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:21,hash,hash,21,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,1,['hash'],['hash']
Security,// Number of bytes of checksum.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/DebugChecksumsSubsection.cpp:22,checksum,checksum,22,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/DebugChecksumsSubsection.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/DebugChecksumsSubsection.cpp,1,['checksum'],['checksum']
Security,"// Number of security levels and masks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/AuthConst.h:13,secur,security,13,net/auth/inc/AuthConst.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/AuthConst.h,1,['secur'],['security']
Security,"// ODRHash is used to calculate a hash based on AST node contents that; // does not rely on pointer addresses. This allows the hash to not vary; // between runs and is usable to detect ODR problems in modules. To use,; // construct an ODRHash object, then call Add* methods over the nodes that; // need to be hashed. Then call CalculateHash to get the hash value.; // Typically, only one Add* call is needed. clear can be called to reuse the; // object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ODRHash.h:34,hash,hash,34,interpreter/llvm-project/clang/include/clang/AST/ODRHash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ODRHash.h,4,['hash'],"['hash', 'hashed']"
Security,"// OK, so the access is to a constant offset from Ptr. Check that Ptr is; // something we can handle and if so extract the size of this base object; // along with its alignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:14,access,access,14,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,1,['access'],['access']
Security,"// ObjC property accesses are not lvalues, but get special treatment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:17,access,accesses,17,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,1,['access'],['accesses']
Security,// ObjCAAutoRefCount and Sanitize LangOpts are used to setup the; // PassManager in BackendUtil.cpp. They need to be initialized no matter; // what the input type is.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:25,Sanitiz,Sanitize,25,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['Sanitiz'],['Sanitize']
Security,"// Objective-C instance variable access. Bail if we're performing fix-it; // code completion since Objective-C properties are normally backed by; // ivars, most Objective-C fix-its here would have little value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:33,access,access,33,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['access'],['access']
Security,"// Objective-C properties allow ""."" access on Objective-C pointer types,; // so adjust the base type to the object type itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:36,access,access,36,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['access'],['access']
Security,// Objective-C property access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:24,access,access,24,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['access'],['access']
Security,"// Objective-C++:; // After a '.' in a member access expression, treat the keyword; // 'class' as if it were an identifier.; //; // This hack allows property access to the 'class' method because it is; // such a common method name. For other C++ keywords that are; // Objective-C method names, one must use the message send syntax.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:46,access,access,46,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,2,['access'],['access']
Security,"// Objects referenced by writeonly GV initializer should not be; // promoted, because there is no any kind of read access to them; // on behalf of this writeonly GV. To avoid promotion we convert; // GV initializer to 'zeroinitializer'. This effectively drops; // references in IR module (not in combined index), so we can; // ignore them when computing import. We do not export references; // of writeonly object. See computeImportForReferencedGlobals",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:115,access,access,115,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,1,['access'],['access']
Security,// Offset of FileChecksum entry in File; // checksums buffer. The checksum entry then; // contains another offset into the string; // table of the actual name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugLinesSubsection.h:44,checksum,checksums,44,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugLinesSubsection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugLinesSubsection.h,2,['checksum'],"['checksum', 'checksums']"
Security,// Offset range is checked later by validator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:36,validat,validator,36,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,1,['validat'],['validator']
Security,// Offset the index constant by the vector width because we are checking for; // accesses to the 2nd vector input of the shuffle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:81,access,accesses,81,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['access'],['accesses']
Security,"// Offsets are validated during parsing, so all offsets in the container are; // valid and contain enough readable data to read a header.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/DXContainer.cpp:15,validat,validated,15,interpreter/llvm-project/llvm/lib/Object/DXContainer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/DXContainer.cpp,1,['validat'],['validated']
Security,"// Ok, now we know that all of the PHI nodes are missing entries for some; // basic blocks. Start by sorting the incoming predecessors for efficient; // access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:153,access,access,153,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['access'],['access']
Security,"// Okay, we know we have space. Find a hash bucket.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SmallPtrSet.cpp:39,hash,hash,39,interpreter/llvm-project/llvm/lib/Support/SmallPtrSet.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SmallPtrSet.cpp,1,['hash'],['hash']
Security,"// Okay, we're going to make a redeclaration. If this is some kind; // of reference, make sure we build the redeclaration in the same DC; // as the original, and ignore the current access specifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:181,access,access,181,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['access'],['access']
Security,"// Old Notes:; // The return of calloc is aligned with std::max_align_t.; // If/whe al > std::max_align_t we need to adjust.; // The layout for the Magic, Stat and Size is:; // [0 : sizeof(std::max_align_t) [ -> Record `size`; // [sizeof(std::max_align_t) : same + size ] -> Real data; lower bound id return value; // [sizeof(std::max_align_t) + size : same + 1 [ -> MEM_MAGIC / Integrity marker; // We need sizeof(size_t) <= sizeof(std::max_align_t); //; // New Notes:; // The return of calloc is aligned with std::max_align_t.; // If/whe al > std::max_align_t we need to adjust.; // The layout for the Offset, Magic, Stat and Size is:; // [0 : returned ptr value - sizeof(size_t) * 3 [ -> Unused; Usually of size 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/newdelete/src/NewDelete.cxx:379,Integrity,Integrity,379,core/newdelete/src/NewDelete.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/newdelete/src/NewDelete.cxx,1,['Integrity'],['Integrity']
Security,"// Old initialization for ALICE.; // Left as an example.; /*; // Check if REVESYS exists, try fallback to $ALICE_ROOT/EVE.; if(gSystem->Getenv(""REVESYS"") == 0) {; if(gSystem->Getenv(""ALICE_ROOT"") != 0) {; Info(eh.Data(), ""setting REVESYS from ALICE_ROOT."");; gSystem->Setenv(""REVESYS"", Form(""%s/EVE"", gSystem->Getenv(""ALICE_ROOT"")));; } else {; Error(eh.Data(), ""REVESYS not defined, neither is ALICE_ROOT."");; gSystem->Exit(1);; }; }; if(gSystem->AccessPathName(gSystem->Getenv(""REVESYS"")) == kTRUE) {; Error(eh.Data(), ""REVESYS '%s' does not exist."", gSystem->Getenv(""REVESYS""));; gSystem->Exit(1);; }. TString macPath(gROOT->GetMacroPath());; macPath += Form("":%s/macros"", gSystem->Getenv(""REVESYS""));; gInterpreter->AddIncludePath(gSystem->Getenv(""REVESYS""));; if(gSystem->Getenv(""ALICE_ROOT"") != 0) {; macPath += Form("":%s/alice-macros"", gSystem->Getenv(""REVESYS""));; gInterpreter->AddIncludePath(Form(""%s/include"", gSystem->Getenv(""ALICE_ROOT"")));; gInterpreter->AddIncludePath(gSystem->Getenv(""ALICE_ROOT""));; }; gROOT->SetMacroPath(macPath);; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveUtil.cxx:448,Access,AccessPathName,448,graf3d/eve/src/TEveUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveUtil.cxx,1,['Access'],['AccessPathName']
Security,"// Old ptx versions have a bug. When PTX code takes address of; // byval parameter with alignment < 4, ptxas generates code to; // spill argument into memory. Alas on sm_50+ ptxas generates; // SASS code that fails with misaligned access. To work around; // the problem, make sure that we align byval parameters by at; // least 4. This bug seems to be fixed at least starting from; // ptxas > 9.0.; // TODO: remove this after verifying the bug is not reproduced; // on non-deprecated ptxas versions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:231,access,access,231,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,1,['access'],['access']
Security,"// On AIX, the variable offset should already be in R4 and the region handle; // should already be in R3.; // For TLSGD, which currently is the only supported access model, we only; // need to generate an absolute branch to .__tls_get_addr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:159,access,access,159,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,1,['access'],['access']
Security,"// On COFF, if the section name contains '$', it is highly likely that the; // user is using section sorting to create an array of globals similar to; // the way initialization callbacks are registered in .init_array and; // .CRT$XCU. The ATL also registers things in .ATL$__[azm]. Adding redzones; // to such globals is counterproductive, because the intent is that they; // will form an array, and out-of-bounds accesses are expected.; // See https://github.com/google/sanitizers/issues/305; // and http://msdn.microsoft.com/en-US/en-en/library/bb918180(v=vs.120).aspx",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:414,access,accesses,414,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,2,"['access', 'sanitiz']","['accesses', 'sanitizers']"
Security,"// On Darwin, unlike other Itanium C++ ABI platforms, the thread-wrapper; // function is only defined alongside the variable, not also alongside; // callers. Normally, all accesses to a thread_local go through the; // thread-wrapper in order to ensure initialization has occurred, underlying; // variable will never be used other than the thread-wrapper, so it can be; // converted to internal linkage.; //; // However, if the variable has the 'constinit' attribute, it _can_ be; // referenced directly, without calling the thread-wrapper, so the linkage; // must not be changed.; //; // Additionally, if the variable isn't plain external linkage, e.g. if it's; // weak or linkonce, the de-duplication semantics are important to preserve,; // so we don't change the linkage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:172,access,accesses,172,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['access'],['accesses']
Security,"// On Darwin/X86-64, we need to use foo@GOTPCREL+4 to access the got entry; // from a data section. In case there's an additional offset, then use; // foo@GOTPCREL+4+<offset>.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetObjectFile.cpp:54,access,access,54,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetObjectFile.cpp,1,['access'],['access']
Security,"// On ELF platforms, we're further restricted in that we can't; // increase the alignment of any variable which might be emitted; // into a shared library, and which is exported. If the main; // executable accesses a variable found in a shared-lib, the main; // exe actually allocates memory for and exports the symbol ITSELF,; // overriding the symbol found in the library. That is, at link; // time, the observed alignment of the variable is copied into the; // executable binary. (A COPY relocation is also generated, to copy; // the initial data from the shadowed variable in the shared-lib; // into the location in the main binary, before running code.); //; // And thus, even though you might think you are defining the; // global, and allocating the memory for the global in your object; // file, and thus should be able to set the alignment arbitrarily,; // that's not actually true. Doing so can cause an ABI breakage; an; // executable might have already been built with the previous; // alignment of the variable, and then assuming an increased; // alignment will be incorrect.; // Conservatively assume ELF if there's no parent pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp:206,access,accesses,206,interpreter/llvm-project/llvm/lib/IR/Globals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp,1,['access'],['accesses']
Security,"// On some 'newer' platform (Fedora Core 17+, Ubuntu 12), the; // initialization order is (by default?) is 'wrong' and so we can't; // delete the interpreter now .. because any of the static in the; // interpreter's library have already been deleted.; // On the link line, we must list the most dependent .o file; // and end with the least dependent (LLVM libraries), unfortunately,; // Fedora Core 17+ or Ubuntu 12 will also execute the initialization; // in the same order (hence doing libCore's before LLVM's and; // vice et versa for both the destructor. We worked around the; // initialization order by delay the TROOT creation until first use.; // We can not do the same for destruction as we have no way of knowing; // the last access ...; // So for now, let's avoid delete TCling except in the special build; // checking the completeness of the termination deletion.; // TODO: Should we do more cleanup here than just call delete?; // Segfaults rootcling in some cases, debug and uncomment:; //; // delete fInterpreter;; // We cannot delete fCleanups because of the logic in atexit which needs it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:735,access,access,735,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['access'],['access']
Security,// Once a may-aliasing def is encountered do not set an optimized; // access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:70,access,access,70,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,1,['access'],['access']
Security,// Once we know the exact type of the function then do validation check on; // all the given constraints.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:55,validat,validation,55,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,1,['validat'],['validation']
Security,"// One byte each for checksum size and kind, then align to 4 bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp:21,checksum,checksum,21,interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,1,['checksum'],['checksum']
Security,// One byte each for checksum size and kind.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp:21,checksum,checksum,21,interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,1,['checksum'],['checksum']
Security,// Only Token that was validated as a string and begins with '<'; // is considered altMacroString!!!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:23,validat,validated,23,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,1,['validat'],['validated']
Security,// Only add subobjects which have public access throughout the entire chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:41,access,access,41,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['access'],['access']
Security,// Only applies to instance accesses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:28,access,accesses,28,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['access'],['accesses']
Security,// Only calculate hash on first call of getODRHash per record.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:18,hash,hash,18,interpreter/llvm-project/clang/lib/AST/Decl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp,4,['hash'],['hash']
Security,"// Only care about pointer arguments. If a noalias argument is; // accessed through a non-pointer argument, it must be captured; // first (e.g. via ptrtoint), and we protect against captures below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:67,access,accessed,67,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['access'],['accessed']
Security,// Only certain substreams are guaranteed to be aligned. Validate; // them here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/DbiStream.cpp:57,Validat,Validate,57,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/DbiStream.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/DbiStream.cpp,1,['Validat'],['Validate']
Security,// Only check access if all of that succeeded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:14,access,access,14,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['access'],['access']
Security,// Only do this when A has multiple uses. This is most important to do; // when it exposes other optimizations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:83,expose,exposes,83,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['expose'],['exposes']
Security,// Only enabled preserved access index region when debuginfo; // is available as debuginfo is needed to preserve user-level; // access pattern.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:26,access,access,26,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,2,['access'],['access']
Security,"// Only examine the first ""base"" operand of each instruction, on the; // assumption that it represents the real base address of the memory access.; // Other operands are typically offsets or indices from this base address.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:139,access,access,139,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,2,['access'],['access']
Security,"// Only in -g mode...; // Check to make sure that there are no uses of this value that are still; // around when the value is destroyed. If there are, then we have a dangling; // reference and something is wrong. This code is here to print out where; // the value is still being referenced.; //; // Note that use_empty() cannot be called here, as it eventually downcasts; // 'this' to GlobalValue (derived class of Value), but GlobalValue has already; // been destructed, so accessing it is UB.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:475,access,accessing,475,interpreter/llvm-project/llvm/lib/IR/Value.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp,1,['access'],['accessing']
Security,// Only move forward at the very end so that everything in validate; // and process gets a consistent answer about whether we're in an IT; // block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:59,validat,validate,59,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['validat'],['validate']
Security,// Only one kernel can access it,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:23,access,access,23,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['access'],['access']
Security,"// Only optimize defining access of KillingDef when directly starting at its; // defining access. The defining access also must only access KillingLoc. At; // the moment we only support instructions with a single write location, so; // it should be sufficient to disable optimizations for instructions that; // also read from memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:26,access,access,26,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,4,['access'],['access']
Security,// Only produce one access control diagnostic for a structured binding; // declaration: we don't need to tell the user that all the fields are; // inaccessible one at a time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:20,access,access,20,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['access'],['access']
Security,"// Only use file when its access rights are 0600",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:26,access,access,26,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,2,['access'],['access']
Security,// Only validate GDS for non-GWS instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:8,validat,validate,8,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,1,['validat'],['validate']
Security,// Only validate if we are using the new format.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:8,validat,validate,8,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,1,['validat'],['validate']
Security,"// Only write out all the fields except 'HashOffset', 'MemProfOffset',; // 'BinaryIdOffset' and `TemporalProfTracesOffset`. We need to remember the; // offset of these fields to allow back patching later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp:41,Hash,HashOffset,41,interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,1,['Hash'],['HashOffset']
Security,"// OpAccessChain could be used for OpenCL, but the SPIRV-LLVM Translator only; // relies on PtrAccessChain, so we'll try not to deviate. For Vulkan however,; // we have to use Op[InBounds]AccessChain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:188,Access,AccessChain,188,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,1,['Access'],['AccessChain']
Security,"// Open authenticated connection to remote PROOF slave server.; // If a connection was already open (fSocket != 0), re-use it; // to perform authentication (optimization needed to avoid a double; // opening in case this is called by TXSlave).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TSlave.cxx:8,authenticat,authenticated,8,proof/proof/src/TSlave.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TSlave.cxx,2,['authenticat'],"['authenticated', 'authentication']"
Security,// Open the secure log file if we haven't already.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/DarwinAsmParser.cpp:12,secur,secure,12,interpreter/llvm-project/llvm/lib/MC/MCParser/DarwinAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/DarwinAsmParser.cpp,1,['secur'],['secure']
Security,// OpenCL C v3.0 s6.7.5 - The generic address space requires support for; // OpenCL C 2.0 or OpenCL C 3.0 with the __opencl_c_generic_address_space; // feature; // OpenCL C v3.0 s6.2.1 - OpenCL pipes require support of OpenCL C 2.0; // or later and __opencl_c_pipes feature; // FIXME: These language options are also defined in setLangDefaults(); // for OpenCL C 2.0 but with no access to target capabilities. Target; // should be immutable once created and thus these language options need; // to be defined only once.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp:379,access,access,379,interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/TargetInfo.cpp,1,['access'],['access']
Security,// OpenCL access qualifiers,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp:10,access,access,10,interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTentative.cpp,1,['access'],['access']
Security,// OpenCL access qualifiers:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:10,access,access,10,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['access'],['access']
Security,// OpenCL usually rejects direct accesses to values of 'half' type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:33,access,accesses,33,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['access'],['accesses']
Security,"// OpenCL v1.2 s6.5.3: The __constant or constant address space name is; // used to describe variables allocated in global memory and which are; // accessed inside a kernel(s) as read-only variables. As such, variables; // in constant address space cannot have local storage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:148,access,accessed,148,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['access'],['accessed']
Security,// OpenCL v2.0 s6.6 - Access qualifier can be used only for image and pipe type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:22,Access,Access,22,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['Access'],['Access']
Security,"// OpenMP 5.2 148:21:; // If the target construct is within a class non-static member function,; // and a variable is an accessible data member of the object for which the; // non-static data member function is invoked, the variable is treated as; // if the this[:1] expression had appeared in a map clause with a map-type; // of tofrom.; // Emit this[:1]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:121,access,accessible,121,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['access'],['accessible']
Security,"// OpenMP [2.12.6, atomic Construct]; // In the next expressions:; // * x and v (as applicable) are both l-value expressions with scalar type.; // * During the execution of an atomic region, multiple syntactic; // occurrences of x must designate the same storage location.; // * Neither of v and expr (as applicable) may access the storage location; // designated by x.; // * Neither of x and expr (as applicable) may access the storage location; // designated by v.; // * expr is an expression with scalar type.; // * binop is one of +, *, -, /, &, ^, |, <<, or >>.; // * binop, binop=, ++, and -- are not overloaded operators.; // * The expression x binop expr must be numerically equivalent to x binop; // (expr). This requirement is satisfied if the operators in expr have; // precedence greater than binop, or by using parentheses around expr or; // subexpressions of expr.; // * The expression expr binop x must be numerically equivalent to (expr); // binop x. This requirement is satisfied if the operators in expr have; // precedence equal to or greater than binop, or by using parentheses around; // expr or subexpressions of expr.; // * For forms that allow multiple occurrences of x, the number of times; // that x is evaluated is unspecified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:321,access,access,321,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,2,['access'],['access']
Security,"// OpenMP [2.14.3.5, Restrictions, C++, p.1,2]; // A variable of class type (or array thereof) that appears in a; // lastprivate clause requires an accessible, unambiguous default; // constructor for the class type, unless the list item is also specified; // in a firstprivate clause.; // A variable of class type (or array thereof) that appears in a; // lastprivate clause requires an accessible, unambiguous copy assignment; // operator for the class type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:148,access,accessible,148,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,2,['access'],['accessible']
Security,"// OpenMP [2.14.3.5, Restrictions, C/C++, p.1]; // A variable of class type (or array thereof) that appears in a lastprivate; // clause requires an accessible, unambiguous default constructor for the; // class type, unless the list item is also specified in a firstprivate; // clause.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:148,access,accessible,148,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['access'],['accessible']
Security,"// OpenMP [2.14.4.1, Restrictions, C/C++, p.2]; // A variable of class type (or array thereof) that appears in a; // copyin clause requires an accessible, unambiguous copy assignment; // operator for the class type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:143,access,accessible,143,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,2,['access'],['accessible']
Security,"// OpenMP [2.6, Canonical Loop Form]; // Var is one of the following:; // A variable of signed or unsigned integer type.; // For C++, a variable of a random access iterator type.; // For C, a variable of a pointer type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:157,access,access,157,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['access'],['access']
Security,"// OpenMP [2.9.3.3, Restrictions, C/C++, p.1]; // A variable of class type (or array thereof) that appears in a private; // clause requires an accessible, unambiguous default constructor for the; // class type.; // Generate helper private variable and initialize it with the default; // value. The address of the original variable is replaced by the address of; // the new private variable in CodeGen. This new variable is not added to; // IdResolver, so the code in the OpenMP region uses original variable for; // proper diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:143,access,accessible,143,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['access'],['accessible']
Security,"// OpenMP [2.9.3.4, Restrictions, C/C++, p.1]; // A variable of class type (or array thereof) that appears in a private; // clause requires an accessible, unambiguous copy constructor for the; // class type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:143,access,accessible,143,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['access'],['accessible']
Security,"// OpenMP [2.9.3.6, Restrictions, p.2]; // A list item that appears in a reduction clause of the innermost; // enclosing worksharing or parallel construct may not be accessed in an; // explicit task.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:166,access,accessed,166,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['access'],['accessed']
Security,"// OpenMP [2.9.3.6, Restrictions, p.2]; // A list item that appears in a reduction clause of the innermost; // enclosing worksharing or parallel construct may not be accessed in; // an explicit task.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:166,access,accessed,166,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['access'],['accessed']
Security,"// OpenMP, 2.11.4 allocate Clause, Restrictions.; // For task, taskloop or target directives, allocation requests to memory; // allocators with the trait access set to thread result in unspecified; // behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:154,access,access,154,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['access'],['access']
Security,"// OpenMP, 2.9.1 Canonical Loop Form, Restrictions.; // The type of the loop iterator on which we depend may not have a random; // access iterator type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:131,access,access,131,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['access'],['access']
Security,"// Optimize (sra (sext_inreg X, i16), C) ->; // (srai (slli X, (XLen-16), (XLen-16) + C); // And (sra (sext_inreg X, i8), C) ->; // (srai (slli X, (XLen-8), (XLen-8) + C); // This can occur when Zbb is enabled, which makes sext_inreg i16/i8 legal.; // This transform matches the code we get without Zbb. The shifts are more; // compressible, and this can help expose CSE opportunities in the sdiv by; // constant optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:360,expose,expose,360,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['expose'],['expose']
Security,// Options for sanitizer coverage instrumentation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation.h:15,sanitiz,sanitizer,15,interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation.h,1,['sanitiz'],['sanitizer']
Security,"// Order an ExprWithCleanups for lifetime marks.; //; // TODO: It'll be good to have a single place to check the access of the; // destructor and generate ExprWithCleanups for various uses. Currently these; // are done in both CreateMaterializeTemporaryExpr and MaybeBindToTemporary,; // but there may be a chance to merge them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:113,access,access,113,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['access'],['access']
Security,"// Order first by hashes, then full function comparison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:18,hash,hashes,18,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,1,['hash'],['hashes']
Security,"// Order using module hash, to be both independent of module name and; // module order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:22,hash,hash,22,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['hash'],['hash']
Security,"// Originally, the function will scan all the stack objects to check whether; // if there is any scalable vector object on the stack or not. However, it; // causes errors in the register allocator. In issue 53016, it returns false; // before RA because there is no RVV stack objects. After RA, it returns true; // because there are spilling slots for RVV values during RA. It will not; // reserve BP during register allocation and generate BP access in the PEI; // pass due to the inconsistent behavior of the function.; //; // The function is changed to use hasVInstructions() as the return value. It; // is not precise, but it can make the register allocation correct.; //; // FIXME: Find a better way to make the decision or revisit the solution in; // D103622.; //; // Refer to https://github.com/llvm/llvm-project/issues/53016.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:443,access,access,443,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['access'],['access']
Security,// Other access sizes,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:9,access,access,9,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['access'],['access']
Security,// Other access to frame index,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp:9,access,access,9,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,1,['access'],['access']
Security,// Other accesses after BaseAccess that will need to be updated to use the; // postinc value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:9,access,accesses,9,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['access'],['accesses']
Security,"// Otherwise do coercion through memory. This is stupid, but; // simple.; // Generally SrcSize is never greater than DstSize, since this means we are; // losing bits. However, this can happen in cases where the structure has; // additional padding, for example due to a user specified alignment.; //; // FIXME: Assert that we aren't truncating non-padding bits when have access; // to that information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:371,access,access,371,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['access'],['access']
Security,"// Otherwise if they are both derived from the same addr-taken global, we; // can't know the two accesses don't overlap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:97,access,accesses,97,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,1,['access'],['accesses']
Security,// Otherwise inject just the new row at the end of the range.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp:13,inject,inject,13,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp,1,['inject'],['inject']
Security,"// Otherwise reject accessing it through the gp pointer. There are some; // historic cases which GCC doesn't appear to respect any more. These; // are .lit4, .lit8 and .srdata. For the moment reject these as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp:20,access,accessing,20,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetObjectFile.cpp,1,['access'],['accessing']
Security,// Otherwise we either have an upwards exposed use vreg that we need to; // materialize or need to forward the downward def from predecessors.; // Check whether we have a single vreg def from all predecessors.; // Otherwise we need a phi.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:39,expose,exposed,39,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,1,['expose'],['exposed']
Security,"// Otherwise, argument access should always use %fp.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp:23,access,access,23,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcFrameLowering.cpp,1,['access'],['access']
Security,"// Otherwise, check if the call modifies or references the; // location this memory access defines. The best we can say; // is that if the call references what this instruction; // defines, it must be clobbered by this location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:84,access,access,84,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,1,['access'],['access']
Security,"// Otherwise, check to see if we have a repeating access pattern where we can; // prove that all accesses are well aligned and dereferenceable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:50,access,access,50,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,2,['access'],"['access', 'accesses']"
Security,"// Otherwise, complain about the unknown accessor kind.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:41,access,accessor,41,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['access'],['accessor']
Security,"// Otherwise, have to walk the all access iterator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:35,access,access,35,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['access'],['access']
Security,"// Otherwise, just build an unresolved lookup expression. Suppress; // any lookup-related diagnostics; we'll hash these out later, when; // we've picked a target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:109,hash,hash,109,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['hash'],['hash']
Security,"// Otherwise, this is a set, validate and collect instruction results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:29,validat,validate,29,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,1,['validat'],['validate']
Security,"// Otherwise, use this absurdly complicated algorithm to try to; // validate the basic, low-level compatibility of the two types.; // As a minimum, require the sizes and alignments to match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:68,validat,validate,68,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['validat'],['validate']
Security,"// Otherwise, we have no instructions to issue and we have instructions; // that will fault if we don't do this right. This is the case for; // processors without pipeline interlocks and other cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:172,interlock,interlocks,172,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,2,['interlock'],['interlocks']
Security,"// Our code motion strategy implies that we can't have dependences; // between accesses in an interleaved group and other accesses located; // between the first and last member of the group. Note that this also; // means that a group can't have more than one member at a given offset.; // The accesses in a group can have dependences with other accesses, but; // we must ensure we don't extend the boundaries of the group such that; // we encompass those dependent accesses.; //; // For example, assume we have the sequence of accesses shown below in a; // stride-2 loop:; //; // (1, 2) is a group | A[i] = a; // (1); // | A[i-1] = b; // (2) |; // A[i-3] = c; // (3); // A[i] = d; // (4) | (2, 4) is not a group; //; // Because accesses (2) and (3) are dependent, we can group (2) with (1); // but not with (4). If we did, the dependent access (3) would be within; // the boundaries of the (2, 4) group.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:79,access,accesses,79,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,8,['access'],"['access', 'accesses']"
Security,"// Output checksum table offset of the given file number. It is possible that; // not all files have been registered yet, and so the offset cannot be; // calculated. In this case a symbol representing the offset is emitted, and; // the value of this symbol will be fixed up at a later time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp:10,checksum,checksum,10,interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,1,['checksum'],['checksum']
Security,"// Output the bug hash for issue unique-ing. Currently, it's just an; // offset from the beginning of the function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp:18,hash,hash,18,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/PlistDiagnostics.cpp,1,['hash'],['hash']
Security,"// Overestimate the expose region to be sure to draw an item that gets; // cut by the region",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGListTree.cxx:20,expose,expose,20,gui/gui/src/TGListTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGListTree.cxx,1,['expose'],['expose']
Security,"// Override the helper symbols injected by GenericLLVMIRPlatformSupport,; // before anything can be emitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp:31,inject,injected,31,interpreter/cling/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp,1,['inject'],['injected']
Security,// PAuthLR authentication instructions need to know the value of PC at the; // point of signing (PACI*).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.cpp:11,authenticat,authentication,11,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.cpp,1,['authenticat'],['authentication']
Security,// PC32DBL accesses require the low bit to be clear.; //; // FIXME: Explicitly check for functions: the datalayout is currently; // missing information about function pointers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp:11,access,accesses,11,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,1,['access'],['accesses']
Security,// PCrel access,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:9,access,access,9,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['access'],['access']
Security,"// PDB always uses the same string table, but each module has its own; // checksums. So we only set the strings if they're not already set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/InputFile.cpp:74,checksum,checksums,74,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/InputFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/InputFile.cpp,1,['checksum'],['checksums']
Security,// PEI::scavengeFrameVirtualRegs() cannot accurately track SPAdj because the; // call frame setup/destroy instructions have already been eliminated. That; // means the stack pointer cannot be used to access the emergency spill slot; // when !hasReservedCallFrame().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.cpp:200,access,access,200,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.cpp,2,['access'],['access']
Security,// PIC defaults to -fno-direct-access-external-data while non-PIC defaults to; // -fdirect-access-external-data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:31,access,access-external-data,31,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,2,['access'],['access-external-data']
Security,"// Packed DeclBits: HasStandaloneLexicalDC,; // isInvalidDecl, HasAttrs, isImplicit, isUsed,; // isReferenced, TopLevelDeclInObjCContainer,; // AccessSpecifier, ModuleOwnershipKind",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:144,Access,AccessSpecifier,144,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,3,['Access'],['AccessSpecifier']
Security,"// Packed DeclBits: ModuleOwnershipKind, isUsed,; // isReferenced, AccessSpecifier,; // HasStandaloneLexicalDC, HasAttrs, isImplicit,; // TopLevelDeclInObjCContainer,; // isInvalidDecl,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:67,Access,AccessSpecifier,67,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,1,['Access'],['AccessSpecifier']
Security,"// Packed DeclBits: ModuleOwnershipKind,; // isReferenced, isUsed, AccessSpecifier. Other; // higher bits should be 0: isImplicit,; // HasStandaloneLexicalDC, HasAttrs,; // TopLevelDeclInObjCContainer, isInvalidDecl",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:67,Access,AccessSpecifier,67,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,2,['Access'],['AccessSpecifier']
Security,"// Packed DeclBits: ModuleOwnershipKind,; // isUsed, isReferenced, AccessSpecifier,; // isImplicit; //; // The following bits should be 0:; // HasStandaloneLexicalDC, HasAttrs,; // TopLevelDeclInObjCContainer,; // isInvalidDecl",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:67,Access,AccessSpecifier,67,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,1,['Access'],['AccessSpecifier']
Security,"// Packed DeclBits: ModuleOwnershipKind,; // isUsed, isReferenced, AccessSpecifier,; //; // The following bits should be 0:; // isImplicit, HasStandaloneLexicalDC, HasAttrs,; // TopLevelDeclInObjCContainer,; // isInvalidDecl",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:67,Access,AccessSpecifier,67,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,3,['Access'],['AccessSpecifier']
Security,// Pad with zeros so that we can start the hashtable at an aligned address.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h:43,hash,hashtable,43,interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h,1,['hash'],['hashtable']
Security,// Parallel loops must not have aliasing loop-invariant memory accesses.; // Hence we don't need to version anything in this case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:63,access,accesses,63,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,1,['access'],['accesses']
Security,"// Parameter accessed by any or unknown offset, represented as FullSet by; // StackSafety, is handled as the parameter for which we have no; // StackSafety info at all. So drop it to reduce summary size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:13,access,accessed,13,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,1,['access'],['accessed']
Security,"// Parameter value and error accessors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooLinearVar.h:29,access,accessors,29,roofit/roofitcore/inc/RooLinearVar.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooLinearVar.h,3,['access'],['accessors']
Security,"// Parameter value and error accessors; /// Set the current value of the object. Needs to be overridden by implementations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsRealLValue.h:29,access,accessors,29,roofit/roofitcore/inc/RooAbsRealLValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsRealLValue.h,1,['access'],['accessors']
Security,"// Parameters (make protected to be accessible directly by derived classes)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/ParamFunction.h:36,access,accessible,36,math/mathmore/inc/Math/ParamFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/ParamFunction.h,1,['access'],['accessible']
Security,// Parse $msa(ir|csr|access|save|modify|request|map|unmap); // No numeric characters follow the name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:21,access,access,21,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,1,['access'],['access']
Security,// Parse -f(no-)?sanitize-coverage flags if coverage is supported by the; // enabled sanitizers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:17,sanitiz,sanitize-coverage,17,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,2,['sanitiz'],"['sanitize-coverage', 'sanitizers']"
Security,// Parse -f(no-)?sanitize-ignorelist options.; // This also validates special case lists format.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:17,sanitiz,sanitize-ignorelist,17,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,2,"['sanitiz', 'validat']","['sanitize-ignorelist', 'validates']"
Security,// Parse -f(no-)?sanitize-metadata.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:17,sanitiz,sanitize-metadata,17,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['sanitiz'],['sanitize-metadata']
Security,// Parse -f[no-]sanitize-memory-track-origins[=level] options.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:16,sanitiz,sanitize-memory-track-origins,16,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['sanitiz'],['sanitize-memory-track-origins']
Security,"// Parse -fsanitize-coverage-(allow|ignore)list options if coverage enabled.; // This also validates special case lists format.; // Here, OptSpecifier() acts as a never-matching command-line argument.; // So, there is no way to clear coverage lists but you can append to them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:91,validat,validates,91,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['validat'],['validates']
Security,// Parse -fsanitize-recover= arguments.; // FIXME: Report unrecoverable sanitizers incorrectly specified here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:72,sanitiz,sanitizers,72,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['sanitiz'],['sanitizers']
Security,// Parse -link-cxx-sanitizer flag.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:19,sanitiz,sanitizer,19,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['sanitiz'],['sanitizer']
Security,// Parse an (optional) access specifier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:23,access,access,23,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['access'],['access']
Security,"// Parse and validate the string, converting it into a unique ID.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:13,validat,validate,13,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,2,['validat'],['validate']
Security,"// Parse the 'virtual' keyword (again!), in case it came after the; // access specifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:71,access,access,71,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['access'],['access']
Security,// Parse the accessor specifications.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:13,access,accessor,13,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['access'],['accessor']
Security,"// Parse the index expression, if we haven't already gotten one; // above (which can only happen in Objective-C++).; // Note that we parse this as an assignment expression, not a constant; // expression (allowing *=, =, etc) to handle the objc case. Sema needs; // to validate that the expression is a constant.; // FIXME: We also need to tell Sema that we're in a; // potentially-potentially evaluated context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:268,validat,validate,268,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,1,['validat'],['validate']
Security,"// Parse the operands list from the (ops) list, validating it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:48,validat,validating,48,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,1,['validat'],['validating']
Security,"// Parsing + Validation; // --------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx:13,Validat,Validation,13,tmva/pymva/src/MethodPyKeras.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx,4,['Validat'],['Validation']
Security,// Partition by MD5 hash. We only need a few bits for evenness as the number; // of partitions will generally be in the 1-2 figure range; the low 16 bits; // are enough.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp:20,hash,hash,20,interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp,1,['hash'],['hash']
Security,// Partition variables accessed indirectly into the different strategies,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:23,access,accessed,23,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['access'],['accessed']
Security,// Patch the Header.HashOffset field.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp:20,Hash,HashOffset,20,interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,1,['Hash'],['HashOffset']
Security,// Patterns in .clang-format-ignore file.; // Check whether `FilePath` is ignored according to the nearest; // .clang-format-ignore file based on the rules below:; // - A blank line is skipped.; // - Leading and trailing spaces of a line are trimmed.; // - A line starting with a hash (`#`) is a comment.; // - A non-comment line is a single pattern.; // - The slash (`/`) is used as the directory separator.; // - A pattern is relative to the directory of the .clang-format-ignore file (or; // the root directory if the pattern starts with a slash).; // - A pattern is negated if it starts with a bang (`!`).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp:280,hash,hash,280,interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,1,['hash'],['hash']
Security,"// Per C++ Core Issue 1170, access control is part of SFINAE.; // Additionally, the AccessCheckingSFINAE flag can be used to temporarily; // make access control a part of SFINAE for the purposes of checking; // type traits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:28,access,access,28,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,3,"['Access', 'access']","['AccessCheckingSFINAE', 'access']"
Security,"// Per C++ [class.qual]p2, if the template-id was an injected-class-name,; // it's not actually allowed to be used as a type in most cases. Because; // we annotate it before we know whether it's valid, we have to check for; // this case here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:53,inject,injected-class-name,53,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['inject'],['injected-class-name']
Security,"// Per [class.qual]p2, this names the constructors of SS, not the; // injected-class-name. We don't have a classification for that.; // There's not much point caching this result, since the parser; // will reject it later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:70,inject,injected-class-name,70,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['inject'],['injected-class-name']
Security,"// Per the current approach for DR1299, look through array element access; // on array glvalues when performing lifetime extension.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:67,access,access,67,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['access'],['access']
Security,"// Perform ""qualified"" name lookup into the declaration context we; // computed, which is either the type of the base of a member access; // expression or the declaration context associated with a prior; // nested-name-specifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:130,access,access,130,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['access'],['access']
Security,"// Perform ""qualified"" name lookup into the declaration context we; // computed, which is either the type of the base of a member access; // expression or the declaration context associated with a prior; // nested-name-specifier.; // The declaration context must be complete.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:130,access,access,130,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,1,['access'],['access']
Security,// Perform a basic validation of the header fields.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugAddr.cpp:19,validat,validation,19,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugAddr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugAddr.cpp,1,['validat'],['validation']
Security,"// Perform authentication, if required",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TServerSocket.cxx:11,authenticat,authentication,11,net/net/src/TServerSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TServerSocket.cxx,1,['authenticat'],['authentication']
Security,// Perform basic validation of the header fields.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugArangeSet.cpp:17,validat,validation,17,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugArangeSet.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFDebugArangeSet.cpp,1,['validat'],['validation']
Security,// Perform basic validation of the remaining header fields.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFListTable.cpp:17,validat,validation,17,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFListTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFListTable.cpp,1,['validat'],['validation']
Security,"// Perform derived-to-base casts and/or field accesses, to get from the; // temporary object we created (and, potentially, for which we extended; // the lifetime) to the subobject we're binding the reference to.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:46,access,accesses,46,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['access'],['accesses']
Security,// Perform range checking and other semantic validations,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:45,validat,validations,45,interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,1,['validat'],['validations']
Security,// Perform the C++ accessibility checks first.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:19,access,accessibility,19,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['access'],['accessibility']
Security,"// Performs a reverse topological traversal, starting from the exit block and; // following back-edges. The dominator is serialized before any predecessors,; // which guarantees that all blocks are serialized after their dominator and; // before their post-dominator (because it's a reverse topological traversal).; // ID should be initially set to 0.; //; // This sort assumes that (1) dominators have been computed, (2) there are no; // critical edges, and (3) the entry block is reachable from the exit block; // and no blocks are accessible via traversal of back-edges from the exit that; // weren't accessible via forward edges from the entry.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:534,access,accessible,534,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,2,['access'],['accessible']
Security,// Pick the best (i.e. most permissive i.e. numerically lowest) access; // across all paths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:64,access,access,64,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['access'],['access']
Security,"// Place global in a large section for x86-64 ELF binaries to mitigate; // relocation overflow pressure. This can be be used for metadata globals that; // aren't directly accessed by code, which has no performance impact.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation.h:171,access,accessed,171,interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation.h,1,['access'],['accessed']
Security,"// Place globals into the hash table in bucket order. When placing a global,; // update the bucket start. Every hash table slot should be filled. Always use; // a refcount of one for now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/GSIStreamBuilder.cpp:26,hash,hash,26,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/GSIStreamBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/GSIStreamBuilder.cpp,2,['hash'],['hash']
Security,"// Please note, the order of the fields used for computing; // the signature is important. Make sure that the changes you; // make are compatible with the reference documentation.; //; // Refs:; // AMAZON http://awsdocs.s3.amazonaws.com/S3/latest/s3-qrc.pdf; // GOOGLE: http://code.google.com/apis/storage/docs/reference/v1/developer-guidev1.html#authentication",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TS3HTTPRequest.cxx:347,authenticat,authentication,347,net/net/src/TS3HTTPRequest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TS3HTTPRequest.cxx,1,['authenticat'],['authentication']
Security,// Please use the accessors above and not the following fields.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:18,access,accessors,18,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,1,['access'],['accessors']
Security,"// Poison fields such that access after their destructors are; // invoked, and before the base class destructor runs, is invalid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:27,access,access,27,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,1,['access'],['access']
Security,// Poison the vtable pointer such that access after the base; // and member destructors are invoked is invalid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:39,access,access,39,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,1,['access'],['access']
Security,"// Pop the high registers first; // There are no store instructions that can access high registers directly,; // so we have to pop into low registers and them move to the high registers.; // This might take multiple pops, as it is possible for there to; // be fewer low registers available than high registers which need restoring.; // Find the first register to restore.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp:77,access,access,77,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb1FrameLowering.cpp,1,['access'],['access']
Security,// Populate AST with potentially promotable accesses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:44,access,accesses,44,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['access'],['accesses']
Security,// Populate the hash binary function map for MD5 function name lookup. This; // is done after BinaryFunctions are finalized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.cpp:16,hash,hash,16,interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.cpp,1,['hash'],['hash']
Security,// Populate the hash table generator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp:16,hash,hash,16,interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,1,['hash'],['hash']
Security,// Populate the hash table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:16,hash,hash,16,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,1,['hash'],['hash']
Security,"// Positive distance bigger than max vectorization factor.; // FIXME: Should use max factor instead of max distance in bytes, which could; // not handle different types.; // E.g. Assume one char is 1 byte in memory and one int is 4 bytes.; // void foo (int *A, char *B) {; // for (unsigned i = 0; i < 1024; i++) {; // A[i+2] = A[i] + 1;; // B[i+2] = B[i] + 1;; // }; // }; //; // This case is currently unsafe according to the max safe distance. If we; // analyze the two accesses on array B, the max safe dependence distance; // is 2. Then we analyze the accesses on array A, the minimum distance needed; // is 8, which is less than 2 and forbidden vectorization, But actually; // both A and B could be vectorized by 2 iterations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:472,access,accesses,472,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,2,['access'],['accesses']
Security,"// Post increment updates its EA after the mem access,; // so we need to treat its offset as zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:47,access,access,47,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,1,['access'],['access']
Security,// Post-order numbers for each basic block. Used to figure out if memory; // accesses are executed before another access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:77,access,accesses,77,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,2,['access'],"['access', 'accesses']"
Security,"// Power9 and up only. For some of these, the X-Form version has access to all; // 64 VSR's whereas the D-Form only has access to the VR's. We replace those; // with pseudo-ops pre-ra and for post-ra, we check that the register loaded; // into or stored from is one of the VR registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:65,access,access,65,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,2,['access'],['access']
Security,"// PowerPC supports unaligned memory access for simple non-vector types.; // Although accessing unaligned addresses is not as efficient as accessing; // aligned addresses, it is generally more efficient than manual expansion,; // and generally only traps for software emulation when crossing page; // boundaries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:37,access,access,37,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,3,['access'],"['access', 'accessing']"
Security,// Prefer a locked operation against a stack location to minimize cache; // traffic. This assumes that stack locations are very likely to be; // accessed only by the owning thread.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:145,access,accessed,145,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['access'],['accessed']
Security,"// Preincrement iterator to avoid invalidation issues.; // This is for CET enhancement.; //; // ENDBR32 and ENDBR64 have specific opcodes:; // ENDBR32: F3 0F 1E FB; // ENDBR64: F3 0F 1E FA; // And we want that attackers won’t find unintended ENDBR32/64; // opcode matches in the binary; // Here’s an example:; // If the compiler had to generate asm for the following code:; // a = 0xF30F1EFA; // it could, for example, generate:; // mov 0xF30F1EFA, dword ptr[a]; // In such a case, the binary would include a gadget that starts; // with a fake ENDBR64 opcode. Therefore, we split such generation; // into multiple operations, let it not shows in the binary",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:210,attack,attackers,210,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['attack'],['attackers']
Security,"// Prepare PyTorch Validation DataSet",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyTorch.cxx:19,Validat,Validation,19,tmva/pymva/src/MethodPyTorch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyTorch.cxx,1,['Validat'],['Validation']
Security,"// Prepare PyTorch validation Dataloader",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyTorch.cxx:19,validat,validation,19,tmva/pymva/src/MethodPyTorch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyTorch.cxx,1,['validat'],['validation']
Security,"// Prepend ""__uniq"" before the hash for tools like profilers to understand; // that this symbol is of internal linkage type. The ""__uniq"" is the; // pre-determined prefix that is used to tell tools that this symbol was; // created with -funique-internal-linkage-symbols and the tools can strip or; // keep the prefix as needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h:31,hash,hash,31,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,1,['hash'],['hash']
Security,// Preprocessor directives get indented before the hash only if specified. In; // Javascript import statements are indented like normal statements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:51,hash,hash,51,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,1,['hash'],['hash']
Security,// Preserve !preserve.access.index in K.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:22,access,access,22,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['access'],['access']
Security,"// Preserve the lexical DeclContext if it is not the surrounding tag; // injection context of the FD. In this example, the semantic context of; // E will be f and the lexical context will be S, while both the; // semantic and lexical contexts of S will be f:; // void f(struct S { enum E { a } f; } s);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:73,inject,injection,73,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['inject'],['injection']
Security,// Pretend the variable template specializations are class template; // specializations and form a fake injected class name type for comparison.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:104,inject,injected,104,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['inject'],['injected']
Security,"// Prevent crashes on accessing history",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/RPyROOTApplication.cxx:22,access,accessing,22,bindings/pyroot/pythonizations/src/RPyROOTApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/RPyROOTApplication.cxx,1,['access'],['accessing']
Security,// Previous is an access modifier remove all new lines.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:18,access,access,18,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,1,['access'],['access']
Security,// Previously calculated hash is stored in DefinitionData.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:25,hash,hash,25,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,3,['hash'],['hash']
Security,"// Print access kind for ""other"" as the default access kind. This way it; // will apply to any new location kinds that get split out of ""other"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp:9,access,access,9,interpreter/llvm-project/llvm/lib/IR/Attributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp,2,['access'],['access']
Security,// Print all the other accesses as notes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:23,access,accesses,23,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,1,['access'],['accesses']
Security,"// Print all values for checksum together, or not at all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:24,checksum,checksum,24,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,1,['checksum'],['checksum']
Security,"// Print established security contexts",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:21,secur,security,21,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['secur'],['security']
Security,// Print everything before SecurityCookie. The vast majority of images today; // have all these fields.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/COFFDumper.cpp:27,Secur,SecurityCookie,27,interpreter/llvm-project/llvm/tools/llvm-readobj/COFFDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/COFFDumper.cpp,1,['Secur'],['SecurityCookie']
Security,"// Print header info for extra headers, pretending they were discovered by; // the regular preprocessor. The primary use case is to support proper; // generation of Make / Ninja file dependencies for implicit includes, such; // as sanitizer ignorelists. It's only important for cl.exe compatibility,; // the GNU way to generate rules is -M / -MM / -MD / -MMD.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp:231,sanitiz,sanitizer,231,interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp,1,['sanitiz'],['sanitizer']
Security,// Print histogram for the .gnu.hash section.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp:32,hash,hash,32,interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,1,['hash'],['hash']
Security,// Print histogram for the .hash section.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp:28,hash,hash,28,interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,1,['hash'],['hash']
Security,"// Print the class definition; // FIXME: Doesn't print access specifiers, e.g., ""public:""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp:55,access,access,55,interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,1,['access'],['access']
Security,"// Process all the top level declarations.; //; // Note: TraverseDecl may modify LocalTUDecls, but only by appending more; // entries. Thus we don't use an iterator, but rely on LocalTUDecls; // random access. By doing so, we automatically compensate for iterators; // possibly being invalidated, although this is a bit slower.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:202,access,access,202,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,1,['access'],['access']
Security,"// Process the CompressPat definitions, validating them as we do so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp:40,validat,validating,40,interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp,1,['validat'],['validating']
Security,"// Process the pseudo expansion definitions, validating them as we do so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/PseudoLoweringEmitter.cpp:45,validat,validating,45,interpreter/llvm-project/llvm/utils/TableGen/PseudoLoweringEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/PseudoLoweringEmitter.cpp,1,['validat'],['validating']
Security,"// Produced e.g. by `csc /debug`. The encoded data is its own mini-stream; // with the following layout (in little endian):; // GUID LanguageTypeGuid;; // GUID LanguageVendorGuid;; // GUID DocumentTypeGuid;; // GUID HashFunctionGuid;; // uint32_t HashDataSize;; // uint32_t CompressedDataSize;; // Followed by HashDataSize bytes containing a hash checksum,; // followed by CompressedDataSize bytes containing source contents.; //; // CompressedDataSize can be 0, in this case only the hash data is present.; // (CompressedDataSize is != 0 e.g. if `/embed` is passed to csc.exe.); // The compressed data format is:; // uint32_t UncompressedDataSize;; // If UncompressedDataSize is 0, the data is stored uncompressed and; // CompressedDataSize stores the uncompressed size.; // If UncompressedDataSize is != 0, then the data is in raw deflate; // encoding as described in rfc1951.; //; // A GUID is 16 bytes, stored in the usual; // uint32_t; // uint16_t; // uint16_t; // uint8_t[24]; // layout.; //; // Well-known GUIDs for LanguageTypeGuid are:; // 63a08714-fc37-11d2-904c-00c04fa302a1 C; // 3a12d0b7-c26c-11d0-b442-00a0244a1dd2 C++; // 3f5162f8-07c6-11d3-9053-00c04fa302a1 C#; // af046cd1-d0e1-11d2-977c-00a0c9b4d50c Cobol; // ab4f38c9-b6e6-43ba-be3b-58080b2ccce3 F#; // 3a12d0b4-c26c-11d0-b442-00a0244a1dd2 Java; // 3a12d0b6-c26c-11d0-b442-00a0244a1dd2 JScript; // af046cd2-d0e1-11d2-977c-00a0c9b4d50c Pascal; // 3a12d0b8-c26c-11d0-b442-00a0244a1dd2 Visual Basic; //; // Well-known GUIDs for LanguageVendorGuid are:; // 994b45c4-e6e9-11d2-903f-00c04fa302a1 Microsoft; //; // Well-known GUIDs for DocumentTypeGuid are:; // 5a869d0b-6611-11d3-bd2a-0000f80849bd Text; //; // Well-known GUIDs for HashFunctionGuid are:; // 406ea660-64cf-4c82-b6f0-42d48172a799 MD5 (HashDataSize is 16); // ff1816ec-aa5e-4d10-87f7-6f4963833460 SHA1 (HashDataSize is 20); // 8829d00f-11b8-4213-878b-770e8597ac16 SHA256 (HashDataSize is 32)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/PDBTypes.h:216,Hash,HashFunctionGuid,216,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/PDBTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/PDBTypes.h,10,"['Hash', 'checksum', 'hash']","['HashDataSize', 'HashFunctionGuid', 'checksum', 'hash']"
Security,"// Produces a human readable description of a CO-RE relocation.; // Such relocations are generated by BPF backend, and processed; // by libbpf's BPF program loader [1].; //; // Each relocation record has the following information:; // - Relocation kind;; // - BTF type ID;; // - Access string offset in string table.; //; // There are different kinds of relocations, these kinds could be split; // in three groups:; // - load-time information about types (size, existence),; // `BTFParser::symbolize()` output for such relocations uses the template:; //; // <relocation-kind> [<id>] <type-name>; //; // For example:; // - ""<type_exists> [7] struct foo""; // - ""<type_size> [7] struct foo""; //; // - load-time information about enums (literal existence, literal value),; // `BTFParser::symbolize()` output for such relocations uses the template:; //; // <relocation-kind> [<id>] <type-name>::<literal-name> = <original-value>; //; // For example:; // - ""<enumval_exists> [5] enum foo::U = 1""; // - ""<enumval_value> [5] enum foo::V = 2""; //; // - load-time information about fields (e.g. field offset),; // `BTFParser::symbolize()` output for such relocations uses the template:; //; // <relocation-kind> [<id>] \; // <type-name>::[N].<field-1-name>...<field-M-name> \; // (<access string>); //; // For example:; // - ""<byte_off> [8] struct bar::[7].v (7:1)""; // - ""<field_exists> [8] struct bar::v (0:1)""; //; // If relocation description is not valid output follows the following pattern:; //; // <relocation-kind> <type-id>::<unprocessedaccess-string> <<error-msg>>; //; // For example:; //; // - ""<type_sz> [42] '' <unknown type id: 42>""; // - ""<byte_off> [4] '0:' <field spec too short>""; //; // Additional examples could be found in unit tests, see; // llvm/unittests/DebugInfo/BTF/BTFParserTest.cpp.; //; // [1] https://www.kernel.org/doc/html/latest/bpf/libbpf/index.html",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/BTF/BTFParser.cpp:279,Access,Access,279,interpreter/llvm-project/llvm/lib/DebugInfo/BTF/BTFParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/BTF/BTFParser.cpp,2,"['Access', 'access']","['Access', 'access']"
Security,"// Profile is not MD5 and if a remapper is present, the remapped name of; // every function needed to be matched against the module, so use the list; // container since each entry is accessed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp:183,access,accessed,183,interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp,1,['access'],['accessed']
Security,"// Promoting one set of accesses may make the pointers for another set; // loop invariant, so run this in a loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:24,access,accesses,24,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['access'],['accesses']
Security,"// Propagate access. For a non-friend declaration, the access is; // whatever we're propagating from. For a friend, it should be the; // previous declaration we just found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:13,access,access,13,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,2,['access'],['access']
Security,"// Properties might be computed, which means the property value could; // theoretically change between calls even in commonly-observed cases like; // this:; //; // if (foo.prop) { // ok, it's nonnull here...; // [bar doStuffWithNonnullVal:foo.prop]; // ...but what about; // here?; // }; //; // If the property is nullable-annotated, a naive analysis would lead to many; // false positives despite the presence of probably-correct nil-checks. To; // reduce the false positive rate, we maintain a history of the most recently; // observed property value. For each property access, if the prior value has; // been constrained to be not nil then we will conservatively assume that the; // next access can be inferred as nonnull.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:572,access,access,572,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,2,['access'],['access']
Security,// Properties on bitfield ivars need to be emitted using expression; // accesses even if they're nominally atomic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:72,access,accesses,72,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['access'],['accesses']
Security,// Property accessor stubs sometimes do not correspond to any property decl; // in the current interface (but in a superclass). They still have a; // corresponding property impl decl in this case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp:12,access,accessor,12,interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,1,['access'],['accessor']
Security,// Property accessors must have exactly the number of expected params.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:12,access,accessors,12,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['access'],['accessors']
Security,"// Protected methods; ////////////////////////////////////////////////////////////////////////////////; /// Validate if the passed 'buffer' contains all sections we require to add object.; /// Returns Int_t combination of TBuffer::ESection flags still required - or; /// TBuffer3D::kNone if buffer is valid.; /// If 'includeRaw' is kTRUE check for kRaw/kRawSizes - skip otherwise.; /// See base/src/TVirtualViewer3D.cxx for description of viewer architecture",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScenePad.cxx:108,Validat,Validate,108,graf3d/gl/src/TGLScenePad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScenePad.cxx,1,['Validat'],['Validate']
Security,"// Protocol used fro a successful authentication",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:34,authenticat,authentication,34,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['authenticat'],['authentication']
Security,"// Provide access to the single global instance of this object.; // static BaseHandler *GetInstance();; // CefClient methods:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/inc/gui_handler.h:11,access,access,11,gui/cefdisplay/inc/gui_handler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/inc/gui_handler.h,1,['access'],['access']
Security,// Provide accessors for the MachineBasicBlock list...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:11,access,accessors,11,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['access'],['accessors']
Security,// Provide an accessor method to use them in range-based patterns.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BreadthFirstIterator.h:14,access,accessor,14,interpreter/llvm-project/llvm/include/llvm/ADT/BreadthFirstIterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BreadthFirstIterator.h,3,['access'],['accessor']
Security,// Provide fast operand accessors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h:24,access,accessors,24,interpreter/llvm-project/llvm/include/llvm/IR/Function.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h,1,['access'],['accessors']
Security,// Provide public access to the underlying map to allow overlap iteration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalUnion.h:18,access,access,18,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalUnion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalUnion.h,1,['access'],['access']
Security,// Provide transparent accessors to the operand list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenInstruction.h:23,access,accessors,23,interpreter/llvm-project/llvm/utils/TableGen/CodeGenInstruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenInstruction.h,1,['access'],['accessors']
Security,// Provides a very limited vector-like interface for lazily accessing one; // component of a scattered vector or vector pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:60,access,accessing,60,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,1,['access'],['accessing']
Security,// Publicly exposed interface to pass...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:12,expose,exposed,12,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,3,['expose'],['exposed']
Security,"// Publics stream contains fixed-size headers and a serialized hash table.; // This implementation is not complete yet. It reads till the end of the; // stream so that we verify the stream is at least not corrupted. However,; // we skip over the hash table which we believe contains information about; // public symbols.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PublicsStream.cpp:63,hash,hash,63,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PublicsStream.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PublicsStream.cpp,2,['hash'],['hash']
Security,// Punt out-of-bounds accesses to sanitizers and/or libc.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:22,access,accesses,22,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,2,"['access', 'sanitiz']","['accesses', 'sanitizers']"
Security,// Put Checksum at a scope where it will persist past the createFile call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:7,Checksum,Checksum,7,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['Checksum'],['Checksum']
Security,// Put the access chain into a stack with the top as the head of the chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:11,access,access,11,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,1,['access'],['access']
Security,// Put the hash in the Signature field too.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBFileBuilder.cpp:11,hash,hash,11,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBFileBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBFileBuilder.cpp,1,['hash'],['hash']
Security,// Qualifiers are irrelevant to this conversion; we're only looking; // for access and ambiguity.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:76,access,access,76,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['access'],['access']
Security,// Queue the defining access to check for alias checks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:22,access,access,22,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,1,['access'],['access']
Security,"// RAX contains the number of bytes of desired stack adjustment.; // The handling here assumes this value has already been updated so as to; // maintain stack alignment.; //; // We need to exit with RSP modified by this amount and execute suitable; // page touches to notify the OS that we're growing the stack responsibly.; // All stack probing must be done without modifying RSP.; //; // MBB:; // SizeReg = RAX;; // ZeroReg = 0; // CopyReg = RSP; // Flags, TestReg = CopyReg - SizeReg; // FinalReg = !Flags.Ovf ? TestReg : ZeroReg; // LimitReg = gs magic thread env access; // if FinalReg >= LimitReg goto ContinueMBB; // RoundBB:; // RoundReg = page address of FinalReg; // LoopMBB:; // LoopReg = PHI(LimitReg,ProbeReg); // ProbeReg = LoopReg - PageSize; // [ProbeReg] = 0; // if (ProbeReg > RoundReg) goto LoopMBB; // ContinueMBB:; // RSP = RSP - RAX; // [rest of original MBB]; // Set up the new basic blocks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:568,access,access,568,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['access'],['access']
Security,// RC injects completely into SubRC.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:6,inject,injects,6,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,1,['inject'],['injects']
Security,"// RColumnElement concrete implementations; //; // Note that this file is in the src directory and not in the inc directory because we need the ability; // to override R__LITTLE_ENDIAN for testing purposes.; // This is not a particularly clean or correct solution, as the tests that do this will end up with two different; // definitions of some RColumnElements, so we might want to change this mechanism in the future. In any case, these; // definitions are implementation details and should not be exposed to a public interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:500,expose,exposed,500,tree/ntuple/v7/src/RColumnElement.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx,1,['expose'],['exposed']
Security,"// Raise a warning when trying to use implicit auto injection feature.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:52,inject,injection,52,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,1,['inject'],['injection']
Security,"// Randomize order of prototype data access",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMCStudy.h:37,access,access,37,roofit/roofitcore/inc/RooMCStudy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMCStudy.h,1,['access'],['access']
Security,"// Range information for accessed offsets for every argument.; // [n x (paramno, range, numcalls, numcalls x (callee_guid, paramno, range))]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:25,access,accessed,25,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,1,['access'],['accessed']
Security,// Ranges that are in the new access but not the old access need to be added; // to the offset bins.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:30,access,access,30,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,2,['access'],['access']
Security,// Ranges that are in the old access but not the new access need to be removed; // from the offset bins.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:30,access,access,30,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,2,['access'],['access']
Security,// Re-do lookup in case of re-hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp:30,hash,hash,30,interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDeclCXX.cpp,1,['hash'],['hash']
Security,// Re-point the uses at our defining access,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:37,access,access,37,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['access'],['access']
Security,// Read Hash Table of Signatures,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnitIndex.cpp:8,Hash,Hash,8,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnitIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnitIndex.cpp,1,['Hash'],['Hash']
Security,// Read and validate the code alignment factor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/EHFrameSupport.cpp:12,validat,validate,12,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/EHFrameSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/EHFrameSupport.cpp,1,['validat'],['validate']
Security,// Read and validate the data alignment factor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/EHFrameSupport.cpp:12,validat,validate,12,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/EHFrameSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/EHFrameSupport.cpp,1,['validat'],['validate']
Security,// Read argument's access qualifier from metadata or default.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVCallLowering.cpp:19,access,access,19,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVCallLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVCallLowering.cpp,1,['access'],['access']
Security,// Read hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp:8,hash,hash,8,interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp,1,['hash'],['hash']
Security,// Read something other than a preprocessor directive hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:54,hash,hash,54,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['hash'],['hash']
Security,// Read the function hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp:21,hash,hash,21,interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp,1,['hash'],['hash']
Security,// Read the hash table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PublicsStream.cpp:12,hash,hash,12,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PublicsStream.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PublicsStream.cpp,1,['hash'],['hash']
Security,// Read the hash type and start offset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp:12,hash,hash,12,interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp,1,['hash'],['hash']
Security,// Read the hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h:12,hash,hash,12,interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h,1,['hash'],['hash']
Security,"// Read the version number. Note - the GCC reader does not validate this; // version, but the profile creator generates v704.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp:59,validat,validate,59,interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp,1,['validat'],['validate']
Security,"// Read user or system authentication directives and; // receive auth info transmitted from the client",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:23,authenticat,authentication,23,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['authenticat'],['authentication']
Security,"// Reading a validation counter will only return a single value, so it is; // safe to only append the first value here. Also assert that this is true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.cpp:13,validat,validation,13,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.cpp,1,['validat'],['validation']
Security,// ReassociateGEPs exposes more opportunites for SLSR. See; // the example in reassociate-geps-and-slsr.ll.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp:19,expose,exposes,19,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.cpp,1,['expose'],['exposes']
Security,// ReassociateGEPs exposes more opportunities for SLSR. See; // the example in reassociate-geps-and-slsr.ll.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:19,expose,exposes,19,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp,1,['expose'],['exposes']
Security,// Recalculate MD5 hash,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/OffloadBundler.cpp:19,hash,hash,19,interpreter/llvm-project/clang/lib/Driver/OffloadBundler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/OffloadBundler.cpp,1,['hash'],['hash']
Security,"// Recall that hash values go into a completely different stream identified by; // the `HashStreamIndex` field of the `TpiStreamHeader`. Therefore, the data; // begins at offset 0 of this independent stream.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/TpiStreamBuilder.cpp:15,hash,hash,15,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/TpiStreamBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/TpiStreamBuilder.cpp,2,"['Hash', 'hash']","['HashStreamIndex', 'hash']"
Security,"// Receive encrypted pass or its hash",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:11,encrypt,encrypted,11,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,2,"['encrypt', 'hash']","['encrypted', 'hash']"
Security,"// Receive password salt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:11,password,password,11,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['password'],['password']
Security,"// Receive the key securely",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:19,secur,securely,19,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['secur'],['securely']
Security,// Recompute the hash and compare it to the one in the bitcode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp:17,hash,hash,17,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeAnalyzer.cpp,1,['hash'],['hash']
Security,// Record GEPs with non-zero offsets as candidates for splitting in; // the event that the offset cannot fit into the r+i addressing mode.; // Simple and common case that only one GEP is used in calculating the; // address for the memory access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:238,access,access,238,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['access'],['access']
Security,// Record that this unwrap is *not* provably safe.; // FIXME: include either the name of the optional (if applicable) or a source; // range of the access for easier interpretation of the result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp:147,access,access,147,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,1,['access'],['access']
Security,// Record the access function for the current subscript.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:14,access,access,14,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,1,['access'],['access']
Security,"// Record the alignment, for quick access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp:35,access,access,35,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZLongBranch.cpp,1,['access'],['access']
Security,// Record this value as validated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:24,validat,validated,24,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['validat'],['validated']
Security,"// Record volatile accesses, unless it's a call, as calls are handled; // specially below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:19,access,accesses,19,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,1,['access'],['accesses']
Security,"// Recover from arrow accesses to records, e.g.:; // struct MyRecord foo;; // foo->bar; // This is actually well-formed in C++ if MyRecord has an; // overloaded operator->, but that should have been dealt with; // by now--or a diagnostic message already issued if a problem; // was encountered while looking for the overloaded operator->.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:22,access,accesses,22,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['access'],['accesses']
Security,"// Recover from dot accesses to pointers, e.g.:; // type *foo;; // foo.bar; // This is actually well-formed in two cases:; // - 'type' is an Objective C type; // - 'bar' is a pseudo-destructor name which happens to refer to; // the appropriate pointer type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:20,access,accesses,20,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['access'],['accesses']
Security,// Recurse as an -> access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:20,access,access,20,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['access'],['access']
Security,// Recursively hash each argument using a helper class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:15,hash,hash,15,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,1,['hash'],['hash']
Security,"// Reference checksum",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx:13,checksum,checksum,13,test/stressProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx,1,['checksum'],['checksum']
Security,// Register callbacks to schedule sanitizer passes at the appropriate part; // of the pipeline.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:34,sanitiz,sanitizer,34,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,1,['sanitiz'],['sanitizer']
Security,"// Register the checker that checks for direct accesses in all functions,; // except for the initialization and copy routines.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp:47,access,accesses,47,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp,1,['access'],['accesses']
Security,"// Register the checker that checks for direct accesses in functions annotated; // with __attribute__((annotate(""objc_no_direct_instance_variable_assignment""))).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp:47,access,accesses,47,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp,1,['access'],['accesses']
Security,"// Rehash all the items into their new buckets. Luckily :) we already have; // the hash values available, so we don't have to rehash any strings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringMap.cpp:83,hash,hash,83,interpreter/llvm-project/llvm/lib/Support/StringMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringMap.cpp,1,['hash'],['hash']
Security,// Release string for ROCm packages built with SPACK if not empty. The; // installation directories of ROCm packages built with SPACK follow the; // convention <package_name>-<rocm_release_string>-<hash>.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:198,hash,hash,198,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,1,['hash'],['hash']
Security,"// Relocation access string follows pattern [0-9]+(:[0-9]+)*,; // e.g.: 12:22:3. Code below splits `SpecStr` by ':', parses; // numbers, and pushes them to `RawSpec`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/BTF/BTFParser.cpp:14,access,access,14,interpreter/llvm-project/llvm/lib/DebugInfo/BTF/BTFParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/BTF/BTFParser.cpp,1,['access'],['access']
Security,// RelocationRef accessors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:17,access,accessors,17,interpreter/llvm-project/llvm/include/llvm-c/Object.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h,2,['access'],['accessors']
Security,// Remember that parameter belongs to a CF audited API.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:43,audit,audited,43,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['audit'],['audited']
Security,// Remember the first tombstone found.; // It's a hash collision or a tombstone. Reprobe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SmallPtrSet.cpp:50,hash,hash,50,interpreter/llvm-project/llvm/lib/Support/SmallPtrSet.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SmallPtrSet.cpp,1,['hash'],['hash']
Security,"// Remember the first tombstone found.; // Otherwise, it's a hash collision or a tombstone, continue quadratic; // probing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:61,hash,hash,61,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,1,['hash'],['hash']
Security,// Remove access kind modifiers if necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:10,access,access,10,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['access'],['access']
Security,"// Remove access qualifiers on images; // (as they are inseparable from type in clang implementation,; // but OpenCL spec provides a special query to get access qualifier; // via clGetKernelArgInfo with CL_KERNEL_ARG_ACCESS_QUALIFIER):",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:10,access,access,10,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,2,['access'],['access']
Security,"// Remove any dead arguments exposed by cleanups, constant folding globals,; // and argument promotion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:29,expose,exposed,29,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['expose'],['exposed']
Security,"// Remove existing hash table",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooLinkedList.cxx:19,hash,hash,19,roofit/roofitcore/src/RooLinkedList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooLinkedList.cxx,1,['hash'],['hash']
Security,"// Remove from hash table",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooLinkedList.cxx:15,hash,hash,15,roofit/roofitcore/src/RooLinkedList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooLinkedList.cxx,1,['hash'],['hash']
Security,"// Remove from the typedef hashtables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:27,hash,hashtables,27,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['hash'],['hashtables']
Security,"// Remove interleaved groups with gaps whose memory; // accesses may wrap around. We have to revisit the getPtrStride analysis,; // this time with ShouldCheckWrap=true, since collectConstStrideAccesses does; // not check wrapping (see documentation there).; // FORNOW we use Assume=false;; // TODO: Change to Assume=true but making sure we don't exceed the threshold; // of runtime SCEV assumptions checks (thereby potentially failing to; // vectorize altogether).; // Additional optional optimizations:; // TODO: If we are peeling the loop and we know that the first pointer doesn't; // wrap then we can deduce that all pointers in the group don't wrap.; // This means that we can forcefully peel the loop in order to only have to; // check the first pointer for no-wrap. When we'll change to use Assume=true; // we'll only need at most one runtime check per interleaved group.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:56,access,accesses,56,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['access'],['accesses']
Security,// Remove memory accesses in BB for I and all following instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:17,access,accesses,17,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['access'],['accesses']
Security,// Remove the -<hash of ModuleMapPath>,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:16,hash,hash,16,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,1,['hash'],['hash']
Security,// Remove the 64-bit feature which we only use to validate if a CPU can; // be used with 64-bit mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/X86TargetParser.cpp:50,validat,validate,50,interpreter/llvm-project/llvm/lib/TargetParser/X86TargetParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/X86TargetParser.cpp,1,['validat'],['validate']
Security,"// Remove the checksum file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManagerFile.cxx:14,checksum,checksum,14,proof/proof/src/TDataSetManagerFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManagerFile.cxx,1,['checksum'],['checksum']
Security,// Remove the entry from the hash table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:29,hash,hash,29,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp,1,['hash'],['hash']
Security,"// Remove the linkage cache. On next access it will calculate it; // considering the new position of the declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp:37,access,access,37,interpreter/cling/lib/Interpreter/DeclExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp,1,['access'],['access']
Security,"// Remove the oldest accessed files first, till we get below the threshold.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CachePruning.cpp:21,access,accessed,21,interpreter/llvm-project/llvm/lib/Support/CachePruning.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CachePruning.cpp,1,['access'],['accessed']
Security,// Removing a store here can leave MemorySSA in an unoptimized state by; // creating MemoryPhis that have identical arguments and by creating; // MemoryUses whose defining access is not an actual clobber. The phi case; // is handled by MemorySSA when passing OptimizePhis = true to; // removeMemoryAccess. The non-optimized MemoryUse case is lazily updated; // by MemorySSA's getClobberingMemoryAccess.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:172,access,access,172,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['access'],['access']
Security,"// Renaming would invalidate the old hash map. Test that it gets regenerated correctly:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooAbsCollection.cxx:37,hash,hash,37,roofit/roofitcore/test/testRooAbsCollection.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooAbsCollection.cxx,1,['hash'],['hash']
Security,// Renumber blocks before sorting them. This is useful for accessing the; // original layout positions and finding the original fallthroughs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp:59,access,accessing,59,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSections.cpp,1,['access'],['accessing']
Security,// Replace (or supplement) instructions accessing live mask.; // This can only happen once all the live mask registers have been created; // and the execute state (WQM/StrictWWM/Exact) of instructions is known.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:40,access,accessing,40,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,1,['access'],['accessing']
Security,// Replace all alloca and SSA values that are accessed across suspend points; // with GetElementPointer from coroutine frame + loads and stores. Create an; // AllocaSpillBB that will become the new entry block for the resume parts of; // the coroutine:; //; // %hdl = coro.begin(...); // whatever; //; // becomes:; //; // %hdl = coro.begin(...); // br label %AllocaSpillBB; //; // AllocaSpillBB:; // ; geps corresponding to allocas that were moved to coroutine frame; // br label PostSpill; //; // PostSpill:; // whatever; //; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:46,access,accessed,46,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['access'],['accessed']
Security,"// Replace all operations (these are all the same, but have a different; // (i1) return type). DAG.getNode will validate that the types of; // a binary operator match, so go through the list in reverse so that; // we've likely promoted both operands first. Any intermediate truncations or; // extensions disappear.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:112,validat,validate,112,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['validat'],['validate']
Security,"// Replace all operations (these are all the same, but have a different; // (promoted) return type). DAG.getNode will validate that the types of; // a binary operator match, so go through the list in reverse so that; // we've likely promoted both operands first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:118,validat,validate,118,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['validat'],['validate']
Security,// Replace all other instructions with Repl with memory access NewMemAcc.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:56,access,access,56,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['access'],['access']
Security,// Replace all our users with our defining access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:43,access,access,43,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['access'],['access']
Security,// Replace any operand with us an incoming block with the new defining; // access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:75,access,access,75,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['access'],['access']
Security,// Replace the entire unique name with a hash of the unique name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeRecordMapping.cpp:41,hash,hash,41,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeRecordMapping.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeRecordMapping.cpp,1,['hash'],['hash']
Security,"// Report error if there are non-trapping sanitizers that require; // c++abi-specific parts of UBSan runtime, and they are not provided by the; // toolchain. We don't have a good way to check the latter, so we just; // check if the toolchan supports vptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:42,sanitiz,sanitizers,42,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['sanitiz'],['sanitizers']
Security,// Report error if user explicitly tries to disable recovery from; // always recoverable sanitizer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:89,sanitiz,sanitizer,89,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['sanitiz'],['sanitizer']
Security,// Report error if user explicitly tries to recover from unrecoverable; // sanitizer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:75,sanitiz,sanitizer,75,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['sanitiz'],['sanitizer']
Security,"// Require authentication",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/res/rpddefs.h:11,authenticat,authentication,11,net/rpdutils/res/rpddefs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/res/rpddefs.h,1,['authenticat'],['authentication']
Security,"// Require client authentication",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TServerSocket.h:18,authenticat,authentication,18,net/net/inc/TServerSocket.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TServerSocket.h,1,['authenticat'],['authentication']
Security,"// Require match of protocol, user, password, host and port",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/netxng/src/TNetXNGSystem.cxx:36,password,password,36,net/netxng/src/TNetXNGSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/netxng/src/TNetXNGSystem.cxx,1,['password'],['password']
Security,"// Required since we overload TObject::Hash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TParameter.h:39,Hash,Hash,39,core/base/inc/TParameter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TParameter.h,17,['Hash'],['Hash']
Security,// Reserve call frame if the size of the maximum call frame fits into 16-bit; // immediate field and there are no variable sized objects on the stack.; // Make sure the second register scavenger spill slot can be accessed with one; // instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:213,access,accessed,213,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,1,['access'],['accessed']
Security,// Reserve the space for HashOffset field.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp:25,Hash,HashOffset,25,interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,1,['Hash'],['HashOffset']
Security,// Reserved for memory access mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp:23,access,access,23,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterInfo.cpp,1,['access'],['access']
Security,// Reset LastSeenModule to avoid overriding the hash unexpectedly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:48,hash,hash,48,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['hash'],['hash']
Security,"// Reset checkSumAdjustment in order to calculate the; // check sum of the head table",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/mathtext/src/fontembed.cxx:9,checkSum,checkSumAdjustment,9,graf2d/mathtext/src/fontembed.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/mathtext/src/fontembed.cxx,1,['checkSum'],['checkSumAdjustment']
Security,"// Reset data for all summaries. Alive and DSO local will be set back from; // of data flow results below. Anything else will not be accessed; // by ThinLTO backend, so we can save on bitcode size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:133,access,accessed,133,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,1,['access'],['accessed']
Security,"// Reset gAuth (if we have been called this means that we need; // to check at least that a valid authentication exists ...)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:98,authenticat,authentication,98,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['authenticat'],['authentication']
Security,"// Reset the CanDoSetRt flag and retry all accesses that have failed.; // We know that we need these checks, so we can now be more aggressive; // and add further checks if required (overflow checks).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:43,access,accesses,43,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['access'],['accesses']
Security,"// Reset the GlobalResolutions to deallocate the associated memory, as there; // are no further accesses. We specifically want to do this before computing; // cross module importing, which adds to peak memory via the computed import; // and export lists.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:96,access,accesses,96,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['access'],['accesses']
Security,// Reset the hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp:13,hash,hash,13,interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,1,['hash'],['hash']
Security,// Reset the scratch path access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:26,access,access,26,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,1,['access'],['access']
Security,// Resize the constant to the same size as the original memory access before; // extension. If it is still the AllOnesValue then this AND is completely; // unneeded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:63,access,access,63,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['access'],['access']
Security,// Restore the non-secure floating point context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp:19,secur,secure,19,interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,1,['secur'],['secure']
Security,"// Result accessors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMCStudy.h:10,access,accessors,10,roofit/roofitcore/inc/RooMCStudy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMCStudy.h,1,['access'],['accessors']
Security,"// Retrieve the base register, offset from the base register and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4). If; // base registers are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:218,access,access,218,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,9,['access'],"['access', 'accesses']"
Security,"// Retrieve the base, offset from the base and width. Width; // is the size of memory that is being loaded/stored (e.g. 1, 2, 4, 8). If; // base are identical, and the offset of a lower memory access +; // the width doesn't overlap the offset of a higher memory access,; // then the memory accesses are different.; // If OffsetAIsScalable and OffsetBIsScalable are both true, they; // are assumed to have the same scale (vscale).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:193,access,access,193,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,3,['access'],"['access', 'accesses']"
Security,"// Retrieve the serialized size of the given CommonTypeInfo, for use; // in on-disk hash tables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp:84,hash,hash,84,interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesWriter.cpp,1,['hash'],['hash']
Security,"// Return a hash value based on the contents of the frame. Here we don't use; // hashing from llvm ADT since we are going to persist the hash id, the hash; // combine algorithm in ADT uses a new randomized seed each time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h:12,hash,hash,12,interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h,4,['hash'],"['hash', 'hashing']"
Security,"// Return a nul-terminated string even for an empty Slice. This is; // safe because all existing SimplifyLibcalls callers require string; // arguments and the behavior of the functions they fold is undefined; // otherwise. Folding the calls this way is preferable to making; // the undefined library calls, even though it prevents sanitizers; // from reporting such calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:331,sanitiz,sanitizers,331,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['sanitiz'],['sanitizers']
Security,// Return a scattered form of V that can be accessed by Point. V must be a; // vector or a pointer to a vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:44,access,accessed,44,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,1,['access'],['accessed']
Security,"// Return an empty Slice for undersized constants to let callers; // transform even undefined library calls into simpler, well-defined; // expressions. This is preferable to making the calls although it; // prevents sanitizers from detecting such calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:216,sanitiz,sanitizers,216,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['sanitiz'],['sanitizers']
Security,// Return early if we aren't dumping public hash table and address map info.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-pdbutil/DumpOutputStyle.cpp:44,hash,hash,44,interpreter/llvm-project/llvm/tools/llvm-pdbutil/DumpOutputStyle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-pdbutil/DumpOutputStyle.cpp,1,['hash'],['hash']
Security,// Return memory access size,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:17,access,access,17,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,1,['access'],['access']
Security,// Return memory access size in bytes,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h:17,access,access,17,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCInstrInfo.h,1,['access'],['access']
Security,// Return pointer to hash (20 characters),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SHA1.cpp:21,hash,hash,21,interpreter/llvm-project/llvm/lib/Support/SHA1.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SHA1.cpp,1,['hash'],['hash']
Security,// Return pointer to hash (32 characters),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SHA256.cpp:21,hash,hash,21,interpreter/llvm-project/llvm/lib/Support/SHA256.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SHA256.cpp,1,['hash'],['hash']
Security,// Return sanitizers which don't require runtime support and are not; // platform dependent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChain.cpp:10,sanitiz,sanitizers,10,interpreter/llvm-project/clang/lib/Driver/ToolChain.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChain.cpp,1,['sanitiz'],['sanitizers']
Security,"// Return size of hash table",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooLinkedList.h:18,hash,hash,18,roofit/roofitcore/inc/RooLinkedList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooLinkedList.h,1,['hash'],['hash']
Security,// Return the function hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:23,hash,hash,23,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,1,['hash'],['hash']
Security,"// Return the list of rule give raw access to the TBuffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx:36,access,access,36,core/meta/src/TGenericClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx,1,['access'],['access']
Security,"// Return the new alloca, addrspacecasted if required to avoid changing the; // addrspace of a volatile access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:104,access,access,104,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['access'],['access']
Security,"// Return the next reference node in the instruction node IA that is related; // to RA. Conceptually, two reference nodes are related if they refer to the; // same instance of a register access, but differ in flags or other minor; // characteristics. Specific examples of related nodes are shadow reference; // nodes.; // Return the equivalent of nullptr if there are no more related references.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:187,access,access,187,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,1,['access'],['access']
Security,"// Return the number of 32-bit words loaded by LDM or stored by STM. If this; // can't be easily determined return 0 (missing MachineMemOperand).; //; // FIXME: The current MachineInstr design does not support relying on machine; // mem operands to determine the width of a memory access. Instead, we expect; // the target to provide this information based on the instruction opcode and; // operands. However, using MachineMemOperand is the best solution now for; // two reasons:; //; // 1) getNumMicroOps tries to infer LDM memory width from the total number of MI; // operands. This is much more dangerous than using the MachineMemOperand; // sizes because CodeGen passes can insert/remove optional machine operands. In; // fact, it's totally incorrect for preRA passes and appears to be wrong for; // postRA passes as well.; //; // 2) getNumLDMAddresses is only used by the scheduling machine model and any; // machine model that calls this should handle the unknown (zero size) case.; //; // Long term, we should require a target hook that verifies MachineMemOperand; // sizes during MC lowering. That target hook should be local to MC lowering; // because we can't ensure that it is aware of other MI forms. Doing this will; // ensure that MachineMemOperands are correctly propagated through all passes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:281,access,access,281,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['access'],['access']
Security,// Return true if GV can be accessed using LARL for reloc model RM; // and code model CM.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.h:28,access,accessed,28,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.h,1,['access'],['accessed']
Security,// Return true if N (a load or a store) fullfills the alignment; // requirements for a PC-relative access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:99,access,access,99,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,1,['access'],['access']
Security,"// Return true if the decl is of type.; // A proper hashtable for caching results would be the ideal solution; // 1) Only one lookup per type; // 2) No string comparison; // We may use a map which becomes an unordered map if c++11 is enabled?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:52,hash,hashtable,52,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['hash'],['hashtable']
Security,"// Return true when all operands of Instr are available at insertion point; // HoistPt. When limiting the number of hoisted expressions, one could hoist; // a load without hoisting its access function. So before hoisting any; // expression, make sure that all its operands are available at insert point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:185,access,access,185,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['access'],['access']
Security,"// Return value and unit accessors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooStringVar.h:25,access,accessors,25,roofit/roofitcore/inc/RooStringVar.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooStringVar.h,1,['access'],['accessors']
Security,// Returns MD5 hash as a hex string,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:15,hash,hash,15,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['hash'],['hash']
Security,"// Returns a representation of an instruction as a vector of MachineOperand; // hash values, see llvm::hash_value(const MachineOperand &MO) for details.; // This creates a signature of the instruction with the same content; // that MachineOperand::isIdenticalTo uses for comparison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:80,hash,hash,80,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,1,['hash'],['hash']
Security,"// Returns an iterator to the earliest position possible within the MBB,; // satisfying the restrictions given by BeforeSet and AfterSet. BeforeSet; // contains instructions that should go before the marker, and AfterSet contains; // ones that should go after the marker. In this function, AfterSet is only; // used for validation checking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:320,validat,validation,320,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,1,['validat'],['validation']
Security,"// Returns an iterator to the latest position possible within the MBB,; // satisfying the restrictions given by BeforeSet and AfterSet. BeforeSet; // contains instructions that should go before the marker, and AfterSet contains; // ones that should go after the marker. In this function, BeforeSet is only; // used for validation checking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:319,validat,validation,319,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,1,['validat'],['validation']
Security,"// Returns an optional list of (pointer-difference expressions, access size); // pairs that can be used to prove that there are no vectorization-preventing; // dependencies at runtime. There are is a vectorization-preventing dependency; // if any pointer-difference is <u VF * InterleaveCount * access size. Returns; // std::nullopt if pointer-difference checks cannot be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:64,access,access,64,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,2,['access'],['access']
Security,// Returns dummy Pfm counters which can be used to execute generated snippet; // without access to performance counters.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:89,access,access,89,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,1,['access'],['access']
Security,// Returns the MD5 hash as a byte string,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:19,hash,hash,19,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['hash'],['hash']
Security,"// Returns the base register in a memory access (load/store). The offset is; // returned in Offset and the access size is returned in AccessSize.; // If the base operand has a subregister or the offset field does not contain; // an immediate value, return nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:41,access,access,41,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,3,"['Access', 'access']","['AccessSize', 'access']"
Security,"// Returns the maximum number of bytes a load/store instruction can access at; // once. This is typically the size of the largest register available on the; // processor. Note that this only used as a hint to generate independant; // load/stores to/from memory, so the exact returned value does not really; // matter as long as it's large enough.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:68,access,access,68,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,1,['access'],['access']
Security,// Returns the offset from the location of the access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:47,access,access,47,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['access'],['access']
Security,"// Returns the property accessed by this method, either explicitly via; // property syntax or implicitly via a getter or setter method. Returns; // nullptr if the call is not a prooperty access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h:24,access,accessed,24,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h,2,['access'],"['access', 'accessed']"
Security,"// Returns true (the first time) if Ty is, or is found to include, a vector; // type that exposes the vector ABI. This is any vector >=16 bytes which; // with vector support are aligned to only 8 bytes. When IsParam is true,; // the type belongs to a value as passed between functions. If it is a; // vector <=16 bytes it will be passed in a vector register (if supported).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/SystemZ.cpp:90,expose,exposes,90,interpreter/llvm-project/clang/lib/CodeGen/Targets/SystemZ.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/SystemZ.cpp,1,['expose'],['exposes']
Security,"// Returns true if Ptr is the pointer operand of a memory access instruction; // I, I is known to not require scalarization, and the pointer is not also; // stored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:58,access,access,58,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['access'],['access']
Security,"// Returns true if the access to the address should be considered ""atomic"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:23,access,access,23,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,1,['access'],['access']
Security,// Returns true if the instruction can be proven to do only two types of; // memory accesses:; // (1) live stack locations in-bounds or; // (2) non-stack locations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:84,access,accesses,84,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,1,['access'],['accesses']
Security,// Returns whether the instruction can safely move past a DMB instruction; // The current implementation allows this iif MI does not have any possible; // memory access,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMOptimizeBarriersPass.cpp:162,access,access,162,interpreter/llvm-project/llvm/lib/Target/ARM/ARMOptimizeBarriersPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMOptimizeBarriersPass.cpp,1,['access'],['access']
Security,// Reverse member pointer conversion. C++ 4.11 specifies member pointer; // conversion. C++ 5.2.9p9 has additional information.; // DR54's access restrictions apply here also.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:139,access,access,139,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,1,['access'],['access']
Security,// Reverting optimal scheduling in favour of occupancy with basic block(s); // having dense global memory access can potentially hurt performance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.cpp:106,access,access,106,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.cpp,1,['access'],['access']
Security,// Rewriting ivar access,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:18,access,access,18,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,1,['access'],['access']
Security,"// Right now, this class is passed around as a cheap value type.; // If you add more members, especially non-POD members, please; // audit the users to pass it by reference instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetCXXABI.h:133,audit,audit,133,interpreter/llvm-project/clang/include/clang/Basic/TargetCXXABI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetCXXABI.h,1,['audit'],['audit']
Security,"// RooArgLists can have duplicate object, so we can't do hash-assisted lookups.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCollection.cxx:57,hash,hash-assisted,57,roofit/roofitcore/src/RooAbsCollection.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCollection.cxx,1,['hash'],['hash-assisted']
Security,// Rotate loops to expose bit-simplification opportunities.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp:19,expose,expose,19,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetMachine.cpp,1,['expose'],['expose']
Security,"// Rotate the 2 ops so we can access both ranges, then permute the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:30,access,access,30,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['access'],['access']
Security,// Routines that add DIEValues to the hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:38,hash,hash,38,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,1,['hash'],['hash']
Security,"// Run Authentication now",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TServerSocket.cxx:7,Authenticat,Authentication,7,net/net/src/TServerSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TServerSocket.cxx,1,['Authenticat'],['Authentication']
Security,"// Run profile matching for checksum mismatched profile, currently only; // support for pseudo-probe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:28,checksum,checksum,28,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['checksum'],['checksum']
Security,// Run the user callback on all accesses we cannot skip and return if; // that succeeded for all or not.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:32,access,accesses,32,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['access'],['accesses']
Security,// Run through all of the instructions in the basic block and try to; // collect potential pairs of GOT indirect access instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:113,access,access,113,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,1,['access'],['access']
Security,// SCEV does not look through non-header PHIs inside the loop. Such phis; // can be analyzed by adding separate accesses for each incoming pointer; // value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:112,access,accesses,112,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['access'],['accesses']
Security,// SCRATCH instructions always access scratch.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:31,access,access,31,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['access'],['access']
Security,"// Safari and Chrome report weird non-integral values for a notched wheel,; // but still expose actual lines scrolled via wheelDelta. Notched wheels; // should behave the same way as arrow keys.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:89,expose,expose,89,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['expose'],['expose']
Security,// Same hash value means we should add the StmtSequence to the current; // group.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:8,hash,hash,8,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,1,['hash'],['hash']
Security,// Sandbox memory access or SP change. Insert mask operation before and/or; // after the instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:18,access,access,18,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,1,['access'],['access']
Security,// Sandbox memory access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp:18,access,access,18,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsNaClELFStreamer.cpp,1,['access'],['access']
Security,"// Sanitize size of slice",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RTensor.hxx:3,Sanitiz,Sanitize,3,tmva/tmva/inc/TMVA/RTensor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RTensor.hxx,1,['Sanitiz'],['Sanitize']
Security,"// Sanitize slice indices; // TODO: Sanitize slice indices; /*; for (std::size_t i = 0; i < sliceSize; i++) {; }; */; // Convert -1 in slice to proper pair of indices; // TODO; // Recompute shape and size",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RTensor.hxx:3,Sanitiz,Sanitize,3,tmva/tmva/inc/TMVA/RTensor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RTensor.hxx,2,['Sanitiz'],['Sanitize']
Security,// Sanitize user input in case of no asserts,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp:3,Sanitiz,Sanitize,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp,1,['Sanitiz'],['Sanitize']
Security,// SanitizeCoverage is not handled by SanOpts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:3,Sanitiz,SanitizeCoverage,3,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,1,['Sanitiz'],['SanitizeCoverage']
Security,// Sanitizer coverage uses the address of the next instruction - 1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/sancov/sancov.cpp:3,Sanitiz,Sanitizer,3,interpreter/llvm-project/llvm/tools/sancov/sancov.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/sancov/sancov.cpp,1,['Sanitiz'],['Sanitizer']
Security,"// Sanitizer feature mismatches are treated as compatible differences. If; // compatible differences aren't allowed, we still only want to check for; // mismatches of non-modular sanitizers (the only ones which can affect AST; // generation).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Sanitiz,Sanitizer,3,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,2,"['Sanitiz', 'sanitiz']","['Sanitizer', 'sanitizers']"
Security,// Sanitizer ignorelist arguments are generated from LanguageOptions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:3,Sanitiz,Sanitizer,3,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['Sanitiz'],['Sanitizer']
Security,// SanitizerKind,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h:3,Sanitiz,SanitizerKind,3,interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h,1,['Sanitiz'],['SanitizerKind']
Security,// Sanitizers can abandon<GlobalsAA>.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:3,Sanitiz,Sanitizers,3,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,1,['Sanitiz'],['Sanitizers']
Security,"// Sanitizers look at the value of the stack at the location; // of the crash. Since a crash can happen anywhere, the; // frame must be lowered before anything else happen for the; // sanitizers to be able to get a correct stack frame.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:3,Sanitiz,Sanitizers,3,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,2,"['Sanitiz', 'sanitiz']","['Sanitizers', 'sanitizers']"
Security,// Sanitizers may use markers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:3,Sanitiz,Sanitizers,3,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,1,['Sanitiz'],['Sanitizers']
Security,// Sanitizers require the hostcall buffer passed in the implicit arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAttributor.cpp:3,Sanitiz,Sanitizers,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAttributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAttributor.cpp,1,['Sanitiz'],['Sanitizers']
Security,"// Save only weights with smallest validation loss",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyTorch.cxx:35,validat,validation,35,tmva/pymva/src/MethodPyTorch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyTorch.cxx,1,['validat'],['validation']
Security,// Save the current top-level hash value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:30,hash,hash,30,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,1,['hash'],['hash']
Security,// Save the exception code in the exception slot to unify exception access in; // the filter function and the landing pad.; // struct EXCEPTION_POINTERS {; // EXCEPTION_RECORD *ExceptionRecord;; // CONTEXT *ContextRecord;; // };; // int exceptioncode = exception_pointers->ExceptionRecord->ExceptionCode;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:68,access,access,68,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,1,['access'],['access']
Security,// Save the location of Header.HashOffset field in \c OS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp:31,Hash,HashOffset,31,interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,1,['Hash'],['HashOffset']
Security,// Save the location of MemProf profile data. This is stored in two parts as; // the schema and as a separate on-disk chained hashtable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp:126,hash,hashtable,126,interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,1,['hash'],['hashtable']
Security,"// Save the module hash produced for the full bitcode, which will; // be used in the backends, and use that in the minimized bitcode; // produced for the full link.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:19,hash,hash,19,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,1,['hash'],['hash']
Security,// Save the non-secure floating point context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp:16,secur,secure,16,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,1,['secur'],['secure']
Security,// Save the written hash value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:20,hash,hash,20,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,1,['hash'],['hash']
Security,"// Scalar integer divide and remainder are lowered to use operations that; // produce two results, to match the available instructions. This exposes; // the two-result form to trivial CSE, which is able to combine x/y and x%y; // into a single instruction.; //; // Scalar integer multiply-high is also lowered to use two-result; // operations, to match the available instructions. However, plain multiply; // (low) operations are left as Legal, as there are single-result; // instructions for this in x86. Using the two-result multiply instructions; // when both high and low results are needed must be arranged by dagcombine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:141,expose,exposes,141,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['expose'],['exposes']
Security,"// Scalar loads of size 8 or 16 bit with proper alignment may be widened to; // 32 bit. Check to see if we need to widen the memory access, 8 or 16 bit; // scalar loads should have a load size of 32 but memory access size of less; // than 32.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:132,access,access,132,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,2,['access'],['access']
Security,// Scalar nodes can only be accessed at offset 0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:28,access,accessed,28,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['access'],['accessed']
Security,"// Scalar nodes have only one possible ""field"" -- their parent in the access; // hierarchy. Offset must be zero at this point, but our caller is supposed; // to check that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:70,access,access,70,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['access'],['access']
Security,"// Scan all accesses of another equivalence class, but only the next; // accesses of the same equivalent class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:12,access,accesses,12,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,2,['access'],['accesses']
Security,// Scan the block for upward-exposed uses and add them to the tracking set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:29,expose,exposed,29,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,1,['expose'],['exposed']
Security,// Scan the methods for accesses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp:24,access,accesses,24,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCUnusedIVarsChecker.cpp,1,['access'],['accesses']
Security,// Scope and SP could be the same MDNode and we don't want to skip; // validation in that case,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:71,validat,validation,71,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['validat'],['validation']
Security,"// Scratch is allocated in 256 dword per wave blocks for the entire; // wavefront. When viewed from the perspective of an arbitrary workitem, this; // is 4-byte aligned.; //; // Only 4-byte alignment is really needed to access anything. Transformations; // on the pointer value itself may rely on the alignment / known low bits of; // the pointer. Set this to something above the minimum to avoid needing; // dynamic realignment in common cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h:220,access,access,220,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,1,['access'],['access']
Security,// Search SYSV hash table to try to find the upper bound of dynsym.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h:15,hash,hash,15,interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,1,['hash'],['hash']
Security,// Search all blocks after the loop for accesses to the same stack slot.; // ReachingDefAnalysis doesn't work for sp as it relies on registers being; // live-out (which sp never is) to know what blocks to look in,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:40,access,accesses,40,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,1,['access'],['accesses']
Security,"// Search for the branchname, determine what it contains, and wire the; // TBranchProxy representing it to us so we can access its data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx:120,access,access,120,tree/treeplayer/src/TTreeReaderValue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx,1,['access'],['access']
Security,"// Search for the branchname, determine what it contains, and wire the; // TBranchProxy representing it to us so we can access its data.; // A proxy for branch must not have been created before (i.e. check; // fProxies before calling this function!)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx:120,access,access,120,tree/treeplayer/src/TTreeReaderValue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx,1,['access'],['access']
Security,"// Search in bottom-up program order for pairs of accesses (A and B) that can; // form interleaved load or store groups. In the algorithm below, access A; // precedes access B in program order. We initialize a group for B in the; // outer loop of the algorithm, and then in the inner loop, we attempt to; // insert each A into B's group if:; //; // 1. A and B have the same stride,; // 2. A and B have the same memory object size, and; // 3. A belongs in B's group according to its distance from B.; //; // Special care is taken to ensure group formation will not break any; // dependences.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:50,access,accesses,50,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,3,['access'],"['access', 'accesses']"
Security,"// Search the hashtable for another tree with the same digest, and; // if find a collision compare those trees by their contents.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:14,hash,hashtable,14,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,1,['hash'],['hashtable']
Security,"// Second argument is a callable, but we can't fully validate it until we try; // calling it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:53,validat,validate,53,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['validat'],['validate']
Security,"// Secret key (for authentication)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TS3HTTPRequest.h:19,authenticat,authentication,19,net/net/inc/TS3HTTPRequest.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TS3HTTPRequest.h,1,['authenticat'],['authentication']
Security,// Section headers do not exist. Falling back to infer; // upper bound of .dynsym from .gnu.hash and .hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h:92,hash,hash,92,interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,2,['hash'],['hash']
Security,// SectionRef accessors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:14,access,accessors,14,interpreter/llvm-project/llvm/include/llvm-c/Object.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h,2,['access'],['accessors']
Security,// Security Extensions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMMachineFunctionInfo.h:3,Secur,Security,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMMachineFunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMMachineFunctionInfo.h,1,['Secur'],['Security']
Security,"// Security level from the list (if not in cleanup mode ...)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:3,Secur,Security,3,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['Secur'],['Security']
Security,"// Security: would the learning lead to non real numbers,; // the learning should stop now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMultiLayerPerceptron.cxx:3,Secur,Security,3,math/mlp/src/TMultiLayerPerceptron.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMultiLayerPerceptron.cxx,1,['Secur'],['Security']
Security,"// See comment on the values above.; // Note that we have a single-dword or sub-dword here, so if underaligned; // it is a slowest possible access, hence returned value is 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:140,access,access,140,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['access'],['access']
Security,// See comments in performSTORECombine() for more details about; // these conditions.; // Code that uses clang vector extensions can mark that it; // wants unaligned accesses to be treated as fast by; // underspecifying alignment to be 1 or 2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:166,access,accesses,166,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['access'],['accesses']
Security,"// See https://flapenguin.me/2017/05/10/elf-lookup-dt-gnu-hash/ for .gnu.hash; // table layout.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp:58,hash,hash,58,interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,2,['hash'],['hash']
Security,"// See https://github.com/google/sanitizers/issues/32; // Constant CFString instances are compiled in the following way:; // -- the string buffer is emitted into; // __TEXT,__cstring,cstring_literals; // -- the constant NSConstantString structure referencing that buffer; // is placed into __DATA,__cfstring; // Therefore there's no point in placing redzones into __DATA,__cfstring.; // Moreover, it causes the linker to crash on OS X 10.7",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:33,sanitiz,sanitizers,33,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['sanitiz'],['sanitizers']
Security,// See if it's a property accessor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:26,access,accessor,26,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,1,['access'],['accessor']
Security,// See if the access is within the bounds of the transfer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:14,access,access,14,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,1,['access'],['access']
Security,// See if we are inside a property accessor.; //; // Record the current tokenPosition so that we can advance and; // reset the current token. `Next` is not set yet so we need; // another way to advance along the token stream.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:35,access,accessor,35,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,1,['access'],['accessor']
Security,"// See if we can peek through to a vector with a wider element type, if the; // signbits extend down to all the sub-elements as well.; // Calling MOVMSK with the wider type, avoiding the bitcast, helps expose; // potential SimplifyDemandedBits/Elts cases.; // If we looked through a truncate that discard bits, we can't do this; // transform.; // FIXME: We could do this transform for truncates that discarded bits by; // inserting an AND mask between the new MOVMSK and the CMP.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:202,expose,expose,202,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['expose'],['expose']
Security,// Seed the table with accesses to the LHS and RHS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp:23,access,accesses,23,interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/PerfectShuffle/PerfectShuffle.cpp,1,['access'],['accesses']
Security,// Select the `ual` feature determined by -m[no-]unaligned-access; // or the alias -m[no-]strict-align.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp:59,access,access,59,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/LoongArch.cpp,1,['access'],['access']
Security,// SelectionDAG node properties.; // SDNPMemOperand: indicates that a node touches memory and therefore must; // have an associated memory operand that describes the access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SDNodeProperties.h:166,access,access,166,interpreter/llvm-project/llvm/utils/TableGen/SDNodeProperties.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SDNodeProperties.h,1,['access'],['access']
Security,"// Sema has done some convenient canonicalization here: if the; // access path involved any virtual steps, the conversion path will; // *start* with a step down to the correct virtual base subobject,; // and hence will not require any further steps.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:67,access,access,67,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,1,['access'],['access']
Security,"// Sema requires access to the following functions because the current design; // of SFINAE requires it to use its own SemaDiagnosticBuilder, which needs to; // access us directly to ensure we minimize the emitted code for the common; // Sema::Diag() patterns.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:17,access,access,17,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,2,['access'],['access']
Security,"// Send it over encrypted",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:16,encrypt,encrypted,16,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['encrypt'],['encrypted']
Security,"// Send the key securely",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:16,secur,securely,16,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['secur'],['securely']
Security,"// Send token encrypted",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:14,encrypt,encrypted,14,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['encrypt'],['encrypted']
Security,"// Sent over the number of entries in the file, used by packetizer do not relying; // on initial validation. Also, -1 means that the file could not be open, which is; // used to flag files as missing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:97,validat,validation,97,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['validat'],['validation']
Security,"// Serialise access to the FQDN list",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/netxng/inc/TNetXNGSystem.h:13,access,access,13,net/netxng/inc/TNetXNGSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/netxng/inc/TNetXNGSystem.h,1,['access'],['access']
Security,"// Serialize access to <waiters_count_>.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/TWin32Condition.h:13,access,access,13,core/thread/inc/TWin32Condition.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/TWin32Condition.h,1,['access'],['access']
Security,// Serialize rendezvous with the debugger as well as access to shared data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp:53,access,access,53,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.cpp,1,['access'],['access']
Security,"// Service functions (useful in the verification code).; // They print some detail info if the validation condition fails",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/inc/TMatrixTBase.h:95,validat,validation,95,math/matrix/inc/TMatrixTBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/inc/TMatrixTBase.h,1,['validat'],['validation']
Security,"// Session token (for authentication)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TS3HTTPRequest.h:22,authenticat,authentication,22,net/net/inc/TS3HTTPRequest.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TS3HTTPRequest.h,1,['authenticat'],['authentication']
Security,"// Set ""llvm.mem.parallel_loop_access"" metaData to versioned loop.; // FIXME: ""llvm.mem.parallel_loop_access"" annotates memory access; // instructions, not loops.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:127,access,access,127,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,1,['access'],['access']
Security,"// Set BaseReg (the base register operand), Offset (the byte offset being; // accessed) and the access Width of the passed instruction that reads/writes; // memory. Returns false if the instruction does not read/write memory or the; // BaseReg/Offset/Width can't be determined. Is not guaranteed to always; // recognise base operands and offsets in all cases.; // TODO: Add an IsScalable bool ref argument (like the equivalent AArch64; // function) and set it as appropriate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:78,access,accessed,78,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,2,['access'],"['access', 'accessed']"
Security,"// Set S3-specific data members. If the access and secret keys are not; // provided in the 'options' argument we look in the environmental; // variables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TS3WebFile.cxx:40,access,access,40,net/net/src/TS3WebFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TS3WebFile.cxx,1,['access'],['access']
Security,// Set access bits correctly on the directly-declared conversions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:7,access,access,7,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,2,['access'],['access']
Security,"// Set also the user, otherwise the password is not exported",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:36,password,password,36,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,2,['password'],['password']
Security,"// Set checkSumAdjustment in the head table",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/mathtext/src/fontembed.cxx:7,checkSum,checkSumAdjustment,7,graf2d/mathtext/src/fontembed.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/mathtext/src/fontembed.cxx,1,['checkSum'],['checkSumAdjustment']
Security,// Set execute-only access for the explicit section,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetObjectFile.cpp:20,access,access,20,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetObjectFile.cpp,1,['access'],['access']
Security,// Set if at least 1 basic block has relatively; // high global memory access,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.h:71,access,access,71,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.h,1,['access'],['access']
Security,// Set metadata access for the explicit section,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetObjectFile.cpp:16,access,access,16,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetObjectFile.cpp,1,['access'],['access']
Security,// Set of access to check after all writes have been processed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:10,access,access,10,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['access'],['access']
Security,// Set of accesses/instructions that will overwrite the result and are; // therefore blockers in the reachability traversal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:10,access,accesses,10,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['access'],['accesses']
Security,// Set the MachineFunction to nullptr so that we can catch attempted; // accesses to MF specific features at the module level and so that; // we can conditionalize accesses based on whether or not it is nullptr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:73,access,accesses,73,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,2,['access'],['accesses']
Security,"// Set the Url for remote access",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TSelEventGen.cxx:26,access,access,26,proof/proofbench/src/TSelEventGen.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TSelEventGen.cxx,1,['access'],['access']
Security,// Set the access specifier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:11,access,access,11,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['access'],['access']
Security,"// Set the authentication information we need to use; // for this file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TS3WebFile.cxx:11,authenticat,authentication,11,net/net/src/TS3WebFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TS3WebFile.cxx,1,['authenticat'],['authentication']
Security,// Set the function hash code for the target profile.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h:20,hash,hash,20,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,1,['hash'],['hash']
Security,"// Set the list of Data Model Evolution read rules giving direct access to the TBuffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx:65,access,access,65,core/meta/src/TGenericClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGenericClassInfo.cxx,1,['access'],['access']
Security,// Set the marked values as tainted. The return value only accessible from; // checkPostStmt.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:59,access,accessible,59,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,1,['access'],['accessible']
Security,// Set the new type for the injected decl too.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:28,inject,injected,28,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['inject'],['injected']
Security,"// Set to the strictest access of the member and the type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TDataMember.cxx:24,access,access,24,core/meta/src/TDataMember.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TDataMember.cxx,1,['access'],['access']
Security,"// Set up the module path, including the hash for the module-creation options.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:41,hash,hash,41,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['hash'],['hash']
Security,// Setup a callback to convert from frame ids to frame using the on-disk; // FrameData hash table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp:87,hash,hash,87,interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp,1,['hash'],['hash']
Security,// Setup access to the debug info.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:9,access,access,9,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,1,['access'],['access']
Security,"// Setup ignorelist files.; // Add default ignorelist from resource directory for activated sanitizers,; // and validate special case lists format.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:92,sanitiz,sanitizers,92,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,2,"['sanitiz', 'validat']","['sanitizers', 'validate']"
Security,// Setup the loop analysis manager from its proxy. It is important that; // this is only done when there are loops to process and we have built the; // LoopStandardAnalysisResults object. The loop analyses cached in this; // manager have access to those analysis results and so it must invalidate; // itself when they go away.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:238,access,access,238,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,1,['access'],['access']
Security,// ShortCut a function where for every BB the exit of the largest region; // starting with BB is stored. These regions can be threated as single BBS.; // This improves performance on linear CFGs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h:126,threat,threated,126,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,1,['threat'],['threated']
Security,"// Should be called before we add system libraries (C++ ABI, libstdc++/libc++,; // C runtime, etc). Returns true if sanitizer system deps need to be linked in.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:116,sanitiz,sanitizer,116,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,1,['sanitiz'],['sanitizer']
Security,// Should be called within CodeGenFunction::SanitizerScope RAII scope.; // Returns 'i1 false' when the conversion Src -> Dst changed the sign.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:44,Sanitiz,SanitizerScope,44,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['Sanitiz'],['SanitizerScope']
Security,// Should be called within CodeGenFunction::SanitizerScope RAII scope.; // Returns 'i1 false' when the truncation Src -> Dst was lossy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:44,Sanitiz,SanitizerScope,44,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['Sanitiz'],['SanitizerScope']
Security,"// Should call the access-method first, so sqlite3 can check whether a NULL-terminator; // needs to be added to the byte-count, e.g. for BLOB!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/sql/sqlite/src/TSQLiteRow.cxx:19,access,access-method,19,sql/sqlite/src/TSQLiteRow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/sql/sqlite/src/TSQLiteRow.cxx,1,['access'],['access-method']
Security,// Should not instrument sanitizer init functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:25,sanitiz,sanitizer,25,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,1,['sanitiz'],['sanitizer']
Security,"// Shrink the subtree_len until it evenly divides the count so far. We know; // that subtree_len itself is a power of 2, so we can use a bitmasking; // trick instead of an actual remainder operation. (Note that if the caller; // consistently passes power-of-2 inputs of the same size, as is hopefully; // typical, this loop condition will always fail, and subtree_len will; // always be the full length of the input.); //; // An aside: We don't have to shrink subtree_len quite this much. For; // example, if count_so_far is 1, we could pass 2 chunks to; // compress_subtree_to_parent_node. Since we'll get 2 CVs back, we'll still; // get the right answer in the end, and we might get to use 2-way SIMD; // parallelism. The problem with this optimization, is that it gets us; // stuck always hashing 2 chunks. The total number of chunks will remain; // odd, and we'll never graduate to higher degrees of parallelism. See; // https://github.com/BLAKE3-team/BLAKE3/issues/69.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c:792,hash,hashing,792,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,1,['hash'],['hashing']
Security,// Signedness only checked when final array elements are accessed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:57,access,accessed,57,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,1,['access'],['accessed']
Security,// Silently discard any unsupported sanitizers implicitly enabled through; // group expansion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:36,sanitiz,sanitizers,36,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['sanitiz'],['sanitizers']
Security,"// Similarly, dive into enums and fish their constants out, making them; // accessible in this scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:76,access,accessible,76,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['access'],['accessible']
Security,// Simple check if not a strided access - clear order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,access,access,33,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['access'],['access']
Security,"// Since it's desired that the load/store instructions be maintained in; // ""program order"" for the interleaved access analysis, we have to visit the; // blocks in the loop in reverse postorder (i.e., in a topological order).; // Such an ordering will ensure that any load/store that may be executed; // before a second load/store will precede the second load/store in; // AccessStrideInfo.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:112,access,access,112,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,2,"['Access', 'access']","['AccessStrideInfo', 'access']"
Security,"// Since lowerConstant already folded and got rid of all IR pointer and; // integer casts, detect GOT equivalent accesses by looking into the MCExpr; // directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:113,access,accesses,113,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['access'],['accesses']
Security,"// Since the access counts will be accumulated across the entire allocation,; // we only update the shadow access count for the first location and thus; // don't need to worry about alignment and type size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:13,access,access,13,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,2,['access'],['access']
Security,"// Since the resource directory is embedded in the module hash, it's important; // that all places that need it call this function, so that they get the; // exact same string (""a/../b/"" and ""b/"" get different hashes, for example).; // Dir is bin/ or lib/, depending on where BinaryPath is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:58,hash,hash,58,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,2,['hash'],"['hash', 'hashes']"
Security,"// Since these are not real X-Form instructions, we must; // add the registers and access 0(NewReg) rather than; // emitting the X-Form pseudo.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:83,access,access,83,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,1,['access'],['access']
Security,"// Since this member now becomes a new top-level record, it should have; // gotten a RecordPrefix injected, and that RecordPrefix + the member we; // just wrote should now constitute the entirety of the current ""new""; // segment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/ContinuationRecordBuilder.cpp:98,inject,injected,98,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/ContinuationRecordBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/ContinuationRecordBuilder.cpp,1,['inject'],['injected']
Security,"// Since we already check via other means (TClassTable which is populated by; // the dictonary loading, and the gROOT list of classes and enums, which are; // populated via TProtoClass/Enum), we should be able to disable the autoloading; // ... which requires access to libCore or libCling ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:260,access,access,260,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['access'],['access']
Security,"// Since we may not have visited the input blocks of the phis, we can't; // use our normal hash approach for phis. Instead, simply look for; // obvious duplicates. The first pass of GVN will tend to create; // identical phis, and the second or later passes can eliminate them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:91,hash,hash,91,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['hash'],['hash']
Security,// Single source offloading languages like CUDA/HIP need to be able to; // access static device variables from host code of the same compilation; // unit. This is done by externalizing the static variable with a shared; // name between the host and device compilation which is the same for the; // same compilation unit whereas different among different compilation; // units.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:75,access,access,75,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['access'],['access']
Security,"// Single vertex accessors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLBoundingBox.h:17,access,accessors,17,graf3d/gl/inc/TGLBoundingBox.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLBoundingBox.h,1,['access'],['accessors']
Security,// Size of the symbol; // These accessors and mutators are identical to those defined for ELF32; // symbol table entries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:32,access,accessors,32,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['access'],['accessors']
Security,// Skip blocks only accessible through NewSucc.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:20,access,accessible,20,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,1,['access'],['accessible']
Security,"// Skip if we do not have NEON and skip illegal vector types. We can; // ""legalize"" wide vector types into multiple interleaved accesses as long as; // the vector types are divisible by 128.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:128,access,accesses,128,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,4,['access'],['accesses']
Security,// Skip instrumentation of stack accesses unless requested.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:33,access,accesses,33,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,1,['access'],['accesses']
Security,// Skip memory accesses inserted by another instrumentation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:15,access,accesses,15,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,1,['access'],['accesses']
Security,// Skip over the COPY that we just validated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:35,validat,validated,35,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['validat'],['validated']
Security,// Skip property accessor function stubs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:17,access,accessor,17,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['access'],['accessor']
Security,// Skip pseudo probe intrinsic calls which are not really killing any memory; // accesses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:81,access,accesses,81,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['access'],['accesses']
Security,// Skip sub-object accesses into rvalues.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:19,access,accesses,19,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,1,['access'],['accesses']
Security,// Skip the following hashhash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:22,hash,hashhash,22,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,1,['hash'],['hashhash']
Security,// Skip the hash.; // Determine the length of the key and the data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h:12,hash,hash,12,interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h,1,['hash'],['hash']
Security,// Skip the stored signature.; // FIXME: we could read the signature out of the import and validate it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:91,validat,validate,91,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,1,['validat'],['validate']
Security,// Skip this line table as it isn't valid. No need to create an error; // here because we validate this in the .debug_info verifier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp:90,validat,validate,90,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,1,['validat'],['validate']
Security,"// Skip uninteresting fields: either special to us, or injected; // template parameters (if they contain a ':').",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SearchableTableEmitter.cpp:55,inject,injected,55,interpreter/llvm-project/llvm/utils/TableGen/SearchableTableEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SearchableTableEmitter.cpp,1,['inject'],['injected']
Security,"// Skip unnamed declarations, e.g. in; // struct S {; // struct { int i; }; // };; // the inner struct corresponds to an unnamed member variable,; // where only `S::i` should be exposed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingDataMemberInfo.cxx:178,expose,exposed,178,core/metacling/src/TClingDataMemberInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingDataMemberInfo.cxx,1,['expose'],['exposed']
Security,"// Slice and return the beginning of the new block.; // If we need to split between the terminators, we theoritically; // need to know where the first and second set of terminators end; // to update the successors properly.; // Now, in pratice, we should have a maximum of 2 branch; // instructions; one conditional and one unconditional. Therefore; // we know how to update the successor by looking at the target of; // the unconditional branch.; // If we end up splitting at some point, then, we should update; // the liveness information and such. I.e., we would need to; // access P here.; // The machine verifier should actually make sure such cases; // cannot happen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:578,access,access,578,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['access'],['access']
Security,"// Small helper to match special cases in range-for loops.; //; // It is possible that containers do not provide a const-overload for their; // iterator accessors. If this is the case, the variable is used non-const; // no matter what happens in the loop. This requires special detection as it; // is then faster to find all mutations of the loop variable.; // It aims at a different modification as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp:153,access,accessors,153,interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,1,['access'],['accessors']
Security,"// So that the TTreeCloner can access the protected interfaces",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:31,access,access,31,tree/tree/inc/TTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h,1,['access'],['access']
Security,// Some ABIs may result in additional accesses to arguments that may; // otherwise not be present.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:38,access,accesses,38,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['access'],['accesses']
Security,"// Some accesses go beyond the end of the global, don't bother.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:8,access,accesses,8,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['access'],['accesses']
Security,// Some architectures allow more than one constant bus access without; // SGPR restriction,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFixSGPRCopies.cpp:55,access,access,55,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFixSGPRCopies.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFixSGPRCopies.cpp,1,['access'],['access']
Security,"// Some call descriptions aren't easily hashable (eg., the ones with qualified; // names in which some sections are omitted), so let's put them; // in a simple vector and use linear lookup.; // TODO: Implement an actual map for fast lookup for ""hashable"" call; // descriptions (eg., the ones for C functions that just match the name).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallDescription.h:40,hash,hashable,40,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallDescription.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallDescription.h,2,['hash'],['hashable']
Security,"// Some compiler-generated accesses are known racy, to avoid false positives; // in data-race analysis pretend they're atomic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:27,access,accesses,27,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,1,['access'],['accesses']
Security,"// Some derived sections might have their own special entries. This method; // returns a vector of <entry name, is used> pairs. It is used for section; // validation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjectYAML/ELFYAML.h:155,validat,validation,155,interpreter/llvm-project/llvm/include/llvm/ObjectYAML/ELFYAML.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjectYAML/ELFYAML.h,1,['validat'],['validation']
Security,"// Some helper functions; // (Not strictly necessary because; // methods are publicly accessible)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/Sample.cxx:86,access,accessible,86,roofit/histfactory/src/Sample.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/Sample.cxx,1,['access'],['accessible']
Security,// Some instructions define regs that are not represented in the selection DAG; // (e.g. unused flags). See tMOVi8. Make sure we don't access past NumValues.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:135,access,access,135,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,1,['access'],['access']
Security,"// Some intervals are suspicious! In some cases we find address; // calculations outside of the lifetime zone, but not actual memory; // read or write. Memory accesses outside of the lifetime zone are a clear; // violation, but address calculations are okay. This can happen when; // GEPs are hoisted outside of the lifetime zone.; // So, in here we only check instructions which can read or write memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:159,access,accesses,159,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,1,['access'],['accesses']
Security,"// Some overloaded operators to facilitate dealing with an TGeoRCPtr as a conventional C pointer.; // Without these operators, one can still use the less transparent Get() method to access the pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoRCPtr.h:182,access,access,182,geom/geom/inc/TGeoRCPtr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoRCPtr.h,1,['access'],['access']
Security,// Some targets default to -fno-direct-access-external-data even for; // -fno-pic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:39,access,access-external-data,39,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['access'],['access-external-data']
Security,// Some targets require that all access to thread local variables go through; // the thread wrapper. This means that we cannot attempt to create a thread; // wrapper or a thread helper.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:33,access,access,33,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['access'],['access']
Security,"// Some transformations (e.g. instcombine) may decide to turn a Fortran; // character object into an integer, and later ones (e.g. SROA) may; // further inject a constant integer in a llvm.dbg.value call to track; // the object's value. Here we trust the transformations are doing the; // right thing, and treat the constant as unsigned to preserve that value; // (i.e. avoid sign extension).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp:153,inject,inject,153,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp,1,['inject'],['inject']
Security,"// Somehow in the process of copy the pointer from one hash to; // other we ended up inducing the addition of more element to; // the table. Most likely those elements have not been copied ....; // i.e. Adding *during* the Rehashing is illegal and fatal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/THashTable.cxx:55,hash,hash,55,core/cont/src/THashTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/THashTable.cxx,1,['hash'],['hash']
Security,"// Something went very wrong and even-though we searched for the baskets; // holding 'entry' we somehow ended up with a range of entries that does; // validate. So we must have been unable to find or fit the needed basket.; // And thus even-though, we know the corresponding baskets wont be in the cache,; // Let's make it official that 'entry' is within the range of this TTreeCache ('s search.); // Without this, the next read will be flagged as 'out-of-range' and then we start at; // the exact same point as this FillBuffer execution resulting in both the requested; // entry still not being part of the cache **and** the beginning of the cluster being; // read **again**.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:151,validat,validate,151,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['validat'],['validate']
Security,"// Sometimes needed libraries are passed by name, such as when using; // sanitizers. We need to check the file magic for any libraries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp:73,sanitiz,sanitizers,73,interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp,1,['sanitiz'],['sanitizers']
Security,"// Sometimes some bunch is not decrypted correctly; // That's why we make retries to make sure that encryption/decryption; // works as expected",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:100,encrypt,encryption,100,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,2,['encrypt'],['encryption']
Security,// Sometimes the interleaved access pass picks up splats as interleaves of; // one element. Don't lower these.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:29,access,access,29,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['access'],['access']
Security,"// Sometimes, it is possible for the target to tell, even without; // aliasing information, that two MIs access different memory; // addresses. This function returns true if two MIs access different; // memory addresses and false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:105,access,access,105,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,2,['access'],['access']
Security,"// Sometimes, it is possible for the target; // to tell, even without aliasing information, that two MIs access different; // memory addresses. This function returns true if two MIs access different; // memory addresses and false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:105,access,access,105,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,2,['access'],['access']
Security,// Sort PHIs to validate into RPO-order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:16,validat,validate,16,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['validat'],['validate']
Security,// Sort by hash value so that blocks with identical end sequences sort; // together.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:11,hash,hash,11,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['hash'],['hash']
Security,// Sort the contents of the buckets by hash value so that hash collisions end; // up together. Stable sort makes testing easier and doesn't cost much more.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:39,hash,hash,39,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,2,['hash'],['hash']
Security,// Sort the global constants to make access more efficient.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp:37,access,access,37,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMergeStringPool.cpp,1,['access'],['access']
Security,"// Source checksum string",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TSchemaRule.h:10,checksum,checksum,10,core/meta/inc/TSchemaRule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TSchemaRule.h,1,['checksum'],['checksum']
Security,"// Sparc always has a fixed frame pointer register, so don't need to; // worry about needing to reserve it. [even if we don't have a frame; // pointer for our frame, it still cannot be used for other things,; // or register window traps will be SADNESS.]; // If there's a reserved call frame, we can use SP to access locals.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcRegisterInfo.cpp:310,access,access,310,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcRegisterInfo.cpp,1,['access'],['access']
Security,"// Special case std::pair to detect when both types are viable and when there; // is no alignment-derived padding in the pair. This is a bit of a lie because; // std::pair isn't truly POD, but it's close enough in all reasonable; // implementations for our use case of hashing the underlying data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:269,hash,hashing,269,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,1,['hash'],['hashing']
Security,"// Special handling for OpenCL bool vectors:; // Since these vectors are stored as packed bits, but we can't read; // individual bits from the BitCastBuffer, we'll buffer all of the; // elements together into an appropriately sized APInt and write them all; // out at once. Because we don't accept vectors where NElts * EltSize; // isn't a multiple of the char size, there will be no padding space, so; // we don't have to worry about reading any padding data which didn't; // actually need to be accessed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:497,access,accessed,497,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['access'],['accessed']
Security,"// Special type for the hook to external function setting up authentication; // related stuff for old versions. For backward compatibility.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TSlave.h:61,authenticat,authentication,61,proof/proof/inc/TSlave.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TSlave.h,1,['authenticat'],['authentication']
Security,// Special warning if member name used in a property-dot for a setter accessor; // does not use a property with same name; e.g. obj.X = ... for a property with; // name 'x'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:70,access,accessor,70,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['access'],['accessor']
Security,"// Split predecessors of the loop exit to make instructions in the loop are; // exposed to exit blocks through trivially replaceable PHIs while keeping the; // loop in the canonical form where each predecessor of each exit block should; // be contained within the loop. For example, this will convert the loop below; // from; //; // LB1:; // %v1 =; // br %LE, %LB2; // LB2:; // %v2 =; // br %LE, %LB1; // LE:; // %p = phi [%v1, %LB1], [%v2, %LB2] <-- non-trivially replaceable; //; // to; //; // LB1:; // %v1 =; // br %LE.split, %LB2; // LB2:; // %v2 =; // br %LE.split2, %LB1; // LE.split:; // %p1 = phi [%v1, %LB1] <-- trivially replaceable; // br %LE; // LE.split2:; // %p2 = phi [%v2, %LB2] <-- trivially replaceable; // br %LE; // LE:; // %p = phi [%p1, %LE.split], [%p2, %LE.split2]; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:80,expose,exposed,80,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['expose'],['exposed']
Security,// Split the wide shuffle mask into halves. Any mask element that is accessing; // operand 1 is offset down to account for narrowing of the vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:69,access,accessing,69,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['access'],['accessing']
Security,"// Split training data into training and validation set",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDNN.cxx:41,validat,validation,41,tmva/tmva/src/MethodDNN.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDNN.cxx,2,['validat'],['validation']
Security,"// Splitting large data structures so that the GEPs accessing them can have; // smaller offsets so that they can be sunk to the same blocks as their users.; // For example, a large struct starting from %base is split into two parts; // where the second part starts from %new_base.; //; // Before:; // BB0:; // %base =; //; // BB1:; // %gep0 = gep %base, off0; // %gep1 = gep %base, off1; // %gep2 = gep %base, off2; //; // BB2:; // %load1 = load %gep0; // %load2 = load %gep1; // %load3 = load %gep2; //; // After:; // BB0:; // %base =; // %new_base = gep %base, off0; //; // BB1:; // %new_gep0 = %new_base; // %new_gep1 = gep %new_base, off1 - off0; // %new_gep2 = gep %new_base, off2 - off0; //; // BB2:; // %load1 = load i32, i32* %new_gep0; // %load2 = load i32, i32* %new_gep1; // %load3 = load i32, i32* %new_gep2; //; // %new_gep1 and %new_gep2 can be sunk to BB2 now after the splitting because; // their offsets are smaller enough to fit into the addressing mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:52,access,accessing,52,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['access'],['accessing']
Security,// SpvScalConst should be created before SpvVecConst to avoid undefined ID; // error on validation.; // TODO: can moved below once sorting of types/consts/defs is implemented.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp:88,validat,validation,88,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp,1,['validat'],['validation']
Security,// Stable hashes are based on the 64-bit FNV-1 hash:; // https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h:10,hash,hashes,10,interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h,2,['hash'],"['hash', 'hashes']"
Security,"// Stack access is very expensive. CSRs are also the high registers, and we; // want to minimize the number of used registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.h:9,access,access,9,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.h,1,['access'],['access']
Security,// Stack frame accessors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpState.h:15,access,accessors,15,interpreter/llvm-project/clang/lib/AST/Interp/InterpState.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/InterpState.h,1,['access'],['accessors']
Security,// Stack slot accesses may coalesce away.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:14,access,accesses,14,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['access'],['accesses']
Security,"// Standard Authentication lib",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSocket.cxx:12,Authenticat,Authentication,12,net/net/src/TSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSocket.cxx,1,['Authenticat'],['Authentication']
Security,// Start Source Inst operands validation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp:30,validat,validation,30,interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp,1,['validat'],['validation']
Security,"// Start the .debug$H section with the version and hash algorithm, currently; // hardcoded to version 0, SHA1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:51,hash,hash,51,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,1,['hash'],['hash']
Security,"// Start with a nearest dominating clobbering access, it will be either; // live on entry (nothing to do, load is not clobbered), MemoryDef, or; // MemoryPhi if several MemoryDefs can define this memory state. In that; // case add all Defs to WorkList and continue going up and checking all; // the definitions of this memory location until the root. When all the; // defs are exhausted and came to the entry state we have no clobber.; // Along the scan ignore barriers and fences which are considered clobbers; // by the MemorySSA, but not really writing anything into the memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUMemoryUtils.cpp:46,access,access,46,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUMemoryUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUMemoryUtils.cpp,1,['access'],['access']
Security,// Starting from kernel 4.9 memory allocated with mmap is counted against; // RLIMIT_DATA. Sanitizers need to allocate tens of terabytes for shadow.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp:91,Sanitiz,Sanitizers,91,interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/bugpoint.cpp,1,['Sanitiz'],['Sanitizers']
Security,"// State gets destroyed here, so the Stk.clear() below doesn't accidentally; // remove values the State's destructor might access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp:123,access,access,123,interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.cpp,1,['access'],['access']
Security,"// Static indexing does not lower to stack access, and hence there is no need; // for special custom lowering to avoid stack access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:43,access,access,43,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,2,['access'],['access']
Security,"// Stein's unbiased risk estimator; // access input parameters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfold.h:39,access,access,39,hist/unfold/inc/TUnfold.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfold.h,1,['access'],['access']
Security,"// Step 2: Sort the Xor-Operands in a way such that the operands containing; // the same symbolic value cluster together. For instance, the input operand; // sequence (""x | 123"", ""y & 456"", ""x & 789"") will be sorted into:; // (""x | 123"", ""x & 789"", ""y & 456"").; //; // The purpose is twofold:; // 1) Cluster together the operands sharing the same symbolic-value.; // 2) Operand having smaller symbolic-value-rank is permuted earlier, which; // could potentially shorten crital path, and expose more loop-invariants.; // Note that values' rank are basically defined in RPO order (FIXME).; // So, if Rank(X) < Rank(Y) < Rank(Z), it means X is defined earlier; // than Y which is defined earlier than Z. Permute ""x | 1"", ""Y & 2"",; // ""z"" in the order of X-Y-Z is better than any other orders.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:487,expose,expose,487,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['expose'],['expose']
Security,// Stop if this doesn't look like an accessor spec.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:37,access,accessor,37,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['access'],['accessor']
Security,"// Stop training if validation loss is not decreasing for several epochs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/inc/TMVA/MethodPyKeras.h:20,validat,validation,20,tmva/pymva/inc/TMVA/MethodPyKeras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/inc/TMVA/MethodPyKeras.h,1,['validat'],['validation']
Security,// Store MD5 in fixed length instead of ULEB128 so NameTable can be; // accessed like an array.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h:72,access,accessed,72,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,1,['access'],['accessed']
Security,// Store all the exported symbol names we found in the input libraries.; // We use a map to get hashed lookup speed; the bool is meaningless.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-tli-checker/llvm-tli-checker.cpp:96,hash,hashed,96,interpreter/llvm-project/llvm/tools/llvm-tli-checker/llvm-tli-checker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-tli-checker/llvm-tli-checker.cpp,1,['hash'],['hashed']
Security,// Store old entries & hashes arrays.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:23,hash,hashes,23,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,1,['hash'],['hashes']
Security,"// Store only weights with smallest validation loss",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/inc/TMVA/MethodPyKeras.h:36,validat,validation,36,tmva/pymva/inc/TMVA/MethodPyKeras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/inc/TMVA/MethodPyKeras.h,2,['validat'],['validation']
Security,"// Store password for later use",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:9,password,password,9,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['password'],['password']
Security,"// Strangely, non-type results are not ignored by this lookup, so the; // program is ill-formed if it finds an injected-class-name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:111,inject,injected-class-name,111,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['inject'],['injected-class-name']
Security,"// Stream names must be exact matches, since they get looked up in a hash; // table and the hash value is dependent on the exact contents of the string.; // link.exe lowercases a path and converts / to \, so we must do the same.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBFileBuilder.cpp:69,hash,hash,69,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBFileBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBFileBuilder.cpp,2,['hash'],['hash']
Security,"// StreamerElement injected by a TSchemaRule. Transient only to preserve forward compatibility.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TStreamerElement.h:19,inject,injected,19,core/meta/inc/TStreamerElement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TStreamerElement.h,1,['inject'],['injected']
Security,"// Strictly limit ourselves to plain loads and stores, not all instructions; // that can access the stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:89,access,access,89,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,2,['access'],['access']
Security,// Strided access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:11,access,access,11,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['access'],['access']
Security,// String Table and Checksums subsections don't use the allocator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/CodeViewYAMLDebugSections.cpp:20,Checksum,Checksums,20,interpreter/llvm-project/llvm/lib/ObjectYAML/CodeViewYAMLDebugSections.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/CodeViewYAMLDebugSections.cpp,1,['Checksum'],['Checksums']
Security,// Strip amdgpu-no-lds-kernel-id from all functions reachable from the; // kernel. We may have inferred this wasn't used prior to the pass.; //; // TODO: We could filter out subgraphs that do not access LDS globals.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:196,access,access,196,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['access'],['access']
Security,"// Strip class version from checksum calculation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTuple.cxx:28,checksum,checksum,28,tree/ntuple/v7/src/RNTuple.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTuple.cxx,1,['checksum'],['checksum']
Security,"// Strip off any operator->. This can only occur inside an actual arrow; // member access, so we treat it as equivalent to an actual object; // expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:83,access,access,83,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,2,['access'],['access']
Security,"// Strip off operator-> calls. They can only occur inside an actual arrow; // member access, so we treat them as equivalent to an actual object; // expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp:85,access,access,85,interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp,1,['access'],['access']
Security,// Strip off the size of access multiplication if we are still analyzing the; // pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:25,access,access,25,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['access'],['access']
Security,// Struct to keep track of one def/use pair for a GOT indirect access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:63,access,access,63,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,1,['access'],['access']
Security,// Subclasses may further refine the validation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:37,validat,validation,37,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,1,['validat'],['validation']
Security,// Subclasses should implement:; // static uint32_t hash(StringRef Name);,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:52,hash,hash,52,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,1,['hash'],['hash']
Security,// Submodule name is given by hashing the names of the globals.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp:30,hash,hashing,30,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp,1,['hash'],['hashing']
Security,// Subscripting matrix types behaves like member accesses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp:49,access,accesses,49,interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprClassification.cpp,1,['access'],['accesses']
Security,"// Subscripting the iterator allows direct access through indexing on arrays; // that do not have a defined length. This way, the return from accessing such; // an array as a data member can both be used in a loop and directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/TupleOfInstances.cxx:43,access,access,43,bindings/pyroot/cppyy/CPyCppyy/src/TupleOfInstances.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/TupleOfInstances.cxx,2,['access'],"['access', 'accessing']"
Security,// Suppress access diagnostics; the access check is instead performed at the; // point of use for an inheriting constructor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:12,access,access,12,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,2,['access'],['access']
Security,"// Suppress the protected check (C++ [class.protected]) for each of the; // assignment operators we found. This strange dance is required when; // we're assigning via a base classes's copy-assignment operator. To; // ensure that we're getting the right base class subobject (without; // ambiguities), we need to cast ""this"" to that subobject type; to; // ensure that we don't go through the virtual call mechanism, we need; // to qualify the operator= name with the base class (see below). However,; // this means that if the base class has a protected copy assignment; // operator, the protected member access check will fail. So, we; // rewrite ""protected"" access to ""public"" access in this case, since we; // know by construction that we're calling from a derived class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:604,access,access,604,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,3,['access'],['access']
Security,"// Swift calling convention does not require we copy the sret argument; // into %d0 for the return, and SRetReturnReg is not set for Swift.; // ABI require that for returning structs by value we copy the sret argument; // into %D0 for the return. Save the argument into a virtual register so that; // we can access it from the return points.; //; // Checking Function.hasStructRetAttr() here is insufficient because the IR; // may not have an explicit sret argument. If MFI.CanLowerReturn is; // false, then an sret argument may be implicitly inserted in the SelDAG. In; // either case MFI->setSRetReturnReg() will have been called.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:308,access,access,308,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,1,['access'],['access']
Security,// Symbol hash table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:10,hash,hash,10,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['hash'],['hash']
Security,"// Symbol table index and type of relocation to apply.; // These accessors and mutators correspond to the ELF64_R_SYM, ELF64_R_TYPE,; // and ELF64_R_INFO macros defined in the ELF specification:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:65,access,accessors,65,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['access'],['accessors']
Security,"// Symbol table index and type of relocation to apply; // These accessors and mutators correspond to the ELF32_R_SYM, ELF32_R_TYPE,; // and ELF32_R_INFO macros defined in the ELF specification:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:64,access,accessors,64,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['access'],['accessors']
Security,// SymbolRef accessors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h:13,access,accessors,13,interpreter/llvm-project/llvm/include/llvm-c/Object.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm-c/Object.h,2,['access'],['accessors']
Security,// Synthesize an explicit cast to gain access to the ivar.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:39,access,access,39,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,2,['access'],['access']
Security,// Synthesize an explicit cast to gain access to the ivar.; // See objc-act.c:objc_synthesize_new_getter() for details.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:39,access,access,39,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,2,['access'],['access']
Security,// Synthesize offset of the whole access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:34,access,access,34,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['access'],['access']
Security,"// System V Rel 4 style shadow passwords",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:31,password,passwords,31,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,2,['password'],['passwords']
Security,// TBAAAccessInfo - Describes a memory access in terms of TBAA.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.h:39,access,access,39,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.h,1,['access'],['access']
Security,// TBAAAccessKind - A kind of TBAA memory access descriptor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.h:42,access,access,42,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.h,1,['access'],['access']
Security,"// TDavixFile options; /// Enable or disable certificate authority check",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/davix/inc/TDavixFile.h:45,certificate,certificate,45,net/davix/inc/TDavixFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/davix/inc/TDavixFile.h,1,['certificate'],['certificate']
Security,"// TEMP(version4): In version 4 checksum is embedded in the on disk representation,; // so we need to strip that as well from the byte count.; // Support for version 4 will be dropped before the class moves out of experimental.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTuple.cxx:32,checksum,checksum,32,tree/ntuple/v7/src/RNTuple.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTuple.cxx,1,['checksum'],['checksum']
Security,"// TEventLists are named objects in a THashList.; // We must update the hashlist if we change the name",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEventList.cxx:72,hash,hashlist,72,tree/tree/src/TEventList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEventList.cxx,1,['hash'],['hashlist']
Security,"// TFormLeafInfoMultiVarDimClones is a small helper class to implement reading; // a data member which is a TClonesArray inside a TClonesArray or collection object; // stored in a TTree. This is the version used for split access; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfo.h:222,access,access,222,tree/treeplayer/inc/TFormLeafInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfo.h,1,['access'],['access']
Security,"// TFormLeafInfoMultiVarDimCollection is a small helper class to implement reading; // a data member which is a collection inside a TClonesArray or collection object; // stored in a TTree. This is the version used for split access; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfo.h:224,access,access,224,tree/treeplayer/inc/TFormLeafInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfo.h,1,['access'],['access']
Security,"// TFormLeafInfoMultiVarDimDirect is a small helper class to implement reading; // a data member on a variable size array inside a TClonesArray object stored; // in a TTree. This is the version used for split access",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfo.h:209,access,access,209,tree/treeplayer/inc/TFormLeafInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfo.h,1,['access'],['access']
Security,// TODO Track the selector locations in a way that is accessible here to; // improve the diagnostic location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:54,access,accessible,54,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['access'],['accessible']
Security,// TODO Track the selector locations in a way that is accessible here; // to improve the diagnostic location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:54,access,accessible,54,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,2,['access'],['accessible']
Security,// TODO(boomanaiden154): Add in support for using validation counters when; // using LBR counters.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:50,validat,validation,50,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,1,['validat'],['validation']
Security,"// TODO(jblomer): quick and dirty hash, likely very sub-optimal, to be revised later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx:34,hash,hash,34,tree/ntuple/v7/inc/ROOT/RCluster.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx,1,['hash'],['hash']
Security,"// TODO(xur): Remove this once we switch to ImprovedFSDiscriminator.; // Compute a hash value using debug line number, and the line numbers from the; // inline stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp:83,hash,hash,83,interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRFSDiscriminator.cpp,1,['hash'],['hash']
Security,// TODO: Add more rigorous validation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:27,validat,validation,27,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,1,['validat'],['validation']
Security,"// TODO: Add parameter validation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDERS.cxx:23,validat,validation,23,tmva/tmva/src/MethodPDERS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDERS.cxx,1,['validat'],['validation']
Security,// TODO: Add support for reversed masked interleaved access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:53,access,access,53,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['access'],['access']
Security,"// TODO: Build `SimpleTemplateNameSpecifier` children and implement; // accessors to them.; // Be aware, we cannot do that simply by calling `TraverseTypeLoc`,; // some `TypeLoc`s have inside them the previous name specifier and; // we want to treat them independently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:72,access,accessors,72,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,1,['access'],['accessors']
Security,// TODO: Check if 32-byte or greater accesses are slow too?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:37,access,accesses,37,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['access'],['accesses']
Security,"// TODO: Complete for other data-types and strides.; // Each combination of Stride, element bit width and VF results in a different; // sequence; The cost tables are therefore accessed with:; // Factor (stride) and VectorType=VFxiN.; // The Cost accounts only for the shuffle sequence;; // The cost of the loads/stores is accounted for separately.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:176,access,accessed,176,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['access'],['accessed']
Security,"// TODO: ContentMap_t should allow lookup by string_view while still providing; // storage of names.; /// The directory content is a hashed map of name => `Internal::RDirectoryEntry`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/v7/inc/ROOT/RDirectory.hxx:133,hash,hashed,133,core/base/v7/inc/ROOT/RDirectory.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/v7/inc/ROOT/RDirectory.hxx,1,['hash'],['hashed']
Security,"// TODO: Could inject an invalid typedef decl in an enclosing scope to; // avoid rippling error messages on subsequent uses of the same type,; // could be useful if #include was forgotten.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:15,inject,inject,15,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['inject'],['inject']
Security,"// TODO: Document how data pointer is determined using STL iterator interface.; // TODO: Sanitize given container type with type traits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RTensor.hxx:89,Sanitiz,Sanitize,89,tmva/tmva/inc/TMVA/RTensor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RTensor.hxx,1,['Sanitiz'],['Sanitize']
Security,"// TODO: For now we do not treat byval arguments as local copies performed; // on the call edge, though, we should. To make that happen we need to; // teach various passes, e.g., DSE, about the copy effect of a byval. That; // would also allow us to mark functions only accessing byval arguments as; // readnone again, arguably their accesses have no effect outside of the; // function, like accesses to allocas.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:270,access,accessing,270,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,3,['access'],"['accesses', 'accessing']"
Security,// TODO: Generate TBAA information that describes this access as a structure; // member access and not just an access to an object of the field's type. This; // should be similar to what we do in EmitLValueForField().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:55,access,access,55,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,3,['access'],['access']
Security,// TODO: Handle aggregates and vectors; // TODO: Support multiple indices.; // TODO: Try to avoid meaningless accesses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp:110,access,accesses,110,interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp,1,['access'],['accesses']
Security,// TODO: Handle more than just ICmps here. We should be able to move; // most instructions without side effects or memory access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:122,access,access,122,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['access'],['access']
Security,// TODO: Handle overlapping accesses.; // We should be computing AccessSize as (TC - 1) * Step + EltSize.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:28,access,accesses,28,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,2,"['Access', 'access']","['AccessSize', 'accesses']"
Security,// TODO: Hash lots more stuff like function alignment and stack objects.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp:9,Hash,Hash,9,interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp,1,['Hash'],['Hash']
Security,// TODO: Hash more stuff like block alignment and branch probabilities.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp:9,Hash,Hash,9,interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp,1,['Hash'],['Hash']
Security,"// TODO: If the loop has existing parallel access metadata, have; // to combine two lists.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:43,access,access,43,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['access'],['access']
Security,"// TODO: Implement accessor to `DecltypeNameSpecifier` inner; // `DecltypeTypeLoc`.; // For that add mapping from `TypeLoc` to `syntax::Node*` then:; // Builder.markChild(TypeLoc, syntax::NodeRole);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:19,access,accessor,19,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,1,['access'],['accessor']
Security,"// TODO: Implement the rest of the logic here. For example, two accesses; // with same final access types result in an access to an object of that final; // access type regardless of their base types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp:64,access,accesses,64,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp,8,['access'],"['access', 'accesses']"
Security,"// TODO: In fact, cost of unswitching a new invariant candidate is *slightly*; // higher because we have just inserted a new block. Need to think how to; // adjust the cost of injected candidates when it was first computed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:176,inject,injected,176,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['inject'],['injected']
Security,// TODO: Instead of checking here for invalid die we might reject; // invalid dies at parsing stage(DWARFUnit::extractDIEsToVector).; // We do not want access out of bounds when parsing corrupted debug data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnit.cpp:152,access,access,152,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnit.cpp,1,['access'],['access']
Security,"// TODO: It may be okay to round to align, but that would imply that; // accessing slightly out of bounds was legal, and we're currently; // inconsistent about that. For the moment, be conservative.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:73,access,accessing,73,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,1,['access'],['accessing']
Security,// TODO: Probably okay to remove after audit; here to reduce change size; // in initial enablement patch for scalable vectors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:39,audit,audit,39,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,3,['audit'],['audit']
Security,"// TODO: Re-enable check_initialization_order=1, currently finds a false; // positive in llvm::DataLayout::reset accessing DefaultAlignments while; // loading the Net library.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/SanitizerSetup.cxx:113,access,accessing,113,core/sanitizer/SanitizerSetup.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/SanitizerSetup.cxx,1,['access'],['accessing']
Security,// TODO: Refine based on subtargets which support unaligned access or 128-bit; // LDS; // TODO: Unsupported flat for SI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:60,access,access,60,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['access'],['access']
Security,// TODO: Should check if the address can definitely not access stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:56,access,access,56,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['access'],['access']
Security,// TODO: Should refine based on estimated number of accesses (e.g. does it; // require splitting based on alignment),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp:52,access,accesses,52,interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp,1,['access'],['accesses']
Security,"// TODO: Should we check the address space from the MachineMemOperand? That; // would allow us to distinguish objects we know don't alias based on the; // underlying address space, even if it was lowered to a different one,; // e.g. private accesses lowered to use MUBUF instructions on a scratch; // buffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:241,access,accesses,241,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['access'],['accesses']
Security,// TODO: Should we emit bounds checks with SanitizerKind::ArrayBounds?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:43,Sanitiz,SanitizerKind,43,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['Sanitiz'],['SanitizerKind']
Security,"// TODO: Split these into own h/cxx files - too long now!; //////////////////////////////////////////////////////////////////////////; // //; // TGLVertex3 //; // //; // 3 component (x/y/z) vertex class //; // //; // This is part of collection of utility classes for GL in TGLUtil.h/cxx//; // These provide const and non-const accessors Arr() / CArr() to a GL //; // compatible internal field - so can be used directly with OpenGL C API//; // calls. They are not intended to be fully featured just provide //; // minimum required. //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h:327,access,accessors,327,graf3d/gl/inc/TGLUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h,1,['access'],['accessors']
Security,"// TODO: Support accesses to members of base classes in TBAA. For now, we; // conservatively pretend that the complete object is of the base class; // type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:17,access,accesses,17,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,2,['access'],['accesses']
Security,// TODO: Take access ranges into account when matching access tags and; // fix this code to generate actual access sizes for generic tags.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:14,access,access,14,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,3,['access'],['access']
Security,"// TODO: The checksum followed by the decompression means we iterate through the buffer twice.; // We should perform some performance tests to see whether we can interleave the two -- i.e., at; // what size of chunks does interleaving (avoiding two fetches from RAM) improve enough for the; // extra function call costs? NOTE that ROOT limits the buffer size to 16MB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/lz4/src/ZipLZ4.cxx:13,checksum,checksum,13,core/lz4/src/ZipLZ4.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/lz4/src/ZipLZ4.cxx,1,['checksum'],['checksum']
Security,// TODO: This can probably be removed once target code is audited. This; // is here purely to reduce patch size and review complexity.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:58,audit,audited,58,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['audit'],['audited']
Security,// TODO: This instruction may already have access group from; // other pragmas e.g. #pragma clang loop vectorize. Append; // so that the existing metadata is not overwritten.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:43,access,access,43,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['access'],['access']
Security,// TODO: This misses out on the sanitizer check below.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:32,sanitiz,sanitizer,32,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,2,['sanitiz'],['sanitizer']
Security,// TODO: Try to avoid undefined accesses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp:32,access,accesses,32,interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp,2,['access'],['accesses']
Security,// TODO: VP_TRUNCATE need to handle when TypeWidenVector access to some; // targets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:57,access,access,57,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['access'],['access']
Security,// TODO: Validate types make sense,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibFunc.cpp:9,Validat,Validate,9,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibFunc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibFunc.cpp,1,['Validat'],['Validate']
Security,"// TODO: We can do better for PHI nodes. In cases like this:; // ptr = phi(relocated_pointer, not_relocated_pointer); // statepoint(ptr); // We will return that stack slot for ptr is unknown. And later we might; // assign different stack slots for ptr and relocated_pointer. This limits; // llvm's ability to remove redundant stores.; // Unfortunately it's hard to accomplish in current infrastructure.; // We use this function to eliminate spill store completely, while; // in example we still need to emit store, but instead of any location; // we need to use special ""preferred"" location.; // TODO: handle simple updates. If a value is modified and the original; // value is no longer live, it would be nice to put the modified value in the; // same slot. This allows folding of the memory accesses for some; // instructions types (like an increment).; // statepoint (i); // i1 = i+1; // statepoint (i1); // However we need to be careful for cases like this:; // statepoint(i); // i1 = i+1; // statepoint(i, i1); // Here we want to reserve spill slot for 'i', but not for 'i+1'. If we just; // put handling of simple modifications in this function like it's done; // for bitcasts we might end up reserving i's slot for 'i+1' because order in; // which we visit values is unspecified.; // Don't know any information about this instruction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp:793,access,accesses,793,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,1,['access'],['accesses']
Security,// TODO: We can use vscale_range to convert a scalable value to an; // upper bound on the access size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:90,access,access,90,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['access'],['access']
Security,"// TODO: We could potentially validate these, but for now just leave indices; // alone.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/RandomIRBuilder.cpp:30,validat,validate,30,interpreter/llvm-project/llvm/lib/FuzzMutate/RandomIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/RandomIRBuilder.cpp,1,['validat'],['validate']
Security,// TODO: We could refine this to captured pointers that could possibly be; // accessed by flat instructions. For now this is mostly a poor way of; // estimating whether there are calls before argument lowering.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAnnotateKernelFeatures.cpp:78,access,accessed,78,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAnnotateKernelFeatures.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAnnotateKernelFeatures.cpp,1,['access'],['accessed']
Security,"// TODO: We currently implement an algorithm whose time complexity is linear in; // the number of existing candidates. However, we could do better by using; // ScopedHashTable. Specifically, while traversing the dominator tree, we could; // maintain all the candidates that dominate the basic block being traversed in; // a ScopedHashTable. This hash table is indexed by the base and the stride of; // a candidate. Therefore, finding the immediate basis of a candidate boils down; // to one hash-table look up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:346,hash,hash,346,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,2,['hash'],"['hash', 'hash-table']"
Security,// TODO: We currently require that all accesses at a given offset must; // use the same type. This could be relaxed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:39,access,accesses,39,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['access'],['accesses']
Security,"// TODO: We don't do phi translation on memory accesses because it's; // complicated. For a load, we'd need to be able to simulate a new memoryuse,; // which we don't have a good way of doing ATM.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:47,access,accesses,47,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['access'],['accesses']
Security,// TODO: We should be able to look up the alternative name for; // the register if it's given.; // TableGen doesn't expose a way of getting retrieving names; // for registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp:116,expose,expose,116,interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRAsmPrinter.cpp,1,['expose'],['expose']
Security,"// TODO: We should be able to widen loads if the alignment is high enough, but; // we also need to modify the memory access size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:117,access,access,117,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['access'],['access']
Security,// TODO: What about AVX-512 (512-bit) accesses?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:38,access,accesses,38,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['access'],['accesses']
Security,// TODO: add accessors for specifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h:13,access,accessors,13,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,1,['access'],['accessors']
Security,"// TODO: add an accessor for the ""static"" keyword.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h:16,access,accessor,16,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,1,['access'],['accessor']
Security,"// TODO: allow memory access dominated by move point? Note that since AI; // could have a reference to itself captured by the call, we would need to; // account for cycles in doing so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:22,access,access,22,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['access'],['access']
Security,// TODO: describe return value as depending on one or more of its arguments.; // StackSafetyDataFlowAnalysis counter stored here for faster access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:140,access,access,140,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,1,['access'],['access']
Security,// TODO: extend the masked interleaved-group support to reversed access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:65,access,access,65,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['access'],['access']
Security,"// TODO: hashing in the ref-count is for moves; resolve this together with the; // improved overloads for implicit conversions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.h:9,hash,hashing,9,bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.h,1,['hash'],['hashing']
Security,"// TODO: move ParsingClassDefinition here.; // TODO: move TentativeParsingAction here.; /// A RAII object used to temporarily suppress access-like; /// checking. Access-like checks are those associated with; /// controlling the use of a declaration, like C++ access control; /// errors and deprecation warnings. They are contextually; /// dependent, in that they can only be resolved with full; /// information about what's being declared. They are also; /// suppressed in certain contexts, like the template arguments of; /// an explicit instantiation. However, those suppression contexts; /// cannot necessarily be fully determined in advance; for; /// example, something starting like this:; /// template <> class std::vector<A::PrivateType>; /// might be the entirety of an explicit instantiation:; /// template <> class std::vector<A::PrivateType>;; /// or just an elaborated type specifier:; /// template <> class std::vector<A::PrivateType> make_vector<>();; /// Therefore this class collects all the diagnostics and permits; /// them to be re-delayed in a new context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/RAIIObjectsForParser.h:135,access,access-like,135,interpreter/llvm-project/clang/include/clang/Parse/RAIIObjectsForParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/RAIIObjectsForParser.h,3,"['Access', 'access']","['Access-like', 'access', 'access-like']"
Security,"// TODO: need to access the genfit of the data and add that to the point, somehow ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooHypoSpace.cxx:17,access,access,17,roofit/xroofit/src/xRooHypoSpace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooHypoSpace.cxx,1,['access'],['access']
Security,// TODO: recognize the TBAA used for constant accesses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:46,access,accesses,46,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['access'],['accesses']
Security,// TODO: support reversed access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:26,access,access,26,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['access'],['access']
Security,"// TODO: the following attempts are all brittle and leak transactions, but; // each properly exposes the symbol so subsequent lookups will succeed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:93,expose,exposes,93,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,1,['expose'],['exposes']
Security,// TODO: use a fast content hash when available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp:28,hash,hash,28,interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenAction.cpp,1,['hash'],['hash']
Security,// TODO: validate array data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h:9,validat,validate,9,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h,1,['validat'],['validate']
Security,// TODO: we should also validate against InvariantMemSets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:24,validat,validate,24,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['validat'],['validate']
Security,"// TODO: white-list trivial vbase initializers. This case wouldn't; // be subject to the restrictions below.; // TODO: white-list cases where:; // - there are no non-reference parameters to the constructor; // - the initializers don't access any non-reference parameters; // - the initializers don't take the address of non-reference; // parameters; // - etc.; // If we ever add any of the above cases, remember that:; // - function-try-blocks will always exclude this optimization; // - we need to perform the constructor prologue and cleanup in; // EmitConstructorBody.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:235,access,access,235,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,1,['access'],['access']
Security,"// TVirtualRefProxy overload: Access referenced object(-data)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TRefArrayProxy.h:30,Access,Access,30,tree/treeplayer/inc/TRefArrayProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TRefArrayProxy.h,1,['Access'],['Access']
Security,"// TVirtualRefProxy overload: Access to container size (if container reference (ie TRefArray) etc)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TRefArrayProxy.h:30,Access,Access,30,tree/treeplayer/inc/TRefArrayProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TRefArrayProxy.h,1,['Access'],['Access']
Security,// Tail merge tend to expose more if-conversion opportunities.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:22,expose,expose,22,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,1,['expose'],['expose']
Security,// Take out the Vptr sanitizer from the enabled sanitizers,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:21,sanitiz,sanitizer,21,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,2,['sanitiz'],"['sanitizer', 'sanitizers']"
Security,"// Take two input vectors (in xAxis, and zAxis) and turn them into an; // orthogonal basis. This is an internal helper function used to implement; // the Set?Axis functions, but is exposed because the functionality is; // often useful.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/inc/TRotation.h:181,expose,exposed,181,math/physics/inc/TRotation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/inc/TRotation.h,1,['expose'],['exposed']
Security,"// Target class checksum",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TSchemaRuleSet.h:16,checksum,checksum,16,core/meta/inc/TSchemaRuleSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TSchemaRuleSet.h,1,['checksum'],['checksum']
Security,// Target is accessible at EC when named in its declaring class.; // We can now hill-climb and simply check whether the declaring; // class is accessible as a base of the naming class. This is; // equivalent to checking the access of a notional public; // member with no instance context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:13,access,accessible,13,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,3,['access'],"['access', 'accessible']"
Security,"// Targets can define their own custom Views that exist within their; // /lib/Target/ directory so that the View can utilize their CustomBehaviour; // or other backend symbols / functionality that are not already exposed; // through one of the MC-layer classes. These Views will be initialized; // using the CustomBehaviour::getViews() variants.; // If a target makes a custom View that does not depend on their target; // CB or their backend, they should put the View within; // /tools/llvm-mca/Views/ instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:213,expose,exposed,213,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,1,['expose'],['exposed']
Security,"// Targets must either support 64-bit offsets for MUBUF instructions, and/or; // support flat operations, otherwise they cannot access a 64-bit global; // address space",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp:128,access,access,128,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,1,['access'],['access']
Security,"// Technically, due to ELF symbol interposition semantics, we can't change the; // alignment or size of symbols. If we increase the alignment or size of a; // symbol, the compiler may make optimisations based on this new alignment or; // size. If the symbol is interposed, this optimisation could lead to; // alignment-related or OOB read/write crashes.; //; // This is handled in the linker. When the linker sees multiple declarations of; // a global variable, and some are tagged, and some are untagged, it resolves it; // to be an untagged definition - but preserves the tag-granule-rounded size and; // tag-granule-alignment. This should prevent these kind of crashes intra-DSO.; // For cross-DSO, it's been a reasonable contract that if you're interposing a; // sanitizer-instrumented global, then the interposer also needs to be; // sanitizer-instrumented.; //; // FIXME: In theory, this can be fixed by splitting the size/alignment of; // globals into two uses: an ""output alignment"" that's emitted to the ELF file,; // and an ""optimisation alignment"" that's used for optimisation. Thus, we could; // adjust the output alignment only, and still optimise based on the pessimistic; // pre-tagging size/alignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64GlobalsTagging.cpp:767,sanitiz,sanitizer-instrumented,767,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64GlobalsTagging.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64GlobalsTagging.cpp,2,['sanitiz'],['sanitizer-instrumented']
Security,"// Tell TPSocket that we want authentication, which has to; // be done using the original socket before creation of set; // of parallel sockets",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSocket.cxx:30,authenticat,authentication,30,net/net/src/TSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSocket.cxx,1,['authenticat'],['authentication']
Security,"// Template of General Matrix Column Access class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/inc/TMatrixTUtils.h:37,Access,Access,37,math/matrix/inc/TMatrixTUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/inc/TMatrixTUtils.h,2,['Access'],['Access']
Security,"// Template of General Matrix Diagonal Access class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/inc/TMatrixTUtils.h:39,Access,Access,39,math/matrix/inc/TMatrixTUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/inc/TMatrixTUtils.h,2,['Access'],['Access']
Security,"// Template of General Matrix Row Access class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/inc/TMatrixTUtils.h:34,Access,Access,34,math/matrix/inc/TMatrixTUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/inc/TMatrixTUtils.h,2,['Access'],['Access']
Security,"// Template of Sparse Matrix Diagonal Access class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/inc/TMatrixTUtils.h:38,Access,Access,38,math/matrix/inc/TMatrixTUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/inc/TMatrixTUtils.h,2,['Access'],['Access']
Security,"// Template of Sparse Matrix Row Access class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/inc/TMatrixTUtils.h:33,Access,Access,33,math/matrix/inc/TMatrixTUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/inc/TMatrixTUtils.h,2,['Access'],['Access']
Security,"// Template of Sub Matrix Access class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/inc/TMatrixTUtils.h:26,Access,Access,26,math/matrix/inc/TMatrixTUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/inc/TMatrixTUtils.h,2,['Access'],['Access']
Security,"// Temporary registers for comparing the hashes. If a register is used; // for the call target, or reserved by the user, we can clobber another; // temporary register as the check is immediately followed by the; // call. The check defaults to X6/X7, but can fall back to X28-X31 if; // needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp:41,hash,hashes,41,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVAsmPrinter.cpp,1,['hash'],['hashes']
Security,// Terminate the previous entry if there is no hash collision with the; // current one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:47,hash,hash,47,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,1,['hash'],['hash']
Security,// Terminator may be a memory accessing instruction too.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:30,access,accessing,30,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,1,['access'],['accessing']
Security,// Test if MappingContextTraits<T>::validate() is defined on type T.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h:36,validat,validate,36,interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,1,['validat'],['validate']
Security,// Test if MappingTraits<T>::validate() is defined on type T.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h:29,validat,validate,29,interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,1,['validat'],['validate']
Security,"// Test scalar arguments for conversion. B has been validated earlier to be a; // negative power of two and thus is guaranteed to have one or more contiguous; // ones starting from the MSB followed by zero or more contiguous zeros. D has; // been validated earlier to be a shifted set of one or more contiguous ones.; // In order to match, B leading ones and D leading zeros should be equal. The; // predicate that B be a negative power of 2 prevents the condition of there; // ever being zero leading ones. Thus 0 == 0 cannot occur. The predicate that; // D always be a shifted mask prevents the condition of D equaling 0. This; // prevents matching the condition where B contains the maximum number of; // leading one bits (-1) and D contains the maximum number of leading zero; // bits (0).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:52,validat,validated,52,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,2,['validat'],['validated']
Security,// That includes picking up the appropriate access specifier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:44,access,access,44,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['access'],['access']
Security,"// The ""name"" of a non-leaf complex pattern (MY_PAT $op1, $op2) is; // ""MY_PAT:op1:op2"". We should already have validated that the uses are; // consistent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp:112,validat,validated,112,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,1,['validat'],['validated']
Security,"// The 'ListForObject' is actually a hash table bucket that can also; // contain other element/name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TViewPubDataMembers.cxx:37,hash,hash,37,core/meta/src/TViewPubDataMembers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TViewPubDataMembers.cxx,1,['hash'],['hash']
Security,"// The 'prettyPrintRegisterOp' function uses the DWARFUnit to support; // DW_OP_regval_type. At this point we are operating on a logical view; // item, with no access to the underlying DWARF data used by LLVM.; // We do not support DW_OP_regval_type here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVELFReader.cpp:160,access,access,160,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVELFReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVELFReader.cpp,1,['access'],['access']
Security,"// The -dfsan-preserve-alignment flag controls whether this pass assumes that; // alignment requirements provided by the input IR are correct. For example,; // if the input IR contains a load with alignment 8, this flag will cause; // the shadow load to have alignment 16. This flag is disabled by default as; // we have unfortunately encountered too much code (including Clang itself;; // see PR14291) which performs misaligned access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:429,access,access,429,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,1,['access'],['access']
Security,"// The 1.10 in the above line is a security feature to prevent crashes close to the limit at 1.00",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNonCPEigenDecay.cxx:35,secur,security,35,roofit/roofit/src/RooNonCPEigenDecay.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNonCPEigenDecay.cxx,1,['secur'],['security']
Security,// The 128-bit system register accesses do not touch PSTATE.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:31,access,accesses,31,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['access'],['accesses']
Security,"// The A2 is in-order with a deep pipeline, and concatenation unrolling; // helps expose latency-hiding opportunities to the instruction scheduler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp:82,expose,expose,82,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetTransformInfo.cpp,1,['expose'],['expose']
Security,"// The AMDGPUOpenMPToolChain only supports sanitizers in the sense that it; // allows sanitizer arguments on the command line if they are supported by the; // host toolchain. The AMDGPUOpenMPToolChain will actually ignore any command; // line arguments for any of these ""supported"" sanitizers. That means that no; // sanitization of device code is actually supported at this time.; //; // This behavior is necessary because the host and device toolchains; // invocations often share the command line, so the device toolchain must; // tolerate flags meant only for the host toolchain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPUOpenMP.cpp:43,sanitiz,sanitizers,43,interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPUOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPUOpenMP.cpp,4,['sanitiz'],"['sanitization', 'sanitizer', 'sanitizers']"
Security,"// The AUTIASP instruction assembles to a hint instruction before v8.3a so; // this instruction can safely used for any v8a architecture.; // From v8.3a onwards there are optimised authenticate LR and return; // instructions, namely RETA{A,B}, that can be used instead. In this case the; // DW_CFA_AARCH64_negate_ra_state can't be emitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.cpp:181,authenticat,authenticate,181,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.cpp,1,['authenticat'],['authenticate']
Security,// The AVR subtarget should support ELPM to access section; // '.progmem[1|2|3|4|5].data'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetObjectFile.cpp:44,access,access,44,interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetObjectFile.cpp,1,['access'],['access']
Security,// The AVR subtarget should support LPM to access section '.progmem*.data'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetObjectFile.cpp:43,access,access,43,interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetObjectFile.cpp,1,['access'],['access']
Security,"// The AccessModifierOffset may be overridden by IndentAccessModifiers,; // in which case we take a negative value of the IndentWidth to simulate; // the upper indent level.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:7,Access,AccessModifierOffset,7,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,1,['Access'],['AccessModifierOffset']
Security,"// The AccessSets are allocated via a BumpPtrAllocator, we call; // the destructor manually.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:7,Access,AccessSets,7,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['Access'],['AccessSets']
Security,// The AnalyzeCallOperands in the base class is not usable since we must; // provide a means of accessing ArgListEntry::IsFixed. Delete them from this; // class. This doesn't stop them being used via the base class though.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.h:96,access,accessing,96,interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsCCState.h,1,['access'],['accessing']
Security,"// The BitcodeWriter writes null bytes into Record[3:4] when the Checksum; // is not present. This matches up with the old internal representation,; // and the old encoding for CSK_None in the ChecksumKind. The new; // representation reserves the value 0 in the ChecksumKind to continue to; // encode None in a backwards-compatible way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:65,Checksum,Checksum,65,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,3,['Checksum'],"['Checksum', 'ChecksumKind']"
Security,"// The CodeSignature section begins with a header, after which the hashes; // of each page of the binary are written.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOWriter.cpp:67,hash,hashes,67,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOWriter.cpp,1,['hash'],['hashes']
Security,"// The CudaToolChain only supports sanitizers in the sense that it allows; // sanitizer arguments on the command line if they are supported by the host; // toolchain. The CudaToolChain will actually ignore any command line; // arguments for any of these ""supported"" sanitizers. That means that no; // sanitization of device code is actually supported at this time.; //; // This behavior is necessary because the host and device toolchains; // invocations often share the command line, so the device toolchain must; // tolerate flags meant only for the host toolchain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:35,sanitiz,sanitizers,35,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,4,['sanitiz'],"['sanitization', 'sanitizer', 'sanitizers']"
Security,"// The ELFObjectWriter can determine the absolute size as it has access to; // the layout information of the assembly file, so a size expression rather; // than an absolute value is ok here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp:65,access,access,65,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,1,['access'],['access']
Security,"// The Evaluator can look through pointer casts as long as alias; // analysis holds because it's just a simple interpreter and doesn't; // skip memory accesses due to invariant group metadata, but we can't; // let users of Evaluator use a value that's been gleaned looking; // through stripping pointer casts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:151,access,accesses,151,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,1,['access'],['accesses']
Security,"// The Gaps mask is invariant and created outside the loop, therefore the; // cost of creating it is not accounted for here. However if we have both; // a MaskForGaps and some other mask that guards the execution of the; // memory access, we need to account for the cost of And-ing the two masks; // inside the loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:231,access,access,231,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,2,['access'],['access']
Security,"// The GenerateInitInstance for STL are not unique and should not be externally accessible",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:80,access,accessible,80,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['access'],['accessible']
Security,"// The HIPAMDToolChain only supports sanitizers in the sense that it allows; // sanitizer arguments on the command line if they are supported by the host; // toolchain. The HIPAMDToolChain will actually ignore any command line; // arguments for any of these ""supported"" sanitizers. That means that no; // sanitization of device code is actually supported at this time.; //; // This behavior is necessary because the host and device toolchains; // invocations often share the command line, so the device toolchain must; // tolerate flags meant only for the host toolchain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp:37,sanitiz,sanitizers,37,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPAMD.cpp,4,['sanitiz'],"['sanitization', 'sanitizer', 'sanitizers']"
Security,"// The HIPSPVToolChain only supports sanitizers in the sense that it allows; // sanitizer arguments on the command line if they are supported by the host; // toolchain. The HIPSPVToolChain will actually ignore any command line; // arguments for any of these ""supported"" sanitizers. That means that no; // sanitization of device code is actually supported at this time.; //; // This behavior is necessary because the host and device toolchains; // invocations often share the command line, so the device toolchain must; // tolerate flags meant only for the host toolchain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp:37,sanitiz,sanitizers,37,interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/HIPSPV.cpp,4,['sanitiz'],"['sanitization', 'sanitizer', 'sanitizers']"
Security,// The Hash Imm form is used for instructions that check or store a hash.; // These instructions have a small immediate range that spans between; // -8 and -512.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:7,Hash,Hash,7,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,2,"['Hash', 'hash']","['Hash', 'hash']"
Security,// The Hash's IncludesSource flag gets set whenever the hashed shader includes; // debug information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXContainerGlobals.cpp:7,Hash,Hash,7,interpreter/llvm-project/llvm/lib/Target/DirectX/DXContainerGlobals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXContainerGlobals.cpp,2,"['Hash', 'hash']","['Hash', 'hashed']"
Security,// The InjectedClassNameType is created in VisitRecordDecl when the; // T->getDecl() is imported. Here we can return the existing type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:7,Inject,InjectedClassNameType,7,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['Inject'],['InjectedClassNameType']
Security,// The Lanai ABI for returning structs by value requires that we copy; // the sret argument into rv for the return. Save the argument into; // a virtual register so that we can access it from the return points.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:177,access,access,177,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,1,['access'],['access']
Security,"// The LiveIn map at this point has all defs that are live-on-exit from B,; // as if they were live-on-entry to B. First, we need to filter out all; // defs that are present in this block. Then we will add reaching defs of; // all upward-exposed uses.; // To filter out the defs, first make a copy of LiveIn, and then re-populate; // LiveIn with the defs that should remain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:238,expose,exposed,238,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,1,['expose'],['exposed']
Security,"// The Load() function reads multiple values from the pointed-to; // memory into xx. This is why we have to copy the input values from; // the x array into a zero-padded buffer to read from. Otherwise,; // Load() would access the x array out of bounds.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitUtil.h:219,access,access,219,math/mathcore/inc/Fit/FitUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitUtil.h,1,['access'],['access']
Security,// The Microsoft extension __interface does not permit non-public; // access specifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:70,access,access,70,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['access'],['access']
Security,"// The ModuleManager's use of FileEntry nodes as the keys for its map of; // loaded modules is less than ideal. Uniqueness for FileEntry nodes is; // maintained by FileManager, which in turn uses inode numbers on hosts; // that support that. When coupled with the module cache's proclivity for; // turning over and deleting stale PCMs, this means entries for different; // module files can wind up reusing the same underlying inode. When this; // happens, subsequent accesses to the Modules map will disagree on the; // ModuleFile associated with a given file. In general, it is not sufficient; // to resolve this conundrum with a type like FileEntryRef that stores the; // name of the FileEntry node on first access because of path canonicalization; // issues. However, the paths constructed for implicit module builds are; // fully under Clang's control. We *can*, therefore, rely on their structure; // being consistent across operating systems and across subsequent accesses; // to the Modules map.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:467,access,accesses,467,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,3,['access'],"['access', 'accesses']"
Security,"// The Name Index has a Hash Table, so use that to speed up the search.; // Compute the Key Hash, if it has not been done already.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFAcceleratorTable.cpp:24,Hash,Hash,24,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFAcceleratorTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFAcceleratorTable.cpp,2,['Hash'],['Hash']
Security,"// The PLT is only used in 32-bit ELF PIC mode. Attempting to use the PLT in; // a static relocation model causes some versions of GNU LD (2.17.50, at; // least) to force BSS-PLT, instead of secure-PLT, even if all objects are; // built with secure-PLT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:191,secur,secure-PLT,191,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,['secur'],['secure-PLT']
Security,"// The RooDataHit can be analytically integrated with the RooDataHist::sum(); // member functions. This functionality is used in the analytical; // integration capabilities of RooHistPdf and RooHistFunc. Therefore, to; // test these two classes at the same time, this tests validated; // RooDataHist::sum() via the RooHistPdf and RooHistFunc interfaces.; // The histograms for this example are kept simple such that one can easily; // calculate the expected values with a calculator.; // We first create an easy non-uniform histogram for the x variable so we; // can know what we expect as test results analytically. The histogram will; // have the following bins with contents:; // - bin1 [0.0, 1.0]: 3 counts (bin volume x counts = 3); // - bin2 [1.0, 3.0]: 1 count (bin volume x counts = 2); // - bin3 [3.0, 3.5]: 8 counts (bin volume x counts = 4)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooDataHist.cxx:274,validat,validated,274,roofit/roofitcore/test/testRooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooDataHist.cxx,1,['validat'],['validated']
Security,"// The RooHistFunc is only used to access this histogram observables in a; // convenient way. That's why this proxy is not ""serving"" this; // RooBinWidthFunction in any way (see proxy constructor arguments in the; // initializer list above).; //; // However, the variables of the histFunc **need to be** value servers,; // because the width of the current bin depends on the values of the; // observables:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinWidthFunction.cxx:35,access,access,35,roofit/roofitcore/src/RooBinWidthFunction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinWidthFunction.cxx,1,['access'],['access']
Security,"// The STL GenerateInitInstance are not unique and hence are declared static; // (not accessible outside the dictionary and not linker error for duplicate)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/RtypesImp.h:86,access,accessible,86,core/base/inc/RtypesImp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/RtypesImp.h,1,['access'],['accessible']
Security,"// The SVE count intrinsics don't support the multiplier immediate so we; // don't have to account for that here. The value returned may be slightly; // over the true required bits, as this is based on the ""ALL"" pattern. The; // other patterns are also exposed by these intrinsics, but they all; // return a value that's strictly less than ""ALL"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:253,expose,exposed,253,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['expose'],['exposed']
Security,"// The TStreamerInfo's checksum is different from the checksum for the compile class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:23,checksum,checksum,23,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,2,['checksum'],['checksum']
Security,"// The TfrI does not access memory, but DefI could. Check if it's safe; // to move DefI down to TfrI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:21,access,access,21,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,1,['access'],['access']
Security,"// The URL consists of URL for the ""scopeName"", ""#a"" and hashed as MD5 text.; // The text is ""Class::EnumerationEnumeration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:57,hash,hashed,57,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['hash'],['hashed']
Security,// The ValueInfo corresponding to the candidate. We save an index hash; // table lookup for each GUID by stashing this here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionImport.h:66,hash,hash,66,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionImport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionImport.h,1,['hash'],['hash']
Security,// The `getSHNDXTable` calls the `getSection` internally when validates; // the symbol table section linked to the SHT_SYMTAB_SHNDX section.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/obj2yaml/elf2yaml.cpp:62,validat,validates,62,interpreter/llvm-project/llvm/tools/obj2yaml/elf2yaml.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/obj2yaml/elf2yaml.cpp,1,['validat'],['validates']
Security,"// The access densities are multiplied by 100 to hold 2 decimal places of; // precision, so need to divide by 100.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:7,access,access,7,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,2,['access'],['access']
Security,// The access function must stride over the innermost loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:7,access,access,7,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['access'],['access']
Security,"// The access list owns the reference, so we erase it from the non-owning list; // first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:7,access,access,7,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['access'],['access']
Security,"// The access of the enum constant is defined by the access of the enum:; // for CINT, all enum constants are public.; // There is no TClass or TDataType for enum types; instead, use CINT:; /*; No - CINT does not know their access restriction.; With CINT5 we have no way of determining it... ClassInfo_t* enumCI = gInterpreter->ClassInfo_Factory(dm->GetTypeName());; if (enumCI) {; Long_t prop = gInterpreter->ClassInfo_Property(enumCI);; if (kIsPrivate & prop); mtype = 3;; else if (kIsProtected & prop); mtype = 4;; else if (kIsPublic & prop); mtype = 5;; gInterpreter->ClassInfo_Delete(enumCI);; }; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocParser.cxx:7,access,access,7,html/src/TDocParser.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocParser.cxx,3,['access'],['access']
Security,// The access of the path down to this record.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp:7,access,access,7,interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/CXXInheritance.cpp,1,['access'],['access']
Security,"// The access offset from the base of the head of chain is also; // calculated here as all debuginfo types are available.; // Get type name and calculate the first index.; // We only want to get type name from typedef, structure or union.; // If user wants a relocation like; // int *p; ... __builtin_preserve_access_index(&p[4]) ...; // or; // int a[10][20]; ... __builtin_preserve_access_index(&a[2][3]) ...; // we will skip them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:7,access,access,7,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,1,['access'],['access']
Security,// The access's stride. It is negative for a reverse access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:7,access,access,7,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,2,['access'],['access']
Security,"// The access-control rules we use here are essentially the rules for; // doing a lookup in Class that just magically skipped the direct; // members of Class itself. That is, the naming class is Class, and the; // access includes the access of the base.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:7,access,access-control,7,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,3,['access'],"['access', 'access-control']"
Security,"// The accessed location varies within the loop, but remains within the; // underlying object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:7,access,accessed,7,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['access'],['accessed']
Security,// The accessors used on call site here do the right thing for calls and; // invokes with operand bundles.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:7,access,accessors,7,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,1,['access'],['accessors']
Security,"// The addresses of the value mapping are unique.; // Therefore, we can use them directly to hash the operand mapping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:93,hash,hash,93,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,1,['hash'],['hash']
Security,// The alignment of the vtordisp is at least the required alignment of the; // entire record. This requirement may be present to support vtordisp; // injection.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:150,inject,injection,150,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['inject'],['injection']
Security,// The alignment of this access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:25,access,access,25,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,1,['access'],['access']
Security,"// The alignment to use when accessing this lvalue. (For vector elements,; // this is the alignment of the whole vector.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGValue.h:29,access,accessing,29,interpreter/llvm-project/clang/lib/CodeGen/CGValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGValue.h,1,['access'],['accessing']
Security,// The allocation containing the EH security guard.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86WinEHState.cpp:36,secur,security,36,interpreter/llvm-project/llvm/lib/Target/X86/X86WinEHState.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86WinEHState.cpp,1,['secur'],['security']
Security,"// The array may be accessed in reverse, for example:; // for (i = N; i > 0; i--); // A[i] = 0;; // In this case, reconstruct the access function using the absolute value; // of the step recurrence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:20,access,accessed,20,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,2,['access'],"['access', 'accessed']"
Security,"// The assumption here is that if the source (R) is longer than the; // destination, then the destination is a sequence of words of; // size RW, and each such word in R can be accessed via a subregister.; //; // If the beginning and the end of the field cross the subregister; // boundary, advance to the next subregister.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:176,access,accessed,176,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,1,['access'],['accessed']
Security,"// The base ESR is 0x8000 and the register information is encoded in bits; // 0-9 as follows:; // - 0-4: n, where the register Xn contains the target address; // - 5-9: m, where the register Wm contains the expected type hash; // Where n, m are in [0, 30].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp:221,hash,hash,221,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp,1,['hash'],['hash']
Security,// The base for all memory accesses. All memory accesses in a block are; // linked together using an intrusive list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:27,access,accesses,27,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,2,['access'],['accesses']
Security,"// The basic dag structure is correct, grab the inputs and validate them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:59,validat,validate,59,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['validat'],['validate']
Security,"// The below are utility functions. Other than creation of accesses to pass; // to insertDef, and removeAccess to remove accesses, you should generally; // not attempt to update memoryssa yourself. It is very non-trivial to get; // the edge cases right, and the above calls already operate in near-optimal; // time bounds.; /// Create a MemoryAccess in MemorySSA at a specified point in a block.; ///; /// When used by itself, this method will only insert the new MemoryAccess; /// into the access list, but not make any other changes, such as inserting; /// MemoryPHI nodes, or updating users to point to the new MemoryAccess. You; /// must specify a correct Definition in this case.; ///; /// Usually, this API is instead combined with insertUse() or insertDef(),; /// which will perform all the necessary MSSA updates. If these APIs are used,; /// then nullptr can be used as Definition, as the correct defining access; /// will be automatically determined.; ///; /// Note: If a MemoryAccess already exists for I, this function will make it; /// inaccessible and it *must* have removeMemoryAccess called on it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:59,access,accesses,59,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,4,['access'],"['access', 'accesses']"
Security,"// The block is cold if it calls/invokes a cold function. However, do not; // mark sanitizer traps as cold.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:83,sanitiz,sanitizer,83,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,1,['sanitiz'],['sanitizer']
Security,"// The branch contains a non-split base class; // FIXME: nothing to do in such cases, because readers cannot access; // non-split members and a reader for the whole branch will be added",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderGenerator.cxx:109,access,access,109,tree/treeplayer/src/TTreeReaderGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderGenerator.cxx,1,['access'],['access']
Security,"// The branch contains a non-split class; // FIXME: nothing to do in such cases, because readers cannot access; // non-split members and a reader for the whole branch will be added",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderGenerator.cxx:104,access,access,104,tree/treeplayer/src/TTreeReaderGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderGenerator.cxx,1,['access'],['access']
Security,"// The bufSize must include the 8 bytes for the final xxhash3 checksum.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx:62,checksum,checksum,62,tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx,1,['checksum'],['checksum']
Security,// The bug affects the swizzling of SVS accesses if there is any carry out; // from the two low order bits (i.e. from bit 1 into bit 2) when adding; // voffset to (soffset + inst_offset).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp:40,access,accesses,40,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp,2,['access'],['accesses']
Security,"// The byte count and class version members are not checksummed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx:52,checksum,checksummed,52,tree/ntuple/v7/src/RMiniFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx,1,['checksum'],['checksummed']
Security,// The bytes of the checksum.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugChecksumsSubsection.h:20,checksum,checksum,20,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugChecksumsSubsection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugChecksumsSubsection.h,1,['checksum'],['checksum']
Security,"// The canonical declaration of every specialization is registered with; // the FunctionTemplateDecl.; // Note this might unload too much in the case:; // template<typename T> T f(){ return T();}; // template<> int f();; // template<> int f() { return 0;}; // when the template specialization was forward declared the canonical; // becomes the first forward declaration. If the canonical forward; // declaration was declared outside the set of the decls to unload we have; // to keep it registered as a template specialization.; //; // In order to diagnose mismatches of the specializations, clang 'injects'; // a implicit forward declaration making it very hard distinguish between; // the explicit and the implicit forward declaration. So far the only way; // to distinguish is by source location comparison.; // FIXME: When the misbehavior of clang is fixed we must avoid relying on; // source locations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp:599,inject,injects,599,interpreter/cling/lib/Interpreter/DeclUnloader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp,1,['inject'],['injects']
Security,"// The clang-cl driver passes ""-o -"" to the frontend. Inject the real; // file here to ensure ""-MT"" can be deduced if need be.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:54,Inject,Inject,54,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,1,['Inject'],['Inject']
Security,"// The client may be running the old pass manager, in which case, we need to; // map the requested Analysis to its equivalent wrapper in the old pass; // manager. The scheme implemented here does not require every Analysis to be; // updated. Only those new analyses that the client cares about in the old; // pass manager need to expose a LegacyWrapper type, and that wrapper should; // support a getResult() method that matches the new Analysis.; //; // We need SFINAE to check for the LegacyWrapper, but function templates don't; // allow partial specialization, which is needed in this case. So instead, we; // use a constexpr bool to perform the SFINAE, and then use this information; // inside the function template.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:330,expose,expose,330,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['expose'],['expose']
Security,"// The code bitset has all bits set to one whose position corresponds to arguments in dimSet.; // It is used as the key for the bin volume caching hash map.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx:147,hash,hash,147,roofit/roofitcore/src/RooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx,1,['hash'],['hash']
Security,"// The component accessor looks fine - now we need to compute the actual type.; // The vector type is implied by the component accessor. For example,; // vec4.b is a float, vec4.xy is a vec2, vec4.rgb is a vec3, etc.; // vec4.s0 is a float, vec4.s23 is a vec3, etc.; // vec4.hi, vec4.lo, vec4.e, and vec4.o all return vec2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:17,access,accessor,17,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,2,['access'],['accessor']
Security,"// The copy constructor is non-trivial, create a mapping from this class; // type to this constructor.; // N.B. The selection of copy constructor is not sensitive to this; // particular throw-site. Lookup will be performed at the catch-site to; // ensure that the copy constructor is, in fact, accessible (via; // friendship or any other means).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:294,access,accessible,294,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['access'],['accessible']
Security,"// The core logic from this function is taken from; // SIInsertWaitcnts::updateEventWaitcntAfter() In that pass, the instructions; // that are being looked at are in the MachineInstr format, whereas we have; // access to the MCInst format. The side effects of this are that we can't use; // the mayAccessVMEMThroughFlat(Inst) or mayAccessLDSThroughFlat(Inst); // functions. Therefore, we conservatively assume that these functions will; // return true. This may cause a few instructions to be incorrectly tagged; // with an extra CNT. However, these are instructions that do interact with at; // least one CNT so giving them an extra CNT shouldn't cause issues in most; // scenarios.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCA/AMDGPUCustomBehaviour.cpp:211,access,access,211,interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCA/AMDGPUCustomBehaviour.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCA/AMDGPUCustomBehaviour.cpp,1,['access'],['access']
Security,"// The correct behavior here is to add the offset into the TBAA; // struct node offset. The base type, however may not have defined; // a type at this additional offset, resulting in errors. Since; // this method is only used within a given load/store access; // the offset provided is only used to subdivide the previous load; // maintaining the validity of the previous TBAA.; //; // This, however, should be revisited in the future.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:252,access,access,252,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,1,['access'],['access']
Security,"// The cpuid register on arm is not accessible from user space. On Linux,; // it is exposed through the /proc/cpuinfo file.; // Read 32 lines from /proc/cpuinfo, which should contain the CPU part line; // in all cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp:36,access,accessible,36,interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,2,"['access', 'expose']","['accessible', 'exposed']"
Security,// The current sequence could be the start of a new CloneGroup. So we; // decrement i so that we visit it again in the outer loop.; // Note: i can never be 0 at this point because we are just comparing; // the hash of the Current StmtSequence with itself in the 'if' above.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:210,hash,hash,210,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,1,['hash'],['hash']
Security,"// The decl was found outside the C++ class, so only ObjC access checks; // apply. Those do not rely on NamingClass and BaseType, so we clear them; // out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:58,access,access,58,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['access'],['access']
Security,"// The default assumption needs to be ecc is enabled, but no directly; // exposed operations depend on it, so it can be safely inlined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp:74,expose,exposed,74,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,1,['expose'],['exposed']
Security,"// The default constructed value for checksumkind is required, but will never; // be used, as the parser checks if the field was actually Seen before using; // the Val.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:37,checksum,checksumkind,37,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,1,['checksum'],['checksumkind']
Security,"// The different predicates and matchers created during; // addInstructionMatcher use the RuleMatcher M to set up their; // instruction ID (InsnVarID) that are going to be used when; // M is going to be emitted.; // However, the code doing the emission still relies on the IDs; // returned during that process by the RuleMatcher when issuing; // the recordInsn opcodes.; // Because of that:; // 1. The order in which we created the predicates; // and such must be the same as the order in which we emit them,; // and; // 2. We need to reset the generation of the IDs in M somewhere between; // addInstructionMatcher and emit; //; // FIXME: Long term, we don't want to have to rely on this implicit; // naming being the same. One possible solution would be to have; // explicit operator for operation capture and reference those.; // The plus side is that it would expose opportunities to share; // the capture accross rules. The downside is that it would; // introduce a dependency between predicates (captures must happen; // before their first use.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp:864,expose,expose,864,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp,1,['expose'],['expose']
Security,"// The early exit in the original loop means that when performing vector; // loads we are potentially reading ahead of the early exit. So we could; // fault if crossing a page boundary. Therefore, we create runtime memory; // checks based on the minimum page size as follows:; // 1. Calculate the addresses of the first memory accesses in the loop,; // i.e. LhsStart and RhsStart.; // 2. Get the last accessed addresses in the loop, i.e. LhsEnd and RhsEnd.; // 3. Determine which pages correspond to all the memory accesses, i.e; // LhsStartPage, LhsEndPage, RhsStartPage, RhsEndPage.; // 4. If LhsStartPage == LhsEndPage and RhsStartPage == RhsEndPage, then; // we know we won't cross any page boundaries in the loop so we can; // enter the vector loop! Otherwise we fall back on the scalar loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoopIdiomTransform.cpp:327,access,accesses,327,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoopIdiomTransform.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoopIdiomTransform.cpp,3,['access'],"['accessed', 'accesses']"
Security,"// The effective context is a subclass of the declaring class.; // Check whether the [class.protected] restriction is limiting; // access.; // To get this exactly right, this might need to be checked more; // holistically; it's not necessarily the case that gaining; // access here would grant us access overall.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:131,access,access,131,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,3,['access'],['access']
Security,"// The expr result is transported as reference, pointer, array, float etc; // based on the desugared type. We should still expose the typedef'ed; // (sugared) type to the cling::Value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp:123,expose,expose,123,interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp,1,['expose'],['expose']
Security,"// The extra condition (fElement is not a TStreamerSTL) is to handle the case where fBranch is a; // TBranchElement and fElement is a TStreamerSTL. Without the extra condition we get an error; // message, although the vector (i.e. the TBranchElement) is accessible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TBranchProxy.cxx:254,access,accessible,254,tree/treeplayer/src/TBranchProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TBranchProxy.cxx,1,['access'],['accessible']
Security,"// The field manager should be accessed via TGeoGlobalMagField::Instance()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoGlobalMagField.h:31,access,accessed,31,geom/geom/inc/TGeoGlobalMagField.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoGlobalMagField.h,1,['access'],['accessed']
Security,// The field must be accessible in the context of the structured binding.; // We already checked that the base class is accessible.; // FIXME: Add 'const' to AccessedEntity's classes so we can remove the; // const_cast here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:21,access,accessible,21,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,3,"['Access', 'access']","['AccessedEntity', 'accessible']"
Security,"// The fieldID could be the root field or the class of fieldId might not be loaded.; // In these cases, only the inner fields are exposed as RDF columns.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:130,expose,exposed,130,tree/dataframe/src/RNTupleDS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx,1,['expose'],['exposed']
Security,// The file checksum subsection should precede all references to it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewReader.cpp:12,checksum,checksum,12,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewReader.cpp,2,['checksum'],['checksum']
Security,"// The file format, which is the inline null-terminated filename and a; // directory index. We don't track file size/timestamp so don't emit them; // in the v5 table. Emit MD5 checksums and source if we have them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp:176,checksum,checksums,176,interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDwarf.cpp,1,['checksum'],['checksums']
Security,"// The file implements built-in CUDA variables using __declspec(property).; // https://msdn.microsoft.com/en-us/library/yhfk0thd.aspx; // All read accesses of built-in variable fields get converted into calls to a; // getter function which in turn calls the appropriate builtin to fetch the; // value.; //; // Example:; // int x = threadIdx.x;; // IR output:; // %0 = call i32 @llvm.nvvm.read.ptx.sreg.tid.x() #3; // PTX output:; // mov.u32 %r2, %tid.x;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h:147,access,accesses,147,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_builtin_vars.h,1,['access'],['accesses']
Security,"// The file must be accessible",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofMgr.cxx:20,access,accessible,20,proof/proof/src/TProofMgr.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofMgr.cxx,1,['access'],['accessible']
Security,"// The first argument needs to be a record field access.; // If it is an array element access, we delay decision; // to BPF backend to check whether the access is a; // field access or not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:49,access,access,49,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,4,['access'],['access']
Security,"// The first instruction loads a PC-relative address into %r11 which is a; // GOT entry for this stub. This initially contains the address to the; // IFunc resolver. We can use %r11 here as it's caller saved but not used; // to pass any arguments. In fact, x86_64 ABI even suggests using %r11 for; // code in the PLT. The IFunc resolver will use %r11 to update the GOT; // entry.; //; // The next instruction just jumps to the address contained in the GOT; // entry. As mentioned above, we do this two-step jump by first setting; // %r11 so that the IFunc resolver has access to it.; //; // The IFunc resolver of course also needs to know the actual address of; // the actual IFunc resolver function. This will be stored in a GOT entry; // right next to the first one for this stub. So, the IFunc resolver will; // be able to call it with %r11+8.; //; // In total, two adjacent GOT entries (+relocation) and one additional; // relocation are required:; // GOT1: Address of the IFunc resolver.; // GOT2: Address of the IFunc resolver function.; // IFuncStubOffset+3: 32-bit PC-relative address of GOT1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp:569,access,access,569,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldELF.cpp,1,['access'],['access']
Security,"// The first space was originally the CSK_None variant, which is now; // obsolete, but the space is still reserved in ChecksumKind, so we account; // for it here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp:118,Checksum,ChecksumKind,118,interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,1,['Checksum'],['ChecksumKind']
Security,"// The first variant was originally CSK_None, encoded as 0. The new; // internal representation removes the need for this by wrapping the; // ChecksumInfo in an Optional, but to preserve Bitcode compatibility the 0; // encoding is reserved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h:142,Checksum,ChecksumInfo,142,interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h,1,['Checksum'],['ChecksumInfo']
Security,"// The floating point arithmetic should have been executed in the same order for reading and writing,; // thus we expect the checksums to be bitwise identical",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_extended.cxx:125,checksum,checksums,125,tree/ntuple/v7/test/ntuple_extended.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_extended.cxx,3,['checksum'],['checksums']
Security,"// The following code may create a signing oracle:; //; // <authenticate LR>; // TCRETURN ; the callee may sign and spill the LR in its prologue; //; // To avoid generating a signing oracle, check the authenticated value; // before possibly re-signing it in the callee, as follows:; //; // <authenticate LR>; // <check if LR contains a valid address>; // b.<cond> break_block; // ret_block:; // TCRETURN; // break_block:; // brk <BrkOperand>; //; // or just; //; // <authenticate LR>; // ldr tmp, [lr]; // TCRETURN; // TmpReg is chosen assuming X16 and X17 are dead after TI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.cpp:60,authenticat,authenticate,60,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.cpp,4,['authenticat'],"['authenticate', 'authenticated']"
Security,"// The following functions are called from constructors of `Expr`, so they; // should not access anything beyond basic",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ComputeDependence.h:90,access,access,90,interpreter/llvm-project/clang/include/clang/AST/ComputeDependence.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ComputeDependence.h,1,['access'],['access']
Security,"// The following member is not touched by a rule due to a checksum mismatch",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/rfield_class.cxx:58,checksum,checksum,58,tree/ntuple/v7/test/rfield_class.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/rfield_class.cxx,1,['checksum'],['checksum']
Security,"// The following member is set by a checksum based rule",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/rfield_class.cxx:36,checksum,checksum,36,tree/ntuple/v7/test/rfield_class.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/rfield_class.cxx,1,['checksum'],['checksum']
Security,"// The following section will collect all input filenames into a vector,; // including those listed within an indirect file.; // If any file can not be accessed, it will error out, unless skip_errors is true",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/main/src/hadd.cxx:152,access,accessed,152,main/src/hadd.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/main/src/hadd.cxx,1,['access'],['accessed']
Security,"// The following set of template specializations implement GraphTraits to treat; // any VPBlockBase as a node in a graph of VPBlockBases. It's important to note; // that VPBlockBase traits don't recurse into VPRegioBlocks, i.e., if the; // VPBlockBase is a VPRegionBlock, this specialization provides access to its; // successors/predecessors but not to the blocks inside the region.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanCFG.h:301,access,access,301,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanCFG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanCFG.h,1,['access'],['access']
Security,"// The following value is a guaranteed unmappable pointer value and has a; // repeated byte-pattern which makes it easier to synthesize. We use it for; // pointers as well as integers so that aggregates are likely to be; // initialized with this repeated value.; // For 32-bit platforms it's a bit trickier because, across systems, only the; // zero page can reasonably be expected to be unmapped. We use max 0xFFFFFFFF; // assuming that memory access will overlap into zero page.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/PatternInit.cpp:445,access,access,445,interpreter/llvm-project/clang/lib/CodeGen/PatternInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/PatternInit.cpp,1,['access'],['access']
Security,"// The following would allow to access the friend by name; // however, it would also prevent the access of the leaves; // within the friend. We could use the '@' notation here; // however this would not be aesthetically pleasing :(; // What we need to do, is add the ability to look ahead to; // the next 'token' to decide whether we to access the tree; // or its leaf.; //} else {; // TTree *tfriend = fTree->GetFriend(treename.c_str());; // TTree *realtree = fTree->GetTree();; // if (!tfriend && realtree != fTree){; // // If it is a chain and we did not find a friend,; // // let's try with the internal tree.; // tfriend = realtree->GetFriend(treename.c_str());; // }; // if (tfriend) {; // TNamed *named = new TNamed(treename.c_str(),tfriend->GetName());; // fLeafNames.AddAtAndExpand(named,fNcodes);; // fLeaves.AddAtAndExpand(tfriend,fNcodes);; // if (cname[i]) leftover = &(cname[i+1]);; // return 2;; // }; //}",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:32,access,access,32,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,3,['access'],['access']
Security,"// The friend class needs to have access to the internal storage; // to be able to build dependency graph, can't declare only one; // function a 'friend' due to the incomplete declaration at this point; // and mutual dependency problems.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h:34,access,access,34,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVDuplicatesTracker.h,1,['access'],['access']
Security,// The frontend that generates that parses the memory mapping information; // from the user should validate that the requested address is a multiple; // of the page size. Assert that this is true here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp:99,validat,validate,99,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Assembler.cpp,1,['validat'],['validate']
Security,"// The full name of the stream that contains the contents of this injected; // source. This is built as a concatenation of the literal ""/src/files""; // plus the ""vname"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/PDBFileBuilder.h:66,inject,injected,66,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/PDBFileBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/PDBFileBuilder.h,1,['inject'],['injected']
Security,// The function hash,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp:16,hash,hash,16,interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,1,['hash'],['hash']
Security,// The function sanitizer metadata needs to match the signature of the; // function it is being attached to. However this does not hold for split; // functions here. Thus remove the metadata for split functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:16,sanitiz,sanitizer,16,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['sanitiz'],['sanitizer']
Security,// The general dynamic access sequence is used to get the; // address of _TLS_MODULE_BASE_.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MCInstLower.cpp:23,access,access,23,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MCInstLower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MCInstLower.cpp,1,['access'],['access']
Security,"// The glvalue must refer to a large enough storage region.; // FIXME: If Address Sanitizer is enabled, insert dynamic instrumentation; // to check this.; // FIXME: Get object address space",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:82,Sanitiz,Sanitizer,82,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['Sanitiz'],['Sanitizer']
Security,// The gnu_debuglink's target is expected to not change or else its CRC would; // become invalidated and get rejected. We can avoid recalculating the; // checksum for every target file inside an archive by precomputing the CRC; // here. This prevents a significant amount of I/O.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/ObjcopyOptions.cpp:154,checksum,checksum,154,interpreter/llvm-project/llvm/tools/llvm-objcopy/ObjcopyOptions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/ObjcopyOptions.cpp,1,['checksum'],['checksum']
Security,"// The hash bitmap has `ceil((IPHR_HASH + 1) / 32)` words in it. The; // reference implementation builds a hash table with IPHR_HASH buckets in it.; // The last bucket is used to link together free hash table cells in a linked; // list, but it is always empty in the compressed, on-disk format. However,; // the bitmap must have a bit for it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/GSIStreamBuilder.cpp:7,hash,hash,7,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/GSIStreamBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/GSIStreamBuilder.cpp,3,['hash'],['hash']
Security,// The hash can be calculated outside the lock.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymCreator.cpp:7,hash,hash,7,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymCreator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymCreator.cpp,1,['hash'],['hash']
Security,"// The hash is based only on size/time of the file, so that the reader can; // match even when symlinking or excess path elements (""foo/../"", ""../""); // change the form of the name. However, complete path is still the key.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:7,hash,hash,7,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['hash'],['hash']
Security,"// The hash is just a starting point for the search, but if it; // doesn't work we should find the string no matter what, because; // we iterate the entire array.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBStringTable.cpp:7,hash,hash,7,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBStringTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBStringTable.cpp,1,['hash'],['hash']
Security,// The hash of the CFG for the instrumented function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h:7,hash,hash,7,interpreter/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h,1,['hash'],['hash']
Security,"// The hash on a markup name",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx:7,hash,hash,7,gui/guihtml/src/TGHtmlParse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx,1,['hash'],['hash']
Security,"// The hash on zType",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx:7,hash,hash,7,gui/guihtml/src/TGHtmlParse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx,2,['hash'],['hash']
Security,"// The hash table for HTML markup names.; //; // If an HTML markup name hashes to H, then gApMap[H] will point to; // a linked list of sgMap structure, one of which will describe the; // the particular markup (if it exists.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx:7,hash,hash,7,gui/guihtml/src/TGHtmlParse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx,2,['hash'],"['hash', 'hashes']"
Security,// The hash table with profile counts comes next.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp:7,hash,hash,7,interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp,1,['hash'],['hash']
Security,"// The hash table; //; // If the name of an escape sequence hashes to the value H, then; // gApEscHash[H] will point to a linked list of Esc structures, one of; // which will be the Esc structure for that escape sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx:7,hash,hash,7,gui/guihtml/src/TGHtmlParse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx,2,['hash'],"['hash', 'hashes']"
Security,// The hash value of dummy mapping records is always zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp:7,hash,hash,7,interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp,1,['hash'],['hash']
Security,"// The hash value to be returned",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx:7,hash,hash,7,gui/guihtml/src/TGHtmlParse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx,1,['hash'],['hash']
Security,"// The high 16 bits of a 18-bit unsigned PC-relative immediate. Used by; // pointer authentication, only within a function, so no relocation can be; // generated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64FixupKinds.h:84,authenticat,authentication,84,interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64FixupKinds.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64FixupKinds.h,1,['authenticat'],['authentication']
Security,// The high part of the thread pointer is in access register 0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:45,access,access,45,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['access'],['access']
Security,// The inheriting constructor was inlined; just inject its arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:48,inject,inject,48,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,1,['inject'],['inject']
Security,"// The instruction referenced does not exist. This normally indicates an; // error in the program, where you try and validate a graph that was created; // in a different FileAnalysis object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h:117,validat,validate,117,interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cfi-verify/lib/FileAnalysis.h,1,['validat'],['validate']
Security,// The interleaved memory access pass will lower interleaved memory ops (i.e; // a load and store followed by a specific shuffle) to vlseg/vsseg; // intrinsics. In those cases then we can treat it as if it's just one (legal); // memory op,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp:26,access,access,26,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.cpp,1,['access'],['access']
Security,"// The intrinsic function call is of the form { ElTy, i8* }; // @llvm.hexagon.L2.loadXX.pbr(i8*, i32). The pointer and memory access type; // should be derived from ElTy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:126,access,access,126,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,1,['access'],['access']
Security,"// The is the first transaction, we have to expose to meta; // what's already in the AST.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:44,expose,expose,44,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['expose'],['expose']
Security,"// The killing access completely overlaps the dead store if and only if; // both start and end of the dead one is ""inside"" the killing one:; // |<->|--dead--|<->|; // |-----killing------|; // Accesses may overlap if and only if start of one of them is ""inside""; // another one:; // |<->|--dead--|<-------->|; // |-------killing--------|; // OR; // |-------dead-------|; // |<->|---killing---|<----->|; //; // We have to be careful here as *Off is signed while *.Size is unsigned.; // Check if the dead access starts ""not before"" the killing one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:15,access,access,15,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,3,"['Access', 'access']","['Accesses', 'access']"
Security,"// The lazily copied regions are locations for which a program; // can access the value stored at that location, but not its address.; // These regions are constructed as a set of regions referred to by; // lazyCompoundVal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h:71,access,access,71,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h,1,['access'],['access']
Security,// The line table can be accessed using the linkage name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp:25,access,accessed,25,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,1,['access'],['accessed']
Security,"// The list contains fHClone, so let's clear it first to avoid; // accessing deleted memory later [we 'could' have just removed; // fHClone from the list]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.h:67,access,accessing,67,hist/hist/src/TH1Merger.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.h,1,['access'],['accessing']
Security,"// The list of friends needs to be accessed via GetTree()->GetListOfFriends(); // (and not directly GetListOfFriends()), otherwise when `main` is a TChain we; // might not recover the list correctly (see #6993 for the TTreeReader issue; // and #6741 for a more complete discussion/explanation).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFriendProxy.cxx:35,access,accessed,35,tree/treeplayer/src/TFriendProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFriendProxy.cxx,1,['access'],['accessed']
Security,"// The list of friends needs to be accessed via GetTree()->GetListOfFriends(); // (and not via GetListOfFriends() directly), otherwise when `t` is a TChain we; // might not recover the list correctly (https://github.com/root-project/root/issues/6741).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:35,access,accessed,35,tree/dataframe/src/RLoopManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx,1,['access'],['accessed']
Security,"// The llvm.amdgcn.module.lds instance is implicitly used by all kernels; // that might call a function which accesses a field within it. This is; // presently approximated to 'all kernels' if there are any such functions; // in the module. This implicit use is redefined as an explicit use here so; // that later passes, specifically PromoteAlloca, account for the required; // memory without any knowledge of this transform.; // An operand bundle on llvm.donothing works because the call instruction; // survives until after the last pass that needs to account for LDS. It is; // better than inline asm as the latter survives until the end of codegen. A; // totally robust solution would be a function with the same semantics as; // llvm.donothing that takes a pointer to the instance and is lowered to a; // no-op after LDS is allocated, but that is not presently necessary.; // This intrinsic is eliminated shortly before instruction selection. It; // does not suffice to indicate to ISel that a given global which is not; // immediately used by the kernel must still be allocated by it. An; // equivalent target specific intrinsic which lasts until immediately after; // codegen would suffice for that, but one would still need to ensure that; // the variables are allocated in the anticpated order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:110,access,accesses,110,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['access'],['accesses']
Security,"// The location entries are contained within a symbol. Get a location,; // to access basic information about indentation, parent, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVLocation.cpp:78,access,access,78,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVLocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVLocation.cpp,1,['access'],['access']
Security,"// The logic for summing over the histogram is borrowed from RooHistPdf with some differences:; //; // - a lambda function is used to inject the parameters for bin scaling into the RooDataHist::sum method; //; // - for simplicity, there is no check for the possibility of full-range integration with another overload of; // RooDataHist::sum",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooParamHistFunc.cxx:134,inject,inject,134,roofit/roofit/src/RooParamHistFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooParamHistFunc.cxx,1,['inject'],['inject']
Security,"// The loop branch contains the parallel loop metadata. In order to ensure; // that any parallel-loop-unaware optimization pass hasn't added loop-carried; // dependencies (thus converted the loop back to a sequential loop), check; // that all the memory instructions in the loop belong to an access group that; // is parallel to this loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp:292,access,access,292,interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopInfo.cpp,1,['access'],['access']
Security,// The loop distribution transformation only has a state form that is; // exposed by #pragma clang loop distribute (enable | disable).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp:74,expose,exposed,74,interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp,1,['expose'],['exposed']
Security,// The low part of the thread pointer is in access register 1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:44,access,access,44,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['access'],['access']
Security,"// The main purpose of iterators is to abstract away from different; // containers and provide a (maybe limited) uniform access to them.; // This implies that any correctly written template function that; // works on multiple containers using iterators takes different; // template parameters for different containers. So we can safely; // assume that passing iterators of different containers as arguments; // whose type replaces the same template parameter is a bug.; //; // Example:; // template<typename I1, typename I2>; // void f(I1 first1, I1 last1, I2 first2, I2 last2);; //; // In this case the first two arguments to f() must be iterators must belong; // to the same container and the last to also to the same container but; // not necessarily to the same as the first two.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MismatchedIteratorChecker.cpp:121,access,access,121,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MismatchedIteratorChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MismatchedIteratorChecker.cpp,1,['access'],['access']
Security,"// The mask operand contains the special register (R Bit) in bit 4, whether; // the register is spsr (R bit is 1) or one of cpsr/apsr (R bit is 0), and; // bits 3-0 contains the fields to be accessed in the special register, set by; // the flags provided with the register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:191,access,accessed,191,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['access'],['accessed']
Security,"// The maximum length of a single segment is 64KB minus the size to insert a; // continuation. So if we are over that, inject a continuation between the; // previous member and the member that was just written, then end the previous; // segment after the continuation and begin a new one with the just-written; // member.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/ContinuationRecordBuilder.cpp:119,inject,inject,119,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/ContinuationRecordBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/ContinuationRecordBuilder.cpp,1,['inject'],['inject']
Security,"// The member access is fully qualified (i.e., X::F).; // Treat this as a non-virtual call and do not warn.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VirtualCallChecker.cpp:14,access,access,14,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VirtualCallChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VirtualCallChecker.cpp,1,['access'],['access']
Security,// The memory access must have a proper alignment and no index register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:14,access,access,14,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,1,['access'],['access']
Security,// The memory mappings that the snippet can access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h:44,access,access,44,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h,1,['access'],['access']
Security,"// The minimum byte offset before the address point. This covers the bytes in; // the vtable object before the address point (e.g. RTTI, access-to-top,; // vtables for other base classes) and is equal to the offset from the start; // of the vtable object to the address point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h:137,access,access-to-top,137,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h,1,['access'],['access-to-top']
Security,// The minimum space required for emitting hashes of both names.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeRecordMapping.cpp:43,hash,hashes,43,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeRecordMapping.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeRecordMapping.cpp,1,['hash'],['hashes']
Security,// The mips ABIs for returning structs by value requires that we copy; // the sret argument into $v0 for the return. Save the argument into; // a virtual register so that we can access it from the return points.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:178,access,access,178,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,1,['access'],['access']
Security,"// The module does not have an entry, it can't have a hash at all",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:54,hash,hash,54,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,1,['hash'],['hash']
Security,"// The more common cases of a phi with no constant operands or just one; // variable operand are handled by FoldPHIArgOpIntoPHI() and foldOpIntoPhi(); // respectively. foldOpIntoPhi() wants to do the opposite transform that is; // performed here. It tries to replicate a cast in the phi operand's basic; // block to expose other folding opportunities. Thus, InstCombine will; // infinite loop without this check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:316,expose,expose,316,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,1,['expose'],['expose']
Security,"// The most reliable way to print unicode in a Windows console is with; // WriteConsoleW. To use that, first transcode from UTF-8 to UTF-16. This; // assumes that LLVM programs always print valid UTF-8 to the console. The data; // might not be UTF-8 for two major reasons:; // 1. The program is printing binary (-filetype=obj -o -), in which case it; // would have been gibberish anyway.; // 2. The program is printing text in a semi-ascii compatible codepage like; // shift-jis or cp1252.; //; // Most LLVM programs don't produce non-ascii text unless they are quoting; // user source input. A well-behaved LLVM program should either validate that; // the input is UTF-8 or transcode from the local codepage to UTF-8 before; // quoting it. If they don't, this may mess up the encoding, but this is still; // probably the best compromise we can make.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp:635,validat,validate,635,interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,1,['validat'],['validate']
Security,// The naming convention for the flag name is __<hash>_<file name> with '.' in; // <file name> replaced with '@'. For example C:\file.any.c would have a flag; // __D032E919_file@any@c. The naming convention match MSVC's format however; // the match is not required to make JMC work. The hashing function used here; // is different from MSVC's.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp:49,hash,hash,49,interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/JMCInstrumenter.cpp,2,['hash'],"['hash', 'hashing']"
Security,"// The nearest water without splitting the UserBB is right after it.; // If the distance is still large (we have a big BB), then we need to split it; // if we don't converge after certain iterations. This helps the following; // situation to converge:; // BB0:; // Big BB; // BB1:; // Constant Pool; // When a CP access is out of range, BB0 may be used as water. However,; // inserting islands between BB0 and BB1 makes other accesses out of range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp:313,access,access,313,interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,2,['access'],"['access', 'accesses']"
Security,"// The new memset is inserted before the memcpy, and it is known that the; // memcpy's defining access is the memset about to be removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:96,access,access,96,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,1,['access'],['access']
Security,"// The next character in the name being hashed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx:40,hash,hashed,40,gui/guihtml/src/TGHtmlParse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx,1,['hash'],['hashed']
Security,"// The next part of the URL is hashed ""@ scopeName::EnumeratorEnumerator"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:31,hash,hashed,31,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['hash'],['hashed']
Security,// The null DIType is the void type. Don't try to hash it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:50,hash,hash,50,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,2,['hash'],['hash']
Security,// The number of blocks required to hash the binary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOLayoutBuilder.h:36,hash,hash,36,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOLayoutBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOLayoutBuilder.h,1,['hash'],['hash']
Security,"// The number of hash buckets.; // Not used when dumping the object, but can be used to override; // the real number of buckets when emiting an object from a YAML document.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjectYAML/ELFYAML.h:17,hash,hash,17,interpreter/llvm-project/llvm/include/llvm/ObjectYAML/ELFYAML.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjectYAML/ELFYAML.h,1,['hash'],['hash']
Security,// The object size sanitizer should not be enabled at -O0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:19,sanitiz,sanitizer,19,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['sanitiz'],['sanitizer']
Security,"// The object type must be complete (or dependent), or; // C++11 [expr.prim.general]p3:; // Unlike the object expression in other contexts, *this is not required to; // be of complete type for purposes of class member access (5.2.5) outside; // the member function body.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:218,access,access,218,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['access'],['access']
Security,// The on-disk hashtable in clangast needs to be aligned by 4 bytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/WasmObjectWriter.cpp:15,hash,hashtable,15,interpreter/llvm-project/llvm/lib/MC/WasmObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/WasmObjectWriter.cpp,1,['hash'],['hashtable']
Security,// The on-disk hashtable needs to be aligned.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ObjectFilePCHContainerOperations.cpp:15,hash,hashtable,15,interpreter/llvm-project/clang/lib/CodeGen/ObjectFilePCHContainerOperations.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ObjectFilePCHContainerOperations.cpp,1,['hash'],['hashtable']
Security,"// The on-file TStreamerInfo's checksum differs from the checksum of a TStreamerInfo on another file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:31,checksum,checksum,31,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,2,['checksum'],['checksum']
Security,"// The optional access argument specifies the size of the smallest memory; // access to be made to the symbol, expressed in bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:16,access,access,16,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,2,['access'],['access']
Security,"// The order in which declarations are removed makes a difference, e.g.; // `MaybeRemoveDeclFromModule()` may require access to type information to; // make up the mangled name.; // Thus, we segregate declarations to be removed in `TagDecl`s (i.e., struct; // / union / class / enum) and other declarations. Removal of `TagDecl`s; // is deferred until all the other declarations have been processed.; // Declarations in each group are iterated in reverse order.; // Note that removing from single-linked list invalidates the iterators.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp:118,access,access,118,interpreter/cling/lib/Interpreter/DeclUnloader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp,1,['access'],['access']
Security,// The order must be consistent between lookup table and accesses to; // lookup table,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:57,access,accesses,57,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['access'],['accesses']
Security,// The original value should completely be mapped.; // Thus the maximum accessed index + 1 is the size of the original value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:72,access,accessed,72,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,1,['access'],['accessed']
Security,// The parent of the injected class name is the class itself.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:21,inject,injected,21,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['inject'],['injected']
Security,"// The path has been mapped by some nested VFS and exposes an external path,; // don't override it with the original path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp:51,expose,exposes,51,interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,1,['expose'],['exposes']
Security,"// The po_iterator_storage template provides access to the set of already; // visited nodes during the po_iterator's depth-first traversal.; //; // The default implementation simply contains a set of visited nodes, while; // the External=true version uses a reference to an external set.; //; // It is possible to prune the depth-first traversal in several ways:; //; // - When providing an external set that already contains some graph nodes,; // those nodes won't be visited again. This is useful for restarting a; // post-order traversal on a graph with nodes that aren't dominated by a; // single node.; //; // - By providing a custom SetType class, unwanted graph nodes can be excluded; // by having the insert() function return false. This could for example; // confine a CFG traversal to blocks in a specific loop.; //; // - Finally, by specializing the po_iterator_storage template itself, graph; // edges can be pruned by returning false in the insertEdge() function. This; // could be used to remove loop back-edges from the CFG seen by po_iterator.; //; // A specialized po_iterator_storage class can observe both the pre-order and; // the post-order. The insertEdge() function is called in a pre-order, while; // the finishPostorder() function is called just before the po_iterator moves; // on to the next node.; /// Default po_iterator_storage implementation with an internal set object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PostOrderIterator.h:45,access,access,45,interpreter/llvm-project/llvm/include/llvm/ADT/PostOrderIterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PostOrderIterator.h,1,['access'],['access']
Security,// The profile runtime also needs access to system libraries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:34,access,access,34,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,1,['access'],['access']
Security,"// The pseudo_probe_desc section has a format like:; // .section .pseudo_probe_desc,"""",@progbits; // .quad -5182264717993193164 // GUID; // .quad 4294967295 // Hash; // .uleb 3 // Name size; // .ascii ""foo"" // Name; // .quad -2624081020897602054; // .quad 174696971957; // .uleb 34; // .ascii ""main""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp:160,Hash,Hash,160,interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCPseudoProbe.cpp,1,['Hash'],['Hash']
Security,"// The random tag in hex representation; // Protection against reply attacks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:69,attack,attacks,69,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['attack'],['attacks']
Security,// The real type this represents...; // An accessor to get the real value...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h:43,access,accessor,43,interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,1,['access'],['accessor']
Security,"// The reference implementation doesn't include code for /src/headerblock; // handling, but it can only read natvis entries lld's PDB files if; // this hash function truncates the hash to 16 bit.; // PDB/include/misc.h in the reference implementation has a hashSz() function; // that returns an unsigned short, that seems what's being used for; // /src/headerblock.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBStringTableBuilder.cpp:152,hash,hash,152,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBStringTableBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBStringTableBuilder.cpp,3,['hash'],"['hash', 'hashSz']"
Security,// The resources are owned by AST when the current file is AST.; // So we reset the resources here to avoid users accessing it; // accidently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:114,access,accessing,114,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,1,['access'],['accessing']
Security,"// The result of V_ICMP/V_FCMP assembly instructions (which this; // intrinsic exposes) is one bit per thread, masked with the EXEC; // register (which contains the bitmask of live threads). So a; // comparison that always returns true is the same as a read of the; // EXEC register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp:79,expose,exposes,79,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,1,['expose'],['exposes']
Security,"// The result of this decay conversion points to an array element within the; // base lvalue. However, since TBAA currently does not support representing; // accesses to elements of member arrays, we conservatively represent accesses; // to the pointee object as if it had no any base lvalue specified.; // TODO: Support TBAA for member arrays.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:158,access,accesses,158,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,2,['access'],['accesses']
Security,// The result type of the GEP might not be the type of the memory; // access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:70,access,access,70,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['access'],['access']
Security,// The return value of a property access is typically a temporary value which; // will not be tracked in a persistent manner by the analyzer. We use; // evalAssume() in order to immediately record constraints on those temporaries; // at the time they are imposed (e.g. by a nil-check conditional).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:34,access,access,34,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,1,['access'],['access']
Security,// The sanitized value appropriate to use as an index into the symbol table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h:7,sanitiz,sanitized,7,interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,1,['sanitiz'],['sanitized']
Security,// The scalar expression of this access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:33,access,access,33,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,1,['access'],['access']
Security,"// The select routine does not have access to the LoadSDNode instance, so; // pass along the extension information",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:36,access,access,36,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,1,['access'],['access']
Security,"// The select's themselves are distinct instructions even if they share; // the same condition and evaluate to consecutive pointers for true and; // false values of the condition. Therefore using the select's themselves; // for grouping instructions would put consecutive accesses into different; // lists and they won't be even checked for being consecutive, and won't; // be vectorized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:272,access,accesses,272,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,1,['access'],['accesses']
Security,// The selected constraint type might expose new sideeffects,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp:38,expose,expose,38,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InlineAsmLowering.cpp,1,['expose'],['expose']
Security,"// The semantics of dynamic initialization of variables with static or thread; // storage duration depends on whether they are declared at block-scope. The; // initialization of such variables at block-scope can be aborted with an; // exception and later retried (per C++20 [stmt.dcl]p4), and recursive entry; // to their initialization has undefined behavior (also per C++20; // [stmt.dcl]p4). For such variables declared at non-block scope, exceptions; // lead to termination (per C++20 [except.terminate]p1), and recursive; // references to the variables are governed only by the lifetime rules (per; // C++20 [class.cdtor]p2), which means such references are perfectly fine as; // long as they avoid touching memory. As a result, block-scope variables must; // not be marked as initialized until after initialization completes (unless; // the mark is reverted following an exception), but non-block-scope variables; // must be marked prior to initialization so that recursive accesses during; // initialization do not restart initialization.; // Variables used when coping with thread-safe statics and exceptions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:980,access,accesses,980,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['access'],['accesses']
Security,"// The shrunken subtree_len might now be 1 chunk long. If so, hash that one; // chunk by itself. Otherwise, compress the subtree into a pair of CVs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c:62,hash,hash,62,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,1,['hash'],['hash']
Security,"// The shuffle inserts exactly one element from operand 0 into operand 1.; // Now see if we can access that element as a scalar via a real insert element; // instruction.; // TODO: We can try harder to locate the element as a scalar. Examples: it; // could be an operand of SCALAR_TO_VECTOR, BUILD_VECTOR, or a constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:96,access,access,96,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['access'],['access']
Security,"// The size is not directly available for physical registers.; // Instead, we need to access a register class that contains Reg and; // get the size of that register class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:86,access,access,86,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,1,['access'],['access']
Security,"// The size is not directly available for physical registers.; // Instead, we need to access a register class that contains Reg and; // get the size of that register class.; // Because this is expensive, we'll cache the register class by calling",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:86,access,access,86,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,1,['access'],['access']
Security,"// The size of the area, accessed by that VLSTM/VLLDM; // S0-S31 + FPSCR + 8 more bytes (VPR + pad, or just pad)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp:25,access,accessed,25,interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,1,['access'],['accessed']
Security,"// The size of the entire CodeSignature section, including both the header and; // hashes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOLayoutBuilder.h:83,hash,hashes,83,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOLayoutBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOLayoutBuilder.h,1,['hash'],['hashes']
Security,"// The size of the handler hash table. For best results this should; // be a prime number which is about the same size as the number of; // escape sequences known to the system.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx:27,hash,hash,27,gui/guihtml/src/TGHtmlParse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx,1,['hash'],['hash']
Security,// The size of the pointer access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:27,access,access,27,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['access'],['access']
Security,"// The small code model's direct accesses use ADRP, which cannot; // necessarily produce the value 0 (if the code is above 4GB).; // Same for the tiny code model, where we have a pc relative LDR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.cpp:33,access,accesses,33,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.cpp,1,['access'],['accesses']
Security,"// The spec says ""while 0 is a valid hash value, the row index in a used slot; // will always be non-zero"". Loop until we find a match or an empty slot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnitIndex.cpp:37,hash,hash,37,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnitIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFUnitIndex.cpp,1,['hash'],['hash']
Security,"// The stack is accessed unswizzled, so we can use a regular copy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp:16,access,accessed,16,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp,1,['access'],['accessed']
Security,// The start location of the active audit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:36,audit,audit,36,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,2,['audit'],['audit']
Security,"// The store to the fixedstack object is needed becuase accessing a; // field of the ByVal will use a gep and load. Ideally we will optimize; // to extracting the value from the register directly, and elide the; // stores when the arguments address is not taken, but that will need to; // be future work.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:56,access,accessing,56,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['access'],['accessing']
Security,// The struct contains results of the module analysis and methods; // to access them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h:73,access,access,73,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,1,['access'],['access']
Security,"// The symbol table. This is an open addressed hash table. The size of the; // hash table is always a power of 2.; // Each slot in the hash table consists of a pair of offset_type values. The; // first value is the offset of the symbol's name in the constant pool. The; // second value is the offset of the CU vector in the constant pool.; // If both values are 0, then this slot in the hash table is empty. This is ok; // because while 0 is a valid constant pool index, it cannot be a valid index; // for both a string and a CU vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFGdbIndex.cpp:47,hash,hash,47,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFGdbIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFGdbIndex.cpp,4,['hash'],['hash']
Security,"// The symmetry with Define is clear. We want to:; // - Create globally the alias and return this very node, unchanged; // - Make aliases accessible based on chains and not globally; // Helper to find out if a name is a column",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:138,access,accessible,138,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['access'],['accessible']
Security,// The tables (AVX512InterleavedLoadTbl and AVX512InterleavedStoreTbl); // contain the cost of the optimized shuffle sequence that the; // X86InterleavedAccess pass will generate.; // The cost of loads and stores are computed separately from the table.; // X86InterleavedAccess support only the following interleaved-access group.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:317,access,access,317,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['access'],['access']
Security,// The target provides a guard check function to validate the guard value.; // Generate a call to that function with the content of the guard slot as; // argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:49,validat,validate,49,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,2,['validat'],['validate']
Security,"// The two profiles coming with different valid hash codes indicates; // either:; // 1. They are same-named static functions from different compilation; // units (without using -unique-internal-linkage-names), or; // 2. They are really the same function but from different compilations.; // Let's bail out in either case for now, which means one profile is; // dropped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h:48,hash,hash,48,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,1,['hash'],['hash']
Security,"// The type is not known to the interpreter, but we don't want to error out; // here, rather if/when this column is used in jitted code, so we inject a broken but telling type name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:143,inject,inject,143,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['inject'],['inject']
Security,// The type of checksum.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugChecksumsSubsection.h:15,checksum,checksum,15,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugChecksumsSubsection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/DebugChecksumsSubsection.h,1,['checksum'],['checksum']
Security,"// The types we specifically need to rebuild are:; // - typenames, typeofs, and decltypes; // - types which will become injected class names; // Of course, we also need to rebuild any type referencing such a; // type. It's safest to just say ""dependent"", but we call out a; // few cases here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:120,inject,injected,120,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['inject'],['injected']
Security,// The uncompressed length may exceed the size of the encoded filenames.; // Skip size validation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp:87,validat,validation,87,interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp,1,['validat'],['validation']
Security,// The underlying objects alias; test accesses for dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:38,access,accesses,38,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['access'],['accesses']
Security,"// The unprivileged access is AS_none as we don't know how the member was; // accessed, which is described by the access in DeclAccessPair.; // `IsAccessible` will examine the actual access of Target (i.e.; // Decl->getAccess()) when calculating the access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:20,access,access,20,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,5,['access'],"['access', 'accessed']"
Security,// The user explicitly enabled the object size sanitizer. Warn; // that this does nothing at -O0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:47,sanitiz,sanitizer,47,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['sanitiz'],['sanitizer']
Security,"// The user explicitly passed -fno-rtti with -fsanitize=vptr, but; // the vptr sanitizer requires RTTI, so this is a user error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:79,sanitiz,sanitizer,79,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['sanitiz'],['sanitizer']
Security,// The validation of ValVersionStr is done at HLSLToolChain::TranslateArgs.; // Assume ValVersionStr is legal here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGHLSLRuntime.cpp:7,validat,validation,7,interpreter/llvm-project/clang/lib/CodeGen/CGHLSLRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGHLSLRuntime.cpp,1,['validat'],['validation']
Security,// The vector accessor can't exceed the number of elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:14,access,accessor,14,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['access'],['accessor']
Security,// The vector predication only has a state form that is exposed by; // #pragma clang loop vectorize_predicate (enable | disable).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp:56,expose,exposed,56,interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp,1,['expose'],['exposed']
Security,"// The version 2 format supports recording profile data of multiple; // functions which share the same key in one value field. To support this,; // the number block counters is recorded as an uint64_t field right after the; // function structural hash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h:247,hash,hash,247,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,1,['hash'],['hash']
Security,"// The vptr sanitizer requires RTTI, but RTTI is disabled (by; // default). Warn that the vptr sanitizer is being disabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:12,sanitiz,sanitizer,12,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,2,['sanitiz'],['sanitizer']
Security,"// The wide helper function returns (writes out) an array of chaining values; // and returns the length of that array. The number of chaining values returned; // is the dyanmically detected SIMD degree, at most MAX_SIMD_DEGREE. Or fewer,; // if the input is shorter than that many chunks. The reason for maintaining a; // wide array of chaining values going back up the tree, is to allow the; // implementation to hash as many parents in parallel as possible.; //; // As a special case when the SIMD degree is 1, this function will still return; // at least 2 outputs. This guarantees that this function doesn't perform the; // root compression. (If it did, it would use the wrong flags, and also we; // wouldn't be able to implement exendable ouput.) Note that this function is; // not used when the whole input is only 1 chunk long; that's a different; // codepath.; //; // Why not just have the caller split the input on the first update(), instead; // of implementing this special rule? Because we don't want to limit SIMD or; // multi-threading parallelism for that update().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c:414,hash,hash,414,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,1,['hash'],['hash']
Security,"// Then check if a previous authentication exists and is valid",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:28,authenticat,authentication,28,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['authenticat'],['authentication']
Security,// Then hash each of the children of the DIE.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:8,hash,hash,8,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,1,['hash'],['hash']
Security,"// Then we append ""#a"" and the hashed text.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:31,hash,hashed,31,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['hash'],['hashed']
Security,"// Then we have to append ""#a"" and the hashed text.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:39,hash,hashed,39,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['hash'],['hashed']
Security,"// Then we have to append the hashed text for the enumerator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:30,hash,hashed,30,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['hash'],['hashed']
Security,// Then we try all possible lengths this subsequence could have and; // reuse the same hash object to make sure we only hash every child; // hash exactly once.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:87,hash,hash,87,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,3,['hash'],['hash']
Security,// Then we validate while printing each block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-fdr-dump.cpp:11,validat,validate,11,interpreter/llvm-project/llvm/tools/llvm-xray/xray-fdr-dump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-fdr-dump.cpp,1,['validat'],['validate']
Security,"// There are five possible optimizations we can do for memcpy:; // a) memcpy-memcpy xform which exposes redundance for DSE.; // b) call-memcpy xform for return slot optimization.; // c) memcpy from freshly alloca'd space or space that has just started; // its lifetime copies undefined data, and we can therefore eliminate; // the memcpy in favor of the data that was already at the destination.; // d) memcpy from a just-memset'd source can be turned into memset.; // e) elimination of memcpy via stack-move optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:96,expose,exposes,96,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,1,['expose'],['exposes']
Security,"// There are integrals (e.g.: _BitInt(128)) that cannot be represented as; // any builtin integral type, so we use the hash of APSInt instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp:119,hash,hash,119,interpreter/llvm-project/clang/lib/AST/ODRHash.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ODRHash.cpp,1,['hash'],['hash']
Security,"// There are no SMRD extloads, so if we have to do a small type access we; // will use a MUBUF load.; // FIXME?: We also need to do this if unaligned, but we don't know the; // alignment here.; // TODO: Update this for GFX12 which does have scalar sub-dword loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:64,access,access,64,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['access'],['access']
Security,"// There are no intrinsic functions that leak arguments.; // If the called function does not return, the current function; // does not return as well, so no possibility of use-after-return.; // Sanitizer function also don't leak or don't return.; // It's safe to both pass pointers to local variables to them; // and to tail-call them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:194,Sanitiz,Sanitizer,194,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,1,['Sanitiz'],['Sanitizer']
Security,"// There are particular cases where we can conclude no-alias between; // a non-addr-taken global and some other underlying object. Specifically,; // a non-addr-taken global is known to not be escaped from any function. It is; // also incorrect for a transformation to introduce an escape of a global in; // a way that is observable when it was not there previously. One function; // being transformed to introduce an escape which could possibly be observed; // (via loading from a global or the return value for example) within another; // function is never safe. If the observation is made through non-atomic; // operations on different threads, it is a data-race and UB. If the; // observation is well defined, by being observed the transformation would have; // changed program behavior by introducing the observed escape, making it an; // invalid transform.; //; // This property does require that transformations which *temporarily* escape; // a global that was not previously escaped, prior to restoring it, cannot rely; // on the results of GMR::alias. This seems a reasonable restriction, although; // currently there is no way to enforce it. There is also no realistic; // optimization pass that would make this mistake. The closest example is; // a transformation pass which does reg2mem of SSA values but stores them into; // global variables temporarily before restoring the global variable's value.; // This could be useful to expose ""benign"" races for example. However, it seems; // reasonable to require that a pass which introduces escapes of global; // variables in this way to either not trust AA results while the escape is; // active, or to be forced to operate as a module pass that cannot co-exist; // with an alias analysis such as GMR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:1440,expose,expose,1440,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,1,['expose'],['expose']
Security,// There are references to yet-unhashed records. Suspend hashing for; // this record until all the other records are processed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeHashing.cpp:57,hash,hashing,57,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeHashing.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeHashing.cpp,1,['hash'],['hashing']
Security,"// There are some cases (for example when the buffer was stored outside of; // a ROOT file) where we do not have a TStreamerInfo. If the checksum is; // the one from the current class, we can still assume that we can read; // the data so let use it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx:137,checksum,checksum,137,io/io/src/TBufferFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx,3,['checksum'],['checksum']
Security,"// There are two main parts to this algorithm:; // - identifying which spelled range covers the expanded tokens; // - validating that this range doesn't cover any extra tokens (First/Last); //; // We do these in order. However as we transform the expanded range into the; // spelled one, we adjust First/Last so the validation remains simple.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:118,validat,validating,118,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,2,['validat'],"['validating', 'validation']"
Security,// There is a form of VFSGNJ which injects the negated sign of its second; // operand. Try and bubble any FNEG up after the extend/round to produce; // this optimized pattern. Avoid modifying cases where FP_ROUND and; // TRUNC=1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:35,inject,injects,35,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['inject'],['injects']
Security,"// There is content - a memory buffer or a file.; // We know it's a file because we started off the FileEntry.; // FIXME: LLVM will completely migrate to FileEntryRef.; // We added `isOpen()` in our commit:; // `Accessor to ""is file opened""; this is crucial info for us.`; // Move this logic to FileEntryRef or have a workaround.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ClangInternalState.cpp:212,Access,Accessor,212,interpreter/cling/lib/Interpreter/ClangInternalState.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ClangInternalState.cpp,1,['Access'],['Accessor']
Security,"// There is no ReadLeave for this node, so we need to do the validation here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:61,validat,validation,61,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['validat'],['validation']
Security,// There is no checksum. Therefore zero the next two fields and align; // back to 4 bytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp:15,checksum,checksum,15,interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCCodeView.cpp,1,['checksum'],['checksum']
Security,"// There is no easy way to access register information in `AIXException`; // class. when ShouldEmitEHBlock is false and VRs are saved, A dumy eh info; // table are emitted in PPCAIXAsmPrinter::emitFunctionBodyEnd.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp:27,access,access,27,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AIXException.cpp,1,['access'],['access']
Security,"// There is no encryption key: send it plain",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:15,encrypt,encryption,15,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['encrypt'],['encryption']
Security,"// There is no overlap between the cluster we found [entryCurrent, entryNext[; // and the authorized range [fEntryMin, fEntryMax]; // so we have nothing to do",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:90,authoriz,authorized,90,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['authoriz'],['authorized']
Security,// There is no overlap between these relatively aligned accesses of; // similar size. Return no alias.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:56,access,accesses,56,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['access'],['accesses']
Security,"// There isn't necessarily a valid equivalent source-level syntax for; // these; in particular, a naive lowering might violate access control.; // So for now we lower to a ConstantExpr holding the value, wrapped around; // an OpaqueValueExpr.; // FIXME: We should have a better representation for this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:127,access,access,127,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['access'],['access']
Security,"// There must be a dataset 'testNtuple' already registered and validated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx:63,validat,validated,63,test/stressProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx,1,['validat'],['validated']
Security,"// There should be a hash value for every type record, or no hashes at all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/TpiStream.cpp:21,hash,hash,21,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/TpiStream.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/TpiStream.cpp,2,['hash'],"['hash', 'hashes']"
Security,"// There was a problem with the checksum, the user likely did not; // increment the version number of the derived class when the; // base class changed. Since we will be member wise streaming; // this class, let's warn the user that something is wrong.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:32,checksum,checksum,32,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,1,['checksum'],['checksum']
Security,"// There's a GNU extension controlled by -mno-shared that allows; // locally-binding symbols to be accessed using absolute addresses.; // This is currently not supported. When supported -mno-shared makes; // .cpload expand to:; // lui $gp, %hi(__gnu_local_gp); // addiu $gp, $gp, %lo(__gnu_local_gp)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp:99,access,accessed,99,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,1,['access'],['accessed']
Security,// There's never a path involved when checking implicit destructor access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:67,access,access,67,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['access'],['access']
Security,// There's no point scattering f16x2 if we only ever access one; // element of it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:53,access,access,53,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,1,['access'],['access']
Security,// These access memory and are handled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp:9,access,access,9,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp,2,['access'],['access']
Security,// These access memory and are not handled yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp:9,access,access,9,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp,2,['access'],['access']
Security,"// These accessors and mutators correspond to the ELF32_R_SYM, ELF32_R_TYPE,; // and ELF32_R_INFO macros defined in the ELF specification:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h:9,access,accessors,9,interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h,1,['access'],['accessors']
Security,"// These accessors and mutators correspond to the ELF32_ST_BIND,; // ELF32_ST_TYPE, and ELF32_ST_INFO macros defined in the ELF specification:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h:9,access,accessors,9,interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h,1,['access'],['accessors']
Security,"// These accessors and mutators correspond to the ELF64_R_SYM, ELF64_R_TYPE,; // and ELF64_R_INFO macros defined in the ELF specification:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h:9,access,accessors,9,interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h,1,['access'],['accessors']
Security,// These accessors are handy for sharing templated code between IR and MIR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:9,access,accessors,9,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,1,['access'],['accessors']
Security,// These are accessors for each flag.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:13,access,accessors,13,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['access'],['accessors']
Security,// These are platform-specific things.; // Will need to go into the back end; // and accessed from here via a hook.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp:85,access,accessed,85,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp,1,['access'],['accessed']
Security,"// These are the above-referenced hash tables. (The pointers are null; // if no entries have been made.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TClass.h:34,hash,hash,34,core/meta/inc/TClass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TClass.h,1,['hash'],['hash']
Security,"// These are the event lists for the mlp train method; // first events in the tree are for training; // the rest for internal testing (cross validation)...; // NOTE: the training events are ordered: first part is signal, second part background",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodTMlpANN.cxx:141,validat,validation,141,tmva/tmva/src/MethodTMlpANN.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodTMlpANN.cxx,1,['validat'],['validation']
Security,"// These are the named PSTATE accesses using ""MSR (immediate)"" instructions,; // along with the upper limit on the immediates allowed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:30,access,accesses,30,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['access'],['accesses']
Security,"// These are the types we expect to return (in order of most to least; // likely):; //; // 1. DeclRefExpr - This is the expression for the base of the structure.; // It's exactly what we want to build an access to the \p counted_by; // field.; // 2. MemberExpr - This is the expression that has the same \p RecordDecl; // as the flexble array member's lexical enclosing \p RecordDecl. This; // allows us to catch things like: ""p->p->array""; // 3. CompoundLiteralExpr - This is for people who create something; // heretical like (struct foo has a flexible array member):; //; // (struct foo){ 1, 2 }.blah[idx];",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:204,access,access,204,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['access'],['access']
Security,// These are the validation counter values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h:17,validat,validation,17,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkResult.h,1,['validat'],['validation']
Security,// These arrays are indexed by log2(AccessSize).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:36,Access,AccessSize,36,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['Access'],['AccessSize']
Security,// These arrays is indexed by AccessIsWrite,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:30,Access,AccessIsWrite,30,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,1,['Access'],['AccessIsWrite']
Security,// These arrays is indexed by AccessIsWrite and Experiment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:30,Access,AccessIsWrite,30,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['Access'],['AccessIsWrite']
Security,"// These arrays is indexed by AccessIsWrite, Experiment and log2(AccessSize).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:30,Access,AccessIsWrite,30,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,2,['Access'],"['AccessIsWrite', 'AccessSize']"
Security,"// These comparisons are nontrivial, so assert that equality implies; // hash equality (DenseMap demands this as an invariant).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:73,hash,hash,73,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,2,['hash'],['hash']
Security,"// These correspond with the checker options. Looking at other checkers such; // as MallocChecker and CStringChecker, this is similar as to how they pull; // off having a modeling class, but emitting diagnostics under a smaller; // checker's name that can be safely disabled without disturbing the; // underlaying modeling engine.; // The reason behind having *checker options* rather then actual *checkers*; // here is that CallAndMessage is among the oldest checkers out there, and can; // be responsible for the majority of the reports on any given project. This; // is obviously not ideal, but changing checker name has the consequence of; // changing the issue hashes associated with the reports, and databases; // relying on this (CodeChecker, for instance) would suffer greatly.; // If we ever end up making changes to the issue hash generation algorithm, or; // the warning messages here, we should totally jump on the opportunity to; // convert these to actual checkers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp:666,hash,hashes,666,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,2,['hash'],"['hash', 'hashes']"
Security,"// These default values are chosen to represent an extremely skewed outcome for; // a condition, but they leave some room for interpretation by later passes.; //; // If the documentation for __builtin_expect() was made explicit that it should; // only be used in extreme cases, we could make this ratio higher. As it stands,; // programmers may be using __builtin_expect() / llvm.expect to annotate that a; // branch is likely or unlikely to be taken.; // WARNING: these values are internal implementation detail of the pass.; // They should not be exposed to the outside of the pass, front-end codegen; // should emit @llvm.expect intrinsics instead of using these weights directly.; // Transforms should use TargetTransformInfo's getPredictableBranchThreshold().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerExpectIntrinsic.cpp:549,expose,exposed,549,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerExpectIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerExpectIntrinsic.cpp,1,['expose'],['exposed']
Security,// These facilities are used for validation in debug builds.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/VerifyDiagnosticConsumer.h:33,validat,validation,33,interpreter/llvm-project/clang/include/clang/Frontend/VerifyDiagnosticConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/VerifyDiagnosticConsumer.h,1,['validat'],['validation']
Security,// These flags allow to change the shadow mapping and control how shadow memory; // is accessed. The shadow mapping looks like:; // Shadow = (Mem >> scale) + offset,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:87,access,accessed,87,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,1,['access'],['accessed']
Security,// These functions and classes need access to the instruction list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h:36,access,access,36,interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h,1,['access'],['access']
Security,"// These functions don't access any memory visible to the compiler.; // Note that this doesn't include objc_retainBlock, because it updates; // pointers when it copies block data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp:25,access,access,25,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp,1,['access'],['access']
Security,// These have no memory access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp:24,access,access,24,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Mips/Target.cpp,2,['access'],['access']
Security,// These iterators are allowed to sub-class DiffListIterator and access; // internal list pointers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h:65,access,access,65,interpreter/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h,1,['access'],['access']
Security,"// These methods allow access to the raw bitset underlying; // this object, breaking type safety. They are necessary for; // efficient interaction with TTree / TBranch / TBasket, but left; // private to prevent users from interacting with the raw bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/ROOT/TIOFeatures.hxx:23,access,access,23,tree/tree/inc/ROOT/TIOFeatures.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/ROOT/TIOFeatures.hxx,1,['access'],['access']
Security,// These need access to the underlying BB list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h:14,access,access,14,interpreter/llvm-project/llvm/include/llvm/IR/Function.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h,1,['access'],['access']
Security,// These only have an effect if hashPDBContentsToGUID() is false.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/InfoStreamBuilder.h:32,hash,hashPDBContentsToGUID,32,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/InfoStreamBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/InfoStreamBuilder.h,1,['hash'],['hashPDBContentsToGUID']
Security,"// These parameters compare to the operands of OpTypeImage (see; // https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#OpTypeImage; // for more details). The first 6 integer parameters all default to 0, and; // will be changed to 1 only for the image type(s) that set the parameter to; // one. The 7th integer parameter is the access qualifier, which is tacked on; // at the end.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/SPIR.cpp:338,access,access,338,interpreter/llvm-project/clang/lib/CodeGen/Targets/SPIR.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/SPIR.cpp,1,['access'],['access']
Security,"// These passes import type identifier resolutions for whole-program; // devirtualization and CFI. They must run early because other passes may; // disturb the specific instruction patterns that these passes look for,; // creating dependencies on resolutions that may not appear in the summary.; //; // For example, GVN may transform the pattern assume(type.test) appearing in; // two basic blocks into assume(phi(type.test, type.test)), which would; // transform a dependency on a WPD resolution into a dependency on a type; // identifier resolution for CFI.; //; // Also, WPD has access to more precise information than ICP and can; // devirtualize more effectively, so it should operate on the IR first.; //; // The WPD and LowerTypeTest passes need to run at -O0 to lower type; // metadata and intrinsics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:582,access,access,582,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['access'],['access']
Security,// These sets are used to seed the analysis with pointers used by memory; // accesses that will remain scalar.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:77,access,accesses,77,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['access'],['accesses']
Security,"// These two mappings contain the main block to access/def mappings for; // MemorySSA. The list contained in PerBlockAccesses really owns all the; // MemoryAccesses.; // Both maps maintain the invariant that if a block is found in them, the; // corresponding list is not empty, and if a block is not found in them, the; // corresponding list is empty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:48,access,access,48,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,1,['access'],['access']
Security,"// Things like GEP's can come in the form of Constants. Constants and; // ConstantExpr's do not have access to the knowledge of what they're; // contained in, so we must dig a little to find an instruction so we can; // tell if they're used inside of the function we're outlining. We also; // replace the original constant expression with a new instruction; // equivalent; an instruction as it allows easy modification in the; // following loop, as we can now know the constant (instruction) is owned by; // our target function and replaceUsesOfWith can now be invoked on it; // (cannot do this with constants it seems). A brand new one also allows us; // to be cautious as it is perhaps possible the old expression was used; // inside of the function but exists and is used externally (unlikely by the; // nature of a Constant, but still).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:101,access,access,101,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['access'],['access']
Security,"// Third argument (bool), defines whether the clobber search should skip the; // original queried access. If true, there will be a follow-up query searching; // for a clobber access past ""self"". Note that the Optimized access is not; // updated if a new clobber is found by this SkipSelf search. If this; // additional query becomes heavily used we may decide to cache the result.; // Walker instantiations will decide how to set the SkipSelf bool.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:98,access,access,98,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,3,['access'],['access']
Security,// Third step: compute the access functions for each subscript.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp:27,access,access,27,interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Delinearization.cpp,2,['access'],['access']
Security,// This access turns into a read/modify/write of the vector. Load the input; // value now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:8,access,access,8,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['access'],['access']
Security,"// This accesses the sampling distribution",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/test/testHypoTestInvResult.cxx:8,access,accesses,8,roofit/roostats/test/testHypoTestInvResult.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/test/testHypoTestInvResult.cxx,1,['access'],['accesses']
Security,"// This assignment is okay, even without the <waiters_count_lock_> held; // because no other waiter threads can wake up to access it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TWin32Condition.cxx:123,access,access,123,core/thread/src/TWin32Condition.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TWin32Condition.cxx,1,['access'],['access']
Security,// This basically repeats the main algorithm but keeps some more; // information.; // The natural access so far.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:98,access,access,98,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['access'],['access']
Security,// This branch handles both standalone functions and static methods.; // Slice the first argument (which is the base) when we access; // static method as non-static.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:126,access,access,126,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['access'],['access']
Security,"// This can happen from recv if ppoll initially gets a read-ready signal for a socket,; // but the received data does not pass the checksum test, so the socket becomes unreadable; // again or from non-blocking send if the socket becomes unwritable either due to the HWM; // being reached or the socket not being connected (anymore). The latter case usually means; // the connection has been severed from the other side, meaning it has probably been killed; // and in that case the next ppoll call will probably also receive a SIGTERM, ending the; // loop. In case something else is wrong, this message will print multiple times, which; // should be taken as a cue for writing a bug report :)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/util.cxx:131,checksum,checksum,131,roofit/multiprocess/src/util.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/util.cxx,1,['checksum'],['checksum']
Security,// This can happen in shared index files for distributed ThinLTO if; // the callee function summary is not included. Record 0 which we; // will have to deal with conservatively when doing any kind of; // validation in the ThinLTO backends.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:204,validat,validation,204,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,1,['validat'],['validation']
Security,"// This changes our hash value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:20,hash,hash,20,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,2,['hash'],['hash']
Security,"// This class doesn't know about the latency of a load instruction. So, it; // conservatively/pessimistically assumes that the latency of a load opcode; // matches the instruction latency.; //; // FIXME: In the absence of cache misses (i.e. L1I/L1D/iTLB/dTLB hits/misses),; // and load/store conflicts, the latency of a load is determined by the depth; // of the load pipeline. So, we could use field `LoadLatency` in the; // MCSchedModel to model that latency.; // Field `LoadLatency` often matches the so-called 'load-to-use' latency from; // L1D, and it usually already accounts for any extra latency due to data; // forwarding.; // When doing throughput analysis, `LoadLatency` is likely to; // be a better predictor of load latency than instruction latency. This is; // particularly true when simulating code with temporal/spatial locality of; // memory accesses.; // Using `LoadLatency` (instead of the instruction latency) is also expected; // to improve the load queue allocation for long latency instructions with; // folded memory operands (See PR39829).; //; // FIXME: On some processors, load/store operations are split into multiple; // uOps. For example, X86 AMD Jaguar natively supports 128-bit data types, but; // not 256-bit data types. So, a 256-bit load is effectively split into two; // 128-bit loads, and each split load consumes one 'LoadQueue' entry. For; // simplicity, this class optimistically assumes that a load instruction only; // consumes one entry in the LoadQueue. Similarly, store instructions only; // consume a single entry in the StoreQueue.; // In future, we should reassess the quality of this design, and consider; // alternative approaches that let instructions specify the number of; // load/store queue entries which they consume at dispatch stage (See; // PR39830).; //; // An instruction that both 'mayStore' and 'HasUnmodeledSideEffects' is; // conservatively treated as a store barrier. It forces older store to be; // executed before newer stores are is",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:859,access,accesses,859,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,1,['access'],['accesses']
Security,// This class has access to the internals of tree nodes. Its sole purpose is to; // define helpers that allow implementing the high-level mutation operations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Mutations.cpp:18,access,access,18,interpreter/llvm-project/clang/lib/Tooling/Syntax/Mutations.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Mutations.cpp,1,['access'],['access']
Security,// This class stores some data in DeclContext::BlockDeclBits; // to save some space. Use the provided accessors to access it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:102,access,accessors,102,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,2,['access'],"['access', 'accessors']"
Security,// This class stores some data in DeclContext::CXXConstructorDeclBits; // to save some space. Use the provided accessors to access it.; /// \name Support for base and member initializers.; /// \{; /// The arguments used to initialize the base or member.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:111,access,accessors,111,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,2,['access'],"['access', 'accessors']"
Security,"// This class stores some data in DeclContext::EnumDeclBits; // to save some space. Use the provided accessors to access it.; /// This represent the integer type that the enum corresponds; /// to for code generation purposes. Note that the enumerator constants may; /// have a different type than this does.; ///; /// If the underlying integer type was explicitly stated in the source; /// code, this is a TypeSourceInfo* for that type. Otherwise this type; /// was automatically deduced somehow, and this is a Type*.; ///; /// Normally if IsFixed(), this would contain a TypeSourceInfo*, but in; /// some cases it won't.; ///; /// The underlying type of an enumeration never has any qualifiers, so; /// we can get away with just storing a raw Type*, and thus save an; /// extra pointer when TypeSourceInfo is needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:101,access,accessors,101,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,2,['access'],"['access', 'accessors']"
Security,// This class stores some data in DeclContext::FunctionDeclBits; // to save some space. Use the provided accessors to access it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:105,access,accessors,105,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,2,['access'],"['access', 'accessors']"
Security,// This class stores some data in DeclContext::LinkageSpecDeclBits to save; // some space. Use the provided accessors to access it.; /// The source location for the extern keyword.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:108,access,accessors,108,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,2,['access'],"['access', 'accessors']"
Security,// This class stores some data in DeclContext::OMPDeclareReductionDeclBits; // to save some space. Use the provided accessors to access it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclOpenMP.h:116,access,accessors,116,interpreter/llvm-project/clang/include/clang/AST/DeclOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclOpenMP.h,2,['access'],"['access', 'accessors']"
Security,"// This class stores some data in DeclContext::ObjCContainerDeclBits; // to save some space. Use the provided accessors to access it.; // These two locations in the range mark the end of the method container.; // The first points to the '@' token, and the second to the 'end' token.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:110,access,accessors,110,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,2,['access'],"['access', 'accessors']"
Security,// This class stores some data in DeclContext::ObjCMethodDeclBits; // to save some space. Use the provided accessors to access it.; /// Return type of this method.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:107,access,accessors,107,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,2,['access'],"['access', 'accessors']"
Security,// This class stores some data in DeclContext::RecordDeclBits; // to save some space. Use the provided accessors to access it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:103,access,accessors,103,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,2,['access'],"['access', 'accessors']"
Security,// This class stores some data in DeclContext::TagDeclBits; // to save some space. Use the provided accessors to access it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:100,access,accessors,100,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,2,['access'],"['access', 'accessors']"
Security,"// This code below only been closely audited for negative strides in the; // unsigned comparison case, it may be correct for signed comparison, but; // that needs to be established.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:37,audit,audited,37,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['audit'],['audited']
Security,// This code has not been audited for volatile/ordered case.; // Check if the successor block has exactly 2 incoming edges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:26,audit,audited,26,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,1,['audit'],['audited']
Security,// This code hasn't been audited for ordered or volatile memory access,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:25,audit,audited,25,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,2,"['access', 'audit']","['access', 'audited']"
Security,// This code validates writes to PSTATE registers.; // Not a write.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:13,validat,validates,13,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['validat'],['validates']
Security,"// This controls whether or not we emit stack-protector instrumentation.; // In MSVC, Buffer Security Check (/GS) is on by default.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:93,Secur,Security,93,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['Secur'],['Security']
Security,"// This corresponds to the `OMFSegMapDesc` structure. The definition is not; // present in the reference implementation, but the layout is derived from; // code that accesses the fields.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/RawTypes.h:166,access,accesses,166,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/RawTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/RawTypes.h,1,['access'],['accesses']
Security,"// This declaration is a reference to an existing entity, but; // has different visibility from that entity: it either makes; // a friend visible or it makes a type visible in a new module.; // In either case, create a new declaration. We only do this if; // the declaration would have meant the same thing if no prior; // declaration were found, that is, if it was found in the same; // scope where we would have injected a declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:414,inject,injected,414,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['inject'],['injected']
Security,// This find the end of this bucket and also verifies that all the hashes in; // this bucket are correct by comparing the stored hashes to the ones we; // compute ourselves.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp:67,hash,hashes,67,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,2,['hash'],['hashes']
Security,"// This flag controls whether we check the shadow of the address; // operand of load or store. Such bugs are very rare, since load from; // a garbage address typically results in SEGV, but still happen; // (e.g. only lower bits of address are garbage, or the access happens; // early at program startup where malloc-ed memory is more likely to; // be zeroed. As of 2012-08-28 this flag adds 20% slowdown.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:259,access,access,259,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['access'],['access']
Security,// This flag indicates that the shader hash was computed; // taking into account source information (-Zss),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h:39,hash,hash,39,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h,1,['hash'],['hash']
Security,// This flag shows if a nontemporal load/stores should be used when accessing; // this lvalue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGValue.h:68,access,accessing,68,interpreter/llvm-project/clang/lib/CodeGen/CGValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGValue.h,1,['access'],['accessing']
Security,// This function can be parsed before we have validated the; // structure as an anonymous struct,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:46,validat,validated,46,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['validat'],['validated']
Security,"// This function does roughly the same thing as GenerateThunk, but in a; // very different way, so that va_start and va_end work correctly.; // FIXME: This function assumes ""this"" is the first non-sret LLVM argument of; // a function, and that there is an alloca built in the entry block; // for all accesses to ""this"".; // FIXME: This function assumes there is only one ""ret"" statement per function.; // FIXME: Cloning isn't correct in the presence of indirect goto!; // FIXME: This implementation of thunks bloats codesize by duplicating the; // function definition. There are alternatives:; // 1. Add some sort of stub support to LLVM for cases where we can; // do a this adjustment, then a sibcall.; // 2. We could transform the definition to take a va_list instead of an; // actual variable argument list, then have the thunks (including a; // no-op thunk for the regular definition) call va_start/va_end.; // There's a bit of per-call overhead for this solution, but it's; // better for codesize if the definition is long.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp:300,access,accesses,300,interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp,1,['access'],['accesses']
Security,"// This function may not be accessible using a pointer; // to the declaring class, get the adjustment necessary; // to convert that to a pointer to the defining class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx:28,access,accessible,28,core/metacling/src/TClingClassInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.cxx,1,['access'],['accessible']
Security,"// This function needs to lock access to the interpreter multiple times.; // Take the lock at the beginning of the function so that we don't incur; // in too much locking/unlocking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TFunction.cxx:31,access,access,31,core/meta/src/TFunction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TFunction.cxx,1,['access'],['access']
Security,"// This function tries to get the injected type from getTypeForDecl,; // then from the previous declaration if possible. If not, it creates; // a new type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:34,inject,injected,34,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['inject'],['injected']
Security,// This function will copy the injected type from D2CXX into Injected.; // The injected decl does not have a previous decl to copy from.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:31,inject,injected,31,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,3,"['Inject', 'inject']","['Injected', 'injected']"
Security,"// This global function needs access to computeFCN(); //friend void TFractionFitFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag);; // Goodness of fit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TFractionFitter.h:30,access,access,30,hist/hist/inc/TFractionFitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TFractionFitter.h,1,['access'],['access']
Security,"// This hack prevents stuff like:; // #define HASH #; // HASH define foo bar; // From having the # character end up at column 1, which makes it so it; // is not handled as a #define next time through the preprocessor if in; // -fpreprocessed mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp:46,HASH,HASH,46,interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp,2,['HASH'],['HASH']
Security,// This has to be delayed as the context hash can change at the start of; // `CompilerInstance::ExecuteAction`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp:41,hash,hash,41,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/ModuleDepCollector.cpp,1,['hash'],['hash']
Security,"// This has to live here, otherwise the CXXNameMangler won't have access to; // it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Mangle.h:66,access,access,66,interpreter/llvm-project/clang/include/clang/AST/Mangle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Mangle.h,1,['access'],['access']
Security,"// This is a GNU implementation of hash used in bloom filter!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp:35,hash,hash,35,interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,1,['hash'],['hash']
Security,"// This is a class property, we should not use the instance to; // access it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:67,access,access,67,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['access'],['access']
Security,"// This is a compromise. If we reach here, unaligned accesses may be slow on; // this target. However, creating smaller, aligned accesses could be even; // slower and would certainly be a lot more code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:53,access,accesses,53,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,2,['access'],['accesses']
Security,"// This is a convenience and flag variable that will be null unless the new; // alloca's integer operations should be widened to this integer type due to; // passing isIntegerWideningViable above. If it is non-null, the desired; // integer type will be stored here for easy access during rewriting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:274,access,access,274,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['access'],['access']
Security,"// This is a fast hash lookup in case the key does not already exist",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TDirectoryFile.cxx:18,hash,hash,18,io/io/src/TDirectoryFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TDirectoryFile.cxx,1,['hash'],['hash']
Security,"// This is a flat memory operation that access both VMEM and LDS, so note it; // - it will require that both the VM and LGKM be flushed to zero if it is; // pending when a VM or LGKM dependency occurs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:40,access,access,40,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['access'],['access']
Security,// This is a hash collision. Mark the filenames ref invalid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp:13,hash,hash,13,interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp,1,['hash'],['hash']
Security,"// This is a helper function used by the creation routines. It places NewAccess; // into the access and defs lists for a given basic block, at the given; // insertion point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:93,access,access,93,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['access'],['access']
Security,// This is a mem access with the same base register and known offsets from it.; // Reason about it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:17,access,access,17,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,1,['access'],['access']
Security,// This is a misaligned access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:24,access,access,24,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,1,['access'],['access']
Security,"// This is a normal type template argument. Note, if the type template; // argument is an injected-class-name for a template, it has a dual nature; // and can be used as either a type or a template. We handle that in; // convertTypeTemplateArgumentToTemplate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:90,inject,injected-class-name,90,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['inject'],['injected-class-name']
Security,"// This is a quite inefficient way to access map elements, but needed for the GDML writer to",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx:38,access,access,38,geom/geom/src/TGeoManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx,1,['access'],['access']
Security,"// This is a special member pulled in through a using decl. Special; // members of derived classes cannot be replaced; ignore this using decl,; // and keep only the (still possibly compiler-generated) special member of the; // derived class.; // NOTE that e.g. `Klass(int = 0)` has SpecMemKind == clang::Sema::CXXDefaultConstructor,; // yet this signature must be exposed, so check the argument count.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingMethodInfo.cxx:364,expose,exposed,364,core/metacling/src/TClingMethodInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingMethodInfo.cxx,1,['expose'],['exposed']
Security,"// This is a transient data member, so it is probably fine to not have; // access to its content. However let's no mark it as definitively setup,; // since another class might use this class for a persistent data member and; // in this case we really want the error message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:75,access,access,75,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['access'],['access']
Security,"// This is actually an interesting policy decision. We don't; // *have* to delay immediately here: we can do the full access; // calculation in the hope that friendship on some intermediate; // class will make the declaration accessible non-dependently.; // But that's not cheap, and odds are very good (note: assertion; // made without data) that the friend declaration will determine; // access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:118,access,access,118,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,3,['access'],"['access', 'accessible']"
Security,"// This is an abstract access, but we need to specify a type and size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:23,access,access,23,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,2,['access'],['access']
Security,// This is an extending load from a sub-dword size. Widen the memory; // access size to 4 bytes and clear the extra high bits appropriately,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:73,access,access,73,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,1,['access'],['access']
Security,// This is an out-of-bounds access and hence UB. Pretend we read zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:28,access,access,28,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['access'],['access']
Security,"// This is in the injected scope, create a new declaration in; // that scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:18,inject,injected,18,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['inject'],['injected']
Security,"// This is inaccurate. It depends on the instruction and address space. The; // only place where we should hit this is for dealing with frame indexes /; // private accesses, so this is correct in that case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp:164,access,accesses,164,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,1,['access'],['accesses']
Security,"// This is largely a copy of AsmParser's ParseDirectiveComm extended to; // accept a 3rd argument, AccessAlignment which indicates the smallest; // memory access made to the symbol, expressed in bytes. If no; // AccessAlignment is specified it defaults to the Alignment Value.; // Hexagon's .lcomm:; // .lcomm Symbol, Length, Alignment, AccessAlignment",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:99,Access,AccessAlignment,99,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,4,"['Access', 'access']","['AccessAlignment', 'access']"
Security,"// This is macOS-specific work-around and makes no sense for any; // other host OS. See https://openradar.appspot.com/FB8914231; //; // The macOS kernel maintains a signature-verification cache to; // quickly validate applications at time of execve(2). The trouble; // is that for the kernel creates the cache entry at the time of the; // mmap(2) call, before we have a chance to write either the code to; // sign or the signature header+hashes. The fix is to invalidate; // all cached data associated with the output file, thus discarding; // the bogus prematurely-cached signature.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOWriter.cpp:209,validat,validate,209,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOWriter.cpp,2,"['hash', 'validat']","['hashes', 'validate']"
Security,"// This is only correct if we access the same subregister index: otherwise,; // we could try to replace ""movb %ah, %al"" with ""movl %eax, %eax"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:30,access,access,30,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,1,['access'],['access']
Security,"// This is quite similar to gnutools::Linker::ConstructJob with changes that; // we use static by default, do not yet support sanitizers or LTO, and a few; // others. Eventually we can support more of that and hopefully migrate back; // to gnutools::Linker.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NaCl.cpp:126,sanitiz,sanitizers,126,interpreter/llvm-project/clang/lib/Driver/ToolChains/NaCl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/NaCl.cpp,1,['sanitiz'],['sanitizers']
Security,"// This is really a std::map, except that it provides a non-trivial; // default constructor to the element accessed via [].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFRegisters.h:107,access,accessed,107,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFRegisters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFRegisters.h,1,['access'],['accessed']
Security,// This is really only to get access to ReplaceNode (which is a protected; // member). Any other members used by HvxSelector can be moved around to; // make them accessible).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.h:30,access,access,30,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.h,2,['access'],"['access', 'accessible']"
Security,// This is responsible for low level access to the object file. It; // knows how to find the required sections and compute relocated; // values.; // The default implementations of the get<Section> methods return dummy values.; // This is to allow clients that only need some of those to implement just the; // ones they need. We can't use unreachable for as many cases because the parser; // implementation is eager and will call some of these methods even if the; // result is not used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFObject.h:37,access,access,37,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFObject.h,1,['access'],['access']
Security,// This is set 'true' initially and also when new blocks have been added to; // the function being analyzed. This boolean is used to control the updating; // of BlockRPONumber prior to accessing the contents of BlockRPONumber.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:185,access,accessing,185,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,1,['access'],['accessing']
Security,"// This is similar to the standard move-from-old-buckets, but the bucket; // count hasn't actually rotated in this case. So we have to carefully; // move construct the keys and values into their new locations, but there; // is no need to re-hash things.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:241,hash,hash,241,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,1,['hash'],['hash']
Security,// This is the first time we try to access OpIdx.; // Create the cells that will hold all the partial values at the; // end of the list of NewVReg.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp:36,access,access,36,interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterBankInfo.cpp,1,['access'],['access']
Security,"// This is the main test, which checks the offset values and the loop; // increment value to determine if the accesses may be loop carried.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:110,access,accesses,110,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['access'],['accesses']
Security,// This is the native endianness case that is most common and optimized for; // efficient lookups. Here we just grab pointers to the native data and; // use ArrayRef objects to allow efficient read only access.; // Read the address offsets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymReader.cpp:203,access,access,203,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/GsymReader.cpp,1,['access'],['access']
Security,"// This is the only use of this, and it's not worth defining a complicated; // densemapinfo hash/equality function for it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:92,hash,hash,92,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['hash'],['hash']
Security,"// This is to be changed whenever something is changed; // in non-backward compatible way; // 0 -> 1: support for SSH authentication via SSH tunnel",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/DaemonUtils.cxx:118,authenticat,authentication,118,net/rpdutils/src/DaemonUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/DaemonUtils.cxx,1,['authenticat'],['authentication']
Security,// This is unfortunately needed because ASTDeclWriter::VisitFunctionDecl; // need to access this bit but we want to avoid making ASTDeclWriter; // a friend of FunctionDeclBitfields just for this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:85,access,access,85,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['access'],['access']
Security,// This isn't exactly right. We're using slow unaligned 32-byte accesses; // as a proxy for a double-pumped AVX memory interface such as on; // Sandybridge.; // Sub-32-bit loads/stores will be slower either with PINSR*/PEXTR* or; // will be scalarized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:64,access,accesses,64,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['access'],['accesses']
Security,"// This kernel doesn't always result in a positive-semidefinite Gram; // matrix so should be used with caution and therefore not; // currently accessible. This is not a valid Mercer kernel",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SVKernelFunction.cxx:143,access,accessible,143,tmva/tmva/src/SVKernelFunction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SVKernelFunction.cxx,1,['access'],['accessible']
Security,// This macro is exposed to the rest of this compilation as a; // ModuleMacro; we don't need to track its MacroDirective any more.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:17,expose,exposed,17,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,1,['expose'],['exposed']
Security,// This maps the offset of this string in the string table to the offset; // of this checksum entry in the checksum buffer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/DebugChecksumsSubsection.cpp:85,checksum,checksum,85,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/DebugChecksumsSubsection.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/DebugChecksumsSubsection.cpp,2,['checksum'],['checksum']
Security,"// This member holds the last result of the value printing. It's a class; // member because we might want to access it after more inputs. If no value; // printing happens, it's in an invalid state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Interpreter/Interpreter.h:109,access,access,109,interpreter/llvm-project/clang/include/clang/Interpreter/Interpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Interpreter/Interpreter.h,1,['access'],['access']
Security,// This metadata is only relevant for instructions that access memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:56,access,access,56,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['access'],['access']
Security,// This method is not accessible outside of this file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:22,access,accessible,22,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['access'],['accessible']
Security,"// This might work out to be a current instantiation, in which; // case the canonical type needs to be the InjectedClassNameType.; //; // TODO: in theory this could be a simple hashtable lookup; most; // changes to CurContext don't change the set of current; // instantiations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:107,Inject,InjectedClassNameType,107,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,2,"['Inject', 'hash']","['InjectedClassNameType', 'hashtable']"
Security,// This must be an access of the only element. Return it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:19,access,access,19,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['access'],['access']
Security,"// This mutex prevents simultaneously loading objects from two different; // threads. This keeps us from having to protect individual data structures; // and guarantees that section allocation requests to the memory manager; // won't be interleaved between modules. It is also used in mapSectionAddress; // and resolveRelocations to protect write access to internal data structures.; //; // loadObject may be called on the same thread during the handling of; // processRelocations, and that's OK. The handling of the relocation lists; // is written in such a way as to work correctly if new elements are added to; // the end of the list while the list is being processed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:347,access,access,347,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,1,['access'],['access']
Security,"// This nested-name-specifier occurs in a member access expression, e.g.,; // x->B::f, and we are looking into the type of the object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:49,access,access,49,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,2,['access'],['access']
Security,"// This node must be the only member of its SCC as it has no callers, and; // that SCC must be the only member of a RefSCC as it has no references.; // Validate these properties first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:152,Validat,Validate,152,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,1,['Validat'],['Validate']
Security,// This only judges whether it is a safe *stack* access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:49,access,access,49,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,1,['access'],['access']
Security,"// This pass should only insert a stack allocation, memory accesses, and; // localrecovers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86WinEHState.cpp:59,access,accesses,59,interpreter/llvm-project/llvm/lib/Target/X86/X86WinEHState.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86WinEHState.cpp,1,['access'],['accesses']
Security,"// This random value acts as a block header, as otherwise the partition of; // opcodes into BBs wouldn't affect the hash, only the order of the; // opcodes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp:116,hash,hash,116,interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp,1,['hash'],['hash']
Security,// This report format is based on the sanitizer stack trace printer. See; // sanitizer_stacktrace_printer.cc in compiler-rt.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Signals.cpp:38,sanitiz,sanitizer,38,interpreter/llvm-project/llvm/lib/Support/Signals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Signals.cpp,1,['sanitiz'],['sanitizer']
Security,"// This returns an exact expression only. TODO: We really only need an; // upper bound here, but SE doesn't expose that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:108,expose,expose,108,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,1,['expose'],['expose']
Security,"// This routine does not expect to deal with volatile instructions.; // Doing so would require piping through the QueryInst all the way through.; // TODO: volatiles can't be elided, but they can be reordered with other; // non-volatile accesses.; // We currently give up on any instruction which is ordered, but we do handle; // atomic instructions which are unordered.; // TODO: Handle ordered instructions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:236,access,accesses,236,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['access'],['accesses']
Security,"// This rule uses a checksum to identify the source class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStructLinkDef.h:20,checksum,checksum,20,tree/ntuple/v7/test/CustomStructLinkDef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStructLinkDef.h,1,['checksum'],['checksum']
Security,"// This rule will be ignored due to a checksum mismatch",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStructLinkDef.h:38,checksum,checksum,38,tree/ntuple/v7/test/CustomStructLinkDef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStructLinkDef.h,1,['checksum'],['checksum']
Security,"// This scheduler implements a different scheduling algorithm than; // GenericScheduler.; //; // There are several specific architecture behaviours that can't be modelled; // for GenericScheduler:; // . When accessing the result of an SGPR load instruction, you have to wait; // for all the SGPR load instructions before your current instruction to; // have finished.; // . When accessing the result of an VGPR load instruction, you have to wait; // for all the VGPR load instructions previous to the VGPR load instruction; // you are interested in to finish.; // . The less the register pressure, the best load latencies are hidden; //; // Moreover some specifities (like the fact a lot of instructions in the shader; // have few dependencies) makes the generic scheduler have some unpredictable; // behaviours. For example when register pressure becomes high, it can either; // manage to prevent register pressure from going too high, or it can; // increase register pressure even more than if it hadn't taken register; // pressure into account.; //; // Also some other bad behaviours are generated, like loading at the beginning; // of the shader a constant in VGPR you won't need until the end of the shader.; //; // The scheduling problem for SI can distinguish three main parts:; // . Hiding high latencies (texture sampling, etc); // . Hiding low latencies (SGPR constant loading, etc); // . Keeping register usage low for better latency hiding and general; // performance; //; // Some other things can also affect performance, but are hard to predict; // (cache usage, the fact the HW can issue several instructions from different; // wavefronts if different types, etc); //; // This scheduler tries to solve the scheduling problem by dividing it into; // simpler sub-problems. It divides the instructions into blocks, schedules; // locally inside the blocks where it takes care of low latencies, and then; // chooses the order of the blocks by taking care of high latencies.; // Dividing the ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:208,access,accessing,208,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,2,['access'],['accessing']
Security,// This set of constraints deal with valid constants for various instructions.; // Validate and return a target constant for them if we can.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:83,Validat,Validate,83,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Validat'],['Validate']
Security,// This should be done before CFG hash computation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:34,hash,hash,34,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,1,['hash'],['hash']
Security,"// This starts at the memory access, and goes backwards in the block to find the; // previous definition. If a definition is not found the block of the access,; // it continues globally, creating phi nodes to ensure we have a single; // definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:29,access,access,29,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,2,['access'],['access']
Security,"// This starts at the memory access, and goes backwards in the block to the find; // the previous definition. If the definition is not found in the block of the; // access, it returns nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:29,access,access,29,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,2,['access'],['access']
Security,"// This struct is for use by ActOnMemberAccess to allow; // BuildMemberReferenceExpr to be able to reinvoke ActOnMemberAccess after; // changing the access operator from a '.' to a '->' (to see if that is the; // change needed to fix an error about an unknown member, e.g. when the class; // defines a custom operator->).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:149,access,access,149,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['access'],['access']
Security,"// This stub has to be able to access the full address space,; // since symbol lookup won't necessarily find a handy, in-range,; // PLT stub for functions which could be anywhere.; // Stub can use ip0 (== x16) to calculate address",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp:31,access,access,31,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyld.cpp,1,['access'],['access']
Security,"// This token is injected to represent the translation of '#include ""a.h""'; // into ""import a.h;"". Mimic the notional ';'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:17,inject,injected,17,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,1,['inject'],['injected']
Security,// This tries to make sure that we assign unique numbers to src and dst when; // the memory accesses reside in different loops that have the same depth.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:92,access,accesses,92,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['access'],['accesses']
Security,"// This triggers if a non-empty bucket points to a name with a mismatched; // hash. Clients are likely to interpret this as an empty bucket, because a; // mismatched hash signals the end of a bucket, but if this is indeed an; // empty bucket, the producer should have signalled this by marking the; // bucket as empty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp:78,hash,hash,78,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,2,['hash'],['hash']
Security,// This version of AnalyzeCallOperands in the base class is not usable; // since we must provide a means of accessing ISD::OutputArg::IsFixed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h:108,access,accessing,108,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZCallingConv.h,1,['access'],['accessing']
Security,"// This warning is deliberately made very specific to reduce false; // positives with logic that uses '&' for hashing. This logic mainly; // looks for code trying to introspect into tagged pointers, which; // code should generally never do.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:110,hash,hashing,110,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['hash'],['hashing']
Security,"// This will handle stores and memory insts. We only do if it the; // defining access has a different type, or it is a pointer produced by; // certain memory operations that cause the memory to have a fixed value; // (IE things like calloc).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:79,access,access,79,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['access'],['access']
Security,"// This will produce different values on 32-bit and 64-bit systens as; // hash_combine returns a size_t. However, this is only used for; // detailed hashing which, in-tree, only needs to distinguish between; // differences in functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp:149,hash,hashing,149,interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp,1,['hash'],['hashing']
Security,"// This will work if the tied src is accessing WORD_0, and the dst is; // writing WORD_1. Modifiers don't matter because all the bits that; // would be impacted are being overwritten by the dst.; // Any other case will not work.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIPeepholeSDWA.cpp:37,access,accessing,37,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIPeepholeSDWA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIPeepholeSDWA.cpp,1,['access'],['accessing']
Security,"// This worker is ready for the next validation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizer.cxx:37,validat,validation,37,proof/proofplayer/src/TPacketizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizer.cxx,2,['validat'],['validation']
Security,"// This would inject an emprt parameter pack, which is a good default.; // But for cases where instantiation fails, this hits bug in unloading; // of the failed instantiation, causing a missing symbol in subsequent; // transactions where a Decl instantiated by the failed instatiation; // is not re-emitted. So for now just give up default-instantiating; // templates with parameter packs, even if this is simply a work-around.; //defaultTemplateArgs.emplace_back(ArrayRef<TemplateArgument>{}); // empty pack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingMethodInfo.cxx:14,inject,inject,14,core/metacling/src/TClingMethodInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingMethodInfo.cxx,1,['inject'],['inject']
Security,"// Throughout C++2a [class.compare]: if overload resolution does not; // result in a usable function, the candidate function is defined as; // deleted. This requires that we selected an accessible function.; //; // Note that this only considers the access of the function when named; // within the type of the subobject, and not the access path for any; // derived-to-base conversion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:186,access,accessible,186,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,3,['access'],"['access', 'accessible']"
Security,"// Thumb has trouble with negative offsets from the FP. Thumb2 has a limited; // negative range for ldr/str (255), and Thumb1 is positive offsets only.; //; // It's going to be better to use the SP or Base Pointer instead. When there; // are variable sized objects, we can't reference off of the SP, so we; // reserve a Base Pointer.; //; // For Thumb2, estimate whether a negative offset from the frame pointer; // will be sufficient to reach the whole stack frame. If a function has a; // smallish frame, it's less likely to have lots of spills and callee saved; // space, so it's all more likely to be within range of the frame pointer.; // If it's wrong, the scavenger will still enable access to work, it just; // won't be optimal. (We should always be able to reach the emergency; // spill slot from the frame pointer.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.cpp:691,access,access,691,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.cpp,1,['access'],['access']
Security,"// Thumb1 instructions don't have explicit S bits. Rather, they; // implicitly set CPSR. Since it's not represented in the encoding, the; // auto-generated decoder won't inject the CPSR operand. We need to fix; // that as a post-pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:170,inject,inject,170,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,1,['inject'],['inject']
Security,"// Thumb1 may require a spill when storing to a frame index through FP (or any; // access with execute-only), for cases where FP is a high register (R11). This; // scans the function for cases where this may happen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp:83,access,access,83,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,1,['access'],['access']
Security,"// To ""insert"" Select_* instructions, we actually have to insert the triangle; // control-flow pattern. The incoming instructions know the destination vreg; // to set, the condition code register to branch on, the true/false values to; // select between, and the condcode to use to select the appropriate branch.; //; // We produce the following control flow:; // HeadMBB; // | \; // | IfFalseMBB; // | /; // TailMBB; //; // When we find a sequence of selects we attempt to optimize their emission; // by sharing the control flow. Currently we only handle cases where we have; // multiple selects with the exact same condition (same LHS, RHS and CC).; // The selects may be interleaved with other instructions if the other; // instructions meet some requirements we deem safe:; // - They are not pseudo instructions.; // - They are debug instructions. Otherwise,; // - They do not have side-effects, do not access memory and their inputs do; // not depend on the results of the select pseudo-instructions.; // The TrueV/FalseV operands of the selects cannot depend on the result of; // previous selects in the sequence.; // These conditions could be further relaxed. See the X86 target for a; // related approach and more information.; //; // Select_FPRX_ (rs1, rs2, imm, rs4, (Select_FPRX_ rs1, rs2, imm, rs4, rs5)); // is checked here and handled by a separate function -; // EmitLoweredCascadedSelect.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:907,access,access,907,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['access'],['access']
Security,// To access function attributes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:6,access,access,6,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,2,['access'],['access']
Security,// To allow access to JITCtor and InterpCtor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:12,access,access,12,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,1,['access'],['access']
Security,// To allow easy access to all instructions in a function with a given; // opcode we store them in the InfoCache. As not all opcodes are interesting; // to concrete attributes we only cache the ones that are as identified in; // the following switch.; // Note: There are no concrete attributes now so this is initially empty.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:17,access,access,17,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['access'],['access']
Security,"// To be safe that the loads can be combined, iterate over all loads and test; // that the corresponding defining access dominates first LI. This guarantees; // that there are no aliasing stores in between the loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:114,access,access,114,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,1,['access'],['access']
Security,"// To conserve compile-time, we avoid walking to the next clobbering def.; // Instead, we just try to get the optimized access, if it exists. DSE; // will try to optimize defs during the earlier traversal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:120,access,access,120,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,1,['access'],['access']
Security,"// To determine the symbol kind for any symbol declared in that function,; // we can access the S_FRAMEPROC for the parent scope function. It contains; // information about the local fp and param fp registers and compare with; // the register in the S_REGREL32 to get a match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp:85,access,access,85,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,1,['access'],['access']
Security,"// To handle this, we have to increase the size of the low part so that the; // second element will start at an 8 byte offset. We can't increase the size; // of the second element because it might make us access off the end of the; // struct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:205,access,access,205,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['access'],['access']
Security,"// To hash intrinsics, we use the opcode, and types like the other; // instructions, but also, the Intrinsic ID, and the Name of the; // intrinsic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:6,hash,hash,6,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,2,['hash'],['hash']
Security,"// To mangle anonymous namespaces, hash the path to the main source file. The; // path should be whatever (probably relative) path was passed on the command; // line. The goal is for the compiler to produce the same output regardless of; // working directory, so use the uncanonicalized relative path.; //; // It's important to make the mangled names unique because, when CodeView; // debug info is in use, the debugger uses mangled type names to distinguish; // between otherwise identically named types in anonymous namespaces.; //; // These symbols are always internal, so there is no need for the hash to; // match what MSVC produces. For the same reason, clang is free to change the; // hash at any time without breaking compatibility with old versions of clang.; // The generated names are intended to look similar to what MSVC generates,; // which are something like ""?A0x01234567@"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:35,hash,hash,35,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,3,['hash'],['hash']
Security,"// To retain the context, checksum, attributes of the original profile, make; // a copy of it if no profile is found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h:26,checksum,checksum,26,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,1,['checksum'],['checksum']
Security,"// To signal to the text printer that a certain text needs to be bolded,; // a special character is injected into the character stream which the; // text printer will later strip out.; /// Bold - Start bolding text.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp:100,inject,injected,100,interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,1,['inject'],['injected']
Security,"// To use this object, it should be created before the new attribute is created,; // and destructed after it is created. The construction already performs the; // import of the data. The array data is accessible in a pointer form, this form; // is used by the attribute classes. This object should be created once for the; // array data to be imported (the array size is not imported, just copied).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:201,access,accessible,201,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['access'],['accessible']
Security,"// Token identifying this authentication",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TSecContext.h:26,authenticat,authentication,26,net/net/inc/TSecContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TSecContext.h,1,['authenticat'],['authentication']
Security,"// Tokens like ""glc"" would be parsed as immediate operands in ParseOperand().; // But MatchInstructionImpl() expects to meet token and fails to validate; // operand. This method checks if we are given immediate operand but expect to; // get corresponding token.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:144,validat,validate,144,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,1,['validat'],['validate']
Security,// Tokens that indicate member access or chained operator& use.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:31,access,access,31,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,1,['access'],['access']
Security,"// Tool access.; /// TranslateArgs - Create a new derived argument list for any argument; /// translations this ToolChain may wish to perform, or 0 if no tool chain; /// specific translations are needed. If \p DeviceOffloadKind is specified; /// the translation specific for that offload kind is performed.; ///; /// \param BoundArch - The bound architecture name, or 0.; /// \param DeviceOffloadKind - The device offload kind used for the; /// translation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h:8,access,access,8,interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,1,['access'],['access']
Security,// Track if all interesting accesses are in the same `nosync` function as; // the given instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:28,access,accesses,28,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['access'],['accesses']
Security,// Trait for reading IndexedMemProfRecord data from the on-disk hash table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h:64,hash,hash,64,interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h,1,['hash'],['hash']
Security,// Trait for reading frame mappings from the on-disk hash table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h:53,hash,hash,53,interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h,1,['hash'],['hash']
Security,// Trait for writing IndexedMemProfRecord data to the on-disk hash table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h:62,hash,hash,62,interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h,1,['hash'],['hash']
Security,// Trait for writing frame mappings to the on-disk hash table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h:51,hash,hash,51,interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h,1,['hash'],['hash']
Security,// Trait used for the on-disk hash table of header search information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:30,hash,hash,30,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['hash'],['hash']
Security,// Trait used for the on-disk hash table used in the method pool.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:30,hash,hash,30,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,2,['hash'],['hash']
Security,"// Transform %rd = UpdateGBR(%rt, %ri); // Into: lwz %rt, .L0$poff - .L0$pb(%ri); // add %rd, %rt, %ri; // or into (if secure plt mode is on):; // addis r30, r30, {.LTOC,_GLOBAL_OFFSET_TABLE} - .L0$pb@ha; // addi r30, r30, {.LTOC,_GLOBAL_OFFSET_TABLE} - .L0$pb@l; // Get the offset from the GOT Base Register to the GOT",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:119,secur,secure,119,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,1,['secur'],['secure']
Security,// Translate available BinaryMetadataFeatures to corresponding clang-cc1; // flags. Does not depend on any other sanitizers. Unsupported on GPUs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:113,sanitiz,sanitizers,113,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['sanitiz'],['sanitizers']
Security,// Translate available CoverageFeatures to corresponding clang-cc1 flags.; // Do it even if Sanitizers.empty() since some forms of coverage don't require; // sanitizers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:92,Sanitiz,Sanitizers,92,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,2,"['Sanitiz', 'sanitiz']","['Sanitizers', 'sanitizers']"
Security,"// Transmit authentication information, if any",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TPServerSocket.cxx:12,authenticat,authentication,12,net/net/src/TPServerSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TPServerSocket.cxx,1,['authenticat'],['authentication']
Security,// Traverse the locations and validate them against the address to line; // mapping in the current compile unit. Record those invalid ranges.; // A valid range must meet the following conditions:; // a) line(lopc) <= line(hipc); // b) line(lopc) and line(hipc) are valid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVLocation.cpp:30,validat,validate,30,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVLocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVLocation.cpp,1,['validat'],['validate']
Security,// Traverse the rest of access chain to complete offset calculation; // and access key construction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:24,access,access,24,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,2,['access'],['access']
Security,// Traverse the scope ranges and for each range:; // - Apply the 'ValidLocation' validation criteria.; // - Add any failed range to the 'LocationList'.; // - Calculate location coverage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVScope.cpp:81,validat,validation,81,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVScope.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVScope.cpp,1,['validat'],['validation']
Security,// Traverse the symbol location ranges and for each range:; // - Apply the 'ValidLocation' validation criteria.; // - Add any failed range to the 'LocationList'.; // - Calculate location coverage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVScope.cpp:91,validat,validation,91,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVScope.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVScope.cpp,1,['validat'],['validation']
Security,"// Treat VAOPT as a placemarker token. Eat either the '##' before the; // RHS/VAOPT (if one exists, suggesting that the LHS (if any) to that; // hashhash was not a placemarker) or the '##'; // after VAOPT, but not both.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:145,hash,hashhash,145,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,1,['hash'],['hashhash']
Security,// Treat a template's injected-class-name as if the template; // specialization type had been used.; // template-name<T> (where template-name refers to a class template); // template-name<i>; // TT<T>; // TT<i>; // TT<>,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:22,inject,injected-class-name,22,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['inject'],['injected-class-name']
Security,// Treat an injected-class-name as its underlying template-id.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:12,inject,injected-class-name,12,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['inject'],['injected-class-name']
Security,"// Treat like a regular ""."" access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp:28,access,access,28,interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp,1,['access'],['access']
Security,// Treat memory accesses to promotable allocas as non-interesting since they; // will not cause memory violations. This greatly speeds up the instrumented; // executable at -O0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:16,access,accesses,16,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['access'],['accesses']
Security,"// Treat now Pred and Hash for unordered set/map containers. Signature is:; // template < class Key,; // class Hash = hash<Key>,; // class Pred = equal_to<Key>,; // class Alloc = allocator<Key>; // > class unordered_{set,multiset}; // template < class Key,; // class Val,; // class Hash = hash<Key>,; // class Pred = equal_to<Key>,; // class Alloc = allocator<Key>; // > class unordered_{map,multimap}",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/src/TClassEdit.cxx:22,Hash,Hash,22,core/foundation/src/TClassEdit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/src/TClassEdit.cxx,5,"['Hash', 'hash']","['Hash', 'hash']"
Security,"// Treat volatile accesses, ordered accesses and unmodeled side effects as; // barriers. We can look after this barrier for separate merges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp:18,access,accesses,18,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp,2,['access'],['accesses']
Security,"// Tree access",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooTreeDataStore.h:8,access,access,8,roofit/roofitcore/inc/RooTreeDataStore.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooTreeDataStore.h,1,['access'],['access']
Security,"// Trees are named objects in a THashList.; // We must update hashlists if we change the name",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:62,hash,hashlists,62,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['hash'],['hashlists']
Security,"// Trees are named objects in a THashList.; // We must update hashlists if we change the name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:62,hash,hashlists,62,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['hash'],['hashlists']
Security,"// True if there is no chance that any outlined candidate from this range; // could require stack fixups. That is, both; // * LR is available in the range (No save/restore around call); // * The range doesn't include calls (No save/restore in outlined frame); // are true.; // These conditions also ensure correctness of the return address; // authentication - we insert sign and authentication instructions only if; // we save/restore LR on stack, but then this condition ensures that the; // outlined range does not modify the SP, therefore the SP value used for; // signing is the same as the one used for authentication.; // FIXME: This is very restrictive; the flags check the whole block,; // not just the bit we will try to outline.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:344,authenticat,authentication,344,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,3,['authenticat'],['authentication']
Security,// Truncate is just accessing a subregister.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:20,access,accessing,20,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,2,['access'],['accessing']
Security,// Truncate the hash so we get 8 characters of hexadecimal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:16,hash,hash,16,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,1,['hash'],['hash']
Security,"// Truncate the name if necessary and append a hash of the name.; // The name length, hash included, is limited to 4096 bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeRecordMapping.cpp:47,hash,hash,47,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeRecordMapping.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeRecordMapping.cpp,2,['hash'],['hash']
Security,"// Try encryption with private key",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:7,encrypt,encryption,7,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,2,['encrypt'],['encryption']
Security,"// Try encryption with public key",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:7,encrypt,encryption,7,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,2,['encrypt'],['encryption']
Security,// Try printing the .gnu.hash table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp:25,hash,hash,25,interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,1,['hash'],['hash']
Security,// Try to access the header directory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp:10,access,access,10,interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesManager.cpp,1,['access'],['access']
Security,"// Try to be smart about what we write here. We can't write anything too; // large, so if we're going to go over the limit, replace lengthy names with; // a stringified hash value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeRecordMapping.cpp:169,hash,hash,169,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeRecordMapping.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeRecordMapping.cpp,1,['hash'],['hash']
Security,"// Try to compensate for a class that got unloaded on us.; // Search through the streamer infos by checksum; // and take the first match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:99,checksum,checksum,99,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['checksum'],['checksum']
Security,// Try to fold the load/store with an update that matches memory; // access size. This should work well for sequential loads.; //; // Filter out invalid updates as well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:69,access,access,69,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['access'],['access']
Security,"// Try to fold with other users. Non-constant updates are considered; // first, and constant updates are sorted to not break a sequence of; // strided accesses (if there is any).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:151,access,accesses,151,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['access'],['accesses']
Security,// Try to inline the call.; // The origin expression here is just used as a kind of checksum;; // this should still be safe even for CallEvents that don't come from exprs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:84,checksum,checksum,84,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,1,['checksum'],['checksum']
Security,"// Try to instantiate the class template as appropriate; otherwise, access to; // its data() may lead to a crash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:68,access,access,68,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['access'],['access']
Security,// Try to keep parsing unless it doesn't look like an accessor spec.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:54,access,accessor,54,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['access'],['accessor']
Security,"// Try to locate an std::hash for this type and use that if it exists",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx:25,hash,hash,25,bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx,1,['hash'],['hash']
Security,// Try to parse the property accessor:; // https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:29,access,accessor,29,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,1,['access'],['accessor']
Security,"// Try to refine the mod-ref info further using other API entry points to the; // aggregate set of AA results.; // We can completely ignore inaccessible memory here, because MemoryLocations; // can only reference accessible memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp:213,access,accessible,213,interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp,1,['access'],['accessible']
Security,// Try to turn sub-dword accesses of vectors into accesses of the same 32-bit; // elements. This exposes more load reduction opportunities by replacing; // multiple small extract_vector_elements with a single 32-bit extract.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:25,access,accesses,25,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,3,"['access', 'expose']","['accesses', 'exposes']"
Security,// Turn off usual access checking for template specializations and; // instantiations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:18,access,access,18,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['access'],['access']
Security,"// Turn off usual access checking for template specializations and; // instantiations.; // C++20 [temp.spec] 13.9/6.; // This disables the access checking rules for function template explicit; // instantiation and explicit specialization:; // - parameter-list;; // - template-argument-list;; // - noexcept-specifier;; // - dynamic-exception-specifications (deprecated in C++11, removed since; // C++17).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:18,access,access,18,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,2,['access'],['access']
Security,// Turn off usual access checking for templates explicit specialization; // and instantiation.; // C++20 [temp.spec] 13.9/6.; // This disables the access checking rules for member function template; // explicit instantiation and explicit specialization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:18,access,access,18,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,2,['access'],['access']
Security,"// Two pages adding up to 100 elements, one with checksum one without",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_serialize.cxx:49,checksum,checksum,49,tree/ntuple/v7/test/ntuple_serialize.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_serialize.cxx,1,['checksum'],['checksum']
Security,// Type accessors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h:8,access,accessors,8,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,1,['access'],['accessors']
Security,"// Type-based relocations don't use access string but clang backend; // generates '0' and libbpf checks it's value, do the same here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/BTF/BTFParser.cpp:36,access,access,36,interpreter/llvm-project/llvm/lib/DebugInfo/BTF/BTFParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/BTF/BTFParser.cpp,1,['access'],['access']
Security,"// Type-dependent operator calls are profiled like their underlying; // syntactic operator.; //; // An operator call to operator-> is always implicit, so just skip it. The; // enclosing MemberExpr will profile the actual member access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp:228,access,access,228,interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/StmtProfile.cpp,1,['access'],['access']
Security,// Typed accessors return std::nullopt/nullptr if the Value is not of this; // type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h:9,access,accessors,9,interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,1,['access'],['accessors']
Security,// Typed accessors return std::nullopt/nullptr if; // - the property doesn't exist; // - or it has the wrong type,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h:9,access,accessors,9,interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,1,['access'],['accessors']
Security,// UB-free unaligned access copied from xmmintrin.h,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/wasm_simd128.h:21,access,access,21,interpreter/llvm-project/clang/lib/Headers/wasm_simd128.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/wasm_simd128.h,2,['access'],['access']
Security,"// Unaligned access can use (for example) LRDB, LRDH, LDR",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:13,access,access,13,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['access'],['access']
Security,// Unaligned accesses should never be slower than the expanded version.; // We check specifically for aligned accesses in the few cases where; // they are required.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:13,access,accesses,13,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,2,['access'],['accesses']
Security,// Unaligned memory access,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp:20,access,access,20,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstructionSelector.cpp,1,['access'],['access']
Security,"// Under SanitizeMemoryUseAfterDtor, poison the trivial base class; // memory. For non-trival base classes the same is done in the class; // destructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:9,Sanitiz,SanitizeMemoryUseAfterDtor,9,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,1,['Sanitiz'],['SanitizeMemoryUseAfterDtor']
Security,"// Under V5, we need implicitarg_ptr + offsets to access private_base or; // shared_base. For pre-V5, however, need to access them through queue_ptr +; // offsets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAttributor.cpp:50,access,access,50,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAttributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAttributor.cpp,2,['access'],['access']
Security,"// Under V5, we need implicitarg_ptr + offsets to access private_base or; // shared_base. We do not actually need queue_ptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAttributor.cpp:50,access,access,50,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAttributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAttributor.cpp,1,['access'],['access']
Security,"// Under normal circumstances B.Index be equal to NextUncovered, but it can; // be less if a bucket points to names which are already known to be in some; // bucket we processed earlier. In that case, we won't trigger this error,; // but report the mismatched hash value error instead. (We know the hash; // will not match because we have already verified that the name's hash; // puts it into the previous bucket.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp:260,hash,hash,260,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,3,['hash'],['hash']
Security,"// Uniform RooDataHist, but with some empty bins to validate that empty; // bins are treated correctly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testTestStatistics.cxx:52,validat,validate,52,roofit/roofitcore/test/testTestStatistics.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testTestStatistics.cxx,1,['validat'],['validate']
Security,"// Unless +-flat-for-global is specified, turn on FlatForGlobal for targets; // that do not support ADDR64 variants of MUBUF instructions. Such targets; // cannot use a 64 bit offset with a MUBUF instruction to access the global; // address space",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp:211,access,access,211,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,1,['access'],['access']
Security,"// Unless +-flat-for-global is specified, use MUBUF instructions for global; // address space access if flat operations are not available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp:94,access,access,94,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,1,['access'],['access']
Security,"// Unless the data is coming via a socket connection from with schema evolution; // (tracking) was not enabled. So let's create the StreamerInfo if it is the; // one for the current version, otherwise let's complain ...; // We could also get here if there old class version was '1' and the new class version is higher than 1; // AND the checksum is the same.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx:337,checksum,checksum,337,io/io/src/TBufferFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx,2,['checksum'],['checksum']
Security,"// Unless the data is coming via a socket connection from with schema evolution; // (tracking) was not enabled. So let's create the StreamerInfo if it is the; // one for the current version, otherwise let's complain ...; // We could also get here when reading a file prior to the introduction of StreamerInfo.; // We could also get here if there old class version was '1' and the new class version is higher than 1; // AND the checksum is the same.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx:427,checksum,checksum,427,io/io/src/TBufferFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx,2,['checksum'],['checksum']
Security,"// Unlike ScalarEvolution::isLoopInvariant() we consider an access outside of; // any loop as invariant, because we only consier expression evaluation at a; // specific position (where the array access takes place), and not across the; // entire function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:60,access,access,60,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,2,['access'],['access']
Security,"// Unlike the other function, do not walk to the def of a def, because we are; // handed something we already believe is the clobbering access.; // We never set SkipSelf to true in Q in this method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:136,access,access,136,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['access'],['access']
Security,"// Unlike the specialization arguments, the injected arguments are not; // always canonical.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:44,inject,injected,44,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['inject'],['injected']
Security,// Unmerge and allow access to each Src element for the artifact combiner.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:21,access,access,21,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['access'],['access']
Security,"// UnresolvedLookupExpr is followed by several trailing objects.; // They are in order:; //; // * An array of getNumResults() DeclAccessPair for the results. These are; // undesugared, which is to say, they may include UsingShadowDecls.; // Access is relative to the naming class.; //; // * An optional ASTTemplateKWAndArgsInfo for the explicitly specified; // template keyword and arguments. Present if and only if; // hasTemplateKWAndArgsInfo().; //; // * An array of getNumTemplateArgs() TemplateArgumentLoc containing; // location information for the explicitly specified template arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:241,Access,Access,241,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,1,['Access'],['Access']
Security,"// UnresolvedMemberExpr is followed by several trailing objects.; // They are in order:; //; // * An array of getNumResults() DeclAccessPair for the results. These are; // undesugared, which is to say, they may include UsingShadowDecls.; // Access is relative to the naming class.; //; // * An optional ASTTemplateKWAndArgsInfo for the explicitly specified; // template keyword and arguments. Present if and only if; // hasTemplateKWAndArgsInfo().; //; // * An array of getNumTemplateArgs() TemplateArgumentLoc containing; // location information for the explicitly specified template arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:241,Access,Access,241,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,1,['Access'],['Access']
Security,"// Update llvm.compiler.used, adding the new liveness globals. This is; // needed so that during LTO these variables stay alive. The alternative; // would be to have the linker handling the LTO symbols, but libLTO; // current API does not expose access to the section for each symbol.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:239,expose,expose,239,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,2,"['access', 'expose']","['access', 'expose']"
Security,// Update the alias and access types of this set...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp:24,access,access,24,interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AliasSetTracker.cpp,1,['access'],['access']
Security,// Update the final access type and size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:20,access,access,20,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['access'],['access']
Security,// Update the linked list of memory accessing instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:36,access,accessing,36,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['access'],['accessing']
Security,"// Update the max number that can access one file node if the default is used",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizer.cxx:34,access,access,34,proof/proofplayer/src/TPacketizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizer.cxx,1,['access'],['access']
Security,// Update the uses of the old MSSA access with NewMemAcc.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:35,access,access,35,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['access'],['access']
Security,// Upper bound on lifetime access density (accesses per byte per lifetime sec); // for marking an allocation cold.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:27,access,access,27,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,2,['access'],"['access', 'accesses']"
Security,// Use 32-bit pointers for accessing const/local/short AS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.h:27,access,accessing,27,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXTargetMachine.h,1,['access'],['accessing']
Security,"// Use PC-relative addressing to access the GOT for this TLS symbol, then; // load the address from the GOT and add the thread pointer. This generates; // the pattern (PseudoLA_TLS_IE sym), which expands to; // (ld (auipc %tls_ie_pcrel_hi(sym)) %pcrel_lo(auipc)).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:33,access,access,33,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['access'],['access']
Security,"// Use PC-relative addressing to access the GOT for this symbol, then load; // the address from the GOT. This generates the pattern (PseudoLGA sym),; // which expands to (ld (addi (auipc %got_pcrel_hi(sym)) %pcrel_lo(auipc))).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:33,access,access,33,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['access'],['access']
Security,"// Use PC-relative addressing to access the GOT for this symbol, then; // load the address from the GOT. This generates the pattern (PseudoLGA; // sym), which expands to (ld (addi (auipc %got_pcrel_hi(sym)); // %pcrel_lo(auipc))).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp:33,access,access,33,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVInstructionSelector.cpp,1,['access'],['access']
Security,"// Use PC-relative addressing to access the symbol. This generates the; // pattern (PseudoLLA sym), which expands to (addi (auipc %pcrel_hi(sym)); // %pcrel_lo(auipc)).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:33,access,access,33,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['access'],['access']
Security,// Use SIMD parallelism to hash up to MAX_SIMD_DEGREE chunks at the same time; // on a single thread. Write out the chunk chaining values and return the; // number of chunks hashed. These chunks are never the root and never empty;; // those cases use a different codepath.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c:27,hash,hash,27,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,2,['hash'],"['hash', 'hashed']"
Security,"// Use SIMD parallelism to hash up to MAX_SIMD_DEGREE parents at the same time; // on a single thread. Write out the parent chaining values and return the; // number of parents hashed. (If there's an odd input chaining value left over,; // return it as an additional output.) These parents are never the root and; // never empty; those cases use a different codepath.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c:27,hash,hash,27,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,2,['hash'],"['hash', 'hashed']"
Security,"// Use SP or FP, whichever gives us the best chance of the offset; // being in range for direct access. If the FPOffset is positive,; // that'll always be best, as the SP will be even further away.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:96,access,access,96,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['access'],['access']
Security,// Use Working as the hash directly if we never used MD5.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp:22,hash,hash,22,interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,1,['hash'],['hash']
Security,// Use a PC-relative addressing mode to access the dynamic GOT address.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:40,access,access,40,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,1,['access'],['access']
Security,"// Use a PC-relative addressing mode to access the global dynamic GOT address.; // This generates the pattern (PseudoLA_TLSDESC sym), which expands to; //; // auipc tX, %tlsdesc_hi(symbol) // R_RISCV_TLSDESC_HI20(symbol); // lw tY, tX, %tlsdesc_lo_load(label) // R_RISCV_TLSDESC_LOAD_LO12_I(label); // addi a0, tX, %tlsdesc_lo_add(label) // R_RISCV_TLSDESC_ADD_LO12_I(label); // jalr t0, tY // R_RISCV_TLSDESC_CALL(label)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:40,access,access,40,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['access'],['access']
Security,"// Use a PC-relative addressing mode to access the global dynamic GOT address.; // This generates the pattern (PseudoLA_TLS_GD sym), which expands to; // (addi (auipc %tls_gd_pcrel_hi(sym)) %pcrel_lo(auipc)).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:40,access,access,40,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['access'],['access']
Security,// Use a hash table for many successors to keep this linear.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:9,hash,hash,9,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,1,['hash'],['hash']
Security,"// Use cantFail(), because p_offset/p_filesz fields of a PT_DYNAMIC are; // validated in findDynamic() and so createDRI() is not expected to fail.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp:76,validat,validated,76,interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,1,['validat'],['validated']
Security,// Use explicit storage to avoid accessing cl::opt in a signal handler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Signals.cpp:33,access,accessing,33,interpreter/llvm-project/llvm/lib/Support/Signals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Signals.cpp,1,['access'],['accessing']
Security,// Use reset because std::make_unique can't access the constructor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:44,access,access,44,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp,2,['access'],['access']
Security,// Use simple DJB2 hash,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.h:19,hash,hash,19,interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.h,1,['hash'],['hash']
Security,"// Use the Object stack for WebAssembly locals which can only be accessed; // by name, not via an address in linear memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp:65,access,accessed,65,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp,1,['access'],['accessed']
Security,"// Use the above access group metadata to create loop level; // metadata, which should be distinct for each loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:17,access,access,17,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['access'],['access']
Security,// Use the cached hash value for insertion instead of recalculating it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp:18,hash,hash,18,interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp,1,['hash'],['hash']
Security,"// Use the first #line directive for this, if any. It's preprocessed, so; // there is no checksum, and of course no source directive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:89,checksum,checksum,89,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,2,['checksum'],['checksum']
Security,"// Use the latest hash version when inserting instrumentation, but use the; // version in the indexed profile if we're reading PGO data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp:18,hash,hash,18,interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,1,['hash'],['hash']
Security,// Use the lexical access specifier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:19,access,access,19,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['access'],['access']
Security,"// Use the precise location size specified by the 3rd argument; // for determining KillingI overwrites DeadLoc if it is a memset_chk; // instruction. memset_chk will write either the amount specified as 3rd; // argument or the function will immediately abort and exit the program.; // NOTE: AA may determine NoAlias if it can prove that the access size; // is larger than the allocation size due to that being UB. To avoid; // returning potentially invalid NoAlias results by AA, limit the use of; // the precise location size to isOverwrite.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:341,access,access,341,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,1,['access'],['access']
Security,// Use this for ODR checking functions between modules. This method compares; // more information than the AddDecl class. SkipBody will process the; // hash as if the function has no body.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ODRHash.h:152,hash,hash,152,interpreter/llvm-project/clang/include/clang/AST/ODRHash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ODRHash.h,1,['hash'],['hash']
Security,// Used for pseudo-indexing an array of type records. An array of such records; // sorted by TypeIndex can allow log(N) lookups even though such a type record; // stream does not provide random access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeIndex.h:194,access,access,194,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeIndex.h,1,['access'],['access']
Security,"// Used to access filesystem interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/netxng/inc/TNetXNGFileStager.h:11,access,access,11,net/netxng/inc/TNetXNGFileStager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/netxng/inc/TNetXNGFileStager.h,1,['access'],['access']
Security,"// Used to test the dependence analyzer.; // Looks through the function, noting instructions that may access memory.; // Calls depends() on every possible pair and prints out the result.; // Ignores all other instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:102,access,access,102,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['access'],['access']
Security,// Useful for accessing the imported attribute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:14,access,accessing,14,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['access'],['accessing']
Security,"// User access control",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:8,access,access,8,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['access'],['access']
Security,"// User access to force deletion of the object. Needed in case of a true; // garbage collector (like in PyPy), to allow the user control over when; // the C++ destructor is called. This method requires that the C++ object; // is owned (no-op otherwise).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx:8,access,access,8,bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx,1,['access'],['access']
Security,"// Using Inspect to make a copy won't compile; // auto copy_inner = res.Inspect();; // This will compile, but we only have read-only access",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/test/base_exception.cxx:133,access,access,133,core/foundation/v7/test/base_exception.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/test/base_exception.cxx,1,['access'],['access']
Security,"// Using declarations cannot inject special members; do not call them; // as such. This might happen by using `Base(Base&, int = 12)`, which; // is fine to be called as `Derived d(someBase, 42)` but not as; // copy constructor of `Derived`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallFunc.cxx:29,inject,inject,29,core/metacling/src/TClingCallFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallFunc.cxx,1,['inject'],['inject']
Security,"// Using the properties listed at the following web page (accessed 06/21/08):; // http://www.numbertheory.org/php/euclid.html; // (especially the properties numbered 3, 4 and 9) it can be proved that; // BitWidth bits suffice for all the computations in the algorithm implemented; // below. More precisely, this number of bits suffice if the multiplicative; // inverse exists, but may not suffice for the general extended Euclidean; // algorithm.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:58,access,accessed,58,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['access'],['accessed']
Security,"// UsrPwd Authentication",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:10,Authenticat,Authentication,10,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['Authenticat'],['Authentication']
Security,"// Usually the thunk uses the access specifier of the new method, but if this; // is a covariant return thunk, then MSVC always uses the public access; // specifier, and we do the same.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp:30,access,access,30,interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/MicrosoftMangle.cpp,2,['access'],['access']
Security,"// Utility functions for unified ivar access. These need to; // eventually be folded into other places (the structure layout; // code).; /// Compute an offset to the given ivar, suitable for passing to; /// EmitValueForIvarAtOffset. Note that the correct handling of; /// bit-fields is carefully coordinated by these two, use caution!; ///; /// The latter overload is suitable for computing the offset of a; /// sythesized ivar.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h:38,access,access,38,interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h,1,['access'],['access']
Security,// VAARG needs to be lowered to access with 8 bytes alignment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:32,access,access,32,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,1,['access'],['access']
Security,// VAARG needs to be lowered to not do unaligned accesses for doubles.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:49,access,accesses,49,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,1,['access'],['accesses']
Security,// VALU access to any SGPR or literal constant other than HazardReg; // mitigates hazard. No need to check HazardReg here as this will; // only be called when !IsHazardFn.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:8,access,access,8,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['access'],['access']
Security,"// VE uses identical register name for all registers like both; // F32 and I32 uses ""%s23"". Need to convert the name of them; // for validation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/AsmParser/VEAsmParser.cpp:133,validat,validation,133,interpreter/llvm-project/llvm/lib/Target/VE/AsmParser/VEAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/AsmParser/VEAsmParser.cpp,1,['validat'],['validation']
Security,// Valid input and still have strings in this hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFAcceleratorTable.cpp:46,hash,hash,46,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFAcceleratorTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFAcceleratorTable.cpp,1,['hash'],['hash']
Security,// Validate & create a 12-bit signed immediate operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,2,['Validat'],['Validate']
Security,// Validate & create a 12-bit unsigned immediate operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,1,['Validat'],['Validate']
Security,// Validate & create a 16-bit signed immediate operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,1,['Validat'],['Validate']
Security,// Validate & create a 5-bit unsigned immediate operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['Validat'],['Validate']
Security,// Validate & create an integer zero operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,2,['Validat'],['Validate']
Security,// Validate -add-plugin args.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,1,['Validat'],['Validate']
Security,// Validate @llvm.global_dtor's type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp,1,['Validat'],['Validate']
Security,// Validate CHPE metadata,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/COFFObjectFile.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Object/COFFObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/COFFObjectFile.cpp,1,['Validat'],['Validate']
Security,// Validate DebugProgramMarkers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,1,['Validat'],['Validate']
Security,// Validate DebugProgramValues.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,1,['Validat'],['Validate']
Security,// Validate EC symbol table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/Archive.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Object/Archive.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/Archive.cpp,1,['Validat'],['Validate']
Security,// Validate GUID length.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['Validat'],['Validate']
Security,// Validate OP_SEL has to be set to all 0 and OP_SEL_HI has to be set to; // all 1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNDPPCombine.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNDPPCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNDPPCombine.cpp,1,['Validat'],['Validate']
Security,"// Validate PAC, It should have been already popped into R12. For CMSE entry; // function, the validation instruction is emitted during expansion of the; // tBXNS_RET, since the validation must use the value of SP at function; // entry, before saving, resp. after restoring, FPCXTNS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,3,"['Validat', 'validat']","['Validate', 'validation']"
Security,"// Validate `Range`, because `makeFileCharRange` accepts some ranges that; // `validateRange` rejects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,2,"['Validat', 'validat']","['Validate', 'validateRange']"
Security,"// Validate a cpu_dispatch/cpu_specific CPU option, which is a different list; // from cpu_is, since it checks via features rather than CPUs directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:3,Validat,Validate,3,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['Validat'],['Validate']
Security,// Validate an integral value which isn't known to fit within the enum's range; // is a valid AtomicOrdering.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/AtomicOrdering.h:3,Validat,Validate,3,interpreter/llvm-project/llvm/include/llvm/Support/AtomicOrdering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/AtomicOrdering.h,1,['Validat'],['Validate']
Security,// Validate an integral value which isn't known to fit within the enum's range; // is a valid AtomicOrderingCABI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/AtomicOrdering.h:3,Validat,Validate,3,interpreter/llvm-project/llvm/include/llvm/Support/AtomicOrdering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/AtomicOrdering.h,1,['Validat'],['Validate']
Security,// Validate and finalize AltiVec vector declspec.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,1,['Validat'],['Validate']
Security,// Validate and pass through -ffp-contract option.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['Validat'],['Validate']
Security,// Validate and pass through -ffp-eval-method option.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['Validat'],['Validate']
Security,// Validate and pass through -ffp-exception-behavior option.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['Validat'],['Validate']
Security,// Validate and pass through -ffp-model option.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['Validat'],['Validate']
Security,// Validate constants ...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['Validat'],['Validate']
Security,"// Validate constraint #2: Does this block contains only the call to; // free, noops, and an unconditional branch?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['Validat'],['Validate']
Security,// Validate constraint #3: Ensure the null case just falls through.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['Validat'],['Validate']
Security,// Validate constraints and modifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,1,['Validat'],['Validate']
Security,"// Validate context-sensitive operand constraints.; // return 'true' if register list contains non-low GPR registers,; // 'false' otherwise. If Reg is in the register list or is HiReg, set; // 'containsReg' to true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['Validat'],['Validate']
Security,// Validate declspec for type-name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['Validat'],['Validate']
Security,"// Validate function argument and return types, extracting overloaded types; // along the way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,1,['Validat'],['Validate']
Security,"// Validate function argument and return types, extracting overloaded; // types along the way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUImageIntrinsicOptimizer.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUImageIntrinsicOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUImageIntrinsicOptimizer.cpp,1,['Validat'],['Validate']
Security,// Validate functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVObject.h:3,Validat,Validate,3,interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/LogicalView/Core/LVObject.h,1,['Validat'],['Validate']
Security,"// Validate input",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManager.cxx:3,Validat,Validate,3,proof/proof/src/TDataSetManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManager.cxx,1,['Validat'],['Validate']
Security,// Validate input Dag operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp,1,['Validat'],['Validate']
Security,// Validate input files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['Validat'],['Validate']
Security,// Validate input profile is provided only once,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/llvm-profgen.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/tools/llvm-profgen/llvm-profgen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/llvm-profgen.cpp,1,['Validat'],['Validate']
Security,"// Validate inputs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLog.cxx:3,Validat,Validate,3,proof/proof/src/TProofLog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLog.cxx,1,['Validat'],['Validate']
Security,// Validate options for HLSL,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['Validat'],['Validate']
Security,// Validate output Dag operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp,1,['Validat'],['Validate']
Security,"// Validate part of constraint #1: Only one predecessor; // FIXME: We can extend the number of predecessor, but in that case, we; // would duplicate the call to free in each predecessor and it may; // not be profitable even for code size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['Validat'],['Validate']
Security,// Validate ranges associated with locations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVScope.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVScope.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVScope.cpp,1,['Validat'],['Validate']
Security,// Validate ranges associated with scopes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVScope.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVScope.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVScope.cpp,1,['Validat'],['Validate']
Security,"// Validate redecl chain by iterating through it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp:3,Validat,Validate,3,interpreter/cling/lib/Interpreter/DeclUnloader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp,1,['Validat'],['Validate']
Security,// Validate signature.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,1,['Validat'],['Validate']
Security,"// Validate spectator; // fSpectatorIdx = GetSpectatorIndexForName(dsi, fSpectatorName);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/CvSplit.cxx:3,Validat,Validate,3,tmva/tmva/src/CvSplit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/CvSplit.cxx,1,['Validat'],['Validate']
Security,// Validate subprogram address range.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DependencyTracker.cpp,1,['Validat'],['Validate']
Security,// Validate that Dag operand type matches the type defined in the; // corresponding instruction. Operands in the input Dag pattern are; // allowed to be a subclass of the type specified in corresponding; // instruction operand instead of being an exact match.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp,1,['Validat'],['Validate']
Security,// Validate that SPE and FPU are mutually exclusive in codegen,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp,1,['Validat'],['Validate']
Security,"// Validate that X, Y, and Mask are bitcasts, and see through them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Validat'],['Validate']
Security,// Validate that all indices in Mask are within the range of the elements; // input to the shuffle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['Validat'],['Validate']
Security,// Validate that corresponding instruction operand expects an immediate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CompressInstEmitter.cpp,1,['Validat'],['Validate']
Security,// Validate that feature macros are set properly for OpenCL C 3.0.; // In other cases assume that target is always valid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Basic/Targets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets.cpp,1,['Validat'],['Validate']
Security,"// Validate that none of the argument registers have been marked as; // reserved, if so report an error. Do the same for the return address if this; // is not a tailcall.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['Validat'],['Validate']
Security,"// Validate that the LHS is allowed to be a variable (either it has not been; // used as a symbol, or it is an absolute symbol).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,1,['Validat'],['Validate']
Security,// Validate that the VTableFuncs list is ordered by offset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ModuleSummaryAnalysis.cpp,1,['Validat'],['Validate']
Security,// Validate that the address in the annotation is a multiple of the; // platform's page size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp,1,['Validat'],['Validate']
Security,// Validate that the annotation is a multiple of the platform's page; // size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp,1,['Validat'],['Validate']
Security,"// Validate that the current preprocessing control stack is empty,; // since we are about to exit a file, and pop the include stack.; //; // If IncludeStackMustBeEmpty is true, the include stack must be empty; // after the popping, otherwise, the include stack must not be empty; // after the popping. Basically, the include stack must be empty; // only if we exit the ""top-level"" file (i.e. finish lexing).; //; // The method returns false, if the current preprocessing control stack; // is not empty (e.g. there is an unterminated #ifdef/#else),; // true - otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h,1,['Validat'],['Validate']
Security,// Validate that the input pattern is correct.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,1,['Validat'],['Validate']
Security,// Validate that the requirements in the module are valid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['Validat'],['Validate']
Security,// Validate that the result pattern has the corrent number and types; // of arguments for the instruction it references.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/PseudoLoweringEmitter.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/utils/TableGen/PseudoLoweringEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/PseudoLoweringEmitter.cpp,1,['Validat'],['Validate']
Security,// Validate that the user supplied a valid component name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,1,['Validat'],['Validate']
Security,// Validate that we can get the buffer data without a fatal error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnalyzer.cpp,1,['Validat'],['Validate']
Security,// Validate the AST as soon as we have a name so we can exit early on; // failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['Validat'],['Validate']
Security,"// Validate the AST before processing any imports (otherwise, untangling; // them can be error-prone and expensive). A module will have a name and; // will already have been validated, but this catches the PCH case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,2,"['Validat', 'validat']","['Validate', 'validated']"
Security,// Validate the CFG.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,1,['Validat'],['Validate']
Security,"// Validate the JSON IO for a given RooAbsReal in a RooWorkspace. The workspace; // will be written out and read back, and then the values of the old and new; // RooAbsReal will be compared for equality in each bin of the observable that; // is called ""x"" by convention.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/test/testRooFitHS3.cxx:3,Validat,Validate,3,roofit/hs3/test/testRooFitHS3.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/test/testRooFitHS3.cxx,1,['Validat'],['Validate']
Security,// Validate the SYSm value first.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,1,['Validat'],['Validate']
Security,// Validate the alias definitions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,1,['Validat'],['Validate']
Security,// Validate the always/never attribute files. We also make sure that they; // are treated as actual dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/XRayArgs.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Driver/XRayArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/XRayArgs.cpp,1,['Validat'],['Validate']
Security,"// Validate the argument list, converting it to set, to discard duplicates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,1,['Validat'],['Validate']
Security,// Validate the argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,1,['Validat'],['Validate']
Security,"// Validate the asm string, ensuring it makes sense given the operands we; // have.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,1,['Validat'],['Validate']
Security,// Validate the attributes on the @property.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,1,['Validat'],['Validate']
Security,// Validate the call type matches the expected libfunc type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibFunc.h:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibFunc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibFunc.h,1,['Validat'],['Validate']
Security,// Validate the command line input.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/llvm-profgen.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/tools/llvm-profgen/llvm-profgen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/llvm-profgen.cpp,1,['Validat'],['Validate']
Security,// Validate the contents of the __builtin_cpu_is(const char*); // argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:3,Validat,Validate,3,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['Validat'],['Validate']
Security,// Validate the contents of the __builtin_cpu_supports(const char*); // argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:3,Validat,Validate,3,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['Validat'],['Validate']
Security,"// Validate the context, now we have a lookup",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['Validat'],['Validate']
Security,// Validate the directive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmStreamer.cpp,2,['Validat'],['Validate']
Security,"// Validate the generated code, checking for consistency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,17,['Validat'],['Validate']
Security,// Validate the image format.; //; // Load the image starts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/MachOObjectFile.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Object/MachOObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/MachOObjectFile.cpp,1,['Validat'],['Validate']
Security,// Validate the input,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['Validat'],['Validate']
Security,// Validate the length of the coverage mapping for this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMappingReader.cpp,1,['Validat'],['Validate']
Security,// Validate the module before returning. This call catches an AST with; // no module name and no imports.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['Validat'],['Validate']
Security,// Validate the number and convert it to an unsigned.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['Validat'],['Validate']
Security,// Validate the number and convert it to an unsigned. GNU does not have a; // line # limit other than it fit in 32-bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['Validat'],['Validate']
Security,// Validate the operands of the instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PHITransAddr.cpp,1,['Validat'],['Validate']
Security,// Validate the option here; we don't save the type here because its; // particular spelling may participate in other driver choices.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['Validat'],['Validate']
Security,"// Validate the original range to attempt to get a meaningful error; // message. If it's valid, then something else is the cause and we just; // return the generic failure message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/Stencil.cpp,1,['Validat'],['Validate']
Security,// Validate the ranges associated with the location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVLocation.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVLocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVLocation.cpp,1,['Validat'],['Validate']
Security,// Validate the relocation kind.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_x86_64.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_x86_64.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_x86_64.cpp,3,['Validat'],['Validate']
Security,// Validate the relocation type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOARM.h,1,['Validat'],['Validate']
Security,// Validate the rest of constraint #1 by matching on the pred branch.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['Validat'],['Validate']
Security,"// Validate the results",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/test/testParamHistFunc.cxx:3,Validat,Validate,3,roofit/histfactory/test/testParamHistFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/test/testParamHistFunc.cxx,2,['Validat'],['Validate']
Security,// Validate the scale amount.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,1,['Validat'],['Validate']
Security,// Validate the section to read relocation entries from.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_i386.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_i386.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/ELF_i386.cpp,3,['Validat'],['Validate']
Security,"// Validate the selected reductions. All iterations must have an isomorphic; // part of the reduction chain and, for non-associative reductions, the chain; // entries must appear in order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,1,['Validat'],['Validate']
Security,// Validate the type matches unless this builtin is specified as; // matching regardless of its declared type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Validat'],['Validate']
Security,// Validate the width of the type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,1,['Validat'],['Validate']
Security,// Validate tied input operands for type mismatches.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAsm.cpp,1,['Validat'],['Validate']
Security,"// Validate values for this element",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TEventIter.cxx:3,Validat,Validate,3,proof/proofplayer/src/TEventIter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TEventIter.cxx,4,['Validat'],['Validate']
Security,// Validate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['Validat'],['Validate']
Security,// Validate/process some options.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:3,Validat,Validate,3,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['Validat'],['Validate']
Security,"// Validate:; // 1. Packet does not have a store in it.; // 2. If the first operand of the nvj is newified, and the second; // operand is also a reg, it (second reg) is not defined in; // the same packet.; // 3. If the second operand of the nvj is newified, (which means; // first operand is also a reg), first reg is not defined in; // the same packet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:3,Validat,Validate,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['Validat'],['Validate']
Security,"// Validated RooSimWSTool build configuration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooSimWSTool.h:3,Validat,Validated,3,roofit/roofitcore/inc/RooSimWSTool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooSimWSTool.h,1,['Validat'],['Validated']
Security,"// Validated RooSimWSTool split rule",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooSimWSTool.h:3,Validat,Validated,3,roofit/roofitcore/inc/RooSimWSTool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooSimWSTool.h,1,['Validat'],['Validated']
Security,// Validated by static_assert in APValue.cpp; hardcoded to avoid needing; // to include Type.h.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/APValue.h:3,Validat,Validated,3,interpreter/llvm-project/clang/include/clang/AST/APValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/APValue.h,1,['Validat'],['Validated']
Security,// Validates if the given combination of features are valid for the target; // triple. Exits with report_fatal_error if not.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h:3,Validat,Validates,3,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h,1,['Validat'],['Validates']
Security,"// Validates the access qualifier is compatible with the call.; // OpenCL v2.0 s6.13.16 - The access qualifiers for pipe should only be; // read_only and write_only, and assumed to be read_only if no qualifier is; // specified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:3,Validat,Validates,3,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,3,"['Validat', 'access']","['Validates', 'access']"
Security,// Validating the node operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:3,Validat,Validating,3,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,1,['Validat'],['Validating']
Security,// Validation Counters,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/ExegesisEmitter.cpp:3,Validat,Validation,3,interpreter/llvm-project/llvm/utils/TableGen/ExegesisEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/ExegesisEmitter.cpp,1,['Validat'],['Validation']
Security,// Validation check,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp:3,Validat,Validation,3,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyCFGStackify.cpp,3,['Validat'],['Validation']
Security,// Validation check for the other arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp:3,Validat,Validation,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,1,['Validat'],['Validation']
Security,// Validation check on the instruction descriptor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp:3,Validat,Validation,3,interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/InstrBuilder.cpp,1,['Validat'],['Validation']
Security,// Validation checks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600OpenCLImageTypeLoweringPass.cpp:3,Validat,Validation,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600OpenCLImageTypeLoweringPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600OpenCLImageTypeLoweringPass.cpp,1,['Validat'],['Validation']
Security,// Validation is in Sema::ActOnAttributedStmt().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp:3,Validat,Validation,3,interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmtAttr.cpp,1,['Validat'],['Validation']
Security,// Validation methods - to check if any element results in undefined behavior,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/FormatString.h:3,Validat,Validation,3,interpreter/llvm-project/clang/include/clang/AST/FormatString.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/FormatString.h,1,['Validat'],['Validation']
Security,// Validation strictness depends on whether message is specified; // in a symbolic or in a numeric form. In the latter case; // only encoding possibility is checked.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:3,Validat,Validation,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,1,['Validat'],['Validation']
Security,"// Validation was handled during parsing, so we just verify that; // something didn't go haywire.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:3,Validat,Validation,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,2,['Validat'],['Validation']
Security,// Validator should check whether or not MMOs cover the entire set of; // locations accessed by the memory instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp:3,Validat,Validator,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,2,"['Validat', 'access']","['Validator', 'accessed']"
Security,"// Value validation; // ----------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx:9,validat,validation,9,tmva/pymva/src/MethodPyKeras.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx,4,['validat'],['validation']
Security,// Values depend on loads if the pointers are must aliased. This means; // that a load depends on another must aliased load from the same value.; // One exception is atomic loads: a value can depend on an atomic load that; // it does not alias with when this atomic load indicates that another; // thread may be accessing the location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:312,access,accessing,312,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['access'],['accessing']
Security,// Vectorization for masked interleaved accesses is only enabled for scalable; // VF.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:40,access,accesses,40,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['access'],['accesses']
Security,// Vectors >= 16 bytes expose the ABI through alignment requirements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/SystemZ.cpp:23,expose,expose,23,interpreter/llvm-project/clang/lib/CodeGen/Targets/SystemZ.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/SystemZ.cpp,1,['expose'],['expose']
Security,// Verify integrity of BECountUsers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:10,integrity,integrity,10,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['integrity'],['integrity']
Security,// Verify integrity of SCEV users.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:10,integrity,integrity,10,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['integrity'],['integrity']
Security,// Verify integrity of ValuesAtScopes users.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:10,integrity,integrity,10,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['integrity'],['integrity']
Security,// Verify integrity of the block disposition cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:10,integrity,integrity,10,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['integrity'],['integrity']
Security,// Verify that all buckets have a valid hash index or are empty.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp:40,hash,hash,40,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,1,['hash'],['hash']
Security,"// Verify that fitting an empty RooDataSet or a RooDataHist with only empty; // bins does not do anything to the parameters. The point of this test is to; // validate that the new CPU backend behaves the same as the legacy evaluation; // backend for empty data objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testTestStatistics.cxx:158,validat,validate,158,roofit/roofitcore/test/testTestStatistics.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testTestStatistics.cxx,1,['validat'],['validate']
Security,// Verify that the first bit starts at a multiple of mask so that the access; // is aligned the same as the access width.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:70,access,access,70,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['access'],['access']
Security,"// Verify that the range covers exactly the name.; // FIXME: extend this code to support cases like `operator +` or; // `foo<int>` for which this range will be too short. Doing so will; // require subcasing `NamedDecl`, because it doesn't provide virtual; // access to the \c DeclarationNameInfo.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp:259,access,access,259,interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RangeSelector.cpp,1,['access'],['access']
Security,// Verify that this is a stack access.; // FIXME: Should probably use stack pseudos before frame lowering.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp:31,access,access,31,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,1,['access'],['access']
Security,"// Verilog uses the backtick instead of the hash for preprocessor stuff.; // And it uses the hash for delays and parameter lists. In order to continue; // using `tok::hash` in other places, the backtick gets marked as the hash; // here. And in order to tell the backtick and hash apart for; // Verilog-specific stuff, the hash becomes an identifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp:44,hash,hash,44,interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatTokenLexer.cpp,6,['hash'],['hash']
Security,// Visit the IR stream and instrument all select instructions. \p; // Ind is a pointer to the counter index variable; \p TotalNC; // is the total number of counters; \p FNV is the pointer to the; // PGO function name var; \p FHash is the function hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:247,hash,hash,247,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,1,['hash'],['hash']
Security,// Volatile operations may access inaccessible memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:27,access,access,27,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,1,['access'],['access']
Security,// Volatility stops an access from being decomposed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:23,access,access,23,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,1,['access'],['access']
Security,"// Walk all the blocks, comparing what the lookups think and what the access; // lists think, as well as the order in the blocks vs the order in the access; // lists.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:70,access,access,70,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,2,['access'],['access']
Security,"// Walk the Record's BranchRegions (representing Conditions) in order to:; // - Hash the condition based on its corresponding ID. This will be used to; // calculate the test vectors.; // - Keep a map of the condition's ordinal position (1, 2, 3, 4) to its; // actual ID. This will be used to visualize the conditions in the; // correct order.; // - Keep track of the condition source location. This will be used to; // visualize where the condition is.; // - Record whether the condition is constant folded so that we exclude it; // from being measured.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp:80,Hash,Hash,80,interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/Coverage/CoverageMapping.cpp,1,['Hash'],['Hash']
Security,"// Walk the blocks in the same order as; // FunctionComparator::cmpBasicBlocks(), accumulating the hash of the; // function ""structure."" (BB and opcode sequence)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp:99,hash,hash,99,interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/StructuralHash.cpp,1,['hash'],['hash']
Security,// Warn about access declarations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:14,access,access,14,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['access'],['access']
Security,// Warn about incompatible groups of sanitizers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:37,sanitiz,sanitizers,37,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['sanitiz'],['sanitizers']
Security,// Warn for unions passing across security boundary (CMSE).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:34,secur,security,34,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['secur'],['security']
Security,"// Warn when a non-static method call is followed by non-static member; // field accesses, which is followed by a DeclRefExpr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:81,access,accesses,81,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['access'],['accesses']
Security,"// We allow accessing the edges by dereferencing or using the arrow; // operator, essentially wrapping the internal optional.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:12,access,accessing,12,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,1,['access'],['accessing']
Security,"// We allow vectorization of flat stores, even though we may need to decompose; // them later if they may access private memory. We don't have enough context; // here, and legalization can handle it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp:106,access,access,106,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,2,['access'],['access']
Security,"// We append ""a"" and then the next hashed text.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:35,hash,hashed,35,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['hash'],['hashed']
Security,// We append a semi-unique hash and the priority to the global name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp:27,hash,hash,27,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXCtorDtorLowering.cpp,1,['hash'],['hash']
Security,"// We append the hashed text.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:17,hash,hashed,17,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['hash'],['hashed']
Security,"// We apply heuristics only to CCC_Symbol:; // * CCC_{Arrow,Dot}MemberAccess reflect member access expressions:; // f.method() and f->method(). These are always calls.; // * A qualified name to a member function may *not* be a call. We have to; // subdivide the cases: For example, f.Base::method(), which is regarded as; // CCC_Symbol, should be a call.; // * Non-member functions and static member functions are always considered; // calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:92,access,access,92,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['access'],['access']
Security,"// We are likely to change the hash value of this object; // with TNamed::Copy, to keep things correct, we need to; // clean up its existing entries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:31,hash,hash,31,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['hash'],['hash']
Security,"// We are now this def's defining access, make sure we actually dominate; // it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:34,access,access,34,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['access'],['access']
Security,"// We are potentially transforming byte-sized (8-bit) memory accesses, so make; // sure we have all of our type-based constraints in place for this target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:61,access,accesses,61,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['access'],['accesses']
Security,"// We are trying to expose opportunity for reassociation. One of the things; // that we want to do to achieve this is to push a negation as deep into an; // expression chain as possible, to expose the add instructions. In practice,; // this means that we turn this:; // X = -(A+12+C+D) into X = -A + -12 + -C + -D = -12 + -A + -C + -D; // so that later, a: Y = 12+X could get reassociated with the -12 to eliminate; // the constants. We assume that instcombine will clean up the mess later if; // we introduce tons of unnecessary negation instructions.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:20,expose,expose,20,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,2,['expose'],['expose']
Security,// We assign a consecutive id to access from different alias sets.; // Accesses between different groups doesn't need to be checked.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:33,access,access,33,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,2,"['Access', 'access']","['Accesses', 'access']"
Security,// We assign consecutive id to access from different dependence sets.; // Accesses within the same set don't need a runtime check.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:31,access,access,31,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,2,"['Access', 'access']","['Accesses', 'access']"
Security,// We avoid copy constructors by not using accessors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h:43,access,accessors,43,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h,1,['access'],['accessors']
Security,"// We cached PHINodes in PHIs. To avoid accessing deleted PHINodes later,; // do not delete PHINodes here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:40,access,accessing,40,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['access'],['accessing']
Security,// We can define most of the accessors automatically:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h:29,access,accessors,29,interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h,1,['access'],['accessors']
Security,"// We can devirtualize calls on an object accessed by a class member access; // expression, since by C++11 [basic.life]p6 we know that it can't refer to; // a derived class object constructed in the same location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:42,access,accessed,42,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,2,['access'],"['access', 'accessed']"
Security,// We can forward past any lifetime start/end that can be proven not to; // alias the memory access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:93,access,access,93,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['access'],['access']
Security,"// We can never access structs with object members with a native; // access, because we need to use write barriers. This is what; // objc_copyStruct is for.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:16,access,access,16,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,2,['access'],['access']
Security,"// We can not use 'cd' as this would access the current thread; // rather than the thread corresponding to that gDirectory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TDirectory.cxx:37,access,access,37,core/base/src/TDirectory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TDirectory.cxx,1,['access'],['access']
Security,"// We can optimistically ignore calls to functions in the same SCC, with; // two caveats:; // * Calls with operand bundles may have additional effects.; // * Argument memory accesses may imply additional effects depending on; // what the argument location is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:174,access,accesses,174,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,1,['access'],['accesses']
Security,"// We can't post-increment the stack pointer if any instruction between; // the memory access (I) and the increment (MBBI) can access the memory; // region defined by [SP, MBBI].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp:87,access,access,87,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,2,['access'],['access']
Security,// We can't tell here whether the index vector has the right type; // for the access; the caller needs to do that instead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:78,access,access,78,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,1,['access'],['access']
Security,"// We can't trivially replace the alias with the aliasee if the aliasee is; // non-trivial in some way. We also can't replace the alias with the aliasee; // if the aliasee may be preemptible at runtime. On ELF, a non-preemptible; // alias can be used to access the definition as if preemption did not; // happen.; // TODO: Try to handle non-zero GEPs of local aliasees.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:254,access,access,254,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['access'],['access']
Security,// We can't use a generic validation scheme for the cpus accepted here; // versus subtarget cpus accepted in the target attribute because the; // variables intitialized by the runtime only support the below currently; // rather than the full range of cpus.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:26,validat,validation,26,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,1,['validat'],['validation']
Security,// We can't use a generic validation scheme for the features accepted here; // versus subtarget features accepted in the target attribute because the; // bitfield structure that's initialized in the runtime only supports the; // below currently rather than the full range of subtarget features. (See; // X86TargetInfo::hasFeature for a somewhat comprehensive list).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp:26,validat,validation,26,interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/X86.cpp,1,['validat'],['validation']
Security,"// We can't use an addressing mode in the 64-bit large code model.; // Global TLS addressing is an exception. In the medium code model,; // we use can use a mode when RIP wrappers are present.; // That signifies access to globals that are known to be ""near"",; // such as the GOT itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:212,access,access,212,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['access'],['access']
Security,"// We cannot let the higher word of DefaultStyle be equal to 0xFFFF.; // In such a case, whole object (in .res file) is equivalent to a; // DIALOGEX. It might lead to access violation/segmentation fault in; // resource readers. For example,; // 1 DIALOG 0, 0, 0, 65432; // STYLE 0xFFFF0001 {}; // would be compiled to a DIALOGEX with 65432 controls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.cpp:167,access,access,167,interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.cpp,1,['access'],['access']
Security,"// We cannot mitigate far jumps or calls, but we also don't expect them; // to be vulnerable to Spectre v1.2 or v2 (self trained) style attacks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:136,attack,attacks,136,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['attack'],['attacks']
Security,"// We cannot mitigate far jumps or calls, but we also don't expect them; // to be vulnerable to Spectre v1.2 style attacks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:115,attack,attacks,115,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['attack'],['attacks']
Security,// We cannot use std::make_unique because we cannot access the private; // constructor from inside it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h:52,access,access,52,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporter.h,1,['access'],['access']
Security,"// We check earlier that we are within the authorized range, but; // we might still be out of the (default) learning range and since; // this is called before any branch is added to the cache, this means; // that the user's first GetEntry is this one which is outside of the; // learning range ... so let's do something sensible-ish.; // Note: we probably should also fix the learning range but we may; // or may not have enough information to know if we can move it; // (for example fEntryMin (eminOld right now) might be the default or user provided)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:43,authoriz,authorized,43,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['authoriz'],['authorized']
Security,// We collect the data from all statements in the sequence as we did before; // when generating a hash value for each sequence. But this time we don't; // hash the collected data and compare the whole data set instead. This; // prevents any false-positives due to hash code collisions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:98,hash,hash,98,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,3,['hash'],['hash']
Security,// We conservatively assume that mayAccessVMEMThroughFlat(Inst); // and mayAccessLDSThroughFlat(Inst) would both return true for this; // instruction. We have to do this because those functions use; // information about the memory operands that we don't have access to.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCA/AMDGPUCustomBehaviour.cpp:259,access,access,259,interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCA/AMDGPUCustomBehaviour.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCA/AMDGPUCustomBehaviour.cpp,1,['access'],['access']
Security,"// We conservatively set the memory operand of a buffer intrinsic to the; // base resource pointer, so that we can access alias information about; // those pointers. Cases like ""this points at the same value; // but with a different offset"" are handled in; // areMemAccessesTriviallyDisjoint.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:115,access,access,115,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['access'],['access']
Security,"// We continue the authentication process in clear",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:19,authenticat,authentication,19,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['authenticat'],['authentication']
Security,"// We could add the block length, but that would take; // a bit of work and not add a lot of uniqueness; // to the hash in some way we could test.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:115,hash,hash,115,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,1,['hash'],['hash']
Security,"// We could explicitly handle all the types of the MachineOperand,; // here but we can just return a common number until we find a; // compelling test case where this is bad. The only side effect here; // is contributing to a hash collision but there's enough information; // (Opcodes,other registers etc) that this will likely not be a problem.; // TODO: Handle the following Index/ID/Predicate cases. They can; // be hashed on in a stable manner.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp:226,hash,hash,226,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.cpp,2,['hash'],"['hash', 'hashed']"
Security,"// We could have a file created using a Foreign class before; // the introduction of the CheckSum. We need to check",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx:89,CheckSum,CheckSum,89,io/io/src/TBufferFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx,3,['CheckSum'],['CheckSum']
Security,"// We could not open the file and we have no authentication information; // so inform the user so that they can check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TS3WebFile.cxx:45,authenticat,authentication,45,net/net/src/TS3WebFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TS3WebFile.cxx,1,['authenticat'],['authentication']
Security,"// We create an access to represent ""live on entry"", for things like; // arguments or users of globals, where the memory they use is defined before; // the beginning of the function. We do not actually insert it into the IR.; // We do not define a live on exit for the immediate uses, and thus our; // semantics do *not* imply that something with no immediate uses can simply; // be removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:16,access,access,16,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['access'],['access']
Security,"// We create data with 100 events at x = 5 and 400 events at x = 15. One; // version will have 500 unweighted entries, the other will have only 2; // entries with the weights 100 and 400 to represent the same data. The; // resulting RooKeysPdfs should be identical for both datasets. Checking; // this validates that dataset weights are correctly dealt with.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooKeysPdf.cxx:302,validat,validates,302,roofit/roofit/test/testRooKeysPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooKeysPdf.cxx,1,['validat'],['validates']
Security,// We created a new clone group with matching hash codes and move it to; // the result vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp:46,hash,hash,46,interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CloneDetection.cpp,1,['hash'],['hash']
Security,// We currently only know how to synthesize property accessors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp:53,access,accessors,53,interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,1,['access'],['accessors']
Security,// We defer the injected-class-name checks until we've found whether; // this template-id is used to form a nested-name-specifier or not.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:16,inject,injected-class-name,16,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['inject'],['injected-class-name']
Security,// We deliberately leave the expression type out of the hash value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVNExpression.h:56,hash,hash,56,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVNExpression.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVNExpression.h,1,['hash'],['hash']
Security,// We did not have a definition in this block before: store the phi's vreg; // as this block downward exposed def.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:102,expose,exposed,102,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,1,['expose'],['exposed']
Security,"// We didn't have access to the comment options when the ASTContext was; // constructed, so register them now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:18,access,access,18,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,1,['access'],['access']
Security,// We disable the vptr sanitizer if it was enabled by group expansion but RTTI; // is disabled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:23,sanitiz,sanitizer,23,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['sanitiz'],['sanitizer']
Security,// We disallow element access for ext_vector_type bool. There is no way to; // materialize a reference to a vector element as a pointer (each element is; // one bit in the vector).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:23,access,access,23,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['access'],['access']
Security,"// We do not have to worry about llvm.assume or range metadata:; // 1. llvm.assume demands its operand, so trivializing can't change it.; // 2. range metadata only applies to memory accesses which demand all bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp:182,access,accesses,182,interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,1,['access'],['accesses']
Security,// We do not implement the 32-bit version of the faster access sequence; // for local-exec that is controlled by -maix-small-local-exec-tls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:56,access,access,56,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['access'],['access']
Security,// We do not produce call enters and call exits for autosynthesized property; // accessors. We do generally produce them for other functions coming from; // the body farm because they may call callbacks that bring us back into; // visible code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp:81,access,accessors,81,interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/PathDiagnostic.cpp,2,['access'],['accessors']
Security,"// We do not use AlignInBits in hashing function here on purpose:; // in most cases this param for local variable is zero (for function param; // it is always zero). This leads to lots of hash collisions and errors on; // cases with lots of similar variables.; // clang/test/CodeGen/debug-info-257-args.c is an example of this problem,; // generated IR is random for each run and test fails with Align included.; // TODO: make hashing work fine with such situations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:32,hash,hashing,32,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,6,['hash'],"['hash', 'hashing']"
Security,// We do our own custom access checks below.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:24,access,access,24,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,2,['access'],['access']
Security,"// We do this custom legalization to convert G_GLOBAL_VALUE into target ADRP +; // G_ADD_LOW instructions.; // By splitting this here, we can optimize accesses in the small code model by; // folding in the G_ADD_LOW into the load/store offset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp:151,access,accesses,151,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp,1,['access'],['accesses']
Security,// We don't care about alignment here since we just emit integer accesses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:65,access,accesses,65,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,1,['access'],['accesses']
Security,"// We don't check wrapping here because we don't know yet if Ptr will be; // part of a full group or a group with gaps. Checking wrapping for all; // pointers (even those that end up in groups with no gaps) will be overly; // conservative. For full groups, wrapping should be ok since if we would; // wrap around the address space we would do a memory access at nullptr; // even without the transformation. The wrapping checks are therefore; // deferred until after we've formed the interleaved groups.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:352,access,access,352,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['access'],['access']
Security,"// We don't have access to labels here, NumLabels will be checked separately.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/InlineAsm.cpp:17,access,access,17,interpreter/llvm-project/llvm/lib/IR/InlineAsm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/InlineAsm.cpp,1,['access'],['access']
Security,// We don't have access to the register scavenger if this function is called; // during PEI::scavengeFrameVirtualRegs() so use LiveUnits in this case.; // TODO: Clobbering SCC is not necessary for scratch instructions in the; // entry.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp:17,access,access,17,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,1,['access'],['access']
Security,"// We don't have access to the signature, so create a symbol without one",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/Disassembler/WebAssemblyDisassembler.cpp:17,access,access,17,interpreter/llvm-project/llvm/lib/Target/WebAssembly/Disassembler/WebAssemblyDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/Disassembler/WebAssemblyDisassembler.cpp,1,['access'],['access']
Security,"// We don't know how long the hash table is until we parse it, so let the; // function responsible for doing that figure it out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBStringTable.cpp:30,hash,hash,30,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBStringTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBStringTable.cpp,1,['hash'],['hash']
Security,"// We don't need the validation version internally, so we drop it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DXILUpgrade.cpp:21,validat,validation,21,interpreter/llvm-project/llvm/lib/Transforms/Utils/DXILUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DXILUpgrade.cpp,1,['validat'],['validation']
Security,"// We don't need this if we only have spills since there is no user facing; // scratch.; // TODO: If we know we don't have flat instructions earlier, we can omit; // this from the input registers.; //; // TODO: We only need to know if we access scratch space through a flat; // pointer. Because we only detect if flat instructions are used at all,; // this will be used more often than necessary on VI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:238,access,access,238,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,1,['access'],['access']
Security,// We don't need to adjust 'packed' to deal with possible tail padding; // because we never do that kind of access through the coercion type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp:108,access,access,108,interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/SwiftCallingConv.cpp,1,['access'],['access']
Security,// We don't need to check non-wrapping here because forward/backward; // dependence wouldn't be valid if these weren't monotonic accesses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:129,access,accesses,129,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,1,['access'],['accesses']
Security,"// We don't use the RooFit::Evaluator for the nominal likelihood. Like this,; // we make sure to validate also the NLL values of the generated code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooFuncWrapper.cxx:97,validat,validate,97,roofit/roofitcore/test/testRooFuncWrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooFuncWrapper.cxx,1,['validat'],['validate']
Security,// We don't validate more complex expressions here,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:12,validat,validate,12,interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,1,['validat'],['validate']
Security,// We don't want access-control diagnostics here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:17,access,access-control,17,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['access'],['access-control']
Security,"// We don't want to bail when we run into the store memory def. But,; // the phi access may point to it. So, pretend like we've already; // checked it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:81,access,access,81,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,1,['access'],['access']
Security,"// We don't want to be too aggressive with the return checking, unless; // it's explicit in the code opts or we're using an appropriate sanitizer.; // Try to respect what the programmer intended.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:136,sanitiz,sanitizer,136,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['sanitiz'],['sanitizer']
Security,// We don't want to check the ODR hash value for declarations from global; // module fragment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:34,hash,hash,34,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['hash'],['hash']
Security,"// We don't want to double prefetch individual cache lines. If this; // access is known to be within one cache line of some other one that; // has already been prefetched, then don't prefetch this one as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp:72,access,access,72,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp,1,['access'],['access']
Security,"// We emit the checksum info for files. This is used by debuggers to; // determine if a pdb matches the source before loading it. Visual Studio,; // for instance, will display a warning that the breakpoints are not valid if; // the pdb does not match the source.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:15,checksum,checksum,15,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,1,['checksum'],['checksum']
Security,"// We expect the majority of the outlining candidates to be in consensus with; // regard to return address sign and authentication, and branch target; // enforcement, in other words, partitioning according to all the four; // possible combinations of PAC-RET and BTI is going to yield one big subset; // and three small (likely empty) subsets. That allows us to cull incompatible; // candidates separately for PAC-RET and BTI.; // Partition the candidates in two sets: one with BTI enabled and one with BTI; // disabled. Remove the candidates from the smaller set. If they are the same; // number prefer the non-BTI ones for outlining, since they have less; // overhead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:116,authenticat,authentication,116,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['authenticat'],['authentication']
Security,"// We handle memory intrinsics explicitly, at least the first (=; // destination) and second (=source) arguments as we know how they are; // accessed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:141,access,accessed,141,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['access'],['accessed']
Security,"// We hash NameRef, which is the mangled name, in order to get most; // overloaded functions resolve correctly.; //; // Strictly speaking, hashing the Tag is only necessary for a; // DW_TAG_module, to prevent uniquing of a module and a namespace; // with the same name.; //; // FIXME: dsymutil-classic won't unique the same type presented; // once as a struct and once as a class. Using the Tag in the fully; // qualified name hash to get the same effect.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerDeclContext.cpp:6,hash,hash,6,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerDeclContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerDeclContext.cpp,3,['hash'],"['hash', 'hashing']"
Security,"// We hash on the UUID",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TFileCollection.cxx:6,hash,hash,6,core/base/src/TFileCollection.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TFileCollection.cxx,1,['hash'],['hash']
Security,"// We have a group with gaps. It therefore can't be a reversed access,; // because such groups get invalidated (TODO).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:63,access,access,63,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,1,['access'],['access']
Security,"// We have a little hack here where keep the owned pointers private, and only; // expose a reference. This has two purposes:; // - Avoid derived classes messing with those pointers.; // - Keep the API consistent. CInfo, MF, MRI, etc. are all accessed as; // references. Accessing Observer/B as pointers unnecessarily leaks; // implementation details into derived classes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Combiner.h:82,expose,expose,82,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Combiner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Combiner.h,3,"['Access', 'access', 'expose']","['Accessing', 'accessed', 'expose']"
Security,"// We have a qualified template-id, e.g., N::A<int>; // If this would be a valid constructor declaration with template; // arguments, we will reject the attempt to form an invalid type-id; // referring to the injected-class-name when we annotate the token,; // per C++ [class.qual]p2.; //; // To improve diagnostics for this case, parse the declaration as a; // constructor (and reject the extra template arguments later).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:209,inject,injected-class-name,209,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['inject'],['injected-class-name']
Security,"// We have a reference to an unnamed field. This is always the; // base of an anonymous struct/union member access, i.e. the; // field is always of record type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:108,access,access,108,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['access'],['access']
Security,// We have a stack access. Is it the right register and slot?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:19,access,access,19,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['access'],['access']
Security,"// We have collected all loads and stores.; // FIXME: many of these accesses do not need to be checked for races; // (e.g. variables that do not escape, etc).; // Instrument memory accesses only if we want to report bugs in the function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:68,access,accesses,68,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,2,['access'],['accesses']
Security,// We have custom shuffle lowering to expose the shuffle mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:38,expose,expose,38,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,1,['expose'],['expose']
Security,"// We have no authentication information, neither in the options; // nor in the enviromental variables. So may be this is a; // world-readable file, so let's continue and see if; // we can open it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TS3WebFile.cxx:14,authenticat,authentication,14,net/net/src/TS3WebFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TS3WebFile.cxx,1,['authenticat'],['authentication']
Security,"// We have the number for a PHI, or possibly live-through value, to be used; // at this Use. There are a number of things we have to check about it though:; // * Does any PHI use an 'Undef' (like an IMPLICIT_DEF) value? If so, this; // Use was not completely dominated by DBG_PHIs and we should abort.; // * Are the Defs or PHIs clobbered in a block? SSAUpdater isn't aware that; // we've left SSA form. Validate that the inputs to each PHI are the; // expected values.; // * Is a PHI we've created actually a merging of values, or are all the; // predecessor values the same, leading to a non-PHI machine value number?; // (SSAUpdater doesn't know that either). Remap validated PHIs into the; // the ValidatedValues collection below to sort this out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:404,Validat,Validate,404,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,3,"['Validat', 'validat']","['Validate', 'ValidatedValues', 'validated']"
Security,"// We have to create a placed volume from the unplaced one to have access; // to the navigation interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/vecgeom/src/TGeoVGShape.cxx:67,access,access,67,geom/vecgeom/src/TGeoVGShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/vecgeom/src/TGeoVGShape.cxx,1,['access'],['access']
Security,"// We have to maintain the illusion that the variable is; // zero-initialized. If the variable might be accessed in its; // initializer, zero-initialize before running the initializer, then; // actually perform the initialization with an assign.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:104,access,accessed,104,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,1,['access'],['accessed']
Security,// We have validated whether the token is an Identifier.; // Now we have to validate whether the token is a; // valid HLASM Label.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:11,validat,validated,11,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,2,['validat'],"['validate', 'validated']"
Security,"// We ignore NONUNIQUE; we do not support OPTION M510 or OPTION OLDSTRUCTS; // anyway, so all field accesses must be qualified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp:100,access,accesses,100,interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,1,['access'],['accesses']
Security,"// We intentionally leave `JoinedEnv.ExprToLoc` and `JoinedEnv.ExprToVal`; // empty, as we never need to access entries in these maps outside of the; // basic block that sets them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:105,access,access,105,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,1,['access'],['access']
Security,"// We keep both the raw value and the min tag value's pointer in a union. When; // the minimum tag value is zero, this allows code below to cleanly expose the; // address of the zero-tag pointer instead of just the zero-tag pointer; // itself. This is especially useful when building `ArrayRef`s out of a single; // pointer. However, we have to carefully access the union due to the active; // member potentially changing. When we *store* a new value, we directly; // access the union to allow us to store using the obvious types. However,; // when we *read* a value, we copy the underlying storage out to avoid relying; // on one member or the other being active.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h:148,expose,expose,148,interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,3,"['access', 'expose']","['access', 'expose']"
Security,// We keep only high 32-bits of hash value. So bucket size cannot; // exceed 2^31. Bucket size is always power of two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:32,hash,hash,32,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,1,['hash'],['hash']
Security,"// We know kernels (generally) cannot be called from within the module. Thus,; // for reachability we would need to step back from a kernel which would allow; // us to reach anything anyway. Even if a kernel is invoked from another; // kernel, values like allocas and shared memory are not accessible. We; // implicitly check for this situation to avoid costly lookups.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:290,access,accessible,290,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['access'],['accessible']
Security,"// We know that dst up to src_size is not written. We now need to make sure; // that dst up to dst_size is not accessed. (If we did not move the memset,; // checking for reads would be sufficient.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:111,access,accessed,111,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,1,['access'],['accessed']
Security,"// We know that elements in the chain with nonverlapping offsets can't; // alias, but AA may not be smart enough to figure this out. Use a; // hashtable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:143,hash,hashtable,143,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,1,['hash'],['hashtable']
Security,// We lower member accesses to base accesses by pretending that the; // member is a base class of its declaring class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:19,access,accesses,19,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,2,['access'],['accesses']
Security,"// We maintain lists of memory accesses per-block, trading memory for time. We; // could just look up the memory access for every possible instruction in the; // stream.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:31,access,accesses,31,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,2,['access'],"['access', 'accesses']"
Security,"// We may end up with a situation when section symbol is technically; // defined, but should not be. That happens because we explicitly; // pre-create few .debug_* sections to have accessors.; // And if these sections were not really defined in the code, but were; // referenced, we simply error out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp:181,access,accessors,181,interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/ELFObjectWriter.cpp,1,['access'],['accessors']
Security,"// We may have a Foreign class let's look using the; // checksum:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCloner.cxx:56,checksum,checksum,56,tree/tree/src/TTreeCloner.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCloner.cxx,1,['checksum'],['checksum']
Security,"// We may have found the injected-class-name of a class template,; // class template partial specialization, or class template specialization.; // In these cases, grab the template that is being defined or specialized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:25,inject,injected-class-name,25,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['inject'],['injected-class-name']
Security,"// We may not have got a salt (if the server may not access it; // or if it needs the full password, like for AFS ...)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:53,access,access,53,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,2,"['access', 'password']","['access', 'password']"
Security,"// We might be replacing an existing declaration in the lookup tables;; // if so, borrow its access specifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:93,access,access,93,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['access'],['access']
Security,// We modified the stack.; // Walk over the basic block and fix up all the stack accesses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:81,access,accesses,81,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,2,['access'],['accesses']
Security,// We must also preserve LoopSimplify and LCSSA. We locally access their IDs; // here because users shouldn't directly get them from this header.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:60,access,access,60,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,1,['access'],['access']
Security,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:34,access,accesses,34,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,4,['access'],"['access', 'accesses']"
Security,"// We must be careful with the undef elements of the sign bit mask, however:; // the mask elt can be undef iff the shift amount for that lane was undef,; // otherwise we need to sanitize undef masks to zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:178,sanitiz,sanitize,178,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['sanitiz'],['sanitize']
Security,"// We must match on the same checksum, an existing TStreamerInfo; // for one of the 'unversioned' class layout (i.e. version was 1).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:29,checksum,checksum,29,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,1,['checksum'],['checksum']
Security,"// We must unpoison the stack before NoReturn calls (throw, _exit, etc).; // See e.g. https://github.com/google/sanitizers/issues/37",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:112,sanitiz,sanitizers,112,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['sanitiz'],['sanitizers']
Security,// We need a global bitmap to tell if a function is executed. We also; // need a global variable to save the order of functions. We can use a; // fixed-size buffer that saves the MD5 hash of the function. We need; // a global variable to save the index into the buffer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp:183,hash,hash,183,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp,1,['hash'],['hash']
Security,// We need a phi: if there is an upwards exposed use we already have a; // destination virtual register number otherwise we generate a new one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp:41,expose,exposed,41,interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwiftErrorValueTracking.cpp,1,['expose'],['exposed']
Security,"// We need a v16i8 for TBL, so we extend the source with a placeholder vector; // for v8i8 to get a v16i8. As the pattern we are replacing is extract +; // insert, we know that the index in the mask must be smaller than the number; // of elements in the source, or we would have an out-of-bounds access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:296,access,access,296,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['access'],['access']
Security,"// We need the dictionary initialization but we don't want to inject the; // declarations into the interpreter, except for those we really need for; // I/O; see rootcling.cxx after the call to TCling__GetInterpreter().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:62,inject,inject,62,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['inject'],['inject']
Security,"// We need this function to not fall back to returning the ""omnipotent char""; // type node for aggregate and union types. Otherwise, any dereference of an; // aggregate will result into the may-alias access descriptor, meaning all; // subsequent accesses to direct and indirect members of that aggregate will; // be considered may-alias too.; // TODO: Combine getTypeInfo() and getBaseTypeInfo() into a single function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp:200,access,access,200,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp,2,['access'],"['access', 'accesses']"
Security,"// We need to compute an access strategy for this bit-field. We are given the; // offset to the first byte in the bit-field, the sub-byte offset is taken; // from the original layout. We reuse the normal bit-field access strategy by; // treating this as an access to a struct where the bit-field is in byte 0,; // and adjust the containing type size as appropriate.; //; // FIXME: Note that currently we make a very conservative estimate of the; // alignment of the bit-field, because (a) it is not clear what guarantees the; // runtime makes us, and (b) we don't have a way to specify that the struct is; // at an alignment plus offset.; //; // Note, there is a subtle invariant here: we can only call this routine on; // non-synthesized ivars but we may be called for synthesized ivars. However,; // a synthesized ivar can never be a bit-field, so this is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.cpp:25,access,access,25,interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.cpp,3,['access'],['access']
Security,// We need to emit host-side 'shadows' for all global; // device-side variables because the CUDA runtime needs their; // size and host-side address in order to provide access to; // their device-side incarnations.; // So device-only functions are the only things we skip.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:168,access,access,168,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['access'],['access']
Security,// We need to follow common pointer manipulation uses to the accesses they; // feed into.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:61,access,accesses,61,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['access'],['accesses']
Security,"// We need to follow common pointer manipulation uses to the accesses they; // feed into. We can try to be smart to avoid looking through things we do not; // like for now, e.g., non-inbounds GEPs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:61,access,accesses,61,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['access'],['accesses']
Security,// We need to generate a new global to hold the address of the indirectly; // called device function. Doing this allows us to keep the visibility and; // linkage of the associated function unchanged while allowing the runtime to; // access its value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:233,access,access,233,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['access'],['access']
Security,// We need to inject some bytes before the member we just wrote but after; // the previous member. Save off the length of the member we just wrote so; // that we can do validate it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/ContinuationRecordBuilder.cpp:14,inject,inject,14,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/ContinuationRecordBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/ContinuationRecordBuilder.cpp,2,"['inject', 'validat']","['inject', 'validate']"
Security,"// We need to keep the references to the stack protector slot through frame; // index operands so that it gets resolved by PEI rather than this pass.; // This avoids accesses to the stack protector though virtual base; // registers, and forces PEI to address it using fp/sp/bp.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:166,access,accesses,166,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,1,['access'],['accesses']
Security,"// We need to search if the library doesn't have .gnu.hash section!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp:54,hash,hash,54,interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,1,['hash'],['hash']
Security,"// We need to temorairly remove the assumption so we can insert the; // sanitizer check before it, else the check will be dropped by optimizations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:72,sanitiz,sanitizer,72,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,1,['sanitiz'],['sanitizer']
Security,"// We now have accesses at two offsets from the same base:; // 1. (...)*GCD + DecompGEP1.Offset with size V1Size; // 2. 0 with size V2Size; // Using arithmetic modulo GCD, the accesses are at; // [ModOffset..ModOffset+V1Size) and [0..V2Size). If the first access fits; // into the range [V2Size..GCD), then we know they cannot overlap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:15,access,accesses,15,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,3,['access'],"['access', 'accesses']"
Security,// We only need to re-check access for methods which we didn't; // manage to match during parsing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:28,access,access,28,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['access'],['access']
Security,"// We only use TTreeReaderArrays to read columns that users flagged as type `RVec`, so we need to check; // that the branch stores the array as contiguous memory that we can actually wrap in an `RVec`.; // Currently we need the first entry to have been loaded to perform the check; // TODO Move check to constructor once ROOT-10823 is fixed and TTreeReaderArray itself exposes this information",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx:369,expose,exposes,369,tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx,1,['expose'],['exposes']
Security,"// We reached the start of the block before finding a defining instruction.; // There are numerous scenarios where this can happen:; // * Constant physical registers,; // * Several intrinsics that allow LLVM-IR to read arbitary registers,; // * Arguments in the entry block,; // * Exception handling landing pads.; // Validating all of them is too difficult, so just insert a DBG_PHI reading; // the variable value at this position, rather than checking it makes sense.; // Create DBG_PHI for specified physreg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:318,Validat,Validating,318,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,1,['Validat'],['Validating']
Security,// We record each overload check line before emitting because subsequent Inst; // definitions may extend the number of permitted types (i.e. augment the; // Mask). Use std::map to avoid sorting the table by hash number.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:207,hash,hash,207,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,1,['hash'],['hash']
Security,"// We record the top most called three functions at each call site.; // Profile metadata contains ""VP"" string identifying this metadata; // as value profiling data, then a uint32_t value for the value profiling; // kind, a uint64_t value for the total number of times the call is; // executed, followed by the function hash and execution count (uint64_t); // pairs for each function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp:319,hash,hash,319,interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,1,['hash'],['hash']
Security,"// We recreate the RequiresExpr body, but not by instantiating it.; // Produce pending diagnostics for dependent access check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:113,access,access,113,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['access'],['access']
Security,"// We represent the primary and partition names as 'Paths' which are sections; // of the hierarchical access path for a clang module. However for C++20; // the periods in a name are just another character, and we will need to; // flatten them into a string.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:102,access,access,102,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,1,['access'],['access']
Security,"// We require that future class versions only append members and store the checksum in the last 8 bytes; // Checksum calculation: strip byte count, class version, fChecksum member",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx:75,checksum,checksum,75,tree/ntuple/v7/src/RMiniFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx,2,"['Checksum', 'checksum']","['Checksum', 'checksum']"
Security,// We reserved the last registers for this. Shift it down to the end of those; // which were actually used.; //; // FIXME: It might be safer to use a pseudoregister before replacement.; // FIXME: We should be able to eliminate unused input registers. We only; // cannot do this for the resources required for scratch access. For now we; // skip over user SGPRs and may leave unused holes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:317,access,access,317,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,1,['access'],['access']
Security,"// We seed the scalars analysis with three classes of instructions: (1); // instructions marked uniform-after-vectorization and (2) bitcast,; // getelementptr and (pointer) phi instructions used by memory accesses; // requiring a scalar use.; //; // (1) Add to the worklist all instructions that have been identified as; // uniform-after-vectorization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:205,access,accesses,205,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['access'],['accesses']
Security,// We should at least make this hidden since we don't want to expose it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp:62,expose,expose,62,interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp,1,['expose'],['expose']
Security,// We should not try to synthesize explicitly redefined accessors.; // We do not know for sure how they behave.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp:56,access,accessors,56,interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/BodyFarm.cpp,1,['access'],['accessors']
Security,// We shouldn't prefer using the FP to access fixed-sized stack objects when; // there are scalable (SVE) objects in between the FP and the fixed-sized; // objects.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:39,access,access,39,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['access'],['access']
Security,// We still need to inject the function into the enclosing block scope so; // that later (non-call) uses can see it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:20,inject,inject,20,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['inject'],['inject']
Security,"// We try to achieve the globally optimal memory access for the loopnest,; // and do interchange based on a bubble-sort fasion. We start from; // the innermost loop, move it outwards to the best possible position; // and repeat this process.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:49,access,access,49,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,1,['access'],['access']
Security,"// We use a perfect hash function here involving the length of the keyword,; // the first and third character. For preprocessor ID's there are no; // collisions (if there were, the switch below would complain about duplicate; // case values). Note that this depends on 'if' being null terminated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp:20,hash,hash,20,interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/IdentifierTable.cpp,1,['hash'],['hash']
Security,"// We use a std::map here to be able to have a defined ordering when; // producing a hash for the cache entry.; // FIXME: we should be able to compute the caching hash for the entry based; // on the index, and nuke this map.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:85,hash,hash,85,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,2,['hash'],['hash']
Security,"// We use uint64_t in the bit-fields below since some bit-fields; // cross the unsigned boundary and this breaks the packing.; /// Stores the bits used by DeclContext.; /// If modified NumDeclContextBit, the ctor of DeclContext and the accessor; /// methods in DeclContext should be updated appropriately.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:236,access,accessor,236,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['access'],['accessor']
Security,"// We want the mem access to be issued at a sane offset from PointerReg,; // so that if PointerReg is null then the access reliably page faults.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:19,access,access,19,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,2,['access'],['access']
Security,// We want to interleave small loops in order to reduce the loop overhead and; // potentially expose ILP opportunities.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:94,expose,expose,94,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['expose'],['expose']
Security,"// We want to reliably handle any conditional branch terminators in the; // MBB, so we manually analyze the branch. We can handle all of the; // permutations here, including ones that analyze branch cannot.; //; // The approach is to walk backwards across the terminators, resetting at; // any unconditional non-indirect branch, and track all conditional edges; // to basic blocks as well as the fallthrough or unconditional successor; // edge. For each conditional edge, we track the target and the opposite; // condition code in order to inject a ""no-op"" cmov into that successor; // that will harden the predicate. For the fallthrough/unconditional; // edge, we inject a separate cmov for each conditional branch with; // matching condition codes. This effectively implements an ""and"" of the; // condition flags, even if there isn't a single condition flag that would; // directly implement that. We don't bother trying to optimize either of; // these cases because if such an optimization is possible, LLVM should; // have optimized the conditional *branches* in that way already to reduce; // instruction count. This late, we simply assume the minimal number of; // branch instructions is being emitted and use that to guide our cmov; // insertion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:540,inject,inject,540,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,2,['inject'],['inject']
Security,"// We will either select ds_read_b64/ds_write_b64 or ds_read2_b32/; // ds_write2_b32 depending on the alignment. In either case with either; // alignment there is no faster way of doing this.; // The numbers returned here and below are not additive, it is a 'speed; // rank'. They are just meant to be compared to decide if a certain way; // of lowering an operation is faster than another. For that purpose; // naturally aligned operation gets it bitsize to indicate that ""it; // operates with a speed comparable to N-bit wide load"". With the full; // alignment ds128 is slower than ds96 for example. If underaligned it; // is comparable to a speed of a single dword access, which would then; // mean 32 < 128 and it is faster to issue a wide load regardless.; // 1 is simply ""slow, don't do it"". I.e. comparing an aligned load to a; // wider load which will not be aligned anymore the latter is slower.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:668,access,access,668,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['access'],['access']
Security,// We will have an entry in the map for each block so we grow the; // structure to twice that size to keep the load factor low in the hash table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:134,hash,hash,134,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,1,['hash'],['hash']
Security,"// We won't be able to check the base class, we need to (try) to check; // this class even-though it does not have a local HashMember.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TCheckHashRecursiveRemoveConsistency.h:123,Hash,HashMember,123,core/meta/src/TCheckHashRecursiveRemoveConsistency.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TCheckHashRecursiveRemoveConsistency.h,1,['Hash'],['HashMember']
Security,// We would normally delete the original instruction here but in this case; // we only needed to inject an additional instruction rather than replace it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:97,inject,inject,97,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,1,['inject'],['inject']
Security,"// We write the header first, starting with the hash buckets count. Normally; // it is the number of entries in HashBuckets, but the ""NBuckets"" property can; // be used to override this field, which is useful for producing broken; // objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp:48,hash,hash,48,interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp,2,"['Hash', 'hash']","['HashBuckets', 'hash']"
Security,"// We'll add uses of the sunk instruction below, but since; // sinking can expose opportunities for it's *operands* add; // them to the worklist",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:75,expose,expose,75,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['expose'],['expose']
Security,"// We're in a lambda; determine the lambda capture field maps unless we're; // just constexpr checking a lambda's call operator. constexpr checking is; // done before the captures have been added to the closure object (unless; // we're inferring constexpr-ness), so we don't have access to them in this; // case. But since we don't need the captures to constexpr check, we can; // just ignore them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:280,access,access,280,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['access'],['access']
Security,"// We're iterating over a hashtable, so this would be a source of; // non-determinism in compiler output *except* that we're just; // messing around with llvm::Constant structures, which never itself; // does anything that should be visible in compiler output.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprConstant.cpp:26,hash,hashtable,26,interpreter/llvm-project/clang/lib/CodeGen/CGExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprConstant.cpp,1,['hash'],['hashtable']
Security,// We're using validateOutputConstraint here because we only care if; // this is a register constraint.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp:15,validat,validateOutputConstraint,15,interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,1,['validat'],['validateOutputConstraint']
Security,"// We've already validated that any VPT predication within the loop will be; // equivalent when we perform the predication transformation; so we know that; // any VPT predicated instruction is predicated upon VCTP. Any live-out; // instruction needs to be predicated, so check this here. The instructions; // in NonPredicated have been found to be a reduction that we can ensure its; // legality. Any MQPRCopy found will need to validate its input as if it was; // live out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:17,validat,validated,17,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,2,['validat'],"['validate', 'validated']"
Security,"// We've never seen a function with this name and hash, add it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp:50,hash,hash,50,interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,1,['hash'],['hash']
Security,"// WebAssembly supports unaligned accesses, though it should be declared; // with the p2align attribute on loads and stores which do so, and there; // may be a performance impact. We tell LLVM they're ""fast"" because; // for the kinds of things that LLVM uses this for (merging adjacent stores; // of constants, etc.), WebAssembly implementations will either want the; // unaligned access or they'll split anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:34,access,accesses,34,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,2,['access'],"['access', 'accesses']"
Security,"// When -O0 is enabled, the Load Value Injection Hardening pass will fall back; // to using the Speculative Execution Side Effect Suppression pass for; // mitigation. This is to prevent slow downs due to; // analyses needed by the LVIHardening pass when compiling at -O0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetMachine.cpp:39,Inject,Injection,39,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetMachine.cpp,1,['Inject'],['Injection']
Security,"// When AA isn't available, but if the load and the store have the same; // base, constant offsets and non-overlapping access ranges, ignore the; // store. This is a simple form of alias analysis that is used by the; // inliner. FIXME: use BasicAA if possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:119,access,access,119,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,1,['access'],['access']
Security,"// When ClearDSOLocalOnDeclarations is true, clear dso_local if GV is; // converted to a declaration, to disable direct access. Don't do this if GV; // is implicitly dso_local due to a non-default visibility.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:120,access,access,120,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,1,['access'],['access']
Security,"// When Dominatee is defined on function entry, it is not dominated by another; // memory access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:90,access,access,90,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['access'],['access']
Security,"// When Dominator is defined on function entry, it dominates the other memory; // access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:82,access,access,82,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['access'],['access']
Security,"// When ForceCheckCXX20ModulesInputFiles and ValidateASTInputFilesContent; // enabled, it is better to check the contents of the inputs. Since we can't; // get correct modified time information for inputs from overriden inputs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:45,Validat,ValidateASTInputFilesContent,45,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['Validat'],['ValidateASTInputFilesContent']
Security,"// When HWASAN is used and tagging of global variables is enabled; // they should be accessed via the GOT, since the tagged address of a global; // is incompatible with existing code models. This also applies to non-pic; // mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:85,access,accessed,85,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['access'],['accessed']
Security,"// When LSR detects uses of the same base address to access different; // types (e.g. unions), it will assume a conservative type for these; // uses:; // LSR Use: Kind=Address of void in addrspace(4294967295), ...; // The type Ty passed here would then be ""void"". Skip the alignment; // checks, but do not return false right away, since that confuses; // LSR into crashing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:53,access,access,53,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,1,['access'],['access']
Security,// When a flow sensitive bug happens in templated code we should not generate; // distinct hash value for every instantiation. Use the signature from the; // primary template.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/IssueHash.cpp:91,hash,hash,91,interpreter/llvm-project/clang/lib/Analysis/IssueHash.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/IssueHash.cpp,1,['hash'],['hash']
Security,"// When a new class is created, we need to be able to find; // if there are any existing classes that have the same name; // after any typedefs are expanded. (This only really affects; // template arguments.) To avoid having to search through all classes; // in that case, we keep a hash table mapping from the fully; // typedef-expanded names to the original class names.; // An entry is made in the table only if they are actually different.; //; // In these objects, the TObjString base holds the typedef-expanded; // name (the hash key), and fOrigName holds the original class name; // (the value to which the key maps).; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:283,hash,hash,283,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,2,['hash'],['hash']
Security,// When a user wants to use objc_boxable with a union or struct; // but they don't have access to the declaration (legacy/third-party code); // then they can 'enable' this feature with a typedef:; // typedef struct __attribute((objc_boxable)) legacy_struct legacy_struct;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:88,access,access,88,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['access'],['access']
Security,"// When an object goes out of scope, we can free the history associated; // with any property accesses on that object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:94,access,accesses,94,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,1,['access'],['accesses']
Security,"// When built with access to the proper Windows APIs, try to actually find; // the correct include paths first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp:19,access,access,19,interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MSVC.cpp,1,['access'],['access']
Security,"// When built with access to the proper Windows APIs, try to actually find; // the correct include paths first. Init for UnivSDK.empty check below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp:19,access,access,19,interpreter/cling/lib/Interpreter/CIFactory.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp,1,['access'],['access']
Security,"// When compiling with -gmodules, also hash -fdebug-prefix-map as it; // affects the debug info in the PCM.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:39,hash,hash,39,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['hash'],['hash']
Security,"// When for example -### or -v is used; // without a file, target specific options are not; // consumed/validated.; // Instead emitting an error emit a warning instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:104,validat,validated,104,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['validat'],['validated']
Security,"// When modeling a C++ constructor, for a variety of reasons we need to track; // the location of the object for the duration of its ConstructionContext.; // ObjectsUnderConstruction maps statements within the construction context; // to the object's location, so that on every such statement the location; // could have been retrieved.; /// ConstructedObjectKey is used for being able to find the path-sensitive; /// memory region of a freshly constructed object while modeling the AST node; /// that syntactically represents the object that is being constructed.; /// Semantics of such nodes may sometimes require access to the region that's; /// not otherwise present in the program state, or to the very fact that; /// the construction context was present and contained references to these; /// AST nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:616,access,access,616,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,1,['access'],['access']
Security,"// When performing member access on a prvalue, materialize a temporary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:26,access,access,26,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['access'],['access']
Security,// When the linkage is not internal we must emit an alias for the original; // variable name as it may be accessed from another object. On non-Mach-O; // we can also emit an alias for internal linkage as it's safe to do so.; // It's not safe on Mach-O as the alias (and thus the portion of the; // MergedGlobals variable) may be dead stripped at link time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:106,access,accessed,106,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,1,['access'],['accessed']
Security,"// When the target also allows 64-bit frame pointer and we do have a; // frame, this is fine to use it for the address accesses as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86RegisterInfo.cpp:119,access,accesses,119,interpreter/llvm-project/llvm/lib/Target/X86/X86RegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86RegisterInfo.cpp,1,['access'],['accesses']
Security,"// When the width of the result grows, assume that a debugger will only; // access the low `FromBits` bits when inspecting the source variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:76,access,access,76,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['access'],['access']
Security,"// When using FP to access scalable vector objects, we need to minus; // the frame size.; //; // |--------------------------| -- <-- FP; // | callee-allocated save | |; // | area for register varargs| |; // |--------------------------| |; // | callee-saved registers | |; // |--------------------------| | MFI.getStackSize(); // | scalar local variables | |; // |--------------------------| -- (Offset of RVV objects is from here.); // | RVV objects |; // |--------------------------|; // | VarSize objects |; // |--------------------------| <-- SP",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:20,access,access,20,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['access'],['access']
Security,"// When using SP or BP to access stack objects, we may require extra padding; // to ensure the bottom of the RVV stack is correctly aligned within the main; // stack. We calculate this as the amount required to align the scalar local; // variable section up to the RVV alignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:26,access,access,26,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['access'],['access']
Security,"// When using SP to access frame objects, we need to add RVV stack size.; //; // |--------------------------| -- <-- FP; // | callee-allocated save | | <----|; // | area for register varargs| | |; // |--------------------------| | |; // | callee-saved registers | | |; // |--------------------------| -- |; // | RVV alignment padding | | |; // | (not counted in | | |; // | MFI.getStackSize() but | | |; // | counted in | | |; // | RVFI.getRVVStackSize()) | | |; // |--------------------------| -- |; // | RVV objects | | |-- MFI.getStackSize(); // | (not counted in | | |; // | MFI.getStackSize()) | | |; // |--------------------------| -- |; // | padding before RVV | | |; // | (not counted in | | |; // | MFI.getStackSize()) | | |; // |--------------------------| -- |; // | scalar local variables | | <----'; // |--------------------------| -- <-- BP (if var sized objects present); // | VarSize objects | |; // |--------------------------| -- <-- SP; //; // The total amount of padding surrounding RVV objects is described by; // RVV->getRVVPadding() and it can be zero. It allows us to align the RVV; // objects to the required alignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:20,access,access,20,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['access'],['access']
Security,"// When we emulate implicit 'this->' in an unqualified lookup, we might; // end up with an invalid naming class. In that case, we avoid emulating; // 'this->' qualifier to satisfy preconditions of the access checking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:201,access,access,201,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['access'],['access']
Security,"// When we'd use andi/andis, we bias toward using the rotates (andi only; // has a record form, and is cracked on POWER cores). However, when using; // general 64-bit constant formation, bias toward the constant form,; // because that exposes more opportunities for CSE.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:235,expose,exposes,235,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['expose'],['exposes']
Security,// Whether the content of input files should be hashed and used to; // validate consistency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h:48,hash,hashed,48,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h,2,"['hash', 'validat']","['hashed', 'validate']"
Security,"// Whether this is accessed as T.member, T->member, or T::member.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:19,access,accessed,19,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['access'],['accessed']
Security,// Whether to keep the symbol name for each frame after hashing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/RawMemProfReader.h:56,hash,hashing,56,interpreter/llvm-project/llvm/include/llvm/ProfileData/RawMemProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/RawMemProfReader.h,1,['hash'],['hashing']
Security,// Whether we can prove that all accesses to this Alloca are in-range and; // during its lifetime.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:33,access,accesses,33,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,1,['access'],['accesses']
Security,"// Which section (header table index) it's defined in; // These accessors and mutators correspond to the ELF32_ST_BIND,; // ELF32_ST_TYPE, and ELF32_ST_INFO macros defined in the ELF specification:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:64,access,accessors,64,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['access'],['accessors']
Security,"// While __func__, etc., are technically not string literals, they; // cannot contain format specifiers and thus are not a security; // liability.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:123,secur,security,123,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['secur'],['security']
Security,"// While `x += 1` (for `x` with width less than int) is modeled as; // promotion+arithmetics+demotion, and we can catch lossy demotion with; // ease; inc/dec with width less than int can't overflow because of; // promotion rules, so we omit promotion+demotion, which means that we can; // not catch lossy ""demotion"". Because we still want to catch these cases; // when the sanitizer is enabled, we perform the promotion, then perform; // the increment/decrement in the wider type, and finally; // perform the demotion. This will catch lossy demotions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:373,sanitiz,sanitizer,373,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['sanitiz'],['sanitizer']
Security,"// While compiler may see key method in this TU, during CUDA; // compilation we should ignore methods that are not accessible; // on this side of compilation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:115,access,accessible,115,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['access'],['accessible']
Security,"// While the next two tokens are 'period' 'identifier', repeatedly parse it as; // a field access. We have to avoid consuming assembler directives that look; // like '.' 'else'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:91,access,access,91,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,1,['access'],['access']
Security,"// While volatile access cannot be eliminated, they do not have to clobber; // non-aliasing locations, as normal accesses can for example be reordered; // with volatile accesses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:18,access,access,18,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,3,['access'],"['access', 'accesses']"
Security,"// While volatile access cannot be eliminated, they do not have to clobber; // non-aliasing locations, as normal accesses, for example, can be safely; // reordered with volatile accesses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:18,access,access,18,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,3,['access'],"['access', 'accesses']"
Security,// Whitelist accesses if there's an invalid or unsupported friend; // declaration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:13,access,accesses,13,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['access'],['accesses']
Security,"// Width of exposed area",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/inc/TRecorder.h:12,expose,exposed,12,gui/recorder/inc/TRecorder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/inc/TRecorder.h,1,['expose'],['exposed']
Security,"// Win64 EH requires a frame pointer if funclets are present, as the locals; // are accessed off the frame pointer in both the parent function and the; // funclets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:84,access,accessed,84,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['access'],['accessed']
Security,"// With constant offsets and constant steps, we can generate pre-inc; // accesses by having the offset equal the step. So, for access #0 with a; // step of 8, we generate a G - 8 base which would require the first access; // to be ((G - 8) + 8),+,8. The pre-indexed access then updates the pointer; // for itself and hopefully becomes the base for other accesses. This means; // means that a single pre-indexed access can be generated to become the new; // base pointer for each iteration of the loop, resulting in no extra add/sub; // instructions for pointer updating.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:73,access,accesses,73,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,6,['access'],"['access', 'accesses']"
Security,"// With large callframes around we may need to use FP to access the scavenging; // emergency spillslot.; //; // Unfortunately some calls to hasFP() like machine verifier ->; // getReservedReg() -> hasFP in the middle of global isel are too early; // to know the max call frame size. Hopefully conservatively returning ""true""; // in those cases is fine.; // DefaultSafeSPDisplacement is fine as we only emergency spill GP regs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:57,access,access,57,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['access'],['access']
Security,// With new-format nodes we stop at the access type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:40,access,access,40,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,1,['access'],['access']
Security,"// With op_sel VOP3P instructions freely can access the low half or high; // half of a register, so any swizzle is free.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp:45,access,access,45,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,1,['access'],['access']
Security,"// With preprocessor directive indentation, the line starts on column 0; // since it's indented after the hash, but FirstIndent is set to the; // preprocessor indent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:106,hash,hash,106,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,1,['hash'],['hash']
Security,"// With the -maix-small-local-exec-tls option, produce a faster access; // sequence for local-exec TLS variables where the offset from the TLS; // base is encoded as an immediate operand.; //; // We only utilize the faster local-exec access sequence when the TLS; // variable has a size within the policy limit. We treat types that are; // not sized or are empty as being over the policy size limit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:64,access,access,64,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,['access'],['access']
Security,"// With the large code model, None forces all memory accesses to be indirect; // rather than RIP-relative.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86Subtarget.cpp:53,access,accesses,53,interpreter/llvm-project/llvm/lib/Target/X86/X86Subtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86Subtarget.cpp,1,['access'],['accesses']
Security,"// With validation enabled, we want to exclude symbols visible to regular; // objects. Local symbols will be in this group due to the current; // implementation but those with VCallVisibilityTranslationUnit will have; // already been marked in clang so are unaffected.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:8,validat,validation,8,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['validat'],['validation']
Security,"// With validation enabled, we want to exclude symbols visible to; // regular objects. Local symbols will be in this group due to the; // current implementation but those with VCallVisibilityTranslationUnit; // will have already been marked in clang so are unaffected.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:8,validat,validation,8,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['validat'],['validation']
Security,"// Without going backwards in the call tree, can we reach the access; // from the least dominating write. Do not allow to pass the instruction; // itself either.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:62,access,access,62,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['access'],['access']
Security,// Word-sized access,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:14,access,access,14,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['access'],['access']
Security,// Work out the hashed gradient indices of the five simplex corners,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs:16,hash,hashed,16,js/modules/three_addons.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs,1,['hash'],['hashed']
Security,// Work out the hashed gradient indices of the four simplex corners,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs:16,hash,hashed,16,js/modules/three_addons.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs,1,['hash'],['hashed']
Security,// Work out the hashed gradient indices of the three simplex corners,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs:16,hash,hashed,16,js/modules/three_addons.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three_addons.mjs,1,['hash'],['hashed']
Security,// Workaround for hashes and backticks in Verilog.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h:18,hash,hashes,18,interpreter/llvm-project/clang/lib/Format/FormatToken.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h,1,['hash'],['hashes']
Security,"// Workaround for multi-threaded environment; // Ensure main thread id picked when canvas implementation is created -; // otherwise it may be assigned in other thread and screw-up gPad access.; // Workaround may not work if main thread id was wrongly initialized before; // This resolves issue https://github.com/root-project/root/issues/15498",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx:185,access,access,185,gui/webgui6/src/TWebCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx,1,['access'],['access']
Security,// Wrapper class that contains Clause's information defined in DirectiveBase.td; // and provides helper methods for accessing it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h:116,access,accessing,116,interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h,1,['access'],['accessing']
Security,// Wrapper class that contains DirectiveLanguage's information defined in; // DirectiveBase.td and provides helper methods for accessing it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h:127,access,accessing,127,interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h,1,['access'],['accessing']
Security,// Wrapper class that contains VersionedClause's information defined in; // DirectiveBase.td and provides helper methods for accessing it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h:125,access,accessing,125,interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h,1,['access'],['accessing']
Security,// Wrapper class that contains a Directive's information defined in; // DirectiveBase.td and provides helper methods for accessing it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h:121,access,accessing,121,interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/DirectiveEmitter.h,1,['access'],['accessing']
Security,// Wraps a TargetGlobalAddress that should be loaded using PC-relative; // accesses (LARL). Operand 0 is the address.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h:75,access,accesses,75,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.h,1,['access'],['accesses']
Security,// Write 16-bytes of 0's for the hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDXContainerWriter.cpp:33,hash,hash,33,interpreter/llvm-project/llvm/lib/MC/MCDXContainerWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDXContainerWriter.cpp,1,['hash'],['hash']
Security,// Write a hash table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBStringTableBuilder.cpp:11,hash,hash,11,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBStringTableBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBStringTableBuilder.cpp,1,['hash'],['hash']
Security,// Write an array of hash buckets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp:21,hash,hash,21,interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp,1,['hash'],['hash']
Security,// Write an array of hash values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp:21,hash,hash,21,interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp,1,['hash'],['hash']
Security,"// Write it out as an unsplit ThinLTO module.; // Save the module hash produced for the full bitcode, which will; // be used in the backends, and use that in the minimized bitcode; // produced for the full link.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:66,hash,hash,66,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,1,['hash'],['hash']
Security,// Write module hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:16,hash,hash,16,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,1,['hash'],['hash']
Security,"// Write out checksum.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/lz4/src/ZipLZ4.cxx:13,checksum,checksum,13,core/lz4/src/ZipLZ4.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/lz4/src/ZipLZ4.cxx,1,['checksum'],['checksum']
Security,// Write the MemProf profile data if we have it. This includes a simple schema; // with the format described below followed by the hashtable:; // uint64_t RecordTableOffset = RecordTableGenerator.Emit; // uint64_t FramePayloadOffset = Stream offset before emitting the frame table; // uint64_t FrameTableOffset = FrameTableGenerator.Emit; // uint64_t Num schema entries; // uint64_t Schema entry 0; // uint64_t Schema entry 1; // ....; // uint64_t Schema entry N - 1; // OnDiskChainedHashTable MemProfRecordData; // OnDiskChainedHashTable MemProfFrameData,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp:131,hash,hashtable,131,interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,1,['hash'],['hashtable']
Security,// Write the hash table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp:13,hash,hash,13,interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfWriter.cpp,3,['hash'],['hash']
Security,// Write the hashes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOWriter.cpp:13,hash,hashes,13,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOWriter.cpp,1,['hash'],['hashes']
Security,// Write the index of the first symbol in the dynamic symbol table accessible; // via the hash table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp:67,access,accessible,67,interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp,2,"['access', 'hash']","['accessible', 'hash']"
Security,"// Write the new bit-field access parameters.; // As the storage offset now is defined as the number of elements from the; // start of the structure, we should divide the Offset by the element size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp:27,access,access,27,interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp,1,['access'],['access']
Security,"// Write these first for easy access when deserializing, as they affect the; // size of the MemberExpr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp:30,access,access,30,interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp,1,['access'],['access']
Security,"// Write this first for easy access when deserializing, as they affect the; // size of the UnaryOperator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp:29,access,access,29,interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp,2,['access'],['access']
Security,"// Writing to stdout should not be treated as an error here, just; // do not set access/modification times or permissions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FileUtilities.cpp:81,access,access,81,interpreter/llvm-project/llvm/lib/Support/FileUtilities.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FileUtilities.cpp,1,['access'],['access']
Security,"// X2/R2 is guaranteed to be preserved within a function if it is reserved.; // The reason it's reserved is that it's the TOC pointer (and the function; // uses the TOC). In functions where it isn't reserved (i.e. leaf functions; // with no TOC access), we can't claim that it is preserved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:245,access,access,245,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,1,['access'],['access']
Security,// X86InterleavedAccess support only the following interleaved-access group.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:63,access,access,63,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['access'],['access']
Security,"// XSStepButton",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSStepButton.h:3,XSS,XSStepButton,3,test/periodic/XSStepButton.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSStepButton.h,1,['XSS'],['XSStepButton']
Security,// XSStepButton; /* ----- ~XSStepButton ----- */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSStepButton.cxx:3,XSS,XSStepButton,3,test/periodic/XSStepButton.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSStepButton.cxx,2,['XSS'],['XSStepButton']
Security,"// You can also validate by comparing with the RooDSCBShape and RooSDSCBShape; // classes that are floating around in the RooFit user community.; // Some commented-out lines are kept on purpose in this test to make this as; // easy as possible.; //; // #include ""RooDSCBShape.h""; // #include ""RooSDSCBShape.h""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooCrystalBall.cxx:16,validat,validate,16,roofit/roofit/test/testRooCrystalBall.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooCrystalBall.cxx,1,['validat'],['validate']
Security,"// You can implement all the usual fixture class members here.; // To access the test parameter, call GetParam() from class; // TestWithParam<T>.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/test_Job.cxx:70,access,access,70,roofit/multiprocess/test/test_Job.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/test_Job.cxx,1,['access'],['access']
Security,// Zero-size loads and stores do not access memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:37,access,access,37,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,1,['access'],['access']
Security,"// [A|B].Start points to the first accessed byte under base [A|B].; // [A|B].End points to the last accessed byte, plus one.; // There is no conflict when the intervals are disjoint:; // NoConflict = (B.Start >= A.End) || (A.Start >= B.End); //; // bound0 = (B.Start < A.End); // bound1 = (A.Start < B.End); // IsConflict = bound0 & bound1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:35,access,accessed,35,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,2,['access'],['accessed']
Security,"// [M3] and [B3] say that, if the target is protected in N, we grant; // access if the access occurs in a friend or member of some class P; // that's a subclass of N and where the target has some natural; // access in P. The 'member' aspect is easy to handle because P; // would necessarily be one of the effective-context records, and we; // address that above. The 'friend' aspect is completely ridiculous; // to implement because there are no restrictions at all on P; // *unless* the [class.protected] restriction applies. If it does,; // however, we should ignore whether the naming class is a friend,; // and instead rely on whether any potential P is a friend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:73,access,access,73,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,3,['access'],['access']
Security,"// [class.mfct.non-static]p3:; // ...is used in the body of a non-static member function of class X,; // if name lookup (3.4.1) resolves the name in the id-expression to a; // non-static non-type member of some class C [...]; // ...if C is not X or a base class of X, the class member access expression; // is ill-formed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:285,access,access,285,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['access'],['access']
Security,"// [cpp.cond]p4:; // Prior to evaluation, macro invocations in the list of preprocessing; // tokens that will become the controlling constant expression are replaced; // (except for those macro names modified by the 'defined' unary operator),; // just as in normal text. If the token 'defined' is generated as a result; // of this replacement process or use of the 'defined' unary operator does; // not match one of the two specified forms prior to macro replacement, the; // behavior is undefined.; // This isn't an idle threat, consider this program:; // #define FOO; // #define BAR defined(FOO); // #if BAR; // ...; // #else; // ...; // #endif; // clang and gcc will pick the #if branch while Visual Studio will take the; // #else branch. Emit a warning about this undefined behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:522,threat,threat,522,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,1,['threat'],['threat']
Security,// [dcl.decomp]p3:; // The unqualified-id get is looked up in the scope of E by class member; // access lookup ...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:97,access,access,97,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['access'],['access']
Security,"// [distinct, filename, directory, checksumkind, checksum]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:35,checksum,checksumkind,35,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,2,['checksum'],"['checksum', 'checksumkind']"
Security,"// [returned ptr value - sizeof(size_t) * 2 : same + sizeof(size_t) [ -> Requested alignment; // [returned ptr value - sizeof(size_t) : same + sizeof(size_t) [ -> Offset between the return ptr value and the allocated start; // [returned ptr value : same + size [ -> Real data start; // [returned ptr value + size : same + 1 [ -> MEM_MAGIC / Integrity marker; //; // Per C++ standard 3.11 Alignment [basic.align]:; // Every alignment value shall be a non-negative integral power of two.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/newdelete/src/NewDelete.cxx:341,Integrity,Integrity,341,core/newdelete/src/NewDelete.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/newdelete/src/NewDelete.cxx,1,['Integrity'],['Integrity']
Security,// ^ TODO: Implement random access methods.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:28,access,access,28,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['access'],['access']
Security,// __linux__; // validate that the annotation refers to an already existing memory; // definition,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp:17,validat,validate,17,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetFile.cpp,1,['validat'],['validate']
Security,"// __shared__ variables are odd. Shadows do get created, but; // they are not registered with the CUDA runtime, so they; // can't really be used to access their device-side; // counterparts. It's not clear yet whether it's nvcc's bug or; // a feature, but we've got to do the same for compatibility.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:148,access,access,148,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,1,['access'],['access']
Security,// __va_start on Windows does not validate the parameter qualifiers,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:34,validat,validate,34,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['validat'],['validate']
Security,// `SubExpr` and its parent logic operator might be part of different basic; // blocks. We try to access the value that is assigned to `SubExpr` in the; // corresponding environment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp:98,access,access,98,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp,1,['access'],['access']
Security,"// `originalFunc` is the real formula and `cleanedFunc` is the; // sanitized version that will not confuse the TF1NormSum; // constructor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:67,sanitiz,sanitized,67,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['sanitiz'],['sanitized']
Security,"// `prev` accesses offsets [PrevDistFromBase, PrevReadEnd).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:10,access,accesses,10,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,1,['access'],['accesses']
Security,"// a copy of fA is made. It can be accessed inside the loop; // without having to take care that the sparse structure of *fA; // otherwise, *fA may be accidentally destroyed by asking; // for an element which is zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx:35,access,accessed,35,hist/unfold/src/TUnfoldSys.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx,1,['access'],['accessed']
Security,"// a couple of globals for access testing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/advancedcpp.cxx:27,access,access,27,bindings/pyroot/cppyy/cppyy/test/advancedcpp.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/advancedcpp.cxx,2,['access'],['access']
Security,"// a global histogram object, which will be accessed both by mhs and mhs1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/threads.cxx:44,access,accessed,44,test/threads.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/threads.cxx,2,['access'],['accessed']
Security,"// a) If T is in the list of [previously hashed types], use the letter; // 'R' as the marker",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:41,hash,hashed,41,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,1,['hash'],['hashed']
Security,"// access (read-write) mode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx:3,access,access,3,io/io/src/TMapFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx,2,['access'],['access']
Security,"// access Execute() method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RDrawable.hxx:3,access,access,3,graf2d/gpadv7/inc/ROOT/RDrawable.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RDrawable.hxx,1,['access'],['access']
Security,"// access Parameter by Name to set limits...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/test/MnSim/DemoGaussSim.cxx:3,access,access,3,math/minuit2/test/MnSim/DemoGaussSim.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/test/MnSim/DemoGaussSim.cxx,1,['access'],['access']
Security,"// access PopulateMenu method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RDrawable.hxx:3,access,access,3,graf2d/gpadv7/inc/ROOT/RDrawable.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RDrawable.hxx,1,['access'],['access']
Security,"// access SetDrawableVersion and AttrMap",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RDrawable.hxx:3,access,access,3,graf2d/gpadv7/inc/ROOT/RDrawable.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RDrawable.hxx,1,['access'],['access']
Security,"// access member to avoid unnecessarily creating fit result if wasnt needed; // create a new subpad and draw fitResult on it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooHypoSpace.cxx:3,access,access,3,roofit/xroofit/src/xRooHypoSpace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooHypoSpace.cxx,1,['access'],['access']
Security,"// access methods",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MinuitParameter.h:3,access,access,3,math/minuit2/inc/Minuit2/MinuitParameter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MinuitParameter.h,1,['access'],['access']
Security,"// access single element - assume tensor dim is 2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuTensor.h:3,access,access,3,tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuTensor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuTensor.h,2,['access'],['access']
Security,"// access single element - assume tensor dim is 3. First index i is always the major independent of row-major or; // column major row- major I - J - K . Column- major is J - K - I",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuTensor.h:3,access,access,3,tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuTensor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu/CpuTensor.h,1,['access'],['access']
Security,"// access target-specific GPU grid values that must be consistent between; // host RTL (plugin), deviceRTL and clang.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:3,access,access,3,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['access'],['access']
Security,"// access the extra data item which is an absolute pointer to the RTTI",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:3,access,access,3,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,1,['access'],['access']
Security,"// access to C++ pointer and type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.h:3,access,access,3,bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.h,1,['access'],['access']
Security,"// access to errors in column-wise representation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnUserParameterState.cxx:3,access,access,3,math/minuit2/src/MnUserParameterState.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnUserParameterState.cxx,1,['access'],['access']
Security,"// access to event information that needs method-specific information",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBase.h:3,access,access,3,tmva/tmva/inc/TMVA/MethodBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBase.h,1,['access'],['access']
Security,"// access to input data",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DataSetManager.h:3,access,access,3,tmva/tmva/inc/TMVA/DataSetManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DataSetManager.h,1,['access'],['access']
Security,"// access to parameters (row-wise)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnApplication.cxx:3,access,access,3,math/minuit2/src/MnApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnApplication.cxx,2,['access'],['access']
Security,"// access to parameters and errors in column-wise representation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnApplication.h:3,access,access,3,math/minuit2/inc/Minuit2/MnApplication.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnApplication.h,3,['access'],['access']
Security,"// access to parameters in column-wise representation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnUserParameterState.cxx:3,access,access,3,math/minuit2/src/MnUserParameterState.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnUserParameterState.cxx,1,['access'],['access']
Security,"// access to single Parameter",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnApplication.h:3,access,access,3,math/minuit2/inc/Minuit2/MnApplication.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnApplication.h,4,['access'],['access']
Security,"// access to single Parameter i",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnUserParameterState.cxx:3,access,access,3,math/minuit2/src/MnUserParameterState.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnUserParameterState.cxx,1,['access'],['access']
Security,"// access to underlying object: cast and dereferencing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/include/CPyCppyy/DispatchPtr.h:3,access,access,3,bindings/pyroot/cppyy/CPyCppyy/include/CPyCppyy/DispatchPtr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/include/CPyCppyy/DispatchPtr.h,1,['access'],['access']
Security,"// access unfolding results",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfold.h:3,access,access,3,hist/unfold/inc/TUnfold.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfold.h,1,['access'],['access']
Security,"// access various properties of the result; /// get matrix connecting input and output changes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfold.h:3,access,access,3,hist/unfold/inc/TUnfold.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfold.h,1,['access'],['access']
Security,// accessing a piece of a volatile complex is a side-effect.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:3,access,accessing,3,interpreter/llvm-project/clang/lib/AST/Expr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp,1,['access'],['accessing']
Security,"// accessing array elements should be OK; //if ((fMajorFormula->GetMultiplicity() != 0) || (fMinorFormula->GetMultiplicity() != 0)) {; // MakeZombie();; // Error(""TreeIndex"",""Cannot build the index with major=%s, minor=%s that cannot be arrays"",fMajorName.Data(), fMinorName.Data());; // return;; //}",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeIndex.cxx:3,access,accessing,3,tree/treeplayer/src/TTreeIndex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeIndex.cxx,1,['access'],['accessing']
Security,"// accessor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/FitterBase.h:3,access,accessor,3,tmva/tmva/inc/TMVA/FitterBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/FitterBase.h,1,['access'],['accessor']
Security,"// accessor to be implemented by the derived classes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiRootSolver.h:3,access,accessor,3,math/mathmore/src/GSLMultiRootSolver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiRootSolver.h,1,['access'],['accessor']
Security,"// accessor to single instance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Tools.h:3,access,accessor,3,tmva/tmva/inc/TMVA/Tools.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Tools.h,1,['access'],['accessor']
Security,"// accessors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/Cylindrical3D.h:3,access,accessors,3,math/genvector/inc/Math/GenVector/Cylindrical3D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/Cylindrical3D.h,16,['access'],['accessors']
Security,"// accessors for Minuit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodCuts.h:3,access,accessors,3,tmva/tmva/inc/TMVA/MethodCuts.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodCuts.h,1,['access'],['accessors']
Security,"// accessors for random and importance sampling",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DataSet.h:3,access,accessors,3,tmva/tmva/inc/TMVA/DataSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DataSet.h,1,['access'],['accessors']
Security,"// accessors; // accessors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Interval.h:3,access,accessors,3,tmva/tmva/inc/TMVA/Interval.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Interval.h,2,['access'],['accessors']
Security,"// accessors; // general",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DataSetInfo.h:3,access,accessors,3,tmva/tmva/inc/TMVA/DataSetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DataSetInfo.h,1,['access'],['accessors']
Security,"// actual logon security level",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/TAuthenticate.h:16,secur,security,16,net/auth/inc/TAuthenticate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/TAuthenticate.h,1,['secur'],['security']
Security,"// add HMAC checksum for string send to client",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:12,checksum,checksum,12,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['checksum'],['checksum']
Security,"// add file to hash table",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/mpi/src/TMPIFile.cxx:15,hash,hash,15,io/mpi/src/TMPIFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/mpi/src/TMPIFile.cxx,1,['hash'],['hash']
Security,"// address of security identifier",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx:14,secur,security,14,core/winnt/src/TWinNTSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx,1,['secur'],['security']
Security,"// address of security identifier to query",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx:14,secur,security,14,core/winnt/src/TWinNTSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx,1,['secur'],['security']
Security,"// address of size of security identifier",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx:22,secur,security,22,core/winnt/src/TWinNTSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx,1,['secur'],['security']
Security,"// after Process we finish working with parameters data,; // if necessary, user can try to access resultset of statement",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/sql/odbc/src/TODBCStatement.cxx:91,access,access,91,sql/odbc/src/TODBCStatement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/sql/odbc/src/TODBCStatement.cxx,1,['access'],['access']
Security,"// after a successful Authenticate call; // points to related security context",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TSocket.h:22,Authenticat,Authenticate,22,net/net/inc/TSocket.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TSocket.h,4,"['Authenticat', 'secur']","['Authenticate', 'security']"
Security,"// algorithm 1, future work can add in more recent encryption schemes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:51,encrypt,encryption,51,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['encrypt'],['encryption']
Security,"// allow RooSpHarmonic access...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/inc/RooLegendre.h:23,access,access,23,roofit/roofitmore/inc/RooLegendre.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/inc/RooLegendre.h,1,['access'],['access']
Security,"// allow access at the class level (always add after setting instance level)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx:9,access,access,9,bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx,1,['access'],['access']
Security,"// allow access at the instance level",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx:9,access,access,9,bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx,1,['access'],['access']
Security,"// allow direct access for better speed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Volume.h:16,access,access,16,tmva/tmva/inc/TMVA/Volume.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Volume.h,1,['access'],['access']
Security,"// and now check if all the elements are equal.; // Sadly, we can't use std::equals since these are random access iterators.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:107,access,access,107,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['access'],['access']
Security,"// and now remove anything that's marked floating; // do to bug in remove have to ensure not using the hash map otherwise will be doing an invalid read after the; // deletion of the owned pars",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooHypoSpace.cxx:103,hash,hash,103,roofit/xroofit/src/xRooHypoSpace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooHypoSpace.cxx,1,['hash'],['hash']
Security,"// and security contexts",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:7,secur,security,7,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['secur'],['security']
Security,// and that def is now our defining access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:36,access,access,36,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['access'],['access']
Security,"// and the referenced type (via the [below attributes]); // FIXME: This seems overly restrictive, and causes hash mismatches; // there's a decl/def difference in the containing type of a; // ptr_to_member_type, but it's what DWARF says, for some reason.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:109,hash,hash,109,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,1,['hash'],['hash']
Security,"// and the saved the password",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:21,password,password,21,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['password'],['password']
Security,"// append sanitized term to `fullFormula`",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:10,sanitiz,sanitized,10,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['sanitiz'],['sanitized']
Security,"// apply pruning validation sample to a decision tree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DecisionTree.h:17,validat,validation,17,tmva/tmva/inc/TMVA/DecisionTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DecisionTree.h,1,['validat'],['validation']
Security,"// arg2 = ""--allow-file-access-from-files"";",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/src/RCefWebDisplayHandle.cxx:24,access,access-from-files,24,gui/cefdisplay/src/RCefWebDisplayHandle.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/src/RCefWebDisplayHandle.cxx,1,['access'],['access-from-files']
Security,"// assume this is a buffer access if the size is known; otherwise assume string",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx:27,access,access,27,bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,1,['access'],['access']
Security,"// at this point validation of alias and colName has already happened, we trust that; // this is a new, valid alias.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx:17,validat,validation,17,tree/dataframe/src/RDFColumnRegister.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFColumnRegister.cxx,1,['validat'],['validation']
Security,"// atomicrmw conceptually includes both a load and store from; // the same location.; // As with a store, the location being accessed is not captured,; // but the value being stored is.; // Volatile stores make the address observable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:125,access,accessed,125,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,1,['access'],['accessed']
Security,"// attribute shorthands: rn=does not access; // memory,ro=only reads from memory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DXILEmitter.cpp:37,access,access,37,interpreter/llvm-project/llvm/utils/TableGen/DXILEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DXILEmitter.cpp,1,['access'],['access']
Security,"// authority/userinfo: user@password, ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TUri.h:28,password,password,28,core/base/inc/TUri.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TUri.h,1,['password'],['password']
Security,"// benchmark access by index",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/tcollbm.cxx:13,access,access,13,test/tcollbm.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/tcollbm.cxx,1,['access'],['access']
Security,"// benchmark access by name",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/tcollbm.cxx:13,access,access,13,test/tcollbm.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/tcollbm.cxx,1,['access'],['access']
Security,"// bounding box for scene (axis aligned) - lazy update - use BoundingBox() to access",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLSceneBase.h:78,access,access,78,graf3d/gl/inc/TGLSceneBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLSceneBase.h,1,['access'],['access']
Security,"// cache input layer and output neuron for fast access",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodANNBase.cxx:48,access,access,48,tmva/tmva/src/MethodANNBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodANNBase.cxx,1,['access'],['access']
Security,"// cache pointers to synapses for fast access, the order matters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodANNBase.cxx:39,access,access,39,tmva/tmva/src/MethodANNBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodANNBase.cxx,1,['access'],['access']
Security,"// calculate exposed region",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEdit.cxx:13,expose,exposed,13,gui/gui/src/TGTextEdit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEdit.cxx,1,['expose'],['exposed']
Security,"// calculate hash for ki + m2_digest;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:13,hash,hash,13,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['hash'],['hash']
Security,"// calculate hash for ko + msg;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:13,hash,hash,13,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['hash'],['hash']
Security,"// calculate hash of sessionKey + key;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:13,hash,hash,13,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['hash'],['hash']
Security,"// calculate the normalization factor for a pruning validation sample",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DecisionTree.h:52,validat,validation,52,tmva/tmva/inc/TMVA/DecisionTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DecisionTree.h,1,['validat'],['validation']
Security,"// calculate the number of events used for validation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBatchGenerator.hxx:43,validat,validation,43,tmva/tmva/inc/TMVA/RBatchGenerator.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBatchGenerator.hxx,1,['validat'],['validation']
Security,"// calculate the weighted error using the pruning validation sample",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DecisionTree.cxx:50,validat,validation,50,tmva/tmva/src/DecisionTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DecisionTree.cxx,1,['validat'],['validation']
Security,"// can also use operator[] to access elements",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/tcollex.cxx:30,access,access,30,test/tcollex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/tcollex.cxx,1,['access'],['access']
Security,"// canOptimizeTLSDFormToXForm - Optimize TLS accesses when an ADD_TLS; // instruction is present. An ADD_TLS instruction, followed by a D-Form memory; // operation, can be optimized to use an X-Form load or store, allowing the; // ADD_TLS node to be removed completely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:45,access,accesses,45,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['access'],['accesses']
Security,"// case TStreamerInfo::kSTLvarp: // Variable size array of STL containers.; // {; // TMemberStreamer *pstreamer = compinfo[i]->fStreamer;; // TClass *cl = compinfo[i]->fClass;; // ROOT::NewArrFunc_t arraynew = cl->GetNewArray();; // ROOT::DelArrFunc_t arraydel = cl->GetDeleteArray();; // UInt_t start,count;; // // Version_t v =; // b.ReadVersion(&start, &count, cle);; // if (pstreamer == 0) {; // Int_t size = cl->Size();; // Int_t imethod = compinfo[i]->fMethod+eoffset;; // DOLOOP {; // char **contp = (char**)(arr[k]+ioffset);; // const Int_t *counter = (Int_t*)(arr[k]+imethod);; // const Int_t sublen = (*counter);; // for(int j=0;j<compinfo[i]->fLength;++j) {; // if (arraydel) arraydel(contp[j]);; // contp[j] = 0;; // if (sublen<=0) continue;; // if (arraynew) {; // contp[j] = (char*)arraynew(sublen, 0);; // char *cont = contp[j];; // for(int k=0;k<sublen;++k) {; // cl->Streamer( cont, b );; // cont += size;; // }; // } else {; // // Can't create an array of object; // Error(""ReadBuffer"",""The element %s::%s type %d (%s) can be read because of the class does not have access to new %s[..]\n"",; // GetName(),aElement->GetFullName(),kase,aElement->GetTypeName(),GetName());; // void *cont = cl->New();; // for(int k=0;k<sublen;++k) {; // cl->Streamer( cont, b );; // }; // }; // }; // }; // } else {; // DOLOOP{(*pstreamer)(b,arr[k]+ioffset,compinfo[i]->fLength);}; // }; // b.CheckByteCount(start,count,aElement->GetFullName());; // }; // continue;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoReadBuffer.cxx:1084,access,access,1084,io/io/src/TStreamerInfoReadBuffer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoReadBuffer.cxx,1,['access'],['access']
Security,// cf top comment.; // Compute the offset of the last element to be accessed: size-1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:68,access,accessed,68,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,1,['access'],['accessed']
Security,"// chance access to 666, so if the lock is expired, other users can remove it; // (attention, currently only supported for local files systems)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TLockFile.cxx:10,access,access,10,io/io/src/TLockFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TLockFile.cxx,1,['access'],['access']
Security,"// check that colors really changing, using hash",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx:44,hash,hash,44,gui/webgui6/src/TWebCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx,1,['hash'],['hash']
Security,"// checksum did not found, do not try again",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,checksum,checksum,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['checksum'],['checksum']
Security,"// clang-format off; /**; * \class ROOT::Experimental::RNTupleDS; * \ingroup dataframe; * \brief The RDataSource implementation for RNTuple. It lets RDataFrame read RNTuple data.; *; * An RDataFrame that reads RNTuple data can be constructed using FromRNTuple().; *; * For each column containing an array or a collection, a corresponding column `#colname` is available to access; * `colname.size()` without reading and deserializing the collection values.; *; **/; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:372,access,access,372,tree/dataframe/src/RNTupleDS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx,1,['access'],['access']
Security,"// clang-format off; /**; * \class ROOT::RDataFrame; * \ingroup dataframe; * \brief ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available; on their machines completely transparently.<br>; Skip to the [class reference](#reference) or keep reading for the user guide. In a nutshell:; ~~~{.cpp}; ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; myHisto->Draw(); // Event loop is run here, upon first access to a result; ~~~. Calculations are expressed in terms of a type-safe *functional chain of actions and transformations*, RDataFrame takes; care of their execution. The implementation automatically puts in place several low level optimisations such as; multi-thread parallelization and caching. \htmlonly; <a href=""https://doi.org/10.5281/zenodo.260230""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.260230.svg""; alt=""DOI""></a>; \endhtmlonly. ## For the impatient user; You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python. ## Table of Contents; - [Cheat sheet](\ref cheatsheet); - [Introduction](\ref introduction); - [Crash course](\ref crash-course); - [Working with collections](\ref collections); - [Transformations: manipulating data](\ref transformations); - [Actions: getting results](\ref actions); - [Distributed execution in Python](\ref distrdf); - [Performance tips and parallel execution](\ref parallel-execution); - [More features](\ref more-features); - [Systematic variations](\ref systematics); - [RDataFrame objects as function arguments and return values](\ref rnode); - [Storing RDataFrame objects in",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:779,access,access,779,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['access'],['access']
Security,"// clang-format off; /**; * \class TTreeReaderValue; * \ingroup treeplayer; * \brief An interface for reading values stored in ROOT columnar datasets; *; * The TTreeReaderValue is a type-safe tool to be used in association with a TTreeReader; * to access the values stored in TTree, TNtuple and TChain datasets.; * TTreeReaderValue can be also used to access collections such as `std::vector`s or TClonesArray; * stored in columnar datasets but it is recommended to use TTreeReaderArray instead as it offers; * several advantages.; *; * See the documentation of TTreeReader for more details and examples.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx:248,access,access,248,tree/treeplayer/src/TTreeReaderValue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx,2,['access'],['access']
Security,"// clang-format off; /**; \class ROOT::Experimental::Internal::RMiniFileReader; \ingroup NTuple; \brief Read RNTuple data blocks from a TFile container, provided by a RRawFile. A RRawFile is used for the byte access. The class implements a minimal subset of TFile, enough to extract; RNTuple data keys.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx:209,access,access,209,tree/ntuple/v7/inc/ROOT/RMiniFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx,1,['access'],['access']
Security,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPageStorage; \ingroup NTuple; \brief Common functionality of an ntuple storage for both reading and writing. The RPageStore provides access to a storage container that keeps the bits of pages and clusters comprising; an ntuple. Concrete implementations can use a TFile, a raw file, an object store, and so on.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:197,access,access,197,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['access'],['access']
Security,"// clang-format off; /**; \class ROOT::Experimental::RNTupleDirectAccessView; \ingroup NTuple; \brief A view variant that provides direct access to the I/O buffers. Only works for mappable fields.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleView.hxx:138,access,access,138,tree/ntuple/v7/inc/ROOT/RNTupleView.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleView.hxx,1,['access'],['access']
Security,"// clang-format off; /**; \class ROOT::Experimental::RNTupleProcessor; \ingroup NTuple; \brief Interface for iterating over entries of RNTuples and vertically concatenated RNTuples (chains). Example usage (see ntpl012_processor.C for a full example):. ~~~{.cpp}; #include <ROOT/RNTupleProcessor.hxx>; using ROOT::Experimental::RNTupleProcessor;; using ROOT::Experimental::RNTupleOpenSpec;. std::vector<RNTupleOpenSpec> ntuples = {{""ntuple1"", ""ntuple1.root""}, {""ntuple2"", ""ntuple2.root""}};; auto processor = RNTupleProcessor::CreateChain(ntuples);. for (const auto &entry : processor) {; std::cout << ""pt = "" << *entry.GetPtr<float>(""pt"") << std::endl;; }; ~~~. An RNTupleProcessor is created by providing one or more RNTupleOpenSpecs, each of which contains the name and storage; location of a single RNTuple. The RNTuples are processed in the order in which they were provided. The RNTupleProcessor constructor also (optionally) accepts an RNTupleModel, which determines which fields should be; read. If no model is provided, a default model based on the descriptor of the first specified RNTuple will be used.; If a field that was present in the first RNTuple is not found in a subsequent one, an error will be thrown. The RNTupleProcessor provides an iterator which gives access to the REntry containing the field data for the current; entry. Additional bookkeeping information can be obtained through the RNTupleProcessor itself.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleProcessor.hxx:1275,access,access,1275,tree/ntuple/v7/inc/ROOT/RNTupleProcessor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleProcessor.hxx,1,['access'],['access']
Security,"// clang-format off; /**; \class TTreeReader; \ingroup treeplayer; \brief A simple, robust and fast interface to read values from ROOT columnar datasets such as TTree, TChain or TNtuple. TTreeReader is associated to TTreeReaderValue and TTreeReaderArray which are handles to concretely; access the information in the dataset. Example code can be found in; - tutorials/tree/hsimpleReader.C; - tutorials/tree/h1analysisTreeReader.C; - <a href=""https://github.com/root-project/roottest/tree/master/root/tree/reader"">This example</a>. You can generate a skeleton of `TTreeReaderValue<T>` and `TTreeReaderArray<T>` declarations; for all of a tree's branches using `TTree::MakeSelector()`. Roottest contains an; <a href=""https://github.com/root-project/roottest/tree/master/root/tree/reader"">example</a>; showing the full power. A simpler analysis example can be found below: it histograms a function of the px and py branches. ~~~{.cpp}; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C). #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"". void hsimpleReader() {; // Create a histogram for the values we read.; TH1F(""h1"", ""ntuple"", 100, -4, 4);. // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");. // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);. // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");. // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }. myHist->Draw();; }; ~~~. A more complete example including error handling and a few combinat",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx:287,access,access,287,tree/treeplayer/src/TTreeReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx,1,['access'],['access']
Security,"// clang-format off; /**; \class TVirtualCollectionProxy; \brief Defines a common interface to inspect/change the contents of an object that represents a collection. Specifically, an object of a class that derives from TVirtualCollectionProxy relays accesses to any object that; matches the proxied collection type.; The interface provides two families of functions: (i) for direct manipulation, e.g. `Insert()` or `At()`; and; (ii) iterator-based, e.g. `GetFunctionCreateIterators()` or `GetFunctionNext()`.; TVirtualCollectionProxy objects are stateful; in particular, many functions require to set the object to operate; on via `PushProxy()` / `PopProxy()`. The `TPushPop` RAII class is provided for convenience.; A collection proxy for a given class can be permanently set using `TClass::CopyCollectionProxy()`.; The `Generate()` function should be overridden in derived classes to return a clean object of the most-derived class.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TVirtualCollectionProxy.h:250,access,accesses,250,core/cont/inc/TVirtualCollectionProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TVirtualCollectionProxy.h,1,['access'],['accesses']
Security,"// clang-format off; /// Check whether the result has already been computed; ///; /// ~~~{.cpp}; /// auto res = df.Count();; /// res.IsReady(); // false, access will trigger event loop; /// std::cout << *res << std::endl; // triggers event loop; /// res.IsReady(); // true; /// ~~~; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:154,access,access,154,tree/dataframe/inc/ROOT/RResultPtr.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx,1,['access'],['access']
Security,"// clang-format off; /// EReadWrite Enumerator; /// | Enum Constant | Description |; /// |-------------|--------------------|; /// | kBase | Base class element |; /// | kOffsetL | Fixed size array |; /// | kOffsetP | Pointer to object |; /// | kCounter | Counter for array size |; /// | kCharStar | Pointer to array of char |; /// | kLegacyChar | Equal to TDataType's kchar |; /// | kBits | TObject::fBits in case of a referenced object |; /// | kObject | Class derived from TObject, or for TStreamerSTL::fCtype non-pointer elements |; /// | kObjectp | Class* derived from TObject and with comment field //->Class, or for TStreamerSTL::fCtype: pointer elements |; /// | kObjectP | Class* derived from TObject and with NO comment field //->Class |; /// | kAny | Class not derived from TObject |; /// | kAnyp | Class* not derived from TObject with comment field //->Class |; /// | kAnyP | Class* not derived from TObject with NO comment field //->Class |; /// | kAnyPnoVT | Class* not derived from TObject with NO comment field //->Class and Class has NO virtual table |; /// | kSTLp | Pointer to STL container |; /// | kTString | TString, special case |; /// | kTObject | TObject, special case |; /// | kTNamed | TNamed , special case |; /// | kCache | Cache the value in memory than is not part of the object but is accessible via a SchemaRule |; /// | kNoType | Indicator that we don't know the current type because the member does not exist in memory |; /// | kUnsupportedConversion | The member type onfile and in memory can not be converted |; /// | kUnset | default value |",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TVirtualStreamerInfo.h:1316,access,accessible,1316,core/meta/inc/TVirtualStreamerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TVirtualStreamerInfo.h,1,['access'],['accessible']
Security,"// clang-format off; /// Trigger the event loop of multiple RDataFrames concurrently; /// \param[in] handles A vector of RResultHandles; /// \return The number of distinct computation graphs that have been processed; ///; /// This function triggers the event loop of all computation graphs which relate to the; /// given RResultHandles. The advantage compared to running the event loop implicitly by accessing the; /// RResultPtr is that the event loops will run concurrently. Therefore, the overall; /// computation of all results is generally more efficient.; /// It should be noted that user-defined operations (e.g., Filters and Defines) of the different RDataFrame graphs are assumed to be safe to call concurrently.; ///; /// ~~~{.cpp}; /// ROOT::RDataFrame df1(""tree1"", ""file1.root"");; /// auto r1 = df1.Histo1D(""var1"");; ///; /// ROOT::RDataFrame df2(""tree2"", ""file2.root"");; /// auto r2 = df2.Sum(""var2"");; ///; /// // RResultPtr -> RResultHandle conversion is automatic; /// ROOT::RDF::RunGraphs({r1, r2});; /// ~~~; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:400,access,accessing,400,tree/dataframe/inc/ROOT/RDFHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx,1,['access'],['accessing']
Security,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Book execution of a custom action using a user-defined helper object.; /// \tparam FirstColumn The type of the first column used by this action. Inferred together with OtherColumns if not present.; /// \tparam OtherColumns A list of the types of the other columns used by this action; /// \tparam Helper The type of the user-defined helper. See below for the required interface it should expose.; /// \param[in] helper The Action Helper to be scheduled.; /// \param[in] columns The names of the columns on which the helper acts.; /// \return the result of the helper wrapped in a RResultPtr.; ///; /// This method books a custom action for execution. The behavior of the action is completely dependent on the; /// Helper object provided by the caller. The required interface for the helper is described below (more; /// methods that the ones required can be present, e.g. a constructor that takes the number of worker threads is usually useful):; ///; /// ### Mandatory interface; ///; /// * `Helper` must publicly inherit from `ROOT::Detail::RDF::RActionImpl<Helper>`; /// * `Helper::Result_t`: public alias for the type of the result of this action helper. `Result_t` must be default-constructible.; /// * `Helper(Helper &&)`: a move-constructor is required. Copy-constructors are discouraged.; /// * `std::shared_ptr<Result_t> GetResultPtr() const`: return a shared_ptr to the result of this action (of type; /// Result_t). The RResultPtr returned by Book will point to this object. Note that this method can be called; /// _before_ Initialize(), because the RResultPtr is constructed before the event loop is started.; /// * `void Initialize()`: this method is called once before starting the event-loop. Useful for setup operations.; /// It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper,; /// or copies of it, might be used",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:498,expose,expose,498,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['expose'],['expose']
Security,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column that is updated when the input sample changes.; /// \param[in] name The name of the defined column.; /// \param[in] expression A C++ callable that computes the new value of the defined column.; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// The signature of the callable passed as second argument should be `T(unsigned int slot, const ROOT::RDF::RSampleInfo &id)`; /// where:; /// - `T` is the type of the defined column; /// - `slot` is a number in the range [0, nThreads) that is different for each processing thread. This can simplify; /// the definition of thread-safe callables if you are interested in using parallel capabilities of RDataFrame.; /// - `id` is an instance of a ROOT::RDF::RSampleInfo object which contains information about the sample which is; /// being processed (see the class docs for more information).; ///; /// DefinePerSample() is useful to e.g. define a quantity that depends on which TTree in which TFile is being; /// processed or to inject a callback into the event loop that is only called when the processing of a new sample; /// starts rather than at every entry.; ///; /// The callable will be invoked once per input TTree or once per multi-thread task, whichever is more often.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// ROOT::RDataFrame df{""mytree"", {""sample1.root"",""sample2.root""}};; /// df.DefinePerSample(""weightbysample"",; /// [](unsigned int slot, const ROOT::RDF::RSampleInfo &id); /// { return id.Contains(""sample1"") ? 1.0f : 2.0f; });; /// ~~~; // clang-format on; // TODO we could SFINAE on F's signature to provide friendlier compilation errors in case of signature mismatch",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1151,inject,inject,1151,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['inject'],['inject']
Security,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column.; /// \param[in] name The name of the defined column.; /// \param[in] expression Function, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column.; /// \param[in] columns Names of the columns/branches in input to the producer function.; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// Define a column that will be visible from all subsequent nodes; /// of the functional chain. The `expression` is only evaluated for entries that pass; /// all the preceding filters.; /// A new variable is created called `name`, accessible as if it was contained; /// in the dataset from subsequent transformations/actions.; ///; /// Use cases include:; /// * caching the results of complex calculations for easy and efficient multiple access; /// * extraction of quantities of interest from complex objects; ///; /// An exception is thrown if the name of the new column is already in use in this branch of the computation graph.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // assuming a function with signature:; /// double myComplexCalculation(const RVec<float> &muon_pts);; /// // we can pass it directly to Define; /// auto df_with_define = df.Define(""newColumn"", myComplexCalculation, {""muon_pts""});; /// // alternatively, we can pass the body of the function as a string, as in Filter:; /// auto df_with_define = df.Define(""newColumn"", ""x*x + y*y"");; /// ~~~; ///; /// \note If the body of the string expression contains an explicit `return` statement (even if it is in a nested; /// scope), RDataFrame _will not_ add another one in front of the expression. So this will not work:; /// ~~~{.cpp}; /// df.Define(""x2"", ""Map(v, [](float e) { return e*e; })""); /// ~~~; /// but instead this will:; /// ~~~{.cpp}; /// df.Define(""x",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:794,access,accessible,794,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['access'],['accessible']
Security,"// clang-format on; ////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \tparam ColumnTypes variadic list of branch/column types.; /// \param[in] columnList columns to be cached in memory.; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// This action returns a new `RDataFrame` object, completely detached from; /// the originating `RDataFrame`. The new dataframe only contains the cached; /// columns and stores their content in memory for fast, zero-copy subsequent access.; ///; /// Use `Cache` if you know you will only need a subset of the (`Filter`ed) data that; /// fits in memory and that will be accessed many times.; ///; /// \note Cache will refuse to process columns with names of the form `#columnname`. These are special columns; /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; /// Alias(): `df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""})`.; ///; /// ### Example usage:; ///; /// **Types and columns specified:**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns specified (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_some_cols_df = df.Cache({""col0"", ""col1"", ""col2""});; /// ~~~; ///; /// **Types inferred and columns selected with a regexp (this invocation relies on jitting):**; /// ~~~{.cpp}; /// auto cache_all_cols_df = df.Cache(myRegexp);; /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:562,access,access,562,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,2,['access'],"['access', 'accessed']"
Security,// class DependenceAnalysisPrinterPass; /// Legacy pass manager pass to access dependence information,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:72,access,access,72,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,1,['access'],['access']
Security,"// class RPagePersistentSink; // clang-format off; /**; \class ROOT::Experimental::Internal::RPageSource; \ingroup NTuple; \brief Abstract interface to read data from an ntuple. The page source is initialized with the columns of interest. Alias columns from projected fields are mapped to the; corresponding physical columns. Pages from the columns of interest can then be mapped into memory.; The page source also gives access to the ntuple's meta-data.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:421,access,access,421,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['access'],['access']
Security,"// class TProxyFile; /** @summary Open ROOT file for reading; * @desc Generic method to open ROOT file for reading; * Following kind of arguments can be provided:; * - string with file URL (see example). In node.js environment local file like 'file://hsimple.root' can be specified; * - [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File} instance which let read local files from browser; * - [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer} instance with complete file content; * - [FileProxy]{@link FileProxy} let access arbitrary files via tiny proxy API; * @param {string|object} arg - argument for file open like url, see details; * @return {object} - Promise with {@link TFile} instance when file is opened; * @example; *; * import { openFile } from 'https://root.cern/js/latest/modules/io.mjs';; * let f = await openFile('https://root.cern/js/files/hsimple.root');; * console.log(`Open file ${f.getFileName()}`); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:597,access,access,597,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['access'],['access']
Security,// class coded as async function which returns class handle; // simple extract class and access class.draw method,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:89,access,access,89,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['access'],['access']
Security,"// cmpxchg conceptually includes both a load and store from; // the same location.; // As with a store, the location being accessed is not captured,; // but the value being stored is.; // Volatile stores make the address observable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:123,access,accessed,123,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,1,['access'],['accessed']
Security,"// command_line->AppendSwitch(""allow-file-access-from-files"");; // command_line->AppendSwitch(""disable-web-security"");; // if (fBatch) {; // command_line->AppendSwitch(""disable-gpu"");; // command_line->AppendSwitch(""disable-gpu-compositing"");; // command_line->AppendSwitch(""disable-gpu-sandbox"");; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/src/simple_app.cxx:42,access,access-from-files,42,gui/cefdisplay/src/simple_app.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/src/simple_app.cxx,2,"['access', 'secur']","['access-from-files', 'security']"
Security,"// command_line->AppendSwitch(""allow-file-access-from-files"");; // command_line->AppendSwitch(""disable-web-security"");; // if (fLastBatch) {; // command_line->AppendSwitch(""disable-webgl"");; // command_line->AppendSwitch(""disable-gpu"");; // command_line->AppendSwitch(""disable-gpu-compositing"");; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/src/simple_app.cxx:42,access,access-from-files,42,gui/cefdisplay/src/simple_app.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/src/simple_app.cxx,2,"['access', 'secur']","['access-from-files', 'security']"
Security,"// complete class for access in constOptimizeTestStatistic",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/RooAbsL.cxx:22,access,access,22,roofit/roofitcore/src/TestStatistics/RooAbsL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/RooAbsL.cxx,1,['access'],['access']
Security,"// concatenate the RNTuple anchor with its checksum",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx:43,checksum,checksum,43,tree/ntuple/v7/src/RMiniFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx,1,['checksum'],['checksum']
Security,// console.error(`Fail to find streamer info with check sum ${ver.checksum} version ${ver.val}`);,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:66,checksum,checksum,66,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['checksum'],['checksum']
Security,"// copy command line arguments, can be later accessed via Argc() and Argv()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:45,access,accessed,45,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['access'],['accessed']
Security,// copying constructors (can use default ones); /**; Access the parameter values; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/ParamFunction.h:53,Access,Access,53,math/mathmore/inc/Math/ParamFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/ParamFunction.h,1,['Access'],['Access']
Security,// create a hash table of event handlers for each element/event pair,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js:12,hash,hash,12,interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js,3,['hash'],['hash']
Security,// create a hash table of event types for the element,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js:12,hash,hash,12,interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js,3,['hash'],['hash']
Security,// create hashes for the edge from the vertices,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:10,hash,hashes,10,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,1,['hash'],['hashes']
Security,"// create semaphore to synchronize access (should use read/write lock)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx:35,access,access,35,io/io/src/TMapFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx,1,['access'],['access']
Security,"// currently dont have a way to access the covariance ""dcovar"" which is a metric from iterative; // covariance method that is used by minuit2 to say if the covariance is accurate or not; // See MinimumError.h: IsAccurate if Dcovar < 0.1; // Note that if strategy>=2 or (strategy=1 and Dcovar>0.05) then hesse will be forced to be run (see; // VariadicMetricBuilder) So only in Strategy=0 can you skip hesse (even if SetParabErrors false).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooFit.cxx:32,access,access,32,roofit/xroofit/src/xRooFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooFit.cxx,1,['access'],['access']
Security,"// daemon access rules",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:10,access,access,10,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['access'],['access']
Security,"// data accessors for external functions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodCFMlpANN.h:8,access,accessors,8,tmva/tmva/inc/TMVA/MethodCFMlpANN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodCFMlpANN.h,1,['access'],['accessors']
Security,"// data members (by access, plus enums)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/inc/TDocParser.h:20,access,access,20,html/inc/TDocParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/inc/TDocParser.h,1,['access'],['access']
Security,"// default security",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/browsable/src/RSysFile.cxx:11,secur,security,11,gui/browsable/src/RSysFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/browsable/src/RSysFile.cxx,2,['secur'],['security']
Security,"// default: multi-level KV with hashed [ad]keys",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h:32,hash,hashed,32,tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h,1,['hash'],['hashed']
Security,// delete the event handler from the hash table,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js:37,hash,hash,37,interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js,3,['hash'],['hash']
Security,"// deny write access for group and world",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:14,access,access,14,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['access'],['access']
Security,"// direct accessors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBase.h:10,access,accessors,10,tmva/tmva/inc/TMVA/MethodBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBase.h,1,['access'],['accessors']
Security,"// direct interpreter access -------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:22,access,access,22,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,3,['access'],['access']
Security,"// direct user access; there are two calls here:; // - explicit pythonization: won't fall through to the base classes and is preferred if present; // - normal pythonization: only called if explicit isn't present, falls through to base classes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx:15,access,access,15,bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,1,['access'],['access']
Security,"// do not expose non-public methods as the Cling wrappers as those won't compile",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx:10,expose,expose,10,bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx,1,['expose'],['expose']
Security,"// do nothing; // Otherwise, check access to friends and make them visible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:35,access,access,35,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['access'],['access']
Security,"// do only HESSE. need access to minimizer. For the moment re-run fitting with hesse options",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:23,access,access,23,hist/hist/src/TBackCompFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx,1,['access'],['access']
Security,"// do only MINOS. need access to minimizer. For the moment re-run fitting with minos options",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:23,access,access,23,hist/hist/src/TBackCompFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx,1,['access'],['access']
Security,"// do we have matching against the proto_name (or proto_pattern) attribute and if yes - select or veto; // The following selects functions on whether the requested prototype exactly matches the; // prototype issued by SelectionRules::GetFunctionPrototype which relies on; // ParmVarDecl::getType()->getAsString(); // to get the type names. Currently, this does not print the prototype in the usual; // human (written) forms. For example:; // For Hash have prototype: '(const class TString &)'; // For Hash have prototype: '(const class TString*)'; // For Hash have prototype: '(const char*)'; // In addition, the const can legally be in various place in the type name and thus; // a string based match will be hard to work out (it would need to normalize both; // the user input string and the clang provided string).; // Using lookup form cling would be probably be a better choice.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/BaseSelectionRule.cxx:446,Hash,Hash,446,core/dictgen/src/BaseSelectionRule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/BaseSelectionRule.cxx,3,['Hash'],['Hash']
Security,"// does authentication key really required",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:8,authenticat,authentication,8,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['authenticat'],['authentication']
Security,"// don't call DeleteWindow() here since that will cause access; // to the deleted dialog in the WaitFor() method (see ctor)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFontDialog.cxx:56,access,access,56,gui/gui/src/TGFontDialog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFontDialog.cxx,1,['access'],['access']
Security,"// don't call DeleteWindow() here since that will cause access; // to the deleted dialog in the WaitFor() method (see ctor); //OpenGL + XQuartz on Mac: gl context and related resources; //must be deleted _before_ UnmapWindow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGColorDialog.cxx:56,access,access,56,gui/gui/src/TGColorDialog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGColorDialog.cxx,1,['access'],['access']
Security,"// don't have access to a 64-bit machine at the moment so long test would be; // pointless...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/testbits.cxx:14,access,access,14,test/testbits.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/testbits.cxx,1,['access'],['access']
Security,"// draws the axis, called "".axis"" for easy access",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:43,access,access,43,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['access'],['access']
Security,"// due to the two-pass layout scheme for non-virtual-bases.; // * Virtual bases sometimes require a 'vtordisp' field that is laid out before; // the virtual base and is used in conjunction with virtual overrides during; // construction and destruction. This is always a 4 byte value and is used as; // an alternative to constructor vtables.; // * vtordisps are allocated in a block of memory with size and alignment equal; // to the alignment of the completed structure (before applying __declspec(; // align())). The vtordisp always occur at the end of the allocation block,; // immediately prior to the virtual base.; // * vfptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vfptrs are always injected at offset 0.; // * vbptrs are injected after all bases and fields have been laid out. In; // order to guarantee proper alignment of all fields, the vfptr injection; // pushes all bases and fields back by the alignment imposed by those bases; // and fields. This can potentially add a significant amount of padding.; // vbptrs are injected immediately after the last non-virtual base as; // lexicographically ordered in the code. If this site isn't pointer aligned; // the vbptr is placed at the next properly aligned location. Enough padding; // is added to guarantee a fit.; // * The last zero sized non-virtual base can be placed at the end of the; // struct (potentially aliasing another object), or may alias with the first; // field, even if they are of the same type.; // * The last zero size virtual base may be placed at the end of the struct; // potentially aliasing another object.; // * The ABI attempts to avoid aliasing of zero sized bases by adding padding; // between bases or vbases with specific properties. The criteria for; // add",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:2098,inject,injected,2098,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['inject'],['injected']
Security,// dxbc::HashFlags,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h:9,Hash,HashFlags,9,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h,1,['Hash'],['HashFlags']
Security,"// echo mode (echo, password, no echo)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressGUI.cxx:20,password,password,20,test/stressGUI.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressGUI.cxx,1,['password'],['password']
Security,"// element access ( for debugging)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cuda/CudaTensor.h:11,access,access,11,tmva/tmva/inc/TMVA/DNN/Architectures/Cuda/CudaTensor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cuda/CudaTensor.h,2,['access'],['access']
Security,"// else lookup with NotForRedeclaration will check access etc",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:51,access,access,51,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['access'],['access']
Security,"// else, this is a message accessing a property on super.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ScopeInfo.cpp:27,access,accessing,27,interpreter/llvm-project/clang/lib/Sema/ScopeInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/ScopeInfo.cpp,1,['access'],['accessing']
Security,"// else; // std::cout << "" Error: the recorded hash and the one returned by Hash are distinct.\n"";",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TCheckHashRecursiveRemoveConsistency.h:47,hash,hash,47,core/meta/src/TCheckHashRecursiveRemoveConsistency.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TCheckHashRecursiveRemoveConsistency.h,2,"['Hash', 'hash']","['Hash', 'hash']"
Security,"// end anonymous namespace; // Compute Hash value for the CFG: the lower 32 bits are CRC32 of the index; // value of each BB in the CFG. The higher 32 bits are the CRC32 of the numbers; // of selects, indirect calls, mem ops and edges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:39,Hash,Hash,39,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,1,['Hash'],['Hash']
Security,// end anonymous namespace; /// Check that we can access the notional vptr of an object / determine its; /// dynamic type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:50,access,access,50,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['access'],['access']
Security,"// end anonymous namespace; /// Figure out if the loop is worth full unrolling.; ///; /// Complete loop unrolling can make some loads constant, and we need to know; /// if that would expose any further optimization opportunities. This routine; /// estimates this optimization. It computes cost of unrolled loop; /// (UnrolledCost) and dynamic cost of the original loop (RolledDynamicCost). By; /// dynamic cost we mean that we won't count costs of blocks that are known not; /// to be executed (i.e. if we have a branch in the loop and we know that at the; /// given iteration its condition would be resolved to true, we won't add up the; /// cost of the 'false'-block).; /// \returns Optional value, holding the RolledDynamicCost and UnrolledCost. If; /// the analysis failed (no benefits expected from the unrolling, or the loop is; /// too big to analyze), the returned value is std::nullopt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:183,expose,expose,183,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['expose'],['expose']
Security,// end namespace AArch64II; //===----------------------------------------------------------------------===//; // v8.3a Pointer Authentication; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64BaseInfo.h:127,Authenticat,Authentication,127,interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64BaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64BaseInfo.h,1,['Authenticat'],['Authentication']
Security,// end namespace IndexedInstrProf; /// Trait for lookups into the on-disk hash table for the binary instrprof; /// format.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h:74,hash,hash,74,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h,1,['hash'],['hash']
Security,"// end namespace Util; /// \class KahanSum; /// The Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors; /// when adding a sequence of finite-precision floating point numbers.; /// This is done by keeping a separate running compensation (a variable to accumulate small errors).; ///; /// ### Auto-vectorisable accumulation; /// This class can internally use multiple accumulators (template parameter `N`).; /// When filled from a collection that supports index access from a *contiguous* block of memory,; /// compilers such as gcc, clang and icc can auto-vectorise the accumulation. This happens by cycling; /// through the internal accumulators based on the value of ""`index % N`"", so `N` accumulators can be filled from a block; /// of `N` numbers in a single instruction.; ///; /// The usage of multiple accumulators might slightly increase the precision in comparison to the single-accumulator version; /// with `N = 1`.; /// This depends on the order and magnitude of the numbers being accumulated. Therefore, in rare cases, the accumulation; /// result can change *in dependence of N*, even when the data are identical.; /// The magnitude of such differences is well below the precision of the floating point type, and will therefore mostly show; /// in the compensation sum(see Carry()). Increasing the number of accumulators therefore only makes sense to; /// speed up the accumulation, but not to increase precision.; ///; /// \param T The type of the values to be accumulated.; /// \param N Number of accumulators. Defaults to 1. Ideal values are the widths of a vector register on the relevant architecture.; /// Depending on the instruction set, good values are:; /// - AVX2-float: 8; /// - AVX2-double: 4; /// - AVX512-float: 16; /// - AVX512-double: 8; ///; /// ### Examples; ///; /// ~~~{.cpp}; /// std::vector<double> numbers(1000);; /// for (std::size_t i=0; i<1000; ++i) {; /// numbers[i] = rand();; /// }; ///; /// ROOT::Math::KahanSu",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Util.h:508,access,access,508,math/mathcore/inc/Math/Util.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Util.h,1,['access'],['access']
Security,// end namespace accessors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h:17,access,accessors,17,interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h,1,['access'],['accessors']
Security,// end namespace afdo_detail; // This class serves sample counts correlation for SampleProfileLoader by; // analyzing pseudo probes and their function descriptors injected by; // SampleProfileProber.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:163,inject,injected,163,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,1,['inject'],['injected']
Security,"// end namespace detail; /// A sum type over pointer-like types.; ///; /// This is a normal tagged union across pointer-like types that uses the low; /// bits of the pointers to store the tag.; ///; /// Each member of the sum type is specified by passing a \c; /// PointerSumTypeMember specialization in the variadic member argument list.; /// This allows the user to control the particular tag value associated with; /// a particular type, use the same type for multiple different tags, and; /// customize the pointer-like traits used for a particular member. Note that; /// these *must* be specializations of \c PointerSumTypeMember, no other type; /// will suffice, even if it provides a compatible interface.; ///; /// This type implements all of the comparison operators and even hash table; /// support by comparing the underlying storage of the pointer values. It; /// doesn't support delegating to particular members for comparisons.; ///; /// It also default constructs to a zero tag with a null pointer, whatever that; /// would be. This means that the zero value for the tag type is significant; /// and may be desirable to set to a state that is particularly desirable to; /// default construct.; ///; /// Having a supported zero-valued tag also enables getting the address of a; /// pointer stored with that tag provided it is stored in its natural bit; /// representation. This works because in the case of a zero-valued tag, the; /// pointer's value is directly stored into this object and we can expose the; /// address of that internal storage. This is especially useful when building an; /// `ArrayRef` of a single pointer stored in a sum type.; ///; /// There is no support for constructing or accessing with a dynamic tag as; /// that would fundamentally violate the type safety provided by the sum type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h:785,hash,hash,785,interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,3,"['access', 'expose', 'hash']","['accessing', 'expose', 'hash']"
Security,// end namespace detail; /// Implements a dense probed hash-table based set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseSet.h:55,hash,hash-table,55,interpreter/llvm-project/llvm/include/llvm/ADT/DenseSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseSet.h,1,['hash'],['hash-table']
Security,// end namespace llvm; /// Returns a hash table key based on memory operands of \p MI. The; /// number of the first memory operand of \p MI is specified through \p N.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp:37,hash,hash,37,interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,1,['hash'],['hash']
Security,// end namespace object; /// Helper class for helping synchronize access to the global address map; /// table. Access to this class should be serialized under a mutex.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:66,access,access,66,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,2,"['Access', 'access']","['Access', 'access']"
Security,"// end of namespace TThreadedObjectUtils; /**; * \class ROOT::TThreadedObject; * \brief A wrapper to make object instances thread private, lazily.; * \tparam T Class of the object to be made thread private (e.g. TH1F); * \ingroup Parallelism; *; * A wrapper which makes objects thread private. The methods of the underlying; * object can be invoked via the arrow operator. The object is created in; * a specific thread lazily, i.e. upon invocation of one of its methods.; * The correct object pointer from within a particular thread can be accessed; * with the overloaded arrow operator or with the Get method.; * In case an elaborate thread management is in place, e.g. in presence of; * stream of operations or ""processing slots"", it is also possible to; * manually select the correct object pointer explicitly.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx:540,access,accessed,540,core/thread/inc/ROOT/TThreadedObject.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx,1,['access'],['accessed']
Security,"// es: A ""stable"" memory operand; that is, one which does not; // include any automodification of the base register. Unlike; // `m', this constraint can be used in asm statements that; // might access the operand several times, or that might not; // access it at all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:194,access,access,194,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,2,['access'],['access']
Security,"// evaluate distribution on point 'xRand'; // ---------- Cell value access functions; // low level functions to access a certain cell value",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/PDEFoam.h:68,access,access,68,tmva/tmva/inc/TMVA/PDEFoam.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/PDEFoam.h,2,['access'],['access']
Security,"// event reference and update; // NOTE: these Event accessors make sure that you get the events transformed according to the; // particular classifiers transformation chosen",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBase.h:52,access,accessors,52,tmva/tmva/inc/TMVA/MethodBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBase.h,1,['access'],['accessors']
Security,// expose internals,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:3,expose,expose,3,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,1,['expose'],['expose']
Security,// extract data from the cache hash; // remove metadata on each item; // and return as array,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:31,hash,hash,31,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['hash'],['hash']
Security,"// extractelt (select %x, %vec1, %vec2), %const ->; // select %x, %vec1[%const], %vec2[%const]; // TODO: Support constant folding of multiple select operands:; // extractelt (select %x, %vec1, %vec2), (select %x, %c1, %c2); // If the extractelement will for instance try to do out of bounds accesses; // because of the values of %c1 and/or %c2, the sequence could be optimized; // early. This is currently not possible because constant folding will reach; // an unreachable assertion if it doesn't find a constant operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:291,access,accesses,291,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['access'],['accesses']
Security,"// facade: forward interface of MnUserParameters and MnUserTransformation; // via MnUserParameterState; // access to parameters (row-wise)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnApplication.h:107,access,access,107,math/minuit2/inc/Minuit2/MnApplication.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnApplication.h,1,['access'],['access']
Security,"// fall through: python is dynamic, and so, the hashing isn't infallible",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx:48,hash,hashing,48,bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx,1,['hash'],['hashing']
Security,// fast access to submitted requests,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:8,access,access,8,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['access'],['access']
Security,"// finally, to expose protected members, copy them over from the C++ dispatcher base; // to the Python dictionary (the C++ dispatcher's Python proxy is not a base of the; // Python class to keep the inheritance tree intact)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx:15,expose,expose,15,bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx,1,['expose'],['expose']
Security,"// first Take triggers the computation of i, then the Filter executes, then Take accesses the cached value of i; // hopefully it won't have changed in the meanwhile!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_concurrency.cxx:81,access,accesses,81,tree/dataframe/test/dataframe_concurrency.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_concurrency.cxx,1,['access'],['accesses']
Security,"// first of all, if access enabled, provide it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TRootSniffer.cxx:20,access,access,20,net/http/src/TRootSniffer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TRootSniffer.cxx,1,['access'],['access']
Security,// fixit: ObjectExpr.propertyname when it is aproperty accessor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:55,access,accessor,55,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['access'],['accessor']
Security,"// for access",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/TClassDocOutput.cxx:7,access,access,7,html/src/TClassDocOutput.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/TClassDocOutput.cxx,1,['access'],['access']
Security,"// for access into copied dataset:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsData.h:7,access,access,7,roofit/roofitcore/inc/RooAbsData.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsData.h,1,['access'],['access']
Security,// for authentication HMAC checksum and sequence id is important; // HMAC used to authenticate server; // sequence id is necessary to exclude submission of same packet again,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs:7,authenticat,authentication,7,js/modules/webwindow.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs,3,"['authenticat', 'checksum']","['authenticate', 'authentication', 'checksum']"
Security,"// for easy access",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TPoint.h:12,access,access,12,core/base/inc/TPoint.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TPoint.h,1,['access'],['access']
Security,"// for fast access; // memory management ---------------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/cpp_cppyy.h:12,access,access,12,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/cpp_cppyy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/cpp_cppyy.h,2,['access'],['access']
Security,"// for std::hash<> testing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/cpp11features.h:12,hash,hash,12,bindings/pyroot/cppyy/cppyy/test/cpp11features.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/test/cpp11features.h,1,['hash'],['hash']
Security,"// for the case where we have an 'exposed' smart pointer:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx:34,expose,exposed,34,bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,1,['expose'],['exposed']
Security,"// for the large tree access directly the branches",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/test/testNdimFit.cxx:22,access,access,22,math/minuit2/test/testNdimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/test/testNdimFit.cxx,2,['access'],['access']
Security,"// function for read/write access infos",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/sql/inc/TSQLFile.h:27,access,access,27,io/sql/inc/TSQLFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/sql/inc/TSQLFile.h,1,['access'],['access']
Security,"// gbl namespace is injected in cppyy.py; // create the memory regulator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx:20,inject,injected,20,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,1,['inject'],['injected']
Security,"// general member access; // should come after specific member access",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/rint/inc/TTabCom.h:18,access,access,18,core/rint/inc/TTabCom.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/rint/inc/TTabCom.h,2,['access'],['access']
Security,// get a reference to the hash table of event handlers,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js:26,hash,hash,26,interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js,3,['hash'],['hash']
Security,"// get neighbour bins along an axis; /********************** access distribution properties *************/; /// number of bins in the distribution possibly including under/overflow",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldBinning.h:61,access,access,61,hist/unfold/inc/TUnfoldBinning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldBinning.h,1,['access'],['access']
Security,"// get number of validation events according to given option",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/inc/TMVA/MethodPyKeras.h:17,validat,validation,17,tmva/pymva/inc/TMVA/MethodPyKeras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/inc/TMVA/MethodPyKeras.h,2,['validat'],['validation']
Security,"// get the sum of weights in the pruning validation sample; // calculate the quality of the tree in the unpruned case",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/CostComplexityPruneTool.cxx:41,validat,validation,41,tmva/tmva/src/CostComplexityPruneTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/CostComplexityPruneTool.cxx,1,['validat'],['validation']
Security,"// getStackSize() includes all the locals in its size calculation. We don't; // include these locals when computing the stack size of a funclet, as they; // are allocated in the parent's stack frame and accessed via the frame; // pointer from the funclet. We only save the callee saved registers in the; // funclet, which are really the callee saved registers of the parent; // function, including the funclet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:203,access,accessed,203,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['access'],['accessed']
Security,"// global accessor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Config.h:10,access,accessor,10,tmva/tmva/inc/TMVA/Config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Config.h,1,['access'],['accessor']
Security,"// global accessor; //; // Adapts a TRandom random number generator to the interface of the ones in the; // standard library (STL) so that TRandom derived generators can be used with; // STL algorithms such as `std::shuffle`.; //; // Example:; // ```; // std::vector<double> v {0, 1, 2, 3, 4, 5};; // TRandom3StdEngine rng(seed);; // std::shuffle(v.begin(), v.end(), rng);; // ```; //; // Or at a lower level:; // ```; // std::vector<double> v {0, 1, 2, 3, 4, 5};; // RandomGenerator<TRandom3> rng(seed);; // std::shuffle(v.begin(), v.end(), rng);; // ```; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Tools.h:10,access,accessor,10,tmva/tmva/inc/TMVA/Tools.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Tools.h,1,['access'],['accessor']
Security,"// gotta draw before accessing the axes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMLPAnalyzer.cxx:21,access,accessing,21,math/mlp/src/TMLPAnalyzer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMLPAnalyzer.cxx,2,['access'],['accessing']
Security,"// group password",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/inc/TWinNTSystem.h:9,password,password,9,core/winnt/inc/TWinNTSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/inc/TWinNTSystem.h,1,['password'],['password']
Security,"// hasPrivateSymbols is the opposite of isStripped, but we expose; // hasPrivateSymbols as a more intuitive interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/DIA/DIARawSymbol.cpp:59,expose,expose,59,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/DIA/DIARawSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/DIA/DIARawSymbol.cpp,1,['expose'],['expose']
Security,"// hash for current coordinates; 0 if not calculated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:3,hash,hash,3,hist/hist/src/THnSparse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx,1,['hash'],['hash']
Security,"// hash map of all filenames without paths",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/inc/THtml.h:3,hash,hash,3,html/inc/THtml.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/inc/THtml.h,1,['hash'],['hash']
Security,// hash possible odd byte,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/Hash.cpp:3,hash,hash,3,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/Hash.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/Hash.cpp,1,['hash'],['hash']
Security,"// hash table",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11ttf/src/TGX11TTF.cxx:3,hash,hash,3,graf2d/x11ttf/src/TGX11TTF.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11ttf/src/TGX11TTF.cxx,1,['hash'],['hash']
Security,"// hash table with thumbnailed pictures",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TRootBrowserLite.cxx:3,hash,hash,3,gui/gui/src/TRootBrowserLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TRootBrowserLite.cxx,1,['hash'],['hash']
Security,// hash value,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,hash,hash,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['hash'],['hash']
Security,"// header: ""Authorization: Bearer mytoken""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/davix/src/TDavixFile.cxx:12,Authoriz,Authorization,12,net/davix/src/TDavixFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/davix/src/TDavixFile.cxx,1,['Authoriz'],['Authorization']
Security,"// height of exposed area",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx:13,expose,exposed,13,graf2d/win32gdk/src/TGWin32.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx,3,['expose'],['exposed']
Security,"// helper function to generate hash from integer numbers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTessellated.cxx:31,hash,hash,31,geom/geom/src/TGeoTessellated.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTessellated.cxx,1,['hash'],['hash']
Security,"// if (!IsFixedLayout(cfrp) && !gSystem->AccessPathName(fPasteFileName.Data())) {; // fFrameMenu->AddEntry(""Replace\tCtrl+R"", kReplaceAct,; // 0, fClient->GetPicture(""bld_paste_into.png""));; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guibuilder/src/TGuiBldDragManager.cxx:41,Access,AccessPathName,41,gui/guibuilder/src/TGuiBldDragManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guibuilder/src/TGuiBldDragManager.cxx,1,['Access'],['AccessPathName']
Security,"// if fAutomatic == true you need a validation sample to optimize pruning",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx:36,validat,validation,36,tmva/tmva/src/MethodBDT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx,1,['validat'],['validation']
Security,"// if files are not available or have wrong permissions or are; // not accessible, give up",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:71,access,accessible,71,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['access'],['accessible']
Security,"// if modification of X [would access an inactive union member], an object; // of the type of X is implicitly created",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:31,access,access,31,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['access'],['access']
Security,"// if not valid, simply reset the hash function so as to not kill performance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx:34,hash,hash,34,bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx,1,['hash'],['hash']
Security,"// if the method is protected, we expose it through re-declaration and forwarding (using; // does not work here b/c there may be private overloads)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx:34,expose,expose,34,bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx,1,['expose'],['expose']
Security,"// if the raw name is the empty string (no guarantees that this is so as truly, the; // address is corrupt, but it is common to be empty), then there is no accessible RTTI; // and getting the unmangled name will crash ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:156,access,accessible,156,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,1,['access'],['accessible']
Security,"// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:59,hash,hash,59,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['hash'],['hash']
Security,"// if we're holding a hard reference, or holding weak reference while being part; // of a dispatcher intermediate, then this delete is from the C++ side, and Python; // is ""notified"" by nulling out the reference and an exception will be raised on; // continued access",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/DispatchPtr.cxx:261,access,access,261,bindings/pyroot/cppyy/CPyCppyy/src/DispatchPtr.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/DispatchPtr.cxx,1,['access'],['access']
Security,// ignore the error since some stylesheets may not be accessible; // due to CORS policies,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:54,access,accessible,54,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['access'],['accessible']
Security,// ilist_iterator_w_bits should also be accessible via isa/dyn_cast.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_iterator.h:40,access,accessible,40,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_iterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_iterator.h,1,['access'],['accessible']
Security,// indices into AccessorNames,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:16,Access,AccessorNames,16,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['Access'],['AccessorNames']
Security,// individual coordinate accessors in various coordinate systems; /**; spatial X component; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/LorentzVector.h:25,access,accessors,25,math/genvector/inc/Math/GenVector/LorentzVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/LorentzVector.h,1,['access'],['accessors']
Security,"// inject ROOT namespace for convenience",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/PyROOTModule.cxx:3,inject,inject,3,bindings/pyroot/pythonizations/src/PyROOTModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/PyROOTModule.cxx,1,['inject'],['inject']
Security,"// inject a FlexibleInterpVar ...; // get the list of clients BEFORE creating the new interpolation ... seems list of clients is inaccurate after",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:3,inject,inject,3,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['inject'],['inject']
Security,"// inject an interpolation node; // get the list of clients BEFORE creating the new interpolation ... seems list of clients is inaccurate after",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:3,inject,inject,3,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['inject'],['inject']
Security,"// inject custom data types",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx:3,inject,inject,3,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,1,['inject'],['inject']
Security,"// inject exception object proxy type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx:3,inject,inject,3,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,1,['inject'],['inject']
Security,"// inject identifiable nullptr and default",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx:3,inject,inject,3,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,1,['inject'],['inject']
Security,"// inject implementation for an overridden method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx:3,inject,inject,3,bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx,1,['inject'],['inject']
Security,"// inject meta type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx:3,inject,inject,3,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,1,['inject'],['inject']
Security,"// inject method proxy type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx:3,inject,inject,3,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,1,['inject'],['inject']
Security,"// inject object proxy type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx:3,inject,inject,3,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,1,['inject'],['inject']
Security,"// inject property proxy type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx:3,inject,inject,3,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,1,['inject'],['inject']
Security,"// inject template proxy type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx:3,inject,inject,3,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,1,['inject'],['inject']
Security,"// int access(const char *pathname, int amode);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:7,access,access,7,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,1,['access'],['access']
Security,"// isSafeAccess returns true if Addr is always inbounds with respect to its; // base object. For example, it is a field access or an array access with; // constant inbounds index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:120,access,access,120,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,2,['access'],['access']
Security,// iterator access to the scheduling classes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.h:12,access,access,12,interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.h,1,['access'],['access']
Security,"// just execute statement,; // later one can try to access results of statement",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/sql/odbc/src/TODBCStatement.cxx:52,access,access,52,sql/odbc/src/TODBCStatement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/sql/odbc/src/TODBCStatement.cxx,1,['access'],['access']
Security,"// kTRUE if encryption for UsrPwd is required",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/TAuthenticate.h:12,encrypt,encryption,12,net/auth/inc/TAuthenticate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/TAuthenticate.h,1,['encrypt'],['encryption']
Security,"// kTRUE if fPasswd is a passwd hash",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/TAuthenticate.h:32,hash,hash,32,net/auth/inc/TAuthenticate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/TAuthenticate.h,1,['hash'],['hash']
Security,"// kTRUE if fgPasswd is a passwd hash",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/TAuthenticate.h:33,hash,hash,33,net/auth/inc/TAuthenticate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/TAuthenticate.h,1,['hash'],['hash']
Security,"// keep protected to be accessible by the derived classes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Minimizer.h:24,access,accessible,24,math/mathcore/inc/Math/Minimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Minimizer.h,1,['access'],['accessible']
Security,"// key data must be excluded from the hash, otherwise the timestamp will; // always lead to unique hashes for each file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:38,hash,hash,38,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,2,['hash'],"['hash', 'hashes']"
Security,// last 8-bytes of standard SHA1 hash,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeHashing.h:33,hash,hash,33,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeHashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeHashing.h,1,['hash'],['hash']
Security,// ldN/stN only support legal vector types of size 64 or 128 in bits.; // Accesses having vector types that are a multiple of 128 bits can be; // matched to more than one ldN/stN instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:74,Access,Accesses,74,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['Access'],['Accesses']
Security,"// libFuzzer wants to intercept calls to certain library functions, so the; // following -fno-builtin-* flags force the compiler to emit interposable; // libcalls to these functions. Other sanitizers effectively do the same thing; // by marking all library call sites with NoBuiltin attribute in their LLVM; // pass. (see llvm::maybeMarkSanitizerLibraryCallNoBuiltin)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:189,sanitiz,sanitizers,189,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['sanitiz'],['sanitizers']
Security,// list from:; // * https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_macros.html; // * https://docs.microsoft.com/en-us/cpp/c-runtime-library/security-features-in-the-crt?view=msvc-160; // * man 7 feature_test_macros; // The list must be sorted for correct binary search.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:147,secur,security-features-in-the-crt,147,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['secur'],['security-features-in-the-crt']
Security,"// llvm.instrprof.cover(i8* <name>, i64 <hash>, i32 <num-counters>,; // i32 <index>)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:41,hash,hash,41,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,1,['hash'],['hash']
Security,"// llvm.instrprof.increment(i8* <name>, i64 <hash>, i32 <num-counters>,; // i32 <index>)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:45,hash,hash,45,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,1,['hash'],['hash']
Security,"// llvm.instrprof.timestamp(i8* <name>, i64 <hash>, i32 <num-counters>,; // i32 <index>)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:45,hash,hash,45,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,1,['hash'],['hash']
Security,// look up a property declaration whose one of its accessors is implemented; // by this method.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:51,access,accessors,51,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,1,['access'],['accessors']
Security,// may be accessed - make dummy,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:10,access,accessed,10,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['access'],['accessed']
Security,"// memVT is bogus. These intrinsics have IntrInaccessibleMemOnly attribute; // in order to model data exchange with other threads, but perform no real; // memory accesses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:162,access,accesses,162,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,1,['access'],['accesses']
Security,"// message types for MsgLogger; // define outside of Types class to facilite access",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Types.h:77,access,access,77,tmva/tmva/inc/TMVA/Types.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Types.h,1,['access'],['access']
Security,"// meta is a hash used to collect geometries, materials.; // not providing it implies that this is the root object; // being serialized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:13,hash,hash,13,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['hash'],['hash']
Security,"// methods as TMethodWrapper objects (by access)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/inc/TDocParser.h:41,access,access,41,html/inc/TDocParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/inc/TDocParser.h,1,['access'],['access']
Security,"// mismatch of HMAC checksum",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:20,checksum,checksum,20,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['checksum'],['checksum']
Security,"// must be even; // Accessor for the j-th normalized grid point along the i-th dimension",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGrid.h:20,Access,Accessor,20,roofit/roofitcore/src/RooGrid.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGrid.h,1,['Access'],['Accessor']
Security,"// must use Instance() method to access/create ClassifierFactory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/ClassifierFactory.h:33,access,access,33,tmva/tmva/inc/TMVA/ClassifierFactory.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/ClassifierFactory.h,1,['access'],['access']
Security,"// must use http: we cannot use https on macOS until we upgrade to the newest Davix; // and turn on the macOS SecureTransport layer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_csv.cxx:110,Secur,SecureTransport,110,tree/dataframe/test/datasource_csv.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_csv.cxx,1,['Secur'],['SecureTransport']
Security,// namespace AA; /// Helper for AA::PointerInfo::Access DenseMap/Set usage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:49,Access,Access,49,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['Access'],['Access']
Security,// namespace AccessQualifier,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVBaseInfo.h:13,Access,AccessQualifier,13,interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/MCTargetDesc/SPIRVBaseInfo.h,1,['Access'],['AccessQualifier']
Security,"// namespace CDT; //*****************************************************************************; // Implementations of template functionlity; //*****************************************************************************; // hash for CDT::V2d<T>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/CDT.h:228,hash,hash,228,math/mathcore/src/CDT/CDT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/CDT.h,1,['hash'],['hash']
Security,"// namespace Detail; /// The field for a class representing a collection of elements via `TVirtualCollectionProxy`.; /// Objects of such type behave as collections that can be accessed through the corresponding member functions in; /// `TVirtualCollectionProxy`. For STL collections, these proxies are provided. Custom classes need to implement the; /// corresponding member functions in `TVirtualCollectionProxy`. At a bare minimum, the user is required to provide an; /// implementation for the following functions in `TVirtualCollectionProxy`: `HasPointers()`, `GetProperties()`,; /// `GetValueClass()`, `GetType()`, `PushProxy()`, `PopProxy()`, `GetFunctionCreateIterators()`, `GetFunctionNext()`,; /// and `GetFunctionDeleteTwoIterators()`.; ///; /// The collection proxy for a given class can be set via `TClass::CopyCollectionProxy()`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx:176,access,accessed,176,tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx,1,['access'],['accessed']
Security,"// namespace Internal; /**; \class RAxisLabels; A RAxisGrow that has a label assigned to each bin and a bin width of 1. While filling still works through coordinates (i.e. arrays of doubles),; RAxisLabels allows to convert a string to a bin number or the bin's coordinate; center. The number of labels and the number of bins reported by RAxisGrow might; differ: the RAxisGrow will only grow when seeing a Fill(), while the RAxisLabels; will add a new label whenever `GetBinCenter()` is called. Implementation details:; Filling happens often; `GetBinCenter()` needs to be fast. Thus the unordered_map.; The painter needs the reverse: it wants the label for bin 0, bin 1 etc. The axis; should only store the bin labels once; referencing them is (due to re-allocation,; hashing etc) non-trivial. So instead, build a `vector<string_view>` for the few; times the axis needs to be painted.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx:767,hash,hashing,767,hist/histv7/inc/ROOT/RAxis.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx,1,['hash'],['hashing']
Security,"// namespace Internal; // clang-format off; /**; \class ROOT::Experimental::RNTupleViewBase; \ingroup NTuple; \brief An RNTupleView provides read-only access to a single field of the ntuple. \tparam T The type of the object that will be read by the view; can be void if unknown at compile time. The view owns a field and its underlying columns in order to fill an RField::RValue object with data. Data can be; accessed by index. For top-level fields, the index refers to the entry number. Fields that are part of; nested collections have global index numbers that are derived from their parent indexes. View can only be created by a reader or by a collection view.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleView.hxx:151,access,access,151,tree/ntuple/v7/inc/ROOT/RNTupleView.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleView.hxx,2,['access'],"['access', 'accessed']"
Security,"// namespace Internal; // prevent access violation when executing the df017_vecOpsHEP.C tutorial with ROOT built in release mode; // TODO: to be reviewed when updating Visual Studio or LLVM",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TBranchProxy.h:34,access,access,34,tree/treeplayer/inc/TBranchProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TBranchProxy.h,1,['access'],['access']
Security,"// namespace ROOT; // For hash maps ROnDiskPage::Key --> ROnDiskPage",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx:26,hash,hash,26,tree/ntuple/v7/inc/ROOT/RCluster.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx,1,['hash'],['hash']
Security,"// namespace ROOT; // clang-format off; /**; * \class TTreeReaderArray; * \ingroup treeplayer; * \brief An interface for reading collections stored in ROOT columnar datasets; *; * The TTreeReaderArray is a type-safe tool to be used in association with a TTreeReader; * to access the collections stored in TTree, TNtuple and TChain datasets.; * In order to access values which are not collections, the TTreeReaderValue class can; * be used.; *; * See the documentation of TTreeReader for more details and examples.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReaderArray.h:272,access,access,272,tree/treeplayer/inc/TTreeReaderArray.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReaderArray.h,2,['access'],['access']
Security,"// namespace TMVA::Experimental::Internal; /// \class TMVA::Experimental::RTensor; /// \brief RTensor is a container with contiguous memory and shape information.; /// \tparam T Data-type of the tensor; ///; /// An RTensor is a vector-like container, which has additional shape information.; /// The elements of the multi-dimensional container can be accessed by their; /// indices in a coherent way without taking care about the one-dimensional memory; /// layout of the contiguous storage. This also allows to manipulate the shape; /// of the container without moving the actual elements in memory. Another feature; /// is that an RTensor can own the underlying contiguous memory but can also represent; /// only a view on existing data without owning it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RTensor.hxx:351,access,accessed,351,tmva/tmva/inc/TMVA/RTensor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RTensor.hxx,1,['access'],['accessed']
Security,// namespace clang; /// Helper macro to simplify type switches.; /// The macro implicitly exposes a type T in the scope of the inner block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/PrimType.h:90,expose,exposes,90,interpreter/llvm-project/clang/lib/AST/Interp/PrimType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/PrimType.h,1,['expose'],['exposes']
Security,// namespace detail; /// One of these variable length records is kept for each; /// selector containing more than one keyword. We use a folding set; /// to unique aggregate names (keyword selectors in ObjC parlance). Access to; /// this class is provided strictly through Selector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h:217,Access,Access,217,interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,1,['Access'],['Access']
Security,"// namespace detail; /// Returns true if \p Element is found in \p Range. Delegates the check to; /// either `.contains(Element)`, `.find(Element)`, or `std::find`, in this; /// order of preference. This is intended as the canonical way to check if an; /// element exists in a range in generic code or range type that does not; /// expose a `.contains(Element)` member.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:332,expose,expose,332,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['expose'],['expose']
Security,"// namespace hashbuilder_detail; /// Declares the hasher member, and functions forwarding directly to the hasher.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h:50,hash,hasher,50,interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h,2,['hash'],['hasher']
Security,// namespace hashing,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h:13,hash,hashing,13,interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h,1,['hash'],['hashing']
Security,"// namespace hashing; // Declared and documented above, but defined here so that any of the hashing; // infrastructure is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:13,hash,hashing,13,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,2,['hash'],['hashing']
Security,"// namespace hashing; /// Combine values into a single hash_code.; ///; /// This routine accepts a varying number of arguments of any type. It will; /// attempt to combine them into a single hash_code. For user-defined types it; /// attempts to call a \see hash_value overload (via ADL) for the type. For; /// integer and pointer types it directly combines their data into the; /// resulting hash_code.; ///; /// The result is suitable for returning from a user's hash_value; /// *implementation* for their user-defined type. Consumers of a type should; /// *not* call this routine, they should instead call 'hash_value'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:13,hash,hashing,13,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,1,['hash'],['hashing']
Security,"// namespace hashing; /// Compute a hash_code for a sequence of values.; ///; /// This hashes a sequence of values. It produces the same hash_code as; /// 'hash_combine(a, b, c, ...)', but can run over arbitrary sized sequences; /// and is significantly faster given pointers and types which can be hashed as; /// a sequence of bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:13,hash,hashing,13,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,3,['hash'],"['hashed', 'hashes', 'hashing']"
Security,// namespace llvm; // Computes a unique hash for the Module considering the current list of; // export/import and other global analysis results.; // The hash is produced in \p Key.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:40,hash,hash,40,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,2,['hash'],['hash']
Security,// namespace llvm; /// Implement std::hash so that hash_code can be used in STL containers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:38,hash,hash,38,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,1,['hash'],['hash']
Security,// namespace llvm; /// Use __safestack_pointer_address even if the platform has a faster way of; /// access safe stack pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:101,access,access,101,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,1,['access'],['access']
Security,"// namespace serialization; /// Reads an AST files chain containing the contents of a translation; /// unit.; ///; /// The ASTReader class reads bitstreams (produced by the ASTWriter; /// class) containing the serialized representation of a given; /// abstract syntax tree and its supporting data structures. An; /// instance of the ASTReader can be attached to an ASTContext object,; /// which will provide access to the contents of the AST files.; ///; /// The AST reader provides lazy de-serialization of declarations, as; /// required when traversing the AST. Only those AST nodes that are; /// actually required will be de-serialized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:408,access,access,408,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['access'],['access']
Security,"// namespace sys; /// This interface provides simple read-only access to a block of memory, and; /// provides simple methods for reading files and standard input into a memory; /// buffer. In addition to basic access to the characters in the file, this; /// interface guarantees you can read one character past the end of the file,; /// and that this character will read as '\0'.; ///; /// The '\0' guarantee is needed to support an optimization -- it's intended to; /// be more efficient for clients which are reading all the data to stop; /// reading when they encounter a '\0' than to continually check the file; /// position to see if it has reached the end of the file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MemoryBuffer.h:63,access,access,63,interpreter/llvm-project/llvm/include/llvm/Support/MemoryBuffer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MemoryBuffer.h,2,['access'],['access']
Security,// namespace vfs; /// Public interface to the memory profiler pass for instrumenting code to; /// profile memory accesses.; ///; /// The profiler itself is a function pass that works by inserting various; /// calls to the MemProfiler runtime library functions. The runtime library; /// essentially replaces malloc() and free() with custom implementations that; /// record data about the allocations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/MemProfiler.h:113,access,accesses,113,interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/MemProfiler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/MemProfiler.h,1,['access'],['accesses']
Security,"// namespace; // Computes a string representation of a hash of the specified name, suitable; // for use when emitting CodeView type names.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeRecordMapping.cpp:55,hash,hash,55,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeRecordMapping.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeRecordMapping.cpp,1,['hash'],['hash']
Security,// namespace; /// Add the given declaration to the hash of all top-level entities.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:51,hash,hash,51,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,1,['hash'],['hash']
Security,// namespace; /// Check if it is legal to scalarize a memory access to \p VecTy at index \p; /// Idx. \p Idx must access a valid vector element.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:61,access,access,61,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,2,['access'],['access']
Security,// namespace; /// Warn if the LSet does not contain a lock sufficient to protect access; /// of at least the passed in AccessKind.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:81,access,access,81,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,2,"['Access', 'access']","['AccessKind', 'access']"
Security,"// namespace; /// Write ObjC data: selectors and the method pool.; ///; /// The method pool contains both instance and factory methods, stored; /// in an on-disk hash table indexed by the selector. The hash table also; /// contains an empty entry for every other selector known to Sema.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:162,hash,hash,162,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,2,['hash'],['hash']
Security,"// namespace; /// all_declared_ivar_begin - return first ivar declared in this class,; /// its extensions and its implementation. Lazily build the list on first; /// access.; ///; /// Caveat: The list returned by this method reflects the current; /// state of the parser. The cache will be updated for every ivar; /// added by an extension or the implementation when they are; /// encountered.; /// See also ObjCIvarDecl::Create().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:166,access,access,166,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,1,['access'],['access']
Security,"// need to create the variation : note - if no variations existed up to now this will inject a new node; // so we should redirect ourself to the new node; // TODO: Do we need to redirect parents?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:86,inject,inject,86,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['inject'],['inject']
Security,"// need to swap out var for newVar; // replace ith element in list with new func, or inject into RooProduct",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:85,inject,inject,85,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['inject'],['inject']
Security,"// needs this for special authentication options",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TSocket.h:26,authenticat,authentication,26,net/net/inc/TSocket.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TSocket.h,2,['authenticat'],['authentication']
Security,"// never exposed so no GC necessary",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPDataMember.cxx:9,expose,exposed,9,bindings/pyroot/cppyy/CPyCppyy/src/CPPDataMember.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPDataMember.cxx,1,['expose'],['exposed']
Security,"// no captureStr has the string to display; // inject line breaks to avoid msgbox being too wide",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:47,inject,inject,47,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['inject'],['inject']
Security,"// no security",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TWin32Condition.cxx:6,secur,security,6,core/thread/src/TWin32Condition.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TWin32Condition.cxx,2,['secur'],['security']
Security,// no volatile accesses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:15,access,accesses,15,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,2,['access'],['accesses']
Security,"// noalias indicates that pointer values based on the argument do not alias; // pointer values which are not based on it. So we add a new ""scope"" for each; // noalias function argument. Accesses using pointers based on that argument; // become part of that alias scope, accesses using pointers not based on that; // argument are tagged as noalias with that scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:186,Access,Accesses,186,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,2,"['Access', 'access']","['Accesses', 'accesses']"
Security,"// non-initialized or public data accesses through class (e.g. by help())",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPDataMember.cxx:34,access,accesses,34,bindings/pyroot/cppyy/CPyCppyy/src/CPPDataMember.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPDataMember.cxx,1,['access'],['accesses']
Security,"// normalisation and limit accessors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBase.h:27,access,accessors,27,tmva/tmva/inc/TMVA/MethodBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBase.h,1,['access'],['accessors']
Security,"// not a leave node ... for further traversal,; // we inject the children into priority queue based on distance to it's bounding box",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:54,inject,inject,54,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,2,['inject'],['inject']
Security,// not found checksum in the list,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:13,checksum,checksum,13,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['checksum'],['checksum']
Security,"// not the right version of the crypt function:; // do not send hash",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:64,hash,hash,64,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['hash'],['hash']
Security,"// note that fSize is a _signed_ integer, but we expose it as an unsigned integer for consistency with STL containers; // as well as backward-compatibility",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:49,expose,expose,49,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,1,['expose'],['expose']
Security,"// note we do not need the trasformed event to get the signal/background information; // by calling Data()->GetEvent instead of this->GetEvent we access the untransformed one",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx:146,access,access,146,tmva/tmva/src/MethodBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx,1,['access'],['access']
Security,"// now prepend ""@"" to the last element of the scope,; // to access the collection and not its containees",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:60,access,access,60,tree/tree/src/TBranchBrowsable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx,1,['access'],['access']
Security,"// now we indicate that there is data and any thread can access it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpWSHandler.cxx:57,access,access,57,net/http/src/THttpWSHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpWSHandler.cxx,3,['access'],['access']
Security,// null signifies implicit access,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:27,access,access,27,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['access'],['access']
Security,"// nullptr needed because accessing Clone via TObject base class puts; // """" instead, so doesnt copy names",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooFit.cxx:26,access,accessing,26,roofit/xroofit/src/xRooFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooFit.cxx,3,['access'],['accessing']
Security,"// number of expose events still to come",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx:13,expose,expose,13,graf2d/win32gdk/src/TGWin32.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx,3,['expose'],['expose']
Security,"// number of external function calls (RootFinder); // accessors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodPDERS.h:54,access,accessors,54,tmva/tmva/inc/TMVA/MethodPDERS.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodPDERS.h,1,['access'],['accessors']
Security,// object to access response data,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:13,access,access,13,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['access'],['access']
Security,"// object with all elements, used for fast access to elements by id",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/controller/Summary.controller.js:43,access,access,43,ui5/eve7/controller/Summary.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/controller/Summary.controller.js,1,['access'],['access']
Security,"// often there is a filewall on front of storage system.; // let clients connect to the data servers; // if it's an old dCache version, pool will try to connect to the client; // (if it's fine with firewall)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/dcache/src/TDCacheFile.cxx:198,firewall,firewall,198,io/dcache/src/TDCacheFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/dcache/src/TDCacheFile.cxx,1,['firewall'],['firewall']
Security,"// one may require to access n-th object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx:22,access,access,22,gui/webgui6/src/TWebCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx,1,['access'],['access']
Security,"// one need to call method to check access rights",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TRootSniffer.cxx:36,access,access,36,net/http/src/TRootSniffer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TRootSniffer.cxx,1,['access'],['access']
Security,"// option string defining the number of validation events",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/inc/TMVA/MethodPyKeras.h:40,validat,validation,40,tmva/pymva/inc/TMVA/MethodPyKeras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/inc/TMVA/MethodPyKeras.h,2,['validat'],['validation']
Security,"// padding is used to pad the passwords to 32 bytes, also is hashed and stored in the final PDF",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:30,password,passwords,30,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,"['hash', 'password']","['hashed', 'passwords']"
Security,"// page payload + checksum (if available)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx:18,checksum,checksum,18,tree/ntuple/v7/src/RPageStorageDaos.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageDaos.cxx,1,['checksum'],['checksum']
Security,"// pass a single validation event through a pruned decision tree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DecisionTree.h:17,validat,validation,17,tmva/tmva/inc/TMVA/DecisionTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DecisionTree.h,1,['validat'],['validation']
Security,"// password",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TSystem.h:3,password,password,3,core/base/inc/TSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TSystem.h,2,['password'],['password']
Security,"// perform series of validation tests",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/PDF.h:21,validat,validation,21,tmva/tmva/inc/TMVA/PDF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/PDF.h,1,['validat'],['validation']
Security,"// pictures might already have been deleted above, so avoid access; // to these objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGToolBar.cxx:60,access,access,60,gui/gui/src/TGToolBar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGToolBar.cxx,1,['access'],['access']
Security,"// pointer to relevant authentication info",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/TAuthenticate.h:23,authenticat,authentication,23,net/auth/inc/TAuthenticate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/TAuthenticate.h,1,['authenticat'],['authentication']
Security,"// pointer to security attributes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx:14,secur,security,14,io/io/src/TMapFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx,2,['secur'],['security']
Security,"// preserve key for longpoll or when with session key used for HMAC hash of messages; // conn->fKey.clear();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:68,hash,hash,68,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['hash'],['hash']
Security,"// prevent uncontrolled memory access in return value calculation; // return the median residual",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/LossFunction.cxx:31,access,access,31,tmva/tmva/src/LossFunction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/LossFunction.cxx,1,['access'],['access']
Security,"// probability and rarity accessors (see Users Guide for definition of Rarity)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Reader.h:26,access,accessors,26,tmva/tmva/inc/TMVA/Reader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Reader.h,1,['access'],['accessors']
Security,"// protect out of bound access (64)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx:24,access,access,24,core/winnt/src/TWinNTSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx,1,['access'],['access']
Security,"// protected function for accessing the internal Minuit2 object. Needed for derived classes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/Minuit2Minimizer.h:26,access,accessing,26,math/minuit2/inc/Minuit2/Minuit2Minimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/Minuit2Minimizer.h,1,['access'],['accessing']
Security,"// protected methods and data need their access changed in the C++ trampoline and then; // exposed on the Python side; so, collect their names as we go along",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx:41,access,access,41,bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx,2,"['access', 'expose']","['access', 'exposed']"
Security,"// provide an accessor to re-initialize after round-tripping from C++ (internal)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx:14,access,accessor,14,bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx,1,['access'],['accessor']
Security,"// publicly accessible global settings",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Config.h:12,access,accessible,12,tmva/tmva/inc/TMVA/Config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Config.h,1,['access'],['accessible']
Security,// r173147: split checksum into cfg checksum and line checksum.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/GCOV.h:18,checksum,checksum,18,interpreter/llvm-project/llvm/include/llvm/ProfileData/GCOV.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/GCOV.h,3,['checksum'],['checksum']
Security,"// random files; /******************************************************************/; /* */; /* file names should come before member accessing */; /* */; /* (because otherwise ""/tmp/a.cc"" might look like you're trying */; /* to access member ""cc"" of some object ""a"") */; /* */; /* but after anything that requires a specific path. */; /* */; /******************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/rint/inc/TTabCom.h:134,access,accessing,134,core/rint/inc/TTabCom.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/rint/inc/TTabCom.h,2,['access'],"['access', 'accessing']"
Security,"// re-authentication required by administrator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:6,authenticat,authentication,6,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['authenticat'],['authentication']
Security,"// re-use gMinuit as static instance of TMinuit; // which can be accessed by the user after minimization; // check if fgMinuit is different than gMinuit; // case 1: fgMinuit not zero but fgMinuit has been deleted (not in gROOT): set to zero; // case 2: fgMinuit not zero and exists in global list : set fgMinuit to gMinuit; // case 3: fgMinuit zero - and gMinuit not zero: create a new instance locally to avoid conflict",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx:65,access,accessed,65,math/minuit/src/TMinuitMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx,1,['access'],['accessed']
Security,// read access,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:8,access,access,8,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,1,['access'],['access']
Security,"// read and validate first the end header magic",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TZIPFile.cxx:12,validat,validate,12,io/io/src/TZIPFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TZIPFile.cxx,3,['validat'],['validate']
Security,"// read and validate first the entry header magic",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TZIPFile.cxx:12,validat,validate,12,io/io/src/TZIPFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TZIPFile.cxx,1,['validat'],['validate']
Security,"// read and validate first the header magic",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TZIPFile.cxx:12,validat,validate,12,io/io/src/TZIPFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TZIPFile.cxx,1,['validat'],['validate']
Security,"// read commit hash",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:15,hash,hash,15,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['hash'],['hash']
Security,"// read status of this data access",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/ROOT/TTreeReaderValueFast.hxx:28,access,access,28,tree/treeplayer/inc/ROOT/TTreeReaderValueFast.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/ROOT/TTreeReaderValueFast.hxx,1,['access'],['access']
Security,"// read-only access",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TRootSniffer.cxx:13,access,access,13,net/http/src/TRootSniffer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TRootSniffer.cxx,1,['access'],['access']
Security,"// reader tests; // setup test tree access",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/stressTMVA.cxx:36,access,access,36,tmva/tmva/test/stressTMVA.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/stressTMVA.cxx,1,['access'],['access']
Security,"// really 240! It might get some extra prefix or extension; // 8.3 is dead, but e.g. ext2 can only hold 255 chars in a file name.; // So mangle name to ""beginning_of_name""-h""hash"".""extension"", where; // beginning_of_name is short enough such that the full name is <255 characters.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocOutput.cxx:174,hash,hash,174,html/src/TDocOutput.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocOutput.cxx,1,['hash'],['hash']
Security,"// recursive pruning of the tree, validation sample required for automatic pruning",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DecisionTree.h:34,validat,validation,34,tmva/tmva/inc/TMVA/DecisionTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DecisionTree.h,1,['validat'],['validation']
Security,// regular attr merging will take care of validating this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,validat,validating,42,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['validat'],['validating']
Security,"// rehash the hash table to reduce the collission rate",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/tcollex.cxx:14,hash,hash,14,test/tcollex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/tcollex.cxx,1,['hash'],['hash']
Security,"// remember counter, it should prevent trying previous hash values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:55,hash,hash,55,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['hash'],['hash']
Security,"// remove "".gif""; // TODO: we need an accessible version of the source, i.e. visible w/o javascript",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocDirective.cxx:38,access,accessible,38,html/src/TDocDirective.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocDirective.cxx,1,['access'],['accessible']
Security,// remove checksum,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:10,checksum,checksum,10,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['checksum'],['checksum']
Security,"// remove default hash",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/src/TClassEdit.cxx:18,hash,hash,18,core/foundation/src/TClassEdit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/src/TClassEdit.cxx,1,['hash'],['hash']
Security,"// require to block context menu command appearing after control ends, required in chrome which inject contextmenu when key released",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:96,inject,inject,96,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['inject'],['inject']
Security,"// reset the pruning validation data",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DecisionTreeNode.h:21,validat,validation,21,tmva/tmva/inc/TMVA/DecisionTreeNode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DecisionTreeNode.h,1,['validat'],['validation']
Security,// return global factor; /********************* access by global bin number ******/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldBinning.h:48,access,access,48,hist/unfold/inc/TUnfoldBinning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldBinning.h,1,['access'],['access']
Security,"// return the misclassification rate of a pruned tree for a validation event sample",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/CCTreeWrapper.h:60,validat,validation,60,tmva/tmva/inc/TMVA/CCTreeWrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/CCTreeWrapper.h,1,['validat'],['validation']
Security,"// return the quality index from the validation sample for the optimal subtree T'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/CCPruner.h:37,validat,validation,37,tmva/tmva/inc/TMVA/CCPruner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/CCPruner.h,1,['validat'],['validation']
Security,"// reverse left/right rather than simply !SortFunc(left, right); // to expose different paths in the comparison logic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:71,expose,expose,71,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['expose'],['expose']
Security,// revision 2; // set flags for what functionalities the user can access,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:66,access,access,66,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['access'],['access']
Security,// rewrite MI to access 'Offset' bytes from the FP. Update Offset to be; // however much remains to be handled. Return 'true' if no further; // work is required.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.h:17,access,access,17,interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.h,1,['access'],['access']
Security,"// run the pruning validation sample through the unpruned tree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/CostComplexityPruneTool.cxx:19,validat,validation,19,tmva/tmva/src/CostComplexityPruneTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/CostComplexityPruneTool.cxx,1,['validat'],['validation']
Security,"// s3 access key",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/davix/src/TDavixFile.cxx:6,access,access,6,net/davix/src/TDavixFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/davix/src/TDavixFile.cxx,1,['access'],['access']
Security,"// sanitize numeric problems",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooLagrangianMorphFunc.cxx:3,sanitiz,sanitize,3,roofit/roofit/src/RooLagrangianMorphFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooLagrangianMorphFunc.cxx,1,['sanitiz'],['sanitize']
Security,"// sanitizeWS(); // clears the caches that might exist up to now, as well interfere with getParameters calls",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:3,sanitiz,sanitizeWS,3,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['sanitiz'],['sanitizeWS']
Security,"// sanitized",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TProofProgressLog.cxx:3,sanitiz,sanitized,3,gui/sessionviewer/src/TProofProgressLog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TProofProgressLog.cxx,1,['sanitiz'],['sanitized']
Security,"// secret session key used for hashing connections keys; // only if set, all messages from and to server signed with HMAC hash",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs:31,hash,hashing,31,js/modules/webwindow.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs,2,['hash'],"['hash', 'hashing']"
Security,"// send changes (need to access client connection list) and set the state under lock; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveManager.cxx:25,access,access,25,graf3d/eve7/src/REveManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveManager.cxx,1,['access'],['access']
Security,"// send our protocol; // if we do not require authentication say it here",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:46,authenticat,authentication,46,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['authenticat'],['authentication']
Security,"// set access control list from /etc/initgroup",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:7,access,access,7,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,3,['access'],['access']
Security,"// set dset to be validated in Collect()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:18,validat,validated,18,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,2,['validat'],['validated']
Security,"// set the cling name using hash of the static formulae map",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:28,hash,hash,28,hist/hist/src/TFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx,2,['hash'],['hash']
Security,"// seteq(x, 0) -> truncate(srl(ctlz(zext(x)), log2(#bits))); // If we're comparing for equality to zero and isCtlzFast is true, expose the; // fact that this can be implemented as a ctlz/srl pair, so that the dag; // combiner can fold the new nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:128,expose,expose,128,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['expose'],['expose']
Security,"// sets a certain block from the origin training set to belong to either Training or Validation set",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DataSet.h:85,Validat,Validation,85,tmva/tmva/inc/TMVA/DataSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DataSet.h,1,['Validat'],['Validation']
Security,"// sets the number of blocks to which the training set is divided,; // some of which are given to the Validation sample. As default they belong all to Training set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DataSet.h:102,Validat,Validation,102,tmva/tmva/inc/TMVA/DataSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DataSet.h,1,['Validat'],['Validation']
Security,"// setter and getter are created behind the scenes, incl. data binding and type validation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/lib/ColorBox.js:80,validat,validation,80,ui5/geom/lib/ColorBox.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/lib/ColorBox.js,2,['validat'],['validation']
Security,"// setup status of this data access",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/ROOT/TTreeReaderValueFast.hxx:29,access,access,29,tree/treeplayer/inc/ROOT/TTreeReaderValueFast.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/ROOT/TTreeReaderValueFast.hxx,1,['access'],['access']
Security,"// setup test tree access",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/stressTMVA.cxx:19,access,access,19,tmva/tmva/test/stressTMVA.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/stressTMVA.cxx,1,['access'],['access']
Security,// shim accessors for different order containers,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp:8,access,accessors,8,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp,1,['access'],['accessors']
Security,"// signature hashes are also used by TemplateProxy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.h:13,hash,hashes,13,bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.h,1,['hash'],['hashes']
Security,"// simple, superfast hash for pointers and alike",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TString.cxx:21,hash,hash,21,core/base/src/TString.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TString.cxx,1,['hash'],['hash']
Security,"// simply restore and expose as the actual smart pointer class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx:22,expose,expose,22,bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/ProxyWrappers.cxx,1,['expose'],['expose']
Security,"// skip 'CACHE' sets because they are auto-removed when sanitizing workspaces, which will invalidate these; // children",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:56,sanitiz,sanitizing,56,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['sanitiz'],['sanitizing']
Security,// skip checksum,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:8,checksum,checksum,8,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['checksum'],['checksum']
Security,"// skip floppy drives, to avoid accessing them each time...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx:32,access,accessing,32,core/winnt/src/TWinNTSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx,1,['access'],['accessing']
Security,// skip hash token.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:8,hash,hash,8,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,2,['hash'],['hash']
Security,"// special cases for access to the CPyCppyy API",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx:21,access,access,21,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,1,['access'],['access']
Security,"// special operand like VINTERP attr_chan; // An instruction may use only one literal.; // This has been validated on the previous step.; // See validateVOPLiteral.; // This literal may be used as more than one operand.; // If all these operands are of the same size,; // this literal counts as one scalar value.; // Otherwise it counts as 2 scalar values.; // See ""GFX10 Shader Programming"", section 3.6.2.3.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:105,validat,validated,105,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,2,['validat'],"['validateVOPLiteral', 'validated']"
Security,"// special workaround for servers like cernbox blocking access to some response headers; // as result, it is not possible to parse multipart responses",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:56,access,access,56,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['access'],['access']
Security,"// specific member accessing; // should come before general member accessing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/rint/inc/TTabCom.h:19,access,accessing,19,core/rint/inc/TTabCom.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/rint/inc/TTabCom.h,2,['access'],['accessing']
Security,// standard 20-byte SHA1 hash,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeHashing.h:25,hash,hash,25,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeHashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeHashing.h,1,['hash'],['hash']
Security,"// static function -; // options:; // g - set by default - geant4 compatibility; // f,n - if none of this two is set then naming convention is; // with incremental suffix, if ""f"" then suffix is pointer; // if ""n"" then there is no suffix, but uniqness of names; // is not secured.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/inc/TGDMLWrite.h:271,secur,secured,271,geom/gdml/inc/TGDMLWrite.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/inc/TGDMLWrite.h,1,['secur'],['secured']
Security,"// std::cerr << ""Error in "" << function << "": Access ("" << accesstype << "") to a collection ("" <<; // collection->IsA()->GetName() << "":"" << collection <<; // "") from multiple threads at a time. holder="" << ""0x"" << std::hex << holder << "" readers="" << fReadSet.size() <<; // ""0x"" << std::hex << local << std::endl;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TCollection.cxx:46,Access,Access,46,core/cont/src/TCollection.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TCollection.cxx,2,"['Access', 'access']","['Access', 'accesstype']"
Security,"// std::cerr << ""Error: old= "" << size << "" new="" << fCont.size() << '\n';; // std::cerr << ""Error "" << classRef.GetName() <<; // "" or one of its base classes override TObject::Hash but does not call TROOT::CallRecursiveRemoveIfNeeded; // in its destructor.\n"";",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TCheckHashRecursiveRemoveConsistency.h:177,Hash,Hash,177,core/meta/src/TCheckHashRecursiveRemoveConsistency.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TCheckHashRecursiveRemoveConsistency.h,1,['Hash'],['Hash']
Security,"// std::cout << "" Found object with hash = "" << p->fRecordedHash << '\n';; // std::cout << "" Current hash = "" << obj->Hash() << '\n';",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TCheckHashRecursiveRemoveConsistency.h:36,hash,hash,36,core/meta/src/TCheckHashRecursiveRemoveConsistency.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TCheckHashRecursiveRemoveConsistency.h,3,"['Hash', 'hash']","['Hash', 'hash']"
Security,"// std::shared_ptr<TStyle> style; // use to keep alive for access from GetStyle below, in case getObject; // has decided to return the owning ptr (for some reason) std::string _title =; // strlen(dataGraph->GetTitle()) ? dataGraph->GetTitle() : GetName(); if (!gROOT->GetStyle(_title.c_str())); // {; // if ( (style = getObject<TStyle>(_title)) ) {; // // loaded style (from workspace?) so put in list and use that; // gROOT->GetListOfStyles()->Add(style.get());; // } else {; // // create new style - gets put in style list automatically so don't have to delete; // // acquire them so saved to workspaces for auto reload ...; // style = const_cast<xRooNode&>(*this).acquireNew<TStyle>(_title.c_str(),; // TString::Format(""Style for %s component"", _title.c_str()));; // (TAttLine &) (*style) = *dynamic_cast<TAttLine *>(dataGraph);; // (TAttFill &) (*style) = *dynamic_cast<TAttFill *>(dataGraph);; // (TAttMarker &) (*style) = *dynamic_cast<TAttMarker *>(dataGraph);; // gROOT->GetListOfStyles()->Add(style.get());; // }; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:59,access,access,59,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['access'],['access']
Security,"// std::shared_ptr<TStyle> style; // use to keep alive for access from GetStyle below, in case; // getObject has decided to return the owning ptr (for some reason) if; // (!gROOT->GetStyle(h->GetTitle())) {; // if ( (style = getObject<TStyle>(h->GetTitle())) ) {; // // loaded style (from workspace?) so put in list and use that; // gROOT->GetListOfStyles()->Add(style.get());; // } else {; // // create new style - gets put in style list automatically so don't have to delete; // // acquire them so saved to workspaces for auto reload ...; // style = acquireNew<TStyle>(h->GetTitle(),; // TString::Format(""Style for %s component"", h->GetTitle()));; // (TAttLine &) (*style) = *dynamic_cast<TAttLine *>(h);; // (TAttFill &) (*style) = *dynamic_cast<TAttFill *>(h);; // (TAttMarker &) (*style) = *dynamic_cast<TAttMarker *>(h);; // gROOT->GetListOfStyles()->Add(style.get());; // }; // }; // (TAttLine&)(*h) = *(gROOT->GetStyle(h->GetTitle()) ? gROOT->GetStyle(h->GetTitle()) : gStyle);; // (TAttFill&)(*h) = *(gROOT->GetStyle(h->GetTitle()) ? gROOT->GetStyle(h->GetTitle()) : gStyle);; // (TAttMarker&)(*h) = *(gROOT->GetStyle(h->GetTitle()) ? gROOT->GetStyle(h->GetTitle()) : gStyle);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:59,access,access,59,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['access'],['access']
Security,"// std::string objects hash to the same values as Python strings to allow; // matches in dictionaries etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx:23,hash,hash,23,bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,1,['hash'],['hash']
Security,// store the event handler in the hash table,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js:34,hash,hash,34,interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build/share/scan-build/sorttable.js,3,['hash'],['hash']
Security,"// store translation between hash and bin",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:29,hash,hash,29,hist/hist/src/THnSparse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx,1,['hash'],['hash']
Security,// struct; // {; // Class isa;; // uint32_t flags;; // uint32_t length; // Number of codepoints; // uint32_t size; // Number of bytes; // uint32_t hash;; // const char *data;; // };,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:147,hash,hash,147,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['hash'],['hash']
Security,// synthesizing accessors must not result in a direct method that is not; // monomorphic,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:16,access,accessors,16,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,1,['access'],['accessors']
Security,"// take access to main node",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/src/TGDMLParse.cxx:8,access,access,8,geom/gdml/src/TGDMLParse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/src/TGDMLParse.cxx,2,['access'],['access']
Security,"// test file access",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/tstring.cxx:13,access,access,13,test/tstring.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/tstring.cxx,1,['access'],['access']
Security,"// testSIV -; // When we have a pair of subscripts of the form [c1 + a1*i] and [c2 - a2*i]; // where i is an induction variable, c1 and c2 are loop invariant, and a1 and; // a2 are constant, we attack it with an SIV test. While they can all be; // solved with the Exact SIV test, it's worthwhile to use simpler tests when; // they apply; they're cheaper and sometimes more precise.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:194,attack,attack,194,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['attack'],['attack']
Security,"// testZIV -; // When we have a pair of subscripts of the form [c1] and [c2],; // where c1 and c2 are both loop invariant, we attack it using; // the ZIV test. Basically, we test by comparing the two values,; // but there are actually three possible results:; // 1) the values are equal, so there's a dependence; // 2) the values are different, so there's no dependence; // 3) the values might be equal, so we have to assume a dependence.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:126,attack,attack,126,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['attack'],['attack']
Security,"// the 'if' part is that surrounded by the debug code.; // Intentionally accessing the deleted memory to check whether it has been changed as; // a consequence (side effect) of executing operator delete. If there no change, we; // can guess this is always the case and we can rely on the changes to fBits made; // by ~TObject to detect use-after-delete error (and print a message rather than; // stop the program with a segmentation fault)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TObject.cxx:73,access,accessing,73,core/base/src/TObject.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TObject.cxx,1,['access'],['accessing']
Security,"// the direct base can be useful for some templates, such as shared_ptrs,; // so make it accessible (the __cpp_cross__ data member also signals that; // this is a cross-inheritance class)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx:89,access,accessible,89,bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx,1,['access'],['accessible']
Security,// the templated records will be resposbible for injecting their templates,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:49,inject,injecting,49,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,1,['inject'],['injecting']
Security,"// there is no accessible dependency file, let's assume the library has been; // modified",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:15,access,accessible,15,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['access'],['accessible']
Security,"// this is indication of main in the middle, already checked hashed value was shown again!!!; // client sends id with increasing counter, if previous value is presented it is BAD",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:61,hash,hashed,61,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['hash'],['hashed']
Security,// this prevents other processes from accessing it by name,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MemoryMapper.cpp:38,access,accessing,38,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MemoryMapper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/MemoryMapper.cpp,1,['access'],['accessing']
Security,"// this should not happen, but it will prevent an endless loop; // in case of a very bad hash function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/THashTable.cxx:89,hash,hash,89,core/cont/src/THashTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/THashTable.cxx,1,['hash'],['hash']
Security,"// this way to get the machine's IP address is needed because; // GetHostByName() on Win32 contacts the DNS which we don't want; // as firewall tools like ZoneAlarm are likely to catch it and; // alarm the user",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUUID.cxx:135,firewall,firewall,135,core/base/src/TUUID.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUUID.cxx,1,['firewall'],['firewall']
Security,"// this.getView().getModel().setProperty('/Method', method);; //to get access to the global model; // this.getView().addDependent(this.methodDialog);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/canv/controller/Canvas.controller.js:71,access,access,71,ui5/canv/controller/Canvas.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/canv/controller/Canvas.controller.js,1,['access'],['access']
Security,"// to access CollectShared method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RDrawable.hxx:6,access,access,6,graf2d/gpadv7/inc/ROOT/RDrawable.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RDrawable.hxx,1,['access'],['access']
Security,"// to access Display method and IsFrameRequired",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RDrawable.hxx:6,access,access,6,graf2d/gpadv7/inc/ROOT/RDrawable.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RDrawable.hxx,1,['access'],['access']
Security,"// to access EUrgent",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h:6,access,access,6,proof/proof/inc/TProof.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h,2,['access'],['access']
Security,"// to access GetCollectionInfo()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField.hxx:6,access,access,6,tree/ntuple/v7/inc/ROOT/RField.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField.hxx,1,['access'],['access']
Security,"// to access SetDrawableVersion",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RDrawable.hxx:6,access,access,6,graf2d/gpadv7/inc/ROOT/RDrawable.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RDrawable.hxx,1,['access'],['access']
Security,"// to access attributes and other members",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RDrawable.hxx:6,access,access,6,graf2d/gpadv7/inc/ROOT/RDrawable.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RDrawable.hxx,1,['access'],['access']
Security,"// to access fCurrentMonitor and CollectInputFrom",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h:6,access,access,6,proof/proof/inc/TProof.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h,1,['access'],['access']
Security,"// to access kPing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h:6,access,access,6,proof/proof/inc/TProof.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h,1,['access'],['access']
Security,// to get access to the controller's model,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/canv/controller/Canvas.controller.js:10,access,access,10,ui5/canv/controller/Canvas.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/canv/controller/Canvas.controller.js,1,['access'],['access']
Security,"// todo: narrow this down; // For each kernel, what variables does it access directly or through; // callees",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:70,access,access,70,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['access'],['access']
Security,"// try authentication , if required",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TPSocket.cxx:7,authenticat,authentication,7,net/net/src/TPSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TPSocket.cxx,2,['authenticat'],['authentication']
Security,"// try base classes to cover a common 'using' case (TODO: this is stupid and misses; // out on base classes; fix that with improved access to Cling)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:132,access,access,132,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,1,['access'],['access']
Security,"// try to mprotect the other bits of the pool with no access...; // we'd really like a version of mremap here that can unmap all the; // other pages in the chunk, but that does not exist, so we protect; // the other pages in this chunk such that they may neither be read,; // written nor executed, only the pages we're interested in for; // communications stay readable and writable; //; // if an OS does not support changing the protection of a part of an; // mmapped area, the mprotect calls below should just fail and not; // change any protection, so we're a little less safe against; // corruption, but everything should still work",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx:54,access,access,54,roofit/roofitcore/src/BidirMMapPipe.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx,1,['access'],['access']
Security,// type ::= Dt <expression> E # decltype of an id-expression; // # or class member access; // ::= DT <expression> E # decltype of an expression; // This purports to be an exhaustive list of id-expressions and; // class member accesses. Note that we do not ignore parentheses;; // parentheses change the semantics of decltype for these; // expressions (and cause the mangler to use the other form).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:83,access,access,83,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,2,['access'],"['access', 'accesses']"
Security,"// type of authentication",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/TAuthenticate.h:11,authenticat,authentication,11,net/auth/inc/TAuthenticate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/TAuthenticate.h,1,['authenticat'],['authentication']
Security,// uint32_t checksum,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:12,checksum,checksum,12,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,1,['checksum'],['checksum']
Security,"// unnamed namespace; //- C++ access to cppyy objects ---------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/API.cxx:30,access,access,30,bindings/pyroot/cppyy/CPyCppyy/src/API.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/API.cxx,1,['access'],['access']
Security,// update values here to let access even when frame is not really updated,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:29,access,access,29,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['access'],['access']
Security,"// use ""const char*"" operator and the Data() member function to access; // the string as a const char*",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/tstring.cxx:64,access,access,64,test/tstring.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/tstring.cxx,1,['access'],['access']
Security,"// use connection mutex to access hold request",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:27,access,access,27,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['access'],['access']
Security,"// use directly vector array for faster element access",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:48,access,access,48,hist/hist/src/TPrincipal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx,1,['access'],['access']
Security,"// use hash of line instead of e.g. line number.; // advantages: more stable (lines can move around, we still find them back),; // no need for keeping a line number context",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocParser.cxx:7,hash,hash,7,html/src/TDocParser.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/TDocParser.cxx,1,['hash'],['hash']
Security,"// use to keep alive for access from GetStyle below, in case getObject has decided to; // return the owning ptr (for some reason)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:25,access,access,25,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['access'],['access']
Security,"// use tolerance to generate int with the desired precision from a real number for hashing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTessellated.cxx:83,hash,hashing,83,geom/geom/src/TGeoTessellated.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTessellated.cxx,1,['hash'],['hashing']
Security,"// user authentication (does not return in case of failure)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:8,authenticat,authentication,8,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['authenticat'],['authentication']
Security,"// user password",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/inc/TWinNTSystem.h:8,password,password,8,core/winnt/inc/TWinNTSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/inc/TWinNTSystem.h,1,['password'],['password']
Security,"// user to be authenticated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/TAuthenticate.h:14,authenticat,authenticated,14,net/auth/inc/TAuthenticate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/TAuthenticate.h,1,['authenticat'],['authenticated']
Security,"// user's password",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/TAuthenticate.h:10,password,password,10,net/auth/inc/TAuthenticate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/TAuthenticate.h,1,['password'],['password']
Security,"// v8M Baseline follows on from v6M, so doesn't support unaligned memory; // access either.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:77,access,access,77,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,1,['access'],['access']
Security,// validate RegBank initialization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/GISel/X86RegisterBankInfo.cpp:3,validat,validate,3,interpreter/llvm-project/llvm/lib/Target/X86/GISel/X86RegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/GISel/X86RegisterBankInfo.cpp,1,['validat'],['validate']
Security,"// validate cache - removes no longer actual elements",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/browserv7/src/RBrowserData.cxx:3,validat,validate,3,gui/browserv7/src/RBrowserData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/browserv7/src/RBrowserData.cxx,1,['validat'],['validate']
Security,// validate each instance of user to be a live function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:3,validat,validate,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,1,['validat'],['validate']
Security,// validate first jump with this slot rule,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,validat,validate,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,1,['validat'],['validate']
Security,"// validate only within stepmax",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:3,validat,validate,3,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,1,['validat'],['validate']
Security,// validate parent declaration,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp:3,validat,validate,3,interpreter/llvm-project/clang/tools/libclang/CXType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp,1,['validat'],['validate']
Security,// validate parent type,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp:3,validat,validate,3,interpreter/llvm-project/clang/tools/libclang/CXType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp,1,['validat'],['validate']
Security,// validate register against architecture,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:3,validat,validate,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,1,['validat'],['validate']
Security,// validate second jump with this slot rule,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:3,validat,validate,3,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,1,['validat'],['validate']
Security,// validate/cleanup values,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,validat,validate,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['validat'],['validate']
Security,"// validateOutputConstraint, validateInputConstraint - Checks that; // a constraint is valid and provides information about it.; // FIXME: These should return a real error instead of just true/false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:3,validat,validateOutputConstraint,3,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,2,['validat'],"['validateInputConstraint', 'validateOutputConstraint']"
Security,// verified in validateFieldParentType,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp:15,validat,validateFieldParentType,15,interpreter/llvm-project/clang/tools/libclang/CXType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp,1,['validat'],['validateFieldParentType']
Security,"// virtual ULong_t Hash() const { return 0; }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/xml/inc/TKeyXML.h:19,Hash,Hash,19,io/xml/inc/TKeyXML.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/xml/inc/TKeyXML.h,1,['Hash'],['Hash']
Security,// vldN/vstN only support legal vector types of size 64 or 128 in bits.; // Accesses having vector types that are a multiple of 128 bits can be; // matched to more than one vldN/vstN instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:76,Access,Accesses,76,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,1,['Access'],['Accesses']
Security,"// we could access it through the base class pointer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/XMLReader.cxx:12,access,access,12,core/dictgen/src/XMLReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/XMLReader.cxx,1,['access'],['access']
Security,"// we expect the cluster pool to contain the requested set of columns, since they were; // validated by CompareDescriptorStructures().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx:91,validat,validated,91,tree/ntuple/v7/src/RNTupleMerger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx,1,['validat'],['validated']
Security,// we need to validate the parent type,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp:14,validat,validate,14,interpreter/llvm-project/clang/tools/libclang/CXType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp,1,['validat'],['validate']
Security,// we use the index array to access the correct indices,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:29,access,access,29,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,1,['access'],['access']
Security,// when code ends with the point - means object itself will be accessed; // sometime branch name itself ends with the point,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:63,access,accessed,63,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['access'],['accessed']
Security,"// whether dot is accessible",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/inc/THtml.h:18,access,accessible,18,html/inc/THtml.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/inc/THtml.h,1,['access'],['accessible']
Security,// write out ivar offset symbols which have been referenced in an ivar; // access expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:75,access,access,75,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,1,['access'],['access']
Security,// write the color property; UI5 has validated it to be a valid CSS color,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/lib/ColorBox.js:37,validat,validated,37,ui5/geom/lib/ColorBox.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/lib/ColorBox.js,1,['validat'],['validated']
Security,"// writes the Control ID and enables event handling - important!; // oRm.addStyle(""background-color"", oControl.getColor()); // write the color property; UI5 has validated it to be a valid CSS color",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/lib/GeomDrawing.js:161,validat,validated,161,ui5/geom/lib/GeomDrawing.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/lib/GeomDrawing.js,1,['validat'],['validated']
Security,"// z/OS XPLink specific: classifies the types of; // accesses to the ADA (Associated Data Area).; // These enums contains values that overlap with the above MO_ enums,; // but that's fine since the above enums are used with ELF,; // while these values are used with z/OS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h:53,access,accesses,53,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.h,1,['access'],['accesses']
Security,// ~ is not a valid module name or context hash,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:43,hash,hash,43,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,1,['hash'],['hash']
Security,// ~XSStepButton; /* ----- ProcessMessage ----- */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSStepButton.cxx:4,XSS,XSStepButton,4,test/periodic/XSStepButton.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/periodic/XSStepButton.cxx,1,['XSS'],['XSStepButton']
Security,"//! Mutex for thread data access; // methods",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoBoolNode.h:26,access,access,26,geom/geom/inc/TGeoBoolNode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoBoolNode.h,1,['access'],['access']
Security,"//! Set to true if a TDirectory might still access this object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TDirectory.h:44,access,access,44,core/base/inc/TDirectory.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TDirectory.h,1,['access'],['access']
Security,"//! Source checksum vector (for searching purposes)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TSchemaRule.h:11,checksum,checksum,11,core/meta/inc/TSchemaRule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TSchemaRule.h,1,['checksum'],['checksum']
Security,"//! Special 'lock' to detect multiple access to a collection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollection.h:38,access,access,38,core/cont/inc/TCollection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollection.h,1,['access'],['access']
Security,"//! current URL to access the file, points to URL; // in the fUrlList or 0, if the list end is reached",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TFileInfo.h:19,access,access,19,core/base/inc/TFileInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TFileInfo.h,1,['access'],['access']
Security,"//! transient member, edited by checksum based rule",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStruct.hxx:32,checksum,checksum,32,tree/ntuple/v7/test/CustomStruct.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStruct.hxx,1,['checksum'],['checksum']
Security,"//! transient member, skipped by checksum based rule due to checksum mismatch",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStruct.hxx:33,checksum,checksum,33,tree/ntuple/v7/test/CustomStruct.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/CustomStruct.hxx,2,['checksum'],['checksum']
Security,"//!Error message in case of checksum/version mismatch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TStreamerElement.h:28,checksum,checksum,28,core/meta/inc/TStreamerElement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TStreamerElement.h,1,['checksum'],['checksum']
Security,"//!checksum of the base class (used during memberwise streaming)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TStreamerElement.h:3,checksum,checksum,3,core/meta/inc/TStreamerElement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TStreamerElement.h,1,['checksum'],['checksum']
Security,"//!hash-map from pdg-code to particle; // make copy-constructor and assigment protected since class cannot be copied",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/TDatabasePDG.h:3,hash,hash-map,3,montecarlo/eg/inc/TDatabasePDG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/inc/TDatabasePDG.h,1,['hash'],['hash-map']
Security,"//*****************************************************************************; // Specialize hash functions; //*****************************************************************************",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/CDTUtils.h:95,hash,hash,95,math/mathcore/src/CDT/CDTUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/CDTUtils.h,1,['hash'],['hash']
Security,"//*this >> checksum;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx:11,checksum,checksum,11,io/io/src/TBufferFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx,2,['checksum'],['checksum']
Security,"//*this >> checksum;; // If *bcnt < 6 then we have a class with 'just' version zero and no checksum",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx:11,checksum,checksum,11,io/io/src/TBufferFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx,2,['checksum'],['checksum']
Security,"//- C++ access to cppyy objects ---------------------------------------------; // C++ Instance (python object proxy) to void* conversion",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/include/CPyCppyy/API.h:8,access,access,8,bindings/pyroot/cppyy/CPyCppyy/include/CPyCppyy/API.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/include/CPyCppyy/API.h,1,['access'],['access']
Security,"//- access to the python interpreter ----------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/API.cxx:4,access,access,4,bindings/pyroot/cppyy/CPyCppyy/src/API.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/API.cxx,1,['access'],['access']
Security,"//- access to the python interpreter ----------------------------------------; // import a python module, making its classes available to Cling",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/include/CPyCppyy/API.h:4,access,access,4,bindings/pyroot/cppyy/CPyCppyy/include/CPyCppyy/API.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/include/CPyCppyy/API.h,1,['access'],['access']
Security,"//---- Directories -------------------------------------------------------------; ////////////////////////////////////////////////////////////////////////////////; /// Create helper TSystem to handle file and directory operations that; /// might be special for remote file access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:273,access,access,273,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['access'],['access']
Security,"//------------------------------------------------------------------------------; // Builder functions of this class are called by EveScene to create RCore; // objects representing an EveElement. They can have children if multiple RCore; // objects are required (e.g., mesh + lines + points).; //; // The top-level object returned by these builder functions will get additional; // properties injected by EveScene:; // - eve_el; // - scene.; //; // Object picking functions in GlViewerRCore will navigate up the parent hierarchy; // until an object with eve_el property is set.; // If secondary selection is enabled on the eve_el, instance picking will be called; // as well and the returned ID will be used as the index for secondary selection.; // This can be overriden by setting get_ctrl property of any RCore object to a function; // that takes a reference to the said argument and returns an instance of class; // EveElemControl.; // get_ctrl property needs to be set at least at the top-level object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/EveElementsRCore.js:393,inject,injected,393,ui5/eve7/lib/EveElementsRCore.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/EveElementsRCore.js,1,['inject'],['injected']
Security,"//------------------------------------------------------------------------------; // CLING - the C++ LLVM-based InterpreterG :); //; // This file is dual-licensed: you can choose to license it under the University; // of Illinois Open Source License or the GNU Lesser General Public License. See; // LICENSE.TXT for details.; //------------------------------------------------------------------------------; // RUN: cat %s | %cling -x c -Xclang -verify 2>&1 | FileCheck %s; // RUN: cat %s | %cling -x c -fsyntax-only -Xclang -verify 2>&1; // Validate cling C mode.; // Fix value printing!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/test/Driver/C.c:542,Validat,Validate,542,interpreter/cling/test/Driver/C.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/test/Driver/C.c,1,['Validat'],['Validate']
Security,"//----------------------------------------------------------------------------//; // Canonical, qualified type template; //----------------------------------------------------------------------------//; /// Represents a canonical, potentially-qualified type.; ///; /// The CanQual template is a lightweight smart pointer that provides access; /// to the canonical representation of a type, where all typedefs and other; /// syntactic sugar has been eliminated. A CanQualType may also have various; /// qualifiers (const, volatile, restrict) attached to it.; ///; /// The template type parameter @p T is one of the Type classes (PointerType,; /// BuiltinType, etc.). The type stored within @c CanQual<T> will be of that; /// type (or some subclass of that type). The typedef @c CanQualType is just; /// a shorthand for @c CanQual<Type>.; ///; /// An instance of @c CanQual<T> can be implicitly converted to a; /// @c CanQual<U> when T is derived from U, which essentially provides an; /// implicit upcast. For example, @c CanQual<LValueReferenceType> can be; /// converted to @c CanQual<ReferenceType>. Note that any @c CanQual type can; /// be implicitly converted to a QualType, but the reverse operation requires; /// a call to ASTContext::getCanonicalType().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CanonicalType.h:335,access,access,335,interpreter/llvm-project/clang/include/clang/AST/CanonicalType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CanonicalType.h,1,['access'],['access']
Security,"//---------------------------------------------------------------------------; // Check if there are conflicting checksums; /////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TSchemaRule.cxx:113,checksum,checksums,113,core/meta/src/TSchemaRule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TSchemaRule.cxx,1,['checksum'],['checksums']
Security,//-------------------------------------------------------------------------===; // Accessor functions set by OptionModifiers; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h:83,Access,Accessor,83,interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,1,['Access'],['Accessor']
Security,"//------------------------------------------------------------------------; // If the checksum is there and we're dealing with the foreign class; //------------------------------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx:86,checksum,checksum,86,tree/tree/src/TBranchSTL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx,1,['checksum'],['checksum']
Security,"//-----------------------------------------------------------------------; // Check if the checksum has been set to right value; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/src/RConversionRuleParser.cxx:91,checksum,checksum,91,core/foundation/src/RConversionRuleParser.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/src/RConversionRuleParser.cxx,1,['checksum'],['checksum']
Security,"//-----------------------------------------------------------------------; // Check if we have either version or checksum specified; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/src/RConversionRuleParser.cxx:113,checksum,checksum,113,core/foundation/src/RConversionRuleParser.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/src/RConversionRuleParser.cxx,1,['checksum'],['checksum']
Security,"//-----------------------------------------------------------------------; // Check if we're dealing with renameing declaration - sourceClass,; // targetClass and either version or checksum required; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/src/RConversionRuleParser.cxx:181,checksum,checksum,181,core/foundation/src/RConversionRuleParser.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/src/RConversionRuleParser.cxx,1,['checksum'],['checksum']
Security,"//------------------------------------------------------------------; // If the checksum matches then retrieve the info; //------------------------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx:80,checksum,checksum,80,tree/tree/src/TBranchSTL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx,1,['checksum'],['checksum']
Security,"/// ""Sanitize"" a filename so that it can be used as an identifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:5,Sanitiz,Sanitize,5,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,1,['Sanitiz'],['Sanitize']
Security,/// 'HASH' magic value to detect endianness.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:5,HASH,HASH,5,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,1,['HASH'],['HASH']
Security,"/// (CUDA) This candidate was not viable because the callee; /// was not accessible from the caller's target (i.e. host->device,; /// global->host, device->host).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h:73,access,accessible,73,interpreter/llvm-project/clang/include/clang/Sema/Overload.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h,1,['access'],['accessible']
Security,"/// .debug_names section consists of one or more units. Each unit starts with a; /// header, which is followed by a list of compilation units, local and foreign; /// type units.; ///; /// These may be followed by an (optional) hash lookup table, which consists of; /// an array of buckets and hashes similar to the apple tables above. The only; /// difference is that the hashes array is 1-based, and consequently an empty; /// bucket is denoted by 0 and not UINT32_MAX.; ///; /// Next is the name table, which consists of an array of names and array of; /// entry offsets. This is different from the apple tables, which store names; /// next to the actual entries.; ///; /// The structure of the entries is described by an abbreviations table, which; /// comes after the name table. Unlike the apple tables, which have a uniform; /// entry structure described in the header, each .debug_names entry may have; /// different index attributes (DW_IDX_???) attached to it.; ///; /// The last segment consists of a list of entries, which is a 0-terminated list; /// referenced by the name table and interpreted with the help of the; /// abbreviation table.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h:227,hash,hash,227,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h,3,['hash'],"['hash', 'hashes']"
Security,"/// @brief A wrapper class to store a C++ function of type 'double (*)(double*, double*)'.; /// The parameters can be accessed as params[<relative position of param in paramSet>] in the function body.; /// The observables can be accessed as obs[i + j], where i represents the observable position and j; /// represents the data entry.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFuncWrapper.h:118,access,accessed,118,roofit/roofitcore/inc/RooFuncWrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFuncWrapper.h,2,['access'],['accessed']
Security,"/// @brief Get an instance of the RMetaData class.; ///; /// Once this is done, the further access to the RMetaData information is granted, for example; /// (given the metadata has a key ""sample_name"" that has an associated value of type string):; /// ~~~{.cpp}; /// mySample.GetMetadata().GetS(""sample_name"");; /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSample.cxx:92,access,access,92,tree/dataframe/src/RSample.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSample.cxx,1,['access'],['access']
Security,"/// @brief Opens a file with the specified creation disposition, access mode,; /// and flags and returns a file descriptor.; ///; /// The caller is responsible for closing the file descriptor once they are; /// finished with it.; ///; /// @param Name The path of the file to open, relative or absolute.; /// @param ResultFD If the file could be opened successfully, its descriptor; /// is stored in this location. Otherwise, this is set to -1.; /// @param Disp Value specifying the existing-file behavior.; /// @param Access Value specifying whether to open the file in read, write, or; /// read-write mode.; /// @param Flags Additional flags.; /// @param Mode The access permissions of the file, represented in octal.; /// @returns errc::success if \a Name has been opened, otherwise a; /// platform-specific error_code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:65,access,access,65,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,3,"['Access', 'access']","['Access', 'access']"
Security,"/// @brief Opens a file with the specified creation disposition, access mode,; /// and flags and returns a platform-specific file object.; ///; /// The caller is responsible for closing the file object once they are; /// finished with it.; ///; /// @param Name The path of the file to open, relative or absolute.; /// @param Disp Value specifying the existing-file behavior.; /// @param Access Value specifying whether to open the file in read, write, or; /// read-write mode.; /// @param Flags Additional flags.; /// @param Mode The access permissions of the file, represented in octal.; /// @returns errc::success if \a Name has been opened, otherwise a; /// platform-specific error_code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:65,access,access,65,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,3,"['Access', 'access']","['Access', 'access']"
Security,"/// @brief Opens the file with the given name in a write-only or read-write; /// mode, returning its open file descriptor. If the file does not exist, it; /// is created.; ///; /// The caller is responsible for closing the file descriptor once they are; /// finished with it.; ///; /// @param Name The path of the file to open, relative or absolute.; /// @param ResultFD If the file could be opened successfully, its descriptor; /// is stored in this location. Otherwise, this is set to -1.; /// @param Flags Additional flags used to determine whether the file should be; /// opened in, for example, read-write or in write-only mode.; /// @param Mode The access permissions of the file, represented in octal.; /// @returns errc::success if \a Name has been opened, otherwise a; /// platform-specific error_code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:655,access,access,655,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,2,['access'],['access']
Security,"/// @brief Opens the file with the given name in a write-only or read-write; /// mode, returning its open file descriptor. If the file does not exist, it; /// is created.; ///; /// The caller is responsible for closing the freeing the file once they are; /// finished with it.; ///; /// @param Name The path of the file to open, relative or absolute.; /// @param Flags Additional flags used to determine whether the file should be; /// opened in, for example, read-write or in write-only mode.; /// @param Mode The access permissions of the file, represented in octal.; /// @returns a platform-specific file descriptor if \a Name has been opened,; /// otherwise an error object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:515,access,access,515,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,2,['access'],['access']
Security,"/// @brief Return 'true' if we can guarantee that if this class (or any class in; /// this class inheritance hierarchy) overload TObject::Hash it also starts; /// the RecursiveRemove process from its own destructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TClass.h:138,Hash,Hash,138,core/meta/inc/TClass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TClass.h,1,['Hash'],['Hash']
Security,"/// @brief Since the squashed code represents all observables as a single flattened array, it is important; /// to keep track of the start index for a vector valued observable which can later be expanded to access the correct; /// element. For example, a vector valued variable x with 10 entries will be squashed to obs[start_idx + i].; /// @param key The name of the node representing the vector valued observable.; /// @param idx The start index (or relative position of the observable in the set of all observables).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Detail/CodeSquashContext.cxx:207,access,access,207,roofit/roofitcore/src/RooFit/Detail/CodeSquashContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Detail/CodeSquashContext.cxx,1,['access'],['access']
Security,"/// @brief Stores code that eventually gets injected into main code body.; /// Mainly used for placing decls outside of loops.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h:44,inject,injected,44,roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h,1,['inject'],['injected']
Security,/// @name Accessors; /// @{; /// Name to use when invoking gcc/g++.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:10,Access,Accessors,10,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['Access'],['Accessors']
Security,"/// @name Adjacent Node Accessors; /// @{; /// Get the previous node, or \c nullptr for the list head.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h:24,Access,Accessors,24,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h,1,['Access'],['Accessors']
Security,/// @name Arg Access; /// @{; /// append - Append \p A to the arg list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Option/ArgList.h:14,Access,Access,14,interpreter/llvm-project/llvm/include/llvm/Option/ArgList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Option/ArgList.h,1,['Access'],['Access']
Security,/// @name Compiler Instance Access; /// @{,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h:28,Access,Access,28,interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,1,['Access'],['Access']
Security,/// @name Registry Access; /// @{,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/TargetRegistry.h:19,Access,Access,19,interpreter/llvm-project/llvm/include/llvm/MC/TargetRegistry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/TargetRegistry.h,1,['Access'],['Access']
Security,/// @}; // Copy local options into a globally accessible data structure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp:46,access,accessible,46,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/Options.cpp,1,['access'],['accessible']
Security,/// @}; /// @name Accessors; /// @{; /// Get the kind of this expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64MCExpr.h:18,Access,Accessors,18,interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64MCExpr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64MCExpr.h,1,['Access'],['Accessors']
Security,/// @}; /// @name Accessors; /// @{; /// This method finds the value with the given \p Name in the; /// the symbol table.; /// @returns the value associated with the \p Name; /// Lookup a named Value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ValueSymbolTable.h:18,Access,Accessors,18,interpreter/llvm-project/llvm/include/llvm/IR/ValueSymbolTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ValueSymbolTable.h,1,['Access'],['Accessors']
Security,/// @}; /// @name Accessors; /// @{; /// getOpcode - Get the kind of this expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCExpr.h:18,Access,Accessors,18,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCExpr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCExpr.h,6,['Access'],['Accessors']
Security,/// @}; /// @name Accessors; /// @{; /// getSubExpr - Get the child of this expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86MCExpr.h:18,Access,Accessors,18,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86MCExpr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86MCExpr.h,1,['Access'],['Accessors']
Security,"/// @}; /// @name Arg Access; /// @{; /// hasArg - Does the arg list contain any option matching \p Id.; ///; /// \p Claim Whether the argument should be claimed, if it exists.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Option/ArgList.h:22,Access,Access,22,interpreter/llvm-project/llvm/include/llvm/Option/ArgList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Option/ArgList.h,1,['Access'],['Access']
Security,/// @}; /// @name Comdat Accessors; /// @{; /// Return the Comdat in the module with the specified name. It is created; /// if it didn't already exist.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h:25,Access,Accessors,25,interpreter/llvm-project/llvm/include/llvm/IR/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h,1,['Access'],['Accessors']
Security,"/// @}; /// @name Convenience Predicates; /// @{; /// Test whether the architecture is 64-bit; ///; /// Note that this tests for 64-bit pointer width, and nothing else. Note; /// that we intentionally expose only three predicates, 64-bit, 32-bit, and; /// 16-bit. The inner details of pointer width for particular architectures; /// is not summed up in the triple, and so only a coarse grained predicate; /// system is provided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/Triple.h:201,expose,expose,201,interpreter/llvm-project/llvm/include/llvm/TargetParser/Triple.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/Triple.h,1,['expose'],['expose']
Security,/// @}; /// @name Direct Component Access; /// @{,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/Triple.h:35,Access,Access,35,interpreter/llvm-project/llvm/include/llvm/TargetParser/Triple.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/Triple.h,1,['Access'],['Access']
Security,"/// @}; /// @name Direct access to the globals list, functions list, and symbol table; /// @{; /// Get the Module's list of global variables (constant).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h:25,access,access,25,interpreter/llvm-project/llvm/include/llvm/IR/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h,1,['access'],['access']
Security,"/// @}; /// @name Function Accessors; /// @{; /// Look up the specified function in the module symbol table. Four; /// possibilities:; /// 1. If it does not exist, add a prototype for the function and return it.; /// 2. Otherwise, if the existing function has the correct prototype, return; /// the existing function.; /// 3. Finally, the function exists but has the wrong prototype: return the; /// function with a constantexpr cast to the right prototype.; ///; /// In all cases, the returned value is a FunctionCallee wrapper around the; /// 'FunctionType *T' passed in, as well as a 'Value*' either of the Function or; /// the bitcast to the function.; ///; /// Note: For library calls getOrInsertLibFunc() should be used instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h:27,Access,Accessors,27,interpreter/llvm-project/llvm/include/llvm/IR/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h,1,['Access'],['Accessors']
Security,"/// @}; /// @name Generic Value Accessors; /// @{; /// Return the global value in the module with the specified name, of; /// arbitrary type. This method returns null if a global with the specified; /// name is not found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h:32,Access,Accessors,32,interpreter/llvm-project/llvm/include/llvm/IR/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h,1,['Access'],['Accessors']
Security,"/// @}; /// @name Global Alias Accessors; /// @{; /// Return the global alias in the module with the specified name, of; /// arbitrary type. This method returns null if a global with the specified; /// name is not found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h:31,Access,Accessors,31,interpreter/llvm-project/llvm/include/llvm/IR/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h,1,['Access'],['Accessors']
Security,"/// @}; /// @name Global IFunc Accessors; /// @{; /// Return the global ifunc in the module with the specified name, of; /// arbitrary type. This method returns null if a global with the specified; /// name is not found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h:31,Access,Accessors,31,interpreter/llvm-project/llvm/include/llvm/IR/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h,1,['Access'],['Accessors']
Security,"/// @}; /// @name Global Variable Accessors; /// @{; /// Look up the specified global variable in the module symbol table. If it; /// does not exist, return null. If AllowInternal is set to true, this; /// function will return types that have InternalLinkage. By default, these; /// types are not returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h:34,Access,Accessors,34,interpreter/llvm-project/llvm/include/llvm/IR/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h,1,['Access'],['Accessors']
Security,/// @}; /// @name Module Flags Accessors; /// @{; /// Returns the module flags in the provided vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h:31,Access,Accessors,31,interpreter/llvm-project/llvm/include/llvm/IR/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h,1,['Access'],['Accessors']
Security,"/// @}; /// @name Module Level Accessors; /// @{; /// Get the module identifier which is, essentially, the name of the module.; /// @returns the module identifier as a string",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h:31,Access,Accessors,31,interpreter/llvm-project/llvm/include/llvm/IR/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h,1,['Access'],['Accessors']
Security,/// @}; /// @name Named Metadata Accessors; /// @{; /// Return the first NamedMDNode in the module with the specified name. This; /// method returns null if a NamedMDNode with the specified name is not found.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h:33,Access,Accessors,33,interpreter/llvm-project/llvm/include/llvm/IR/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h,1,['Access'],['Accessors']
Security,/// @}; /// @name Target Registration; /// @{; /// RegisterTarget - Register the given target. Attempts to register a; /// target which has already been registered will be ignored.; ///; /// Clients are responsible for ensuring that registration doesn't occur; /// while another thread is attempting to access the registry. Typically; /// this is done by initializing all targets at program startup.; ///; /// @param T - The target being registered.; /// @param Name - The target name. This should be a static string.; /// @param ShortDesc - A short target description. This should be a static; /// string.; /// @param BackendName - The name of the backend. This should be a static; /// string that is the same for all targets that share a backend; /// implementation and must match the name used in the 'def X : Target ...' in; /// TableGen.; /// @param ArchMatchFn - The arch match checking function for this target.; /// @param HasJIT - Whether the target supports JIT code; /// generation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/TargetRegistry.h:303,access,access,303,interpreter/llvm-project/llvm/include/llvm/MC/TargetRegistry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/TargetRegistry.h,1,['access'],['access']
Security,/// @}; /// @name Typed Component Access; /// @{; /// Get the parsed architecture type of this triple.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/Triple.h:34,Access,Access,34,interpreter/llvm-project/llvm/include/llvm/TargetParser/Triple.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/Triple.h,1,['Access'],['Access']
Security,"/// @}; /// Create a compiler invocation from a list of input options.; /// \returns true on success.; ///; /// \returns false if an error was encountered while parsing the arguments; /// and attempts to recover and continue parsing the rest of the arguments.; /// The recovery is best-effort and only guarantees that \p Res will end up in; /// one of the vaild-to-access (albeit arbitrary) states.; ///; /// \param [out] Res - The resulting invocation.; /// \param [in] CommandLineArgs - Array of argument strings, this must not; /// contain ""-cc1"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h:365,access,access,365,interpreter/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h,1,['access'],['access']
Security,/// @}; /// Reference to the loop user variable as accessed in the loop body.; /// @{,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:51,access,accessed,51,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,1,['access'],['accessed']
Security,/// @}; /// \defgroup Data members accessed sequentially.; ///; /// @{; /// DwarfStringPoolEntries for .debug_str section.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:35,access,accessed,35,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,1,['access'],['accessed']
Security,/// @}; /// \name Accessors related to the insertion points.; /// @{,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h:18,Access,Accessors,18,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,1,['Access'],['Accessors']
Security,/// @}; /// \name Accessors; /// @{,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCExpr.h:18,Access,Accessors,18,interpreter/llvm-project/llvm/include/llvm/MC/MCExpr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCExpr.h,3,['Access'],['Accessors']
Security,/// @}; /// \name Accessors; /// @{; /// Get the kind of this binary expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCExpr.h:18,Access,Accessors,18,interpreter/llvm-project/llvm/include/llvm/MC/MCExpr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCExpr.h,1,['Access'],['Accessors']
Security,/// @}; /// \name Accessors; /// @{; /// Get the kind of this unary expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCExpr.h:18,Access,Accessors,18,interpreter/llvm-project/llvm/include/llvm/MC/MCExpr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCExpr.h,1,['Access'],['Accessors']
Security,/// @}; /// \name Backend Data Access; /// @{,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h:31,Access,Access,31,interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h,1,['Access'],['Access']
Security,"/// @}; /// \name Data Region List Access; /// @{; // FIXME: This is a total hack, this should not be here. Once things are; // factored so that the streamer has direct access to the .o writer, it can; // disappear.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h:35,Access,Access,35,interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h,4,"['Access', 'access']","['Access', 'access']"
Security,"/// @}; /// \name Indirect Symbol List Access; /// @{; // FIXME: This is a total hack, this should not be here. Once things are; // factored so that the streamer has direct access to the .o writer, it can; // disappear.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h:39,Access,Access,39,interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h,2,"['Access', 'access']","['Access', 'access']"
Security,/// @}; /// \name Linker Option List Access; /// @{,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h:37,Access,Access,37,interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h,1,['Access'],['Access']
Security,/// @}; /// \name Symbol List Access; /// @{,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h:30,Access,Access,30,interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h,1,['Access'],['Access']
Security,/// @}; /// \name Target Writer Proxy Accessors; /// @{,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCMachObjectWriter.h:38,Access,Accessors,38,interpreter/llvm-project/llvm/include/llvm/MC/MCMachObjectWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCMachObjectWriter.h,1,['Access'],['Accessors']
Security,"/// @}; //===--------------------------------------------------------------------===//; // Accessors used to build up machine instructions.; /// Add the specified operand to the instruction. If it is an implicit; /// operand, it is added to the end of the operand list. If it is an; /// explicit operand it is added at the end of the explicit operand list; /// (before the first implicit operand).; ///; /// MF must be the machine function that was used to allocate this; /// instruction.; ///; /// MachineInstrBuilder provides a more convenient interface for creating; /// instructions and adding operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:91,Access,Accessors,91,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['Access'],['Accessors']
Security,"/// A ""must be executed context"" for a given program point PP is the set of; /// instructions, potentially before and after PP, that are executed always when; /// PP is reached. The MustBeExecutedContextExplorer an interface to explore; /// ""must be executed contexts"" in a module through the use of; /// MustBeExecutedIterator.; ///; /// The explorer exposes ""must be executed iterators"" that traverse the must be; /// executed context. There is little information sharing between iterators as; /// the expected use case involves few iterators for ""far apart"" instructions.; /// If that changes, we should consider caching more intermediate results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:352,expose,exposes,352,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,1,['expose'],['exposes']
Security,"/// A C++ access specifier (public, private, protected), plus the; /// special value ""none"" which means different things in different contexts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Specifiers.h:10,access,access,10,interpreter/llvm-project/clang/include/clang/Basic/Specifiers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Specifiers.h,1,['access'],['access']
Security,/// A CFG hash code used to identify a function code changes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h:10,hash,hash,10,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfileProbe.h,1,['hash'],['hash']
Security,"/// A DeclContext is a named program scope that is used for ODR uniquing of; /// types.; ///; /// The set of DeclContext for the ODR-subject parts of a Dwarf link is; /// expanded (and uniqued) with each new object file processed. We need to; /// determine the context of each DIE in an linked object file to see if the; /// corresponding type has already been emitted.; ///; /// The contexts are conceptually organized as a tree (eg. a function scope is; /// contained in a namespace scope that contains other scopes), but; /// storing/accessing them in an actual tree is too inefficient: we need to be; /// able to very quickly query a context for a given child context by name.; /// Storing a StringMap in each DeclContext would be too space inefficient.; ///; /// The solution here is to give each DeclContext a link to its parent (this; /// allows to walk up the tree), but to query the existence of a specific; /// DeclContext using a separate DenseMap keyed on the hash of the fully; /// qualified name of the context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinkerDeclContext.h:537,access,accessing,537,interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinkerDeclContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinkerDeclContext.h,2,"['access', 'hash']","['accessing', 'hash']"
Security,"/// A FactSet is the set of facts that are known to be true at a; /// particular program point. FactSets must be small, because they are; /// frequently copied, and are thus implemented as a set of indices into a; /// table maintained by a FactManager. A typical FactSet only holds 1 or 2; /// locks, so we can get away with doing a linear search for lookup. Note; /// that a hashtable or map is inappropriate in this case, because lookups; /// may involve partial pattern matches, rather than exact matches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:376,hash,hashtable,376,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,1,['hash'],['hashtable']
Security,"/// A MemorySSAWalker that does AA walks to disambiguate accesses. It no; /// longer does caching on its own, but the name has been retained for the; /// moment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:57,access,accesses,57,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['access'],['accesses']
Security,/// A POD class for pairing a NamedDecl* with an access specifier.; /// Can be put into unions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclAccessPair.h:49,access,access,49,interpreter/llvm-project/clang/include/clang/AST/DeclAccessPair.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclAccessPair.h,1,['access'],['access']
Security,"/// A TObject-derived class to inject the memory regulation logic in the ROOT list of cleanups.; ///; /// The purpose of this class is to keep the responsibilities separate between; /// the TMemoryRegulator logic and the rest of ROOT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/TMemoryRegulator.h:31,inject,inject,31,bindings/pyroot/pythonizations/src/TMemoryRegulator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/TMemoryRegulator.h,1,['inject'],['inject']
Security,"/// A Trace object represents the records that have been loaded from XRay; /// log files generated by instrumented binaries. We encapsulate the logic of; /// reading the traces in factory functions that populate the Trace object; /// appropriately.; ///; /// Trace objects provide an accessor to an XRayFileHeader which says more about; /// details of the file from which the XRay trace was loaded from.; ///; /// Usage:; ///; /// if (auto TraceOrErr = loadTraceFile(""xray-log.something.xray"")) {; /// auto& T = *TraceOrErr;; /// // T.getFileHeader() will provide information from the trace header.; /// for (const XRayRecord &R : T) {; /// // ... do something with R here.; /// }; /// } else {; /// // Handle the error here.; /// }; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:284,access,accessor,284,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,1,['access'],['accessor']
Security,"/// A Value is an JSON value of unknown type.; /// They can be copied, but should generally be moved.; ///; /// === Composing values ===; ///; /// You can implicitly construct Values from:; /// - strings: std::string, SmallString, formatv, StringRef, char*; /// (char*, and StringRef are references, not copies!); /// - numbers; /// - booleans; /// - null: nullptr; /// - arrays: {""foo"", 42.0, false}; /// - serializable things: types with toJSON(const T&)->Value, found by ADL; ///; /// They can also be constructed from object/array helpers:; /// - json::Object is a type like map<ObjectKey, Value>; /// - json::Array is a type like vector<Value>; /// These can be list-initialized, or used to build up collections in a loop.; /// json::ary(Collection) converts all items in a collection to Values.; ///; /// === Inspecting values ===; ///; /// Each Value is one of the JSON kinds:; /// null (nullptr_t); /// boolean (bool); /// number (double, int64 or uint64); /// string (StringRef); /// array (json::Array); /// object (json::Object); ///; /// The kind can be queried directly, or implicitly via the typed accessors:; /// if (std::optional<StringRef> S = E.getAsString(); /// assert(E.kind() == Value::String);; ///; /// Array and Object also have typed indexing accessors for easy traversal:; /// Expected<Value> E = parse(R""( {""options"": {""font"": ""sans-serif""}} )"");; /// if (Object* O = E->getAsObject()); /// if (Object* Opts = O->getObject(""options"")); /// if (std::optional<StringRef> Font = Opts->getString(""font"")); /// assert(Opts->at(""font"").kind() == Value::String);; ///; /// === Converting JSON values to C++ types ===; ///; /// The convention is to have a deserializer function findable via ADL:; /// fromJSON(const json::Value&, T&, Path) -> bool; ///; /// The return value indicates overall success, and Path is used for precise; /// error reporting. (The Path::Root passed in at the top level fromJSON call; /// captures any nested error and can render it in context).; /// If c",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h:1112,access,accessors,1112,interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,1,['access'],['accessors']
Security,/// A class providing access to the contents of a minidump file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h:22,access,access,22,interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/Minidump.h,1,['access'],['access']
Security,"/// A class that represents a single row in the unwind table that is decoded by; /// parsing the DWARF Call Frame Information opcodes.; ///; /// The row consists of an optional address, the rule to unwind the CFA and all; /// rules to unwind any registers. If the address doesn't have a value, this; /// row represents the initial instructions for a CIE. If the address has a; /// value the UnwindRow represents a row in the UnwindTable for a FDE. The; /// address is the first address for which the CFA location and register rules; /// are valid within a function.; ///; /// UnwindRow objects are created by parsing opcodes in the DWARF Call Frame; /// Information and UnwindRow objects are lazily populated and pushed onto a; /// stack in the UnwindTable when evaluating this state machine. Accessors are; /// needed for the address, CFA value, and register locations as the opcodes; /// encode a state machine that produces a sorted array of UnwindRow objects; /// \see UnwindTable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h:793,Access,Accessors,793,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h,1,['Access'],['Accessors']
Security,"/// A collection of ValueTables, one per BB in a function, with convenient; /// accessor methods.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:80,access,accessor,80,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,1,['access'],['accessor']
Security,/// A collection of metadata nodes that might be associated with a; /// memory access used by the alias-analysis infrastructure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Metadata.h:79,access,access,79,interpreter/llvm-project/llvm/include/llvm/IR/Metadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Metadata.h,1,['access'],['access']
Security,"/// A collection of on-disk hash tables, merged when relevant for performance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h:28,hash,hash,28,interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h,1,['hash'],['hash']
Security,/// A container for a CompilerInstance (possibly with an ExternalASTMerger; /// attached to its ASTContext).; ///; /// Provides an accessor for the DeclContext origins associated with the; /// ExternalASTMerger (or an empty list of origins if no ExternalASTMerger is; /// attached).; ///; /// This is the main unit of parsed source code maintained by clang-import-test.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp:131,access,accessor,131,interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-import-test/clang-import-test.cpp,1,['access'],['accessor']
Security,/// A container which contains a StringRef plus a precomputed hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h:62,hash,hash,62,interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,1,['hash'],['hash']
Security,"/// A container which contains a string, which it owns, plus a precomputed hash.; ///; /// We do not null-terminate the string.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h:75,hash,hash,75,interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,1,['hash'],['hash']
Security,"/// A declaration being accessed, together with information about how; /// it was accessed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DelayedDiagnostic.h:24,access,accessed,24,interpreter/llvm-project/clang/include/clang/Sema/DelayedDiagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DelayedDiagnostic.h,2,['access'],['accessed']
Security,"/// A flag tracking whether this value has been poisoned.; ///; /// On delete and RAUW, we leave the value pointer alone so that as a raw; /// pointer it produces the same value (and we fit into the same key of; /// a hash table, etc), but we poison the handle so that any top-level usage; /// will fail.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ValueHandle.h:218,hash,hash,218,interpreter/llvm-project/llvm/include/llvm/IR/ValueHandle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ValueHandle.h,1,['hash'],['hash']
Security,"/// A forward range over the partitions of the alloca's slices.; ///; /// This accesses an iterator range over the partitions of the alloca's; /// slices. It computes these partitions on the fly based on the overlapping; /// offsets of the slices and the ability to split them. It will visit ""empty""; /// partitions to cover regions of the alloca only accessed via split; /// slices.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:79,access,accesses,79,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,2,['access'],"['accessed', 'accesses']"
Security,/// A frontend action which simply wraps some other runtime-specified; /// frontend action.; ///; /// Deriving from this class allows an action to inject custom logic around; /// some existing action's behavior. It implements every virtual method in; /// the FrontendAction interface by forwarding to the wrapped action.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h:147,inject,inject,147,interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,1,['inject'],['inject']
Security,"/// A globally hashed type represents a hash value that is sufficient to; /// uniquely identify a record across multiple type streams or type sequences.; /// This works by, for any given record A which references B, replacing the; /// TypeIndex that refers to B with a previously-computed global hash for B. As; /// this is a recursive algorithm (e.g. the global hash of B also depends on the; /// global hashes of the types that B refers to), a global hash can uniquely; /// identify that A occurs in another stream that has a completely; /// different graph structure. Although the hash itself is slower to compute,; /// probing is much faster with a globally hashed type, because the hash itself; /// is considered ""as good as"" the original type. Since type records can be; /// quite large, this makes the equality comparison of the hash much faster than; /// equality comparison of a full record.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeHashing.h:15,hash,hashed,15,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeHashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeHashing.h,10,['hash'],"['hash', 'hashed', 'hashes']"
Security,/// A handle to a particular switch case. It exposes a convenient interface; /// to both the case value and the successor block.; ///; /// We define this as a template and instantiate it to form both a const and; /// non-const handle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:45,expose,exposes,45,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['expose'],['exposes']
Security,"/// A handy container for a FunctionType+Callee-pointer pair, which can be; /// passed around as a single entity. This assists in replacing the use of; /// PointerType::getElementType() to access the function's type, since that's; /// slated for removal as part of the [opaque pointer types] project.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h:189,access,access,189,interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h,1,['access'],['access']
Security,"/// A hash mismatch occurs when a profile record for a symbol does not have; /// the same hash as a coverage mapping record for the same symbol. This; /// returns a list of hash mismatches, where each mismatch is a pair of the; /// symbol name and its coverage mapping hash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h:6,hash,hash,6,interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h,4,['hash'],['hash']
Security,/// A hash of parts of the class to help in ODR checking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:6,hash,hash,6,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,3,['hash'],['hash']
Security,/// A hash table stored on disk.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h:6,hash,hash,6,interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h,1,['hash'],['hash']
Security,/// A helper class for checking for a friend which will grant access; /// to a protected instance member.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:62,access,access,62,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['access'],['access']
Security,"/// A helper class keeping track of loaded libraries. It implements a fast; /// search O(1) while keeping deterministic iterability in a memory efficient; /// way. The underlying set uses a custom hasher for better efficiency given the; /// specific problem where the library names (m_LibName) are relatively short; /// strings and the base paths (m_Path) are repetitive long strings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp:197,hash,hasher,197,interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,1,['hash'],['hasher']
Security,/// A helper class that contains everything needed to construct a; /// PathDiagnostic object. It does no much more then providing convenient; /// getters and some well placed asserts for extra security.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:193,secur,security,193,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['secur'],['security']
Security,/// A helper function for determining the number of interleaved accesses we; /// will generate when lowering accesses of the given type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:64,access,accesses,64,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,4,['access'],['accesses']
Security,/// A lightweight accessor for an operand bundle meant to be passed; /// around by value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:18,access,accessor,18,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['access'],['accessor']
Security,/// A linked list of values in a particular hash bucket.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h:44,hash,hash,44,interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h,1,['hash'],['hash']
Security,"/// A linked-list with a custom, local allocator.; ///; /// Expose a std::list-like interface that owns and uses a custom LLVM-style; /// allocator (e.g., BumpPtrAllocator), leveraging \a simple_ilist for the; /// implementation details.; ///; /// Because this list owns the allocator, calling \a splice() with a different; /// list isn't generally safe. As such, \a splice has been left out of the; /// interface entirely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AllocatorList.h:60,Expose,Expose,60,interpreter/llvm-project/llvm/include/llvm/ADT/AllocatorList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AllocatorList.h,1,['Expose'],['Expose']
Security,"/// A list of (pointer-difference, access size) pairs that can be used to; /// prove that there are no vectorization-preventing dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:35,access,access,35,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['access'],['access']
Security,"/// A list of module identifiers this module directly depends on, not; /// including transitive dependencies.; ///; /// This may include modules with a different context hash when it can be; /// determined that the differences are benign for this compilation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:170,hash,hash,170,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,1,['hash'],['hash']
Security,"/// A list of modules this translation unit directly depends on, not including; /// transitive dependencies.; ///; /// This may include modules with a different context hash when it can be; /// determined that the differences are benign for this compilation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h:169,hash,hash,169,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningTool.h,1,['hash'],['hash']
Security,/// A list of upward exposed vreg uses that need to be satisfied by either a; /// copy def or a phi node at the beginning of the basic block representing; /// the predecessor(s) swifterror value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SwiftErrorValueTracking.h:21,expose,exposed,21,interpreter/llvm-project/llvm/include/llvm/CodeGen/SwiftErrorValueTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SwiftErrorValueTracking.h,1,['expose'],['exposed']
Security,/// A loaded pass plugin.; ///; /// An instance of this class wraps a loaded pass plugin and gives access to; /// its interface defined by the \c PassPluginLibraryInfo it exposes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h:99,access,access,99,interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h,2,"['access', 'expose']","['access', 'exposes']"
Security,"/// A locally hashed type represents a straightforward hash code of a serialized; /// record. The record is simply serialized, and then the bytes are hashed by; /// a standard algorithm. This is sufficient for the case of de-duplicating; /// records within a single sequence of types, because if two records both have; /// a back-reference to the same type in the same stream, they will both have; /// the same numeric value for the TypeIndex of the back reference.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeHashing.h:14,hash,hashed,14,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeHashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/TypeHashing.h,3,['hash'],"['hash', 'hashed']"
Security,"/// A map containing the hash of the lookup buffer. This allows us to avoid; /// allocating memory for parsing when we know nothing has changed. Used by; /// StartParsingRAII.; // We do not want to include ""clang/Basic/SourceLocation.h"" because it makes; // the use of this header at runtime significantly slower.; // We really need llvm::hash_code->clang::FileID mapping but we put opaque; // source location as unsigned to compute the FileID when needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/LookupHelper.h:25,hash,hash,25,interpreter/cling/include/cling/Interpreter/LookupHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/LookupHelper.h,1,['hash'],['hash']
Security,"/// A node in the call graph.; ///; /// This represents a single node. Its primary roles are to cache the list of; /// callees, de-duplicate and provide fast testing of whether a function is a; /// callee, and facilitate iteration of child nodes in the graph.; ///; /// The node works much like an optional in order to lazily populate the; /// edges of each node. Until populated, there are no edges. Once populated,; /// you can access the edges by dereferencing the node or using the `->`; /// operator as if the node was an `std::optional<EdgeSequence>`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:430,access,access,430,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,1,['access'],['access']
Security,"/// A pair of a canonical FunctionDecl and a SourceLocation. When used as the; /// key in a hashtable, both the FD and location are hashed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:92,hash,hashtable,92,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['hash'],"['hashed', 'hashtable']"
Security,"/// A partition of the slices.; ///; /// An ephemeral representation for a range of slices which can be viewed as; /// a partition of the alloca. This range represents a span of the alloca's; /// memory which cannot be split, and provides access to all of the slices; /// overlapping some part of the partition.; ///; /// Objects of this type are produced by traversing the alloca's slices, but; /// are only ephemeral and not persistent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:239,access,access,239,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['access'],['access']
Security,"/// A pointer to a memory block, live or dead.; ///; /// This object can be allocated into interpreter stack frames. If pointing to; /// a live block, it is a link in the chain of pointers pointing to the block.; ///; /// In the simplest form, a Pointer has a Block* (the pointee) and both Base; /// and Offset are 0, which means it will point to raw data.; ///; /// The Base field is used to access metadata about the data. For primitive; /// arrays, the Base is followed by an InitMap. In a variety of cases, the; /// Base is preceded by an InlineDescriptor, which is used to track the; /// initialization state, among other things.; ///; /// The Offset field is used to access the actual data. In other words, the; /// data the pointer decribes can be found at; /// Pointee->rawData() + Pointer.Offset.; ///; ///; /// Pointee Offset; /// │ │; /// │ │; /// ▼ ▼; /// ┌───────┬────────────┬─────────┬────────────────────────────┐; /// │ Block │ InlineDesc │ InitMap │ Actual Data │; /// └───────┴────────────┴─────────┴────────────────────────────┘; /// ▲; /// │; /// │; /// Base",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h:393,access,access,393,interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h,2,['access'],['access']
Security,"/// A pointer to an on-disk hash table of opaque type; /// ASTSelectorLookupTable.; ///; /// This hash table provides the IDs of all selectors, and the associated; /// instance and factory methods.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h:28,hash,hash,28,interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,2,['hash'],['hash']
Security,/// A pointer to an on-disk hash table of opaque type; /// IdentifierHashTable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h:28,hash,hash,28,interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,1,['hash'],['hash']
Security,/// A pointer to an on-disk representation of the hash table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h:50,hash,hash,50,interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h,1,['hash'],['hash']
Security,/// A precomputed hash tag used for uniquing PDFileEntry objects.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h:18,hash,hash,18,interpreter/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h,1,['hash'],['hash']
Security,/// A proxy object for computing a pointer via indirecting a copy of a; /// reference. This is used in APIs which need to produce a pointer but for; /// which the reference might be a temporary. The proxy preserves the; /// reference internally and exposes the pointer via a arrow operator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h:249,expose,exposes,249,interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,1,['expose'],['exposes']
Security,/// A proxy object for computing a reference via indirecting a copy of an; /// iterator. This is used in APIs which need to produce a reference via; /// indirection but for which the iterator object might be a temporary. The; /// proxy preserves the iterator internally and exposes the indirected; /// reference via a conversion operator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h:274,expose,exposes,274,interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,1,['expose'],['exposes']
Security,/// A raw_ostream that hash the content using the sha1 algorithm.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_sha1_ostream.h:23,hash,hash,23,interpreter/llvm-project/llvm/include/llvm/Support/raw_sha1_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_sha1_ostream.h,1,['hash'],['hash']
Security,/// A readonly view of a hash table used in the globals and publics streams.; /// Most clients will only want to iterate this to get symbol record offsets; /// into the PDB symbol stream.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/GlobalsStream.h:25,hash,hash,25,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/GlobalsStream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/GlobalsStream.h,1,['hash'],['hash']
Security,"/// A recipe to compute the pointers for widened memory accesses of IndexTy for; /// all parts. If IsReverse is true, compute pointers for accessing the input in; /// reverse order per part.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:56,access,accesses,56,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,2,['access'],"['accesses', 'accessing']"
Security,/// A record for a potential prefetch made during the initial scan of the; /// loop. This is used to let a single prefetch target multiple memory accesses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp:146,access,accesses,146,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp,1,['access'],['accesses']
Security,"/// A reference group represents a set of memory references that exhibit; /// temporal or spacial reuse. Two references belong to the same; /// reference group with respect to a inner loop L iff:; /// 1. they have a loop independent dependency, or; /// 2. they have a loop carried dependence with a small dependence distance; /// (e.g. less than 2) carried by the inner loop, or; /// 3. they refer to the same array, and the subscript in their innermost; /// dimension is less than or equal to 'd' (where 'd' is less than the cache; /// line size); ///; /// Intuitively a reference group represents memory references that access; /// the same cache line. Conditions 1,2 above account for temporal reuse, while; /// contition 3 accounts for spacial reuse.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:622,access,access,622,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,1,['access'],['access']
Security,/// A reference to a \c DirectoryEntry that includes the name of the directory; /// as it was accessed by the FileManager's client.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DirectoryEntry.h:94,access,accessed,94,interpreter/llvm-project/clang/include/clang/Basic/DirectoryEntry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DirectoryEntry.h,1,['access'],['accessed']
Security,/// A reference to a \c FileEntry that includes the name of the file as it was; /// accessed by the FileManager's client.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileEntry.h:84,access,accessed,84,interpreter/llvm-project/clang/include/clang/Basic/FileEntry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileEntry.h,1,['access'],['accessed']
Security,/// A reference to an Interned FoldingSetNodeID for this node.; /// The Allocator in SelectionDAG holds the data.; /// SDVTList contains all types which are frequently accessed in SelectionDAG.; /// The size of this list is not expected to be big so it won't introduce; /// a memory penalty.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:168,access,accessed,168,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['access'],['accessed']
Security,"/// A relation between a parent and child node, e.g. 'left-hand-side of; /// a binary expression'. Used for implementing accessors.; ///; /// In general `NodeRole`s should be named the same as their accessors.; ///; /// Some roles describe parent/child relations that occur multiple times in; /// language grammar. We define only one role to describe all instances of such; /// recurring relations. For example, grammar for both ""if"" and ""while""; /// statements requires an opening paren and a closing paren. The opening; /// paren token is assigned the OpenParen role regardless of whether it appears; /// as a child of IfStatement or WhileStatement node. More generally, when; /// grammar requires a certain fixed token (like a specific keyword, or an; /// opening paren), we define a role for this token and use it across all; /// grammar rules with the same requirement. Names of such reusable roles end; /// with a ~Token or a ~Keyword suffix.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h:121,access,accessors,121,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,2,['access'],['accessors']
Security,"/// A rewritten comparison expression that was originally written using; /// operator syntax.; ///; /// In C++20, the following rewrites are performed:; /// - <tt>a == b</tt> -> <tt>b == a</tt>; /// - <tt>a != b</tt> -> <tt>!(a == b)</tt>; /// - <tt>a != b</tt> -> <tt>!(b == a)</tt>; /// - For \c \@ in \c <, \c <=, \c >, \c >=, \c <=>:; /// - <tt>a @ b</tt> -> <tt>(a <=> b) @ 0</tt>; /// - <tt>a @ b</tt> -> <tt>0 @ (b <=> a)</tt>; ///; /// This expression provides access to both the original syntax and the; /// rewritten expression.; ///; /// Note that the rewritten calls to \c ==, \c <=>, and \c \@ are typically; /// \c CXXOperatorCallExprs, but could theoretically be \c BinaryOperators.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:469,access,access,469,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,1,['access'],['access']
Security,"/// A scoped hash table of the current values of all of our simple; /// scalar expressions.; ///; /// As we walk down the domtree, we look to see if instructions are in this:; /// if so, we replace them with what we find, otherwise we insert them so; /// that dominated values can succeed in their lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:13,hash,hash,13,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['hash'],['hash']
Security,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:13,hash,hash,13,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,2,"['access', 'hash']","['access', 'hash']"
Security,/// A scoped hash table of the current values of read-only call; /// values.; ///; /// It uses the same generation count as loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:13,hash,hash,13,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['hash'],['hash']
Security,"/// A set of symbols to look up, each associated with a SymbolLookupFlags; /// value.; ///; /// This class is backed by a vector and optimized for fast insertion,; /// deletion and iteration. It does not guarantee a stable order between; /// operations, and will not automatically detect duplicate elements (they; /// can be manually checked by calling the validate method).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:357,validat,validate,357,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['validat'],['validate']
Security,"/// A setup object containing callbacks to construct a memory manager and; /// memory access object. Both are optional. If not specified,; /// EPCGenericJITLinkMemoryManager and EPCGenericMemoryAccess will be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/SimpleRemoteEPC.h:86,access,access,86,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/SimpleRemoteEPC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/SimpleRemoteEPC.h,1,['access'],['access']
Security,"/// A single checksum, represented by a \a Kind and a \a Value (a string).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h:13,checksum,checksum,13,interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h,1,['checksum'],['checksum']
Security,/// A single item in the hash table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h:25,hash,hash,25,interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h,1,['hash'],['hash']
Security,/// A single parameter index whose accessors require each use to make explicit; /// the parameter index encoding needed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Attr.h:35,access,accessors,35,interpreter/llvm-project/clang/include/clang/AST/Attr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Attr.h,1,['access'],['accessors']
Security,"/// A stable hash value for machine instructions.; /// Returns 0 if no stable hash could be computed.; /// The hashing and equality testing functions ignore definitions so this is; /// useful for CSE, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp:13,hash,hash,13,interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineStableHash.cpp,3,['hash'],"['hash', 'hashing']"
Security,"/// A storage location for a record (struct, class, or union).; ///; /// Contains storage locations for all modeled fields of the record (also; /// referred to as ""children""). The child map is flat, so accessible members of; /// the base class are directly accessible as children of this location.; ///; /// Record storage locations may also contain so-called synthetic fields. These; /// are typically used to model the internal state of a class (e.g. the value; /// stored in a `std::optional`) without having to depend on that class's; /// implementation details. All `RecordStorageLocation`s of a given type should; /// have the same synthetic fields.; ///; /// The storage location for a field of reference type may be null. This; /// typically occurs in one of two situations:; /// - The record has not been fully initialized.; /// - The maximum depth for modelling a self-referential data structure has been; /// reached.; /// Storage locations for fields of all other types must be non-null.; ///; /// FIXME: Currently, the storage location of unions is modelled the same way as; /// that of structs or classes. Eventually, we need to change this modelling so; /// that all of the members of a given union have the same storage location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/StorageLocation.h:202,access,accessible,202,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/StorageLocation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/StorageLocation.h,2,['access'],['accessible']
Security,/// A string hash of the top-level declaration and macro definition; /// names processed the last time that we reparsed the file.; ///; /// This hash value is used to determine when we need to refresh the; /// global code-completion cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:13,hash,hash,13,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,2,['hash'],['hash']
Security,/// A string hash of the top-level declaration and macro definition; /// names processed the last time that we reparsed the precompiled preamble.; ///; /// This hash value is used to determine when we need to refresh the; /// global code-completion cache after a rebuild of the precompiled preamble.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:13,hash,hash,13,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,2,['hash'],['hash']
Security,"/// A struct to densely store the state of an instruction after unrolling at; /// each iteration.; ///; /// This is designed to work like a tuple of <Instruction *, int> for the; /// purposes of hashing and lookup, but to be able to associate two boolean; /// states with each key.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:195,hash,hashing,195,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['hash'],['hashing']
Security,"/// A structure for putting ""fast""-unqualified QualTypes into a; /// DenseMap. This uses the standard pointer hash function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h:110,hash,hash,110,interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h,1,['hash'],['hash']
Security,"/// A trie to efficiently match against the entries of the compilation; /// database in order of matching suffix length.; ///; /// When a clang tool is supposed to operate on a specific file, we have to; /// find the corresponding file in the compilation database. Although entries; /// in the compilation database are keyed by filename, a simple string match; /// is insufficient because of symlinks. Commonly, a project hierarchy looks; /// like this:; /// /<project-root>/src/<path>/<somefile>.cc (used as input for the tool); /// /<project-root>/build/<symlink-to-src>/<path>/<somefile>.cc (stored in DB); ///; /// Furthermore, there might be symlinks inside the source folder or inside the; /// database, so that the same source file is translated with different build; /// options.; ///; /// For a given input file, the \c FileMatchTrie finds its entries in order; /// of matching suffix length. For each suffix length, there might be one or; /// more entries in the database. For each of those entries, it calls; /// \c llvm::sys::fs::equivalent() (injected as \c PathComparator). There might; /// be zero or more entries with the same matching suffix length that are; /// equivalent to the input file. Three cases are distinguished:; /// 0 equivalent files: Continue with the next suffix length.; /// 1 equivalent file: Best match found, return it.; /// >1 equivalent files: Match is ambiguous, return error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h:1056,inject,injected,1056,interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/FileMatchTrie.h,1,['inject'],['injected']
Security,/// A type that provides access to a new line separated list of symbol names to; /// ignore when extracting API information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/APIIgnoresList.h:25,access,access,25,interpreter/llvm-project/clang/include/clang/ExtractAPI/APIIgnoresList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ExtractAPI/APIIgnoresList.h,1,['access'],['access']
Security,"/// A type-list implementation.; ///; /// A ""linked list"" of types, accessible by using the ::head and ::tail; /// typedefs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h:68,access,accessible,68,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h,1,['access'],['accessible']
Security,"/// A uniform memory op is a load or store which accesses the same memory; /// location on all \p VF lanes, if \p VF is provided and otherwise if the; /// memory location is invariant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:49,access,accesses,49,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['access'],['accesses']
Security,"/// A utility class to expose symbols found via dlsym to the JIT.; ///; /// If an instance of this class is attached to a JITDylib as a fallback; /// definition generator, then any symbol found in the given DynamicLibrary that; /// passes the 'Allow' predicate will be added to the JITDylib.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h:23,expose,expose,23,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h,1,['expose'],['expose']
Security,"/// A utility class to expose symbols from a static library.; ///; /// If an instance of this class is attached to a JITDylib as a fallback; /// definition generator, then any symbol found in the archive will result in; /// the containing object being added to the JITDylib.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h:23,expose,expose,23,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h,1,['expose'],['expose']
Security,/// A utility class to provide a pseudo-random number generator which is; /// the same across all platforms. This is somewhat close to the libc; /// implementation. Note: This is not a cryptographically secure pseudorandom; /// number generator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-stress/llvm-stress.cpp:203,secur,secure,203,interpreter/llvm-project/llvm/tools/llvm-stress/llvm-stress.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-stress/llvm-stress.cpp,1,['secur'],['secure']
Security,"/// A vector that allocates memory in pages.; ///; /// Order is kept, but memory is allocated only when one element of the page is; /// accessed. This introduces a level of indirection, but it is useful when you; /// have a sparsely initialised vector where the full size is allocated upfront.; ///; /// As a side effect the elements are initialised later than in a normal vector.; /// On the first access to one of the elements of a given page, all the elements; /// of the page are initialised. This also means that the elements of the page; /// are initialised beyond the size of the vector.; ///; /// Similarly on destruction the elements are destroyed only when the page is; /// not needed anymore, delaying invoking the destructor of the elements.; ///; /// Notice that this has iterators only on materialized elements. This; /// is deliberately done under the assumption you would dereference the elements; /// while iterating, therefore materialising them and losing the gains in terms; /// of memory usage this container provides. If you have such a use case, you; /// probably want to use a normal std::vector or a llvm::SmallVector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:136,access,accessed,136,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,2,['access'],"['access', 'accessed']"
Security,/// A wrapper analysis pass for the legacy pass manager that exposes a \c; /// MemoryDepnedenceResults instance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:61,expose,exposes,61,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,1,['expose'],['exposes']
Security,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks, and; /// applies dynamic knowledge to simplify SCEV expressions and convert them; /// to a more usable form. We need this in case assumptions about SCEV; /// expressions need to be made in order to avoid unknown dependences. For; /// example we might assume a unit stride for a pointer in order to prove; /// that a memory access is strided and doesn't wrap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:394,access,access,394,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['access'],['access']
Security,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks.; /// Simplifies SCEV expressions in the context of existing SCEV assumptions.; /// The interleaved access analysis can also add new predicates (for example; /// by versioning strides of pointers).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:170,access,access,170,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,1,['access'],['access']
Security,"/// A wrapper class around a pointer that always points to its canonical; /// declaration.; ///; /// CanonicalDeclPtr<decl_type> behaves just like decl_type*, except we call; /// decl_type::getCanonicalDecl() on construction.; ///; /// This is useful for hashtables that you want to be keyed on a declaration's; /// canonical decl -- if you use CanonicalDeclPtr as the key, you don't need to; /// remember to call getCanonicalDecl() everywhere.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Redeclarable.h:255,hash,hashtables,255,interpreter/llvm-project/clang/include/clang/AST/Redeclarable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Redeclarable.h,1,['hash'],['hashtables']
Security,"/// A wrapper pass around a callback which can be used to populate the; /// AAResults in the AAResultsWrapperPass from an external AA.; ///; /// The callback provided here will be used each time we prepare an AAResults; /// object, and will receive a reference to the function wrapper pass, the; /// function, and the AAResults object to populate. This should be used when; /// setting up a custom pass pipeline to inject a hook into the AA results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:415,inject,inject,415,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,1,['inject'],['inject']
Security,/// A wrapper pass to provide the legacy pass manager access to a suitably; /// prepared AAResults object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:54,access,access,54,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,1,['access'],['access']
Security,/// ASTReaderListener implementation to validate the information of; /// the PCH file against an initialized Preprocessor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:40,validat,validate,40,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['validat'],['validate']
Security,/// ASTReaderListenter implementation to set SuggestedPredefines of; /// ASTReader which is required to use a pch file. This is the replacement; /// of PCHValidator or SimplePCHValidator when using a pch file without; /// validating it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:222,validat,validating,222,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['validat'],['validating']
Security,"/// AST_MATCHER(Type, DefineMatcher) { ... }; /// defines a zero parameter function named DefineMatcher() that returns a; /// Matcher<Type> object.; ///; /// The code between the curly braces has access to the following variables:; ///; /// Node: the AST node being matched; its type is Type.; /// Finder: an ASTMatchFinder*.; /// Builder: a BoundNodesTreeBuilder*.; ///; /// The code should return true if 'Node' matches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersMacros.h:196,access,access,196,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersMacros.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersMacros.h,1,['access'],['access']
Security,"/// AST_MATCHER_FUNCTION_P(ReturnType, DefineMatcher, ParamType, Param) {; /// ... }; /// defines a single-parameter function named DefineMatcher() that returns a; /// ReturnType object.; ///; /// The code between the curly braces has access to the following variables:; ///; /// Param: the parameter passed to the function; its type; /// is ParamType.; ///; /// The code should return an instance of ReturnType.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersMacros.h:235,access,access,235,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersMacros.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersMacros.h,1,['access'],['access']
Security,"/// AST_MATCHER_P(Type, DefineMatcher, ParamType, Param) { ... }; /// defines a single-parameter function named DefineMatcher() that returns a; /// Matcher<Type> object.; ///; /// The code between the curly braces has access to the following variables:; ///; /// Node: the AST node being matched; its type is Type.; /// Param: the parameter passed to the function; its type; /// is ParamType.; /// Finder: an ASTMatchFinder*.; /// Builder: a BoundNodesTreeBuilder*.; ///; /// The code should return true if 'Node' matches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersMacros.h:218,access,access,218,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersMacros.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersMacros.h,1,['access'],['access']
Security,"/// AST_MATCHER_P2(; /// Type, DefineMatcher, ParamType1, Param1, ParamType2, Param2) { ... }; /// defines a two-parameter function named DefineMatcher() that returns a; /// Matcher<Type> object.; ///; /// The code between the curly braces has access to the following variables:; ///; /// Node: the AST node being matched; its type is Type.; /// Param1, Param2: the parameters passed to the function; their types; /// are ParamType1 and ParamType2.; /// Finder: an ASTMatchFinder*.; /// Builder: a BoundNodesTreeBuilder*.; ///; /// The code should return true if 'Node' matches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersMacros.h:244,access,access,244,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersMacros.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersMacros.h,1,['access'],['access']
Security,"/// AST_MATCHER_REGEX(Type, DefineMatcher, Param) { ... }; /// defines a function named DefineMatcher() that takes a regular expression; /// string paramater and an optional RegexFlags parameter and returns a; /// Matcher<Type> object.; ///; /// The code between the curly braces has access to the following variables:; ///; /// Node: the AST node being matched; its type is Type.; /// Param: a pointer to an \ref llvm::Regex object; /// Finder: an ASTMatchFinder*.; /// Builder: a BoundNodesTreeBuilder*.; ///; /// The code should return true if 'Node' matches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersMacros.h:284,access,access,284,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersMacros.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersMacros.h,1,['access'],['access']
Security,"/// Access - Used by C++ decls for the access specifier.; // NOTE: VC++ treats enums as signed, avoid using the AccessSpecifier enum",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:4,Access,Access,4,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,3,"['Access', 'access']","['Access', 'AccessSpecifier', 'access']"
Security,/// Access TargetOptions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/JITTargetMachineBuilder.h:4,Access,Access,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/JITTargetMachineBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/JITTargetMachineBuilder.h,2,['Access'],['Access']
Security,/// Access Triple.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/JITTargetMachineBuilder.h:4,Access,Access,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/JITTargetMachineBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/JITTargetMachineBuilder.h,2,['Access'],['Access']
Security,/// Access Uses that should be dropped if the alloca is promotable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Access,Access,4,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['Access'],['Access']
Security,"/// Access a particular processing slot.; ///; /// This method is thread-safe as long as concurrent calls request different slots (i.e. pass a different; /// argument) and no thread accesses slot `i` via the arrow operator, so mixing usage of GetAtSlot; /// with usage of the arrow operator can be dangerous.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx:4,Access,Access,4,core/thread/inc/ROOT/TThreadedObject.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx,2,"['Access', 'access']","['Access', 'accesses']"
Security,"/// Access a particular slot which corresponds to a single thread.; /// This is in general faster than the GetAtSlot method but it is; /// responsibility of the caller to make sure that the slot exists; /// and to check that the contained object is initialized (and not; /// a nullptr).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx:4,Access,Access,4,core/thread/inc/ROOT/TThreadedObject.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx,1,['Access'],['Access']
Security,"/// Access a particular slot which corresponds to a single thread.; /// This overload is faster than the GetAtSlotUnchecked method but; /// the caller is responsible to make sure that the slot exists, to; /// check that the contained object is initialized and that the returned; /// pointer will not outlive the TThreadedObject that returned it, which; /// maintains ownership of the actual object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx:4,Access,Access,4,core/thread/inc/ROOT/TThreadedObject.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx,1,['Access'],['Access']
Security,/// Access a specific versioned result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesReader.h:4,Access,Access,4,interpreter/llvm-project/clang/include/clang/APINotes/APINotesReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesReader.h,1,['Access'],['Access']
Security,/// Access all owned ObjectFiles.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Access,Access,4,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,1,['Access'],['Access']
Security,/// Access all versioned results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesReader.h:4,Access,Access,4,interpreter/llvm-project/clang/include/clang/APINotes/APINotesReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesReader.h,1,['Access'],['Access']
Security,/// Access control.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DelayedDiagnostic.h:4,Access,Access,4,interpreter/llvm-project/clang/include/clang/Sema/DelayedDiagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DelayedDiagnostic.h,1,['Access'],['Access']
Security,"/// Access element by index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooArgList.h:4,Access,Access,4,roofit/roofitcore/inc/RooArgList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooArgList.h,1,['Access'],['Access']
Security,"/// Access internal vertex adjacent triangles",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h:4,Access,Access,4,math/mathcore/src/CDT/Triangulation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h,2,['Access'],['Access']
Security,/// Access qualifier. Optional.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/AMDGPUMetadata.h:4,Access,Access,4,interpreter/llvm-project/llvm/include/llvm/Support/AMDGPUMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/AMDGPUMetadata.h,1,['Access'],['Access']
Security,/// Access qualifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/AMDGPUMetadata.h:4,Access,Access,4,interpreter/llvm-project/llvm/include/llvm/Support/AMDGPUMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/AMDGPUMetadata.h,1,['Access'],['Access']
Security,"/// Access specifier as written in the source code (may be AS_none).; ///; /// The actual type of data stored here is an AccessSpecifier, but we use; /// ""unsigned"" here to work around Microsoft ABI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:4,Access,Access,4,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,2,['Access'],"['Access', 'AccessSpecifier']"
Security,/// Access subtarget features.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/JITTargetMachineBuilder.h:4,Access,Access,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/JITTargetMachineBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/JITTargetMachineBuilder.h,2,['Access'],['Access']
Security,/// Access the GSYM header.; /// \returns A native endian version of the GSYM header.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h:4,Access,Access,4,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,1,['Access'],['Access']
Security,/// Access the Idx'th operand as a register and return it.; /// This assumes that the Idx'th operand is a Register type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h:4,Access,Access,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h,1,['Access'],['Access']
Security,"/// Access the ImplBase_t this RHist points to.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:4,Access,Access,4,hist/histv7/inc/ROOT/RHist.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx,1,['Access'],['Access']
Security,/// Access the dead operands referring to this alloca.; ///; /// These are operands which have cannot actually be used to refer to the; /// alloca as they are outside its range and the user doesn't correct for; /// that. These mostly consist of PHI node inputs and the like which we just; /// need to replace with undef.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Access,Access,4,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['Access'],['Access']
Security,/// Access the dead users for this alloca.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Access,Access,4,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['Access'],['Access']
Security,/// Access the list of assumption handles currently tracked for this; /// function.; ///; /// Note that these produce weak handles that may be null. The caller must; /// handle that case.; /// FIXME: We should replace this with pointee_iterator<filter_iterator<...>>; /// when we can write that to filter out the null values. Then caller code; /// will become simpler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:4,Access,Access,4,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,1,['Access'],['Access']
Security,/// Access the list of assumptions which affect this value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:4,Access,Access,4,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,1,['Access'],['Access']
Security,/// Access the list of branches which affect this value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h:4,Access,Access,4,interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h,1,['Access'],['Access']
Security,/// Access the map from outer analyses to deferred invalidation requiring; /// analyses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:4,Access,Access,4,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['Access'],['Access']
Security,"/// Access the map of state names to index numbers. Triggers a recomputation; /// if the shape is dirty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCategory.h:4,Access,Access,4,roofit/roofitcore/inc/RooAbsCategory.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCategory.h,1,['Access'],['Access']
Security,/// Access the object which can disable optional passes and individual; /// optimizations at compile time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h:4,Access,Access,4,interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,2,['Access'],['Access']
Security,/// Access the owned ObjectFile with architecture \p T.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Access,Access,4,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,1,['Access'],['Access']
Security,"/// Access the pointer corresponding to the current slot. This method is; /// not adequate for being called inside tight loops as it implies a; /// lookup in a mapping between the threadIDs and the slot indices.; /// A good practice consists in copying the pointer onto the stack and; /// proceed with the loop as shown in this work item (psudo-code) which; /// will be sent to different threads:; /// ~~~{.cpp}; /// auto workItem = [](){; /// auto objPtr = tthreadedObject.Get();; /// for (auto i : ROOT::TSeqI(1000)) {; /// // tthreadedObject->FastMethod(i); // don't do this! Inefficient!; /// objPtr->FastMethod(i);; /// }; /// }; /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx:4,Access,Access,4,core/thread/inc/ROOT/TThreadedObject.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx,1,['Access'],['Access']
Security,"/// Access the raw io_uring instance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/ROOT/RIoUring.hxx:4,Access,Access,4,io/io/inc/ROOT/RIoUring.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/ROOT/RIoUring.hxx,1,['Access'],['Access']
Security,"/// Access the wrapped object and allow to call its methods.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx:4,Access,Access,4,core/thread/inc/ROOT/TThreadedObject.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx,1,['Access'],['Access']
Security,"/// Access to a derived version of all the currently owned ObjectFiles. The; /// conversion might be invalid, in which case an Error is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Access,Access,4,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,1,['Access'],['Access']
Security,/// Access to a derived version of the currently owned ObjectFile with; /// architecture \p T. The conversion must be known to be valid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Access,Access,4,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,1,['Access'],['Access']
Security,"/// Access to memory operands of the instruction. If there are none, that does; /// not imply anything about whether the function accesses memory. Instead,; /// the caller must behave conservatively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:4,Access,Access,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,2,"['Access', 'access']","['Access', 'accesses']"
Security,"/// Access to memory operands of the instruction.; ///; /// If `memoperands_begin() == memoperands_end()`, that does not imply; /// anything about whether the function accesses memory. Instead, the caller; /// must behave conservatively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:4,Access,Access,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,4,"['Access', 'access']","['Access', 'accesses']"
Security,/// Access to memory via argument pointers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ModRef.h:4,Access,Access,4,interpreter/llvm-project/llvm/include/llvm/Support/ModRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ModRef.h,1,['Access'],['Access']
Security,"/// Access to target class pointer (if available)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfoReference.h:4,Access,Access,4,tree/treeplayer/inc/TFormLeafInfoReference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfoReference.h,1,['Access'],['Access']
Security,/// Access to the STV_xxx flag stored in the first two bits of st_other.; /// STV_DEFAULT: 0; /// STV_INTERNAL: 1; /// STV_HIDDEN: 2; /// STV_PROTECTED: 3,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h:4,Access,Access,4,interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h,1,['Access'],['Access']
Security,/// Access to the allocator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h:4,Access,Access,4,interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h,1,['Access'],['Access']
Security,"/// Access to the bin borders used by this axis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx:4,Access,Access,4,hist/histv7/inc/ROOT/RAxis.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx,1,['Access'],['Access']
Security,"/// Access to the info's connected branch",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfoReference.h:4,Access,Access,4,tree/treeplayer/inc/TFormLeafInfoReference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfoReference.h,2,['Access'],['Access']
Security,"/// Access to the info's proxy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfoReference.h:4,Access,Access,4,tree/treeplayer/inc/TFormLeafInfoReference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfoReference.h,1,['Access'],['Access']
Security,"/// Access to the offset of the data",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfoReference.h:4,Access,Access,4,tree/treeplayer/inc/TFormLeafInfoReference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfoReference.h,1,['Access'],['Access']
Security,"/// Access to the parent pad (const version).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RPad.hxx:4,Access,Access,4,graf2d/gpadv7/inc/ROOT/RPad.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RPad.hxx,1,['Access'],['Access']
Security,"/// Access to the parent pad (non-const version).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RPad.hxx:4,Access,Access,4,graf2d/gpadv7/inc/ROOT/RPad.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RPad.hxx,1,['Access'],['Access']
Security,"/// Access to the top-most canvas (const version).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RPad.hxx:4,Access,Access,4,graf2d/gpadv7/inc/ROOT/RPad.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RPad.hxx,1,['Access'],['Access']
Security,"/// Access to the top-most canvas (non-const version).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RPad.hxx:4,Access,Access,4,graf2d/gpadv7/inc/ROOT/RPad.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RPad.hxx,1,['Access'],['Access']
Security,"/// Access to the top-most canvas, if any (const version).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RPadBase.hxx:4,Access,Access,4,graf2d/gpadv7/inc/ROOT/RPadBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RPadBase.hxx,1,['Access'],['Access']
Security,"/// Access to the top-most canvas, if any (non-const version).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RCanvas.hxx:4,Access,Access,4,graf2d/gpadv7/inc/ROOT/RCanvas.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RCanvas.hxx,2,['Access'],['Access']
Security,"/// Access to the value class from the object pointer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfoReference.h:4,Access,Access,4,tree/treeplayer/inc/TFormLeafInfoReference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfoReference.h,1,['Access'],['Access']
Security,"/// Access to the value class of the reference proxy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfoReference.h:4,Access,Access,4,tree/treeplayer/inc/TFormLeafInfoReference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfoReference.h,1,['Access'],['Access']
Security,"/// Access value of referenced object (macro from TFormLeafInfo.g)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfoReference.h:4,Access,Access,4,tree/treeplayer/inc/TFormLeafInfoReference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfoReference.h,1,['Access'],['Access']
Security,/// AccessTy/MemoryInst - This is the type for the access (e.g. double) and; /// the memory instruction that we're computing this address for.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:4,Access,AccessTy,4,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,2,"['Access', 'access']","['AccessTy', 'access']"
Security,/// AccessType - The final access type. May be null if there is no TBAA; /// information available about this access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.h:4,Access,AccessType,4,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.h,3,"['Access', 'access']","['AccessType', 'access']"
Security,/// Accessor for an element of the global_ctors/global_dtors array.; ///; /// This class provides a read-only view of the element with any casts on; /// the function stripped away.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h:4,Access,Accessor,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h,1,['Access'],['Accessor']
Security,/// Accessor for common functionality.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:4,Access,Accessor,4,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,1,['Access'],['Accessor']
Security,/// Accessor for constants.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/StackMapParser.h:4,Access,Accessor,4,interpreter/llvm-project/llvm/include/llvm/Object/StackMapParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/StackMapParser.h,1,['Access'],['Accessor']
Security,/// Accessor for function records.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/StackMapParser.h:4,Access,Accessor,4,interpreter/llvm-project/llvm/include/llvm/Object/StackMapParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/StackMapParser.h,1,['Access'],['Accessor']
Security,/// Accessor for information about the declaration site.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h:4,Access,Accessor,4,interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h,1,['Access'],['Accessor']
Security,/// Accessor for location records.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/StackMapParser.h:4,Access,Accessor,4,interpreter/llvm-project/llvm/include/llvm/Object/StackMapParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/StackMapParser.h,1,['Access'],['Accessor']
Security,/// Accessor for stackmap live-out fields.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/StackMapParser.h:4,Access,Accessor,4,interpreter/llvm-project/llvm/include/llvm/Object/StackMapParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/StackMapParser.h,1,['Access'],['Accessor']
Security,/// Accessor for stackmap records.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/StackMapParser.h:4,Access,Accessor,4,interpreter/llvm-project/llvm/include/llvm/Object/StackMapParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/StackMapParser.h,1,['Access'],['Accessor']
Security,/// Accessor for the AllocActions object for this graph. This can be used to; /// register allocation action calls prior to finalization.; ///; /// Accessing this object after finalization will result in undefined; /// behavior.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:4,Access,Accessor,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,2,['Access'],"['Accessing', 'Accessor']"
Security,/// Accessor for the analysis manager.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:4,Access,Accessor,4,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,4,['Access'],['Accessor']
Security,/// Accessor methods to return the set of stubs in sorted order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h:4,Access,Accessor,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h,3,['Access'],['Accessor']
Security,/// Accessor to the directive tokens that's atomic to avoid data races.; /// \p CachedFileContents has ownership of the pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:4,Access,Accessor,4,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['Access'],['Accessor']
Security,/// Accessors for information about the innermost field.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h:4,Access,Accessors,4,interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Pointer.h,1,['Access'],['Accessors']
Security,/// Accessors...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h:4,Access,Accessors,4,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h,1,['Access'],['Accessors']
Security,/// Accessors.; /// @{,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:4,Access,Accessors,4,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,7,['Access'],['Accessors']
Security,"/// Accumulate from a range denoted by iterators.; ///; /// This function will auto-vectorise with random-access iterators.; /// \param[in] begin Beginning of a range. Needs to be a random access iterator for automatic; /// vectorisation, because a contiguous block of memory needs to be read.; /// \param[in] end End of the range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Util.h:106,access,access,106,math/mathcore/inc/Math/Util.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Util.h,2,['access'],['access']
Security,"/// ActOnCXXMemberDeclarator - This is invoked when a C++ class member; /// declarator is parsed. 'AS' is the access specifier, 'BW' specifies the; /// bitfield width if there is one, 'InitExpr' specifies the initializer if; /// one has been parsed, and 'InitStyle' is set if an in-class initializer is; /// present (but parsing it has been deferred).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:110,access,access,110,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['access'],['access']
Security,/// Actual access qualifier. Optional.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/AMDGPUMetadata.h:11,access,access,11,interpreter/llvm-project/llvm/include/llvm/Support/AMDGPUMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/AMDGPUMetadata.h,1,['access'],['access']
Security,"/// Actual data for the on-disk hash table of header file; /// information.; ///; /// This pointer points into a memory buffer, where the on-disk hash; /// table for header file information actually lives.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h:32,hash,hash,32,interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,2,['hash'],['hash']
Security,"/// Actual data for the on-disk hash table of identifiers.; ///; /// This pointer points into a memory buffer, where the on-disk hash; /// table for identifiers actually lives.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h:32,hash,hash,32,interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,2,['hash'],['hash']
Security,/// Actual page data. All the page elements are allocated on the; /// first access of any of the elements of the page. Elements are default; /// constructed and elements of the page are stored contiguously.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h:76,access,access,76,interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PagedVector.h,1,['access'],['access']
Security,"/// Add a call stack context with the given allocation type to the Trie.; /// The context is represented by the list of stack ids (computed during; /// matching via a debug location hash), expected to be in order from the; /// allocation call down to the bottom of the call stack (i.e. callee to; /// caller order).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h:182,hash,hash,182,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h,1,['hash'],['hash']
Security,/// Add a declaration to these results with its natural access.; /// Does not test the acceptance criteria.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h:56,access,access,56,interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,1,['access'],['access']
Security,/// Add a declaration to these results with the given access.; /// Does not test the acceptance criteria.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h:54,access,access,54,interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,1,['access'],['access']
Security,/// Add a memprof frame identified by the hash of the contents of the frame in; /// \p FrameId.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfWriter.h:42,hash,hash,42,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfWriter.h,1,['hash'],['hash']
Security,"/// Add a new Access to the state at offset \p Offset and with size \p Size.; /// The access is associated with \p I, writes \p Content (if anything), and; /// is of kind \p Kind. If an Access already exists for the same \p I and same; /// \p RemoteI, the two are combined, potentially losing information about; /// offset and size. The resulting access must now be moved from its original; /// OffsetBin to the bin for its new offset.; ///; /// \Returns CHANGED, if the state changed, UNCHANGED otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:14,Access,Access,14,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,4,"['Access', 'access']","['Access', 'access']"
Security,"/// Add a new branch, and infer the data type from the array `addobj` being passed.; ///; /// \note This and the previous overload should cover most cases for creating a branch. Try to use these two whenever; /// possible, unless e.g. type conversions are needed.; ///; /// \param[in] name Name of the branch to be created.; /// \param[in] addobj Array of the objects to be added. When calling Fill(), the current value of the type/object will be saved.; /// \param[in] bufsize he buffer size in bytes for this branch. When the buffer is full, it is compressed and written to disc.; /// The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes).; /// A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode.; /// \param[in] splitlevel If T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches.; /// \return Pointer to the TBranch that was created. The branch is owned by the tree.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:824,access,accessed,824,tree/tree/inc/TTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h,1,['access'],['accessed']
Security,"/// Add a new branch, and infer the data type from the type of `obj` being passed.; ///; /// \note This and the next overload should cover most cases for creating a branch. Try to use these two whenever; /// possible, unless e.g. type conversions are needed.; ///; /// \param[in] name Name of the branch to be created.; /// \param[in] obj Address of the object to be added. Make sure to pass a pointer to the actual type/class that; /// should be stored in the tree (no pointers to base classes). When calling Fill(), the current value of the type/object will be saved.; /// \param[in] bufsize The buffer size in bytes for this branch. When the buffer is full, it is compressed and written to disc.; /// The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes).; /// A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode.; /// \param[in] splitlevel If T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches.; /// \return Pointer to the TBranch that was created. The branch is owned by the tree.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:941,access,accessed,941,tree/tree/inc/TTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h,1,['access'],['accessed']
Security,"/// Add a new module with the given \p Hash, mapped to the given \p; /// ModID, and return a reference to the module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:39,Hash,Hash,39,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['Hash'],['Hash']
Security,"/// Add a new result to this result set, where we already know; /// the hiding declaration (if any).; ///; /// \param R the result to add (if it is unique).; ///; /// \param CurContext the context in which this result will be named.; ///; /// \param Hiding the declaration that hides the result.; ///; /// \param InBaseClass whether the result was found in a base; /// class of the searched context.; ///; /// \param BaseExprType the type of expression that precedes the ""."" or ""->""; /// in a member access expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:500,access,access,500,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['access'],['access']
Security,"/// Add a range accessed by this Access.; ///; /// If there are multiple ranges, then this is a ""may access"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:16,access,accessed,16,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,3,"['Access', 'access']","['Access', 'access', 'accessed']"
Security,/// Add accessed bytes to the map.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:8,access,accessed,8,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['access'],['accessed']
Security,/// Add all access groups in @p AccGroups to @p List.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:12,access,access,12,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['access'],['access']
Security,/// Add code that checks at runtime if the accessed arrays in \p PointerChecks; /// overlap. Returns the final comparator value or NULL if no check is needed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:43,access,accessed,43,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,1,['access'],['accessed']
Security,/// Add empty line only when access modifier starts a new logical block.; /// Logical block is a group of one or more member fields or functions.; /// \code; /// struct foo {; /// private:; /// int i;; ///; /// protected:; /// int j;; /// /* comment */; /// public:; /// foo() {}; ///; /// private:; /// protected:; /// };; /// \endcode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:29,access,access,29,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['access'],['access']
Security,"/// Add function counts for the given function. If there are already counts; /// for this function and the hash and number of counts match, each counter is; /// summed. Optionally scale counts by \p Weight.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfWriter.h:107,hash,hash,107,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfWriter.h,1,['hash'],['hash']
Security,"/// Add object to be painted.; /// Correspondent drawable will be created via GetDrawable() function which should be defined and be accessed at calling time.; /// If required, extra arguments for GetDrawable() function can be provided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RPadBase.hxx:132,access,accessed,132,graf2d/gpadv7/inc/ROOT/RPadBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RPadBase.hxx,1,['access'],['accessed']
Security,/// Add the accessibility attribute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:12,access,accessibility,12,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,1,['access'],['accessibility']
Security,/// Add the bytes in the StringRef \p Str to the hash.; // Note that this isn't a string and so this won't include any trailing NULL; // bytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/MD5.cpp:49,hash,hash,49,interpreter/llvm-project/llvm/lib/Support/MD5.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/MD5.cpp,1,['hash'],['hash']
Security,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any CodeGenPassBuilder<Derived>::addXX routine may be overriden by the; /// Target. The addPre/Post methods with empty header implementations allow; /// injecting target-specific fixups just before or after major stages.; /// Additionally, targets have the flexibility to change pass order within a; /// stage by overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:431,inject,injecting,431,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,1,['inject'],['injecting']
Security,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any TargetPassConfig::addXX routine may be overriden by the Target. The; /// addPre/Post methods with empty header implementations allow injecting; /// target-specific fixups just before or after major stages. Additionally,; /// targets have the flexibility to change pass order within a stage by; /// overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.; ///; /// TODO: We could use a single addPre/Post(ID) hook to allow pass injection; /// before/after any target-independent pass. But it's currently overkill.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:415,inject,injecting,415,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,2,['inject'],"['injecting', 'injection']"
Security,/// Add the given macro to the hash of all top-level entities.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:31,hash,hash,31,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,1,['hash'],['hash']
Security,/// Address-mode matching performs shift-of-and to and-of-shift; /// reassociation in order to expose more scaled addressing; /// opportunities.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:95,expose,expose,95,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['expose'],['expose']
Security,/// Adds \param Str to the hash and includes a NULL byte.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:27,hash,hash,27,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,1,['hash'],['hash']
Security,/// Adds \param Value to the hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:29,hash,hash,29,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,1,['hash'],['hash']
Security,/// Adds a sanitized control-flow diagnostic edge to a path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:11,sanitiz,sanitized,11,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['sanitiz'],['sanitized']
Security,"/// Adds an appropriate access operator (`.`, `->` or nothing, in the case of; /// implicit `this`) to the end of the given expression. Adds parentheses when; /// needed by the syntax and simplifies when possible. If `PLTypeClass` is; /// `Pointer`, for known pointer-like types (see `isKnownPointerLikeType`),; /// treats `operator->` and `operator*` like the built-in `->` and `*`; /// operators.; ///; /// `x` becomes `x->` or `x.`, depending on `E`'s type; /// `a+b` becomes `(a+b)->` or `(a+b).`, depending on `E`'s type; /// `&a` becomes `a.`; /// `*a` becomes `a->`",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h:24,access,access,24,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h,1,['access'],['access']
Security,"/// Adds an instruction which restores the link register from the top the; /// stack into the MachineBasicBlock \p MBB at position \p It. If \p Auth is; /// true, restore an authentication code and authenticate LR.; /// If \p CFI is true, emit CFI instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h:174,authenticat,authentication,174,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h,2,['authenticat'],"['authenticate', 'authentication']"
Security,"/// Adds an instruction which saves the link register on top of the stack into; /// the MachineBasicBlock \p MBB at position \p It. If \p Auth is true,; /// compute and store an authentication code alongiside the link register.; /// If \p CFI is true, emit CFI instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h:178,authenticat,authentication,178,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h,1,['authenticat'],['authentication']
Security,/// Adds run-time bounds checks to memory accessing instructions.; ///; /// \p Or is the condition that should guard the trap.; ///; /// \p GetTrapBB is a callable that returns the trap BB to use on failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp:42,access,accessing,42,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp,1,['access'],['accessing']
Security,/// Adds the attributes of \param Die to the hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:45,hash,hash,45,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,1,['hash'],['hash']
Security,/// Adds the first unsigned integer operand to the CRC-32C checksum of; /// the second unsigned integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32L </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 32-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:59,checksum,checksum,59,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,4,['checksum'],['checksum']
Security,/// Adds the parent context of \param Parent to the hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:52,hash,hash,52,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,1,['hash'],['hash']
Security,/// Adds the string in \p Str to the hash. This also hashes; /// a trailing NULL with the string.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp:37,hash,hash,37,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.cpp,2,['hash'],"['hash', 'hashes']"
Security,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// second unsigned integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32D instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 32-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:53,checksum,checksum,53,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,4,['checksum'],['checksum']
Security,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned 64-bit integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32Q </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 64-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:53,checksum,checksum,53,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,4,['checksum'],['checksum']
Security,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned 64-bit integer operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32Q instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 64-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:53,checksum,checksum,53,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,4,['checksum'],['checksum']
Security,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned char operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32B </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 8-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:53,checksum,checksum,53,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,4,['checksum'],['checksum']
Security,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned char operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32B instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 8-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:53,checksum,checksum,53,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,4,['checksum'],['checksum']
Security,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned short operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CRC32W </c> instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 16-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h:53,checksum,checksum,53,interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/crc32intrin.h,4,['checksum'],['checksum']
Security,/// Adds the unsigned integer operand to the CRC-32C checksum of the; /// unsigned short operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CRC32W instruction.; ///; /// \param __C; /// An unsigned integer operand to add to the CRC-32C checksum of operand; /// \a __D.; /// \param __D; /// An unsigned 16-bit integer operand used to compute the CRC-32C checksum.; /// \returns The result of adding operand \a __C to the CRC-32C checksum of; /// operand \a __D.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:53,checksum,checksum,53,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,4,['checksum'],['checksum']
Security,/// Adjust `Value` for the target endianness and add it to the hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h:63,hash,hash,63,interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h,1,['hash'],['hash']
Security,"/// Adjust the MemoryLocation so that it represents accesses to this; /// location across all iterations, rather than a single one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:52,access,accesses,52,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['access'],['accesses']
Security,"/// AliasedFlag - This is set to true if the slot might be aliased; /// and it's not undefined behavior to access it through such an; /// alias. Note that it's always undefined behavior to access a C++; /// object that's under construction through an alias derived from; /// outside the construction process.; ///; /// This flag controls whether calls that produce the aggregate; /// value may be evaluated directly into the slot, or whether they; /// must be evaluated into an unaliased temporary and then memcpy'ed; /// over. Since it's invalid in general to memcpy a non-POD C++; /// object, it's important that this flag never be set when; /// evaluating an expression which constructs such an object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGValue.h:107,access,access,107,interpreter/llvm-project/clang/lib/CodeGen/CGValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGValue.h,2,['access'],['access']
Security,/// Aliases - Test whether the access represented by tag A may alias the; /// access represented by tag B.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp:31,access,access,31,interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TypeBasedAliasAnalysis.cpp,2,['access'],['access']
Security,"/// Allocate a User with the operands co-allocated. If DescBytes is non-zero; /// then allocate an additional DescBytes bytes before the operands. These; /// bytes can be accessed by calling getDescriptor.; ///; /// DescBytes needs to be divisible by sizeof(void *). The allocated; /// descriptor, if any, is aligned to sizeof(void *) bytes.; ///; /// This is used for subclasses which have a fixed number of operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/User.h:171,access,accessed,171,interpreter/llvm-project/llvm/include/llvm/IR/User.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/User.h,1,['access'],['accessed']
Security,"/// Allocate a memory block of (at least) the given size suitable for data.; /// The SectionID is a unique identifier assigned by the JIT engine, and; /// optionally recorded by the memory manager to access a loaded section.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h:200,access,access,200,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,1,['access'],['access']
Security,"/// Allocate a memory block of (at least) the given size suitable for; /// executable code. The SectionID is a unique identifier assigned by the; /// RuntimeDyld instance, and optionally recorded by the memory manager to; /// access a loaded section.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h:226,access,access,226,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,1,['access'],['access']
Security,/// Allocated API-exposed wrappters for Diagnostics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:18,expose,exposed,18,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,1,['expose'],['exposed']
Security,/// Allocator for HashData and Values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:18,Hash,HashData,18,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,1,['Hash'],['HashData']
Security,"/// Allow access to clients that need the byte representation, such as; /// ASTWriterStmt::VisitStringLiteral().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:10,access,access,10,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['access'],['access']
Security,/// Allow access to the constructor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:10,access,access,10,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['access'],['access']
Security,/// Allow access to the private members from the Attributor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:10,access,access,10,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['access'],['access']
Security,/// Allowed outside users. This holds the variables that can be accessed from; /// outside the loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:64,access,accessed,64,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['access'],['accessed']
Security,/// Always add empty line after access modifiers if there are none.; /// MaxEmptyLinesToKeep is applied also.; /// \code; /// struct foo {; /// private:; ///; /// int i;; /// protected:; ///; /// int j;; /// /* comment */; /// public:; ///; /// foo() {}; /// private:; ///; /// protected:; ///; /// };; /// \endcode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:32,access,access,32,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['access'],['access']
Security,/// Always add empty line before access modifiers unless access modifier; /// is at the start of struct or class definition.; /// \code; /// struct foo {; /// private:; /// int i;; ///; /// protected:; /// int j;; /// /* comment */; ///; /// public:; /// foo() {}; ///; /// private:; ///; /// protected:; /// };; /// \endcode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:33,access,access,33,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,2,['access'],['access']
Security,/// An AccessSpecDecl record.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h:7,Access,AccessSpecDecl,7,interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h,1,['Access'],['AccessSpecDecl']
Security,/// An AnalysisManager<MachineFunction> that also exposes IR analysis results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:50,expose,exposes,50,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,1,['expose'],['exposes']
Security,"/// An ELF note.; ///; /// Wraps a note header, providing methods for accessing the name and; /// descriptor safely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h:70,access,accessing,70,interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h,1,['access'],['accessing']
Security,/// An ElaboratedTypeKeyword. 8 bits for efficient access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:51,access,access,51,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['access'],['access']
Security,/// An LLVMContext together with an associated mutex that can be used to lock; /// the context to prevent concurrent access by other threads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ThreadSafeModule.h:117,access,access,117,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ThreadSafeModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ThreadSafeModule.h,1,['access'],['access']
Security,"/// An RAII class that tracks when the Preprocessor starts and stops lexing; /// the definition of a (ISO C/C++) variadic macro. As an example, this is; /// useful for unpoisoning and repoisoning certain identifiers (such as; /// __VA_ARGS__) that are only allowed in this context. Also, being a friend; /// of the Preprocessor class allows it to access PP's cached identifiers; /// directly (as opposed to performing a lookup each time).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/VariadicMacroSupport.h:347,access,access,347,interpreter/llvm-project/clang/include/clang/Lex/VariadicMacroSupport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/VariadicMacroSupport.h,1,['access'],['access']
Security,"/// An RAII wrapper used for the read-only access to `RPageSource::fDescriptor`. See `GetExclDescriptorGuard()``.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:43,access,access,43,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['access'],['access']
Security,"/// An RAII wrapper used for the writable access to `RPageSource::fDescriptor`. See `GetSharedDescriptorGuard()`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:42,access,access,42,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['access'],['access']
Security,/// An abstract interface for memory access kind related attributes; /// (readnone/readonly/writeonly).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:37,access,access,37,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['access'],['access']
Security,"/// An abstract node for C++ statements, e.g. 'while', 'if', etc.; /// FIXME: add accessors for semicolon of statements that have it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h:82,access,accessors,82,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h,1,['access'],['accessors']
Security,/// An abstract superclass that describes a custom extension to the; /// module/precompiled header file format.; ///; /// A module file extension can introduce additional information into; /// compiled module files (.pcm) and precompiled headers (.pch) via a; /// custom writer that can then be accessed via a custom reader when; /// the module file or precompiled header is loaded.; ///; /// Subclasses must use LLVM RTTI for open class hierarchies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFileExtension.h:295,access,accessed,295,interpreter/llvm-project/clang/include/clang/Serialization/ModuleFileExtension.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFileExtension.h,1,['access'],['accessed']
Security,/// An access class for ilist_node private API.; ///; /// This gives access to the private parts of ilist nodes. Nodes for an ilist; /// should friend this class if they inherit privately from ilist_node.; ///; /// Using this class outside of the ilist implementation is unsupported.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h:7,access,access,7,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h,2,['access'],['access']
Security,/// An access description.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:7,access,access,7,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['access'],['access']
Security,"/// An adjustment to be made to the temporary created when emitting a; /// reference binding, which accesses a particular subobject of that temporary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:100,access,accesses,100,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['access'],['accesses']
Security,/// An alias set tracker to partition the access set by underlying object and; //intrinsic property (such as TBAA metadata).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:42,access,access,42,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['access'],['access']
Security,"/// An analysis over an ""inner"" IR unit that provides access to an; /// analysis manager over a ""outer"" IR unit. The inner unit must be contained; /// in the outer unit.; ///; /// For example OuterAnalysisManagerProxy<ModuleAnalysisManager, Function> is an; /// analysis over Functions (the ""inner"" unit) which provides access to a Module; /// analysis manager. The ModuleAnalysisManager is the ""outer"" manager being; /// proxied, and Modules are the ""outer"" IR unit. The inner/outer relationship; /// is valid because each Function is contained in one Module.; ///; /// This proxy only exposes the const interface of the outer analysis manager,; /// to indicate that you cannot cause an outer analysis to run from within an; /// inner pass. Instead, you must rely on the \c getCachedResult API. This is; /// due to keeping potential future concurrency in mind. To give an example,; /// running a module analysis before any function passes may give a different; /// result than running it in a function pass. Both may be valid, but it would; /// produce non-deterministic results. GlobalsAA is a good analysis example,; /// because the cached information has the mod/ref info for all memory for each; /// function at the time the analysis was computed. The information is still; /// valid after a function transformation, but it may be *different* if; /// recomputed after that transform. GlobalsAA is never invalidated.; ///; /// This proxy doesn't manage invalidation in any way -- that is handled by the; /// recursive return path of each layer of the pass manager. A consequence of; /// this is the outer analyses may be stale. We invalidate the outer analyses; /// only when we're done running passes over the inner IR units.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:54,access,access,54,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,3,"['access', 'expose']","['access', 'exposes']"
Security,"/// An analysis over an ""outer"" IR unit that provides access to an; /// analysis manager over an ""inner"" IR unit. The inner unit must be contained; /// in the outer unit.; ///; /// For example, InnerAnalysisManagerProxy<FunctionAnalysisManager, Module> is; /// an analysis over Modules (the ""outer"" unit) that provides access to a; /// Function analysis manager. The FunctionAnalysisManager is the ""inner""; /// manager being proxied, and Functions are the ""inner"" unit. The inner/outer; /// relationship is valid because each Function is contained in one Module.; ///; /// If you're (transitively) within a pass manager for an IR unit U that; /// contains IR unit V, you should never use an analysis manager over V, except; /// via one of these proxies.; ///; /// Note that the proxy's result is a move-only RAII object. The validity of; /// the analyses in the inner analysis manager is tied to its lifetime.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:54,access,access,54,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,2,['access'],['access']
Security,"/// An array access can be written A[4] or 4[A] (both are equivalent).; /// - getBase() and getIdx() always present the normalized view: A[4].; /// In this case getBase() returns ""A"" and getIdx() returns ""4"".; /// - getLHS() and getRHS() present the syntactic view. e.g. for; /// 4[A] getLHS() returns ""4"".; /// Note: Because vector element access is also written A[4] we must; /// predicate the format conversion in getBase and getIdx only on the; /// the type of the RHS, as it is possible for the LHS to be a vector of; /// integer type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:13,access,access,13,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,2,['access'],['access']
Security,"/// An artificial field that transforms an RNTuple column that contains the offset of collections into; /// collection sizes. It is used to provide the ""number of"" RDF columns for collections, e.g.; /// `R_rdf_sizeof_jets` for a collection named `jets`.; ///; /// This field owns the collection offset field but instead of exposing the collection offsets it exposes; /// the collection sizes (offset(N+1) - offset(N)). For the time being, we offer this functionality only in RDataFrame.; /// TODO(jblomer): consider providing a general set of useful virtual fields as part of RNTuple.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:358,expose,exposes,358,tree/dataframe/src/RNTupleDS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx,1,['expose'],['exposes']
Security,"/// An attacker may speculatively store over a value that is then speculatively; /// loaded and used as the target of an indirect call or jump instruction. This; /// is called Spectre v1.2 or Bounds Check Bypass Store (BCBS) and is described; /// in this paper:; /// https://people.csail.mit.edu/vlk/spectre11.pdf; ///; /// When this happens, the speculative execution of the call or jump will end up; /// being steered to this attacker controlled address. While most such loads; /// will be adequately hardened already, we want to ensure that they are; /// definitively treated as needing post-load hardening. While address hardening; /// is sufficient to prevent secret data from leaking to the attacker, it may; /// not be sufficient to prevent an attacker from steering speculative; /// execution. We forcibly unfolded all relevant loads above and so will always; /// have an opportunity to post-load harden here, we just need to scan for cases; /// not already flagged and add them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:7,attack,attacker,7,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,4,['attack'],['attacker']
Security,/// An easy to access representation of llvm.used and llvm.compiler.used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:15,access,access,15,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['access'],['access']
Security,"/// An egregious hack for compatibility with libstdc++-4.2: in <tr1/hashtable>,; /// a function with a pointer return type contains a 'return false;' statement.; /// In C++11, 'false' is not a null pointer, so this breaks the build of any; /// code using that header.; ///; /// Work around this by treating 'return false;' as zero-initializing the result; /// if it's used in a pointer-returning function in a system header.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:68,hash,hashtable,68,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['hash'],['hashtable']
Security,"/// An extension of the MLInlineAdvisor for the 'development' mode, targeting; /// the offline training scenario. Note that training happens outside of the; /// compiler, this facility is concerned with producing training data (""logs"").; /// This InlineAdvisor can operate in the following modes:; ///; /// 1) collect logs for the default policy. This is useful for bootstrapping; /// training, which will be considerably faster by starting from a reasonable; /// policy.; ///; /// 2) collect logs for the ML policy, using a model from a previous; /// training. Potentially, that model uses internally some small random; /// perturbation of its weights, to induce exploration (setting this up is the; /// responsibility of the training algorithm). The logs would then be used to; /// retrain and improve on this model.; ///; /// 3) use the provided model, with no logging. This is useful for end to end; /// validation - the model, in this case, is a release candidate and shouldn't; /// have random perturbations. It is a convenience feature: rather than needing; /// to take the release candidate model and compile it in 'release' mode,; /// validate it, then potentially discard it, it's easier to just pass the model; /// to the compiler, albeit compilation would be slower, as a one-off. Once the; /// model behaves satisfactorily, it can be compiled AOT, for efficiency, in; /// release mode. The expectation is that a well-trained model provides a good; /// policy over a sufficiently diverse codebase, over many changes (i.e.; /// training happens seldom).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:908,validat,validation,908,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,2,['validat'],"['validate', 'validation']"
Security,"/// An ilist node that can access its parent list.; ///; /// Requires \c NodeTy to have \a getParent() to find the parent node, and the; /// \c ParentTy to have \a getSublistAccess() to get a reference to the list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h:27,access,access,27,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h,1,['access'],['access']
Security,/// An implementation detail class which is introduced to split the checker; /// logic into several methods while maintaining a consistently updated state; /// and access to other contextual data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp:164,access,access,164,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp,1,['access'],['access']
Security,"/// An initial pass after recognizing all the statements is done in the; /// Parser when the directive OMPD_loop is mapped to OMPD_for,; /// OMPD_distribute or OMPD_simd. A second transform pass with call from; /// clang::TreeTransform::TransformOMPExecutableDirective() is done; /// with the Directive as one of the above mapped directive without; /// the bind clause. Then ""PrevMappedDirective"" stored in the; /// OMPExecutableDirective is accessed and hence this else statement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:442,access,accessed,442,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['access'],['accessed']
Security,/// An input file. This is a symbol table wrapper that only exposes the; /// information that an LTO client should need in order to do symbol resolution.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h:60,expose,exposes,60,interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h,1,['expose'],['exposes']
Security,/// An instruction group can only access 2 channel pair (either [XY] or [ZW]); /// from KCache bank on R700+. This function check if MI set in input meet; /// this limitations,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.h:34,access,access,34,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.h,1,['access'],['access']
Security,"/// An interface for accessing data in a stream-like format, but which; /// discourages copying. Instead of specifying a buffer in which to copy; /// data on a read, the API returns an ArrayRef to data owned by the stream's; /// implementation. Since implementations may not necessarily store data in a; /// single contiguous buffer (or even in memory at all), in such cases a it may; /// be necessary for an implementation to cache such a buffer so that it can; /// return it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStream.h:21,access,accessing,21,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStream.h,1,['access'],['accessing']
Security,"/// An iterator type that allows iterating over the pointees via some; /// other iterator.; ///; /// The typical usage of this is to expose a type that iterates over Ts, but; /// which is implemented with some iterator over T*s:; ///; /// \code; /// using iterator = pointee_iterator<SmallVectorImpl<T *>::iterator>;; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h:133,expose,expose,133,interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,1,['expose'],['expose']
Security,/// An object containing the capability of hashing and adding hash; /// attributes onto a DIE.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:43,hash,hashing,43,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,2,['hash'],"['hash', 'hashing']"
Security,/// An on-disk hash table whose data is versioned based on the Swift version.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp:15,hash,hash,15,interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesReader.cpp,1,['hash'],['hash']
Security,"/// An opaque object representing a hash code.; ///; /// This object represents the result of hashing some entity. It is intended to; /// be used to implement hashtables or other hashing-based data structures.; /// While it wraps and exposes a numeric value, this value should not be; /// trusted to be stable or predictable across processes or executions.; ///; /// In order to obtain the hash_code for an object 'x':; /// \code; /// using llvm::hash_value;; /// llvm::hash_code code = hash_value(x);; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:36,hash,hash,36,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,5,"['expose', 'hash']","['exposes', 'hash', 'hashing', 'hashing-based', 'hashtables']"
Security,"/// An opaque object representing a stable hash code. It can be serialized,; /// deserialized, and is stable across processes and executions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h:43,hash,hash,43,interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h,1,['hash'],['hash']
Security,"/// An optimization pass providing Scalar Replacement of Aggregates.; ///; /// This pass takes allocations which can be completely analyzed (that is, they; /// don't escape) and tries to turn them into scalar SSA values. There are; /// a few steps to this process.; ///; /// 1) It takes allocations of aggregates and analyzes the ways in which they; /// are used to try to split them into smaller allocations, ideally of; /// a single scalar data type. It will split up memcpy and memset accesses; /// as necessary and try to isolate individual scalar accesses.; /// 2) It will transform accesses into forms which are suitable for SSA value; /// promotion. This can be replacing a memset with a scalar store of an; /// integer value, or it can involve speculating operations on a PHI or; /// select to be a PHI or select of the results.; /// 3) Finally, this will try to detect a pattern of accesses which map cleanly; /// onto insert and extract operations on a vector value, and convert them to; /// this form. By doing so, it will enable promotion of vector aggregates to; /// SSA vector values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:488,access,accesses,488,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,4,['access'],['accesses']
Security,/// Analyses memory accesses in a loop.; ///; /// Checks whether run time pointer checks are needed and builds sets for data; /// dependence checking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:20,access,accesses,20,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['access'],['accesses']
Security,/// Analysis pass providing the \c TargetTransformInfo.; ///; /// The core idea of the TargetIRAnalysis is to expose an interface through; /// which LLVM targets can analyze and provide information about the middle; /// end's target-independent IR. This supports use cases such as target-aware; /// cost modeling of IR constructs.; ///; /// This is a function analysis because much of the cost modeling for targets; /// is done in a subtarget specific way and LLVM supports compiling different; /// functions targeting different subtargets in order to support runtime; /// dispatch according to the observed subtarget.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:110,expose,expose,110,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['expose'],['expose']
Security,/// Analysis pass that exposes the \c DXILResource for a module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILResourceAnalysis.h:23,expose,exposes,23,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILResourceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILResourceAnalysis.h,1,['expose'],['exposes']
Security,/// Analysis pass that exposes the \c IVUsers for a loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h:23,expose,exposes,23,interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h,1,['expose'],['exposes']
Security,/// Analysis pass that exposes the \c LoopInfo for a function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:23,expose,exposes,23,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,1,['expose'],['exposes']
Security,/// Analysis pass that exposes the \c RegionInfo for a function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:23,expose,exposes,23,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,1,['expose'],['exposes']
Security,/// Analysis pass that exposes the \c ScalarEvolution for a function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:23,expose,exposes,23,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['expose'],['exposes']
Security,/// Analyze the interleaved accesses and collect them in interleave; /// groups. Substitute symbolic strides using \p Strides.; /// Consider also predicated loads/stores in the analysis if; /// \p EnableMaskedInterleavedGroup is true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:28,access,accesses,28,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,1,['access'],['accesses']
Security,"/// Append an ntuple to the existing file, which must not be accessed while data is filled into any created context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx:61,access,accessed,61,tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx,1,['access'],['accessed']
Security,"/// Are arguments to a call destroyed left to right in the callee?; /// This is a fundamental language change, since it implies that objects; /// passed by value do *not* live to the end of the full expression.; /// Temporaries passed to a function taking a const reference live to the end; /// of the full expression as usual. Both the caller and the callee must; /// have access to the destructor, while only the caller needs the; /// destructor if this is false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetCXXABI.h:374,access,access,374,interpreter/llvm-project/clang/include/clang/Basic/TargetCXXABI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetCXXABI.h,1,['access'],['access']
Security,/// Arguments which should be sanitized on function return.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:30,sanitiz,sanitized,30,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,1,['sanitiz'],['sanitized']
Security,/// Array element access. This extends the array if necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp:18,access,access,18,interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/BinaryFormat/MsgPackDocument.cpp,1,['access'],['access']
Security,"/// Array of [0..NumFiles) DBI name buffer offsets. In the reference; /// implementation this field is a pointer. But since you can't portably; /// serialize a pointer, on 64-bit platforms they copy all the values except; /// this one into the 32-bit version of the struct and use that for; /// serialization. Regardless, this field is unused, it is only there to; /// store a pointer that can be accessed at runtime.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/RawTypes.h:397,access,accessed,397,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/RawTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/RawTypes.h,1,['access'],['accessed']
Security,"/// Asserts that instruction order numbers are marked invalid, or that they; /// are in ascending order. This is constant time if the ordering is invalid,; /// and linear in the number of instructions if the ordering is valid. Callers; /// should be careful not to call this in ways that make common operations; /// O(n^2). For example, it takes O(n) time to assign order numbers to; /// instructions, so the order should be validated no more than once after; /// each ordering to ensure that transforms have the same algorithmic; /// complexity when asserts are enabled as when they are disabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h:425,validat,validated,425,interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h,1,['validat'],['validated']
Security,/// Asserts that the cached info for \p BB is up-to-date. This helps to catch; /// the usage error of accessing a block without properly invalidating after a; /// previous transform.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:102,access,accessing,102,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,1,['access'],['accessing']
Security,/// Asserts whether or not the contents of this tracking is up-to-date. This; /// helps to catch the usage error of accessing a block without properly; /// invalidating after a previous transform.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:116,access,accessing,116,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,1,['access'],['accessing']
Security,"/// Associate a filename with a specified logical file number, and also; /// specify that file's checksum information. This implements the '.cv_file 4; /// ""foo.c""' assembler directive. Returns true on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h:97,checksum,checksum,97,interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,1,['checksum'],['checksum']
Security,"/// Associate a filename with a specified logical file number.; /// Also associate a directory, optional checksum, and optional source; /// text with the logical file. This implements the DWARF2; /// '.file 4 ""dir/foo.c""' assembler directive, and the DWARF5; /// '.file 4 ""dir/foo.c"" md5 ""..."" source ""...""' assembler directive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h:105,checksum,checksum,105,interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,1,['checksum'],['checksum']
Security,"/// At this point, we have learned that the only two values ever stored into GV; /// are its initializer and OtherVal. See if we can shrink the global into a; /// boolean and select between the two values whenever it is used. This exposes; /// the values to other scalar optimizations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:231,expose,exposes,231,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['expose'],['exposes']
Security,/// Attach llvm.access.group metadata to the memref instructions of \p Block,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:16,access,access,16,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['access'],['access']
Security,/// Attempt to delinearize \p AccessFn for fixed-size arrays.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:30,Access,AccessFn,30,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,1,['Access'],['AccessFn']
Security,/// Attempt to promote indirect call and also inline the promoted call.; ///; /// \param F Caller function.; /// \param Candidate ICP and inline candidate.; /// \param SumOrigin Original sum of target counts for indirect call before; /// promoting given candidate.; /// \param Sum Prorated sum of remaining target counts for indirect call; /// after promoting given candidate.; /// \param InlinedCallSite Output vector for new call sites exposed after; /// inlining.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:438,expose,exposed,438,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['expose'],['exposed']
Security,"/// Attempt to sort the pointers in \p VL and return the sorted indices; /// in \p SortedIndices, if reordering is required.; ///; /// Returns 'true' if sorting is legal, otherwise returns 'false'.; ///; /// For example, for a given \p VL of memory accesses in program order, a[i+4],; /// a[i+0], a[i+1] and a[i+7], this function will sort the \p VL and save the; /// sorted indices in \p SortedIndices as a[i+0], a[i+1], a[i+4], a[i+7] and; /// saves the mask for actual memory accesses in program order in; /// \p SortedIndices as <1,2,0,3>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:249,access,accesses,249,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,2,['access'],['accesses']
Security,"/// Attempts to create a new module and add it to the list of known; /// modules.; ///; /// \param FileName The file name of the module to be loaded.; ///; /// \param Type The kind of module being loaded.; ///; /// \param ImportLoc The location at which the module is imported.; ///; /// \param ImportedBy The module that is importing this module, or NULL if; /// this module is imported directly by the user.; ///; /// \param Generation The generation in which this module was loaded.; ///; /// \param ExpectedSize The expected size of the module file, used for; /// validation. This will be zero if unknown.; ///; /// \param ExpectedModTime The expected modification time of the module; /// file, used for validation. This will be zero if unknown.; ///; /// \param ExpectedSignature The expected signature of the module file, used; /// for validation. This will be zero if unknown.; ///; /// \param ReadSignature Reads the signature from an AST file without actually; /// loading it.; ///; /// \param Module A pointer to the module file if the module was successfully; /// loaded.; ///; /// \param ErrorStr Will be set to a non-empty string if any errors occurred; /// while trying to load the module.; ///; /// \return A pointer to the module that corresponds to this file name,; /// and a value indicating whether the module was loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h:568,validat,validation,568,interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,3,['validat'],['validation']
Security,"/// Attempts to resolve the given range to one that can be edited by a rewrite;; /// generally, one that starts and ends within a particular file. If a value is; /// returned, it satisfies \c validateEditRange.; ///; /// If \c IncludeMacroExpansion is true, a limited set of cases involving source; /// locations in macro expansions is supported. For example, if we're looking to; /// rewrite the int literal 3 to 6, and we have the following definition:; /// #define DO_NOTHING(x) x; /// then; /// foo(DO_NOTHING(3)); /// will be rewritten to; /// foo(6)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h:192,validat,validateEditRange,192,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h,1,['validat'],['validateEditRange']
Security,"/// AuditedType - This routine audits the type AT and returns false if it is one of known; /// CF object types or of the ""void *"" variety. It returns true if we don't care about the type; /// such as a non-pointer or pointers which have no ownership issues (such as ""int *"").",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp:4,Audit,AuditedType,4,interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ObjCMT.cpp,2,"['Audit', 'audit']","['AuditedType', 'audits']"
Security,/// Base class for CUDA/HIP action builder. It injects device code in; /// the host backend action.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:47,inject,injects,47,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['inject'],['injects']
Security,"/// Base class for non-leaf nodes of the computational graph.; /// It only exposes the bare minimum interface required to work as a generic part of the computation graph.; /// RDataFrames and results of transformations can be cast to this type via ROOT::RDF::RNode (or ROOT.RDF.AsRNode in PyROOT).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RNodeBase.hxx:75,expose,exposes,75,tree/dataframe/inc/ROOT/RDF/RNodeBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RNodeBase.hxx,1,['expose'],['exposes']
Security,"/// Base class for the trait describing the on-disk hash table for the; /// identifiers in an AST file.; ///; /// This class is not useful by itself; rather, it provides common; /// functionality for accessing the on-disk hash table of identifiers; /// in an AST file. Different subclasses customize that functionality; /// based on what information they are interested in. Those subclasses; /// must provide the \c data_type type and the ReadData operation, only.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h:52,hash,hash,52,interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h,3,"['access', 'hash']","['accessing', 'hash']"
Security,"/// Base class that is common to both the \c ExtQuals and \c Type; /// classes, which allows \c QualType to access the common fields between the; /// two.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:108,access,access,108,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['access'],['access']
Security,/// BaseType - The base/leading access type. May be null if this access; /// descriptor represents an access that is not considered to be an access; /// to an aggregate or union member.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.h:32,access,access,32,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.h,4,['access'],['access']
Security,"/// Basic type, like 'int' or 'float'.; ///; /// TODO: Split out DW_TAG_unspecified_type.; /// TODO: Drop unused accessors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h:113,access,accessors,113,interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h,1,['access'],['accessors']
Security,/// Begin suppressing access-like checks,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/RAIIObjectsForParser.h:22,access,access-like,22,interpreter/llvm-project/clang/include/clang/Parse/RAIIObjectsForParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/RAIIObjectsForParser.h,1,['access'],['access-like']
Security,"/// BinaryStreamRef is to BinaryStream what ArrayRef is to an Array. It; /// provides copy-semantics and read only access to a ""window"" of the underlying; /// BinaryStream. Note that BinaryStreamRef is *not* a BinaryStream. That is to; /// say, it does not inherit and override the methods of BinaryStream. In; /// general, you should not pass around pointers or references to BinaryStreams; /// and use inheritance to achieve polymorphism. Instead, you should pass; /// around BinaryStreamRefs by value and achieve polymorphism that way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamRef.h:115,access,access,115,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamRef.h,1,['access'],['access']
Security,/// Bitmask of enabled sanitizers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h:23,sanitiz,sanitizers,23,interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h,1,['sanitiz'],['sanitizers']
Security,/// Blob data is not stored in the buffer if you are using the correct; /// accessor; this method should not be used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h:76,access,accessor,76,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h,1,['access'],['accessor']
Security,"/// Bloom filter is a stochastic data structure which can tell us if a symbol; /// name does not exist in a library with 100% certainty. If it tells us it; /// exists this may not be true:; /// https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2; ///; /// ELF has this optimization in the new linkers by default, It is stored in the; /// gnu.hash section of the object file.; ///; ///\returns true if the symbol may be in the library.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp:231,hash,hash-elf-sections-,231,interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,2,['hash'],"['hash', 'hash-elf-sections-']"
Security,"/// Boundary nodes are placeholders for the boundary of the; /// scheduling region.; ///; /// BoundaryNodes can have DAG edges, including Data edges, but they do not; /// correspond to schedulable entities (e.g. instructions) and do not have a; /// valid ID. Consequently, always check for boundary nodes before accessing; /// an associative data structure keyed on node ID.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:312,access,accessing,312,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,1,['access'],['accessing']
Security,"/// Buffer containing the index file, which is lazily accessed so long; /// as the global module index is live.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h:54,access,accessed,54,interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h,1,['access'],['accessed']
Security,"/// Build a new extended vector element access expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:40,access,access,40,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['access'],['access']
Security,"/// Build a new member access expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:23,access,access,23,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['access'],['access']
Security,"/// Build an expression accessing the ""counted_by"" field.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:24,access,accessing,24,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['access'],['accessing']
Security,"/// BuildCallToMemberFunction - Build a call to a member; /// function. MemExpr is the expression that refers to the member; /// function (and includes the object parameter), Args/NumArgs are the; /// arguments to the function call (not including the object; /// parameter). The caller needs to validate that the member; /// expression refers to a non-static member function or an overloaded; /// member function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:295,validat,validate,295,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['validat'],['validate']
Security,"/// Builds an implicit member access expression. The current context; /// is known to be an instance method, and the given unqualified lookup; /// set is known to contain only instance members, at least one of which; /// is from an appropriate type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:30,access,access,30,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['access'],['access']
Security,"/// By default, uses are *not* optimized during MemorySSA construction.; /// Calling this method will attempt to optimize all MemoryUses, if this has; /// not happened yet for this MemorySSA instance. This should be done if you; /// plan to query the clobbering access for most uses, or if you walk the; /// def-use chain of uses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:262,access,access,262,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,1,['access'],['access']
Security,"/// By the time a cluster has been loaded, this cluster might not be necessary anymore. This can happen if; /// there are jumps in the access pattern (i.e. the access pattern deviates from linear access).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:135,access,access,135,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,3,['access'],['access']
Security,/// CCState - This class holds information needed while lowering arguments and; /// return values. It captures which registers are already assigned and which; /// stack slots are used. It provides accessors to allocate these values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:197,access,accessors,197,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,1,['access'],['accessors']
Security,/// CFG hash value for the function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h:8,hash,hash,8,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,1,['hash'],['hash']
Security,"/// CRTP base class providing obvious overloads for the core \c; /// Allocate() methods of LLVM-style allocators.; ///; /// This base class both documents the full public interface exposed by all; /// LLVM-style allocators, and redirects all of the overloads to a single core; /// set of methods which the derived class must define.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/AllocatorBase.h:181,expose,exposed,181,interpreter/llvm-project/llvm/include/llvm/Support/AllocatorBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/AllocatorBase.h,1,['expose'],['exposed']
Security,/// Cache for TLI::getLibFunc() result without prototype validation.; /// UnknownLibFunc if uninitialized. NotLibFunc if definitely not lib func.; /// Otherwise may be libfunc if prototype validation passes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h:57,validat,validation,57,interpreter/llvm-project/llvm/include/llvm/IR/Function.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h,2,['validat'],['validation']
Security,"/// Cache of TBAA base nodes that have already been visited. This cachce maps; /// a node that has been visited to a pair (IsInvalid, BitWidth) where; ///; /// \c IsInvalid is true iff the node is invalid.; /// \c BitWidth, if non-zero, is the bitwidth of the integer used to denoting; /// the offset of the access. If zero, only a zero offset is allowed.; ///; /// \c BitWidth has no meaning if \c IsInvalid is true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h:308,access,access,308,interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h,1,['access'],['access']
Security,"/// Cache of the tree/chain branch names. Never access directy, always use GetBranchNames().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx:48,access,access,48,tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx,1,['access'],['access']
Security,"/// Calculate Start and End points of memory access.; /// Let's assume A is the first access and B is a memory access on N-th loop; /// iteration. Then B is calculated as:; /// B = A + Step*N .; /// Step value may be positive or negative.; /// N is a calculated back-edge taken count:; /// N = (TripCount > 0) ? RoundDown(TripCount -1 , VF) : 0; /// Start and End points are calculated in the following way:; /// Start = UMIN(A, B) ; End = UMAX(A, B) + SizeOfElt,; /// where SizeOfElt is the size of single memory access in bytes.; ///; /// There is no conflict when the intervals are disjoint:; /// NoConflict = (P2.Start >= P1.End) || (P1.Start >= P2.End)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:45,access,access,45,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,4,['access'],['access']
Security,/// Calculate a unique representation for a statement that is; /// stable across compiler invocations.; ///; /// \param ID profile information will be stored in ID.; ///; /// \param Hash an ODRHash object which will be called where pointers would; /// have been used in the Profile function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Stmt.h:182,Hash,Hash,182,interpreter/llvm-project/clang/include/clang/AST/Stmt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Stmt.h,1,['Hash'],['Hash']
Security,/// Calculate hash of the pcm content.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTWriter.h:14,hash,hash,14,interpreter/llvm-project/clang/include/clang/Serialization/ASTWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTWriter.h,1,['hash'],['hash']
Security,"/// Calculate the ""Indirect Address"" for the given \p RegIndex and; /// \p Channel; ///; /// We model indirect addressing using a virtual address space that can be; /// accessed with loads and stores. The ""Indirect Address"" is the memory; /// address in this virtual address space that maps to the given \p RegIndex; /// and \p Channel.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.h:169,access,accessed,169,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.h,1,['access'],['accessed']
Security,/// Calculates the access of a decl that is reached; /// along a path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:19,access,access,19,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,1,['access'],['access']
Security,"/// Call \p CB on all accesses that might interfere with \p I and; /// return true if all such accesses were known and the callback returned true; /// for all of them, false otherwise. In contrast to forallInterferingAccesses; /// this function will perform reasoning to exclude write accesses that cannot; /// affect the load even if they on the surface look as if they would. The; /// flag \p HasBeenWrittenTo will be set to true if we know that \p I does not; /// read the initial value of the underlying memory. If \p SkipCB is given and; /// returns false for a potentially interfering access, that access is not; /// checked for actual interference.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:22,access,accesses,22,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,5,['access'],"['access', 'accesses']"
Security,"/// Call \p CB on all accesses that might interfere with \p Range and return; /// true if all such accesses were known and the callback returned true for; /// all of them, false otherwise. An access interferes with an offset-size; /// pair if it might read or write that memory region.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:22,access,accesses,22,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,3,['access'],"['access', 'accesses']"
Security,"/// Callback invoked whenever an inclusion directive of; /// any kind (\c \#include, \c \#import, etc.) has been processed, regardless; /// of whether the inclusion will actually result in an inclusion.; ///; /// \param HashLoc The location of the '#' that starts the inclusion; /// directive.; ///; /// \param IncludeTok The token that indicates the kind of inclusion; /// directive, e.g., 'include' or 'import'.; ///; /// \param FileName The name of the file being included, as written in the; /// source code.; ///; /// \param IsAngled Whether the file name was enclosed in angle brackets;; /// otherwise, it was enclosed in quotes.; ///; /// \param FilenameRange The character range of the quotes or angle brackets; /// for the written file name.; ///; /// \param File The actual file that may be included by this inclusion; /// directive.; ///; /// \param SearchPath Contains the search path which was used to find the file; /// in the file system. If the file was found via an absolute include path,; /// SearchPath will be empty. For framework includes, the SearchPath and; /// RelativePath will be split up. For example, if an include of ""Some/Some.h""; /// is found via the framework path; /// ""path/to/Frameworks/Some.framework/Headers/Some.h"", SearchPath will be; /// ""path/to/Frameworks/Some.framework/Headers"" and RelativePath will be; /// ""Some.h"".; ///; /// \param RelativePath The path relative to SearchPath, at which the include; /// file was found. This is equal to FileName except for framework includes.; ///; /// \param Imported The module, whenever an inclusion directive was; /// automatically turned into a module import or null otherwise.; ///; /// \param FileType The characteristic kind, indicates whether a file or; /// directory holds normal user code, system code, or system code which is; /// implicitly 'extern ""C""' in C++ mode.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PPCallbacks.h:220,Hash,HashLoc,220,interpreter/llvm-project/clang/include/clang/Lex/PPCallbacks.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PPCallbacks.h,1,['Hash'],['HashLoc']
Security,/// Called during setup of the client to indicate that the client is ready; /// to receive messages.; ///; /// Transport objects should not access the client until this method is; /// called.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h:140,access,access,140,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h,1,['access'],['access']
Security,/// Called on a load from and a store to a location.; ///; /// The method will be called each time a location (pointer) value is; /// accessed.; /// \param Loc The value of the location (pointer).; /// \param IsLoad The flag specifying if the location is a store or a load.; /// \param S The load is performed while processing the statement.; ///; /// check::Location,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:134,access,accessed,134,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,1,['access'],['accessed']
Security,"/// Called when the contents of one or more regions change.; ///; /// This can occur in many different ways: an explicit bind, a blanket; /// invalidation of the region contents, or by passing a region to a function; /// call whose behavior the analyzer cannot model perfectly.; ///; /// \param State The current program state.; /// \param Invalidated A set of all symbols potentially touched by the change.; /// \param ExplicitRegions The regions explicitly requested for invalidation.; /// For a function call, this would be the arguments. For a bind, this; /// would be the region being bound to.; /// \param Regions The transitive closure of regions accessible from,; /// \p ExplicitRegions, i.e. all regions that may have been touched; /// by this change. For a simple bind, this list will be the same as; /// \p ExplicitRegions, since a bind does not affect the contents of; /// anything accessible through the base region.; /// \param LCtx LocationContext that is useful for getting various contextual; /// info, like callstack, CFG etc.; /// \param Call The opaque call triggering this invalidation. Will be 0 if the; /// change was not triggered by a call.; ///; /// check::RegionChanges",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:654,access,accessible,654,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,2,['access'],['accessible']
Security,"/// Can load/store 2 registers/cycle, but needs an extra cycle if the access; /// is not 64-bit aligned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:70,access,access,70,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,1,['access'],['access']
Security,"/// Can the file be accessed?; ///; /// @param Path Input path.; /// @returns errc::success if the path can be accessed, otherwise a; /// platform-specific error_code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:20,access,accessed,20,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,2,['access'],['accessed']
Security,"/// Can the stack be realigned. This can be false if the target does not; /// support stack realignment, or if the user asks us not to realign the; /// stack. In this situation, overaligned allocas are all treated as dynamic; /// allocations and the target must handle them as part of DYNAMIC_STACKALLOC; /// lowering. All non-alloca stack objects have their alignment clamped to the; /// base ABI stack alignment.; /// FIXME: There is room for improvement in this case, in terms of; /// grouping overaligned allocas into a ""secondary stack frame"" and; /// then only use a single alloca to allocate this frame and only a; /// single virtual register to access it. Currently, without such an; /// optimization, each such alloca gets its own dynamic realignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:653,access,access,653,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,1,['access'],['access']
Security,"/// Canonical proxy type returned when retrieving the members of a; /// canonical type or as the result of the @c CanQual<T>::getAs member; /// function.; ///; /// The CanProxy type mainly exists as a proxy through which operator-> will; /// look to either map down to a raw T* (e.g., PointerType*) or to a proxy; /// type that provides canonical-type access to the fields of the type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CanonicalType.h:352,access,access,352,interpreter/llvm-project/clang/include/clang/AST/CanonicalType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CanonicalType.h,1,['access'],['access']
Security,"/// Captures file system interaction and generates data to be later replayed; /// with the RedirectingFileSystem.; ///; /// For any file that gets accessed we eventually create:; /// - a copy of the file inside Root; /// - a record in RedirectingFileSystem mapping that maps:; /// current real path -> path to the copy in Root; ///; /// That intent is that later when the mapping is used by RedirectingFileSystem; /// it simulates the state of FS that we collected.; ///; /// We generate file copies and mapping lazily - see writeMapping and copyFiles.; /// We don't try to capture the state of the file at the exact time when it's; /// accessed. Files might get changed, deleted ... we record only the ""final""; /// state.; ///; /// In order to preserve the relative topology of files we use their real paths; /// as relative paths inside of the Root.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileCollector.h:147,access,accessed,147,interpreter/llvm-project/llvm/include/llvm/Support/FileCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileCollector.h,2,['access'],['accessed']
Security,"/// Cast a base object to a member's actual type.; ///; /// There are two relevant checks:; ///; /// C++ [class.access.base]p7:; ///; /// If a class member access operator [...] is used to access a non-static; /// data member or non-static member function, the reference is ill-formed if; /// the left operand [...] cannot be implicitly converted to a pointer to the; /// naming class of the right operand.; ///; /// C++ [expr.ref]p7:; ///; /// If E2 is a non-static data member or a non-static member function, the; /// program is ill-formed if the class of which E2 is directly a member is an; /// ambiguous base (11.8) of the naming class (11.9.3) of E2.; ///; /// Note that the latter check does not consider access; the access of the; /// ""real"" base class is checked as appropriate when checking the access of the; /// member name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:112,access,access,112,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,6,['access'],['access']
Security,/// Categorize the pointer arguments of CB that might access memory in; /// AccessedLoc and update the state and access map accordingly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:54,access,access,54,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,3,"['Access', 'access']","['AccessedLoc', 'access']"
Security,"/// Changes options inside \p CI to use PCH from this preamble. Also remaps; /// main file to \p MainFileBuffer and updates \p VFS to ensure the preamble; /// is accessible.; /// Requires that CanReuse() is true.; /// For in-memory preambles, PrecompiledPreamble instance continues to own the; /// MemoryBuffer with the Preamble after this method returns. The caller is; /// responsible for making sure the PrecompiledPreamble instance outlives the; /// compiler run and the AST that will be using the PCH.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h:162,access,accessible,162,interpreter/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/PrecompiledPreamble.h,1,['access'],['accessible']
Security,"/// Check ODR hashes for C/ObjC when merging types from modules.; /// Differently from C++, actually parse the body and reject in case; /// of a mismatch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:14,hash,hashes,14,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['hash'],['hashes']
Security,/// Check \p Pred on all accesses to the memory kinds specified by \p MLK.; ///; /// This method will evaluate \p Pred on all accesses (access instruction +; /// underlying accessed memory pointer) and it will return true if \p Pred; /// holds every time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:25,access,accesses,25,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,4,['access'],"['access', 'accessed', 'accesses']"
Security,/// Check a VLA for validity.; /// Every dimension of the array and the total size is checked for validity.; /// Returns null or a new state where the size is validated.; /// 'ArraySize' will contain SVal that refers to the total size (in char); /// of the array.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp:159,validat,validated,159,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp,1,['validat'],['validated']
Security,/// Check an ext-vector component access expression.; ///; /// VK should be set in advance to the value kind of the base; /// expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:34,access,access,34,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['access'],['access']
Security,"/// Check assignment constraints for an assignment of RHS to LHSType.; ///; /// \param LHSType The destination type for the assignment.; /// \param RHS The source expression for the assignment.; /// \param Diagnose If \c true, diagnostics may be produced when checking; /// for assignability. If a diagnostic is produced, \p RHS will be; /// set to ExprError(). Note that this function may still return; /// without producing a diagnostic, even for an invalid assignment.; /// \param DiagnoseCFAudited If \c true, the target is a function parameter; /// in an audited Core Foundation API and does not need to be checked; /// for ARC retain issues.; /// \param ConvertRHS If \c true, \p RHS will be updated to model the; /// conversions necessary to perform the assignment. If \c false,; /// \p Diagnose must also be \c false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:560,audit,audited,560,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['audit'],['audited']
Security,"/// Check by comparing bits 62 and 61 of the authenticated address.; ///; /// This method modifies control flow and inserts the following checker:; ///; /// ```; /// eor Xtmp, Xn, Xn, lsl #1; /// tbnz Xtmp, #62, break_block; /// ```",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.h:45,authenticat,authenticated,45,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.h,1,['authenticat'],['authenticated']
Security,"/// Check by comparing the authenticated value with an XPAC-ed one without; /// using PAuth instructions not encoded as HINT. Can only be applied to LR.; ///; /// This method modifies control flow and inserts the following checker:; ///; /// ```; /// mov Xtmp, LR; /// xpaclri ; encoded as ""hint #7""; /// ; Note: at this point, the LR register contains the address as if; /// ; the authentication succeeded and the temporary register contains the; /// ; *real* result of authentication.; /// cmp Xtmp, LR; /// b.ne break_block; /// ```",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.h:27,authenticat,authenticated,27,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.h,3,['authenticat'],"['authenticated', 'authentication']"
Security,"/// Check for equality. Similar to StringRef::equals, but will also cover for; /// the case where one or both are hash codes. Comparing their int values are; /// sufficient. A hash code FunctionId is considered not equal to a StringRef; /// FunctionId regardless of actual contents.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/FunctionId.h:114,hash,hash,114,interpreter/llvm-project/llvm/include/llvm/ProfileData/FunctionId.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/FunctionId.h,2,['hash'],['hash']
Security,"/// Check for:; /// CERT/STR02-C. ""Sanitize data passed to complex subsystems""; /// CWE-78, ""Failure to Sanitize Data into an OS Command""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:35,Sanitiz,Sanitize,35,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,2,['Sanitiz'],['Sanitize']
Security,/// Check if \p Instr belongs to any interleaved access group.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:49,access,access,49,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['access'],['access']
Security,/// Check if \p MO would be a valid operand for the given operand; /// definition \p OpInfo. Note this does not attempt to validate constant bus; /// restrictions (e.g. literal constant usage).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.h:123,validat,validate,123,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.h,1,['validat'],['validate']
Security,"/// Check if \p Op is known to access an address not on the function's stack .; /// At the moment, accesses where the underlying object is a global, function; /// argument, or jump table are considered non-stack accesses. Note that the; /// caller's stack may get accessed when passing an argument via the stack,; /// but not the stack of the current function.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:31,access,access,31,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,4,['access'],"['access', 'accessed', 'accesses']"
Security,/// Check if a certain (single) sanitizer is enabled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h:32,sanitiz,sanitizer,32,interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h,1,['sanitiz'],['sanitizer']
Security,"/// Check if a value looks like a hash.; ///; /// The routine is expected to detect values computed using the most common hash; /// algorithms. Typically, hash computations end with one of the following; /// instructions:; ///; /// 1) MUL with a constant wider than BypassType; /// 2) XOR instruction; ///; /// And even if we are wrong and the value is not a hash, it is still quite; /// unlikely that such values will fit into BypassType.; ///; /// To detect string hash algorithms like FNV we have to look through PHI-nodes.; /// It is implemented as a depth-first search for values that look neither long; /// nor hash-like.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:34,hash,hash,34,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,6,['hash'],"['hash', 'hash-like']"
Security,"/// Check if executing a load of this pointer value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do; /// a quick local scan of the basic block containing \c ScanFrom, to determine; /// if the address is already accessed.; ///; /// This uses the pointee type to determine how many bytes need to be safe to; /// load from the pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:420,access,accessed,420,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,1,['access'],['accessed']
Security,/// Check if one or more sanitizers are enabled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h:25,sanitiz,sanitizers,25,interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h,1,['sanitiz'],['sanitizers']
Security,/// Check if the given type is a valid base type to be used in access tags.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp:63,access,access,63,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp,1,['access'],['access']
Security,/// Check if the instruction accessing memory (TheI) can be moved to the; /// location ToI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:29,access,accessing,29,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,1,['access'],['accessing']
Security,"/// Check if the instruction is large stride.; /// The purpose is to identify memory access pattern like:; /// x = a[i];; /// y = a[i+1000];; /// z = a[i+2000];; /// In the above example, the second and third memory access will be marked; /// large stride memory access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.cpp:85,access,access,85,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.cpp,3,['access'],['access']
Security,/// Check if the return value of this function requires sanitization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:56,sanitiz,sanitization,56,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,2,['sanitiz'],['sanitization']
Security,/// Check if the stride of the accesses is large enough to; /// warrant a prefetch.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp:31,access,accesses,31,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp,1,['access'],['accesses']
Security,"/// Check if the type of a class element has an accessible destructor, and marks; /// it referenced. Returns true if we shouldn't form a reference to the; /// destructor.; ///; /// Aggregate initialization requires a class element's destructor be; /// accessible per 11.6.1 [dcl.init.aggr]:; ///; /// The destructor for each element of class type is potentially invoked; /// (15.4 [class.dtor]) from the context where the aggregate initialization; /// occurs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:48,access,accessible,48,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,2,['access'],['accessible']
Security,"/// Check if this object represents a StringRef, or a hash code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/FunctionId.h:54,hash,hash,54,interpreter/llvm-project/llvm/include/llvm/ProfileData/FunctionId.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/FunctionId.h,1,['hash'],['hash']
Security,"/// Check if we can emit a run-time no-alias check for \p Access.; ///; /// Returns true if we can emit a run-time no alias check for \p Access.; /// If we can check this access, this also adds it to a dependence set and; /// adds a run-time to check for it to \p RtCheck. If \p Assume is true,; /// we will attempt to use additional run-time checks in order to get; /// the bounds of the pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:58,Access,Access,58,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,3,"['Access', 'access']","['Access', 'access']"
Security,"/// Check loop instructions safe for Loop versioning.; /// It returns true if it's safe else returns false.; /// Consider following:; /// 1) Check all load store in loop body are non atomic & non volatile.; /// 2) Check function call safety, by ensuring its not accessing memory.; /// 3) Loop body shouldn't have any may throw instruction.; /// 4) Loop body shouldn't have any convergent or noduplicate instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:262,access,accessing,262,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,1,['access'],['accessing']
Security,/// Check memory accesses in loop and confirms it's good for; /// LoopVersioningLICM.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:17,access,accesses,17,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,1,['access'],['accesses']
Security,"/// Check piece by piece the 4 64 bits ints which make up the hash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/RConcurrentHashColl.hxx:62,hash,hash,62,core/thread/inc/ROOT/RConcurrentHashColl.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/RConcurrentHashColl.hxx,1,['hash'],['hash']
Security,/// Check that the items in 'Live' dominate 'TI'. This is used as a basic; /// validation check for the liveness computation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:79,validat,validation,79,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['validat'],['validation']
Security,/// Check the address space of the memory access for the given machine memory; /// operand.; /// - InsnID(ULEB128) - Instruction ID; /// - MMOIdx(ULEB128) - MMO index; /// - NumAddrSpace(ULEB128) - Number of valid address spaces; /// - AddrSpaceN(ULEB128) - An allowed space of the memory access; /// - AddrSpaceN+1 ...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h:42,access,access,42,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h,2,['access'],['access']
Security,"/// Check the constraints on expression operands to unary type expression; /// and type traits.; ///; /// Completes any types necessary and validates the constraints on the operand; /// expression. The logic mostly mirrors the type-based overload, but may modify; /// the expression as it completes the type for that expression through template; /// instantiation, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:140,validat,validates,140,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['validat'],['validates']
Security,"/// Check the constraints on operands to unary expression and type; /// traits.; ///; /// This will complete any types necessary, and validate the various constraints; /// on those operands.; ///; /// The UsualUnaryConversions() function is *not* called by this routine.; /// C99 6.3.2.1p[2-4] all state:; /// Except when it is the operand of the sizeof operator ...; ///; /// C++ [expr.sizeof]p4; /// The lvalue-to-rvalue, array-to-pointer, and function-to-pointer; /// standard conversions are not applied to the operand of sizeof.; ///; /// This policy is followed for all of the unary trait expressions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:134,validat,validate,134,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['validat'],['validate']
Security,/// Check the dependence for two accesses with the same stride \p Stride.; /// \p Distance is the positive distance and \p TypeByteSize is type size in; /// bytes.; ///; /// \returns true if they are independent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:33,access,accesses,33,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['access'],['accesses']
Security,/// Check the minimum alignment of the memory access for the given machine; /// memory operand.; /// - InsnID(ULEB128) - Instruction ID; /// - MMOIdx(ULEB128) - MMO index; /// - MinAlign(ULEB128) - Minimum acceptable alignment,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h:46,access,access,46,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h,1,['access'],['access']
Security,"/// Check the preprocessor options deserialized from the control block; /// against the preprocessor options in an existing preprocessor.; ///; /// \param Diags If non-null, produce diagnostics for any mismatches incurred.; /// \param Validation If set to OptionValidateNone, ignore differences in; /// preprocessor options. If set to OptionValidateContradictions,; /// require that options passed both in the AST file and on the command; /// line (-D or -U) match, but tolerate options missing in one or the; /// other. If set to OptionValidateContradictions, require that there; /// are no differences in the options between the two.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:235,Validat,Validation,235,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['Validat'],['Validation']
Security,/// Check the size of the memory access for the given machine memory operand.; /// - InsnID(ULEB128) - Instruction ID; /// - MMOIdx(ULEB128) - MMO index; /// - Size(4) - The size in bytes of the memory access,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h:33,access,access,33,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h,2,['access'],['access']
Security,/// Check the size of the memory access for the given machine memory operand; /// against the size of an operand.; /// - InsnID(ULEB128) - Instruction ID; /// - MMOIdx(ULEB128) - MMO index; /// - OpIdx(ULEB128) - The operand index to compare the MMO against,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h:33,access,access,33,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h,1,['access'],['access']
Security,"/// Check validaty of calling convention attribute \p attr. If \p FD; /// is not null pointer, use \p FD to determine the CUDA/HIP host/device; /// target. Otherwise, it is specified by \p CFT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:10,validat,validaty,10,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['validat'],['validaty']
Security,/// Check whether MDNode is a vtable access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Metadata.h:37,access,access,37,interpreter/llvm-project/llvm/include/llvm/IR/Metadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Metadata.h,1,['access'],['access']
Security,/// Check whether a given allocation must be put on the safe; /// stack or not. The function analyzes all uses of AI and checks whether it is; /// only accessed in a memory safe way (as decided statically).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:152,access,accessed,152,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,1,['access'],['accessed']
Security,/// Check whether null pointer dereferencing is considered undefined behavior; /// for a given function or an address space.; /// Null pointer access in non-zero address space is not considered undefined.; /// Return value: false => null pointer dereference is undefined.; /// Return value: true => null pointer dereference is not undefined.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h:143,access,access,143,interpreter/llvm-project/llvm/include/llvm/IR/Function.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h,1,['access'],['access']
Security,"/// Check whether or not we should apply the terminal rule on the; /// destination (Dst) of \p Copy.; /// When the terminal rule applies, Copy is not profitable to; /// coalesce.; /// Dst is terminal if it has exactly one affinity (Dst, Src) and; /// at least one interference (Dst, Dst2). If Dst is terminal, the; /// terminal rule consists in checking that at least one of; /// interfering node, say Dst2, has an affinity of equal or greater; /// weight with Src.; /// In that case, Dst2 and Dst will not be able to be both coalesced; /// with Src. Since Dst2 exposes more coalescing opportunities than; /// Dst, we can drop \p Copy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:562,expose,exposes,562,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['expose'],['exposes']
Security,/// Check whether the access index chain is valid. We check; /// here because there may be type casts between two; /// access indexes. We want to ensure memory access still valid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:22,access,access,22,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,3,['access'],['access']
Security,/// Check whether the access through \p Ptr has a constant stride.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:22,access,access,22,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['access'],['access']
Security,/// Check whether the dependencies between the accesses are safe.; ///; /// Only checks sets with elements in \p CheckDeps.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:47,access,accesses,47,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['access'],['accesses']
Security,"/// Check whether the result has already been computed; ///; /// ~~~{.cpp}; /// std::vector<RResultHandle> results;; /// results.emplace_back(df.Mean<double>(""var""));; /// res.IsReady(); // false, access will trigger event loop; /// std::cout << res.GetValue<double>() << std::endl; // triggers event loop; /// res.IsReady(); // true; /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultHandle.hxx:197,access,access,197,tree/dataframe/inc/ROOT/RResultHandle.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultHandle.hxx,1,['access'],['access']
Security,"/// Check whether there is a plausible dependence between the two; /// accesses.; ///; /// Access \p A must happen before \p B in program order. The two indices; /// identify the index into the program order map.; ///; /// This function checks whether there is a plausible dependence (or the; /// absence of such can't be proved) between the two accesses. If there is a; /// plausible dependence but the dependence distance is bigger than one; /// element access it records this distance in \p MinDepDistBytes (if this; /// distance is smaller than any other distance encountered so far).; /// Otherwise, this function returns true signaling a possible dependence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:71,access,accesses,71,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,4,"['Access', 'access']","['Access', 'access', 'accesses']"
Security,/// CheckCXXThrowOperand - Validate the operand of a throw.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:27,Validat,Validate,27,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['Validat'],['Validate']
Security,"/// CheckDerivedToBaseConversion - Check whether the Derived-to-Base; /// conversion (where Derived and Base are class types) is; /// well-formed, meaning that the conversion is unambiguous (and; /// that all of the base classes are accessible). Returns true; /// and emits a diagnostic if the code is ill-formed, returns false; /// otherwise. Loc is the location where this routine should point to; /// if there is an error, and Range is the source range to highlight; /// if there is an error.; ///; /// If either InaccessibleBaseID or AmbiguousBaseConvID are 0, then the; /// diagnostic for the respective type of error will be suppressed, but the; /// check for ill-formed code will still be performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:233,access,accessible,233,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['access'],['accessible']
Security,"/// CheckJump - Validate that the specified jump statement is valid: that it is; /// jumping within or out of its current scope, not into a deeper one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:16,Validat,Validate,16,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,1,['Validat'],['Validate']
Security,"/// CheckStaticArrayArgument - If the given argument corresponds to a static; /// array parameter, check that it is non-null, and that if it is formed by; /// array-to-pointer decay, the underlying array is sufficiently large.; ///; /// C99 6.7.5.3p7: If the keyword static also appears within the [ and ] of the; /// array type derivation, then for each call to the function, the value of the; /// corresponding actual argument shall provide access to the first element of; /// an array with at least as many elements as specified by the size expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:443,access,access,443,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['access'],['access']
Security,/// Checking the object expression in a non-static data member access. Must; /// be an object within its lifetime.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:63,access,access,63,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['access'],['access']
Security,"/// Checks _syntactically_ whether it is possible to access FD from the record; /// that contains it without a preceding assert (even if that access happens; /// inside a method). This is mainly used for records that act like unions, like; /// having multiple bit fields, with only a fraction being properly initialized.; /// If these fields are properly guarded with asserts, this method returns; /// false.; ///; /// Since this check is done syntactically, this method could be inaccurate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:53,access,access,53,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,2,['access'],['access']
Security,/// Checks access for a hierarchy conversion.; ///; /// \param ForceCheck true if this check should be performed even if access; /// control is disabled; some things rely on this for semantics; /// \param ForceUnprivileged true if this check should proceed as if the; /// context had no special privileges,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,access,access,11,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,2,['access'],['access']
Security,"/// Checks access to Target from the given class. The check will take access; /// specifiers into account, but no member access expressions and such.; ///; /// \param Target the declaration to check if it can be accessed; /// \param NamingClass the class in which the lookup was started.; /// \param BaseType type of the left side of member access expression.; /// \p BaseType and \p NamingClass are used for C++ access control.; /// Depending on the lookup case, they should be set to the following:; /// - lhs.target (member access without a qualifier):; /// \p BaseType and \p NamingClass are both the type of 'lhs'.; /// - lhs.X::target (member access with a qualifier):; /// BaseType is the type of 'lhs', NamingClass is 'X'; /// - X::target (qualified lookup without member access):; /// BaseType is null, NamingClass is 'X'.; /// - target (unqualified lookup).; /// BaseType is null, NamingClass is the parent class of 'target'.; /// \return true if the Target is accessible from the Class, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,access,access,11,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,10,['access'],"['access', 'accessed', 'accessible']"
Security,/// Checks access to a constructor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,access,access,11,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,2,['access'],['access']
Security,/// Checks access to a member.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,access,access,11,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['access'],['access']
Security,/// Checks access to all the declarations in the given result set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,access,access,11,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['access'],['access']
Security,/// Checks access to an entity from the given effective context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,access,access,11,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['access'],['access']
Security,"/// Checks access to an overloaded member operator, including; /// conversion operators.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,access,access,11,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['access'],['access']
Security,/// Checks access to an overloaded operator new or delete.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,access,access,11,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['access'],['access']
Security,/// Checks access to the target of a friend declaration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:11,access,access,11,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['access'],['access']
Security,"/// Checks guarded_by and pt_guarded_by attributes.; /// Whenever we identify an access (read or write) to a DeclRefExpr that is; /// marked with guarded_by, we must ensure the appropriate mutexes are held.; /// Similarly, we check if the access is to an expression that dereferences; /// a pointer marked with pt_guarded_by.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:81,access,access,81,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,2,['access'],['access']
Security,/// Checks if a pointer is live and accessible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h:36,access,accessible,36,interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,1,['access'],['accessible']
Security,"/// Checks if the specified call is known to only read from non-volatile; /// memory (or not access memory at all).; ///; /// Calls that unwind the stack are legal for this predicate.; ///; /// This property allows many common optimizations to be performed in the; /// absence of interfering store instructions, such as CSE of strlen calls.; ///; /// This property corresponds to the GCC 'pure' attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:93,access,access,93,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,1,['access'],['access']
Security,"/// Checks if the specified function is known to only read from non-volatile; /// memory (or not access memory at all).; ///; /// Functions that unwind the stack are legal for this predicate.; ///; /// This property allows many common optimizations to be performed in the; /// absence of interfering store instructions, such as CSE of strlen calls.; ///; /// This property corresponds to the GCC 'pure' attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:97,access,access,97,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,1,['access'],['access']
Security,/// Checks if two instructions may access the same memory.; ///; /// \p Loc1 is the location of \p Inst1. It is passed explicitly because it; /// is invariant in the calling loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,access,access,35,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['access'],['access']
Security,/// Checks implicit access to a member in a structured binding.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:20,access,access,20,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['access'],['access']
Security,/// Checks legality for LoopVersioningLICM by considering following:; /// a) loop structure legality b) loop instruction legality; /// c) loop memory access legality.; /// Return true if legal else returns false.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:150,access,access,150,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,1,['access'],['access']
Security,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:36,access,accesses,36,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,7,['access'],"['access', 'accesses']"
Security,/// Clear this MachineInstr's memory reference descriptor list. This resets; /// the memrefs to their most conservative state. This should be used only; /// as a last resort since it greatly pessimizes our knowledge of the memory; /// access performed by the instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:235,access,access,235,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['access'],['access']
Security,"/// Closed hash table from Offset -> StreamNumber, where Offset is the offset; /// of the stream name in NamesBuffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/NamedStreamMap.h:11,hash,hash,11,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/NamedStreamMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/NamedStreamMap.h,1,['hash'],['hash']
Security,/// Code completion occurred on the right-hand side of a member; /// access expression using the arrow operator.; ///; /// The results of this completion are the members of the type being; /// accessed. The type itself is available via; /// \c CodeCompletionContext::getType().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h:69,access,access,69,interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,2,['access'],"['access', 'accessed']"
Security,/// Code completion occurred on the right-hand side of a member; /// access expression using the dot operator.; ///; /// The results of this completion are the members of the type being; /// accessed. The type itself is available via; /// \c CodeCompletionContext::getType().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h:69,access,access,69,interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,2,['access'],"['access', 'accessed']"
Security,/// Code completion occurred on the right-hand side of an Objective-C; /// property access expression.; ///; /// The results of this completion are the members of the type being; /// accessed. The type itself is available via; /// \c CodeCompletionContext::getType().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h:84,access,access,84,interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,2,['access'],"['access', 'accessed']"
Security,/// Code integrity checks are enforced.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:9,integrity,integrity,9,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,1,['integrity'],['integrity']
Security,"/// CodeInjector is an interface which is responsible for injecting AST; /// of function definitions that may not be available in the original source.; ///; /// The getBody function will be called each time the static analyzer examines a; /// function call that has no definition available in the current translation; /// unit. If the returned statement is not a null pointer, it is assumed to be; /// the body of a function which will be used for the analysis. The source of; /// the body can be arbitrary, but it is advised to use memoization to avoid; /// unnecessary reparsing of the external source that provides the body of the; /// functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/CodeInjector.h:58,inject,injecting,58,interpreter/llvm-project/clang/include/clang/Analysis/CodeInjector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/CodeInjector.h,1,['inject'],['injecting']
Security,"/// CodeViewContext has the real knowledge about this format, so let it access; /// our members.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCFragment.h:72,access,access,72,interpreter/llvm-project/llvm/include/llvm/MC/MCFragment.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCFragment.h,2,['access'],['access']
Security,/// Collect all the accesses with a constant stride in program order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:20,access,accesses,20,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,1,['access'],['accesses']
Security,"/// Collect all the data dependency infos coming from any pair of memory; /// accesses from \p Src to \p Dst, and store them into \p Deps. Return true; /// if a dependence exists, and false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h:78,access,accesses,78,interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DDG.h,1,['access'],['accesses']
Security,"/// Collect memory access with loop invariant strides.; ///; /// Looks for accesses like ""a[i * StrideA]"" where ""StrideA"" is loop; /// invariant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:19,access,access,19,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,2,['access'],"['access', 'accesses']"
Security,/// Collect store and getelementptr instructions and organize them; /// according to the underlying object of their pointer operands. We sort the; /// instructions by their underlying objects to reduce the cost of; /// consecutive access queries.; ///; /// TODO: We can further reduce this cost if we flush the chain creation; /// every time we run into a memory barrier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h:231,access,access,231,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h,1,['access'],['access']
Security,/// Collect the dependences from LoopAccessInfo.; ///; /// We process the dependences once during the interleaved access analysis to; /// enable constant-time dependence queries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:114,access,access,114,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,1,['access'],['access']
Security,"/// Collect the instructions that are uniform after vectorization. An; /// instruction is uniform if we represent it with a single scalar value in; /// the vectorized loop corresponding to each vector iteration. Examples of; /// uniform instructions include pointer operands of consecutive or; /// interleaved memory accesses. Note that although uniformity implies an; /// instruction will be scalar, the reverse is not true. In general, a; /// scalarized instruction will be represented by VF scalar values in the; /// vectorized loop, each corresponding to an iteration of the original; /// scalar loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:317,access,accesses,317,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['access'],['accesses']
Security,/// Collect the visible conversions of a base class.; ///; /// \param Record a base class of the class we're considering; /// \param InVirtual whether this base class is a virtual base (or a base; /// of a virtual base); /// \param Access the access along the inheritance path to this base; /// \param ParentHiddenTypes the conversions provided by the inheritors; /// of this base; /// \param Output the set to which to add conversions from non-virtual bases; /// \param VOutput the set to which to add conversions from virtual bases; /// \param HiddenVBaseCs the set of conversions which were hidden in a; /// virtual base along some inheritance path,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:232,Access,Access,232,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,2,"['Access', 'access']","['Access', 'access']"
Security,"/// Collect unswitch candidates by invariant conditions that are not immediately; /// present in the loop. However, they can be injected into the code if we; /// decide it's profitable.; /// An example of such conditions is following:; ///; /// for (...) {; /// x = load ...; /// if (! x <u C1) break;; /// if (! x <u C2) break;; /// <do something>; /// }; ///; /// We can unswitch by condition ""C1 <=u C2"". If that is true, then ""x <u C1 <=; /// C2"" automatically implies ""x <u C2"", so we can get rid of one of; /// loop-variant checks in unswitched loop version.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:128,inject,injected,128,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['inject'],['injected']
Security,/// Collection accessors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:15,access,accessors,15,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,1,['access'],['accessors']
Security,/// Collection of parameters shared beetween the Loop Vectorizer and the; /// Loop Access Analysis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:83,Access,Access,83,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['Access'],['Access']
Security,"/// Combine one chunk of data into the current in-flight hash.; ///; /// This merges one chunk of data into the hash. First it tries to buffer; /// the data. If the buffer is full, it hashes the buffer into its; /// hash_state, empties it, and then merges the new chunk in. This also; /// handles cases where the data straddles the end of the buffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:57,hash,hash,57,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,3,['hash'],"['hash', 'hashes']"
Security,"/// Compare one IRInstructionData class to another IRInstructionData class for; /// whether they are performing a the same operation, and can mapped to the; /// same value. For regular instructions if the hash value is the same, then; /// they will also be close.; ///; /// \param A - The first IRInstructionData class to compare; /// \param B - The second IRInstructionData class to compare; /// \returns true if \p A and \p B are similar enough to be mapped to the same; /// value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:205,hash,hash,205,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,1,['hash'],['hash']
Security,/// Compile time access to the IR attribute kind.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:17,access,access,17,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,2,['access'],['access']
Security,/// Compile-time customization of User operands.; ///; /// Customizes operand-related allocators and accessors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/User.h:101,access,accessors,101,interpreter/llvm-project/llvm/include/llvm/IR/User.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/User.h,1,['access'],['accessors']
Security,/// Compute a fingerprint of this key for use in on-disk hash table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h:57,hash,hash,57,interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h,1,['hash'],['hash']
Security,/// Compute a hash_code for a pointer's address.; ///; /// N.B.: This hashes the *address*. Not the value and not the type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:70,hash,hashes,70,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,1,['hash'],['hashes']
Security,"/// Compute a stable_hash for a sequence of values.; ///; /// This hashes a sequence of values. It produces the same stable_hash as; /// 'stable_hash_combine(a, b, c, ...)', but can run over arbitrary sized; /// sequences and is significantly faster given pointers and types which; /// can be hashed as a sequence of bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h:67,hash,hashes,67,interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StableHashing.h,2,['hash'],"['hashed', 'hashes']"
Security,"/// Compute an MD5 hash of a file's contents.; ///; /// @param FD Input file descriptor.; /// @returns An MD5Result with the hash computed, if successful, otherwise a; /// std::error_code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:19,hash,hash,19,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,2,['hash'],['hash']
Security,"/// Compute suitable alignment to access this slice of the *new*; /// alloca.; ///; /// You can optionally pass a type to this routine and if that type's ABI; /// alignment is itself suitable, this will return zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:34,access,access,34,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['access'],['access']
Security,"/// Compute the access-group list of access groups that @p Inst1 and @p Inst2; /// are both in. If either instruction does not access memory at all, it is; /// considered to be in every list.; ///; /// If the list contains just one access group, it is returned directly. If the; /// list is empty, returns nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:16,access,access-group,16,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,4,['access'],"['access', 'access-group']"
Security,/// Compute the array dimensions Sizes from the set of Terms extracted from; /// the memory access function of this SCEVAddRecExpr (second step of; /// delinearization).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:92,access,access,92,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,1,['access'],['access']
Security,"/// Compute the base of the whole preserve_* intrinsics chains, i.e., the base; /// pointer of the first preserve_*_access_index call, and construct the access; /// string, which will be the name of a global variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:153,access,access,153,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,1,['access'],['access']
Security,"/// Compute the context hash for \p Deps, and create the mapping; /// \c ModuleDepsByID[Deps.ID] = &Deps.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:24,hash,hash,24,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,1,['hash'],['hash']
Security,/// Compute the file checksum debug info for input file ID.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:21,checksum,checksum,21,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,1,['checksum'],['checksum']
Security,/// Compute the final 64-bit hash code value based on the current; /// state and the length of bytes hashed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:29,hash,hash,29,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,2,['hash'],"['hash', 'hashed']"
Security,"/// Compute the index to access the element at (\p RowIdx, \p ColumnIdx) from; /// a matrix with \p NumRows embedded in a vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/MatrixBuilder.h:25,access,access,25,interpreter/llvm-project/llvm/include/llvm/IR/MatrixBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/MatrixBuilder.h,1,['access'],['access']
Security,"/// Compute the union of two access-group lists.; ///; /// If the list contains just one access group, it is returned directly. If the; /// list is empty, returns nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:29,access,access-group,29,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,2,['access'],"['access', 'access-group']"
Security,/// Compute whether or not a memory access at \p MI1 aliases with an access at; /// \p MI2 \returns true if either alias/no-alias is known. Sets \p IsAlias; /// accordingly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h:36,access,access,36,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h,2,['access'],['access']
Security,"/// ComputeHash - Compute a strong hash value for this FoldingSetNodeID, used; /// to lookup the node in the FoldingSetBase.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:35,hash,hash,35,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,1,['hash'],['hash']
Security,"/// ComputeHash - Compute a strong hash value for this FoldingSetNodeIDRef,; /// used to lookup the node in the FoldingSetBase.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:35,hash,hash,35,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,1,['hash'],['hash']
Security,/// ComputeNodeHash - Instantiations may optionally provide a way to compute a; /// hash value directly from a node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:84,hash,hash,84,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,1,['hash'],['hash']
Security,/// ComputeNodeHash - Instantiations of the FoldingSet template implement; /// this function to compute a hash value for the given node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:106,hash,hash,106,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,1,['hash'],['hash']
Security,/// Computes a unique hash for the Module considering the current list of; /// export/import and other global analysis results.; /// The hash is produced in \p Key.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h:22,hash,hash,22,interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h,2,['hash'],['hash']
Security,"/// Computes function attributes in post-order over the call graph.; ///; /// By operating in post-order, this pass computes precise attributes for; /// called functions prior to processsing their callers. This ""bottom-up""; /// approach allows powerful interprocedural inference of function attributes; /// like memory access patterns, etc. It can discover functions that do not; /// access memory, or only read memory, and give them the readnone/readonly; /// attribute. It also discovers function arguments that are not captured by; /// the function and marks them with the nocapture attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionAttrs.h:319,access,access,319,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionAttrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionAttrs.h,2,['access'],['access']
Security,/// Computes the Bernstein hash after folding the input according to the Dwarf 5; /// standard case folding rules.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DJB.h:27,hash,hash,27,interpreter/llvm-project/llvm/include/llvm/Support/DJB.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DJB.h,1,['hash'],['hash']
Security,/// Computes the full DWARF4 7.27 hash of the DIE.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h:34,hash,hash,34,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h,1,['hash'],['hash']
Security,/// Computes the hash for a given bytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MD5.h:17,hash,hash,17,interpreter/llvm-project/llvm/include/llvm/Support/MD5.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MD5.h,1,['hash'],['hash']
Security,"/// ConcurrentHashTable - is a resizeable concurrent hashtable.; /// The number of resizings limited up to x2^31. This hashtable is; /// useful to have efficient access to aggregate data(like strings,; /// type descriptors...) and to keep only single copy of such; /// an aggregate. The hashtable allows only concurrent insertions:; ///; /// KeyDataTy* = insert ( const KeyTy& );; ///; /// Data structure:; ///; /// Inserted value KeyTy is mapped to 64-bit hash value ->; ///; /// [------- 64-bit Hash value --------]; /// [ StartEntryIndex ][ Bucket Index ]; /// | |; /// points to the points to; /// first probe the bucket.; /// position inside; /// bucket entries; ///; /// After initialization, all buckets have an initial size. During insertions,; /// buckets might be extended to contain more entries. Each bucket can be; /// independently resized and rehashed(no need to lock the whole table).; /// Different buckets may have different sizes. If the single bucket is full; /// then the bucket is resized.; ///; /// BucketsArray keeps all buckets. Each bucket keeps an array of Entries; /// (pointers to KeyDataTy) and another array of entries hashes:; ///; /// BucketsArray[BucketIdx].Hashes[EntryIdx]:; /// BucketsArray[BucketIdx].Entries[EntryIdx]:; ///; /// [Bucket 0].Hashes -> [uint32_t][uint32_t]; /// [Bucket 0].Entries -> [KeyDataTy*][KeyDataTy*]; ///; /// [Bucket 1].Hashes -> [uint32_t][uint32_t][uint32_t][uint32_t]; /// [Bucket 1].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*][KeyDataTy*]; /// .........................; /// [Bucket N].Hashes -> [uint32_t][uint32_t][uint32_t]; /// [Bucket N].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*]; ///; /// ConcurrentHashTableByPtr uses an external thread-safe allocator to allocate; /// KeyDataTy items.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:53,hash,hashtable,53,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,11,"['Hash', 'access', 'hash']","['Hash', 'Hashes', 'access', 'hash', 'hashes', 'hashtable']"
Security,"/// Const access to statistics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:10,access,access,10,hist/histv7/inc/ROOT/RHistImpl.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx,1,['access'],['access']
Security,/// Const accessor to the directives.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCLinkerOptimizationHint.h:10,access,accessor,10,interpreter/llvm-project/llvm/include/llvm/MC/MCLinkerOptimizationHint.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCLinkerOptimizationHint.h,1,['access'],['accessor']
Security,/// Const element access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/Math.h:18,access,access,18,interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/Math.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/Math.h,1,['access'],['access']
Security,/// Construct a CacheCost object for the loop nest described by \p Loops.; /// The optional parameter \p TRT can be used to specify the max. distance; /// between array elements accessed in a loop so that the elements are; /// classified to have temporal reuse.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:178,access,accessed,178,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,1,['access'],['accessed']
Security,"/// Construct a recursive hash combining helper.; ///; /// This sets up the state for a recursive hash combine, including getting; /// the seed and buffer setup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:26,hash,hash,26,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,2,['hash'],['hash']
Security,/// Construct an invalid parameter index (\c isValid returns false and; /// accessors fail an assert).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Attr.h:76,access,accessors,76,interpreter/llvm-project/clang/include/clang/AST/Attr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Attr.h,1,['access'],['accessors']
Security,/// Construct class to support accessing the machine memory operands; /// of instructions in the machine function \p MF.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp:31,access,accessing,31,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,1,['access'],['accessing']
Security,"/// Construct from an \a MDNode.; ///; /// Note: if \c N is not an \a DILocation, a verifier check will fail, and; /// accessors will crash. However, construction from other nodes is; /// supported in order to handle forward references when reading textual; /// IR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugLoc.h:119,access,accessors,119,interpreter/llvm-project/llvm/include/llvm/IR/DebugLoc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugLoc.h,1,['access'],['accessors']
Security,/// ConstructionContext's subclasses describe different ways of constructing; /// an object in C++. The context re-captures the essential parent AST nodes; /// of the CXXConstructExpr it is assigned to and presents these nodes; /// through easy-to-understand accessor methods.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/ConstructionContext.h:259,access,accessor,259,interpreter/llvm-project/clang/include/clang/Analysis/ConstructionContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/ConstructionContext.h,1,['access'],['accessor']
Security,/// Constructor from a hash code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/FunctionId.h:23,hash,hash,23,interpreter/llvm-project/llvm/include/llvm/ProfileData/FunctionId.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/FunctionId.h,1,['hash'],['hash']
Security,/// Constructor; ///; /// \param Functions The set of functions we are deriving attributes for.; /// \param InfoCache Cache to hold various information accessible for; /// the abstract attributes.; /// \param Configuration The Attributor configuration which determines what; /// generic features to use.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:152,access,accessible,152,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['access'],['accessible']
Security,"/// Constructs a UnicodeCharSet instance from an array of; /// UnicodeCharRanges.; ///; /// Array pointed by \p Ranges should have the lifetime at least as long as; /// the UnicodeCharSet instance, and should not change. Array is validated by; /// the constructor, so it makes sense to create as few UnicodeCharSet; /// instances per each array of ranges, as possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/UnicodeCharRanges.h:230,validat,validated,230,interpreter/llvm-project/llvm/include/llvm/Support/UnicodeCharRanges.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/UnicodeCharRanges.h,1,['validat'],['validated']
Security,"/// Constructs a `MemberExpr` that accesses the named member (\p Member) of the; /// object bound to \p BaseId. The access is constructed idiomatically: if \p; /// BaseId is bound to `e` and \p Member identifies member `m`, then returns; /// `e->m`, when e is a pointer, `e2->m` when e = `*e2` and `e.m` otherwise.; /// Additionally, `e` is wrapped in parentheses, if needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h:35,access,accesses,35,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,2,['access'],"['access', 'accesses']"
Security,"/// Constructs a clang tool to run over a list of files.; ///; /// \param Compilations The CompilationDatabase which contains the compile; /// command lines for the given source paths.; /// \param SourcePaths The source files to run over. If a source files is; /// not found in Compilations, it is skipped.; /// \param PCHContainerOps The PCHContainerOperations for loading and creating; /// clang modules.; /// \param BaseFS VFS used for all underlying file accesses when running the; /// tool.; /// \param Files The file manager to use for underlying file operations when; /// running the tool.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:459,access,accesses,459,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,1,['access'],['accesses']
Security,/// Constructs a unique AbbrevTag that captures what a DIE accesses.; /// Using this tag we can emit a unique abbreviation for each DIE.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:59,access,accesses,59,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,1,['access'],['accesses']
Security,/// Contains a list of all hash values indexed by TypeIndex.toArrayIndex().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/GlobalTypeTableBuilder.h:27,hash,hash,27,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/GlobalTypeTableBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/GlobalTypeTableBuilder.h,1,['hash'],['hash']
Security,/// Convenience accessor for elements in the slice.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:16,access,accessor,16,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,1,['access'],['accessor']
Security,/// Convenience accessor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:16,access,accessor,16,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,2,['access'],['accessor']
Security,/// Convenience accessor. Returns null if there is no return value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:16,access,accessor,16,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['access'],['accessor']
Security,/// Convenience accessors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:16,access,accessors,16,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['access'],['accessors']
Security,/// Convenience accessors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:16,access,accessors,16,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['access'],['accessors']
Security,/// Convenience accessors; /// Return the outer EH-pad this funclet is nested within.; ///; /// Note: This returns the associated CatchSwitchInst if this FuncletPadInst; /// is a CatchPadInst.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:16,access,accessors,16,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['access'],['accessors']
Security,"/// Convert a TLS address reference into the correct sequence of loads; /// and calls to compute the variable's address (for Darwin, currently) and; /// return an SDValue containing the final node.; /// Darwin only has one TLS scheme which must be capable of dealing with the; /// fully general situation, in the worst case. This means:; /// + ""extern __thread"" declaration.; /// + Defined in a possibly unknown dynamic library.; ///; /// The general system is that each __thread variable has a [3 x i64] descriptor; /// which contains information used by the runtime to calculate the address. The; /// only part of this the compiler needs to know about is the first xword, which; /// contains a function pointer that must be called with the address of the; /// entire descriptor in ""x0"".; ///; /// Since this descriptor may be in a different unit, in general even the; /// descriptor must be accessed via an indirect load. The ""ideal"" code sequence; /// is:; /// adrp x0, _var@TLVPPAGE; /// ldr x0, [x0, _var@TLVPPAGEOFF] ; x0 now contains address of descriptor; /// ldr x1, [x0] ; x1 contains 1st entry of descriptor,; /// ; the function pointer; /// blr x1 ; Uses descriptor address in x0; /// ; Address of _var is now in x0.; ///; /// If the address of _var's descriptor *is* known to the linker, then it can; /// change the first ""ldr"" instruction to an appropriate ""add x0, x0, #imm"" for; /// a slight efficiency gain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:893,access,accessed,893,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['access'],['accessed']
Security,"/// Convert a TLS address reference into the correct sequence of loads; /// and calls to compute the variable's address for Darwin, and return an; /// SDValue containing the final node.; /// Darwin only has one TLS scheme which must be capable of dealing with the; /// fully general situation, in the worst case. This means:; /// + ""extern __thread"" declaration.; /// + Defined in a possibly unknown dynamic library.; ///; /// The general system is that each __thread variable has a [3 x i32] descriptor; /// which contains information used by the runtime to calculate the address. The; /// only part of this the compiler needs to know about is the first word, which; /// contains a function pointer that must be called with the address of the; /// entire descriptor in ""r0"".; ///; /// Since this descriptor may be in a different unit, in general access must; /// proceed along the usual ARM rules. A common sequence to produce is:; ///; /// movw rT1, :lower16:_var$non_lazy_ptr; /// movt rT1, :upper16:_var$non_lazy_ptr; /// ldr r0, [rT1]; /// ldr rT2, [r0]; /// blx rT2; /// [...address now in r0...]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:847,access,access,847,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['access'],['access']
Security,"/// Convert a template-argument that we parsed as a type into a template, if; /// possible. C++ permits injected-class-names to perform dual service as; /// template template arguments and as template type arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:104,inject,injected-class-names,104,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['inject'],['injected-class-names']
Security,/// Convert a value into a format suitable for passing to a runtime; /// sanitizer handler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:73,sanitiz,sanitizer,73,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['sanitiz'],['sanitizer']
Security,"/// Convert an AccessSpecifier into the corresponding DINode flag.; /// As an optimization, return 0 if the access specifier equals the; /// default for the containing type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:15,Access,AccessSpecifier,15,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,2,"['Access', 'access']","['AccessSpecifier', 'access']"
Security,/// Convert the hash code to its numerical value for use.; /*explicit*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:16,hash,hash,16,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,1,['hash'],['hash']
Security,"/// Convert to StringRef. This is only allowed when it is known this object is; /// representing a StringRef, not a hash code. Calling this function on a hash; /// code is considered an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/FunctionId.h:116,hash,hash,116,interpreter/llvm-project/llvm/include/llvm/ProfileData/FunctionId.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/FunctionId.h,2,['hash'],['hash']
Security,/// Create MemoryEffectsBase that can access any location with the given; /// ModRefInfo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ModRef.h:38,access,access,38,interpreter/llvm-project/llvm/include/llvm/Support/ModRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ModRef.h,1,['access'],['access']
Security,/// Create MemoryEffectsBase that can access only the given location with the; /// given ModRefInfo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ModRef.h:38,access,access,38,interpreter/llvm-project/llvm/include/llvm/Support/ModRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ModRef.h,1,['access'],['access']
Security,/// Create MemoryEffectsBase that can only access argument memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ModRef.h:43,access,access,43,interpreter/llvm-project/llvm/include/llvm/Support/ModRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ModRef.h,1,['access'],['access']
Security,/// Create MemoryEffectsBase that can only access inaccessible memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ModRef.h:43,access,access,43,interpreter/llvm-project/llvm/include/llvm/Support/ModRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ModRef.h,1,['access'],['access']
Security,/// Create MemoryEffectsBase that can only access inaccessible or argument; /// memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ModRef.h:43,access,access,43,interpreter/llvm-project/llvm/include/llvm/Support/ModRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ModRef.h,1,['access'],['access']
Security,"/// Create a ARM MCSubtargetInfo instance. This is exposed so Asm parser, etc.; /// do not need to go through TargetRegistry.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.h:51,expose,exposed,51,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCTargetDesc.h,1,['expose'],['exposed']
Security,/// Create a CacheCost for the loop nest rooted by \p Root.; /// The optional parameter \p TRT can be used to specify the max. distance; /// between array elements accessed in a loop so that the elements are; /// classified to have temporal reuse.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:164,access,accessed,164,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,1,['access'],['accessed']
Security,"/// Create a Hexagon MCSubtargetInfo instance. This is exposed so Asm parser,; /// etc. do not need to go through TargetRegistry.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.h:55,expose,exposed,55,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonMCTargetDesc.h,1,['expose'],['exposed']
Security,"/// Create a LoopID for transformations.; ///; /// The methods call each other in case multiple transformations are applied; /// to a loop. The transformation first to be applied will use LoopID of the; /// next transformation in its followup attribute.; ///; /// @param Attrs The loop's transformations.; /// @param LoopProperties Non-transformation properties such as debug; /// location, parallel accesses and disabled; /// transformations. These are added to the returned; /// LoopID.; /// @param HasUserTransforms [out] Set to true if the returned MDNode encodes; /// at least one transformation.; ///; /// @return A LoopID (metadata node) that can be used for the llvm.loop; /// annotation or followup-attribute.; /// @{",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGLoopInfo.h:400,access,accesses,400,interpreter/llvm-project/clang/lib/CodeGen/CGLoopInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGLoopInfo.h,1,['access'],['accesses']
Security,"/// Create a RResultPtr and set its pointer to the corresponding RAction; /// This overload is invoked by non-jitted actions, as they have access to RAction before constructing RResultPtr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx:139,access,access,139,tree/dataframe/inc/ROOT/RResultPtr.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RResultPtr.hxx,1,['access'],['access']
Security,/// Create a VFS that uses \p Collector to collect files accessed via \p; /// BaseFS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileCollector.h:57,access,accessed,57,interpreter/llvm-project/llvm/include/llvm/Support/FileCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileCollector.h,1,['access'],['accessed']
Security,"/// Create a X86 MCSubtargetInfo instance. This is exposed so Asm parser, etc.; /// do not need to go through TargetRegistry.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.h:51,expose,exposed,51,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86MCTargetDesc.h,1,['expose'],['exposed']
Security,"/// Create a call to Masked Compress Store intrinsic; /// \p Val - data to be stored,; /// \p Ptr - base pointer for the store; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:210,access,accessed,210,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,1,['access'],['accessed']
Security,/// Create a call to Masked Expand Load intrinsic; /// \p Ty - vector type to load; /// \p Ptr - base pointer for the load; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:206,access,accessed,206,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,1,['access'],['accessed']
Security,/// Create a call to a Masked Gather intrinsic.; /// \p Ty - vector type to gather; /// \p Ptrs - vector of pointers for loading; /// \p Align - alignment for one element; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:254,access,accessed,254,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,1,['access'],['accessed']
Security,/// Create a call to a Masked Load intrinsic.; /// \p Ty - vector type to load; /// \p Ptr - base pointer for the load; /// \p Alignment - alignment of the source location; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:255,access,accessed,255,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,1,['access'],['accessed']
Security,"/// Create a call to a Masked Scatter intrinsic.; /// \p Data - data to be stored,; /// \p Ptrs - the vector of pointers, where the \p Data elements should be; /// stored; /// \p Align - alignment for one element; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:296,access,accessed,296,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,1,['access'],['accessed']
Security,"/// Create a call to a Masked Store intrinsic.; /// \p Val - data to be stored,; /// \p Ptr - base pointer for the store; /// \p Alignment - alignment of the destination location; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:262,access,accessed,262,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,1,['access'],['accessed']
Security,"/// Create a code extractor for a sequence of blocks.; ///; /// Given a sequence of basic blocks where the first block in the sequence; /// dominates the rest, prepare a code extractor object for pulling this; /// sequence out into its new function. When a DominatorTree is also given,; /// extra checking and transformations are enabled. If AllowVarArgs is true,; /// vararg functions can be extracted. This is safe, if all vararg handling; /// code is extracted, including vastart. If AllowAlloca is true, then; /// extraction of blocks containing alloca instructions would be possible,; /// however code extractor won't validate whether extraction is legal.; /// Any new allocations will be placed in the AllocationBlock, unless; /// it is null, in which case it will be placed in the entry block of; /// the function from which the code is being extracted.; /// If ArgsInZeroAddressSpace param is set to true, then the aggregate; /// param pointer of the outlined function is declared in zero address; /// space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:623,validat,validate,623,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,1,['validat'],['validate']
Security,"/// Create a file descriptor to hold debugging information for a file.; /// \param Filename File name.; /// \param Directory Directory.; /// \param Checksum Optional checksum kind (e.g. CSK_MD5, CSK_SHA1, etc.); /// and value.; /// \param Source Optional source text.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DIBuilder.h:148,Checksum,Checksum,148,interpreter/llvm-project/llvm/include/llvm/IR/DIBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DIBuilder.h,2,"['Checksum', 'checksum']","['Checksum', 'checksum']"
Security,"/// Create a new RawFile that accesses the same resource. The file pointer is reset to zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/ROOT/RRawFile.hxx:30,access,accesses,30,io/io/inc/ROOT/RRawFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/ROOT/RRawFile.hxx,1,['access'],['accesses']
Security,/// Create a new object to represent a bit-field access.; ///; /// \param Addr - The base address of the bit-field sequence this; /// bit-field refers to.; /// \param Info - The information describing how to perform the bit-field; /// access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGValue.h:49,access,access,49,interpreter/llvm-project/clang/lib/CodeGen/CGValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGValue.h,2,['access'],['access']
Security,"/// Create a special GVN for PHINodes that will be used outside of; /// the region. We create a hash code based on the Canonical number of the; /// parent BasicBlock, the canonical numbering of the values stored in the; /// PHINode and the aggregate argument location. This is used to find whether; /// this PHINode type has been given a canonical numbering already. If not, we; /// assign it a value and store it for later use. The value is returned to; /// identify different output schemes for the set of regions.; ///; /// \param Region - The region that \p PN is an output for.; /// \param PN - The PHINode we are analyzing.; /// \param Blocks - The blocks for the region we are analyzing.; /// \param AggArgIdx - The argument \p PN will be stored into.; /// \returns An optional holding the assigned canonical number, or std::nullopt; /// if there is some attribute of the PHINode blocking it from being used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:96,hash,hash,96,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,1,['hash'],['hash']
Security,/// Create a synthesized property accessor stub inside the \@implementation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:34,access,accessor,34,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,1,['access'],['accessor']
Security,/// Create all simple and struct types exposed by the runtime and remember; /// the llvm::PointerTypes of them for easy access later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:39,expose,exposed,39,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,2,"['access', 'expose']","['access', 'exposed']"
Security,"/// Create an implicit MemberExpr, with no location, qualifier, template; /// arguments, and so on. Suitable only for non-static member access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:136,access,access,136,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['access'],['access']
Security,"/// Create the hash table.; ///; /// \param Buckets is the beginning of the hash table itself, which follows; /// the payload of entire structure. This is the value returned by; /// OnDiskHashTableGenerator::Emit.; ///; /// \param Base is the point from which all offsets into the structure are; /// based. This is offset 0 in the stream that was used when Emitting the; /// table.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h:15,hash,hash,15,interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h,2,['hash'],['hash']
Security,"/// Create the hash table.; ///; /// \param Buckets is the beginning of the hash table itself, which follows; /// the payload of entire structure. This is the value returned by; /// OnDiskHashTableGenerator::Emit.; ///; /// \param Payload is the beginning of the data contained in the table. This; /// is Base plus any padding or header data that was stored, ie, the offset; /// that the stream was at when calling Emit.; ///; /// \param Base is the point from which all offsets into the structure are; /// based. This is offset 0 in the stream that was used when Emitting the; /// table.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h:15,hash,hash,15,interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OnDiskHashTable.h,2,['hash'],['hash']
Security,"/// CreateTempAlloca - This creates an alloca and inserts it into the entry; /// block if \p ArraySize is nullptr, otherwise inserts it at the current; /// insertion point of the builder. The caller is responsible for setting an; /// appropriate alignment on; /// the alloca.; ///; /// \p ArraySize is the number of array elements to be allocated if it; /// is not nullptr.; ///; /// LangAS::Default is the address space of pointers to local variables and; /// temporaries, as exposed in the source language. In certain; /// configurations, this is not the same as the alloca address space, and a; /// cast is needed to lift the pointer from the alloca AS into; /// LangAS::Default. This can happen when the target uses a restricted; /// address space for the stack but the source language requires; /// LangAS::Default to be a generic address space. The latter condition is; /// common for most programming languages; OpenCL is an exception in that; /// LangAS::Default is the private address space, which naturally maps; /// to the stack.; ///; /// Because the address of a temporary is often exposed to the program in; /// various ways, this function will perform the cast. The original alloca; /// instruction is returned through \p Alloca if it is not nullptr.; ///; /// The cast is not performaed in CreateTempAllocaWithoutCast. This is; /// more efficient if the caller knows that the address will not be exposed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:477,expose,exposed,477,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,3,['expose'],['exposed']
Security,/// Creates a pair of globals used to iterate the array of offloading entries by; /// accessing the section variables provided by the linker.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/Offloading/Utility.h:86,access,accessing,86,interpreter/llvm-project/llvm/include/llvm/Frontend/Offloading/Utility.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/Offloading/Utility.h,1,['access'],['accessing']
Security,"/// Creates a replacement of the range [Offset, Offset+Length) in; /// FilePath with ReplacementText.; ///; /// \param FilePath A source file accessible via a SourceManager.; /// \param Offset The byte offset of the start of the range in the file.; /// \param Length The length of the range in bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h:142,access,accessible,142,interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Core/Replacement.h,1,['access'],['accessible']
Security,"/// Creates an uncompressed RNTuple called ""ntpl"" with three float fields, px, py, pz, with a single entry.; /// The page of px has a wrong checksum. The page of py has corrupted data. The page of pz is valid.; /// The function is backend agnostic (file, DAOS, ...).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_test.hxx:140,checksum,checksum,140,tree/ntuple/v7/test/ntuple_test.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_test.hxx,1,['checksum'],['checksum']
Security,"/// Creates sanitizer constructor function lazily. If a constructor and init; /// function already exist, this function returns it. Otherwise it calls \c; /// createSanitizerCtorAndInitFunctions. The FunctionsCreatedCallback is invoked; /// in that case, passing the new Ctor and Init function.; ///; /// \return Returns pair of pointers to constructor, and init functions; /// respectively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h:12,sanitiz,sanitizer,12,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,1,['sanitiz'],['sanitizer']
Security,"/// Creates sanitizer constructor function, and calls sanitizer's init; /// function from it.; /// \return Returns pair of pointers to constructor, and init functions; /// respectively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h:12,sanitiz,sanitizer,12,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,2,['sanitiz'],['sanitizer']
Security,/// Creates sanitizer constructor function.; /// \return Returns pointer to constructor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h:12,sanitiz,sanitizer,12,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,1,['sanitiz'],['sanitizer']
Security,/// DWARF Frame entries accessors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h:24,access,accessors,24,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h,1,['access'],['accessors']
Security,/// Deal with an access and signal if it was handled successfully.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:17,access,access,17,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['access'],['access']
Security,/// Debug info flags.; ///; /// The three accessibility flags are mutually exclusive and rolled together; /// in the first two bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h:42,access,accessibility,42,interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h,1,['access'],['accessibility']
Security,"/// DebugInfo isn't attached to string literals by default. While certain; /// aspects of debuginfo aren't useful for string literals (like a name), it's; /// nice to be able to symbolize the line and column information. This is; /// especially useful for sanitizers, as it allows symbolization of; /// heap-buffer-overflows on constant strings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:256,sanitiz,sanitizers,256,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,1,['sanitiz'],['sanitizers']
Security,"/// Decide whether or not a use of function Decl can be a call.; ///; /// \param ND the function declaration.; ///; /// \param BaseExprType the object type in a member access expression,; /// if any.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:168,access,access,168,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['access'],['access']
Security,"/// Decide whether or not a use of member function Decl can be a call.; ///; /// \param Method the function declaration.; ///; /// \param BaseExprType the object type in a member access expression,; /// if any.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:179,access,access,179,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['access'],['access']
Security,/// Declare a type to represent a global unique identifier for a global value.; /// This is a 64 bits hash that is used by PGO and ThinLTO to have a compact; /// unique way to identify a symbol.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h:102,hash,hash,102,interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,1,['hash'],['hash']
Security,"/// Declares an immutable list type \p NameTy, suitable for placement into; /// the ProgramState. This is implementing using llvm::ImmutableList.; ///; /// \code; /// State = State->add<Name>(E); // Adds to the /end/ of the list.; /// bool Present = State->contains<Name>(E);; /// NameTy List = State->get<Name>();; /// \endcode; ///; /// The macro should not be used inside namespaces, or for traits that must; /// be accessible from more than one translation unit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h:419,access,accessible,419,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h,1,['access'],['accessible']
Security,"/// Declares an immutable map of type \p NameTy, suitable for placement into; /// the ProgramState. This is implementing using llvm::ImmutableMap.; ///; /// \code; /// State = State->set<Name>(K, V);; /// const Value *V = State->get<Name>(K); // Returns NULL if not in the map.; /// State = State->remove<Name>(K);; /// NameTy Map = State->get<Name>();; /// \endcode; ///; /// The macro should not be used inside namespaces, or for traits that must; /// be accessible from more than one translation unit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h:457,access,accessible,457,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h,1,['access'],['accessible']
Security,"/// Declares an immutable set of type \p NameTy, suitable for placement into; /// the ProgramState. This is implementing using llvm::ImmutableSet.; ///; /// \code; /// State = State->add<Name>(E);; /// State = State->remove<Name>(E);; /// bool Present = State->contains<Name>(E);; /// NameTy Set = State->get<Name>();; /// \endcode; ///; /// The macro should not be used inside namespaces, or for traits that must; /// be accessible from more than one translation unit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h:422,access,accessible,422,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h,1,['access'],['accessible']
Security,"/// Dedicated, process-wide RDirectory.; ///; /// \note This is *not* thread-safe. You will need to syncronize yourself. In; /// general it's a bad idea to use a global collection in a multi-threaded; /// environment; ROOT itself does not make use of it. It is merely offered for; /// historical, process-wide object registration by name. Instead, pass a; /// pointer to the object where you need to access it - this is also much; /// faster than a lookup by name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/v7/inc/ROOT/RDirectory.hxx:400,access,access,400,core/base/v7/inc/ROOT/RDirectory.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/v7/inc/ROOT/RDirectory.hxx,1,['access'],['access']
Security,"/// Default constructor. Initializes the state to ""disabled"". The bisection; /// will be enabled by the cl::opt call-back when the command line option; /// is processed.; /// Clients should not instantiate this class directly. All access should go; /// through LLVMContext.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/OptBisect.h:231,access,access,231,interpreter/llvm-project/llvm/include/llvm/IR/OptBisect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/OptBisect.h,1,['access'],['access']
Security,"/// Default options when address sanitizer starts up in ROOT executables.; /// This is relevant when ROOT's build option `asan` is on.; /// These can be overridden / augmented by the ASAN_OPTIONS environment variable.; /// Using ASAN_OPTIONS=help=1 and starting an instrumented ROOT exectuable, available options will be printed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/SanitizerSetup.cxx:33,sanitiz,sanitizer,33,core/sanitizer/SanitizerSetup.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/SanitizerSetup.cxx,1,['sanitiz'],['sanitizer']
Security,"/// Default options when leak sanitizer starts up in ROOT exectuables.; /// This is relevant when ROOT's build options `asan` is on.; /// These can be overridden / augmented by the LSAN_OPTIONS environment variable.; /// Using LSAN_OPTIONS=help=1 and starting an instrumented ROOT exectuable, available options will be printed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/SanitizerSetup.cxx:30,sanitiz,sanitizer,30,core/sanitizer/SanitizerSetup.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/SanitizerSetup.cxx,1,['sanitiz'],['sanitizer']
Security,"/// Default suppressions for leak sanitizer in ROOT.; /// Since llvm uses allocators that do not give back memory, many leaks would show up.; /// A customisable version can be found in `$ROOTSYS/build/`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/SanitizerSetup.cxx:34,sanitiz,sanitizer,34,core/sanitizer/SanitizerSetup.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/SanitizerSetup.cxx,1,['sanitiz'],['sanitizer']
Security,/// Default taint rules are initalized with the help of a CheckerContext to; /// access the names of built-in functions like memcpy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:81,access,access,81,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,1,['access'],['access']
Security,/// Defines in which cases to put empty line before access modifiers.; /// \version 12,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:52,access,access,52,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['access'],['access']
Security,/// Defines when to put an empty line after access modifiers.; /// ``EmptyLineBeforeAccessModifier`` configuration handles the number of; /// empty lines between two access modifiers.; /// \version 13,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:44,access,access,44,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,2,['access'],['access']
Security,"/// Definitions of declarations injected also into cling.; /// NOTE: this could also stay in a header #included here and into cling, but; /// for the sake of simplicity we just redeclare them here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/demo/cling-demo.cpp:32,inject,injected,32,interpreter/cling/tools/demo/cling-demo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/demo/cling-demo.cpp,1,['inject'],['injected']
Security,/// Dependece between memory access instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:29,access,access,29,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['access'],['access']
Security,"/// Dereference the file pointer, giving access to the RFileImplBase object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx:41,access,access,41,io/io/v7/inc/ROOT/RFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx,1,['access'],['access']
Security,"/// Dereference the file pointer, giving access to the RFileImplBase object.; /// const overload.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx:41,access,access,41,io/io/v7/inc/ROOT/RFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx,1,['access'],['access']
Security,/// Describes the syntax that was used in a documentation command.; ///; /// Exact values of this enumeration are important because they used to select; /// parts of diagnostic messages. Audit diagnostics before changing or adding; /// a new value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Comment.h:187,Audit,Audit,187,interpreter/llvm-project/clang/include/clang/AST/Comment.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Comment.h,1,['Audit'],['Audit']
Security,"/// Destroy a __strong variable.; ///; /// At -O0, emit a call to store 'null' into the address;; /// instrumenting tools prefer this because the address is exposed,; /// but it's relatively cumbersome to optimize.; ///; /// At -O1 and above, just load and call objc_release.; ///; /// call void \@objc_storeStrong(i8** %addr, i8* null)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:157,expose,exposed,157,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['expose'],['exposed']
Security,"/// Determine if \p D has a reachable definition. If not, suggest a; /// declaration that should be made reachable to expose the definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:118,expose,expose,118,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['expose'],['expose']
Security,"/// Determine if \p D has a visible definition. If not, suggest a declaration; /// that should be made visible to expose the definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:114,expose,expose,114,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['expose'],['expose']
Security,/// Determine if the call can access memmory only using pointers based; /// on its arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h:30,access,access,30,interpreter/llvm-project/llvm/include/llvm/IR/Function.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h,4,['access'],['access']
Security,/// Determine if the call does not access memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:35,access,access,35,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['access'],['access']
Security,/// Determine if the call does not access or only reads memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:35,access,access,35,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['access'],['access']
Security,/// Determine if the call does not access or only writes memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:35,access,access,35,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['access'],['access']
Security,/// Determine if the function does not access memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h:39,access,access,39,interpreter/llvm-project/llvm/include/llvm/IR/Function.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h,3,['access'],['access']
Security,/// Determine if the function does not access or only reads memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h:39,access,access,39,interpreter/llvm-project/llvm/include/llvm/IR/Function.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h,3,['access'],['access']
Security,/// Determine if the function does not access or only writes memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h:39,access,access,39,interpreter/llvm-project/llvm/include/llvm/IR/Function.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h,3,['access'],['access']
Security,/// Determine if the function may only access memory that is; /// either inaccessible from the IR or pointed to by its arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h:39,access,access,39,interpreter/llvm-project/llvm/include/llvm/IR/Function.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h,4,['access'],['access']
Security,/// Determine if the function may only access memory that is; /// inaccessible from the IR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h:39,access,access,39,interpreter/llvm-project/llvm/include/llvm/IR/Function.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h,4,['access'],['access']
Security,/// Determine if the target supports unaligned memory accesses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:54,access,accesses,54,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['access'],['accesses']
Security,"/// Determine if the target supports unaligned memory accesses.; ///; /// This function returns true if the target allows unaligned memory accesses; /// of the specified type in the given address space. If true, it also returns; /// a relative speed of the unaligned memory access in the last argument by; /// reference. The higher the speed number the faster the operation comparing; /// to a number returned by another such call. This is used, for example, in; /// situations where an array copy/move/set is converted to a sequence of; /// store operations. Its use helps to ensure that such replacements don't; /// generate code that causes an alignment error (trap) on the target machine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:54,access,accesses,54,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,3,['access'],"['access', 'accesses']"
Security,"/// Determine if the target supports unaligned memory accesses.; ///; /// This function returns true if the target allows unaligned memory accesses; /// of the specified type in the given address space. If true, it also returns; /// whether the unaligned memory access is ""fast"" in the last argument by; /// reference. This is used, for example, in situations where an array; /// copy/move/set is converted to a sequence of store operations. Its use; /// helps to ensure that such replacements don't generate code that causes an; /// alignment error (trap) on the target machine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:54,access,accesses,54,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,3,['access'],"['access', 'accesses']"
Security,"/// Determine the underlying locations kinds for \p Ptr, e.g., globals or; /// arguments, and update the state and access map accordingly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:115,access,access,115,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['access'],['access']
Security,"/// Determine whether a declaration @c D of correspondent type (return; /// type for functions/methods) @c QT has any of the given attributes,; /// provided they pass necessary validation checks AND tracking the given; /// attribute is enabled.; /// Returns the object kind corresponding to the present attribute, or; /// std::nullopt, if none of the specified attributes are present.; /// Crashes if passed an attribute which is not explicitly handled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/RetainSummaryManager.h:177,validat,validation,177,interpreter/llvm-project/clang/include/clang/Analysis/RetainSummaryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/RetainSummaryManager.h,1,['validat'],['validation']
Security,"/// Determine whether a given condition (indicated by Condition) is covered; /// by an Independence Pair. Because condition IDs are not associated based; /// on their position in the expression, accessing conditions in the; /// TestVectors requires a translation from a ordinal position to actual; /// condition ID. This is done via PosToID[].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h:195,access,accessing,195,interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h,1,['access'],['accessing']
Security,"/// Determine whether one partial specialization, P1, is at least as; /// specialized than another, P2.; ///; /// \tparam TemplateLikeDecl The kind of P2, which must be a; /// TemplateDecl or {Class,Var}TemplatePartialSpecializationDecl.; /// \param T1 The injected-class-name of P1 (faked for a variable template).; /// \param T2 The injected-class-name of P2 (faked for a variable template).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:257,inject,injected-class-name,257,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,2,['inject'],['injected-class-name']
Security,"/// Determine whether the given architecture supports unaligned atomic; /// accesses. They don't have to be fast, just faster than a function; /// call and a mutex.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:76,access,accesses,76,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['access'],['accesses']
Security,"/// Determine whether the given expression is a qualified member; /// access expression, of a form that could be turned into a pointer to member; /// with the address-of operator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:70,access,access,70,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['access'],['access']
Security,"/// Determine, for two memory accesses in the same block,; /// whether \p Dominator dominates \p Dominatee.; /// \returns True if \p Dominator dominates \p Dominatee.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:30,access,accesses,30,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['access'],['accesses']
Security,"/// Determines the active Scope associated with the given declaration; /// context.; ///; /// This routine maps a declaration context to the active Scope object that; /// represents that declaration context in the parser. It is typically used; /// from ""scope-less"" code (e.g., template instantiation, lazy creation of; /// declarations) that injects a name for name-lookup purposes and, therefore,; /// must update the Scope.; ///; /// \returns The scope corresponding to the given declaraion context, or NULL; /// if no such scope is open.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:343,inject,injects,343,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['inject'],['injects']
Security,"/// Determines whether \p Range is one that can be read from. If; /// `AllowSystemHeaders` is false, a range that falls within a system header; /// fails validation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h:154,validat,validation,154,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/SourceCode.h,1,['validat'],['validation']
Security,/// Determines whether the accessed entity is accessible. Public members; /// have been weeded out by this point.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:27,access,accessed,27,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,2,['access'],"['accessed', 'accessible']"
Security,"/// Determines whether the given built-in diagnostic ID is; /// for an error that is suppressed if it occurs during C++ template; /// argument deduction.; ///; /// When an error is suppressed due to SFINAE, the template argument; /// deduction fails but no diagnostic is emitted. Certain classes of; /// errors, such as those errors that involve C++ access control,; /// are not SFINAE errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h:350,access,access,350,interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h,1,['access'],['access']
Security,"/// Determines whether this declaration represents the; /// injected class name.; ///; /// The injected class name in C++ is the name of the class that; /// appears inside the class itself. For example:; ///; /// \code; /// struct C {; /// // C is implicitly declared here as a synonym for the class name.; /// };; ///; /// C::C c; // same as ""C c;""; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:60,inject,injected,60,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,2,['inject'],['injected']
Security,"/// Determines whether this is an ""interesting"" identifier that needs a; /// full IdentifierInfo structure written into the hash table. Notably, this; /// doesn't check whether the name has macros defined; use PublicMacroIterator; /// to check that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:124,hash,hash,124,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['hash'],['hash']
Security,/// Determines whether this lookup is suppressing access control diagnostics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h:50,access,access,50,interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,1,['access'],['access']
Security,"/// Diagnose a successfully-corrected typo. Separated from the correction; /// itself to allow external validation of the result, etc.; ///; /// \param Correction The result of performing typo correction.; /// \param TypoDiag The diagnostic to produce. This will have the corrected; /// string added to it (and usually also a fixit).; /// \param PrevNote A note to use when indicating the location of the entity to; /// which we are correcting. Will have the correction string added to it.; /// \param ErrorRecovery If \c true (the default), the caller is going to; /// recover from the typo as if the corrected string had been typed.; /// In this case, \c PDiag must be an error, and we will attach a fixit; /// to it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:104,validat,validation,104,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['validat'],['validation']
Security,/// DiagnoseUnusedBackingIvarInAccessor - Issue an 'unused' warning if ivar which; /// backs the property is not used in the property's accessor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:136,access,accessor,136,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['access'],['accessor']
Security,/// Diagnoses the current set of gathered accesses. This typically; /// happens at full expression level. The set is cleared after emitting the; /// diagnostics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:42,access,accesses,42,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['access'],['accesses']
Security,/// Different styles for empty line after access modifiers.; /// ``EmptyLineBeforeAccessModifier`` configuration handles the number of; /// empty lines between two access modifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:42,access,access,42,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,2,['access'],['access']
Security,/// Different styles for empty line before access modifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:43,access,access,43,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['access'],['access']
Security,/// Directly access the live interval unions per regunit.; /// This returns an array indexed by the regunit number.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:13,access,access,13,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,1,['access'],['access']
Security,/// Disable direct TLS access through segment registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:23,access,access,23,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['access'],['access']
Security,/// Disable the sanitizers specified in \p K.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h:16,sanitiz,sanitizers,16,interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sanitizers.h,1,['sanitiz'],['sanitizers']
Security,/// Disable validation for a precompiled header and the modules it depends on.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h:12,validat,validation,12,interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,1,['validat'],['validation']
Security,/// Disable validation for all kinds.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h:12,validat,validation,12,interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,1,['validat'],['validation']
Security,/// Disable validation for module files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h:12,validat,validation,12,interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,1,['validat'],['validation']
Security,/// Disabled instance will stop reporting anything to TokenCollector.; /// This ensures that uses of the preprocessor after TokenCollector::consume(); /// is called do not access the (possibly invalid) collector instance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:172,access,access,172,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,1,['access'],['access']
Security,/// Do constant FP folding when opportunities are exposed after MIR building.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:50,expose,exposed,50,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,1,['expose'],['exposed']
Security,/// Do constant folding when opportunities are exposed after MIR building.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:47,expose,exposed,47,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,2,['expose'],['exposed']
Security,/// Do constraint-specific validation check.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:27,validat,validation,27,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,1,['validat'],['validation']
Security,/// Do the access attribute and DSOLocal propagation in combined index.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:11,access,access,11,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['access'],['access']
Security,"/// Does the system support unaligned memory access.; ///; /// MIPS32r6/MIPS64r6 require full unaligned access support but does not; /// specify which component of the system provides it. Hardware, software, and; /// hybrid implementations are all valid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:45,access,access,45,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,2,['access'],['access']
Security,/// Drive the analysis of interleaved memory accesses in the loop.; ///; /// Use this class to analyze interleaved accesses only when we can vectorize; /// a loop. Otherwise it's meaningless to do analysis as the vectorization; /// on interleaved accesses is unsafe.; ///; /// The analysis collects interleave groups and records the relationships; /// between the member and the group in a map.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:45,access,accesses,45,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,3,['access'],['accesses']
Security,"/// Drive the analysis of memory accesses in the loop; ///; /// This class is responsible for analyzing the memory accesses of a loop. It; /// collects the accesses and then its main helper the AccessAnalysis class; /// finds and categorizes the dependences in buildDependenceSets.; ///; /// For memory dependences that can be analyzed at compile time, it determines; /// whether the dependence is part of cycle inhibiting vectorization. This work; /// is delegated to the MemoryDepChecker class.; ///; /// For memory dependences that cannot be determined at compile time, it; /// generates run-time checks to prove independence. This is done by; /// AccessAnalysis::canCheckPtrAtRT and the checks are maintained by the; /// RuntimePointerCheck class.; ///; /// If pointers can wrap or can't be expressed as affine AddRec expressions by; /// ScalarEvolution, we will generate run-time checks by emitting a; /// SCEVUnionPredicate.; ///; /// Checks for both memory dependences and the SCEV predicates contained in the; /// PSE must be emitted in order for the results of this analysis to be valid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:33,access,accesses,33,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,5,"['Access', 'access']","['AccessAnalysis', 'accesses']"
Security,"/// During operand reordering, we are trying to select the operand at lane; /// that matches best with the operand at the neighboring lane. Our; /// selection is based on the type of value we are looking for. For example,; /// if the neighboring lane has a load, we need to look for a load that is; /// accessing a consecutive address. These strategies are summarized in the; /// 'ReorderingMode' enumerator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:303,access,accessing,303,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['access'],['accessing']
Security,/// ELF specific e_header flags; // It would be good if there were an MCELFAssembler class to hold this.; // ELF header flags are used both by the integrated and standalone assemblers.; // Access to the flags is necessary in cases where assembler directives affect; // which flags to be set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h:189,Access,Access,189,interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h,1,['Access'],['Access']
Security,"/// Each Scheduling boundary is associated with ready queues. It tracks the; /// current cycle in the direction of movement, and maintains the state; /// of ""hazards"" and other interlocks at the current cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:177,interlock,interlocks,177,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['interlock'],['interlocks']
Security,"/// Each Scheduling boundary is associated with ready queues. It tracks the; /// current cycle in whichever direction at has moved, and maintains the state; /// of ""hazards"" and other interlocks at the current cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:184,interlock,interlocks,184,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,1,['interlock'],['interlocks']
Security,"/// Edge connecting two vertices: vertex with smaller index is always first; /// \note: hash Edge is specialized at the bottom",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/CDTUtils.h:88,hash,hash,88,math/mathcore/src/CDT/CDTUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/CDTUtils.h,1,['hash'],['hash']
Security,/// Element access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/Math.h:12,access,access,12,interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/Math.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/Math.h,1,['access'],['access']
Security,"/// Element access. This extends the array if necessary, with empty nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:12,access,access,12,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,1,['access'],['access']
Security,/// Eliminate writes to objects that are not visible in the caller and are not; /// accessed before returning from the function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:84,access,accessed,84,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,1,['access'],['accessed']
Security,"/// Emit a check that \p Base points into an array object, which; /// we can access at index \p Index. \p Accessed should be \c false if we; /// this expression is used as an lvalue, for instance in ""&Arr[Idx]"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:77,access,access,77,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,2,"['Access', 'access']","['Accessed', 'access']"
Security,/// Emit a description of a source location in a format suitable for; /// passing to a runtime sanitizer handler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:95,sanitiz,sanitizer,95,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['sanitiz'],['sanitizer']
Security,/// Emit a description of a type in a format suitable for passing to; /// a runtime sanitizer handler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:84,sanitiz,sanitizer,84,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['sanitiz'],['sanitizer']
Security,"/// Emit a locked operation on a stack location which does not change any; /// memory location, but does involve a lock prefix. Location is chosen to be; /// a) very likely accessed only by a single thread to minimize cache traffic,; /// and b) definitely dereferenceable. Returns the new Chain result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:173,access,accessed,173,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['access'],['accessed']
Security,"/// Emit a representation of a SourceLocation for passing to a handler; /// in a sanitizer runtime library. The format for this data is:; /// \code; /// struct SourceLocation {; /// const char *Filename;; /// int32_t Line, Column;; /// };; /// \endcode; /// For an invalid SourceLocation, the Filename pointer is null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:81,sanitiz,sanitizer,81,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['sanitiz'],['sanitizer']
Security,"/// Emit a sanitization check for the given ""binary"" operation (which; /// might actually be a unary increment which has been lowered to a binary; /// operation). The check passes if all values in \p Checks (which are \c i1),; /// are \c true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:11,sanitiz,sanitization,11,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['sanitiz'],['sanitization']
Security,"/// Emit a type description suitable for use by a runtime sanitizer library. The; /// format of a type descriptor is; ///; /// \code; /// { i16 TypeKind, i16 TypeInfo }; /// \endcode; ///; /// followed by an array of i8 containing the type name. TypeKind is 0 for an; /// integer, 1 for a floating point value, and -1 for anything else.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:58,sanitiz,sanitizer,58,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['sanitiz'],['sanitizer']
