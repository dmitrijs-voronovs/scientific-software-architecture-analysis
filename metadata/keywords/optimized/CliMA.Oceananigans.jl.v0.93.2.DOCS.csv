quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Availability," 60)`. !!! note ""LatitudeLongitudeGrid topologies""; It's still possible to use `topology = (Periodic, Bounded, Bounded)` if `longitude` doesn't have 360 degrees.; But neither `latitude` nor `z` may be `Periodic` with `LatitudeLongitudeGrid`. ### Bathymetry, topography, and other irregularities. Irregular or ""complex"" domains are represented with [`ImmersedBoundaryGrid`](@ref), which combines one of the; above underlying grids with a type of immersed boundary. The immersed boundaries we support currently are. 1. [`GridFittedBottom`](@ref), which fits a one- or two-dimensional bottom height to the underlying grid, so the active part of the domain is above the bottom height.; 2. [`PartialCellBottom`](@ref Oceananigans.ImmersedBoundaries.PartialCellBottom), which is similar to [`GridFittedBottom`](@ref), except that the height of the bottommost cell is changed to conform to bottom height, limited to prevent the bottom cells from becoming too thin.; 3. [`GridFittedBoundary`](@ref), which fits a three-dimensional mask to the grid. To build an `ImmersedBoundaryGrid`, we start by building one of the three underlying grids, and then embedding a boundary into that underlying grid. ```jldoctest grids; using Oceananigans.Units. grid = RectilinearGrid(topology = (Bounded, Bounded, Bounded),; size = (20, 20, 20),; x = (-5kilometers, 5kilometers),; y = (-5kilometers, 5kilometers),; z = (0, 1kilometer)). # Height and width; H = 100meters; W = 1kilometer. mountain(x, y) = H * exp(-(x^2 + y^2) / 2W^2); mountain_grid = ImmersedBoundaryGrid(grid, GridFittedBottom(mountain)). # output; 20√ó20√ó20 ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3√ó3√ó3 halo:; ‚îú‚îÄ‚îÄ immersed_boundary: GridFittedBottom(mean(z)=6.28318, min(z)=1.58939e-8, max(z)=93.9413); ‚îú‚îÄ‚îÄ underlying_grid: 20√ó20√ó20 RectilinearGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ Bounded x ‚àà [-5000.0, 5000.0] regularly spaced with Œîx=500.0; ‚îú‚îÄ‚îÄ Bounded y ‚àà [-5000.0, 5000.0] regularly spaced wi",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:8074,mask,mask,8074,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['mask'],['mask']
Availability," A few more time-steps, and it's starting to get a little diffuse!. ```@example cpu; simulation.stop_iteration += 400; run!(simulation). compute!(Œ∂); heatmap(Œ∂, axis=(; aspect=1)); ```. ## They always cheat with too-simple ""quick"" starts. Fine, we'll re-run this code on the GPU. But we're a little greedy, so we'll also; crank up the resolution, throw in a `TimeStepWizard` to update `simulation.Œît` adaptively,; and add a passive tracer initially concentrated in the center of the domain; which will make for an even prettier figure of the final state:. ```@setup gpu; using CairoMakie; CairoMakie.activate!(type = ""png""); ```. ```@example gpu; using Oceananigans; using CairoMakie. grid = RectilinearGrid(GPU(),; size = (1024, 1024),; x = (-œÄ, œÄ),; y = (-œÄ, œÄ),; topology = (Periodic, Periodic, Flat)). model = NonhydrostaticModel(; grid, advection=WENO(), tracers=:c). Œ¥ = 0.5; c·µ¢(x, y) = exp(-(x^2 + y^2) / 2Œ¥^2); œµ(x, y) = 2rand() - 1; set!(model, u=œµ, v=œµ, c=c·µ¢). simulation = Simulation(model; Œît=1e-3, stop_time=10); conjure_time_step_wizard!(simulation, cfl=0.2, IterationInterval(10)); run!(simulation). u, v, w = model.velocities; Œ∂ = Field(‚àÇx(v) - ‚àÇy(u)); compute!(Œ∂). fig = Figure(size=(1200, 600)); axŒ∂ = Axis(fig[1, 1], aspect=1, title=""vorticity""); axc = Axis(fig[1, 2], aspect=1, title=""tracer""); heatmap!(axŒ∂, Œ∂, colormap=:balance); heatmap!(axc, model.tracers.c); current_figure(); ```. See how we did that? We passed the positional argument `GPU()` to `RectilinearGrid`.; (This only works if a GPU is available, of course, and; [CUDA.jl is configured](https://cuda.juliagpu.org/stable/installation/overview/).). ## Well, that was tantalizing. But you'll need to know a lot more to become a productive, Oceananigans-wielding computational scientist (spherical grids, forcing, boundary conditions,; turbulence closures, output writing, actually labeling your axes... ü§Ø).; It'd be best to move on to the [one-dimensional diffusion example](@ref one_dimensional_diffusion_example).; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/quick_start.md:2660,avail,available,2660,docs/src/quick_start.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/quick_start.md,1,['avail'],['available']
Availability," The constructor for `Relaxation` accepts the keyword arguments `mask`, and `target`,; which specify a `mask(x, y, z)` function that multiplies the forcing, and a `target(x, y, z)`; distribution for the quantity in question. By default, `mask` uncovered the whole domain; and `target` restores the field in question to 0. We illustrate usage of `mask` and `target` by implementing a sponge layer that relaxes; velocity fields to zero and restores temperature to a linear gradient in the bottom; 1/10th of the domain:. ```jldoctest sponge_layer; grid = RectilinearGrid(size=(1, 1, 1), x=(0, 1), y=(0, 1), z=(-1, 0)). damping_rate = 1/100 # relax fields on a 100 second time-scale; temperature_gradient = 0.001 # ‚Å∞C m‚Åª¬π; surface_temperature = 20 # ‚Å∞C (at z=0). target_temperature = LinearTarget{:z}(intercept=surface_temperature, gradient=temperature_gradient); bottom_mask = GaussianMask{:z}(center=-grid.Lz, width=grid.Lz/10). uvw_sponge = Relaxation(rate=damping_rate, mask=bottom_mask); T_sponge = Relaxation(rate=damping_rate, mask=bottom_mask, target=target_temperature). model = NonhydrostaticModel(grid=grid, forcing=(u=uvw_sponge, v=uvw_sponge, w=uvw_sponge, T=T_sponge), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S)). model.forcing.u. # output; ContinuousForcing{Nothing} at (Face, Center, Center); ‚îú‚îÄ‚îÄ func: Relaxation(rate=0.01, mask=exp(-(z + 1.0)^2 / (2 * 0.1^2)), target=0); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:u,); ```. ```jldoctest sponge_layer; model.forcing.T. # output; ContinuousForcing{Nothing} at (Center, Center, Center); ‚îú‚îÄ‚îÄ func: Relaxation(rate=0.01, mask=exp(-(z + 1.0)^2 / (2 * 0.1^2)), target=20.0 + 0.001 * z); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:T,); ```. ## `AdvectiveForcing`. `AdvectiveForcing` defines a forcing function that represents advection by; a separate or ""slip"" velocity relative to the prognostic model velocity field.; `AdvectiveForcing` is implemented with native Oceananigans advection operators,; which means that tracers",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:9716,mask,mask,9716,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,2,['mask'],['mask']
Availability," an approximation to ; the discretized momentum equation for an intermediate velocity field ``\boldsymbol{v}^\star`` ; without worrying about satisfying the incompressibility constraint. We then project ``\boldsymbol{v}^\star`` ; onto the space of divergence-free velocity fields to obtain a value for ``\boldsymbol{v}^{n+1}`` ; that satisfies continuity. For example, for the `NonhydrostaticModel`, if we ignore the background velocity fields and the; surface waves, we thus discretize the momentum equation as; ```math; \frac{\boldsymbol{v}^\star - \boldsymbol{v}^n}{\Delta t}; = - \left[ \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} \boldsymbol{v} \right]^{n+\frac{1}{2}}; - \boldsymbol{f} \times \boldsymbol{v}^{n+\frac{1}{2}}; + \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \nu \boldsymbol{\nabla} \boldsymbol{v}^{n+\frac{1}{2}} \right ); + \boldsymbol{F}_{\boldsymbol{v}}^{n+\frac{1}{2}} \, ,; ```; where the superscript ``n + \frac{1}{2}`` indicates that these terms are evaluated at time step ; ``n + \frac{1}{2}``, which we compute explicitly (see [Time-stepping section](@ref time_stepping)). The projection is then performed; ```math; \boldsymbol{v}^{n+1} = \boldsymbol{v}^\star - \Delta t \, \boldsymbol{\nabla} p^{n+1} \, ,; ```; to obtain a divergence-free velocity field ``\boldsymbol{v}^{n+1}``. Here the projection is performed by solving an elliptic; problem for the pressure ``p^{n+1}`` with the boundary condition; ```math; \boldsymbol{\hat{n}} \boldsymbol{\cdot} \boldsymbol{\nabla} p^{n+1} |_{\partial\Omega} = 0 \, .; ```. [Orszag86](@citet) and [Brown01](@citet) raise an important issue regarding these fractional step ; methods, which is that ""*while the velocity can be reliably computed to second-order accuracy ; in time and space, the pressure is typically only first-order accurate in the ``L_\infty``-norm.*"" ; The numerical boundary conditions must be carefully accounted for to ensure the second-order ; accuracy promised by the fractional step methods.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/fractional_step.md:2033,reliab,reliably,2033,docs/src/appendix/fractional_step.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/fractional_step.md,1,['reliab'],['reliably']
Availability," appropriate for; typical applications: we only do it here for illustration purposes. ```@repl checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1))). simulation = Simulation(model, Œît=1, stop_iteration=8). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=IterationInterval(5), prefix=""model_checkpoint""); ```. Again, for illustration purposes of this example, we also add another callback so we can see the iteration; of the simulation. ```@repl checkpointing; show_iteration(sim) = @info ""iteration: $(iteration(sim)); time: $(prettytime(sim.model.clock.time))""; add_callback!(simulation, show_iteration, name=:info, IterationInterval(1)); ```. Now let's run. ```@repl checkpointing; run!(simulation); ```. The default options should provide checkpoint files that are easy to restore from (in most cases).; For more advanced options and features, see [`Checkpointer`](@ref). ## Picking up a simulation from a checkpoint file. Picking up a simulation from a checkpoint requires the original script that was used to generate; the checkpoint data. Change the first instance of [`run!`](@ref) in the script to take `pickup=true`. When `pickup=true` is provided to `run!` then it finds the latest checkpoint file in the current working; directory, loads prognostic fields and their tendencies from file, resets the model clock and iteration,; to the clock time and iteration that the checkpoint corresponds to, and updates the model auxiliary state.; After that, the time-stepping loop. In this simple example, although the simulation run up to iteration 8,; the latest checkpoint is associated with iteration 5. ```@repl checkpointing; simulation.stop_iteration = 12. run!(simulation, pickup=true); ```. Use `pickup=iteration`, where `iteration` is an `Integer`, to pick up from a specific iteration.; Or, use `pickup=filepath`, where `filepath` is a string, to pickup from a specific file located; at `filepath`.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md:1760,checkpoint,checkpoint,1760,docs/src/model_setup/checkpointing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md,6,['checkpoint'],"['checkpoint', 'checkpointing']"
Availability," can also use the convenience [`add_callback!`](@ref):. ```@example checkpointing; add_callback!(simulation, show_time, name=:total_A_via_convenience, IterationInterval(2)). simulation; ```. The keyword argument `callsite` determines the moment at which the callback is executed.; By default, `callsite = TimeStepCallsite()`, indicating execution _after_ the completion of; a timestep. The other options are `callsite = TendencyCallsite()` that executes the callback; after the tendencies are computed but _before_ taking a timestep and `callsite = UpdateStateCallsite()`; that executes the callback within `update_state!`, after auxiliary variables have been computed; (for multi-stage time-steppers, `update_state!` may be called multiple times per timestep). As an example of a callback with `callsite = TendencyCallsite()` , we show below how we can; manually add to the tendency field of one of the velocity components. Here we've chosen; the `:u` field using parameters:. ```@example checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))). simulation = Simulation(model, Œît=1, stop_iteration=10). function modify_tendency!(model, params); model.timestepper.G‚Åø[params.c] .+= params.Œ¥; return nothing; end. simulation.callbacks[:modify_u] = Callback(modify_tendency!, IterationInterval(1),; callsite = TendencyCallsite(),; parameters = (c = :u, Œ¥ = 1)). run!(simulation); ```. Above there is no forcing at all, but due to the callback the ``u``-velocity is increased. ```@example checkpointing; @info model.velocities.u; ```. !!! note ""Example only for illustration purposes""; The above is a redundant example since it could be implemented better with a simple forcing function.; We include it here though for illustration purposes of how one can use callbacks. ## Functions. Callback functions can only take one or two parameters `sim` - a simulation, or `model` for state callbacks, and optionally may also accept a NamedTuple of p",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/callbacks.md:1742,checkpoint,checkpointing,1742,docs/src/model_setup/callbacks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/callbacks.md,1,['checkpoint'],['checkpointing']
Availability," shown in the second example. The following code constructs a model in which all components; of the velocity field are damped to zero everywhere on a time-scale of 1000 seconds, or ~17 minutes:. ```jldoctest; damping = Relaxation(rate = 1/1000). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = NonhydrostaticModel(grid=grid, forcing=(u=damping, v=damping, w=damping)). model.forcing.w. # output; ContinuousForcing{Nothing} at (Center, Center, Face); ‚îú‚îÄ‚îÄ func: Relaxation(rate=0.001, mask=1, target=0); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:w,); ```. The constructor for `Relaxation` accepts the keyword arguments `mask`, and `target`,; which specify a `mask(x, y, z)` function that multiplies the forcing, and a `target(x, y, z)`; distribution for the quantity in question. By default, `mask` uncovered the whole domain; and `target` restores the field in question to 0. We illustrate usage of `mask` and `target` by implementing a sponge layer that relaxes; velocity fields to zero and restores temperature to a linear gradient in the bottom; 1/10th of the domain:. ```jldoctest sponge_layer; grid = RectilinearGrid(size=(1, 1, 1), x=(0, 1), y=(0, 1), z=(-1, 0)). damping_rate = 1/100 # relax fields on a 100 second time-scale; temperature_gradient = 0.001 # ‚Å∞C m‚Åª¬π; surface_temperature = 20 # ‚Å∞C (at z=0). target_temperature = LinearTarget{:z}(intercept=surface_temperature, gradient=temperature_gradient); bottom_mask = GaussianMask{:z}(center=-grid.Lz, width=grid.Lz/10). uvw_sponge = Relaxation(rate=damping_rate, mask=bottom_mask); T_sponge = Relaxation(rate=damping_rate, mask=bottom_mask, target=target_temperature). model = NonhydrostaticModel(grid=grid, forcing=(u=uvw_sponge, v=uvw_sponge, w=uvw_sponge, T=T_sponge), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S)). model.forcing.u. # output; ContinuousForcing{Nothing} at (Face, Center, Center); ‚îú‚îÄ‚îÄ func: Relaxation(rate=0.01, mask=exp(-(z + 1.0)^2 / (2 * 0.1^2)), target=0); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ f",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:9092,mask,mask,9092,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['mask'],['mask']
Availability," simulation; time to files of the form `model_checkpoint_iteration12500.jld2` where `12500` is the iteration; number (automatically filled in). Here's an example where we checkpoint every 5 iterations. This is far more often than appropriate for; typical applications: we only do it here for illustration purposes. ```@repl checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1))). simulation = Simulation(model, Œît=1, stop_iteration=8). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=IterationInterval(5), prefix=""model_checkpoint""); ```. Again, for illustration purposes of this example, we also add another callback so we can see the iteration; of the simulation. ```@repl checkpointing; show_iteration(sim) = @info ""iteration: $(iteration(sim)); time: $(prettytime(sim.model.clock.time))""; add_callback!(simulation, show_iteration, name=:info, IterationInterval(1)); ```. Now let's run. ```@repl checkpointing; run!(simulation); ```. The default options should provide checkpoint files that are easy to restore from (in most cases).; For more advanced options and features, see [`Checkpointer`](@ref). ## Picking up a simulation from a checkpoint file. Picking up a simulation from a checkpoint requires the original script that was used to generate; the checkpoint data. Change the first instance of [`run!`](@ref) in the script to take `pickup=true`. When `pickup=true` is provided to `run!` then it finds the latest checkpoint file in the current working; directory, loads prognostic fields and their tendencies from file, resets the model clock and iteration,; to the clock time and iteration that the checkpoint corresponds to, and updates the model auxiliary state.; After that, the time-stepping loop. In this simple example, although the simulation run up to iteration 8,; the latest checkpoint is associated with iteration 5. ```@repl checkpointing; simulation.stop_iteration = 12. run!(simulation, pi",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md:1472,checkpoint,checkpointing,1472,docs/src/model_setup/checkpointing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md,1,['checkpoint'],['checkpointing']
Availability,"# Boundary conditions. Users may impose *no-penetration*, *flux*, *gradient* (Neumann), and; *value* (Dirichlet) boundary conditions in bounded, non-periodic directions.; Note that the only boundary condition available for a velocity field normal to the bounded; direction is *no-penetration*. ## Flux boundary conditions. A flux boundary condition prescribes flux of a quantity normal to the boundary.; For a tracer ``c`` this corresponds to prescribing; ```math; q_c \, |_b \equiv \boldsymbol{q}_c \boldsymbol{\cdot} \hat{\boldsymbol{n}} \, |_{\partial \Omega_b} \, ,; ```; where ``\partial \Omega_b`` is an external boundary. ## Gradient (Neumann) boundary condition. A gradient boundary condition prescribes the gradient of a field normal to the boundary.; For a tracer ``c`` this prescribes; ```math; \gamma \equiv \boldsymbol{\nabla} c \boldsymbol{\cdot} \hat{\boldsymbol{n}} \, |_{\partial \Omega_b} \, .; ```. ## Value (Dirichlet) boundary condition. A value boundary condition prescribes the value of a field on a boundary; for a tracer this; prescribes; ```math; c_b \equiv c \, |_{\partial \Omega_b} \, .; ```. ## No penetration boundary condition. A no penetration boundary condition prescribes the velocity component normal to a boundary to be 0,; so that; ```math; \boldsymbol{\hat{n}} \boldsymbol{\cdot} \boldsymbol{v} \, |_{\partial \Omega_b} = 0 \, .; ```; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/boundary_conditions.md:209,avail,available,209,docs/src/physics/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/boundary_conditions.md,1,['avail'],['available']
Availability,"# Callbacks. A [`Callback`](@ref) can be used to execute an arbitrary user-defined function on the; simulation at user-defined times. For example, we can specify a callback which displays the run time every 2 iterations:; ```@meta; DocTestSetup = quote; using Oceananigans; end; ```. ```@example checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))). simulation = Simulation(model, Œît=1, stop_iteration=10). show_time(sim) = @info ""Time is $(prettytime(sim.model.clock.time))"". simulation.callbacks[:total_A] = Callback(show_time, IterationInterval(2)). simulation; ```. Now when simulation runs the simulation the callback is called. ```@example checkpointing; run!(simulation); ```. We can also use the convenience [`add_callback!`](@ref):. ```@example checkpointing; add_callback!(simulation, show_time, name=:total_A_via_convenience, IterationInterval(2)). simulation; ```. The keyword argument `callsite` determines the moment at which the callback is executed.; By default, `callsite = TimeStepCallsite()`, indicating execution _after_ the completion of; a timestep. The other options are `callsite = TendencyCallsite()` that executes the callback; after the tendencies are computed but _before_ taking a timestep and `callsite = UpdateStateCallsite()`; that executes the callback within `update_state!`, after auxiliary variables have been computed; (for multi-stage time-steppers, `update_state!` may be called multiple times per timestep). As an example of a callback with `callsite = TendencyCallsite()` , we show below how we can; manually add to the tendency field of one of the velocity components. Here we've chosen; the `:u` field using parameters:. ```@example checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))). simulation = Simulation(model, Œît=1, stop_iteration=10). function modify_tendency!(model, params); model.timestepper.G‚Åø[params.c] .+= param",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/callbacks.md:296,checkpoint,checkpointing,296,docs/src/model_setup/callbacks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/callbacks.md,3,['checkpoint'],['checkpointing']
Availability,"# Coriolis. The Coriolis option determines whether the fluid experiences the effect of the Coriolis force, or rotation. Currently; three options are available: no rotation, ``f``-plane, and ``\beta``-plane. !!! info ""Coriolis vs. rotation""; If you are wondering why this option is called ""Coriolis"" it is because rotational effects could include the; Coriolis and centripetal forces, both of which arise in non-inertial reference frames. But here the model only; considers the Coriolis force. ## No rotation. By default there is no rotation. This can be made explicit by passing `coriolis = nothing` to a model constructor. ## Traditional ``f``-plane. To set up an ``f``-plane with, for example, Coriolis parameter ``f = 10^{-4} \text{s}^{-1}``. ```@meta; DocTestSetup = quote; using Oceananigans; end; ```. ```jldoctest; julia> coriolis = FPlane(f=1e-4); FPlane{Float64}(f=0.0001); ```. An ``f``-plane can also be specified at some latitude on a spherical planet with a planetary rotation rate. For example,; to specify an ``f``-plane at a latitude of ``\varphi = 45¬∞\text{N}`` on Earth which has a rotation rate of; ``\Omega = 7.292115 \times 10^{-5} \text{s}^{-1}``. ```jldoctest; julia> coriolis = FPlane(rotation_rate=7.292115e-5, latitude=45); FPlane{Float64}(f=0.000103126); ```. in which case the value of ``f`` is given by ``2\Omega\sin\varphi``. ## Coriolis term for constant rotation in a Cartesian coordinate system. One can use `ConstantCartesianCoriolis` to set up a Coriolis acceleration term where the Coriolis parameter; is constant and the rotation axis is arbitrary. For example, with; ``\boldsymbol{f} = (0, f_y, f_z) = (0, 2, 1) \times 10^{-4} \text{s}^{-1}``,. ```jldoctest; julia> coriolis = ConstantCartesianCoriolis(fx=0, fy=2e-4, fz=1e-4); ConstantCartesianCoriolis{Float64}: fx = 0.00e+00, fy = 2.00e-04, fz = 1.00e-04; ```. Or alternatively, the same result can be achieved by specifying the magnitude of the Coriolis; frequency `f` and the `rotation_axis`. So another way ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/coriolis.md:149,avail,available,149,docs/src/model_setup/coriolis.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/coriolis.md,1,['avail'],['available']
Availability,"# Oceananigans.jl performance benchmarks. This directory contains scripts and modules for benchmarking various features of Oceananigans. To instantiate the benchmarks environment, run. ```; julia -e 'using Pkg; Pkg.activate(pwd()); Pkg.instantiate(); Pkg.develop(PackageSpec(path=joinpath(@__DIR__, "".."")))'; ```. Once the environment has been instantiated, benchmarks can be run via, e.g. ```; julia --project benchmark_nonhydrostatic_model.jl; ```. Most scripts benchmark one feature (e.g. advection schemes, arbitrary tracers). If your machine contains a CUDA-compatible GPU, benchmarks will also run on the GPU. Tables with benchmark results will be printed (and each table will also be saved to an HTML file). ## Distributed benchmarks. Run distributed benchmarks by running the launcher scripts for either the shallow water model: `distributed_shallow_water_model.jl` or the nonhydrostatic model: `distributed_nonhydrostatic_model.jl`. Change settings within the scripts to toggle between strong or weak scaling and threaded or MPI architecture. The single and serial scripts executed by the launcher scripts can also be executed manually from the command line with the appropriate arguments. ## Measuring performance regression. Running the `benchmark_regression.jl` script will run the nonhydrostatic model tests on the current branch and on the main branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression. ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/benchmark/README.md:1438,down,down,1438,benchmark/README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/benchmark/README.md,1,['down'],['down']
Availability,"# Oceananigans.jl. *üåä Fast and friendly fluid dynamics on CPUs and GPUs.*. Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic; and hydrostatic Boussinesq equations on CPUs and GPUs.; It runs on GPUs (wow, fast!), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans is written in Julia by the [Climate Modeling Alliance](https://clima.caltech.edu); and heroic external collaborators. ## Quick install. Oceananigans is a [registered Julia package](https://julialang.org/packages/). So to install it,. 1. [Download Julia](https://julialang.org/downloads/). 2. Launch Julia and type. ```julia; julia> using Pkg. julia> Pkg.add(""Oceananigans""); ```. !!! compat ""Julia 1.9 is required""; Oceananigans requires Julia 1.9 or later. If you're [new to Julia](https://docs.julialang.org/en/v1/manual/getting-started/) and its [wonderful `Pkg` manager](https://docs.julialang.org/en/v1/stdlib/Pkg/), the [Oceananigans wiki](https://github.com/CliMA/Oceananigans.jl/wiki) provides [more detailed installation instructions](https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans). ## The Oceananigans ""knowledge base"". It's _deep_ and includes:. * This documentation, which provides; * example Oceananigans scripts,; * tutorials that describe key Oceananigans objects and functions,; * explanations of Oceananigans finite-volume-based numerical methods,; * details of the dynamical equations solved by Oceananigans models, and; * a library documenting all user-facing Oceananigans objects and functions.; * [Discussions on the Oceananigans github](https://github.com/CliMA/Oceananigans.jl/discussions), covering topics like; * [""Computational science""](https://github.com/CliMA/Oceananigans.jl/discussions/categories/computational-science), or how to science and set up numeric",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md:738,down,downloads,738,docs/src/index.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md,1,['down'],['downloads']
Availability,"# Output writers. `AbstractOutputWriter`s save data to disk.; `Oceananigans` provides three ways to write output:. 1. [`NetCDFOutputWriter`](@ref) for output of arrays and scalars that uses [NCDatasets.jl](https://github.com/Alexander-Barth/NCDatasets.jl); 2. [`JLD2OutputWriter`](@ref) for arbitrary julia data structures that uses [JLD2.jl](https://github.com/JuliaIO/JLD2.jl); 3. [`Checkpointer`](@ref) that automatically saves as much model data as possible, using [JLD2.jl](https://github.com/JuliaIO/JLD2.jl). The `Checkpointer` is discussed in detail on a separate [section](@ref checkpointing) of the documentation. ## Basic usage. [`NetCDFOutputWriter`](@ref) and [`JLD2OutputWriter`](@ref) require four inputs:. 1. The `model` from which output data is sourced (required to initialize the `OutputWriter`).; 2. A key-value pairing of output ""names"" and ""output"" objects. `JLD2OutputWriter` accepts `NamedTuple`s and `Dict`s;; `NetCDFOutputWriter` accepts `Dict`s with string-valued keys. Output objects are either `AbstractField`s or; functions that return data when called via `func(model)`.; 3. A `schedule` on which output is written. `TimeInterval`, `IterationInterval`, `WallTimeInterval` schedule; periodic output according to the simulation time, simulation interval, or ""wall time"" (the physical time; according to a clock on your wall). A fourth `schedule` called `AveragedTimeInterval` specifies; periodic output that is time-averaged over a `window` prior to being written.; 4. The `filename` and `dir`ectory. Other important keyword arguments are. * `indices` for outputting subregions, two- and one-dimensional slices of fields. Specifies the indices to write to disk with a `Tuple` of `Colon`, `UnitRange`,or `Int` elements. For example, `indices = (:, :, 1)` implies outputing ``x-y``-slices of the bottom-most index (`k=1`). Defaults to `(:, :, :)`, i.e., ""all indices"".; * `with_halos :: Boolean`: whether to output the halos (`true`) or only the interior points (`false`; de",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md:587,checkpoint,checkpointing,587,docs/src/model_setup/output_writers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md,1,['checkpoint'],['checkpointing']
Availability,"# [Checkpointing](@id checkpointing). A [`Checkpointer`](@ref) can be used to serialize the entire model state to a file from which the model; can be restored at any time. This is useful if you'd like to periodically checkpoint when running; long simulations in case of crashes or hitting cluster time limits, but also if you'd like to restore; from a checkpoint and try out multiple scenarios. For example, to periodically checkpoint the model state to disk every 1,000,000 seconds of simulation; time to files of the form `model_checkpoint_iteration12500.jld2` where `12500` is the iteration; number (automatically filled in). Here's an example where we checkpoint every 5 iterations. This is far more often than appropriate for; typical applications: we only do it here for illustration purposes. ```@repl checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1))). simulation = Simulation(model, Œît=1, stop_iteration=8). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=IterationInterval(5), prefix=""model_checkpoint""); ```. Again, for illustration purposes of this example, we also add another callback so we can see the iteration; of the simulation. ```@repl checkpointing; show_iteration(sim) = @info ""iteration: $(iteration(sim)); time: $(prettytime(sim.model.clock.time))""; add_callback!(simulation, show_iteration, name=:info, IterationInterval(1)); ```. Now let's run. ```@repl checkpointing; run!(simulation); ```. The default options should provide checkpoint files that are easy to restore from (in most cases).; For more advanced options and features, see [`Checkpointer`](@ref). ## Picking up a simulation from a checkpoint file. Picking up a simulation from a checkpoint requires the original script that was used to generate; the checkpoint data. Change the first instance of [`run!`](@ref) in the script to take `pickup=true`. When `pickup=true` is provided to `run!` then it finds the latest checkp",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md:22,checkpoint,checkpointing,22,docs/src/model_setup/checkpointing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md,6,['checkpoint'],"['checkpoint', 'checkpointing']"
Availability,"# [Turbulence closures](@id numerical_closures). To truly simulate and resolve turbulence at high Reynolds number (so basically all interesting flows) would require; you resolve all motions down to the [Kolmogorov41](@citet) length scale ``\eta = (\nu^3 / \varepsilon)^{1/4}`` where; ``\nu`` is the kinematic viscosity and ``\varepsilon`` the average rate of dissipation of turbulence kinetic energy per; unit mass. As pointed out way back by [Corrsin61](@citet), to run a simulation on a horizontal domain about 10 times the size of an; ""average eddy"" with 100 vertical levels and where the grid spacing is given by ``\eta`` would require the computer to; store on the order of ``10^{14}`` variables.[^1] This is still impractical today, although may be within; reach in less than a decade. He ends by suggesting the use of an analog rather digital computer---a tank of water. [^1]: And even then, ``\eta`` gives the *maximum* allowable grid spacing. There is significant flow structure; smaller than ``\eta``. To have any hope of simulating high Reynolds number flows we need some way of resolving the sub-grid scale motions.[^2]. [^2]: In reality there is no need to resolve all motions down to the Kolmogorov length scale to achieve; acceptable accuracy. Perhaps good results can be achieved if 80\% of the kinetic energy is resolved; (¬ß13) [Pope00](@cite). ## Reynolds-averaged Navier‚ÄìStokes equations. Following [Reynolds1895](@citet), we can decompose flow variables such as velocity ``\boldsymbol{v}`` into the mean component; ``\overline{\boldsymbol{v}}`` and the fluctuating component ``\boldsymbol{v}^\prime`` so that ``\boldsymbol{v} = \overline{\boldsymbol{v}} + \boldsymbol{v}^\prime``; [see ¬ß4 of [Pope00](@citet) for a modern discussion]. Expressing the Navier-Stokes equations in tensor notation; ```math; \begin{align}; \partial_i v_i &= 0 \, ,\\; \partial_t v_i + v_j \partial_j v_i &= f_i - \alpha\partial_i p + \nu \partial_j \partial_j v_i \, ,; \end{align}; ```; where ``\alpha ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md:190,down,down,190,docs/src/numerical_implementation/turbulence_closures.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md,1,['down'],['down']
Availability,", 1), z=(-1, 0)). damping_rate = 1/100 # relax fields on a 100 second time-scale; temperature_gradient = 0.001 # ‚Å∞C m‚Åª¬π; surface_temperature = 20 # ‚Å∞C (at z=0). target_temperature = LinearTarget{:z}(intercept=surface_temperature, gradient=temperature_gradient); bottom_mask = GaussianMask{:z}(center=-grid.Lz, width=grid.Lz/10). uvw_sponge = Relaxation(rate=damping_rate, mask=bottom_mask); T_sponge = Relaxation(rate=damping_rate, mask=bottom_mask, target=target_temperature). model = NonhydrostaticModel(grid=grid, forcing=(u=uvw_sponge, v=uvw_sponge, w=uvw_sponge, T=T_sponge), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S)). model.forcing.u. # output; ContinuousForcing{Nothing} at (Face, Center, Center); ‚îú‚îÄ‚îÄ func: Relaxation(rate=0.01, mask=exp(-(z + 1.0)^2 / (2 * 0.1^2)), target=0); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:u,); ```. ```jldoctest sponge_layer; model.forcing.T. # output; ContinuousForcing{Nothing} at (Center, Center, Center); ‚îú‚îÄ‚îÄ func: Relaxation(rate=0.01, mask=exp(-(z + 1.0)^2 / (2 * 0.1^2)), target=20.0 + 0.001 * z); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:T,); ```. ## `AdvectiveForcing`. `AdvectiveForcing` defines a forcing function that represents advection by; a separate or ""slip"" velocity relative to the prognostic model velocity field.; `AdvectiveForcing` is implemented with native Oceananigans advection operators,; which means that tracers advected by the ""flux form"" advection term; ``ùõÅ‚ãÖùêÆ_{\rm slip} c``. Caution is advised when ``ùêÆ_{\rm slip}`` is not divergence free. As an example, consider a model for sediment settling at a constant rate:. ```jldoctest; using Oceananigans. r_sediment = 1e-4 # [m] ""Fine sand""; œÅ_sediment = 1200 # kg m‚Åª¬≥; œÅ_ocean = 1026 # kg m‚Åª¬≥; Œîb = 9.81 * (œÅ_ocean - œÅ_sediment) / œÅ_ocean # m s‚Åª¬≤; ŒΩ_molecular = 1.05e-6 # m¬≤ s‚Åª¬π; w_sediment = 2/9 * Œîb / ŒΩ_molecular * r_sediment^2 # m s‚Åª¬π. sinking = AdvectiveForcing(w=w_sediment). # output; AdvectiveForcing:; ‚îú‚îÄ‚îÄ u: ZeroField{Int64}; ‚îú‚îÄ‚îÄ v: ZeroField{Int64}; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:10338,mask,mask,10338,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['mask'],['mask']
Availability,"- \xi) \sin y \, ,; ```; which satisfies the boundary conditions ``u_y |_{y=0} = u_y |_{y=\pi} = 0`` and; ``v |_{y=0} = v |_{y=\pi} = 0``. The vorticity forcing is; ```math; F_{\omega} = - 2 \xi^\prime f_x \sin y + 4 f \sin y \, ,; ```; which implies that; ```math; F_v = - 2 \xi^\prime f_x \cos y + 4 f \cos y \, ,; ```; and ``F_v = \tfrac{1}{2} \sin 2 y``. ## Forced, fixed-slip flow. A forced flow satisfying ""fixed-slip"" boundary conditions at ``y=0`` and ``y=1`` has; the streamfunction; ```math; \psi(x, y, t) = - \cos [x - \xi(t)] (y^3 - y^2) \, ,; ```; and thus ``g(y) = y^3 - y^2``. The velocity field ``(u, v)`` is; ```math; u = f (3y^2 - 2 y) \, , \quad \text{and} \quad v = - f_x (y^3 - y^2) \, ,; ```; which satisfies the boundary conditions; ```math; u |_{y=0} = 0 \, , \quad u |_{y=1} = f \, , \quad \text{and} \quad v |_{y=0} = v |_{y=1} = 0 \, .; ```; The vorticity forcing is; ```math; F_{\omega} = - \xi^\prime f_x (y^3 - y^2 - 6y + 2) - f f_x (12 y^3 - 12 y^2 + 4 y) + f (y^3 - y^2 - 12 y + 4) \, ,; ```; which implies that; ```math; F_v = \xi^\prime f_x (\tfrac{1}{4} y^4 - \tfrac{1}{3} y^3 - 3 y^2 + 2y); + f f_x (3 y^4 - 4 y^3 + 2y^2 ) ; - f (\tfrac{1}{4} y^4 - \tfrac{1}{3} y^3 - 6 y^2 + 4 y) \, ,; ```; and; ```math; F_v = 3 y^5 - 5 y^4 + 2y^3 \, .; ```. We set up the problem in the same manner as the forced, free-slip problem above. Note that we ; also must the no-slip boundary condition ``u |_{y=0} = 0`` and the time-dependent fixed-slip ; condition ``u |_{y=1} = f``. As for the free-slip problem, we find that the error between the ; numerical and analytical solutions decreases with ``1 / N_x^2 \sim \Delta x^2``, where ``N_x``; is the number of grid points and ``\Delta x`` is the spatial resolution:. ![Forced fixed slip convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/forced_fixed_slip_convergence.png). The convergence tests are performed using both ``y`` and ``z`` as the bounded direction.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md:10141,error,error,10141,docs/src/appendix/convergence_tests.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md,1,['error'],['error']
Availability,". To explain how flux boundary conditions are imposed ; in `Oceananigans.jl`, we note that the average of the tracer conservation equation over a finite ; volume yields; ```math; \begin{equation}; \label{eq:dc/dt}; \partial_t c_{i, j, k} = - \frac{1}{V_{i, j, k}} \oint_{\partial \Omega_{i, j, k}} (\boldsymbol{v} c + \boldsymbol{q}_c) ; \boldsymbol{\cdot} \hat{\boldsymbol{n}} \, \mathrm{d} S; + \frac{1}{V_{i, j, k}} \int_{V_{i, j, k}} F_c \, \mathrm{d} V \, ,; \end{equation}; ```; where the surface integral over ``\partial \Omega_{i, j, k}`` averages the flux of ``c`` across ; the six faces of the finite volume. The right-hand-side of \eqref{eq:dc/dt} above is denoted as ; ``G_c |_{i, j, k}``. An external boundary of a finite volume is associated with a no-penetration condition such that; ``\hat{\boldsymbol{n}} \boldsymbol{\cdot} \boldsymbol{v} \, |_{\partial \Omega_b} = 0``, where ; ``\hat{\boldsymbol{n}}`` is the vector normal to ``\partial \Omega_b``. Furthermore, the closures ; currently available in `Oceananigans.jl` have the property that ``\boldsymbol{q}_c \propto \boldsymbol{\nabla} c``.; Thus setting ``\hat{\boldsymbol{n}} \boldsymbol{\cdot} \boldsymbol{\nabla} c \, |_{\partial \Omega_b} = 0`` ; on the external boundary implies that the total flux of ``c`` across the external boundary is; ```math; \begin{equation}; \hat{\boldsymbol{n}} \boldsymbol{\cdot} \left ( \boldsymbol{v} c + \boldsymbol{q}_c \right ) |_{\partial \Omega_b} = 0 \, .; \end{equation}; ```; `Oceananigans.jl` exploits this fact to define algorithm that prescribe fluxes across external ; boundaries ``\partial \Omega_b``:. 1. Impose a constant gradient ``\hat{\boldsymbol{n}} \boldsymbol{\cdot} \boldsymbol{\nabla} c ; \, |_{\partial \Omega_b} = 0`` across external boundaries via using halo points (similar ; to \eqref{eq:gradient-bc}), which ensures that the evaluation of ``G_c`` in boundary-adjacent; cells does not include fluxes across the external boundary, and;; 2. Add the prescribed flux to",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md:4394,avail,available,4394,docs/src/numerical_implementation/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md,1,['avail'],['available']
Availability,".com/CliMA/Oceananigans.jl/wiki/Productive-Oceananigans-workflows-and-Julia-environments).; * [Issues](https://github.com/CliMA/Oceananigans.jl/issues) and [pull requests](https://github.com/CliMA/Oceananigans.jl/pulls) also contain lots of information about problems we've found, solutions we're trying to implement, and dreams we're dreaming to make tomorrow better üåà. ## Getting in touch. Whether you need help getting started with Oceananigans, found a bug, want Oceananigans to be more awesome, or just want to chat about computational oceanography, you've got a few options for getting in touch:. * [Start a discussion](https://github.com/CliMA/Oceananigans.jl/discussions). This is great for general questions about numerics, science, experimental or under-documented features, and for getting help setting up a neat new numerical experiment.; * [Open an issue](https://github.com/CliMA/Oceananigans.jl/issues). Issues are best if you think the Oceananigans source code needs attention: a bug, a sign error (üò±), an important missing feature, or a typo in this documentation üëÄ.; * Sign up for the [Julia Slack](https://julialang.org/slack/) and join the `#oceananigans` channel because we love to chat. ## Citing. If you use Oceananigans as part of your research, teaching, or other activities, we would be grateful if you could; cite our work and mention Oceananigans by name. ```bibtex; @article{OceananigansJOSS,; doi = {10.21105/joss.02018},; url = {https://doi.org/10.21105/joss.02018},; year = {2020},; publisher = {The Open Journal},; volume = {5},; number = {53},; pages = {2018},; author = {Ali Ramadhan and Gregory LeClaire Wagner and Chris Hill and Jean-Michel Campin and Valentin Churavy and Tim Besard and Andre Souza and Alan Edelman and Raffaele Ferrari and John Marshall},; title = {Oceananigans.jl: Fast and friendly geophysical fluid dynamics on GPUs},; journal = {Journal of Open Source Software}; }; ```. ## Papers and preprints using Oceananigans. If you have work using Oce",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md:3812,error,error,3812,docs/src/index.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md,1,['error'],['error']
Availability,"= (0, 1kilometer)). H = 100meters; W = 1kilometer. mountain(x, y) = H * exp(-(x^2 + y^2) / 2W^2); mountain_grid = ImmersedBoundaryGrid(grid, GridFittedBottom(mountain)); ```. ```@example grids; using CairoMakie. h = mountain_grid.immersed_boundary.bottom_height. fig = Figure(size=(600, 600)); ax = Axis(fig[2, 1], xlabel=""x (m)"", ylabel=""y (m)"", aspect=1); hm = heatmap!(ax, h); Colorbar(fig[1, 1], hm, vertical=false, label=""Bottom height (m)""). current_figure(); ```. ## Once more with feeling. In summary, making a grid requires . * The machine architecture, or whether data is stored on the CPU, GPU, or distributed across multiple devices or nodes.; * Information about the domain geometry. Domains can take a variety of shapes, including; - lines (one-dimensional),; - rectangles (two-dimensional),; - boxes (three-dimensional),; - sectors of a thin spherical shells (two- or three-dimensional).; Irregular domains -- such as domains that include bathymetry or topography -- are represented by using a masking technique to ""immerse"" an irregular boundary within an ""underlying"" regular grid. Part of specifying the shape of the domain also requires specifying the nature of each dimension, which may be; - [`Periodic`](@ref), which means that the dimension circles back onto itself: information leaving the left side of the domain re-enters on the right.; - [`Bounded`](@ref), which means that the two sides of the dimension are either impenetrable (solid walls), or ""open"", representing a specified external state.; - [`Flat`](@ref), which means nothing can vary in that dimension, reducing the overall dimensionality of the grid.; * Defining the number of cells that divide each dimension. The number of cells, with or without explicit specification of the cell interfaces, determines the spatial resolution of the grid.; * The representation of floating point numbers, which can be single-precision (`Float32`) or double precision (`Float64`). Let's dive into each of these options in more ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:10479,mask,masking,10479,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['mask'],['masking']
Availability,"Float64}; ‚îú‚îÄ‚îÄ func: u_forcing_func (generic function with 1 method); ‚îî‚îÄ‚îÄ parameters: 0.001; ```. The annotation `@inbounds` is crucial for performance when accessing array indices; of the fields in `model_fields`. ## `Relaxation`. `Relaxation` defines a special forcing function that restores a field at a specified `rate` to; a `target` distribution, within a region uncovered by a `mask`ing function.; `Relaxation` is useful for implementing sponge layers, as shown in the second example. The following code constructs a model in which all components; of the velocity field are damped to zero everywhere on a time-scale of 1000 seconds, or ~17 minutes:. ```jldoctest; damping = Relaxation(rate = 1/1000). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = NonhydrostaticModel(grid=grid, forcing=(u=damping, v=damping, w=damping)). model.forcing.w. # output; ContinuousForcing{Nothing} at (Center, Center, Face); ‚îú‚îÄ‚îÄ func: Relaxation(rate=0.001, mask=1, target=0); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:w,); ```. The constructor for `Relaxation` accepts the keyword arguments `mask`, and `target`,; which specify a `mask(x, y, z)` function that multiplies the forcing, and a `target(x, y, z)`; distribution for the quantity in question. By default, `mask` uncovered the whole domain; and `target` restores the field in question to 0. We illustrate usage of `mask` and `target` by implementing a sponge layer that relaxes; velocity fields to zero and restores temperature to a linear gradient in the bottom; 1/10th of the domain:. ```jldoctest sponge_layer; grid = RectilinearGrid(size=(1, 1, 1), x=(0, 1), y=(0, 1), z=(-1, 0)). damping_rate = 1/100 # relax fields on a 100 second time-scale; temperature_gradient = 0.001 # ‚Å∞C m‚Åª¬π; surface_temperature = 20 # ‚Å∞C (at z=0). target_temperature = LinearTarget{:z}(intercept=surface_temperature, gradient=temperature_gradient); bottom_mask = GaussianMask{:z}(center=-grid.Lz, width=grid.Lz/10). uvw_sponge = Relaxation(rate=da",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:8667,mask,mask,8667,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['mask'],['mask']
Availability,"X}^- \right); \right\rbrace \, ,; ```; where ``\tilde{X} = \text{FFT}(X^\prime)`` and ``\tilde{X}^-`` indicates that ``\tilde{X}`` is indexed in reverse. ### 2D fast inverse cosine transform; The inverse can be computed using; ```math; Y_{k_1, k_2} = \text{IDCT}(X_{n_1, n_2}) =; \frac{1}{4} \text{Re} \left\lbrace; \omega_{4N_1}^{-k} \omega_{4N_2}^{-k}; \left( \tilde{X} - M_1 M_2 \tilde{X}^{--} \right); - \mathrm{i} \left( M_1 \tilde{X}^{-+} + M_2 \tilde{X}^{+-} \right); \right\rbrace \, ,; ```; where ``\tilde{X} = \text{IFFT}(X)`` here, ``\tilde{X}^{-+}`` is indexed in reverse along the first dimension,; ``\tilde{X}^{-+}`` along the second dimension, and ``\tilde{X}^{--}`` along both. ``M_1`` and ``M_2`` are masks of lengths; ``N_1`` and ``N_2`` respectively, both containing ones except at the first element where ``M_0 = 0``. Afterwards, the inverse; permutation of \eqref{eq:permutation} must be applied. Due to the extra steps involved in calculating the cosine transform in 2D, running with two ; wall-bounded dimensions typically slows the model down by a factor of 2. Switching to the FACR ; algorithm may help here as a 2D cosine transform won't be necessary anymore. ## Iterative Solvers. For problems with irregular grids the eigenvectors of the discrete Poisson operator are no longer simple Fourier; series sines and cosines. This means discrete Fast Fourier Transforms can't be used to generate the projection ; of the equation right hand side onto eigenvectors. So an eigenvector based approach to solving; the Poisson equation is not computationally efficient. For problems with grids that are non uniform in multiple directions, we use instead a pre-conditioned conjugate; gradient iterative solver. Such cases include curvilinear grids on the sphere and also telescoping cartesian; grids that stretch along more than one dimension. There are two forms of the pressure operator in this approach.; One is rigid lid form and one is an implicit free-surface form. ### Rigid lid ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:11001,down,down,11001,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['down'],['down']
Availability,"`; where; ```math; \overline{S}_{ij} = \frac{1}{2} ( \partial_j \overline{u}_i + \partial_i \overline{u}_j ) \, ,; ```; is the mean rate of strain tensor. Thanks to the non-linearity of the Navier-Stokes equations, even when averaged we are left with pesky fluctuation; terms which form the components of the *Reynolds stress tensor*; ```math; \tau_{ij} = \rho \overline{v_i^\prime v_j^\prime} \, .; ```; Attempting to close the equations leads to the *closure problem*: the time evolution of the Reynolds stresses; depends on triple covariances ``\overline{v_i^\prime v_j^\prime v_k^\prime}`` and covariances with pressure, which depend; on quadruple covariances and so on [Chou45](@cite). This is kind of hopeless so we will have to find some way to model the Reynolds stresses. ## Gradient-diffusion hypothesis and eddy viscosity models. The *gradient-diffusion hypothesis*, due to [Boussinesq1877](@citet), assumes that the transport of scalar fluxes; such as ``\overline{\boldsymbol{v}^\prime c^\prime}`` and ``\overline{v_i^\prime v_j^\prime}`` occurs down the mean scalar gradient; ``\boldsymbol{\nabla} \overline{c}`` as if they are being diffused (¬ß4.4) [Pope00](@cite). This is in analogy with how momentum transfer by; molecular motion in a gas can be described by a molecular viscosity. Taking this assumption we can express the Reynolds stresses and turbulent tracer fluxes in terms of the mean variables; and close the equations; ```math; \overline{\boldsymbol{v}^\prime c^\prime} = -\kappa_e \boldsymbol{\nabla} \overline{c}; \quad \text{and} \quad; \overline{v_i^\prime v_j^\prime} = -2\nu_e \overline{S}_{ij} \, ,; ```; where ``\nu_e = \nu_e(\boldsymbol{x}, t)`` is the turbulent or *eddy viscosity* and ``\kappa_e = \kappa_e(\boldsymbol{x}, t)``; is the *eddy diffusivity*. The effective diffusivity ends up being the sum of the molecular and eddy diffusivities. So just by using an elevated; value for the viscosity and diffusivity, you are already using an eddy viscosity model. T",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md:3602,down,down,3602,docs/src/numerical_implementation/turbulence_closures.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md,1,['down'],['down']
Availability,"``4 \times 4 \times 2``.; Note that length units are whatever is used to construct the grid, so it's up to the user to make sure that all inputs use consistent units. In building our first grid, we did not specify whether it should be constructed on the [`CPU`](@ref)` or [`GPU`](@ref).; As a result, the grid was constructed by default on the CPU.; Next we build a grid on the _GPU_ that's two-dimensional in ``x, z`` and has variably-spaced cell interfaces in the `z`-direction,. ```jldoctest grids_gpu; architecture = GPU(); z_faces = [0, 1, 3, 6, 10]. grid = RectilinearGrid(architecture,; topology = (Periodic, Flat, Bounded),; size = (10, 4),; x = (0, 20),; z = z_faces). # output; 10√ó1√ó4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on GPU with 3√ó0√ó3 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 20.0) regularly spaced with Œîx=2.0; ‚îú‚îÄ‚îÄ Flat y; ‚îî‚îÄ‚îÄ Bounded z ‚àà [0.0, 10.0] variably spaced with min(Œîz)=1.0, max(Œîz)=4.0; ```. !!! note ""GPU architecture requires a CUDA-enabled device""; To run the above example and create a grid on the GPU, an Nvidia GPU has to be available; and [`CUDA.jl`](https://cuda.juliagpu.org/stable/) must be working). For more information; see the [`CUDA.jl` documentation](https://cuda.juliagpu.org/stable/). The ``y``-dimension is ""missing"" because it's marked `Flat` in `topology = (Periodic, Flat, Bounded)`.; So nothing varies in ``y``: `y`-derivatives are 0.; Also, the keyword argument (or ""kwarg"" for short) that specifies the ``y``-domains may be omitted, and `size` has only two elements rather than 3 as in the first example.; In the stretched cell interfaces specified by `z_interfaces`, the number of; vertical cell interfaces is `Nz + 1 = length(z_interfaces) = 5`, where `Nz = 4` is the number; of cells in the vertical. A bit later in this tutorial, we'll give examples that illustrate how to build a grid thats [`Distributed`](@ref) across _multiple_ CPUs and GPUs. ## Grid types: squares, shells, and mountains. The shape of the physical domain determines what ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:2798,avail,available,2798,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['avail'],['available']
Availability,"ain script) inside functions slows down the code. One; way to circumvent this is to always [use local variables or pass them as arguments to; functions](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). This; helps the compiler optimize the code. Another way around this is to [define global variables as constants whenever; possible](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). One; thing to keep in mind when doing this is that when a `const` is defined, its value can't be changed; until you restart the Julia session. So this latter approach is good for production-ready code, but; may be undesirable in the early stages of development while you still have to change the parameters; of the simulation for exploration. It is especially important to avoid global variables in functions that are meant to be executed in; GPU kernels (such as functions defining boundary conditions and forcings). Otherwise the Julia GPU; compiler can fail with obscure errors. This is explained in more detail in the GPU simulation tips; section below. ### Consider inlining small functions. Inlining is when the compiler [replaces a function call with the body of the function that is being; called before compiling](https://en.wikipedia.org/wiki/Inline_expansion). The advantage of inlining; (which in julia can be done with the [`@inline`; macro](https://docs.julialang.org/en/v1/devdocs/meta/)) is that gets rid of the time spent calling; the function. The Julia compiler automatically makes some calls as to what functions it should or; shouldn't inline, but you can force a function to be inlined by including the macro `@inline` before; its definition. This is more suited for small functions that are called often. Here's an example of; an implementation of the Heaviside function that forces it to be inlined:. ```julia; @inline heaviside(x) = ifelse(x < 0, zero(x), one(x)); ```. In practice it's hard to say whether inlining a functi",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:2150,error,errors,2150,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['error'],['errors']
Availability,"be; - [`Periodic`](@ref), which means that the dimension circles back onto itself: information leaving the left side of the domain re-enters on the right.; - [`Bounded`](@ref), which means that the two sides of the dimension are either impenetrable (solid walls), or ""open"", representing a specified external state.; - [`Flat`](@ref), which means nothing can vary in that dimension, reducing the overall dimensionality of the grid.; * Defining the number of cells that divide each dimension. The number of cells, with or without explicit specification of the cell interfaces, determines the spatial resolution of the grid.; * The representation of floating point numbers, which can be single-precision (`Float32`) or double precision (`Float64`). Let's dive into each of these options in more detail. ### Specifying the machine architecture. The positional argument `CPU()` or `GPU()`, specifies the ""architecture"" of the simulation.; By using `architecture = GPU()`, any fields constructed on `grid` store their data on; an Nvidia [`GPU`](@ref), if one is available. By default, the grid will be constructed on; the [`CPU`](@ref) if this argument is omitted.; So, for example,. ```jldoctest grids; grid = RectilinearGrid(size=3, z=(0, 1), topology=(Flat, Flat, Bounded)); cpu_grid = RectilinearGrid(CPU(), size=3, z=(0, 1), topology=(Flat, Flat, Bounded)). grid == cpu_grid. # output; true; ```. To use more than one CPU, we use the `Distributed` architecture,. ```jldoctest grids; child_architecture = CPU(); architecture = Distributed(child_architecture). # output; [ Info: MPI has not been initialized, so we are calling MPI.Init().; Distributed{CPU} across 1 rank:; ‚îú‚îÄ‚îÄ local_rank: 0 of 0-0; ‚îî‚îÄ‚îÄ local_index: [1, 1, 1]; ```. which allows us to distributed computations across either CPUs or GPUs.; In this case, we didn't launch `julia` on multiple nodes using [MPI](https://en.wikipedia.org/wiki/Message_Passing_Interface),; so we're only ""distributed"" across 1 node.; <!-- For more, see [Distr",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:11734,avail,available,11734,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['avail'],['available']
Availability,"boundary conditions on the; _normal_ velocity component must use the [`Open`](@ref) boundary condition type. Finally, note that `ValueBoundaryCondition(condition)` is an alias for `BoundaryCondition(Value, condition)`. ### 2. Constant `Flux` boundary condition. ```jldoctest; julia> œÅ‚ÇÄ = 1027; # Reference density [kg/m¬≥]. julia> œÑ‚Çì = 0.08; # Wind stress [N/m¬≤]. julia> wind_stress_bc = FluxBoundaryCondition(-œÑ‚Çì/œÅ‚ÇÄ); FluxBoundaryCondition: -7.78968e-5; ```. A constant [`Flux`](@ref) boundary condition can be imposed on tracers and tangential velocity components; that can be used, for example, to specify cooling, heating, evaporation, or wind stress at the ocean surface. !!! info ""The flux convention in Oceananigans""; `Oceananigans` uses the convention that positive fluxes produce transport in the; _positive_ direction (east, north, and up for ``x``, ``y``, ``z``).; This means, for example, that a _negative_ flux of momentum or velocity at a _top_; boundary, such as in the above example, produces currents in the _positive_ direction,; because it prescribes a downwards flux of momentum into the domain from the top.; Likewise, a _positive_ temperature flux at the top boundary; causes _cooling_, because it transports heat _upwards_, out of the domain.; Conversely, a positive flux at a _bottom_ boundary acts to increase the interior; values of a quantity. ### 3. Spatially- and temporally-varying flux. Boundary conditions may be specified by functions,. ```jldoctest; julia> @inline surface_flux(x, y, t) = cos(2œÄ * x) * cos(t);. julia> top_tracer_bc = FluxBoundaryCondition(surface_flux); FluxBoundaryCondition: ContinuousBoundaryFunction surface_flux at (Nothing, Nothing, Nothing); ```. !!! info ""Boundary condition functions""; By default, a function boundary condition is called with the signature; ```julia; f(Œæ, Œ∑, t); ```; where `t` is time and `Œæ, Œ∑` are spatial coordinates that vary along the boundary:; * `f(y, z, t)` on `x`-boundaries;; * `f(x, z, t)` on `y`-boundaries;; *",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md:10372,down,downwards,10372,docs/src/model_setup/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md,1,['down'],['downwards']
Availability,"ca} w ); + \delta_z^{aaf} ( \nu \overline{A_z}^{aac} \partial_z^{aac} w ); \right ] \, ,; ```; where ``\nu`` is the kinematic viscosity. An isotropic diffusion operator acting on a tracer ``c``, on the other hand, is discretized via; ```math; \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \kappa \boldsymbol{\nabla} c \right ); = \frac{1}{V} \left[ \vphantom{\overline{A_x}^{caa}}; \delta_x^{caa} ( \kappa A_x \partial_x^{faa} c ); + \delta_y^{aca} ( \kappa A_y \partial_y^{afa} c ); + \delta_z^{aac} ( \kappa A_z \partial_z^{aaf} c ); \right] \, .; ```. ## Vertical integrals; Vertical integrals are converted into sums along each column. For example, the hydrostatic pressure ; anomaly is; ```math; p_{HY}^\prime = \int_{-L_z}^0 b^\prime \, \mathrm{d} z \, ,; ```; where ``b^\prime`` is the buoyancy perturbation. Converting it into a sum that we compute from ; the top downwards we get; ```math; \begin{equation}; p_{HY}^\prime(k) =; \begin{cases}; - \overline{b_{N_z}^\prime}^{aaf} \Delta z^F_{N_z}, & \quad k = N_z \, , \\; p_{HY}^\prime(k+1) - \overline{b_{k+1}^\prime}^{aaf} \Delta z^F_k, & \quad 1 \le k \le N_z - 1 \, ,; \end{cases}; \end{equation}; ```; where we converted the sum into a recursive definition for ``p_{HY}^\prime(k)`` in terms of ; ``p_{HY}^\prime(k+1)`` so that the integral may be computed with ``\mathcal{O}(N_z)`` operations ; by a single thread. The vertical velocity ``w`` may be computed from ``u`` and ``v`` via the continuity equation; ```math; w = - \int_{-L_z}^0 (\partial_x u + \partial_y v) \, \mathrm{d} z \, ,; ```; to satisfy the incompressibility condition ``\boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{v} = 0``; to numerical precision. This also involves computing a vertical integral, in this case evaluated; from the bottom up; ```math; \begin{equation}; w_k =; \begin{cases}; 0, & \quad k = 1 \, , \\; w_{k-1} - \left( \partial_x^{caa} u + \partial_y^{aca} v \right) \Delta z^C_k, & \quad 2 \le k \le N_z \, .; \end{cases}; \end{equation}; ```; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/spatial_operators.md:7192,down,downwards,7192,docs/src/numerical_implementation/spatial_operators.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/spatial_operators.md,1,['down'],['downwards']
Availability,"ce_model). The [`HydrostaticFreeSurfaceModel`](@ref) solves the incompressible Navier-Stokes equations under; the Boussinesq and hydrostatic approximations and with an arbitrary number of tracer conservation ; equations. Physics associated with individual terms in the momentum and tracer conservation; equations -- the background rotation rate of the equation's reference frame,; gravitational effects associated with buoyant tracers under the Boussinesq; approximation, generalized stresses and tracer fluxes associated with viscous and; diffusive physics, and arbitrary ""forcing functions"" -- are determined by the whims of the; user. ## Mass conservation and free surface evolution equation. The mass conservation equation is; ```math; 0 = \boldsymbol{\nabla}_h \boldsymbol{\cdot} \boldsymbol{u} + \partial_z w \, . ; ```. Given the horizontal flow ``\boldsymbol{u}`` we use the above to diagnose the vertical velocity ``w``.; We integrate the mass conservation equation from the bottom of the fluid (where ``w = 0``) up to; depth ``z`` and recover ``w(x, y, z, t)``. The free surface displacement ``\eta(x, y, t)`` satisfies the linearized kinematic boundary ; condition at the surface; ```math; \partial_t \eta = w(x, y, z=0, t) \, .; ```. ## The momentum conservation equation. The equations governing the conservation of momentum in a rotating fluid, including buoyancy; via the Boussinesq approximation are; ```math; \begin{align}; \partial_t \boldsymbol{u} & = - \left ( \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} \right ) \boldsymbol{u}; - \boldsymbol{f} \times \boldsymbol{u} ; - \boldsymbol{\nabla}_h (p + g \eta); - \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{\tau}; + \boldsymbol{F_u} \, , \label{eq:momentum}\\; 0 & = b - \partial_z p \, , \label{eq:hydrostatic}; \end{align}; ```; where ``b`` the is buoyancy, ``\boldsymbol{\tau}`` is the hydrostatic kinematic stress tensor, ; ``\boldsymbol{F_u}`` denotes an internal forcing of the horizontal flow ``\boldsymbol{u",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/hydrostatic_free_surface_model.md:1113,recover,recover,1113,docs/src/physics/hydrostatic_free_surface_model.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/hydrostatic_free_surface_model.md,1,['recover'],['recover']
Availability,"d `rate` to; a `target` distribution, within a region uncovered by a `mask`ing function.; `Relaxation` is useful for implementing sponge layers, as shown in the second example. The following code constructs a model in which all components; of the velocity field are damped to zero everywhere on a time-scale of 1000 seconds, or ~17 minutes:. ```jldoctest; damping = Relaxation(rate = 1/1000). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = NonhydrostaticModel(grid=grid, forcing=(u=damping, v=damping, w=damping)). model.forcing.w. # output; ContinuousForcing{Nothing} at (Center, Center, Face); ‚îú‚îÄ‚îÄ func: Relaxation(rate=0.001, mask=1, target=0); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:w,); ```. The constructor for `Relaxation` accepts the keyword arguments `mask`, and `target`,; which specify a `mask(x, y, z)` function that multiplies the forcing, and a `target(x, y, z)`; distribution for the quantity in question. By default, `mask` uncovered the whole domain; and `target` restores the field in question to 0. We illustrate usage of `mask` and `target` by implementing a sponge layer that relaxes; velocity fields to zero and restores temperature to a linear gradient in the bottom; 1/10th of the domain:. ```jldoctest sponge_layer; grid = RectilinearGrid(size=(1, 1, 1), x=(0, 1), y=(0, 1), z=(-1, 0)). damping_rate = 1/100 # relax fields on a 100 second time-scale; temperature_gradient = 0.001 # ‚Å∞C m‚Åª¬π; surface_temperature = 20 # ‚Å∞C (at z=0). target_temperature = LinearTarget{:z}(intercept=surface_temperature, gradient=temperature_gradient); bottom_mask = GaussianMask{:z}(center=-grid.Lz, width=grid.Lz/10). uvw_sponge = Relaxation(rate=damping_rate, mask=bottom_mask); T_sponge = Relaxation(rate=damping_rate, mask=bottom_mask, target=target_temperature). model = NonhydrostaticModel(grid=grid, forcing=(u=uvw_sponge, v=uvw_sponge, w=uvw_sponge, T=T_sponge), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S)). model.forcing.u. # output; ContinuousForcing{N",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:8984,mask,mask,8984,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['mask'],['mask']
Availability,"d grid](@id finite_volume). The `Oceananigans.jl` staggered grid is defined by a rectilinear array of cuboids of horizontal dimensions ; ``\Delta x_{i, j, k}, \Delta y_{i, j, k}`` and vertical dimension ; ``\Delta z_{i, j, k}``, where ``(i, j, k)`` index the location of each cell in the staggered grid.; Note that the indices ``(i, j, k)`` increase with increasing coordinate ``(x, y, z)``. ![Schematic of staggered grid](assets/staggered_grid.png); *A schematic of `Oceananigans.jl` finite volumes for a two-dimensional staggered grid in ``(x, z)``.; Tracers ``c`` and pressure ``p`` are defined at the center of the control volume. The ``u`` control volumes are ; centered on the left and right edges of the pressure control volume while the ``w`` control volumes are centered ; on the top and bottom edges of the pressure control volumes. The indexing convention places the ``i^{\rm{th}}`` ; ``u``-node on cell ``x``-faces to the left of the ``i`` tracer point at cell centers.*. Dropping explicit indexing, the areas of cell faces are given by; ```math; A_x = \Delta y \Delta z, \quad A_y = \Delta x \Delta z, \quad A_z = \Delta x \Delta y \, ,; ```; so that each cell encloses a volume ``V = \Delta x \Delta y \Delta z``. A finite volume method discretizes a continuous quantity ``c`` by considering its average over a finite volume:; ```math; c_{i, j, k} \equiv \frac{1}{V_{i, j, k}} \int c(\boldsymbol{x}) \, \mathrm{d} V_{i, j, k} \, .; ```; The finite volumes that discretize each of ``u``, ``v``, and ``w`` are located on a grid which is ""staggered"" ; with respect to the grid that defines tracer finite volumes. ; The nodes, or central points of the velocity finite volumes are co-located with the faces of the tracer ; finite volume.; In particular, the ``u``-nodes are located in the center of the ""``x``-face"" (east of the tracer point), ; ``v``-nodes are located on ``y``-faces south of the tracer point, and ``w``-nodes are located on ; ``z``-faces downwards from the tracer point.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/finite_volume.md:2003,down,downwards,2003,docs/src/numerical_implementation/finite_volume.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/finite_volume.md,1,['down'],['downwards']
Availability,"e often than appropriate for; typical applications: we only do it here for illustration purposes. ```@repl checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1))). simulation = Simulation(model, Œît=1, stop_iteration=8). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=IterationInterval(5), prefix=""model_checkpoint""); ```. Again, for illustration purposes of this example, we also add another callback so we can see the iteration; of the simulation. ```@repl checkpointing; show_iteration(sim) = @info ""iteration: $(iteration(sim)); time: $(prettytime(sim.model.clock.time))""; add_callback!(simulation, show_iteration, name=:info, IterationInterval(1)); ```. Now let's run. ```@repl checkpointing; run!(simulation); ```. The default options should provide checkpoint files that are easy to restore from (in most cases).; For more advanced options and features, see [`Checkpointer`](@ref). ## Picking up a simulation from a checkpoint file. Picking up a simulation from a checkpoint requires the original script that was used to generate; the checkpoint data. Change the first instance of [`run!`](@ref) in the script to take `pickup=true`. When `pickup=true` is provided to `run!` then it finds the latest checkpoint file in the current working; directory, loads prognostic fields and their tendencies from file, resets the model clock and iteration,; to the clock time and iteration that the checkpoint corresponds to, and updates the model auxiliary state.; After that, the time-stepping loop. In this simple example, although the simulation run up to iteration 8,; the latest checkpoint is associated with iteration 5. ```@repl checkpointing; simulation.stop_iteration = 12. run!(simulation, pickup=true); ```. Use `pickup=iteration`, where `iteration` is an `Integer`, to pick up from a specific iteration.; Or, use `pickup=filepath`, where `filepath` is a string, to pickup from a specific file located; at `f",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md:1712,checkpoint,checkpoint,1712,docs/src/model_setup/checkpointing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md,1,['checkpoint'],['checkpoint']
Availability,"e simulations changing between CPUs and GPUs is; just a matter of changing the `architecture` argument in the model from `CPU()` to `GPU()`. However,; for more complex simulations some care needs to be taken on the part of the user. While knowledge of; GPU computing (and Julia) is again desirable, an inexperienced user can also achieve high efficiency; in GPU simulations by following a few simple principles. ### Global variables that need to be used in GPU computations need to be defined as constants or passed as parameters. Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation; will crash. This includes any variables that are referenced as global variables in functions; used for forcing of boundary conditions. For example,. ```julia; T‚ÇÄ = 20 # ·µíC; surface_temperature(x, y, t) = T‚ÇÄ * sin(2œÄ / 86400 * t); T_bcs = FieldBoundaryConditions(bottom = GradientBoundaryCondition(surface_temperature)); ```. will throw an error if run on the GPU (and will run more slowly than it should on the CPU).; Replacing the first line above with. ```julia; const T‚ÇÄ = 20 # ·µíC; ```. fixes the issue by indicating to the compiler that `T‚ÇÄ` will not change. Note that the _literal_ `2œÄ / 86400` is not an issue -- it's only the; _variable_ `T‚ÇÄ` that must be declared `const`. Alternatively, we can pass the variable as a parameter to `GradientBoundaryCondition`. To do that; we need to pass a named tuple as `parameter` keyword argument:. ```julia; T‚ÇÄ = 20 # ·µíC; surface_temperature(x, y, t, p) = p.T‚ÇÄ * sin(2œÄ / 86400 * t); T_bcs = FieldBoundaryConditions(bottom = GradientBoundaryCondition(surface_temperature, parameters=(; T‚ÇÄ))); ```. ### Complex diagnostics using computed `Field`s may not work on GPUs. `Field`s are the most convenient way to calculate diagnostics for your simulation. They will; always work on CPUs, but when their complexity is high (in terms of number of abstract operations); the compiler can't translate them into GPU code and they fail ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:4560,error,error,4560,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['error'],['error']
Availability,"e space of divergenece free velocity by applying; ```math; \begin{equation}; \label{eq:pressure_correction_step}; \boldsymbol{u}^{n+1} = \boldsymbol{u}^\star - \Delta t\boldsymbol{\nabla}p^{n+1},; \end{equation}; ```; but we have changed ``p^{n+1}`` to ``\phi`` and ``\boldsymbol{u}^\star`` to ``\tilde{\boldsymbol{u}}^\star``; so for ``\boldsymbol{\nabla}\phi \big |_{\partial\Omega} = 0`` the modified predictor velocity must; equal the corrected velocity on the boundary. For simple open boundary conditions such as no penetration or a straight forward prescription of; a known velocity at ``t^{n+1}`` this is simple to implement as we just set the boundary condition; on the predictor velocity and don't change it after the correction. But some open boundary methods; calculate the boundary value based on the interior solution. As a simple example, if we wanted to ; set the wall normal veloicty gradient to zero at the west boundary then we would set the boundary ; point to; ```math; \begin{equation}; \label{eq:zero_wall_normal_velocity_gradient}; u^\star_{1jk} \approx u^\star_{3jk} + (u^\star_{2jk} - u^\star_{jk4}) / 2 + \mathcal{O}(\Delta x^2),; \end{equation}; ```; but we then pressure correct the interior so a new ``\mathcal{O}(\Delta t)`` error is introduced as; ```math; \begin{equation}; \begin{align}; u^{n+1}_{1jk} &\approx u^{n+1}_{3jk} + (u^{n+1}_{2jk} - u^{n+1}_{jk4}) / 2 + \mathcal{O}(\Delta x^2),\\; &= u^\star_{1jk} - \Delta t \left(\boldsymbol{\nabla}p^{n+1}_{3jk} + (\boldsymbol{\nabla}p^{n+1}_{2jk} - \boldsymbol{\nabla}p^{n+1}_{4jk}) / 2\right) + \mathcal{O}(\Delta x^2),\\; &\approx u^\star_{1jk} + \mathcal{O}(\Delta x^2) + \mathcal{O}(\Delta t).; \end{align}; \end{equation}; ```; This is prefered to a divergent interior solution as open boundary conditions (except no penetration); are typlically already unphysical and only used in an attempt to allow information to enter or exit; the domain. Open boundary conditions are represented by the [`Open`](@ref) type.",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md:11562,error,error,11562,docs/src/numerical_implementation/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md,1,['error'],['error']
Availability,"eananigans.jl/issues/new/choose); ; * [Creating a GitHub discussion](https://github.com/CliMA/Oceananigans.jl/discussions/new). * Sending a message to the [#oceananigans channel](https://julialang.slack.com/archives/C01D24C0CAH) on [Julia Slack](https://julialang.org/slack/). We follow the [ColPrac guide](https://github.com/SciML/ColPrac) for collaborative; practices. We ask that new contributors read that guide before submitting a pull request. ## Creating issues. The simplest way to contribute to Oceananigans is to create or comment on issues and discussions. The most useful bug reports:. * Provide an explicit code snippet -- not just a link -- that reproduces the bug in the latest tagged version of Oceananigans. This is sometimes called the [""minimal working example""](https://en.wikipedia.org/wiki/Minimal_working_example). Reducing bug-producing code to a minimal example can dramatically decrease the time it takes to resolve an issue. * Paste the _entire_ error received when running the code snippet, even if it's unbelievably long. * Use triple backticks (```` ``` ````) to enclose code snippets, and other [markdown formatting syntax](https://docs.github.com/en/github/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) to make your issue easy and quick to read. * Report the Oceananigans version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created. Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general. ## But I want to _code_!. * New users help write Oceananigans code and documentation by [forking the Oceananigans repository](https://docs.github.com/en/github/collaborating-with-pull-requests/working-with-forks), [using git](https://guides.github.com/introduction/git-handbook/) to edit code and docs, and then creating a [pull r",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md:1195,error,error,1195,CONTRIBUTING.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md,1,['error'],['error']
Availability,"ed. A state-of-the-art Tesla V100 GPU has 32GB of; memory -- enough memory for simulations with about 100 million points, or grids a bit smaller; than 512 √ó 512 √ó 512. (The maximum grid size depends on some user-specified factors,; like the number of passive tracers or computed diagnostics.); For large simulations on the GPU, careful management of memory allocation may be required:. - Use the [`nvidia-smi`](https://developer.nvidia.com/nvidia-system-management-interface) command; line utility to monitor the memory usage of the GPU. It should tell you how much memory there is; on your GPU and how much of it you're using and you can run it from Julia via. ```julia; julia> ;; shell> run(`nvidia-smi`); ```. - Try to use higher-order advection schemes. In general when you use a higher-order scheme you need; fewer grid points to achieve the same accuracy that you would with a lower-order one. Refer to the; [documentation](https://clima.github.io/OceananigansDocumentation/stable/appendix/library/#Advection); for available advection schemes. - Manually define scratch space to be reused in diagnostics. By default, every time a user-defined; diagnostic is calculated the compiler reserves a new chunk of memory for that calculation, usually; called scratch space. In general, the more diagnostics, the more scratch space needed and the bigger; the memory requirements. However, if you explicitly create a scratch space and pass that same; scratch space for as many diagnostics as you can, you minimize the memory requirements of your; calculations by reusing the same chunk of memory. Have a look at an; [example for how to create scratch space](https://github.com/CliMA/LESbrary.jl/blob/cf31b0ec20219d5ad698af334811d448c27213b0/examples/three_layer_ constant_fluxes.jl#L380-L383) and how it can be; [used in calculations](https://github.com/CliMA/LESbrary.jl/blob/cf31b0ec20219d5ad698af334811d448c27213b0/src/TurbulenceStatistics/first_through_third_order.jl#L109-L112). ### Arrays in GPUs a",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:9395,avail,available,9395,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['avail'],['available']
Availability,"he completion of; a timestep. The other options are `callsite = TendencyCallsite()` that executes the callback; after the tendencies are computed but _before_ taking a timestep and `callsite = UpdateStateCallsite()`; that executes the callback within `update_state!`, after auxiliary variables have been computed; (for multi-stage time-steppers, `update_state!` may be called multiple times per timestep). As an example of a callback with `callsite = TendencyCallsite()` , we show below how we can; manually add to the tendency field of one of the velocity components. Here we've chosen; the `:u` field using parameters:. ```@example checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))). simulation = Simulation(model, Œît=1, stop_iteration=10). function modify_tendency!(model, params); model.timestepper.G‚Åø[params.c] .+= params.Œ¥; return nothing; end. simulation.callbacks[:modify_u] = Callback(modify_tendency!, IterationInterval(1),; callsite = TendencyCallsite(),; parameters = (c = :u, Œ¥ = 1)). run!(simulation); ```. Above there is no forcing at all, but due to the callback the ``u``-velocity is increased. ```@example checkpointing; @info model.velocities.u; ```. !!! note ""Example only for illustration purposes""; The above is a redundant example since it could be implemented better with a simple forcing function.; We include it here though for illustration purposes of how one can use callbacks. ## Functions. Callback functions can only take one or two parameters `sim` - a simulation, or `model` for state callbacks, and optionally may also accept a NamedTuple of parameters. ## Scheduling. The time that callbacks are called at are specified by schedule functions which can be:; - [`IterationInterval`](@ref) : runs every `n` iterations; - [`TimeInterval`](@ref) : runs every `n`s of model run time; - [`SpecifiedTimes`](@ref) : runs at the specified times; - [`WallTimeInterval`](@ref) : runs every `n`s of wall time; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/callbacks.md:2300,checkpoint,checkpointing,2300,docs/src/model_setup/callbacks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/callbacks.md,2,"['checkpoint', 'redundant']","['checkpointing', 'redundant']"
Availability,"ime = 0 seconds, iteration = 0); ‚îú‚îÄ‚îÄ grid: 1√ó1√ó1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ timestepper: RungeKutta3TimeStepper; ‚îú‚îÄ‚îÄ tracers: (); ‚îú‚îÄ‚îÄ closure: Nothing; ‚îú‚îÄ‚îÄ buoyancy: Nothing; ‚îî‚îÄ‚îÄ coriolis: Nothing. julia> typeof(model.velocities.u.data); OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}. julia> adapt(Array, model.velocities.u.data); 3√ó3√ó3 OffsetArray(::Array{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2√ó0:2√ó0:2:; [:, :, 0] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 1] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0; ```. Notice that to view the `CuArray` that stores values for `u` we first need to transform; it into a regular `Array` using `Adapt.adapt`. If we naively try to view the `CuArray`; without that step we get an error:. ```julia; julia> model.velocities.u.data; 3√ó3√ó3 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2√ó0:2√ó0:2:; [:, :, 0] =; Error showing value of type OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}:; ERROR: Scalar indexing is disallowed.; ```. Here `CUDA.jl` throws an error because scalar `getindex` is not `allowed`. There are ways to; overcome this limitation and allow scalar indexing (more about that ; in the [CUDA.jl documentation](https://cuda.juliagpu.org/stable/usage/workflow/#UsageWorkflowScalar)), but this option; can be very slow on GPUs, so it is advised to only use this last method when using the REPL or ; prototyping -- never in production-ready scripts. You might also need to keep these differences in mind when using arrays; to define initial conditions, boundary conditions or; forcing functions on a GPU. To learn more about working with `CuArray`s, see the; [array programming](https://juliagpu.github.io/CUDA.jl/dev/usage/array/) section; of the CUDA.jl documentation.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:13274,error,error,13274,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['error'],['error']
Availability,"implies that ``F_{\omega}`` is given by; ```math; F_{\omega} = -\xi^\prime f_x (g - g^{\prime\prime}) + f f_x (g g^{\prime\prime\prime} - g^\prime g^{\prime\prime}) + f (g - 2 g^{\prime\prime} + g^{\prime\prime\prime\prime}) \, ,; ```; where primes denote derivatives of functions of a single argument. ; Setting ``\partial_y F_v = F_{\omega}``, we find that if ``F_v`` satisfies; ```math; \partial_y F_v = (g^\prime)^2 + g g^{\prime\prime} \, ,; ```; then the pressure Poisson equation becomes; ```math; \nabla^2 p = \cos [2 (x - \xi)] [(g^\prime)^2 - g g^{\prime\prime}] + \partial_x F_v \, .; ```; This completes the specification of the problem. We set up the problem by imposing the time-dependent forcing functions ``F_u`` and ``F_v``; on ``u`` and ``v``, initializing the flow at ``t=0``, and integrating the problem forwards; in time using Oceananigans. We find the expected convergence of the numerical solution to the; analytical solution: the error between the numerical and analytical solutions; decreases with ``1/N_x^2 \sim \Delta x^2``, where ``N_x`` is the number of grid; points and ``\Delta x`` is the spatial resolution:. ![Forced free slip convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/forced_free_slip_convergence.png). The convergence tests are performed using both ``y`` and ``z`` as the bounded direction. ### Forced, free-slip flow. A forced flow satisfying free-slip conditions at ``y = 0`` and ``y = \pi`` has the streamfunction; ```math; \psi(x, y, t) = - \cos [x - \xi(t)] \sin (y) \, ,; ```; and thus ``g(y) = \sin y``. The velocity field ``(u, v)`` is; ```math; u = \cos (x - \xi) \cos y \, , \quad \text{and} \quad v = \sin (x - \xi) \sin y \, ,; ```; which satisfies the boundary conditions ``u_y |_{y=0} = u_y |_{y=\pi} = 0`` and; ``v |_{y=0} = v |_{y=\pi} = 0``. The vorticity forcing is; ```math; F_{\omega} = - 2 \xi^\prime f_x \sin y + 4 f \sin y \, ,; ```; which implies that; ```math; F_v =",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md:7818,error,error,7818,docs/src/appendix/convergence_tests.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md,1,['error'],['error']
Availability,"l coordinates,; time, model velocity and tracer fields, and external parameters. ```@meta; DocTestSetup = quote; using Oceananigans; end; ```. Forcings are added to models by passing a `NamedTuple` of functions or forcing objects; to the `forcing` keyword argument in `NonhydrostaticModel`'s constructor.; By default, momentum and tracer forcing functions are assumed to be functions of; `x, y, z, t`. A basic example is. ```jldoctest; u_forcing(x, y, z, t) = exp(z) * cos(x) * sin(t). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, forcing=(u=u_forcing,)). model.forcing.u. # output; ContinuousForcing{Nothing} at (Face, Center, Center); ‚îú‚îÄ‚îÄ func: u_forcing (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (); ```. More general forcing functions are built via the `Forcing` constructor; described below. `Oceananigans` also provides two convenience types:. * `Relaxation` for damping terms that restore a field to a; target distribution outside of a masked region of space. `Relaxation` can be; used to implement sponge layers near the boundaries of a domain.; * `AdvectiveForcing` for advecting individual quantities by a separate or; ""slip"" velocity relative to both the prognostic model velocity field and any; `BackgroundField` velocity field. ## The `Forcing` constructor. The `Forcing` constructor provides an interface for specifying forcing functions that. 1. Depend on external parameters; and; 2. Depend on model fields at the `x, y, z` location that forcing is applied; and/or; 3. Require access to discrete model data. ### Forcing functions with external parameters. Most forcings involve external, changeable parameters.; Here are two examples of `forcing_func`tions that depend on ; _(i)_ a single scalar parameter `s`, and _(ii)_ a `NamedTuple` of parameters, `p`:. ```jldoctest parameterized_forcing; # Forcing that depends on a scalar parameter `s`; u_forcing_func(x, y, z, t, s) = s * z. u_forcing",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:1343,mask,masked,1343,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['mask'],['masked']
Availability,"ld2` where `12500` is the iteration; number (automatically filled in). Here's an example where we checkpoint every 5 iterations. This is far more often than appropriate for; typical applications: we only do it here for illustration purposes. ```@repl checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1))). simulation = Simulation(model, Œît=1, stop_iteration=8). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=IterationInterval(5), prefix=""model_checkpoint""); ```. Again, for illustration purposes of this example, we also add another callback so we can see the iteration; of the simulation. ```@repl checkpointing; show_iteration(sim) = @info ""iteration: $(iteration(sim)); time: $(prettytime(sim.model.clock.time))""; add_callback!(simulation, show_iteration, name=:info, IterationInterval(1)); ```. Now let's run. ```@repl checkpointing; run!(simulation); ```. The default options should provide checkpoint files that are easy to restore from (in most cases).; For more advanced options and features, see [`Checkpointer`](@ref). ## Picking up a simulation from a checkpoint file. Picking up a simulation from a checkpoint requires the original script that was used to generate; the checkpoint data. Change the first instance of [`run!`](@ref) in the script to take `pickup=true`. When `pickup=true` is provided to `run!` then it finds the latest checkpoint file in the current working; directory, loads prognostic fields and their tendencies from file, resets the model clock and iteration,; to the clock time and iteration that the checkpoint corresponds to, and updates the model auxiliary state.; After that, the time-stepping loop. In this simple example, although the simulation run up to iteration 8,; the latest checkpoint is associated with iteration 5. ```@repl checkpointing; simulation.stop_iteration = 12. run!(simulation, pickup=true); ```. Use `pickup=iteration`, where `iteration` is an `Integer",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md:1545,checkpoint,checkpoint,1545,docs/src/model_setup/checkpointing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md,1,['checkpoint'],['checkpoint']
Availability,"locity location:; N¬≤ = ‚Ñëxz·∂†·µÉ·∂ú(i, j, k, grid, ‚àÇz·∂†·∂ú·∂†, model_fields.b). # Set to zero in unstable stratification where N¬≤ < 0:; N¬≤ = max(N¬≤, zero(typeof(N¬≤))). return @inbounds - Œµ * sqrt(N¬≤) * model_fields.u[i, j, k]; end. u_forcing = Forcing(u_forcing_func, discrete_form=true, parameters=1e-3). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, tracers=:b, buoyancy=BuoyancyTracer(), forcing=(u=u_forcing, b=b_forcing)). model.forcing.b. # output; DiscreteForcing{Nothing}; ‚îú‚îÄ‚îÄ func: b_forcing_func (generic function with 1 method); ‚îî‚îÄ‚îÄ parameters: nothing; ```. ```jldoctest discrete_forcing; model.forcing.u. # output; DiscreteForcing{Float64}; ‚îú‚îÄ‚îÄ func: u_forcing_func (generic function with 1 method); ‚îî‚îÄ‚îÄ parameters: 0.001; ```. The annotation `@inbounds` is crucial for performance when accessing array indices; of the fields in `model_fields`. ## `Relaxation`. `Relaxation` defines a special forcing function that restores a field at a specified `rate` to; a `target` distribution, within a region uncovered by a `mask`ing function.; `Relaxation` is useful for implementing sponge layers, as shown in the second example. The following code constructs a model in which all components; of the velocity field are damped to zero everywhere on a time-scale of 1000 seconds, or ~17 minutes:. ```jldoctest; damping = Relaxation(rate = 1/1000). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = NonhydrostaticModel(grid=grid, forcing=(u=damping, v=damping, w=damping)). model.forcing.w. # output; ContinuousForcing{Nothing} at (Center, Center, Face); ‚îú‚îÄ‚îÄ func: Relaxation(rate=0.001, mask=1, target=0); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:w,); ```. The constructor for `Relaxation` accepts the keyword arguments `mask`, and `target`,; which specify a `mask(x, y, z)` function that multiplies the forcing, and a `target(x, y, z)`; distribution for the quantity in question. By default, `mask` uncovered the whole domain; an",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:8088,mask,mask,8088,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['mask'],['mask']
Availability,"mask` and `target` by implementing a sponge layer that relaxes; velocity fields to zero and restores temperature to a linear gradient in the bottom; 1/10th of the domain:. ```jldoctest sponge_layer; grid = RectilinearGrid(size=(1, 1, 1), x=(0, 1), y=(0, 1), z=(-1, 0)). damping_rate = 1/100 # relax fields on a 100 second time-scale; temperature_gradient = 0.001 # ‚Å∞C m‚Åª¬π; surface_temperature = 20 # ‚Å∞C (at z=0). target_temperature = LinearTarget{:z}(intercept=surface_temperature, gradient=temperature_gradient); bottom_mask = GaussianMask{:z}(center=-grid.Lz, width=grid.Lz/10). uvw_sponge = Relaxation(rate=damping_rate, mask=bottom_mask); T_sponge = Relaxation(rate=damping_rate, mask=bottom_mask, target=target_temperature). model = NonhydrostaticModel(grid=grid, forcing=(u=uvw_sponge, v=uvw_sponge, w=uvw_sponge, T=T_sponge), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S)). model.forcing.u. # output; ContinuousForcing{Nothing} at (Face, Center, Center); ‚îú‚îÄ‚îÄ func: Relaxation(rate=0.01, mask=exp(-(z + 1.0)^2 / (2 * 0.1^2)), target=0); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:u,); ```. ```jldoctest sponge_layer; model.forcing.T. # output; ContinuousForcing{Nothing} at (Center, Center, Center); ‚îú‚îÄ‚îÄ func: Relaxation(rate=0.01, mask=exp(-(z + 1.0)^2 / (2 * 0.1^2)), target=20.0 + 0.001 * z); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:T,); ```. ## `AdvectiveForcing`. `AdvectiveForcing` defines a forcing function that represents advection by; a separate or ""slip"" velocity relative to the prognostic model velocity field.; `AdvectiveForcing` is implemented with native Oceananigans advection operators,; which means that tracers advected by the ""flux form"" advection term; ``ùõÅ‚ãÖùêÆ_{\rm slip} c``. Caution is advised when ``ùêÆ_{\rm slip}`` is not divergence free. As an example, consider a model for sediment settling at a constant rate:. ```jldoctest; using Oceananigans. r_sediment = 1e-4 # [m] ""Fine sand""; œÅ_sediment = 1200 # kg m‚Åª¬≥; œÅ_ocean = 1026 # kg m‚Åª¬≥; Œîb = 9.81 * (œÅ_",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:10086,mask,mask,10086,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['mask'],['mask']
Availability,"much as possible ""behind the scenes"".; Yet Oceananigans' flexibility places some responsibility on users to ensure high performance simulations,; especially for complex setups with user-defined forcing functions, boundary condition functions, and diagnostics.; Furthermore, in case of more complex GPU runs, some details could; sometimes prevent your simulation from running altogether. While Julia knowledge is obviously; desirable here, a user that is unfamiliar with Julia can get away with efficient simulations by; learning a few rules of thumb. It is nonetheless recommended that users go through Julia's; [performance tips](https://docs.julialang.org/en/v1/manual/performance-tips/), which contains more; in-depth explanations of some of the aspects discussed here. ## General (CPU/GPU) simulation tips. ### Avoid global variables whenever possible. In general using a [global; variable](https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Global-Scope) (which can be; loosely defined as a variable defined in the main script) inside functions slows down the code. One; way to circumvent this is to always [use local variables or pass them as arguments to; functions](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). This; helps the compiler optimize the code. Another way around this is to [define global variables as constants whenever; possible](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). One; thing to keep in mind when doing this is that when a `const` is defined, its value can't be changed; until you restart the Julia session. So this latter approach is good for production-ready code, but; may be undesirable in the early stages of development while you still have to change the parameters; of the simulation for exploration. It is especially important to avoid global variables in functions that are meant to be executed in; GPU kernels (such as functions defining boundary conditions and forcings)",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:1160,down,down,1160,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['down'],['down']
Availability,"n accessing array indices; of the fields in `model_fields`. ## `Relaxation`. `Relaxation` defines a special forcing function that restores a field at a specified `rate` to; a `target` distribution, within a region uncovered by a `mask`ing function.; `Relaxation` is useful for implementing sponge layers, as shown in the second example. The following code constructs a model in which all components; of the velocity field are damped to zero everywhere on a time-scale of 1000 seconds, or ~17 minutes:. ```jldoctest; damping = Relaxation(rate = 1/1000). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = NonhydrostaticModel(grid=grid, forcing=(u=damping, v=damping, w=damping)). model.forcing.w. # output; ContinuousForcing{Nothing} at (Center, Center, Face); ‚îú‚îÄ‚îÄ func: Relaxation(rate=0.001, mask=1, target=0); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:w,); ```. The constructor for `Relaxation` accepts the keyword arguments `mask`, and `target`,; which specify a `mask(x, y, z)` function that multiplies the forcing, and a `target(x, y, z)`; distribution for the quantity in question. By default, `mask` uncovered the whole domain; and `target` restores the field in question to 0. We illustrate usage of `mask` and `target` by implementing a sponge layer that relaxes; velocity fields to zero and restores temperature to a linear gradient in the bottom; 1/10th of the domain:. ```jldoctest sponge_layer; grid = RectilinearGrid(size=(1, 1, 1), x=(0, 1), y=(0, 1), z=(-1, 0)). damping_rate = 1/100 # relax fields on a 100 second time-scale; temperature_gradient = 0.001 # ‚Å∞C m‚Åª¬π; surface_temperature = 20 # ‚Å∞C (at z=0). target_temperature = LinearTarget{:z}(intercept=surface_temperature, gradient=temperature_gradient); bottom_mask = GaussianMask{:z}(center=-grid.Lz, width=grid.Lz/10). uvw_sponge = Relaxation(rate=damping_rate, mask=bottom_mask); T_sponge = Relaxation(rate=damping_rate, mask=bottom_mask, target=target_temperature). model = NonhydrostaticModel(grid=gri",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:8811,mask,mask,8811,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,2,['mask'],['mask']
Availability,"odes correspond to solutions in the null space of the; pressure projection operator with eigenvalue zero and are thus indistinguishable from a uniform pressure field; [Sani81](@cite). The staggered grid was first introduced by [Harlow65](@citet) with their *marker and cell* method. In meteorology; and oceanography, this particular staggered grid configuration is referred to as the Arakawa C-grid after [Arakawa77](@citet), who; investigated four different staggered grids and the unstaggered A-grid for use in an atmospheric model. [Arakawa77](@citet) investigated the dispersion relation of inertia-gravity waves[^2] traveling in the ``x``-direction; ```math; \omega^2 = f^2 + gHk^2 \, ,; ```; in the linearized rotating shallow-water equations for five grids. Here ``\omega`` is the angular frequency, ``H`` is the; height of the fluid and ``k`` is the wavenumber in the ``x``-direction. Looking at the effect of spatial discretization; error on the frequency of these waves they find that the B and C-grids reproduce the dispersion relation most closely; out of the five [Arakawa77](@citet) (Figure 5). In particular, the dispersion relation for the C-grid is given by; ```math; \omega^2 = f^2 \left[ \cos^2 \left( \frac{k\Delta}{2} \right); + 4 \left( \frac{\lambda}{\Delta} \right)^2 \sin^2 \left( \frac{k\Delta}{2} \right) \right] \, ,; ```; where ``\lambda`` is the wavelength and ``\Delta`` is the grid spacing. Paraphrasing p. 184 of [Arakawa77](@citet): The; wavelength of the shortest resolvable wave is ``2\Delta`` with corresponding wavenumber ``k = \pi/\Delta`` so it is; sufficient to evaluate the dispersion relation over the range ``0 < k \Delta < \pi``. The frequency is monotonically; increasing for ``\lambda / \Delta > \frac{1}{2}`` and monotonically decreasing for ``\lambda / \Delta < \frac{1}{2}``. For the; fourth smallest wave ``\lambda / \Delta = \frac{1}{2}`` we get ``\omega^2 = f^2`` which matches the ``k = 0`` wave. Furthermore,; the group velocity is zero for all ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/staggered_grid.md:3172,error,error,3172,docs/src/appendix/staggered_grid.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/staggered_grid.md,1,['error'],['error']
Availability,"ontributor's%20Guide-blueviolet?style=flat-square"">; </a>; <a href=""https://doi.org/10.21105/joss.02018"">; <img alt=""JOSS"" src=""https://joss.theoj.org/papers/10.21105/joss.02018/status.svg"">; </a>; </p>. <!-- Version and documentation badges -->; <p align=""center"">; <a href=""https://github.com/CliMA/Oceananigans.jl/releases"">; <img alt=""GitHub tag (latest SemVer pre-release)"" src=""https://img.shields.io/github/v/tag/CliMA/Oceananigans.jl?include_prereleases&label=latest%20version&logo=github&sort=semver&style=flat-square"">; </a>; <a href=""https://clima.github.io/OceananigansDocumentation/stable"">; <img alt=""Stable documentation"" src=""https://img.shields.io/badge/documentation-stable%20release-blue?style=flat-square"">; </a>; <a href=""https://clima.github.io/OceananigansDocumentation/dev"">; <img alt=""Development documentation"" src=""https://img.shields.io/badge/documentation-in%20development-orange?style=flat-square"">; </a>; </p>. <!-- Downloads -->; <!-- counts downloads from individual IPs excluding bots (eg, CI) -->; <!-- see https://discourse.julialang.org/t/announcing-package-download-stats/69073 -->. <p align=""center"">; <a href=""https://juliapkgstats.com/pkg/Oceananigans"">; <img alt=""Downloads per month"" src=""https://img.shields.io/badge/dynamic/json?url=http%3A%2F%2Fjuliapkgstats.com%2Fapi%2Fv1%2Fmonthly_downloads%2FOceananigans&query=total_requests&suffix=%2Fmonth&label=Downloads&style=flat-square"">; </a>; <a href=""https://juliapkgstats.com/pkg/Oceananigans"">; <img alt=""Downloads per month"" src=""https://img.shields.io/badge/dynamic/json?url=http%3A%2F%2Fjuliapkgstats.com%2Fapi%2Fv1%2Ftotal_downloads%2FOceananigans&query=total_requests&&label=Total%20Downloads&style=flat-square"">; </a>; </p>. <!-- CI/CD badges -->; <p align=""center"">; <a href=""https://buildkite.com/clima/oceananigans"">; <img alt=""Buildkite CPU+GPU build status"" src=""https://img.shields.io/buildkite/4d921fc17b95341ea5477fb62df0e6d9364b61b154e050a123/main?logo=buildkite&label=Buildkite%20CPU%2BGPU&",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:2018,down,downloads,2018,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['down'],['downloads']
Availability,"ould be used:. 1. [`RectilinearGrid`](@ref Oceananigans.Grids.RectilinearGrid) can be fashioned into lines, rectangles and boxes.; 2. [`LatitudeLongitudeGrid`](@ref Oceananigans.Grids.LatitudeLongitudeGrid) represents sectors of thin spherical shells, with cells bounded by lines of constant latitude and longitude.; 3. [`OrthogonalSphericalShellGrid`](@ref Oceananigans.Grids.OrthogonalSphericalShellGrid) represents sectors of thin spherical shells divided with mesh lines that intersect at right angles (thus, orthogonal) but are otherwise arbitrary. !!! note ""OrthogonalSphericalShellGrids.jl""; See the auxiliary package [`OrthogonalSphericalShellGrids.jl`](https://github.com/CliMA/OrthogonalSphericalShellGrids.jl); for recipes that implement some useful `OrthogonalSphericalShellGrid`, including the; [""tripolar"" grid](https://www.sciencedirect.com/science/article/abs/pii/S0021999196901369). For example, to make a `LatitudeLongitudeGrid` that wraps around the sphere, extends for 60 degrees latitude on either side of the equator, and also has 5 vertical levels down to 1000 meters, we write. ```jldoctest grids; architecture = CPU(). grid = LatitudeLongitudeGrid(architecture,; size = (180, 10, 5),; longitude = (-180, 180),; latitude = (-60, 60),; z = (-1000, 0)). # output; 180√ó10√ó5 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3√ó3√ó3 halo and with precomputed metrics; ‚îú‚îÄ‚îÄ longitude: Periodic Œª ‚àà [-180.0, 180.0) regularly spaced with ŒîŒª=2.0; ‚îú‚îÄ‚îÄ latitude: Bounded œÜ ‚àà [-60.0, 60.0] regularly spaced with ŒîœÜ=12.0; ‚îî‚îÄ‚îÄ z: Bounded z ‚àà [-1000.0, 0.0] regularly spaced with Œîz=200.0; ```. The main difference between the syntax for `LatitudeLongitudeGrid` versus that for the `RectilinearGrid` are the names of the horizontal coordinates:; `LatitudeLongitudeGrid` has `longitude` and `latitude` where `RectilinearGrid` has `x` and `y`. !!! note ""Extrinsic and intrinsic coordinate systems""; Every grid is associated with an ""extrinsic"" coordinate system: `Rectilinea",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:4822,down,down,4822,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['down'],['down']
Availability,"oundary condition for velocity fields.; # Note that the no-slip boundary condition is _only_ applied on immersed boundaries.; velocity_bcs = FieldBoundaryConditions(immersed=ValueBoundaryCondition(0)); model = NonhydrostaticModel(; grid, boundary_conditions=(u=velocity_bcs, v=velocity_bcs, w=velocity_bcs)). # Insepct the boundary condition on the vertical velocity:; model.velocities.w.boundary_conditions.immersed. # output; ImmersedBoundaryCondition:; ‚îú‚îÄ‚îÄ west: ValueBoundaryCondition: 0.0; ‚îú‚îÄ‚îÄ east: ValueBoundaryCondition: 0.0; ‚îú‚îÄ‚îÄ south: ValueBoundaryCondition: 0.0; ‚îú‚îÄ‚îÄ north: ValueBoundaryCondition: 0.0; ‚îú‚îÄ‚îÄ bottom: Nothing; ‚îî‚îÄ‚îÄ top: Nothing; ```. !!! warning ""`NonhydrostaticModel` on `ImmersedBoundaryGrid`""; The pressure solver for `NonhydrostaticModel` is approximate, and is unable to produce; a velocity field that is simultaneously divergence-free while also satisfying impenetrability; on the immersed boundary. As a result, simulated dynamics with `NonhydrostaticModel` can; exhibit egregiously unphysical errors and should be interpreted with caution. An `ImmersedBoundaryCondition` encapsulates boundary conditions on each potential boundary-facet; of a boundary-adjacent cell. Boundary conditions on specific faces of immersed-boundary-adjacent; cells may also be specified by manually building an `ImmersedBoundaryCondition`:. ```julia; bottom_drag_bc = ImmersedBoundaryCondition(bottom=ValueBoundaryCondition(0)). # output; ImmersedBoundaryCondition:; ‚îú‚îÄ‚îÄ west: Nothing; ‚îú‚îÄ‚îÄ east: Nothing; ‚îú‚îÄ‚îÄ south: Nothing; ‚îú‚îÄ‚îÄ north: Nothing; ‚îú‚îÄ‚îÄ bottom: ValueBoundaryCondition: 0; ‚îî‚îÄ‚îÄ top: Nothing; ```. The `ImmersedBoundaryCondition` may then be incorporated into the boundary conditions for a; `Field` by prescribing it to the `immersed` boundary label,. ```julia; velocity_bcs = FieldBoundaryConditions(immersed=bottom_drag_bc). # output; Oceananigans.FieldBoundaryConditions, with boundary conditions; ‚îú‚îÄ‚îÄ west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing); ‚îú‚îÄ‚îÄ east: De",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md:21080,error,errors,21080,docs/src/model_setup/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md,1,['error'],['errors']
Availability,"r`](@ref) can be used to serialize the entire model state to a file from which the model; can be restored at any time. This is useful if you'd like to periodically checkpoint when running; long simulations in case of crashes or hitting cluster time limits, but also if you'd like to restore; from a checkpoint and try out multiple scenarios. For example, to periodically checkpoint the model state to disk every 1,000,000 seconds of simulation; time to files of the form `model_checkpoint_iteration12500.jld2` where `12500` is the iteration; number (automatically filled in). Here's an example where we checkpoint every 5 iterations. This is far more often than appropriate for; typical applications: we only do it here for illustration purposes. ```@repl checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1))). simulation = Simulation(model, Œît=1, stop_iteration=8). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=IterationInterval(5), prefix=""model_checkpoint""); ```. Again, for illustration purposes of this example, we also add another callback so we can see the iteration; of the simulation. ```@repl checkpointing; show_iteration(sim) = @info ""iteration: $(iteration(sim)); time: $(prettytime(sim.model.clock.time))""; add_callback!(simulation, show_iteration, name=:info, IterationInterval(1)); ```. Now let's run. ```@repl checkpointing; run!(simulation); ```. The default options should provide checkpoint files that are easy to restore from (in most cases).; For more advanced options and features, see [`Checkpointer`](@ref). ## Picking up a simulation from a checkpoint file. Picking up a simulation from a checkpoint requires the original script that was used to generate; the checkpoint data. Change the first instance of [`run!`](@ref) in the script to take `pickup=true`. When `pickup=true` is provided to `run!` then it finds the latest checkpoint file in the current working; directory, loads pr",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md:1012,checkpoint,checkpointer,1012,docs/src/model_setup/checkpointing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md,1,['checkpoint'],['checkpointer']
Availability,"s guide; helps you make a contribution. Feel free to ask us questions and chat with us at any time about any topic at all; by:. * [Opening a GitHub issue](https://github.com/CliMA/Oceananigans.jl/issues/new). * [Creating a GitHub discussion](https://github.com/CliMA/Oceananigans.jl/discussions/new). * Sending a message to the [#oceananigans channel](https://julialang.slack.com/archives/C01D24C0CAH) on [Julia Slack](https://julialang.org/slack/). ## Creating issues. The simplest way to contribute to Oceananigans is to create or comment on issues and discussions. The most useful bug reports:. * Provide an explicit code snippet -- not just a link -- that reproduces the bug in the latest tagged version of Oceananigans. This is sometimes called the [""minimal working example""](https://en.wikipedia.org/wiki/Minimal_working_example). Reducing bug-producing code to a minimal example can dramatically decrease the time it takes to resolve an issue. * Paste the _entire_ error received when running the code snippet, even if it's unbelievably long. * Use triple backticks (e.g., ````` ```some_code; and_some_more_code;``` `````) to enclose code snippets, and other [markdown formatting syntax](https://docs.github.com/en/github/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) to make your issue easy and quick to read. * Report the Oceananigans version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created. Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general. ## But I want to _code_!. * New users help write Oceananigans code and documentation by [forking the Oceananigans repository](https://docs.github.com/en/github/collaborating-with-pull-requests/working-with-forks), [using git](https://guides.github.com/introduction/git-handbook/) to edit c",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:1063,error,error,1063,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['error'],['error']
Availability,"sine transform for a real signal of length ``N_1 \times N_2`` is then given by; ```math; Y_{k_1, k_2} = \text{DCT}(X_{n_1, n_2}) =; 2 \text{Re} \left\lbrace; \omega_{4N_1}^k \left( \omega_{4N_2}^k \tilde{X} + \omega_{4N_2}^{-k} \tilde{X}^- \right); \right\rbrace \, ,; ```; where ``\tilde{X} = \text{FFT}(X^\prime)`` and ``\tilde{X}^-`` indicates that ``\tilde{X}`` is indexed in reverse. ### 2D fast inverse cosine transform; The inverse can be computed using; ```math; Y_{k_1, k_2} = \text{IDCT}(X_{n_1, n_2}) =; \frac{1}{4} \text{Re} \left\lbrace; \omega_{4N_1}^{-k} \omega_{4N_2}^{-k}; \left( \tilde{X} - M_1 M_2 \tilde{X}^{--} \right); - \mathrm{i} \left( M_1 \tilde{X}^{-+} + M_2 \tilde{X}^{+-} \right); \right\rbrace \, ,; ```; where ``\tilde{X} = \text{IFFT}(X)`` here, ``\tilde{X}^{-+}`` is indexed in reverse along the first dimension,; ``\tilde{X}^{-+}`` along the second dimension, and ``\tilde{X}^{--}`` along both. ``M_1`` and ``M_2`` are masks of lengths; ``N_1`` and ``N_2`` respectively, both containing ones except at the first element where ``M_0 = 0``. Afterwards, the inverse; permutation of \eqref{eq:permutation} must be applied. Due to the extra steps involved in calculating the cosine transform in 2D, running with two ; wall-bounded dimensions typically slows the model down by a factor of 2. Switching to the FACR ; algorithm may help here as a 2D cosine transform won't be necessary anymore. ## Iterative Solvers. For problems with irregular grids the eigenvectors of the discrete Poisson operator are no longer simple Fourier; series sines and cosines. This means discrete Fast Fourier Transforms can't be used to generate the projection ; of the equation right hand side onto eigenvectors. So an eigenvector based approach to solving; the Poisson equation is not computationally efficient. For problems with grids that are non uniform in multiple directions, we use instead a pre-conditioned conjugate; gradient iterative solver. Such cases include curvilinear grids on",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:10657,mask,masks,10657,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['mask'],['masks']
Availability,"ss.02018"">; <img alt=""JOSS"" src=""https://joss.theoj.org/papers/10.21105/joss.02018/status.svg"">; </a>; </p>. <!-- Version and documentation badges -->; <p align=""center"">; <a href=""https://github.com/CliMA/Oceananigans.jl/releases"">; <img alt=""GitHub tag (latest SemVer pre-release)"" src=""https://img.shields.io/github/v/tag/CliMA/Oceananigans.jl?include_prereleases&label=latest%20version&logo=github&sort=semver&style=flat-square"">; </a>; <a href=""https://clima.github.io/OceananigansDocumentation/stable"">; <img alt=""Stable documentation"" src=""https://img.shields.io/badge/documentation-stable%20release-blue?style=flat-square"">; </a>; <a href=""https://clima.github.io/OceananigansDocumentation/dev"">; <img alt=""Development documentation"" src=""https://img.shields.io/badge/documentation-in%20development-orange?style=flat-square"">; </a>; </p>. <!-- Downloads -->; <!-- counts downloads from individual IPs excluding bots (eg, CI) -->; <!-- see https://discourse.julialang.org/t/announcing-package-download-stats/69073 -->. <p align=""center"">; <a href=""https://juliapkgstats.com/pkg/Oceananigans"">; <img alt=""Downloads per month"" src=""https://img.shields.io/badge/dynamic/json?url=http%3A%2F%2Fjuliapkgstats.com%2Fapi%2Fv1%2Fmonthly_downloads%2FOceananigans&query=total_requests&suffix=%2Fmonth&label=Downloads&style=flat-square"">; </a>; <a href=""https://juliapkgstats.com/pkg/Oceananigans"">; <img alt=""Downloads per month"" src=""https://img.shields.io/badge/dynamic/json?url=http%3A%2F%2Fjuliapkgstats.com%2Fapi%2Fv1%2Ftotal_downloads%2FOceananigans&query=total_requests&&label=Total%20Downloads&style=flat-square"">; </a>; </p>. <!-- CI/CD badges -->; <p align=""center"">; <a href=""https://buildkite.com/clima/oceananigans"">; <img alt=""Buildkite CPU+GPU build status"" src=""https://img.shields.io/buildkite/4d921fc17b95341ea5477fb62df0e6d9364b61b154e050a123/main?logo=buildkite&label=Buildkite%20CPU%2BGPU&style=flat-square"">; </a>; <a href=""https://hub.docker.com/r/aliramadhan/oceananigans"">; <img ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:2139,down,download-stats,2139,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['down'],['download-stats']
Availability,"the *closure problem*: the time evolution of the Reynolds stresses; depends on triple covariances ``\overline{v_i^\prime v_j^\prime v_k^\prime}`` and covariances with pressure, which depend; on quadruple covariances and so on [Chou45](@cite). This is kind of hopeless so we will have to find some way to model the Reynolds stresses. ## Gradient-diffusion hypothesis and eddy viscosity models. The *gradient-diffusion hypothesis*, due to [Boussinesq1877](@citet), assumes that the transport of scalar fluxes; such as ``\overline{\boldsymbol{v}^\prime c^\prime}`` and ``\overline{v_i^\prime v_j^\prime}`` occurs down the mean scalar gradient; ``\boldsymbol{\nabla} \overline{c}`` as if they are being diffused (¬ß4.4) [Pope00](@cite). This is in analogy with how momentum transfer by; molecular motion in a gas can be described by a molecular viscosity. Taking this assumption we can express the Reynolds stresses and turbulent tracer fluxes in terms of the mean variables; and close the equations; ```math; \overline{\boldsymbol{v}^\prime c^\prime} = -\kappa_e \boldsymbol{\nabla} \overline{c}; \quad \text{and} \quad; \overline{v_i^\prime v_j^\prime} = -2\nu_e \overline{S}_{ij} \, ,; ```; where ``\nu_e = \nu_e(\boldsymbol{x}, t)`` is the turbulent or *eddy viscosity* and ``\kappa_e = \kappa_e(\boldsymbol{x}, t)``; is the *eddy diffusivity*. The effective diffusivity ends up being the sum of the molecular and eddy diffusivities. So just by using an elevated; value for the viscosity and diffusivity, you are already using an eddy viscosity model. The eddy viscosity model is simple and for that reason is very popular. It can work well even with a constant eddy; diffusivity. However, it does assume that the flux is aligned down gradient, which is not true even in simple turbulent; flows as the physics of turbulence is quite different from that of colliding molecules leading to the viscous stress law; (¬ß4.4,10.1) [Pope00](@cite). So we might want something a little bit more sophisticated.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md:4721,down,down,4721,docs/src/numerical_implementation/turbulence_closures.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md,1,['down'],['down']
Availability,"to the [Kolmogorov41](@citet) length scale ``\eta = (\nu^3 / \varepsilon)^{1/4}`` where; ``\nu`` is the kinematic viscosity and ``\varepsilon`` the average rate of dissipation of turbulence kinetic energy per; unit mass. As pointed out way back by [Corrsin61](@citet), to run a simulation on a horizontal domain about 10 times the size of an; ""average eddy"" with 100 vertical levels and where the grid spacing is given by ``\eta`` would require the computer to; store on the order of ``10^{14}`` variables.[^1] This is still impractical today, although may be within; reach in less than a decade. He ends by suggesting the use of an analog rather digital computer---a tank of water. [^1]: And even then, ``\eta`` gives the *maximum* allowable grid spacing. There is significant flow structure; smaller than ``\eta``. To have any hope of simulating high Reynolds number flows we need some way of resolving the sub-grid scale motions.[^2]. [^2]: In reality there is no need to resolve all motions down to the Kolmogorov length scale to achieve; acceptable accuracy. Perhaps good results can be achieved if 80\% of the kinetic energy is resolved; (¬ß13) [Pope00](@cite). ## Reynolds-averaged Navier‚ÄìStokes equations. Following [Reynolds1895](@citet), we can decompose flow variables such as velocity ``\boldsymbol{v}`` into the mean component; ``\overline{\boldsymbol{v}}`` and the fluctuating component ``\boldsymbol{v}^\prime`` so that ``\boldsymbol{v} = \overline{\boldsymbol{v}} + \boldsymbol{v}^\prime``; [see ¬ß4 of [Pope00](@citet) for a modern discussion]. Expressing the Navier-Stokes equations in tensor notation; ```math; \begin{align}; \partial_i v_i &= 0 \, ,\\; \partial_t v_i + v_j \partial_j v_i &= f_i - \alpha\partial_i p + \nu \partial_j \partial_j v_i \, ,; \end{align}; ```; where ``\alpha = \rho^{-1}`` is the specific volume and ``f_i`` represents external forces. We can plug in the Reynolds; decomposition for ``\boldsymbol{v}`` and after some manipulation arrive at the following",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md:1190,down,down,1190,docs/src/numerical_implementation/turbulence_closures.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md,1,['down'],['down']
Availability,"unded z ‚àà [-1.0, 0.0] regularly spaced with Œîz=1.0. julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ‚îú‚îÄ‚îÄ grid: 1√ó1√ó1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ timestepper: RungeKutta3TimeStepper; ‚îú‚îÄ‚îÄ tracers: (); ‚îú‚îÄ‚îÄ closure: Nothing; ‚îú‚îÄ‚îÄ buoyancy: Nothing; ‚îî‚îÄ‚îÄ coriolis: Nothing. julia> typeof(model.velocities.u.data); OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}. julia> adapt(Array, model.velocities.u.data); 3√ó3√ó3 OffsetArray(::Array{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2√ó0:2√ó0:2:; [:, :, 0] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 1] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0; ```. Notice that to view the `CuArray` that stores values for `u` we first need to transform; it into a regular `Array` using `Adapt.adapt`. If we naively try to view the `CuArray`; without that step we get an error:. ```julia; julia> model.velocities.u.data; 3√ó3√ó3 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2√ó0:2√ó0:2:; [:, :, 0] =; Error showing value of type OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}:; ERROR: Scalar indexing is disallowed.; ```. Here `CUDA.jl` throws an error because scalar `getindex` is not `allowed`. There are ways to; overcome this limitation and allow scalar indexing (more about that ; in the [CUDA.jl documentation](https://cuda.juliagpu.org/stable/usage/workflow/#UsageWorkflowScalar)), but this option; can be very slow on GPUs, so it is advised to only use this last method when using the REPL or ; prototyping -- never in production-ready scripts. You might also need to keep these differences in mind when using arrays; to define initial conditions, boundary conditions or; forcing functions on a GPU. To learn more about working w",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:12895,error,error,12895,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['error'],['error']
Availability,"uster time limits, but also if you'd like to restore; from a checkpoint and try out multiple scenarios. For example, to periodically checkpoint the model state to disk every 1,000,000 seconds of simulation; time to files of the form `model_checkpoint_iteration12500.jld2` where `12500` is the iteration; number (automatically filled in). Here's an example where we checkpoint every 5 iterations. This is far more often than appropriate for; typical applications: we only do it here for illustration purposes. ```@repl checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1))). simulation = Simulation(model, Œît=1, stop_iteration=8). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=IterationInterval(5), prefix=""model_checkpoint""); ```. Again, for illustration purposes of this example, we also add another callback so we can see the iteration; of the simulation. ```@repl checkpointing; show_iteration(sim) = @info ""iteration: $(iteration(sim)); time: $(prettytime(sim.model.clock.time))""; add_callback!(simulation, show_iteration, name=:info, IterationInterval(1)); ```. Now let's run. ```@repl checkpointing; run!(simulation); ```. The default options should provide checkpoint files that are easy to restore from (in most cases).; For more advanced options and features, see [`Checkpointer`](@ref). ## Picking up a simulation from a checkpoint file. Picking up a simulation from a checkpoint requires the original script that was used to generate; the checkpoint data. Change the first instance of [`run!`](@ref) in the script to take `pickup=true`. When `pickup=true` is provided to `run!` then it finds the latest checkpoint file in the current working; directory, loads prognostic fields and their tendencies from file, resets the model clock and iteration,; to the clock time and iteration that the checkpoint corresponds to, and updates the model auxiliary state.; After that, the time-stepping loop. In this",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md:1248,checkpoint,checkpointing,1248,docs/src/model_setup/checkpointing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md,1,['checkpoint'],['checkpointing']
Availability,"waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans.jl is developed by the [Climate Modeling Alliance](https://clima.caltech.edu) and heroic external collaborators. ## Contents. - [Contents](#contents); - [Installation instructions](#installation-instructions); - [Running your first model](#running-your-first-model); - [The Oceananigans knowledge base](#the-oceananigans-knowledge-base); - [Citing](#citing); - [Contributing](#contributing); - [Movies](#movies); - [Deep convection](#deep-convection); - [Free convection](#free-convection); - [Winds blowing over the ocean](#winds-blowing-over-the-ocean); - [Free convection with wind stress](#free-convection-with-wind-stress); - [Performance benchmarks](#performance-benchmarks). ## Installation instructions. Oceananigans is a [registered Julia package](https://julialang.org/packages/). So to install it,. 1. [Download Julia](https://julialang.org/downloads/) (version 1.9 or later). 2. Launch Julia and type. ```julia; julia> using Pkg. julia> Pkg.add(""Oceananigans""); ```. This installs the latest version that's _compatible with your current environment_.; Don't forget to *be careful* üèÑ and check which Oceananigans you installed:. ```julia; julia> Pkg.status(""Oceananigans""); ```. ## Running your first model. Let's run a two-dimensional, horizontally-periodic simulation of turbulence using 128¬≤ finite volume cells for 4 non-dimensional time units:. ```julia; using Oceananigans; grid = RectilinearGrid(CPU(), size=(128, 128), x=(0, 2œÄ), y=(0, 2œÄ), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO()); œµ(x, y) = 2rand() - 1; set!(model, u=œµ, v=œµ); simulation = Simulation(model; Œît=0.01, stop_time=4); run!(simulation); ```. But there's more: changing `CPU()` to `GPU()` makes this code run on a CUDA-enabled Nvidia GPU. Dive into [the documentation](https://clima.github.io/OceananigansDocumentation/stable/) f",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:4585,down,downloads,4585,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['down'],['downloads']
Deployability," A few more time-steps, and it's starting to get a little diffuse!. ```@example cpu; simulation.stop_iteration += 400; run!(simulation). compute!(Œ∂); heatmap(Œ∂, axis=(; aspect=1)); ```. ## They always cheat with too-simple ""quick"" starts. Fine, we'll re-run this code on the GPU. But we're a little greedy, so we'll also; crank up the resolution, throw in a `TimeStepWizard` to update `simulation.Œît` adaptively,; and add a passive tracer initially concentrated in the center of the domain; which will make for an even prettier figure of the final state:. ```@setup gpu; using CairoMakie; CairoMakie.activate!(type = ""png""); ```. ```@example gpu; using Oceananigans; using CairoMakie. grid = RectilinearGrid(GPU(),; size = (1024, 1024),; x = (-œÄ, œÄ),; y = (-œÄ, œÄ),; topology = (Periodic, Periodic, Flat)). model = NonhydrostaticModel(; grid, advection=WENO(), tracers=:c). Œ¥ = 0.5; c·µ¢(x, y) = exp(-(x^2 + y^2) / 2Œ¥^2); œµ(x, y) = 2rand() - 1; set!(model, u=œµ, v=œµ, c=c·µ¢). simulation = Simulation(model; Œît=1e-3, stop_time=10); conjure_time_step_wizard!(simulation, cfl=0.2, IterationInterval(10)); run!(simulation). u, v, w = model.velocities; Œ∂ = Field(‚àÇx(v) - ‚àÇy(u)); compute!(Œ∂). fig = Figure(size=(1200, 600)); axŒ∂ = Axis(fig[1, 1], aspect=1, title=""vorticity""); axc = Axis(fig[1, 2], aspect=1, title=""tracer""); heatmap!(axŒ∂, Œ∂, colormap=:balance); heatmap!(axc, model.tracers.c); current_figure(); ```. See how we did that? We passed the positional argument `GPU()` to `RectilinearGrid`.; (This only works if a GPU is available, of course, and; [CUDA.jl is configured](https://cuda.juliagpu.org/stable/installation/overview/).). ## Well, that was tantalizing. But you'll need to know a lot more to become a productive, Oceananigans-wielding computational scientist (spherical grids, forcing, boundary conditions,; turbulence closures, output writing, actually labeling your axes... ü§Ø).; It'd be best to move on to the [one-dimensional diffusion example](@ref one_dimensional_diffusion_example).; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/quick_start.md:2744,install,installation,2744,docs/src/quick_start.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/quick_start.md,1,['install'],['installation']
Deployability," a factor of 2. Switching to the FACR ; algorithm may help here as a 2D cosine transform won't be necessary anymore. ## Iterative Solvers. For problems with irregular grids the eigenvectors of the discrete Poisson operator are no longer simple Fourier; series sines and cosines. This means discrete Fast Fourier Transforms can't be used to generate the projection ; of the equation right hand side onto eigenvectors. So an eigenvector based approach to solving; the Poisson equation is not computationally efficient. For problems with grids that are non uniform in multiple directions, we use instead a pre-conditioned conjugate; gradient iterative solver. Such cases include curvilinear grids on the sphere and also telescoping cartesian; grids that stretch along more than one dimension. There are two forms of the pressure operator in this approach.; One is rigid lid form and one is an implicit free-surface form. ### Rigid lid pressure operator. The rigid lid operator is based on the same continuous form as is used in the Direct Method; solver. ### Implicit free surface pressure operator. The implicit free surface solver solves for the free-surface, ``\eta(x, y, t)``, in the vertically; integrated continuity equation:. ```math; \begin{equation}; \label{eq:vertically-integrated-continuity}; \partial_t \eta + \partial_x \left ( \int_{-H}^0 u \, \mathrm{d}z \right ) + \partial_y \left ( \int_{-H}^0 v \, \mathrm{d}z \right ) = M \, ,; \end{equation}; ```. where ``H(x, y)`` is the depth of the water column (to first order with respect to the free surface; elevation) and ``M`` is some surface volume flux (e.g., terms such as precipitation, evaporation and; runoff); currently Oceananigans.jl assumes ``M = 0``. Note that in deriving \eqref{eq:vertically-integrated-continuity},; we used the bottom boundary condition ``w_{\rm bottom} = \boldsymbol{u}_{\rm bottom} \boldsymbol{\cdot} \boldsymbol{\nabla}_h H``. To form a linear system that can be solved implicitly we recast the vertically",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:12003,continuous,continuous,12003,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['continuous'],['continuous']
Deployability," appropriate for; typical applications: we only do it here for illustration purposes. ```@repl checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1))). simulation = Simulation(model, Œît=1, stop_iteration=8). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=IterationInterval(5), prefix=""model_checkpoint""); ```. Again, for illustration purposes of this example, we also add another callback so we can see the iteration; of the simulation. ```@repl checkpointing; show_iteration(sim) = @info ""iteration: $(iteration(sim)); time: $(prettytime(sim.model.clock.time))""; add_callback!(simulation, show_iteration, name=:info, IterationInterval(1)); ```. Now let's run. ```@repl checkpointing; run!(simulation); ```. The default options should provide checkpoint files that are easy to restore from (in most cases).; For more advanced options and features, see [`Checkpointer`](@ref). ## Picking up a simulation from a checkpoint file. Picking up a simulation from a checkpoint requires the original script that was used to generate; the checkpoint data. Change the first instance of [`run!`](@ref) in the script to take `pickup=true`. When `pickup=true` is provided to `run!` then it finds the latest checkpoint file in the current working; directory, loads prognostic fields and their tendencies from file, resets the model clock and iteration,; to the clock time and iteration that the checkpoint corresponds to, and updates the model auxiliary state.; After that, the time-stepping loop. In this simple example, although the simulation run up to iteration 8,; the latest checkpoint is associated with iteration 5. ```@repl checkpointing; simulation.stop_iteration = 12. run!(simulation, pickup=true); ```. Use `pickup=iteration`, where `iteration` is an `Integer`, to pick up from a specific iteration.; Or, use `pickup=filepath`, where `filepath` is a string, to pickup from a specific file located; at `filepath`.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md:2213,update,updates,2213,docs/src/model_setup/checkpointing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md,1,['update'],['updates']
Deployability," immediate, and is; generally proportional to the size of the pull request. ## Reporting a bug. The easiest way to get involved is to report issues you encounter when using; Oceananigans or by requesting something you think is missing. * Head over to the [issues](https://github.com/CLiMA/Oceananigans.jl/issues) page. * Search to see if your issue already exists or has even been solved previously. * If you indeed have a new issue or request, click the ""New Issue"" button. * Please be as specific as possible. Include the version of the code you were using, as; well as what operating system you are running. The output of Julia's `versioninfo()`; and `] status` is helpful to include. Try your best to include a complete, [""minimal working example""](https://en.wikipedia.org/wiki/Minimal_working_example) that reproduces the issue. ## Setting up your development environment. * Install [Julia](https://julialang.org/) on your system. * Install `git` on your system if it is not already there (install XCode command line tools on; a Mac or `git bash` on Windows). * Login to your GitHub account and make a fork of the; [Oceananigans repository](https://github.com/CLiMA/Oceananigans.jl) by; clicking the ""Fork"" button. * Clone your fork of the Oceananigans repository (in terminal on Mac/Linux or git shell/; GUI on Windows) in the location you'd like to keep it.; ```; git clone https://github.com/your-user-name/Oceananigans.jl.git; ```. * Navigate to that folder in the terminal or in Anaconda Prompt if you're on Windows. * Connect your repository to the upstream (main project).; ```; git remote add oceananigans https://github.com/CLiMA/Oceananigans.jl.git; ```. * Create the development environment by opening Julia via `julia --project` then; typing in `] instantiate`. This will install all the dependencies in the Project.toml; file. Your development environment is now ready!. * You can test to make sure Oceananigans works by typing in `] test`. (This is equivalent to; `using Pkg; Pkg.t",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:6518,install,install,6518,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['install'],['install']
Deployability," readable code. ## What is a ""collaborator"" and how can I become one?. * Collaborators have permissions to review pull requests and status allows a contributor to review pull requests in addition to opening them. Collaborators can also create branches in the main Oceananigans repository. * We ask that new contributors try their hand at forking Oceananigans, and opening and merging a pull request before requesting collaborator status. ## What's a good way to start developing Oceananigans?. * Tackle an existing issue. We keep a list of [good first issues](https://github.com/CLiMA/Oceananigans.jl/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22); that are self-contained and suitable for a newcomer to try and work on. * Try to run Oceananigans and play around with it to simulate your favorite; fluids and ocean physics. If you run into any problems or find it difficult; to use or understand, please open an issue!. * Write up an example or tutorial on how to do something useful with; Oceananigans, like how to set up a new physical configuration. * Improve documentation or comments if you found something hard to use. * Implement a new feature if you need it to use Oceananigans. If you're interested in working on something, let us know by commenting on existing issues or ; by opening a new issue. This is to make sure no one else is working on the same issue and so ; we can help and guide you in case there is anything you need to know beforehand. ## Ground Rules. * Each pull request should consist of a logical collection of changes. You can; include multiple bug fixes in a single pull request, but they should be related.; For unrelated changes, please submit multiple pull requests. * Do not commit changes to files that are irrelevant to your feature or bugfix; (eg: `.gitignore`). * Be willing to accept criticism and work on improving your code; we don't want; to break other users' code, so care must be taken not to introduce bugs. We; discuss pull requests and kee",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:4461,configurat,configuration,4461,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['configurat'],['configuration']
Deployability," use `TitleCase` for types, `snake_case` for objects, and always.put.spaces.after.commas. For formatting decisions we loosely follow the [YASGuide](https://github.com/jrevels/YASGuide). It's worth few extra minutes of our time to leave future generations with well-written, readable code. ## What is a ""collaborator"" and how can I become one?. * Collaborators have permissions to review pull requests and status allows a contributor to review pull requests in addition to opening them. Collaborators can also create branches in the main Oceananigans repository. * We ask that new contributors try their hand at forking Oceananigans, and opening and merging a pull request before requesting collaborator status. ## What's a good way to start developing Oceananigans?. * Tackle an existing issue. We keep a list of [good first issues](https://github.com/CLiMA/Oceananigans.jl/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22); that are self-contained and suitable for a newcomer to try and work on. * Try to run Oceananigans and play around with it to simulate your favorite; fluids and ocean physics. If you run into any bugs/problems or find it difficult; to use or understand, please open an issue!. * Write up an example or tutorial on how to do something useful with; Oceananigans, like how to set up a new physical configuration. * Improve documentation or comments if you found something hard to use. * Implement a new feature if you need it to use Oceananigans. If you're interested in working on something, let us know by commenting on; existing issues or by opening a new issue. This is to make sure no one else; is working on the same issue and so we can help and guide you in case there; is anything you need to know beforehand. We also hang out on the #oceananigans channel on Julia Slack, which is a great; place to discuss anything Oceananigans-related, especially contributions! To; join the Julia Slack, go to [https://julialang.org/slack/](https://julialang.org/slack/).; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md:4546,configurat,configuration,4546,CONTRIBUTING.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md,1,['configurat'],['configuration']
Deployability,"# Convergence Tests. Convergence tests are implemented in `/validation/convergence_tests` and range; from zero-dimensional time-stepper tests to two-dimensional integration tests that; involve non-trivial pressure fields, advection, and diffusion. For all tests except point exponential decay, we use the ``L_1`` norm,. ```math; L_1 \equiv \frac{\mathrm{mean} | \phi_\mathrm{sim} - \phi_\mathrm{exact} |}{\mathrm{mean} | \phi_\mathrm{exact} |}; ```. and ``L_\infty`` norm,. ```math; L_\infty \equiv \frac{\max | \phi_\mathrm{sim} - \phi_\mathrm{exact} |}{\max | \phi_\mathrm{exact} |} \, ,; ```. to compare simulated fields, ``\phi_\mathrm{sim}``, with exact, analytically-derived solutions; ``\phi_\mathrm{exact}``.; The field ``\phi`` may be a tracer field or a velocity field. ## Point Exponential Decay. This test analyzes time-stepper convergence by simulating the zero-dimensional, or spatially-uniform equation. ```math; \partial_t c = - c \, ,; ```. with the initial condition ``c = 1``, which has the analytical solution ``c = \mathrm{e}^{-t}``. We find the expected first-order convergence with decreasing time-step ``\Delta t`` using our; first-order accurate, ""modified second-order"" Adams-Bashforth time-stepping method:. ![Point exponential decay](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/point_exponential_decay_time_stepper_convergence.png). This result validates the correctness of the `Oceananigans` implementation of Adams-Bashforth time-stepping. ## One-dimensional advection and diffusion of a Gaussian. This and the following tests focus on convergence with grid spacing, ``\Delta x``. In one dimension with constant diffusivity ``\kappa`` and in the presence of a; constant velocity ``U``, a Gaussian evolves according to. ```math; c = \frac{\mathrm{e}^{- (x - U t)^2 / 4 \kappa t}}{\sqrt{4 \pi \kappa t}} \, .; ```. For this test we take the initial time as ``t=t_0``.; We simulate this problem with advection and ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md:161,integrat,integration,161,docs/src/appendix/convergence_tests.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md,1,['integrat'],['integration']
Deployability,"# Elliptic solvers. ## The elliptic problem for the pressure. The 3D non-hydrostatic pressure field is obtained by taking the divergence of the horizontal ; component of the momentum equations and invoking the vertical component to yield an elliptic ; Poisson equation for the non-hydrostatic kinematic pressure; ```math; \begin{equation}; \label{eq:poisson-pressure}; \nabla^2 p_{NH} = \frac{\boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{v}^n}{\Delta t} + \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{G}_{\boldsymbol{v}} \equiv \mathscr{F} \, ,; \end{equation}; ```; along with homogenous Neumann boundary conditions ``\boldsymbol{v} \cdot \boldsymbol{\hat{n}} = 0`` ; (Neumann on ``p`` for wall-bounded directions and periodic otherwise) and where ``\mathscr{F}`` ; denotes the source term for the Poisson equation. !!! note ""Hydrostatic approximation""; For problems in which the hydrostatic approximation is invoked, the Poisson equation for; pressure above only needs to be solved for the vertically integrated flow and the pressure; field is a two dimensional term ``p_S(x, y, t)``. ## Direct method. Discretizing elliptic problems that can be solved via a classical separation-of-variables approach, such as Poisson's; equation, results in a linear system of equations ``M \boldsymbol{x} = \boldsymbol{y}`` where ``M`` is a real symmetric matrix of block; tridiagonal form. This allows for the matrix to be decomposed and solved efficiently, provided that the eigenvalues and; eigenvectors of the blocks are known (¬ß2) [Buzbee70](@cite). In the case of Poisson's equation on a rectangle,; [Hockney65](@citet) has taken advantage of the fact that the fast Fourier transform can be used to perform the matrix; multiplication steps resulting in an even more efficient method. [Schumann88](@citet) describe the implementation of such; an algorithm for Poisson's equation on a staggered grid with Dirichlet, Neumann, and periodic boundary conditions. The method can be explained easily by ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:1015,integrat,integrated,1015,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['integrat'],['integrated']
Deployability,"# Oceananigans.jl performance benchmarks. This directory contains scripts and modules for benchmarking various features of Oceananigans. To instantiate the benchmarks environment, run. ```; julia -e 'using Pkg; Pkg.activate(pwd()); Pkg.instantiate(); Pkg.develop(PackageSpec(path=joinpath(@__DIR__, "".."")))'; ```. Once the environment has been instantiated, benchmarks can be run via, e.g. ```; julia --project benchmark_nonhydrostatic_model.jl; ```. Most scripts benchmark one feature (e.g. advection schemes, arbitrary tracers). If your machine contains a CUDA-compatible GPU, benchmarks will also run on the GPU. Tables with benchmark results will be printed (and each table will also be saved to an HTML file). ## Distributed benchmarks. Run distributed benchmarks by running the launcher scripts for either the shallow water model: `distributed_shallow_water_model.jl` or the nonhydrostatic model: `distributed_nonhydrostatic_model.jl`. Change settings within the scripts to toggle between strong or weak scaling and threaded or MPI architecture. The single and serial scripts executed by the launcher scripts can also be executed manually from the command line with the appropriate arguments. ## Measuring performance regression. Running the `benchmark_regression.jl` script will run the nonhydrostatic model tests on the current branch and on the main branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression. ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/benchmark/README.md:980,toggle,toggle,980,benchmark/README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/benchmark/README.md,1,['toggle'],['toggle']
Deployability,"# Oceananigans.jl. *üåä Fast and friendly fluid dynamics on CPUs and GPUs.*. Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic; and hydrostatic Boussinesq equations on CPUs and GPUs.; It runs on GPUs (wow, fast!), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans is written in Julia by the [Climate Modeling Alliance](https://clima.caltech.edu); and heroic external collaborators. ## Quick install. Oceananigans is a [registered Julia package](https://julialang.org/packages/). So to install it,. 1. [Download Julia](https://julialang.org/downloads/). 2. Launch Julia and type. ```julia; julia> using Pkg. julia> Pkg.add(""Oceananigans""); ```. !!! compat ""Julia 1.9 is required""; Oceananigans requires Julia 1.9 or later. If you're [new to Julia](https://docs.julialang.org/en/v1/manual/getting-started/) and its [wonderful `Pkg` manager](https://docs.julialang.org/en/v1/stdlib/Pkg/), the [Oceananigans wiki](https://github.com/CliMA/Oceananigans.jl/wiki) provides [more detailed installation instructions](https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans). ## The Oceananigans ""knowledge base"". It's _deep_ and includes:. * This documentation, which provides; * example Oceananigans scripts,; * tutorials that describe key Oceananigans objects and functions,; * explanations of Oceananigans finite-volume-based numerical methods,; * details of the dynamical equations solved by Oceananigans models, and; * a library documenting all user-facing Oceananigans objects and functions.; * [Discussions on the Oceananigans github](https://github.com/CliMA/Oceananigans.jl/discussions), covering topics like; * [""Computational science""](https://github.com/CliMA/Oceananigans.jl/discussions/categories/computational-science), or how to science and set up numeric",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md:589,install,install,589,docs/src/index.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md,2,['install'],['install']
Deployability,") that reproduces the issue. ## Setting up your development environment. * Install [Julia](https://julialang.org/) on your system. * Install `git` on your system if it is not already there (install XCode command line tools on; a Mac or `git bash` on Windows). * Login to your GitHub account and make a fork of the; [Oceananigans repository](https://github.com/CLiMA/Oceananigans.jl) by; clicking the ""Fork"" button. * Clone your fork of the Oceananigans repository (in terminal on Mac/Linux or git shell/; GUI on Windows) in the location you'd like to keep it.; ```; git clone https://github.com/your-user-name/Oceananigans.jl.git; ```. * Navigate to that folder in the terminal or in Anaconda Prompt if you're on Windows. * Connect your repository to the upstream (main project).; ```; git remote add oceananigans https://github.com/CLiMA/Oceananigans.jl.git; ```. * Create the development environment by opening Julia via `julia --project` then; typing in `] instantiate`. This will install all the dependencies in the Project.toml; file. Your development environment is now ready!. * You can test to make sure Oceananigans works by typing in `] test`. (This is equivalent to; `using Pkg; Pkg.test()`.) Doing so will run all the tests (and this can take a while).; Alternatively, you can run only one test script file by providing its name as an environment; variable. For example, to run the tests only from the `test_coriolis.jl` file we call:. ```; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; ```. ## Pull Requests. We follow the [ColPrac guide](https://github.com/SciML/ColPrac) for collaborative practices.; We ask that new contributors read that guide before submitting a pull request. Changes and contributions should be made via GitHub pull requests against the ``main`` branch. When you're done making changes, commit the changes you made. Chris Beams has written a ; [guide](https://chris.beams.io/posts/git-commit/) on how to write good commit messages. When yo",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:7312,install,install,7312,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['install'],['install']
Deployability,"10.21105/joss.02018},; year = {2020},; publisher = {The Open Journal},; volume = {5},; number = {53},; pages = {2018},; author = {Ali Ramadhan and Gregory LeClaire Wagner and Chris Hill and Jean-Michel Campin and Valentin Churavy and Tim Besard and Andre Souza and Alan Edelman and Raffaele Ferrari and John Marshall},; title = {Oceananigans.jl: Fast and friendly geophysical fluid dynamics on GPUs},; journal = {Journal of Open Source Software}; }; ```. ## Papers and preprints using Oceananigans. If you have work using Oceananigans that you would like to have listed here, please open a pull request to add it or let us know!. 1. Bisits, J. I., Zika, J. D., and Evans, D. G. (2024) [Does cabbeling shape the thermohaline structure of high-latitude oceans?](https://doi.org/10.1175/JPO-D-24-0061.1) _Journal of Physical Oceanography_, in press. DOI: [10.1175/JPO-D-24-0061.1](https://doi.org/10.1175/JPO-D-24-0061.1). 1. Strong-Wright J. and Taylor, J. R. (2024) [A model of tidal flow and tracer release in a giant kelp forest](https://doi.org/10.1017/flo.2024.13), _Flow_, **4**, E21. DOI: [10.1017/flo.2024.13](https://doi.org/10.1017/flo.2024.13). 1. Chor, T. and Wenegrat, J. (2024). [The turbulent dynamics of anticyclonic submesoscale headland wakes](https://doi.org/10.31223/X5570C), _Earth arXiv_, DOI: [10.31223/X5570C](https://doi.org/10.31223/X5570C). 1. Wagner, G. L., Hillier, A., Constantinou, N. C., Silvestri, S., Souza, A., Burns, K., Hill, C., Campin, J.-M., Marshall, J., and Ferrari, R. (2024). [Formulation and calibration of CATKE, a one-equation parameterization for microscale ocean mixing](https://doi.org/10.48550/arXiv.2306.13204), _arXiv_, arXiv:2306.13204. DOI: [10.48550/arXiv.2306.13204](https://doi.org/10.48550/arXiv.2306.13204). 1. Allred, T., Li, X., Wiersdorf, A., Greenman, B., and Gopalakrishnan, G. (2024). [FlowFPX: Nimble tools for debugging floating-point exceptions](https://doi.org/10.48550/arXiv.2403.15632), _arXiv_, arXiv:2403.15632. DOI: [10.48550/a",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md:5279,release,release,5279,docs/src/index.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md,1,['release'],['release']
Deployability,"3.069 s ‚îÇ 3.115 s ‚îÇ 23.03 MiB ‚îÇ 1034063 ‚îÇ 2 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò. Shallow water model weak multithreading scaling speedup; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ threads ‚îÇ slowdown ‚îÇ efficiency ‚îÇ memory ‚îÇ allocs ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ (8192, 512) ‚îÇ 1 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ; ‚îÇ (8192, 1024) ‚îÇ 2 ‚îÇ 2.04972 ‚îÇ 0.487872 ‚îÇ 13.2156 ‚îÇ 464.601 ‚îÇ; ‚îÇ (8192, 2048) ‚îÇ 4 ‚îÇ 1.63302 ‚îÇ 0.612363 ‚îÇ 9.95278 ‚îÇ 327.951 ‚îÇ; ‚îÇ (8192, 4096) ‚îÇ 8 ‚îÇ 1.62507 ‚îÇ 0.615359 ‚îÇ 11.9706 ‚îÇ 384.754 ‚îÇ; ‚îÇ (8192, 8192) ‚îÇ 16 ‚îÇ 1.74747 ‚îÇ 0.572257 ‚îÇ 12.755 ‚îÇ 372.71 ‚îÇ; ‚îÇ (8192, 16384) ‚îÇ 32 ‚îÇ 2.10486 ‚îÇ 0.47509 ‚îÇ 16.846 ‚îÇ 446.101 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò; ```. ### Strong Scaling Multithreaded Nonhydrostatic Model. The notable and continuous decrease in efficiencies for the strong scaling nonhydrostatic model is likely caused by the `256^3` grid not sufficiently saturating 32 threads running on 32 CPUs. At the time this benchmark was produced, multithreading for both nonhydrostatic and shallow water models is still an active area of improvement. Please use the appropriate scripts found in [`benchmarks`](https://github.com/CliMA/Oceananigans.jl/tree/main/benchmark) to obtain more recent and hopefully ameliorated benchmark results. ```; Oceananigans v0.58.9; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; EBVERSIONJULIA = 1.6.1; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel; JULIA_LOAD_PATH = ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:28324,continuous,continuous,28324,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['continuous'],['continuous']
Deployability,"309.06662)), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans.jl is developed by the [Climate Modeling Alliance](https://clima.caltech.edu) and heroic external collaborators. ## Contents. - [Contents](#contents); - [Installation instructions](#installation-instructions); - [Running your first model](#running-your-first-model); - [The Oceananigans knowledge base](#the-oceananigans-knowledge-base); - [Citing](#citing); - [Contributing](#contributing); - [Movies](#movies); - [Deep convection](#deep-convection); - [Free convection](#free-convection); - [Winds blowing over the ocean](#winds-blowing-over-the-ocean); - [Free convection with wind stress](#free-convection-with-wind-stress); - [Performance benchmarks](#performance-benchmarks). ## Installation instructions. Oceananigans is a [registered Julia package](https://julialang.org/packages/). So to install it,. 1. [Download Julia](https://julialang.org/downloads/) (version 1.9 or later). 2. Launch Julia and type. ```julia; julia> using Pkg. julia> Pkg.add(""Oceananigans""); ```. This installs the latest version that's _compatible with your current environment_.; Don't forget to *be careful* üèÑ and check which Oceananigans you installed:. ```julia; julia> Pkg.status(""Oceananigans""); ```. ## Running your first model. Let's run a two-dimensional, horizontally-periodic simulation of turbulence using 128¬≤ finite volume cells for 4 non-dimensional time units:. ```julia; using Oceananigans; grid = RectilinearGrid(CPU(), size=(128, 128), x=(0, 2œÄ), y=(0, 2œÄ), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO()); œµ(x, y) = 2rand() - 1; set!(model, u=œµ, v=œµ); simulation = Simulation(model; Œît=0.01, stop_time=4); run!(simulation); ```. But there's more: changing `CPU()` to `GPU()` makes this code run on a CUDA-enabled Nvidia GPU. Dive into [the documentation",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:4530,install,install,4530,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['install'],['install']
Deployability,"`M = 0``. Note that in deriving \eqref{eq:vertically-integrated-continuity},; we used the bottom boundary condition ``w_{\rm bottom} = \boldsymbol{u}_{\rm bottom} \boldsymbol{\cdot} \boldsymbol{\nabla}_h H``. To form a linear system that can be solved implicitly we recast the vertically-integrated continuity; equation \eqref{eq:vertically-integrated-continuity} into a discrete integral form. The best way to do; so is by starting from the discrete version of the continuity equation (in this case without any surface; volume flux, ``M = 0``). ```math; \begin{align}; \label{eq:continuity-discrete}; \delta_x (A_x u) + \delta_y (A_y v) + \delta_z (A_z w) = 0 \, ,; \end{align}; ```. and summing it vertically to get:. ```math; \begin{align}; \label{eq:vertically-integrated-continuity-discrete}; \delta_x \sum_k (A_x u) + \delta_y \sum_k (A_y v) + A_z \underbrace{w(k = N_z + 1)}_{w_{\rm top}} = 0 \, .; \end{align}; ```. In equations \eqref{eq:continuity-discrete} and \eqref{eq:vertically-integrated-continuity-discrete} and; here after, we have abused notation and used, e.g., ``u`` and ``v`` to denote the volume averages; over grid cells of the quantities ``u`` and ``v`` respectively. Using ``w_{\rm top} = \partial_t \eta`` and; being a bit more explicit on the locations the difference operators act on,; \eqref{eq:vertically-integrated-continuity-discrete} becomes:. ```math; \begin{equation}; \label{eq:semi-discrete-integral-continuity}; A_z \partial_t \eta + \delta_{x}^{caa} \sum_{k} (A_x u) + \delta_y^{aca} \sum_k (A_y v) = 0 \, .; \end{equation}; ```. We can now apply the velocity fractional step equation (discussed in the [Time-stepping section](@ref time_stepping)) for the [hydrostatic model](@ref hydrostatic_free_surface_model):. ```math; \begin{equation}; \label{eq:hydrostatic-fractional-step}; \boldsymbol{u}^{n+1} = \boldsymbol{u}^{\star} - g \Delta t \, \boldsymbol{\nabla} \eta^{n+1} \, .; \end{equation}; ```. We impose that the ``n+1``-th time step velocity is consist",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:13715,integrat,integrated-continuity-discrete,13715,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['integrat'],['integrated-continuity-discrete']
Deployability,"cale oceanic boundary layer; turbulence forced by a surface cooling in a horizontally periodic domain using; $256^3$ grid points. The upper layer is well-mixed by turbulent convection and; bounded below by a strong buoyancy interface. (Right) Simulation of; instability of a horizontal density gradient in a rotating channel using; $256\times512\times128$ grid points. A similar process called baroclinic; instability acting on basin-scale temperature gradients fills the oceans with; eddies that stir carbon and heat. Plots made with `matplotlib` [@Hunter2007]; and `cmocean` [@Thyng2016]. ``Oceananigans.jl`` leverages the Julia programming language [@Bezanson2017] to; implement high-level, low-cost abstractions, a friendly user interface, and a; high-performance model in one language and a common code base for execution on; the CPU or GPU with Julia‚Äôs native GPU compiler [@Besard2019]. Because Julia is; a high-level language, development is streamlined and users can flexibly specify; model configurations, set up arbitrary diagnostics and output, extend the code; base, and implement new features. Configuring a model with `architecture=CPU()`; or `architecture=GPU()` will execute the model on the CPU or GPU. By pinning a; simulation script against a specific version of Oceananigans, simulation results; are reproducible up to hardware differences. Performance benchmarks show significant speedups when running on a GPU. Large; simulations on an Nvidia Tesla V100 GPU require ~1 nanosecond per grid point per; iteration. GPU simulations are therefore roughly 3x more cost-effective; than CPU simulations on cloud computing platforms such as Google Cloud. A GPU; with 32 GB of memory can time-step models with ~150 million grid points assuming; five fields are being evolved; for example, three velocity components and; tracers for temperature and salinity. These performance gains permit the; long-time integration of realistic simulations, such as large eddy simulation of; oceanic boun",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md:2816,configurat,configurations,2816,paper/paper.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md,1,['configurat'],['configurations']
Deployability,"ce_model). The [`HydrostaticFreeSurfaceModel`](@ref) solves the incompressible Navier-Stokes equations under; the Boussinesq and hydrostatic approximations and with an arbitrary number of tracer conservation ; equations. Physics associated with individual terms in the momentum and tracer conservation; equations -- the background rotation rate of the equation's reference frame,; gravitational effects associated with buoyant tracers under the Boussinesq; approximation, generalized stresses and tracer fluxes associated with viscous and; diffusive physics, and arbitrary ""forcing functions"" -- are determined by the whims of the; user. ## Mass conservation and free surface evolution equation. The mass conservation equation is; ```math; 0 = \boldsymbol{\nabla}_h \boldsymbol{\cdot} \boldsymbol{u} + \partial_z w \, . ; ```. Given the horizontal flow ``\boldsymbol{u}`` we use the above to diagnose the vertical velocity ``w``.; We integrate the mass conservation equation from the bottom of the fluid (where ``w = 0``) up to; depth ``z`` and recover ``w(x, y, z, t)``. The free surface displacement ``\eta(x, y, t)`` satisfies the linearized kinematic boundary ; condition at the surface; ```math; \partial_t \eta = w(x, y, z=0, t) \, .; ```. ## The momentum conservation equation. The equations governing the conservation of momentum in a rotating fluid, including buoyancy; via the Boussinesq approximation are; ```math; \begin{align}; \partial_t \boldsymbol{u} & = - \left ( \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} \right ) \boldsymbol{u}; - \boldsymbol{f} \times \boldsymbol{u} ; - \boldsymbol{\nabla}_h (p + g \eta); - \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{\tau}; + \boldsymbol{F_u} \, , \label{eq:momentum}\\; 0 & = b - \partial_z p \, , \label{eq:hydrostatic}; \end{align}; ```; where ``b`` the is buoyancy, ``\boldsymbol{\tau}`` is the hydrostatic kinematic stress tensor, ; ``\boldsymbol{F_u}`` denotes an internal forcing of the horizontal flow ``\boldsymbol{u",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/hydrostatic_free_surface_model.md:1002,integrat,integrate,1002,docs/src/physics/hydrostatic_free_surface_model.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/hydrostatic_free_surface_model.md,1,['integrat'],['integrate']
Deployability,"d grid](@id finite_volume). The `Oceananigans.jl` staggered grid is defined by a rectilinear array of cuboids of horizontal dimensions ; ``\Delta x_{i, j, k}, \Delta y_{i, j, k}`` and vertical dimension ; ``\Delta z_{i, j, k}``, where ``(i, j, k)`` index the location of each cell in the staggered grid.; Note that the indices ``(i, j, k)`` increase with increasing coordinate ``(x, y, z)``. ![Schematic of staggered grid](assets/staggered_grid.png); *A schematic of `Oceananigans.jl` finite volumes for a two-dimensional staggered grid in ``(x, z)``.; Tracers ``c`` and pressure ``p`` are defined at the center of the control volume. The ``u`` control volumes are ; centered on the left and right edges of the pressure control volume while the ``w`` control volumes are centered ; on the top and bottom edges of the pressure control volumes. The indexing convention places the ``i^{\rm{th}}`` ; ``u``-node on cell ``x``-faces to the left of the ``i`` tracer point at cell centers.*. Dropping explicit indexing, the areas of cell faces are given by; ```math; A_x = \Delta y \Delta z, \quad A_y = \Delta x \Delta z, \quad A_z = \Delta x \Delta y \, ,; ```; so that each cell encloses a volume ``V = \Delta x \Delta y \Delta z``. A finite volume method discretizes a continuous quantity ``c`` by considering its average over a finite volume:; ```math; c_{i, j, k} \equiv \frac{1}{V_{i, j, k}} \int c(\boldsymbol{x}) \, \mathrm{d} V_{i, j, k} \, .; ```; The finite volumes that discretize each of ``u``, ``v``, and ``w`` are located on a grid which is ""staggered"" ; with respect to the grid that defines tracer finite volumes. ; The nodes, or central points of the velocity finite volumes are co-located with the faces of the tracer ; finite volume.; In particular, the ``u``-nodes are located in the center of the ""``x``-face"" (east of the tracer point), ; ``v``-nodes are located on ``y``-faces south of the tracer point, and ``w``-nodes are located on ; ``z``-faces downwards from the tracer point.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/finite_volume.md:1302,continuous,continuous,1302,docs/src/numerical_implementation/finite_volume.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/finite_volume.md,1,['continuous'],['continuous']
Deployability,"e the projection ; of the equation right hand side onto eigenvectors. So an eigenvector based approach to solving; the Poisson equation is not computationally efficient. For problems with grids that are non uniform in multiple directions, we use instead a pre-conditioned conjugate; gradient iterative solver. Such cases include curvilinear grids on the sphere and also telescoping cartesian; grids that stretch along more than one dimension. There are two forms of the pressure operator in this approach.; One is rigid lid form and one is an implicit free-surface form. ### Rigid lid pressure operator. The rigid lid operator is based on the same continuous form as is used in the Direct Method; solver. ### Implicit free surface pressure operator. The implicit free surface solver solves for the free-surface, ``\eta(x, y, t)``, in the vertically; integrated continuity equation:. ```math; \begin{equation}; \label{eq:vertically-integrated-continuity}; \partial_t \eta + \partial_x \left ( \int_{-H}^0 u \, \mathrm{d}z \right ) + \partial_y \left ( \int_{-H}^0 v \, \mathrm{d}z \right ) = M \, ,; \end{equation}; ```. where ``H(x, y)`` is the depth of the water column (to first order with respect to the free surface; elevation) and ``M`` is some surface volume flux (e.g., terms such as precipitation, evaporation and; runoff); currently Oceananigans.jl assumes ``M = 0``. Note that in deriving \eqref{eq:vertically-integrated-continuity},; we used the bottom boundary condition ``w_{\rm bottom} = \boldsymbol{u}_{\rm bottom} \boldsymbol{\cdot} \boldsymbol{\nabla}_h H``. To form a linear system that can be solved implicitly we recast the vertically-integrated continuity; equation \eqref{eq:vertically-integrated-continuity} into a discrete integral form. The best way to do; so is by starting from the discrete version of the continuity equation (in this case without any surface; volume flux, ``M = 0``). ```math; \begin{align}; \label{eq:continuity-discrete}; \delta_x (A_x u) + \delta_y (A_y",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:12286,integrat,integrated-continuity,12286,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['integrat'],['integrated-continuity']
Deployability,"ence of a zigzag pressure field: on a 1D; collocated grid the velocity at the point ``i`` is influenced by the pressure at points ``i-1`` and ``i+1``, and a zigzag; pressure field will be felt as a uniform pressure, which is obviously wrong and would reduce the accuracy of the; solution. The pressure is effectively taken from a coarser grid than what is actually used. The basic problem is that; the momentum equations will use the pressure difference between two alternate points when it should be using two; adjacent points. From the viewpoint of linear algebra, these spurious pressure modes correspond to solutions in the null space of the; pressure projection operator with eigenvalue zero and are thus indistinguishable from a uniform pressure field; [Sani81](@cite). The staggered grid was first introduced by [Harlow65](@citet) with their *marker and cell* method. In meteorology; and oceanography, this particular staggered grid configuration is referred to as the Arakawa C-grid after [Arakawa77](@citet), who; investigated four different staggered grids and the unstaggered A-grid for use in an atmospheric model. [Arakawa77](@citet) investigated the dispersion relation of inertia-gravity waves[^2] traveling in the ``x``-direction; ```math; \omega^2 = f^2 + gHk^2 \, ,; ```; in the linearized rotating shallow-water equations for five grids. Here ``\omega`` is the angular frequency, ``H`` is the; height of the fluid and ``k`` is the wavenumber in the ``x``-direction. Looking at the effect of spatial discretization; error on the frequency of these waves they find that the B and C-grids reproduce the dispersion relation most closely; out of the five [Arakawa77](@citet) (Figure 5). In particular, the dispersion relation for the C-grid is given by; ```math; \omega^2 = f^2 \left[ \cos^2 \left( \frac{k\Delta}{2} \right); + 4 \left( \frac{\lambda}{\Delta} \right)^2 \sin^2 \left( \frac{k\Delta}{2} \right) \right] \, ,; ```; where ``\lambda`` is the wavelength and ``\Delta`` is the",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/staggered_grid.md:2578,configurat,configuration,2578,docs/src/appendix/staggered_grid.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/staggered_grid.md,1,['configurat'],['configuration']
Deployability,"he [Climate Modeling Alliance](https://clima.caltech.edu) and heroic external collaborators. ## Contents. - [Contents](#contents); - [Installation instructions](#installation-instructions); - [Running your first model](#running-your-first-model); - [The Oceananigans knowledge base](#the-oceananigans-knowledge-base); - [Citing](#citing); - [Contributing](#contributing); - [Movies](#movies); - [Deep convection](#deep-convection); - [Free convection](#free-convection); - [Winds blowing over the ocean](#winds-blowing-over-the-ocean); - [Free convection with wind stress](#free-convection-with-wind-stress); - [Performance benchmarks](#performance-benchmarks). ## Installation instructions. Oceananigans is a [registered Julia package](https://julialang.org/packages/). So to install it,. 1. [Download Julia](https://julialang.org/downloads/) (version 1.9 or later). 2. Launch Julia and type. ```julia; julia> using Pkg. julia> Pkg.add(""Oceananigans""); ```. This installs the latest version that's _compatible with your current environment_.; Don't forget to *be careful* üèÑ and check which Oceananigans you installed:. ```julia; julia> Pkg.status(""Oceananigans""); ```. ## Running your first model. Let's run a two-dimensional, horizontally-periodic simulation of turbulence using 128¬≤ finite volume cells for 4 non-dimensional time units:. ```julia; using Oceananigans; grid = RectilinearGrid(CPU(), size=(128, 128), x=(0, 2œÄ), y=(0, 2œÄ), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO()); œµ(x, y) = 2rand() - 1; set!(model, u=œµ, v=œµ); simulation = Simulation(model; Œît=0.01, stop_time=4); run!(simulation); ```. But there's more: changing `CPU()` to `GPU()` makes this code run on a CUDA-enabled Nvidia GPU. Dive into [the documentation](https://clima.github.io/OceananigansDocumentation/stable/) for more code examples and tutorials.; Below, you'll find movies from GPU simulations along with CPU and GPU [performance benchmarks](https://github.com/clima/",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:4717,install,installs,4717,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['install'],['installs']
Deployability,"ic version of Oceananigans, simulation results; are reproducible up to hardware differences. Performance benchmarks show significant speedups when running on a GPU. Large; simulations on an Nvidia Tesla V100 GPU require ~1 nanosecond per grid point per; iteration. GPU simulations are therefore roughly 3x more cost-effective; than CPU simulations on cloud computing platforms such as Google Cloud. A GPU; with 32 GB of memory can time-step models with ~150 million grid points assuming; five fields are being evolved; for example, three velocity components and; tracers for temperature and salinity. These performance gains permit the; long-time integration of realistic simulations, such as large eddy simulation of; oceanic boundary layer turbulence over a seasonal cycle or the generation of; training data for turbulence parameterizations in Earth system models. ``Oceananigans.jl`` is continuously tested on CPUs and GPUs with unit tests,; integration tests, analytic solutions to the incompressible Navier-Stokes; equations, convergence tests, and verification experiments against published; scientific results. Future development plans include support for distributed; parallelism with CUDA-aware MPI as well as topography. Ocean models that are similar to ``Oceananigans.jl`` include MITgcm; [@Marshall1997] and MOM6 [@Adcroft2019], both written in Fortran. However,; ``Oceananigans.jl`` features a more efficient non-hydrostatic pressure solver; than MITgcm (and MOM6 is strictly hydrostatic). PALM [@Maronga2020] is Fortran; software for large eddy simulation of atmospheric and oceanic boundary layers; with complex boundaries on parallel CPU and GPU architectures. ``Oceananigans.jl``; is distinguished by its use of Julia which allows for a script-based interface as; opposed to a configuration-file-based interface used by MITgcm, MOM6, and PALM.; Dedalus [@Burns2020] is Python software with an intuitive script-based interface; that solves general partial differential equations, incl",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md:3976,continuous,continuously,3976,paper/paper.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md,2,"['continuous', 'integrat']","['continuously', 'integration']"
Deployability,"ict ourselves to a class of problems in which; ```math; \psi(x, y, t) = - f(x, t) g(y) \, , \quad \text{with} \quad f \equiv \cos [x - \xi(t)] \, , \quad; \xi(t) \equiv 1 + \sin(t^2) \, .; ```; Grinding through the algebra, this particular form implies that ``F_{\omega}`` is given by; ```math; F_{\omega} = -\xi^\prime f_x (g - g^{\prime\prime}) + f f_x (g g^{\prime\prime\prime} - g^\prime g^{\prime\prime}) + f (g - 2 g^{\prime\prime} + g^{\prime\prime\prime\prime}) \, ,; ```; where primes denote derivatives of functions of a single argument. ; Setting ``\partial_y F_v = F_{\omega}``, we find that if ``F_v`` satisfies; ```math; \partial_y F_v = (g^\prime)^2 + g g^{\prime\prime} \, ,; ```; then the pressure Poisson equation becomes; ```math; \nabla^2 p = \cos [2 (x - \xi)] [(g^\prime)^2 - g g^{\prime\prime}] + \partial_x F_v \, .; ```; This completes the specification of the problem. We set up the problem by imposing the time-dependent forcing functions ``F_u`` and ``F_v``; on ``u`` and ``v``, initializing the flow at ``t=0``, and integrating the problem forwards; in time using Oceananigans. We find the expected convergence of the numerical solution to the; analytical solution: the error between the numerical and analytical solutions; decreases with ``1/N_x^2 \sim \Delta x^2``, where ``N_x`` is the number of grid; points and ``\Delta x`` is the spatial resolution:. ![Forced free slip convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/forced_free_slip_convergence.png). The convergence tests are performed using both ``y`` and ``z`` as the bounded direction. ### Forced, free-slip flow. A forced flow satisfying free-slip conditions at ``y = 0`` and ``y = \pi`` has the streamfunction; ```math; \psi(x, y, t) = - \cos [x - \xi(t)] \sin (y) \, ,; ```; and thus ``g(y) = \sin y``. The velocity field ``(u, v)`` is; ```math; u = \cos (x - \xi) \cos y \, , \quad \text{and} \quad v = \sin (x - \xi) \sin y \, ,; ```; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md:7664,integrat,integrating,7664,docs/src/appendix/convergence_tests.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md,1,['integrat'],['integrating']
Deployability,"llaborators. ## Contents. - [Contents](#contents); - [Installation instructions](#installation-instructions); - [Running your first model](#running-your-first-model); - [The Oceananigans knowledge base](#the-oceananigans-knowledge-base); - [Citing](#citing); - [Contributing](#contributing); - [Movies](#movies); - [Deep convection](#deep-convection); - [Free convection](#free-convection); - [Winds blowing over the ocean](#winds-blowing-over-the-ocean); - [Free convection with wind stress](#free-convection-with-wind-stress); - [Performance benchmarks](#performance-benchmarks). ## Installation instructions. Oceananigans is a [registered Julia package](https://julialang.org/packages/). So to install it,. 1. [Download Julia](https://julialang.org/downloads/) (version 1.9 or later). 2. Launch Julia and type. ```julia; julia> using Pkg. julia> Pkg.add(""Oceananigans""); ```. This installs the latest version that's _compatible with your current environment_.; Don't forget to *be careful* üèÑ and check which Oceananigans you installed:. ```julia; julia> Pkg.status(""Oceananigans""); ```. ## Running your first model. Let's run a two-dimensional, horizontally-periodic simulation of turbulence using 128¬≤ finite volume cells for 4 non-dimensional time units:. ```julia; using Oceananigans; grid = RectilinearGrid(CPU(), size=(128, 128), x=(0, 2œÄ), y=(0, 2œÄ), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO()); œµ(x, y) = 2rand() - 1; set!(model, u=œµ, v=œµ); simulation = Simulation(model; Œît=0.01, stop_time=4); run!(simulation); ```. But there's more: changing `CPU()` to `GPU()` makes this code run on a CUDA-enabled Nvidia GPU. Dive into [the documentation](https://clima.github.io/OceananigansDocumentation/stable/) for more code examples and tutorials.; Below, you'll find movies from GPU simulations along with CPU and GPU [performance benchmarks](https://github.com/clima/Oceananigans.jl#performance-benchmarks). ## The Oceananigans knowledge base. It's",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:4861,install,installed,4861,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['install'],['installed']
Deployability,"lly-integrated continuity; equation \eqref{eq:vertically-integrated-continuity} into a discrete integral form. The best way to do; so is by starting from the discrete version of the continuity equation (in this case without any surface; volume flux, ``M = 0``). ```math; \begin{align}; \label{eq:continuity-discrete}; \delta_x (A_x u) + \delta_y (A_y v) + \delta_z (A_z w) = 0 \, ,; \end{align}; ```. and summing it vertically to get:. ```math; \begin{align}; \label{eq:vertically-integrated-continuity-discrete}; \delta_x \sum_k (A_x u) + \delta_y \sum_k (A_y v) + A_z \underbrace{w(k = N_z + 1)}_{w_{\rm top}} = 0 \, .; \end{align}; ```. In equations \eqref{eq:continuity-discrete} and \eqref{eq:vertically-integrated-continuity-discrete} and; here after, we have abused notation and used, e.g., ``u`` and ``v`` to denote the volume averages; over grid cells of the quantities ``u`` and ``v`` respectively. Using ``w_{\rm top} = \partial_t \eta`` and; being a bit more explicit on the locations the difference operators act on,; \eqref{eq:vertically-integrated-continuity-discrete} becomes:. ```math; \begin{equation}; \label{eq:semi-discrete-integral-continuity}; A_z \partial_t \eta + \delta_{x}^{caa} \sum_{k} (A_x u) + \delta_y^{aca} \sum_k (A_y v) = 0 \, .; \end{equation}; ```. We can now apply the velocity fractional step equation (discussed in the [Time-stepping section](@ref time_stepping)) for the [hydrostatic model](@ref hydrostatic_free_surface_model):. ```math; \begin{equation}; \label{eq:hydrostatic-fractional-step}; \boldsymbol{u}^{n+1} = \boldsymbol{u}^{\star} - g \Delta t \, \boldsymbol{\nabla} \eta^{n+1} \, .; \end{equation}; ```. We impose that the ``n+1``-th time step velocity is consistent with \eqref{eq:semi-discrete-integral-continuity}. ```math; \begin{equation}; A_z \frac{\eta^{n+1} - \eta^{n}}{\Delta t} = - \delta_x^{caa} \sum_k (A_x u^{n+1}) - \delta_y^{aca} \sum_k (A_y v^{n+1}) \, .; \end{equation}; ```. Substituting ``u^{n+1}`` and ``v^{n+1}`` from the disc",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:14058,integrat,integrated-continuity-discrete,14058,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['integrat'],['integrated-continuity-discrete']
Deployability,"mg alt=""Docker build status"" src=""https://img.shields.io/docker/cloud/build/aliramadhan/oceananigans?label=Docker&logo=docker&logoColor=white&style=flat-square"">; </a>; </p>. Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic; and hydrostatic Boussinesq equations on CPUs and GPUs.; It runs on GPUs (wow, [fast!](http://arxiv.org/abs/2309.06662)), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans.jl is developed by the [Climate Modeling Alliance](https://clima.caltech.edu) and heroic external collaborators. ## Contents. - [Contents](#contents); - [Installation instructions](#installation-instructions); - [Running your first model](#running-your-first-model); - [The Oceananigans knowledge base](#the-oceananigans-knowledge-base); - [Citing](#citing); - [Contributing](#contributing); - [Movies](#movies); - [Deep convection](#deep-convection); - [Free convection](#free-convection); - [Winds blowing over the ocean](#winds-blowing-over-the-ocean); - [Free convection with wind stress](#free-convection-with-wind-stress); - [Performance benchmarks](#performance-benchmarks). ## Installation instructions. Oceananigans is a [registered Julia package](https://julialang.org/packages/). So to install it,. 1. [Download Julia](https://julialang.org/downloads/) (version 1.9 or later). 2. Launch Julia and type. ```julia; julia> using Pkg. julia> Pkg.add(""Oceananigans""); ```. This installs the latest version that's _compatible with your current environment_.; Don't forget to *be careful* üèÑ and check which Oceananigans you installed:. ```julia; julia> Pkg.status(""Oceananigans""); ```. ## Running your first model. Let's run a two-dimensional, horizontally-periodic simulation of turbulence using 128¬≤ finite volume cells for 4 non-dimensional time units:. ```julia; using Oceananigans; grid = Recti",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:3915,install,installation-instructions,3915,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['install'],['installation-instructions']
Deployability,"nfigurations, set up arbitrary diagnostics and output, extend the code; base, and implement new features. Configuring a model with `architecture=CPU()`; or `architecture=GPU()` will execute the model on the CPU or GPU. By pinning a; simulation script against a specific version of Oceananigans, simulation results; are reproducible up to hardware differences. Performance benchmarks show significant speedups when running on a GPU. Large; simulations on an Nvidia Tesla V100 GPU require ~1 nanosecond per grid point per; iteration. GPU simulations are therefore roughly 3x more cost-effective; than CPU simulations on cloud computing platforms such as Google Cloud. A GPU; with 32 GB of memory can time-step models with ~150 million grid points assuming; five fields are being evolved; for example, three velocity components and; tracers for temperature and salinity. These performance gains permit the; long-time integration of realistic simulations, such as large eddy simulation of; oceanic boundary layer turbulence over a seasonal cycle or the generation of; training data for turbulence parameterizations in Earth system models. ``Oceananigans.jl`` is continuously tested on CPUs and GPUs with unit tests,; integration tests, analytic solutions to the incompressible Navier-Stokes; equations, convergence tests, and verification experiments against published; scientific results. Future development plans include support for distributed; parallelism with CUDA-aware MPI as well as topography. Ocean models that are similar to ``Oceananigans.jl`` include MITgcm; [@Marshall1997] and MOM6 [@Adcroft2019], both written in Fortran. However,; ``Oceananigans.jl`` features a more efficient non-hydrostatic pressure solver; than MITgcm (and MOM6 is strictly hydrostatic). PALM [@Maronga2020] is Fortran; software for large eddy simulation of atmospheric and oceanic boundary layers; with complex boundaries on parallel CPU and GPU architectures. ``Oceananigans.jl``; is distinguished by its use of Juli",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md:3732,integrat,integration,3732,paper/paper.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md,1,['integrat'],['integration']
Deployability,"ore roughly 3x more cost-effective; than CPU simulations on cloud computing platforms such as Google Cloud. A GPU; with 32 GB of memory can time-step models with ~150 million grid points assuming; five fields are being evolved; for example, three velocity components and; tracers for temperature and salinity. These performance gains permit the; long-time integration of realistic simulations, such as large eddy simulation of; oceanic boundary layer turbulence over a seasonal cycle or the generation of; training data for turbulence parameterizations in Earth system models. ``Oceananigans.jl`` is continuously tested on CPUs and GPUs with unit tests,; integration tests, analytic solutions to the incompressible Navier-Stokes; equations, convergence tests, and verification experiments against published; scientific results. Future development plans include support for distributed; parallelism with CUDA-aware MPI as well as topography. Ocean models that are similar to ``Oceananigans.jl`` include MITgcm; [@Marshall1997] and MOM6 [@Adcroft2019], both written in Fortran. However,; ``Oceananigans.jl`` features a more efficient non-hydrostatic pressure solver; than MITgcm (and MOM6 is strictly hydrostatic). PALM [@Maronga2020] is Fortran; software for large eddy simulation of atmospheric and oceanic boundary layers; with complex boundaries on parallel CPU and GPU architectures. ``Oceananigans.jl``; is distinguished by its use of Julia which allows for a script-based interface as; opposed to a configuration-file-based interface used by MITgcm, MOM6, and PALM.; Dedalus [@Burns2020] is Python software with an intuitive script-based interface; that solves general partial differential equations, including the incompressible; Navier-Stokes equations, with spectral methods. # Acknowledgements. Our work is supported by the generosity of Eric and Wendy Schmidt by; recommendation of the Schmidt Futures program, and by the National Science; Foundation under grant AGS-6939393. # References; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md:4880,configurat,configuration-file-based,4880,paper/paper.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md,1,['configurat'],['configuration-file-based']
Deployability,"ps://www.repostatus.org/#active"">; <img alt=""Repo status"" src=""https://www.repostatus.org/badges/latest/active.svg?style=flat-square"" />; </a>; <a href=""https://mit-license.org"">; <img alt=""MIT license"" src=""https://img.shields.io/badge/License-MIT-blue.svg?style=flat-square"">; </a>; <a href=""https://github.com/CliMA/Oceananigans.jl/discussions"">; <img alt=""Ask us anything"" src=""https://img.shields.io/badge/Ask%20us-anything-1abc9c.svg?style=flat-square"">; </a>; <a href=""https://github.com/SciML/ColPrac"">; <img alt=""ColPrac: Contributor's Guide on Collaborative Practices for Community Packages"" src=""https://img.shields.io/badge/ColPrac-Contributor's%20Guide-blueviolet?style=flat-square"">; </a>; <a href=""https://doi.org/10.21105/joss.02018"">; <img alt=""JOSS"" src=""https://joss.theoj.org/papers/10.21105/joss.02018/status.svg"">; </a>; </p>. <!-- Version and documentation badges -->; <p align=""center"">; <a href=""https://github.com/CliMA/Oceananigans.jl/releases"">; <img alt=""GitHub tag (latest SemVer pre-release)"" src=""https://img.shields.io/github/v/tag/CliMA/Oceananigans.jl?include_prereleases&label=latest%20version&logo=github&sort=semver&style=flat-square"">; </a>; <a href=""https://clima.github.io/OceananigansDocumentation/stable"">; <img alt=""Stable documentation"" src=""https://img.shields.io/badge/documentation-stable%20release-blue?style=flat-square"">; </a>; <a href=""https://clima.github.io/OceananigansDocumentation/dev"">; <img alt=""Development documentation"" src=""https://img.shields.io/badge/documentation-in%20development-orange?style=flat-square"">; </a>; </p>. <!-- Downloads -->; <!-- counts downloads from individual IPs excluding bots (eg, CI) -->; <!-- see https://discourse.julialang.org/t/announcing-package-download-stats/69073 -->. <p align=""center"">; <a href=""https://juliapkgstats.com/pkg/Oceananigans"">; <img alt=""Downloads per month"" src=""https://img.shields.io/badge/dynamic/json?url=http%3A%2F%2Fjuliapkgstats.com%2Fapi%2Fv1%2Fmonthly_downloads%2FOceananigans&",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:1361,release,releases,1361,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,2,['release'],"['release', 'releases']"
Deployability,"s used in the Direct Method; solver. ### Implicit free surface pressure operator. The implicit free surface solver solves for the free-surface, ``\eta(x, y, t)``, in the vertically; integrated continuity equation:. ```math; \begin{equation}; \label{eq:vertically-integrated-continuity}; \partial_t \eta + \partial_x \left ( \int_{-H}^0 u \, \mathrm{d}z \right ) + \partial_y \left ( \int_{-H}^0 v \, \mathrm{d}z \right ) = M \, ,; \end{equation}; ```. where ``H(x, y)`` is the depth of the water column (to first order with respect to the free surface; elevation) and ``M`` is some surface volume flux (e.g., terms such as precipitation, evaporation and; runoff); currently Oceananigans.jl assumes ``M = 0``. Note that in deriving \eqref{eq:vertically-integrated-continuity},; we used the bottom boundary condition ``w_{\rm bottom} = \boldsymbol{u}_{\rm bottom} \boldsymbol{\cdot} \boldsymbol{\nabla}_h H``. To form a linear system that can be solved implicitly we recast the vertically-integrated continuity; equation \eqref{eq:vertically-integrated-continuity} into a discrete integral form. The best way to do; so is by starting from the discrete version of the continuity equation (in this case without any surface; volume flux, ``M = 0``). ```math; \begin{align}; \label{eq:continuity-discrete}; \delta_x (A_x u) + \delta_y (A_y v) + \delta_z (A_z w) = 0 \, ,; \end{align}; ```. and summing it vertically to get:. ```math; \begin{align}; \label{eq:vertically-integrated-continuity-discrete}; \delta_x \sum_k (A_x u) + \delta_y \sum_k (A_y v) + A_z \underbrace{w(k = N_z + 1)}_{w_{\rm top}} = 0 \, .; \end{align}; ```. In equations \eqref{eq:continuity-discrete} and \eqref{eq:vertically-integrated-continuity-discrete} and; here after, we have abused notation and used, e.g., ``u`` and ``v`` to denote the volume averages; over grid cells of the quantities ``u`` and ``v`` respectively. Using ``w_{\rm top} = \partial_t \eta`` and; being a bit more explicit on the locations the difference opera",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:13010,integrat,integrated,13010,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,2,['integrat'],"['integrated', 'integrated-continuity']"
Deployability,"st order with respect to the free surface; elevation) and ``M`` is some surface volume flux (e.g., terms such as precipitation, evaporation and; runoff); currently Oceananigans.jl assumes ``M = 0``. Note that in deriving \eqref{eq:vertically-integrated-continuity},; we used the bottom boundary condition ``w_{\rm bottom} = \boldsymbol{u}_{\rm bottom} \boldsymbol{\cdot} \boldsymbol{\nabla}_h H``. To form a linear system that can be solved implicitly we recast the vertically-integrated continuity; equation \eqref{eq:vertically-integrated-continuity} into a discrete integral form. The best way to do; so is by starting from the discrete version of the continuity equation (in this case without any surface; volume flux, ``M = 0``). ```math; \begin{align}; \label{eq:continuity-discrete}; \delta_x (A_x u) + \delta_y (A_y v) + \delta_z (A_z w) = 0 \, ,; \end{align}; ```. and summing it vertically to get:. ```math; \begin{align}; \label{eq:vertically-integrated-continuity-discrete}; \delta_x \sum_k (A_x u) + \delta_y \sum_k (A_y v) + A_z \underbrace{w(k = N_z + 1)}_{w_{\rm top}} = 0 \, .; \end{align}; ```. In equations \eqref{eq:continuity-discrete} and \eqref{eq:vertically-integrated-continuity-discrete} and; here after, we have abused notation and used, e.g., ``u`` and ``v`` to denote the volume averages; over grid cells of the quantities ``u`` and ``v`` respectively. Using ``w_{\rm top} = \partial_t \eta`` and; being a bit more explicit on the locations the difference operators act on,; \eqref{eq:vertically-integrated-continuity-discrete} becomes:. ```math; \begin{equation}; \label{eq:semi-discrete-integral-continuity}; A_z \partial_t \eta + \delta_{x}^{caa} \sum_{k} (A_x u) + \delta_y^{aca} \sum_k (A_y v) = 0 \, .; \end{equation}; ```. We can now apply the velocity fractional step equation (discussed in the [Time-stepping section](@ref time_stepping)) for the [hydrostatic model](@ref hydrostatic_free_surface_model):. ```math; \begin{equation}; \label{eq:hydrostatic-fraction",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:13487,integrat,integrated-continuity-discrete,13487,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['integrat'],['integrated-continuity-discrete']
Deployability,"tic; and hydrostatic Boussinesq equations on CPUs and GPUs.; It runs on GPUs (wow, fast!), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans is written in Julia by the [Climate Modeling Alliance](https://clima.caltech.edu); and heroic external collaborators. ## Quick install. Oceananigans is a [registered Julia package](https://julialang.org/packages/). So to install it,. 1. [Download Julia](https://julialang.org/downloads/). 2. Launch Julia and type. ```julia; julia> using Pkg. julia> Pkg.add(""Oceananigans""); ```. !!! compat ""Julia 1.9 is required""; Oceananigans requires Julia 1.9 or later. If you're [new to Julia](https://docs.julialang.org/en/v1/manual/getting-started/) and its [wonderful `Pkg` manager](https://docs.julialang.org/en/v1/stdlib/Pkg/), the [Oceananigans wiki](https://github.com/CliMA/Oceananigans.jl/wiki) provides [more detailed installation instructions](https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans). ## The Oceananigans ""knowledge base"". It's _deep_ and includes:. * This documentation, which provides; * example Oceananigans scripts,; * tutorials that describe key Oceananigans objects and functions,; * explanations of Oceananigans finite-volume-based numerical methods,; * details of the dynamical equations solved by Oceananigans models, and; * a library documenting all user-facing Oceananigans objects and functions.; * [Discussions on the Oceananigans github](https://github.com/CliMA/Oceananigans.jl/discussions), covering topics like; * [""Computational science""](https://github.com/CliMA/Oceananigans.jl/discussions/categories/computational-science), or how to science and set up numerical simulations in Oceananigans, and; * [""Experimental features""](https://github.com/CliMA/Oceananigans.jl/discussions?discussions_q=experimental+features), which covers new and sparse",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md:1179,install,installation,1179,docs/src/index.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md,1,['install'],['installation']
Deployability,"tilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, forcing=(w=w_forcing, S=S_forcing), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S)). model.forcing.w. # output; ContinuousForcing{Nothing} at (Center, Center, Face); ‚îú‚îÄ‚îÄ func: w_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:u, :v, :w); ```. ```jldoctest field_dependent_forcing; model.forcing.S. # output; ContinuousForcing{Float64} at (Center, Center, Center); ‚îú‚îÄ‚îÄ func: S_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: 0.01; ‚îî‚îÄ‚îÄ field dependencies: (:S,); ```. The `field_dependencies` arguments follow `x, y, z, t` in the forcing `func`tion in; the order they are specified in `Forcing`.; If both `field_dependencies` and `parameters` are specified, then the `field_dependencies`; arguments follow `x, y, z, t`, and `parameters` follow `field_dependencies`. Model fields that arise in the arguments of continuous `Forcing` `func`tions are; automatically interpolated to the staggered grid location at which the forcing is applied. ### ""Discrete form"" forcing functions. ""Discrete form"" forcing functions are either called with the signature. ```julia; func(i, j, k, grid, clock, model_fields); ```. or the parameterized form. ```julia; func(i, j, k, grid, clock, model_fields, parameters); ```. Discrete form forcing functions can access the entirety of model field; data through the argument `model_fields`. The object `model_fields` is a `NamedTuple`; whose properties include the velocity fields `model_fields.u`, `model_fields.v`,; `model_fields.w` and all fields in `model.tracers`. Using discrete forcing functions may require understanding the; staggered arrangement of velocity fields and tracers in `Oceananigans`.; Here's a slightly non-sensical example in which the vertical derivative of a buoyancy; tracer is used as a time-scale for damping the u-velocity field:. ```jldoctest discrete_forcing; # A damping term that depends on a ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:5396,continuous,continuous,5396,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['continuous'],['continuous']
Deployability,"ular grids the eigenvectors of the discrete Poisson operator are no longer simple Fourier; series sines and cosines. This means discrete Fast Fourier Transforms can't be used to generate the projection ; of the equation right hand side onto eigenvectors. So an eigenvector based approach to solving; the Poisson equation is not computationally efficient. For problems with grids that are non uniform in multiple directions, we use instead a pre-conditioned conjugate; gradient iterative solver. Such cases include curvilinear grids on the sphere and also telescoping cartesian; grids that stretch along more than one dimension. There are two forms of the pressure operator in this approach.; One is rigid lid form and one is an implicit free-surface form. ### Rigid lid pressure operator. The rigid lid operator is based on the same continuous form as is used in the Direct Method; solver. ### Implicit free surface pressure operator. The implicit free surface solver solves for the free-surface, ``\eta(x, y, t)``, in the vertically; integrated continuity equation:. ```math; \begin{equation}; \label{eq:vertically-integrated-continuity}; \partial_t \eta + \partial_x \left ( \int_{-H}^0 u \, \mathrm{d}z \right ) + \partial_y \left ( \int_{-H}^0 v \, \mathrm{d}z \right ) = M \, ,; \end{equation}; ```. where ``H(x, y)`` is the depth of the water column (to first order with respect to the free surface; elevation) and ``M`` is some surface volume flux (e.g., terms such as precipitation, evaporation and; runoff); currently Oceananigans.jl assumes ``M = 0``. Note that in deriving \eqref{eq:vertically-integrated-continuity},; we used the bottom boundary condition ``w_{\rm bottom} = \boldsymbol{u}_{\rm bottom} \boldsymbol{\cdot} \boldsymbol{\nabla}_h H``. To form a linear system that can be solved implicitly we recast the vertically-integrated continuity; equation \eqref{eq:vertically-integrated-continuity} into a discrete integral form. The best way to do; so is by starting from the discret",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:12205,integrat,integrated,12205,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['integrat'],['integrated']
Deployability,"urbulence simulation with `128¬≤` [finite volume](https://en.wikipedia.org/wiki/Finite_volume_method) cells; and a fifth-order upwinded [WENO advection scheme](https://en.wikipedia.org/wiki/WENO_methods).; It's quite similar to the [two-dimensional turbulence example](https://clima.github.io/OceananigansDocumentation/stable/generated/two_dimensional_turbulence/). ## Visualization. They say that a [Makie](https://makie.juliaplots.org/stable/) visualization is worth a thousand Unicode characters, so let's plot vorticity,. ```@example cpu; using CairoMakie. u, v, w = model.velocities; Œ∂ = Field(‚àÇx(v) - ‚àÇy(u)); compute!(Œ∂). heatmap(Œ∂, axis=(; aspect=1)); ```. A few more time-steps, and it's starting to get a little diffuse!. ```@example cpu; simulation.stop_iteration += 400; run!(simulation). compute!(Œ∂); heatmap(Œ∂, axis=(; aspect=1)); ```. ## They always cheat with too-simple ""quick"" starts. Fine, we'll re-run this code on the GPU. But we're a little greedy, so we'll also; crank up the resolution, throw in a `TimeStepWizard` to update `simulation.Œît` adaptively,; and add a passive tracer initially concentrated in the center of the domain; which will make for an even prettier figure of the final state:. ```@setup gpu; using CairoMakie; CairoMakie.activate!(type = ""png""); ```. ```@example gpu; using Oceananigans; using CairoMakie. grid = RectilinearGrid(GPU(),; size = (1024, 1024),; x = (-œÄ, œÄ),; y = (-œÄ, œÄ),; topology = (Periodic, Periodic, Flat)). model = NonhydrostaticModel(; grid, advection=WENO(), tracers=:c). Œ¥ = 0.5; c·µ¢(x, y) = exp(-(x^2 + y^2) / 2Œ¥^2); œµ(x, y) = 2rand() - 1; set!(model, u=œµ, v=œµ, c=c·µ¢). simulation = Simulation(model; Œît=1e-3, stop_time=10); conjure_time_step_wizard!(simulation, cfl=0.2, IterationInterval(10)); run!(simulation). u, v, w = model.velocities; Œ∂ = Field(‚àÇx(v) - ‚àÇy(u)); compute!(Œ∂). fig = Figure(size=(1200, 600)); axŒ∂ = Axis(fig[1, 1], aspect=1, title=""vorticity""); axc = Axis(fig[1, 2], aspect=1, title=""tracer""); heatmap!(axŒ∂, Œ∂, colorm",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/quick_start.md:1516,update,update,1516,docs/src/quick_start.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/quick_start.md,1,['update'],['update']
Deployability,"ure operator in this approach.; One is rigid lid form and one is an implicit free-surface form. ### Rigid lid pressure operator. The rigid lid operator is based on the same continuous form as is used in the Direct Method; solver. ### Implicit free surface pressure operator. The implicit free surface solver solves for the free-surface, ``\eta(x, y, t)``, in the vertically; integrated continuity equation:. ```math; \begin{equation}; \label{eq:vertically-integrated-continuity}; \partial_t \eta + \partial_x \left ( \int_{-H}^0 u \, \mathrm{d}z \right ) + \partial_y \left ( \int_{-H}^0 v \, \mathrm{d}z \right ) = M \, ,; \end{equation}; ```. where ``H(x, y)`` is the depth of the water column (to first order with respect to the free surface; elevation) and ``M`` is some surface volume flux (e.g., terms such as precipitation, evaporation and; runoff); currently Oceananigans.jl assumes ``M = 0``. Note that in deriving \eqref{eq:vertically-integrated-continuity},; we used the bottom boundary condition ``w_{\rm bottom} = \boldsymbol{u}_{\rm bottom} \boldsymbol{\cdot} \boldsymbol{\nabla}_h H``. To form a linear system that can be solved implicitly we recast the vertically-integrated continuity; equation \eqref{eq:vertically-integrated-continuity} into a discrete integral form. The best way to do; so is by starting from the discrete version of the continuity equation (in this case without any surface; volume flux, ``M = 0``). ```math; \begin{align}; \label{eq:continuity-discrete}; \delta_x (A_x u) + \delta_y (A_y v) + \delta_z (A_z w) = 0 \, ,; \end{align}; ```. and summing it vertically to get:. ```math; \begin{align}; \label{eq:vertically-integrated-continuity-discrete}; \delta_x \sum_k (A_x u) + \delta_y \sum_k (A_y v) + A_z \underbrace{w(k = N_z + 1)}_{w_{\rm top}} = 0 \, .; \end{align}; ```. In equations \eqref{eq:continuity-discrete} and \eqref{eq:vertically-integrated-continuity-discrete} and; here after, we have abused notation and used, e.g., ``u`` and ``v`` to denote t",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:12775,integrat,integrated-continuity,12775,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['integrat'],['integrated-continuity']
Energy Efficiency," 0.408879 ‚îÇ 0.992685 ‚îÇ 1.33816 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 64, 1) ‚îÇ 17.0612 ‚îÇ 0.266582 ‚îÇ 1.03519 ‚îÇ 1.5735 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 128, 1) ‚îÇ 25.409 ‚îÇ 0.198508 ‚îÇ 1.16772 ‚îÇ 2.03693 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò; ```. ![ss_nonhydrostatic_efficiency](https://user-images.githubusercontent.com/45054739/130146219-b354fa25-7d77-4206-8e7e-ec639b2250fa.png). ## Multithreading. Oceananigans can also achieve parallelism via multithreading. Though its efficiencies are less than that of the MPI distributed architectures, its simple setup still makes it a viable option for achieving speedups on simple systems. ### Weak Scaling Multithreaded Shallow Water Model. The initial drop and then rise in efficiencies going from 1 to 2 to 4 threads is likely caused by the 2 threads being automatically allocated onto only one physical CPU core. Though one physical CPU core may contain 2 logical cores each capable of running a separate thread, having 2 threads run on one core will still reduce efficiencies as many resources such as caches and buses must be shared by both threads. Note that there are as many CPU cores allocated as the maximum number of threads. ```; Oceananigans v0.58.9; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :. Shallow water model weak scaling with multithreading benchmark; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ threads ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allo",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:25835,reduce,reduce,25835,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['reduce'],['reduce']
Energy Efficiency," 1.0) regularly spaced with Œîy=1.0; ‚îî‚îÄ‚îÄ Bounded z ‚àà [-1.0, 0.0] regularly spaced with Œîz=1.0. julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ‚îú‚îÄ‚îÄ grid: 1√ó1√ó1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ timestepper: RungeKutta3TimeStepper; ‚îú‚îÄ‚îÄ tracers: (); ‚îú‚îÄ‚îÄ closure: Nothing; ‚îú‚îÄ‚îÄ buoyancy: Nothing; ‚îî‚îÄ‚îÄ coriolis: Nothing. julia> typeof(model.velocities.u.data); OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}. julia> adapt(Array, model.velocities.u.data); 3√ó3√ó3 OffsetArray(::Array{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2√ó0:2√ó0:2:; [:, :, 0] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 1] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0; ```. Notice that to view the `CuArray` that stores values for `u` we first need to transform; it into a regular `Array` using `Adapt.adapt`. If we naively try to view the `CuArray`; without that step we get an error:. ```julia; julia> model.velocities.u.data; 3√ó3√ó3 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2√ó0:2√ó0:2:; [:, :, 0] =; Error showing value of type OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}:; ERROR: Scalar indexing is disallowed.; ```. Here `CUDA.jl` throws an error because scalar `getindex` is not `allowed`. There are ways to; overcome this limitation and allow scalar indexing (more about that ; in the [CUDA.jl documentation](https://cuda.juliagpu.org/stable/usage/workflow/#UsageWorkflowScalar)), but this option; can be very slow on GPUs, so it is advised to only use this last method when using the REPL or ; prototyping -- never in production-ready scripts. You might also need to keep these differences in mind when using arrays; to define initial conditions, boundary conditions or; forcing functio",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:12818,adapt,adapt,12818,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['adapt'],['adapt']
Energy Efficiency," 1.16772 ‚îÇ 2.03693 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò; ```. ![ss_nonhydrostatic_efficiency](https://user-images.githubusercontent.com/45054739/130146219-b354fa25-7d77-4206-8e7e-ec639b2250fa.png). ## Multithreading. Oceananigans can also achieve parallelism via multithreading. Though its efficiencies are less than that of the MPI distributed architectures, its simple setup still makes it a viable option for achieving speedups on simple systems. ### Weak Scaling Multithreaded Shallow Water Model. The initial drop and then rise in efficiencies going from 1 to 2 to 4 threads is likely caused by the 2 threads being automatically allocated onto only one physical CPU core. Though one physical CPU core may contain 2 logical cores each capable of running a separate thread, having 2 threads run on one core will still reduce efficiencies as many resources such as caches and buses must be shared by both threads. Note that there are as many CPU cores allocated as the maximum number of threads. ```; Oceananigans v0.58.9; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :. Shallow water model weak scaling with multithreading benchmark; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ threads ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ samples ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ (8192, 512) ‚îÇ 1 ‚îÇ 1.458 s ‚îÇ 1.458 s ‚îÇ 1.4",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:25968,allocate,allocated,25968,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['allocate'],['allocated']
Energy Efficiency," 2, 3)). model = NonhydrostaticModel(grid=grid). simulation = Simulation(model, Œît=1.25, stop_iteration=3). f(model) = model.clock.time^2; # scalar output. g(model) = model.clock.time .* exp.(znodes(grid, Center())) # single-column profile output (vector). xC, yF = xnodes(grid, Center()), ynodes(grid, Face()). XC = [xC[i] for i in 1:Nx, j in 1:Ny]; YF = [yF[j] for i in 1:Nx, j in 1:Ny]. h(model) = @. model.clock.time * sin(XC) * cos(YF) # x-y slice output (2D array). outputs = Dict(""scalar"" => f, ""profile"" => g, ""slice"" => h). dims = Dict(""scalar"" => (), ""profile"" => (""zC"",), ""slice"" => (""xC"", ""yC"")). output_attributes = Dict(; ""scalar"" => Dict(""longname"" => ""Some scalar"", ""units"" => ""bananas""),; ""profile"" => Dict(""longname"" => ""Some vertical profile"", ""units"" => ""watermelons""),; ""slice"" => Dict(""longname"" => ""Some slice"", ""units"" => ""mushrooms""); ). global_attributes = Dict(""location"" => ""Bay of Fundy"", ""onions"" => 7). simulation.output_writers[:things] =; NetCDFOutputWriter(model, outputs,; schedule=IterationInterval(1), filename=""things.nc"", dimensions=dims, verbose=true,; global_attributes=global_attributes, output_attributes=output_attributes); ```. `NetCDFOutputWriter` can also be configured for `outputs` that are interpolated or regridded; to a different grid than `model.grid`. To use this functionality, include the keyword argument; `grid = output_grid`. ```@example; using Oceananigans; using Oceananigans.Fields: interpolate!. grid = RectilinearGrid(size=(1, 1, 8), extent=(1, 1, 1));; model = NonhydrostaticModel(; grid). coarse_grid = RectilinearGrid(size=(grid.Nx, grid.Ny, grid.Nz√∑2), extent=(grid.Lx, grid.Ly, grid.Lz)); coarse_u = Field{Face, Center, Center}(coarse_grid). interpolate_u(model) = interpolate!(coarse_u, model.velocities.u); outputs = (; u = interpolate_u). output_writer = NetCDFOutputWriter(model, outputs;; grid = coarse_grid,; filename = ""coarse_u.nc"",; schedule = IterationInterval(1)); ```. See [`NetCDFOutputWriter`](@ref) for more informati",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md:5132,schedul,schedule,5132,docs/src/model_setup/output_writers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md,1,['schedul'],['schedule']
Energy Efficiency," ```. and a time- and horizontal-average of tracer `c` every 20 minutes of simulation time; to a file called `some_more_averaged_data.jld2`. ```@example jld2_output_writer; simulation.output_writers[:avg_c] = JLD2OutputWriter(model, (; c=c_avg),; filename = ""some_more_averaged_data.jld2"",; schedule = AveragedTimeInterval(20minute, window=5minute)); ```. See [`JLD2OutputWriter`](@ref) for more information. ## Time-averaged output. Time-averaged output is specified by setting the `schedule` keyword argument for either `NetCDFOutputWriter` or; `JLD2OutputWriter` to [`AveragedTimeInterval`](@ref). With `AveragedTimeInterval`, the time-average of ``a`` is taken as a left Riemann sum corresponding to. ```math; \langle a \rangle = \frac{1}{T} \int_{t_i-T}^{t_i} a \, \mathrm{d} t \, ,; ```. where ``\langle a \rangle`` is the time-average of ``a``, ``T`` is the time-`window` for averaging specified by; the `window` keyword argument to `AveragedTimeInterval`, and the ``t_i`` are discrete times separated by the; time `interval`. The ``t_i`` specify both the end of the averaging window and the time at which output is written. ### Example. Building an `AveragedTimeInterval` that averages over a 1 day window, every 4 days,. ```jldoctest averaged_time_interval; using Oceananigans; using Oceananigans.Units. schedule = AveragedTimeInterval(4days, window=1day). # output; AveragedTimeInterval(window=1 day, stride=1, interval=4 days); ```. An `AveragedTimeInterval` schedule directs an output writer; to time-average its outputs before writing them to disk:. ```@example averaged_time_interval; using Oceananigans; using Oceananigans.Units. model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))). simulation = Simulation(model, Œît=10minutes, stop_time=30days). simulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,; filename = ""even_more_averaged_velocity_data.jld2"",; schedule = AveragedTimeInterval(4days, window=1day, stride=2)); ```; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md:8898,schedul,schedule,8898,docs/src/model_setup/output_writers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md,3,['schedul'],['schedule']
Energy Efficiency," an `AbstractField` or a function called with `func(model)` that returns arbitrary output.; Whenever output needs to be written, the functions will be called and the output; of the function will be saved to the JLD2 file. ### Examples. Write out 3D fields for u, v, w, and a tracer c, along with a horizontal average:. ```@example jld2_output_writer; using Oceananigans; using Oceananigans.Utils: hour, minute. model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)), tracers=(:c,)); simulation = Simulation(model, Œît=12, stop_time=1hour). function init_save_some_metadata!(file, model); file[""author""] = ""Chim Riggles""; file[""parameters/coriolis_parameter""] = 1e-4; file[""parameters/density""] = 1027; return nothing; end. c_avg = Field(Average(model.tracers.c, dims=(1, 2))). # Note that model.velocities is NamedTuple; simulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,; filename = ""some_more_data.jld2"",; schedule = TimeInterval(20minute),; init = init_save_some_metadata!); ```. and a time- and horizontal-average of tracer `c` every 20 minutes of simulation time; to a file called `some_more_averaged_data.jld2`. ```@example jld2_output_writer; simulation.output_writers[:avg_c] = JLD2OutputWriter(model, (; c=c_avg),; filename = ""some_more_averaged_data.jld2"",; schedule = AveragedTimeInterval(20minute, window=5minute)); ```. See [`JLD2OutputWriter`](@ref) for more information. ## Time-averaged output. Time-averaged output is specified by setting the `schedule` keyword argument for either `NetCDFOutputWriter` or; `JLD2OutputWriter` to [`AveragedTimeInterval`](@ref). With `AveragedTimeInterval`, the time-average of ``a`` is taken as a left Riemann sum corresponding to. ```math; \langle a \rangle = \frac{1}{T} \int_{t_i-T}^{t_i} a \, \mathrm{d} t \, ,; ```. where ``\langle a \rangle`` is the time-average of ``a``, ``T`` is the time-`window` for averaging specified by; the `window` keyword argument to `AveragedTimeInterval`, ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md:7516,schedul,schedule,7516,docs/src/model_setup/output_writers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md,1,['schedul'],['schedule']
Energy Efficiency," eddy simulation are defined in; [Oceanostics.jl](https://github.com/tomchor/Oceanostics.jl/blob/3b8f67338656557877ef8ef5ebe3af9e7b2974e2/src/TurbulentKineticEnergyTerms.jl#L35-L57),. ```julia; using Oceanostics: IsotropicPseudoViscousDissipationRate; Œµ = IsotropicViscousDissipationRate(model, u, v, w, ŒΩ); compute!(Œµ); ```; [Start an issue on Github](https://github.com/CliMA/Oceananigans.jl/issues/new) if more help is needed. ### Try to decrease the memory-use of your runs. GPU runs are sometimes memory-limited. A state-of-the-art Tesla V100 GPU has 32GB of; memory -- enough memory for simulations with about 100 million points, or grids a bit smaller; than 512 √ó 512 √ó 512. (The maximum grid size depends on some user-specified factors,; like the number of passive tracers or computed diagnostics.); For large simulations on the GPU, careful management of memory allocation may be required:. - Use the [`nvidia-smi`](https://developer.nvidia.com/nvidia-system-management-interface) command; line utility to monitor the memory usage of the GPU. It should tell you how much memory there is; on your GPU and how much of it you're using and you can run it from Julia via. ```julia; julia> ;; shell> run(`nvidia-smi`); ```. - Try to use higher-order advection schemes. In general when you use a higher-order scheme you need; fewer grid points to achieve the same accuracy that you would with a lower-order one. Refer to the; [documentation](https://clima.github.io/OceananigansDocumentation/stable/appendix/library/#Advection); for available advection schemes. - Manually define scratch space to be reused in diagnostics. By default, every time a user-defined; diagnostic is calculated the compiler reserves a new chunk of memory for that calculation, usually; called scratch space. In general, the more diagnostics, the more scratch space needed and the bigger; the memory requirements. However, if you explicitly create a scratch space and pass that same; scratch space for as many diagnostics as",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:8875,monitor,monitor,8875,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['monitor'],['monitor']
Energy Efficiency,"# Grids. The grids currently supported are:; - `RectilinearGrid`s with either constant or variable grid spacings and; - `LatitudeLongitudeGrid` on the sphere. ## `RectilinearGrid`. A `RectilinearGrid` is constructed by specifying the `size` of the grid (a `Tuple` specifying; the number of grid points in each direction) and either the `extent` (a `Tuple` specifying the; physical extent of the grid in each direction), or by prescribing `x`, `y`, and `z`. Keyword; arguments `x`, `y`, and `z` could be either *(i)* 2-`Tuple`s that define the the _end points_ in; each direction, or *(ii)* arrays or functions of the corresponding indices `i`, `j`, or `k` that; specify the locations of cell faces in the `x`-, `y`-, or `z`-direction, respectively. A regular rectilinear grid with ``N_x \times N_y \times N_z = 32 \times 64 \times 256`` grid points; and an `extent` of ``L_x = 128`` meters, ``L_y = 256`` meters, and ``L_z = 512`` meters is constructed; by. ```@meta; DocTestSetup = quote; using Oceananigans; end; ```. ```jldoctest; julia> grid = RectilinearGrid(size = (32, 64, 256), extent = (128, 256, 512)); 32√ó64√ó256 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 128.0) regularly spaced with Œîx=4.0; ‚îú‚îÄ‚îÄ Periodic y ‚àà [0.0, 256.0) regularly spaced with Œîy=4.0; ‚îî‚îÄ‚îÄ Bounded z ‚àà [-512.0, 0.0] regularly spaced with Œîz=2.0; ```. !!! info ""Default domain""; When using the `extent` keyword, e.g., `extent = (Lx, Ly, Lz)`, then the ``x \in [0, L_x]``,; ``y \in [0, L_y]``, and ``z \in [-L_z, 0]`` -- a sensible choice for oceanographic applications. ### Specifying the grid's architecture. The first positional argument in either `RectilinearGrid` or `LatitudeLongitudeGrid` is the grid's; architecture. By default `architecture = CPU()`. By providing `GPU()` as the `architecture` argument; we can construct the grid on GPU:. ```julia; julia> grid = RectilinearGrid(GPU(), size = (32, 64, 256), extent = (128, 256, 512)); 32√ó64√ó256 RectilinearGri",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/legacy_grids.md:883,meter,meters,883,docs/src/model_setup/legacy_grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/legacy_grids.md,3,['meter'],['meters']
Energy Efficiency,"# Operations and averaging. `Field`s are more than mere vessels for data.; They come equipped with a powerful infrastructure for assembling expression trees that represent; arithmetic and discrete calculus operations.; We also supply a system for computing reductions (averages, integrals, and cumulative integrals) of `Field`s.; This infrastructure can be used to construct initial conditions, set up diagnostic calculations that are performed; and saved to disk while a simulation runs, and also for post-processing. We start by constructing a `CenterField` on a simple grid,. ```jldoctest operations; using Oceananigans. grid = RectilinearGrid(topology = (Periodic, Flat, Bounded),; size = (4, 4),; x = (0, 2œÄ),; z = (-4, 0)). c = CenterField(grid). periodic_but_decaying(x, z) = sin(x) * exp(z); set!(c, periodic_but_decaying). # output; 4√ó1√ó4 Field{Center, Center, Center} on RectilinearGrid on CPU; ‚îú‚îÄ‚îÄ grid: 4√ó1√ó4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3√ó0√ó3 halo; ‚îú‚îÄ‚îÄ boundary conditions: FieldBoundaryConditions; ‚îÇ ‚îî‚îÄ‚îÄ west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; ‚îî‚îÄ‚îÄ data: 10√ó1√ó10 OffsetArray(::Array{Float64, 3}, -2:7, 1:1, -2:7) with eltype Float64 with indices -2:7√ó1:1√ó-2:7; ‚îî‚îÄ‚îÄ max=0.428882, min=-0.428882, mean=1.04083e-17; ```. An `AbstractOperation` (or _operation_ for short) differs from a `Field` in that only represents a computation.; Unlike `Field`s, `AbstractOperation`s do not have any data, and are associated only with minimal memory allocation.; `AbstractOperations` are generated by inflicting `Field`s with ordinary arithmetic expressions,. ```jldoctest operations; two_c = 2 * c. # output; BinaryOperation at (Center, Center, Center); ‚îú‚îÄ‚îÄ grid: 4√ó1√ó4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3√ó0√ó3 halo; ‚îî‚îÄ‚îÄ tree:; * at (Center, Center, Center); ¬†¬† ‚îú‚îÄ‚îÄ 2; ¬†¬† ‚îî‚îÄ‚îÄ 4√ó1√ó4 Field{Center, Center, Center} on RectilinearGrid on CPU; ```. and even by chaining e",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/operations.md:101,power,powerful,101,docs/src/operations.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/operations.md,1,['power'],['powerful']
Energy Efficiency,"# Simulations. `Simulation`s are basically a utility for managing a time-stepping loop, including scheduling; important activities such as:. * Logging the progress of a simulation,; * Computing and writing diagnostics or other output to disk,; * Stopping a simulation when its time has come. The most important line in any script is `run!(simulation)`.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulations.md:98,schedul,scheduling,98,docs/src/simulations.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulations.md,1,['schedul'],['scheduling']
Energy Efficiency,"# [Grids](@id grids_tutorial). ```@meta; DocTestSetup = quote; using Oceananigans; using CairoMakie; CairoMakie.activate!(type = ""svg""); set_theme!(Theme(fontsize=24)); end; ```. Oceananigans simulates the dynamics of ocean-flavored fluids by solving equations that conserve momentum, mass, and energy on a grid of finite volumes or ""cells"".; The first decision we make when setting up a simulation is: on what _grid_ are we going to run our simulation?; The ""grid"" captures the. 1. The geometry of the physical domain;; 2. The way that domain is divided into a mesh of finite volumes;; 3. The machine architecture (CPU, GPU, lots of CPUs or lots of GPUs); and; 4. The precision of floating point numbers (double precision or single precision). We start by making a simple grid that divides a three-dimensional rectangular domain -- ""a box"" -- into evenly-spaced cells,. ```jldoctest grids; using Oceananigans. grid = RectilinearGrid(topology = (Periodic, Periodic, Bounded),; size = (16, 8, 4),; x = (0, 64),; y = (0, 32),; z = (0, 8)). # output; 16√ó8√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 64.0) regularly spaced with Œîx=4.0; ‚îú‚îÄ‚îÄ Periodic y ‚àà [0.0, 32.0) regularly spaced with Œîy=4.0; ‚îî‚îÄ‚îÄ Bounded z ‚àà [0.0, 8.0] regularly spaced with Œîz=2.0; ```. This simple grid. * Has a domain that's ""periodic"" in ``x, y``, but bounded in ``z``.; * Has `16` cells in `x`, `8` cells in `y`, and `4` cells in `z`. That means there are ``16 \times 8 \times 4 = 512`` cells in all.; * Has an `x` dimension that spans from `x=0`, to `x=64`. And `y` spans `y=0` to `y=32`, and `z` spans `z=0` to `z=8`.; * Has cells that are all the same size, dividing the box in 512 that each has dimension ``4 \times 4 \times 2``.; Note that length units are whatever is used to construct the grid, so it's up to the user to make sure that all inputs use consistent units. In building our first grid, we did not specify whether it should be constructed on the [`CPU`](",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:295,energy,energy,295,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['energy'],['energy']
Energy Efficiency,"# [Simulation tips](@id simulation_tips). Oceananigans attempts to optimize computations as much as possible ""behind the scenes"".; Yet Oceananigans' flexibility places some responsibility on users to ensure high performance simulations,; especially for complex setups with user-defined forcing functions, boundary condition functions, and diagnostics.; Furthermore, in case of more complex GPU runs, some details could; sometimes prevent your simulation from running altogether. While Julia knowledge is obviously; desirable here, a user that is unfamiliar with Julia can get away with efficient simulations by; learning a few rules of thumb. It is nonetheless recommended that users go through Julia's; [performance tips](https://docs.julialang.org/en/v1/manual/performance-tips/), which contains more; in-depth explanations of some of the aspects discussed here. ## General (CPU/GPU) simulation tips. ### Avoid global variables whenever possible. In general using a [global; variable](https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Global-Scope) (which can be; loosely defined as a variable defined in the main script) inside functions slows down the code. One; way to circumvent this is to always [use local variables or pass them as arguments to; functions](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). This; helps the compiler optimize the code. Another way around this is to [define global variables as constants whenever; possible](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). One; thing to keep in mind when doing this is that when a `const` is defined, its value can't be changed; until you restart the Julia session. So this latter approach is good for production-ready code, but; may be undesirable in the early stages of development while you still have to change the parameters; of the simulation for exploration. It is especially important to avoid global variables in functions that are meant t",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:586,efficient,efficient,586,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['efficient'],['efficient']
Energy Efficiency,"# [Turbulence closures](@id numerical_closures). To truly simulate and resolve turbulence at high Reynolds number (so basically all interesting flows) would require; you resolve all motions down to the [Kolmogorov41](@citet) length scale ``\eta = (\nu^3 / \varepsilon)^{1/4}`` where; ``\nu`` is the kinematic viscosity and ``\varepsilon`` the average rate of dissipation of turbulence kinetic energy per; unit mass. As pointed out way back by [Corrsin61](@citet), to run a simulation on a horizontal domain about 10 times the size of an; ""average eddy"" with 100 vertical levels and where the grid spacing is given by ``\eta`` would require the computer to; store on the order of ``10^{14}`` variables.[^1] This is still impractical today, although may be within; reach in less than a decade. He ends by suggesting the use of an analog rather digital computer---a tank of water. [^1]: And even then, ``\eta`` gives the *maximum* allowable grid spacing. There is significant flow structure; smaller than ``\eta``. To have any hope of simulating high Reynolds number flows we need some way of resolving the sub-grid scale motions.[^2]. [^2]: In reality there is no need to resolve all motions down to the Kolmogorov length scale to achieve; acceptable accuracy. Perhaps good results can be achieved if 80\% of the kinetic energy is resolved; (¬ß13) [Pope00](@cite). ## Reynolds-averaged Navier‚ÄìStokes equations. Following [Reynolds1895](@citet), we can decompose flow variables such as velocity ``\boldsymbol{v}`` into the mean component; ``\overline{\boldsymbol{v}}`` and the fluctuating component ``\boldsymbol{v}^\prime`` so that ``\boldsymbol{v} = \overline{\boldsymbol{v}} + \boldsymbol{v}^\prime``; [see ¬ß4 of [Pope00](@citet) for a modern discussion]. Expressing the Navier-Stokes equations in tensor notation; ```math; \begin{align}; \partial_i v_i &= 0 \, ,\\; \partial_t v_i + v_j \partial_j v_i &= f_i - \alpha\partial_i p + \nu \partial_j \partial_j v_i \, ,; \end{align}; ```; where ``\alpha ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md:393,energy,energy,393,docs/src/numerical_implementation/turbulence_closures.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md,1,['energy'],['energy']
Energy Efficiency,", if can be difficult to just view a `CuArray` since Julia needs to access ; its elements to do that. Consider the example below:. ```julia; julia> using Oceananigans, Adapt. julia> grid = RectilinearGrid(GPU(); size=(1, 1, 1), extent=(1, 1, 1), halo=(1, 1, 1)); 1√ó1√ó1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 1.0) regularly spaced with Œîx=1.0; ‚îú‚îÄ‚îÄ Periodic y ‚àà [0.0, 1.0) regularly spaced with Œîy=1.0; ‚îî‚îÄ‚îÄ Bounded z ‚àà [-1.0, 0.0] regularly spaced with Œîz=1.0. julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ‚îú‚îÄ‚îÄ grid: 1√ó1√ó1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ timestepper: RungeKutta3TimeStepper; ‚îú‚îÄ‚îÄ tracers: (); ‚îú‚îÄ‚îÄ closure: Nothing; ‚îú‚îÄ‚îÄ buoyancy: Nothing; ‚îî‚îÄ‚îÄ coriolis: Nothing. julia> typeof(model.velocities.u.data); OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}. julia> adapt(Array, model.velocities.u.data); 3√ó3√ó3 OffsetArray(::Array{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2√ó0:2√ó0:2:; [:, :, 0] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 1] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0; ```. Notice that to view the `CuArray` that stores values for `u` we first need to transform; it into a regular `Array` using `Adapt.adapt`. If we naively try to view the `CuArray`; without that step we get an error:. ```julia; julia> model.velocities.u.data; 3√ó3√ó3 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2√ó0:2√ó0:2:; [:, :, 0] =; Error showing value of type OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}:; ERROR: Scalar indexing is disallowed.; ```. Here `CUDA.jl` throws an error because scalar `getindex` is not `allowed`. There are ways to; overcome this limitation and allow scalar indexing (",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:12389,adapt,adapt,12389,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['adapt'],['adapt']
Energy Efficiency,"9 ‚îÇ 1.13541 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 8, 1) ‚îÇ 6.94845 ‚îÇ 0.868556 ‚îÇ 0.972279 ‚îÇ 1.16437 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 16, 1) ‚îÇ 11.2086 ‚îÇ 0.700536 ‚îÇ 0.978143 ‚îÇ 1.2223 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 32, 1) ‚îÇ 13.0841 ‚îÇ 0.408879 ‚îÇ 0.992685 ‚îÇ 1.33816 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 64, 1) ‚îÇ 17.0612 ‚îÇ 0.266582 ‚îÇ 1.03519 ‚îÇ 1.5735 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 128, 1) ‚îÇ 25.409 ‚îÇ 0.198508 ‚îÇ 1.16772 ‚îÇ 2.03693 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò; ```. ![ss_nonhydrostatic_efficiency](https://user-images.githubusercontent.com/45054739/130146219-b354fa25-7d77-4206-8e7e-ec639b2250fa.png). ## Multithreading. Oceananigans can also achieve parallelism via multithreading. Though its efficiencies are less than that of the MPI distributed architectures, its simple setup still makes it a viable option for achieving speedups on simple systems. ### Weak Scaling Multithreaded Shallow Water Model. The initial drop and then rise in efficiencies going from 1 to 2 to 4 threads is likely caused by the 2 threads being automatically allocated onto only one physical CPU core. Though one physical CPU core may contain 2 logical cores each capable of running a separate thread, having 2 threads run on one core will still reduce efficiencies as many resources such as caches and buses must be shared by both threads. Note that there are as many CPU cores allocated as the maximum number of threads. ```; Oceananigans v0.58.9; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :. Shallow water mode",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:25648,allocate,allocated,25648,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['allocate'],['allocated']
Energy Efficiency,"; ‚îú‚îÄ‚îÄ Bounded y ‚àà [0.0, 10000.0] regularly spaced with Œîy=156.25; ‚îî‚îÄ‚îÄ Bounded z ‚àà [-1000.0, 0.0] regularly spaced with Œîz=31.25; ```. The `Flat` topology comes in handy when running problems with fewer than 3 dimensions. As an example,; to use a two-dimensional horizontal, doubly periodic domain the topology is `(Periodic, Periodic, Flat)`.; In that case, the `size` and `extent` are 2-tuples, e.g.,. ```jldoctest; julia> grid = RectilinearGrid(topology = (Periodic, Periodic, Flat), size = (32, 32), extent = (10, 20)); 32√ó32√ó1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3√ó3√ó0 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 10.0) regularly spaced with Œîx=0.3125; ‚îú‚îÄ‚îÄ Periodic y ‚àà [0.0, 20.0) regularly spaced with Œîy=0.625; ‚îî‚îÄ‚îÄ Flat z; ```. ### Specifying domain end points. To specify a domain with a different origin than the default, the `x`, `y`, and `z` keyword arguments must be used.; For example, a grid with ``x \in [-100, 100]`` meters, ``y \in [0, 12.5]`` meters, and ``z \in [-\pi, \pi]`` meters; is constructed via. ```jldoctest; julia> grid = RectilinearGrid(size = (32, 16, 256), x = (-100, 100), y = (0, 12.5), z = (-œÄ, œÄ)); 32√ó16√ó256 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [-100.0, 100.0) regularly spaced with Œîx=6.25; ‚îú‚îÄ‚îÄ Periodic y ‚àà [0.0, 12.5) regularly spaced with Œîy=0.78125; ‚îî‚îÄ‚îÄ Bounded z ‚àà [-3.14159, 3.14159] regularly spaced with Œîz=0.0245437; ```. ### Grids with non-regular spacing in some of the directions. For a ""channel"" model, as the one we constructed above, one would probably like to have finer resolution near; the channel walls. We construct a grid that has non-regular spacing in the bounded dimensions, here ``y`` and ``z``; by prescribing functions for `y` and `z` keyword arguments. For example, we can use the Chebychev nodes, which are more closely stacked near boundaries, to prescribe the; ``y``- and ``z``-faces. ```jldoctest; julia> Nx, Ny, Nz = 64, 64, 32;. julia> Lx, Ly, Lz = 1e4, 1e4, ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/legacy_grids.md:4027,meter,meters,4027,docs/src/model_setup/legacy_grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/legacy_grids.md,2,['meter'],['meters']
Energy Efficiency,"=> 7). simulation.output_writers[:things] =; NetCDFOutputWriter(model, outputs,; schedule=IterationInterval(1), filename=""things.nc"", dimensions=dims, verbose=true,; global_attributes=global_attributes, output_attributes=output_attributes); ```. `NetCDFOutputWriter` can also be configured for `outputs` that are interpolated or regridded; to a different grid than `model.grid`. To use this functionality, include the keyword argument; `grid = output_grid`. ```@example; using Oceananigans; using Oceananigans.Fields: interpolate!. grid = RectilinearGrid(size=(1, 1, 8), extent=(1, 1, 1));; model = NonhydrostaticModel(; grid). coarse_grid = RectilinearGrid(size=(grid.Nx, grid.Ny, grid.Nz√∑2), extent=(grid.Lx, grid.Ly, grid.Lz)); coarse_u = Field{Face, Center, Center}(coarse_grid). interpolate_u(model) = interpolate!(coarse_u, model.velocities.u); outputs = (; u = interpolate_u). output_writer = NetCDFOutputWriter(model, outputs;; grid = coarse_grid,; filename = ""coarse_u.nc"",; schedule = IterationInterval(1)); ```. See [`NetCDFOutputWriter`](@ref) for more information. ## JLD2 output writer. JLD2 is a fast HDF5 compatible file format written in pure Julia.; JLD2 files can be opened in Julia with the [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) package; and in Python with the [h5py](https://www.h5py.org/) package. The `JLD2OutputWriter` receives either a `Dict`ionary or `NamedTuple` containing; `name, output` pairs. The `name` can be a symbol or string. The `output` must either be; an `AbstractField` or a function called with `func(model)` that returns arbitrary output.; Whenever output needs to be written, the functions will be called and the output; of the function will be saved to the JLD2 file. ### Examples. Write out 3D fields for u, v, w, and a tracer c, along with a horizontal average:. ```@example jld2_output_writer; using Oceananigans; using Oceananigans.Utils: hour, minute. model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)), tracers",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md:6035,schedul,schedule,6035,docs/src/model_setup/output_writers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md,1,['schedul'],['schedule']
Energy Efficiency,"FOutputWriter`](@ref) for output of arrays and scalars that uses [NCDatasets.jl](https://github.com/Alexander-Barth/NCDatasets.jl); 2. [`JLD2OutputWriter`](@ref) for arbitrary julia data structures that uses [JLD2.jl](https://github.com/JuliaIO/JLD2.jl); 3. [`Checkpointer`](@ref) that automatically saves as much model data as possible, using [JLD2.jl](https://github.com/JuliaIO/JLD2.jl). The `Checkpointer` is discussed in detail on a separate [section](@ref checkpointing) of the documentation. ## Basic usage. [`NetCDFOutputWriter`](@ref) and [`JLD2OutputWriter`](@ref) require four inputs:. 1. The `model` from which output data is sourced (required to initialize the `OutputWriter`).; 2. A key-value pairing of output ""names"" and ""output"" objects. `JLD2OutputWriter` accepts `NamedTuple`s and `Dict`s;; `NetCDFOutputWriter` accepts `Dict`s with string-valued keys. Output objects are either `AbstractField`s or; functions that return data when called via `func(model)`.; 3. A `schedule` on which output is written. `TimeInterval`, `IterationInterval`, `WallTimeInterval` schedule; periodic output according to the simulation time, simulation interval, or ""wall time"" (the physical time; according to a clock on your wall). A fourth `schedule` called `AveragedTimeInterval` specifies; periodic output that is time-averaged over a `window` prior to being written.; 4. The `filename` and `dir`ectory. Other important keyword arguments are. * `indices` for outputting subregions, two- and one-dimensional slices of fields. Specifies the indices to write to disk with a `Tuple` of `Colon`, `UnitRange`,or `Int` elements. For example, `indices = (:, :, 1)` implies outputing ``x-y``-slices of the bottom-most index (`k=1`). Defaults to `(:, :, :)`, i.e., ""all indices"".; * `with_halos :: Boolean`: whether to output the halos (`true`) or only the interior points (`false`; default). * `array_type` for specifying the type of the array that holds outputted field data. The default is; `Array{Float64}`",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md:1109,schedul,schedule,1109,docs/src/model_setup/output_writers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md,1,['schedul'],['schedule']
Energy Efficiency,"NO advection scheme](https://en.wikipedia.org/wiki/WENO_methods).; It's quite similar to the [two-dimensional turbulence example](https://clima.github.io/OceananigansDocumentation/stable/generated/two_dimensional_turbulence/). ## Visualization. They say that a [Makie](https://makie.juliaplots.org/stable/) visualization is worth a thousand Unicode characters, so let's plot vorticity,. ```@example cpu; using CairoMakie. u, v, w = model.velocities; Œ∂ = Field(‚àÇx(v) - ‚àÇy(u)); compute!(Œ∂). heatmap(Œ∂, axis=(; aspect=1)); ```. A few more time-steps, and it's starting to get a little diffuse!. ```@example cpu; simulation.stop_iteration += 400; run!(simulation). compute!(Œ∂); heatmap(Œ∂, axis=(; aspect=1)); ```. ## They always cheat with too-simple ""quick"" starts. Fine, we'll re-run this code on the GPU. But we're a little greedy, so we'll also; crank up the resolution, throw in a `TimeStepWizard` to update `simulation.Œît` adaptively,; and add a passive tracer initially concentrated in the center of the domain; which will make for an even prettier figure of the final state:. ```@setup gpu; using CairoMakie; CairoMakie.activate!(type = ""png""); ```. ```@example gpu; using Oceananigans; using CairoMakie. grid = RectilinearGrid(GPU(),; size = (1024, 1024),; x = (-œÄ, œÄ),; y = (-œÄ, œÄ),; topology = (Periodic, Periodic, Flat)). model = NonhydrostaticModel(; grid, advection=WENO(), tracers=:c). Œ¥ = 0.5; c·µ¢(x, y) = exp(-(x^2 + y^2) / 2Œ¥^2); œµ(x, y) = 2rand() - 1; set!(model, u=œµ, v=œµ, c=c·µ¢). simulation = Simulation(model; Œît=1e-3, stop_time=10); conjure_time_step_wizard!(simulation, cfl=0.2, IterationInterval(10)); run!(simulation). u, v, w = model.velocities; Œ∂ = Field(‚àÇx(v) - ‚àÇy(u)); compute!(Œ∂). fig = Figure(size=(1200, 600)); axŒ∂ = Axis(fig[1, 1], aspect=1, title=""vorticity""); axc = Axis(fig[1, 2], aspect=1, title=""tracer""); heatmap!(axŒ∂, Œ∂, colormap=:balance); heatmap!(axc, model.tracers.c); current_figure(); ```. See how we did that? We passed the positional argument `GPU()` to `Re",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/quick_start.md:1539,adapt,adaptively,1539,docs/src/quick_start.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/quick_start.md,1,['adapt'],['adaptively']
Energy Efficiency,"` here, ``\tilde{X}^{-+}`` is indexed in reverse along the first dimension,; ``\tilde{X}^{-+}`` along the second dimension, and ``\tilde{X}^{--}`` along both. ``M_1`` and ``M_2`` are masks of lengths; ``N_1`` and ``N_2`` respectively, both containing ones except at the first element where ``M_0 = 0``. Afterwards, the inverse; permutation of \eqref{eq:permutation} must be applied. Due to the extra steps involved in calculating the cosine transform in 2D, running with two ; wall-bounded dimensions typically slows the model down by a factor of 2. Switching to the FACR ; algorithm may help here as a 2D cosine transform won't be necessary anymore. ## Iterative Solvers. For problems with irregular grids the eigenvectors of the discrete Poisson operator are no longer simple Fourier; series sines and cosines. This means discrete Fast Fourier Transforms can't be used to generate the projection ; of the equation right hand side onto eigenvectors. So an eigenvector based approach to solving; the Poisson equation is not computationally efficient. For problems with grids that are non uniform in multiple directions, we use instead a pre-conditioned conjugate; gradient iterative solver. Such cases include curvilinear grids on the sphere and also telescoping cartesian; grids that stretch along more than one dimension. There are two forms of the pressure operator in this approach.; One is rigid lid form and one is an implicit free-surface form. ### Rigid lid pressure operator. The rigid lid operator is based on the same continuous form as is used in the Direct Method; solver. ### Implicit free surface pressure operator. The implicit free surface solver solves for the free-surface, ``\eta(x, y, t)``, in the vertically; integrated continuity equation:. ```math; \begin{equation}; \label{eq:vertically-integrated-continuity}; \partial_t \eta + \partial_x \left ( \int_{-H}^0 u \, \mathrm{d}z \right ) + \partial_y \left ( \int_{-H}^0 v \, \mathrm{d}z \right ) = M \, ,; \end{equation}; ```.",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:11514,efficient,efficient,11514,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['efficient'],['efficient']
Energy Efficiency,"alf. [![Watch free convection in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/free_convection_0956.png)](https://www.youtube.com/watch?v=yq4op9h3xcU). ## [Winds blowing over the ocean](https://www.youtube.com/watch?v=IRncfbvuiy8). An idealized simulation of a strong wind stress acting on the surface of a stratified ocean. The simulation employs a; resolution of 256x256x256 volumes in a 100x100x100 m horizontally periodic domain. A pretty strong wind stress of; 0.1 N/m¬≤ is applied in the x direction which mechanically mixes the upper layer of the ocean. This leads to a ""mixed; layer"" of constant temperature near the surface of the ocean. You can also see the onset of Kelvin-Helmholtz; instabilities as the mechanical mixing sets in. The video shows the temperature field in the top 25 meters and the domain is sliced in half for visualization. The line; plots show the horizontally averaged temperature profile (top right), horizontally averaged turbulent kinetic energy; (middle right), and the horizontally averaged buoyancy flux (or temperature flux). [![Watch winds blowing over the ocean](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_0400.png)](https://www.youtube.com/watch?v=IRncfbvuiy8). ## [Free convection with wind stress](https://www.youtube.com/watch?v=ob6OMQgPfI4). An idealized simulation of a strong wind stress acting on the surface of a stratified ocean along with a cooling flux; that sucks heat out of the surface. The simulation employs a resolution of 256x256x256 volumes in a 100x100x100 m; horizontally periodic domain. A pretty strong wind stress of 0.1 N/m¬≤ is applied in the x direction which mechanically; mixes the upper layer of the ocean. Also, heat is sucked out of the ocean surface at a rate of 75 W/m¬≤ which cools the; surface water and making it denser. This cold dense water then sinks into the ocean interior, initiating a convective; process that keeps mixing th",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/gallery.md:2690,energy,energy,2690,docs/src/gallery.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/gallery.md,1,['energy'],['energy']
Energy Efficiency,"d layer"" has a relatively constant; temperature and keeps deepening as the surface is cooled. The video shows the temperature field and the domain is sliced in half. [![Watch free convection in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/free_convection_0956.png)](https://www.youtube.com/watch?v=yq4op9h3xcU). ## [Winds blowing over the ocean](https://www.youtube.com/watch?v=IRncfbvuiy8). An idealized simulation of a strong wind stress acting on the surface of a stratified ocean. The simulation employs a; resolution of 256x256x256 volumes in a 100x100x100 m horizontally periodic domain. A pretty strong wind stress of; 0.1 N/m¬≤ is applied in the x direction which mechanically mixes the upper layer of the ocean. This leads to a ""mixed; layer"" of constant temperature near the surface of the ocean. You can also see the onset of Kelvin-Helmholtz; instabilities as the mechanical mixing sets in. The video shows the temperature field in the top 25 meters and the domain is sliced in half for visualization. The line; plots show the horizontally averaged temperature profile (top right), horizontally averaged turbulent kinetic energy; (middle right), and the horizontally averaged buoyancy flux (or temperature flux). [![Watch winds blowing over the ocean](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_0400.png)](https://www.youtube.com/watch?v=IRncfbvuiy8). ## [Free convection with wind stress](https://www.youtube.com/watch?v=ob6OMQgPfI4). An idealized simulation of a strong wind stress acting on the surface of a stratified ocean along with a cooling flux; that sucks heat out of the surface. The simulation employs a resolution of 256x256x256 volumes in a 100x100x100 m; horizontally periodic domain. A pretty strong wind stress of 0.1 N/m¬≤ is applied in the x direction which mechanically; mixes the upper layer of the ocean. Also, heat is sucked out of the ocean surface at a rate of 75 W/m¬≤ whi",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/gallery.md:2511,meter,meters,2511,docs/src/gallery.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/gallery.md,1,['meter'],['meters']
Energy Efficiency,"eneral, decomposed into three components:; ```math; \rho(\boldsymbol{x}, t) = \rho_0 + \rho_*(z) + \rho'(\boldsymbol{x}, t) \, ,; ```; where ``\rho_0`` is a constant 'reference' density, ``\rho_*(z)`` is a background density; profile which, when non-zero, is typically associated with the hydrostatic compression; of seawater in the deep ocean, and ``\rho'(\boldsymbol{x}, t)`` is the dynamic component of density; corresponding to inhomogeneous distributions of a buoyant tracer such as temperature or salinity. The fluid *buoyancy*, associated with the buoyant acceleration of fluid, is; defined in terms of ``\rho'`` as; ```math; b = - \frac{g \rho'}{\rho_0} \, ,; ```; where ``g`` is gravitational acceleration. The Boussinesq approximation is valid when ``\rho_* + \rho' \ll \rho_0``, which implies the; fluid is _approximately_ incompressible, and thus does not support acoustic waves. In this case, ; the mass conservation equation reduces to the continuity equation; ```math; \begin{equation}; \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{v} = \partial_x u + \partial_y v + \partial_z w = 0 \, .; \label{eq:continuity}; \end{equation}; ```. Similarly, in the the momentum equations we can divide through with ``\rho_0`` and use that ``\rho_* + \rho' \ll \rho_0`` to get:; ```math; \begin{equation}; \partial_t \boldsymbol{v} + \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} \boldsymbol{v} + \dotsb = - \frac1{\rho_0} \boldsymbol{\nabla} p - g \frac{\rho}{\rho_0} \hat{\boldsymbol{z}} + \dotsb \, .; \label{eq:momentum}; \end{equation}; ```. We refer to ``p / \rho_0`` as the ""kinematic pressure"" with dimensions of velocity squared. Hereafter, we; abuse notation a bit and denote the kinematic pressure simply as ``p``. !!! info ""Convention on dynamic versus kinematic pressure""; In Oceananigans, the pressure ``p`` refers to ""kinematic pressure"" (with dimensions velocity squared),; i.e., the dynamic pressure scaled with the reference fluid density ``\rho_0``. [^1]: Named afte",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/boussinesq.md:1135,reduce,reduces,1135,docs/src/physics/boussinesq.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/boussinesq.md,1,['reduce'],['reduces']
Energy Efficiency,"fusivity components ``\kappa_h`` and ``\kappa_z``. ## Smagorinsky-Lilly turbulence closure. In the turbulence closure proposed by [Lilly62](@citet) and [Smagorinsky63](@citet),; the subgrid stress associated with unresolved turbulent motions is modeled diffusively via; ```math; \tau_{ij} = - 2 \nu_e \Sigma_{ij} \, ,; ```; where ``\Sigma_{ij} = \tfrac{1}{2} \left ( v_{i, j} + v_{j, i} \right )`` is the resolved; strain rate.; The eddy viscosity is given by; ```math; \begin{align}; \nu_e = \left ( C \Delta_f \right )^2 \sqrt{ \Sigma^2 } \, \varsigma(N^2 / \Sigma^2) \, ,; \label{eq:smagorinsky-viscosity}; \end{align}; ```; where ``\Delta_f`` is the ""filter width"" associated with the finite volume grid spacing and; ``C`` is a user-specified model constant, ``\Sigma^2 \equiv \Sigma_{ij} \Sigma_{ij}``.; The factor ``\varsigma(N^2 / \Sigma^2)`` reduces ``\nu_e`` in regions of; strong stratification via; ```math; \varsigma(N^2 / \Sigma^2) = \sqrt{1 - \min \left ( 1, C_b N^2 / \Sigma^2 \right )} \, ,; ```; where ``N^2 = \max \left (0, \partial_z b \right )`` is the squared buoyancy frequency for stable; stratification with ``\partial_z b > 0`` and ``C_b`` is a user-specified constant. Lilly (1962); proposed ``C_b = 1/Pr``, where ``Pr`` is a turbulent Prandtl number.; The filter width for the Smagorinsky-Lilly closure is; ```math; \Delta_f(\boldsymbol{x}) = \left ( \Delta x \Delta y \Delta z \right)^{1/3} \, ,; ```; where ``\Delta x``, ``\Delta y``, and ``\Delta z`` are the grid spacing in the; ``\boldsymbol{\hat x}``, ``\boldsymbol{\hat y}``, and ``\boldsymbol{\hat z}`` directions at location ``\boldsymbol{x} = (x, y, z)``. The effect of subgrid turbulence on tracer mixing is also modeled diffusively via; ```math; \boldsymbol{q}_c = - \kappa_e \boldsymbol{\nabla} c \, ,; ```; where the eddy diffusivity ``\kappa_e`` is; ```math; \kappa_e = \frac{\nu_e}{Pr} + \kappa \, .; ```; Both ``Pr`` and ``\kappa`` may be set independently for each tracer. ## Anisotropic minimum dissipatio",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/turbulence_closures.md:3876,reduce,reduces,3876,docs/src/physics/turbulence_closures.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/turbulence_closures.md,1,['reduce'],['reduces']
Energy Efficiency,"g Oceananigans; using Oceananigans.Utils: hour, minute. model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)), tracers=(:c,)); simulation = Simulation(model, Œît=12, stop_time=1hour). function init_save_some_metadata!(file, model); file[""author""] = ""Chim Riggles""; file[""parameters/coriolis_parameter""] = 1e-4; file[""parameters/density""] = 1027; return nothing; end. c_avg = Field(Average(model.tracers.c, dims=(1, 2))). # Note that model.velocities is NamedTuple; simulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,; filename = ""some_more_data.jld2"",; schedule = TimeInterval(20minute),; init = init_save_some_metadata!); ```. and a time- and horizontal-average of tracer `c` every 20 minutes of simulation time; to a file called `some_more_averaged_data.jld2`. ```@example jld2_output_writer; simulation.output_writers[:avg_c] = JLD2OutputWriter(model, (; c=c_avg),; filename = ""some_more_averaged_data.jld2"",; schedule = AveragedTimeInterval(20minute, window=5minute)); ```. See [`JLD2OutputWriter`](@ref) for more information. ## Time-averaged output. Time-averaged output is specified by setting the `schedule` keyword argument for either `NetCDFOutputWriter` or; `JLD2OutputWriter` to [`AveragedTimeInterval`](@ref). With `AveragedTimeInterval`, the time-average of ``a`` is taken as a left Riemann sum corresponding to. ```math; \langle a \rangle = \frac{1}{T} \int_{t_i-T}^{t_i} a \, \mathrm{d} t \, ,; ```. where ``\langle a \rangle`` is the time-average of ``a``, ``T`` is the time-`window` for averaging specified by; the `window` keyword argument to `AveragedTimeInterval`, and the ``t_i`` are discrete times separated by the; time `interval`. The ``t_i`` specify both the end of the averaging window and the time at which output is written. ### Example. Building an `AveragedTimeInterval` that averages over a 1 day window, every 4 days,. ```jldoctest averaged_time_interval; using Oceananigans; using Oceananigans.Units. schedu",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md:7876,schedul,schedule,7876,docs/src/model_setup/output_writers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md,1,['schedul'],['schedule']
Energy Efficiency,"halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 10000.0) regularly spaced with Œîx=156.25; ‚îú‚îÄ‚îÄ Bounded y ‚àà [0.0, 10000.0] regularly spaced with Œîy=156.25; ‚îî‚îÄ‚îÄ Bounded z ‚àà [-1000.0, 0.0] regularly spaced with Œîz=31.25; ```. The `Flat` topology comes in handy when running problems with fewer than 3 dimensions. As an example,; to use a two-dimensional horizontal, doubly periodic domain the topology is `(Periodic, Periodic, Flat)`.; In that case, the `size` and `extent` are 2-tuples, e.g.,. ```jldoctest; julia> grid = RectilinearGrid(topology = (Periodic, Periodic, Flat), size = (32, 32), extent = (10, 20)); 32√ó32√ó1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3√ó3√ó0 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 10.0) regularly spaced with Œîx=0.3125; ‚îú‚îÄ‚îÄ Periodic y ‚àà [0.0, 20.0) regularly spaced with Œîy=0.625; ‚îî‚îÄ‚îÄ Flat z; ```. ### Specifying domain end points. To specify a domain with a different origin than the default, the `x`, `y`, and `z` keyword arguments must be used.; For example, a grid with ``x \in [-100, 100]`` meters, ``y \in [0, 12.5]`` meters, and ``z \in [-\pi, \pi]`` meters; is constructed via. ```jldoctest; julia> grid = RectilinearGrid(size = (32, 16, 256), x = (-100, 100), y = (0, 12.5), z = (-œÄ, œÄ)); 32√ó16√ó256 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [-100.0, 100.0) regularly spaced with Œîx=6.25; ‚îú‚îÄ‚îÄ Periodic y ‚àà [0.0, 12.5) regularly spaced with Œîy=0.78125; ‚îî‚îÄ‚îÄ Bounded z ‚àà [-3.14159, 3.14159] regularly spaced with Œîz=0.0245437; ```. ### Grids with non-regular spacing in some of the directions. For a ""channel"" model, as the one we constructed above, one would probably like to have finer resolution near; the channel walls. We construct a grid that has non-regular spacing in the bounded dimensions, here ``y`` and ``z``; by prescribing functions for `y` and `z` keyword arguments. For example, we can use the Chebychev nodes, which are more closely stacked near boundaries, to prescribe the; ``y``- and ``z``-faces. ```jldoc",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/legacy_grids.md:3999,meter,meters,3999,docs/src/model_setup/legacy_grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/legacy_grids.md,1,['meter'],['meters']
Energy Efficiency,"he completion of; a timestep. The other options are `callsite = TendencyCallsite()` that executes the callback; after the tendencies are computed but _before_ taking a timestep and `callsite = UpdateStateCallsite()`; that executes the callback within `update_state!`, after auxiliary variables have been computed; (for multi-stage time-steppers, `update_state!` may be called multiple times per timestep). As an example of a callback with `callsite = TendencyCallsite()` , we show below how we can; manually add to the tendency field of one of the velocity components. Here we've chosen; the `:u` field using parameters:. ```@example checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))). simulation = Simulation(model, Œît=1, stop_iteration=10). function modify_tendency!(model, params); model.timestepper.G‚Åø[params.c] .+= params.Œ¥; return nothing; end. simulation.callbacks[:modify_u] = Callback(modify_tendency!, IterationInterval(1),; callsite = TendencyCallsite(),; parameters = (c = :u, Œ¥ = 1)). run!(simulation); ```. Above there is no forcing at all, but due to the callback the ``u``-velocity is increased. ```@example checkpointing; @info model.velocities.u; ```. !!! note ""Example only for illustration purposes""; The above is a redundant example since it could be implemented better with a simple forcing function.; We include it here though for illustration purposes of how one can use callbacks. ## Functions. Callback functions can only take one or two parameters `sim` - a simulation, or `model` for state callbacks, and optionally may also accept a NamedTuple of parameters. ## Scheduling. The time that callbacks are called at are specified by schedule functions which can be:; - [`IterationInterval`](@ref) : runs every `n` iterations; - [`TimeInterval`](@ref) : runs every `n`s of model run time; - [`SpecifiedTimes`](@ref) : runs at the specified times; - [`WallTimeInterval`](@ref) : runs every `n`s of wall time; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/callbacks.md:2834,schedul,schedule,2834,docs/src/model_setup/callbacks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/callbacks.md,1,['schedul'],['schedule']
Energy Efficiency,"hedule. ## NetCDF output writer. Model data can be saved to NetCDF files along with associated metadata. The NetCDF output writer is generally used by; passing it a dictionary of (label, field) pairs and any indices for slicing if you don't want to save the full 3D field. ### Examples. Saving the u velocity field and temperature fields as full 3D fields, surface 2D slices, and; 1D columns to separate NetCDF files:. ```@example netcdf1; using Oceananigans. grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1)). model = NonhydrostaticModel(grid=grid, tracers=:c). simulation = Simulation(model, Œît=12, stop_time=3600). fields = Dict(""u"" => model.velocities.u, ""c"" => model.tracers.c). simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filename=""more_fields.nc"", schedule=TimeInterval(60)); ```. ```@example netcdf1; simulation.output_writers[:surface_slice_writer] =; NetCDFOutputWriter(model, fields, filename=""another_surface_xy_slice.nc"",; schedule=TimeInterval(60), indices=(:, :, grid.Nz)); ```. ```@example netcdf1; simulation.output_writers[:averaged_profile_writer] =; NetCDFOutputWriter(model, fields,; filename = ""another_averaged_z_profile.nc"",; schedule = AveragedTimeInterval(60, window=20),; indices = (1, 1, :)); ```. `NetCDFOutputWriter` also accepts output functions that write scalars and arrays to disk,; provided that their `dimensions` are provided:. ```@example; using Oceananigans. Nx, Ny, Nz = 16, 16, 16. grid = RectilinearGrid(size=(Nx, Ny, Nz), extent=(1, 2, 3)). model = NonhydrostaticModel(grid=grid). simulation = Simulation(model, Œît=1.25, stop_iteration=3). f(model) = model.clock.time^2; # scalar output. g(model) = model.clock.time .* exp.(znodes(grid, Center())) # single-column profile output (vector). xC, yF = xnodes(grid, Center()), ynodes(grid, Face()). XC = [xC[i] for i in 1:Nx, j in 1:Ny]; YF = [yF[j] for i in 1:Nx, j in 1:Ny]. h(model) = @. model.clock.time * sin(XC) * cos(YF) # x-y slice output (2D array). outputs = ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md:3585,schedul,schedule,3585,docs/src/model_setup/output_writers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md,1,['schedul'],['schedule']
Energy Efficiency,"if you don't want to save the full 3D field. ### Examples. Saving the u velocity field and temperature fields as full 3D fields, surface 2D slices, and; 1D columns to separate NetCDF files:. ```@example netcdf1; using Oceananigans. grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1)). model = NonhydrostaticModel(grid=grid, tracers=:c). simulation = Simulation(model, Œît=12, stop_time=3600). fields = Dict(""u"" => model.velocities.u, ""c"" => model.tracers.c). simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filename=""more_fields.nc"", schedule=TimeInterval(60)); ```. ```@example netcdf1; simulation.output_writers[:surface_slice_writer] =; NetCDFOutputWriter(model, fields, filename=""another_surface_xy_slice.nc"",; schedule=TimeInterval(60), indices=(:, :, grid.Nz)); ```. ```@example netcdf1; simulation.output_writers[:averaged_profile_writer] =; NetCDFOutputWriter(model, fields,; filename = ""another_averaged_z_profile.nc"",; schedule = AveragedTimeInterval(60, window=20),; indices = (1, 1, :)); ```. `NetCDFOutputWriter` also accepts output functions that write scalars and arrays to disk,; provided that their `dimensions` are provided:. ```@example; using Oceananigans. Nx, Ny, Nz = 16, 16, 16. grid = RectilinearGrid(size=(Nx, Ny, Nz), extent=(1, 2, 3)). model = NonhydrostaticModel(grid=grid). simulation = Simulation(model, Œît=1.25, stop_iteration=3). f(model) = model.clock.time^2; # scalar output. g(model) = model.clock.time .* exp.(znodes(grid, Center())) # single-column profile output (vector). xC, yF = xnodes(grid, Center()), ynodes(grid, Face()). XC = [xC[i] for i in 1:Nx, j in 1:Ny]; YF = [yF[j] for i in 1:Nx, j in 1:Ny]. h(model) = @. model.clock.time * sin(XC) * cos(YF) # x-y slice output (2D array). outputs = Dict(""scalar"" => f, ""profile"" => g, ""slice"" => h). dims = Dict(""scalar"" => (), ""profile"" => (""zC"",), ""slice"" => (""xC"", ""yC"")). output_attributes = Dict(; ""scalar"" => Dict(""longname"" => ""Some scalar"", ""units"" => ""bananas""),; ""pro",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md:3799,schedul,schedule,3799,docs/src/model_setup/output_writers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md,1,['schedul'],['schedule']
Energy Efficiency,"ly defined up to a constant. To resolve this; ambiguity we choose the solution with zero mean by setting the zeroth Fourier coefficient ``p_{000}`` (corresponding to; ``k_x = k_y = k_z = 0``) to zero. This also has the added benefit of discarding the zero eigenvalue so we don't divide by; it. The Fast Fourier transforms are computed using FFTW.jl [[Frigo98](@cite) and [Frigo05](@cite)] on the CPU and using the; cuFFT library on the GPU. Along wall-bounded dimensions, the cosine transform is used. In particular, as the transforms; are performed on a staggered grid, DCT-II (`REDFT10`) is used to perform the forward cosine transform and DCT-III; (`REDFT01`) is used to perform the inverse cosine transform. ## Direct method with a vertically stretched grid. Using Fourier transforms for all three dimensions results in a method requiring ``\mathcal{O}(N \log_2 N)`` operations; where ``N`` is the total number of grid points. This algorithm can be made even more efficient by solving a tridiagonal; system along one of the dimensions and utilizing cyclic reduction. This results in the *Fourier analysis cyclic; reduction* or ``\text{FACR}(\ell)`` algorithm (with ``\ell`` cyclic reduction steps) which requires only; ``\mathcal{O}(N \log_2\log_2 N)`` operations provided the optimal number of cyclic reduction steps is taken, which is; ``\ell = \log_2 \log_2 n`` where ``n`` is the number of grid points in the cyclic reduction dimension. The FACR algorithm; was first developed by [Hockney69](@citet) and is well reviewed by [Swarztrauber77](@citet) then further benchmarked and; extended by [Temperton79](@citet) and [Temperton80](@citet). Furthermore, the FACR algorithm removes the restriction that the grid is uniform in one of the dimensions so it can; be utilized to implement a fast Poisson solver for vertically stretched grids if the cyclic reduction is applied in the; along the vertical dimension. Expanding ``p_{NH}`` and ``\mathscr{F}`` into Fourier modes along the ``x`` and ``y`",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:5125,efficient,efficient,5125,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['efficient'],['efficient']
Energy Efficiency,"l{\nabla} \boldsymbol{\cdot} \boldsymbol{G}_{\boldsymbol{v}} \equiv \mathscr{F} \, ,; \end{equation}; ```; along with homogenous Neumann boundary conditions ``\boldsymbol{v} \cdot \boldsymbol{\hat{n}} = 0`` ; (Neumann on ``p`` for wall-bounded directions and periodic otherwise) and where ``\mathscr{F}`` ; denotes the source term for the Poisson equation. !!! note ""Hydrostatic approximation""; For problems in which the hydrostatic approximation is invoked, the Poisson equation for; pressure above only needs to be solved for the vertically integrated flow and the pressure; field is a two dimensional term ``p_S(x, y, t)``. ## Direct method. Discretizing elliptic problems that can be solved via a classical separation-of-variables approach, such as Poisson's; equation, results in a linear system of equations ``M \boldsymbol{x} = \boldsymbol{y}`` where ``M`` is a real symmetric matrix of block; tridiagonal form. This allows for the matrix to be decomposed and solved efficiently, provided that the eigenvalues and; eigenvectors of the blocks are known (¬ß2) [Buzbee70](@cite). In the case of Poisson's equation on a rectangle,; [Hockney65](@citet) has taken advantage of the fact that the fast Fourier transform can be used to perform the matrix; multiplication steps resulting in an even more efficient method. [Schumann88](@citet) describe the implementation of such; an algorithm for Poisson's equation on a staggered grid with Dirichlet, Neumann, and periodic boundary conditions. The method can be explained easily by taking the Fourier transform of both sides of \eqref{eq:poisson-pressure} to yield; ```math; \begin{equation}; \label{eq:poisson-spectral}; -(k_x^2 + k_y^2 + k_z^2) \widehat{p}_{NH} = \widehat{\mathscr{F}}; \quad \implies \quad; \widehat{p}_{NH} = - \frac{\widehat{\mathscr{F}}}{k_x^2 + k_y^2 + k_z^2} \, ,; \end{equation}; ```; where ``\widehat{\cdot}`` denotes the Fourier component. Here ``k_x``, ``k_y``, and ``k_z`` are the wavenumbers. However, when; solving the eq",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:1446,efficient,efficiently,1446,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['efficient'],['efficiently']
Energy Efficiency,"ore roughly 3x more cost-effective; than CPU simulations on cloud computing platforms such as Google Cloud. A GPU; with 32 GB of memory can time-step models with ~150 million grid points assuming; five fields are being evolved; for example, three velocity components and; tracers for temperature and salinity. These performance gains permit the; long-time integration of realistic simulations, such as large eddy simulation of; oceanic boundary layer turbulence over a seasonal cycle or the generation of; training data for turbulence parameterizations in Earth system models. ``Oceananigans.jl`` is continuously tested on CPUs and GPUs with unit tests,; integration tests, analytic solutions to the incompressible Navier-Stokes; equations, convergence tests, and verification experiments against published; scientific results. Future development plans include support for distributed; parallelism with CUDA-aware MPI as well as topography. Ocean models that are similar to ``Oceananigans.jl`` include MITgcm; [@Marshall1997] and MOM6 [@Adcroft2019], both written in Fortran. However,; ``Oceananigans.jl`` features a more efficient non-hydrostatic pressure solver; than MITgcm (and MOM6 is strictly hydrostatic). PALM [@Maronga2020] is Fortran; software for large eddy simulation of atmospheric and oceanic boundary layers; with complex boundaries on parallel CPU and GPU architectures. ``Oceananigans.jl``; is distinguished by its use of Julia which allows for a script-based interface as; opposed to a configuration-file-based interface used by MITgcm, MOM6, and PALM.; Dedalus [@Burns2020] is Python software with an intuitive script-based interface; that solves general partial differential equations, including the incompressible; Navier-Stokes equations, with spectral methods. # Acknowledgements. Our work is supported by the generosity of Eric and Wendy Schmidt by; recommendation of the Schmidt Futures program, and by the National Science; Foundation under grant AGS-6939393. # References; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md:4498,efficient,efficient,4498,paper/paper.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md,1,['efficient'],['efficient']
Energy Efficiency,"ould be used:. 1. [`RectilinearGrid`](@ref Oceananigans.Grids.RectilinearGrid) can be fashioned into lines, rectangles and boxes.; 2. [`LatitudeLongitudeGrid`](@ref Oceananigans.Grids.LatitudeLongitudeGrid) represents sectors of thin spherical shells, with cells bounded by lines of constant latitude and longitude.; 3. [`OrthogonalSphericalShellGrid`](@ref Oceananigans.Grids.OrthogonalSphericalShellGrid) represents sectors of thin spherical shells divided with mesh lines that intersect at right angles (thus, orthogonal) but are otherwise arbitrary. !!! note ""OrthogonalSphericalShellGrids.jl""; See the auxiliary package [`OrthogonalSphericalShellGrids.jl`](https://github.com/CliMA/OrthogonalSphericalShellGrids.jl); for recipes that implement some useful `OrthogonalSphericalShellGrid`, including the; [""tripolar"" grid](https://www.sciencedirect.com/science/article/abs/pii/S0021999196901369). For example, to make a `LatitudeLongitudeGrid` that wraps around the sphere, extends for 60 degrees latitude on either side of the equator, and also has 5 vertical levels down to 1000 meters, we write. ```jldoctest grids; architecture = CPU(). grid = LatitudeLongitudeGrid(architecture,; size = (180, 10, 5),; longitude = (-180, 180),; latitude = (-60, 60),; z = (-1000, 0)). # output; 180√ó10√ó5 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3√ó3√ó3 halo and with precomputed metrics; ‚îú‚îÄ‚îÄ longitude: Periodic Œª ‚àà [-180.0, 180.0) regularly spaced with ŒîŒª=2.0; ‚îú‚îÄ‚îÄ latitude: Bounded œÜ ‚àà [-60.0, 60.0] regularly spaced with ŒîœÜ=12.0; ‚îî‚îÄ‚îÄ z: Bounded z ‚àà [-1000.0, 0.0] regularly spaced with Œîz=200.0; ```. The main difference between the syntax for `LatitudeLongitudeGrid` versus that for the `RectilinearGrid` are the names of the horizontal coordinates:; `LatitudeLongitudeGrid` has `longitude` and `latitude` where `RectilinearGrid` has `x` and `y`. !!! note ""Extrinsic and intrinsic coordinate systems""; Every grid is associated with an ""extrinsic"" coordinate system: `Rectilinea",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:4835,meter,meters,4835,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['meter'],['meters']
Energy Efficiency,"ow the horizontally averaged temperature profile (top right), horizontally averaged turbulent kinetic energy; (middle right), and the horizontally averaged buoyancy flux (or temperature flux). [![Watch winds blowing over the ocean](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_0400.png)](https://www.youtube.com/watch?v=IRncfbvuiy8). ## [Free convection with wind stress](https://www.youtube.com/watch?v=ob6OMQgPfI4). An idealized simulation of a strong wind stress acting on the surface of a stratified ocean along with a cooling flux; that sucks heat out of the surface. The simulation employs a resolution of 256x256x256 volumes in a 100x100x100 m; horizontally periodic domain. A pretty strong wind stress of 0.1 N/m¬≤ is applied in the x direction which mechanically; mixes the upper layer of the ocean. Also, heat is sucked out of the ocean surface at a rate of 75 W/m¬≤ which cools the; surface water and making it denser. This cold dense water then sinks into the ocean interior, initiating a convective; process that keeps mixing the upper layer of the ocean. This leads to a ""mixed layer"" of constant temperature near the; surface of the ocean. You can also see the onset of Kelvin-Helmholtz instabilities as the mechanical mixing sets in. The video shows the temperature field and the domain is sliced in half for visualization. The line plots show the; horizontally averaged temperature profile (top right), horizontally averaged turbulent kinetic energy (middle right),; and the horizontally averaged buoyancy flux (or temperature flux). The unusual periodic prism colormap is used to show; the fine details at the surface as it cools and the layers of different temperatures (the isopycnals) being perturbed; by internal waves. [![Watch free convection with wind stress in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_unstable_7500.png)](https://www.youtube.com/watch?v=ob6OMQgPfI4). ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/gallery.md:4094,energy,energy,4094,docs/src/gallery.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/gallery.md,1,['energy'],['energy']
Energy Efficiency,"p_time=1hour). function init_save_some_metadata!(file, model); file[""author""] = ""Chim Riggles""; file[""parameters/coriolis_parameter""] = 1e-4; file[""parameters/density""] = 1027; return nothing; end. c_avg = Field(Average(model.tracers.c, dims=(1, 2))). # Note that model.velocities is NamedTuple; simulation.output_writers[:velocities] = JLD2OutputWriter(model, model.velocities,; filename = ""some_more_data.jld2"",; schedule = TimeInterval(20minute),; init = init_save_some_metadata!); ```. and a time- and horizontal-average of tracer `c` every 20 minutes of simulation time; to a file called `some_more_averaged_data.jld2`. ```@example jld2_output_writer; simulation.output_writers[:avg_c] = JLD2OutputWriter(model, (; c=c_avg),; filename = ""some_more_averaged_data.jld2"",; schedule = AveragedTimeInterval(20minute, window=5minute)); ```. See [`JLD2OutputWriter`](@ref) for more information. ## Time-averaged output. Time-averaged output is specified by setting the `schedule` keyword argument for either `NetCDFOutputWriter` or; `JLD2OutputWriter` to [`AveragedTimeInterval`](@ref). With `AveragedTimeInterval`, the time-average of ``a`` is taken as a left Riemann sum corresponding to. ```math; \langle a \rangle = \frac{1}{T} \int_{t_i-T}^{t_i} a \, \mathrm{d} t \, ,; ```. where ``\langle a \rangle`` is the time-average of ``a``, ``T`` is the time-`window` for averaging specified by; the `window` keyword argument to `AveragedTimeInterval`, and the ``t_i`` are discrete times separated by the; time `interval`. The ``t_i`` specify both the end of the averaging window and the time at which output is written. ### Example. Building an `AveragedTimeInterval` that averages over a 1 day window, every 4 days,. ```jldoctest averaged_time_interval; using Oceananigans; using Oceananigans.Units. schedule = AveragedTimeInterval(4days, window=1day). # output; AveragedTimeInterval(window=1 day, stride=1, interval=4 days); ```. An `AveragedTimeInterval` schedule directs an output writer; to time-aver",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md:8069,schedul,schedule,8069,docs/src/model_setup/output_writers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md,1,['schedul'],['schedule']
Energy Efficiency,"r`](@ref) can be used to serialize the entire model state to a file from which the model; can be restored at any time. This is useful if you'd like to periodically checkpoint when running; long simulations in case of crashes or hitting cluster time limits, but also if you'd like to restore; from a checkpoint and try out multiple scenarios. For example, to periodically checkpoint the model state to disk every 1,000,000 seconds of simulation; time to files of the form `model_checkpoint_iteration12500.jld2` where `12500` is the iteration; number (automatically filled in). Here's an example where we checkpoint every 5 iterations. This is far more often than appropriate for; typical applications: we only do it here for illustration purposes. ```@repl checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1))). simulation = Simulation(model, Œît=1, stop_iteration=8). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=IterationInterval(5), prefix=""model_checkpoint""); ```. Again, for illustration purposes of this example, we also add another callback so we can see the iteration; of the simulation. ```@repl checkpointing; show_iteration(sim) = @info ""iteration: $(iteration(sim)); time: $(prettytime(sim.model.clock.time))""; add_callback!(simulation, show_iteration, name=:info, IterationInterval(1)); ```. Now let's run. ```@repl checkpointing; run!(simulation); ```. The default options should provide checkpoint files that are easy to restore from (in most cases).; For more advanced options and features, see [`Checkpointer`](@ref). ## Picking up a simulation from a checkpoint file. Picking up a simulation from a checkpoint requires the original script that was used to generate; the checkpoint data. Change the first instance of [`run!`](@ref) in the script to take `pickup=true`. When `pickup=true` is provided to `run!` then it finds the latest checkpoint file in the current working; directory, loads pr",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md:1048,schedul,schedule,1048,docs/src/model_setup/checkpointing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md,1,['schedul'],['schedule']
Energy Efficiency,"rbulent Prandtl number; ``\text{Pr}_t`` is usually chosen to be ``\mathcal{O}(1)`` from experimental observations. Assuming that the SGS energy cascade is equal to the overall dissipation rate ``\varepsilon`` from the; [Kolmogorov41](@citet) theory, [Lilly66](@citet) was able to derive a value of; ```math; C_s = \left( \frac{3}{2}C_K\pi^\frac{4}{3} \right)^{-\frac{3}{4}} \approx 0.16 \, ,; ```; using an empirical value of ``C_K \approx 1.6`` for the Kolmogorov constant. This seems reasonable for isotropic; turbulence if the grid spacing ``\Delta`` falls in the inertial range. In practice, ``C_s`` is a tunable parameter. Due to the presence of the constant ``C_s``, the model is sometimes referred to as the *constant Smagorinsky* model; in contrast to *dynamic Smagorinsky* models that dynamically compute ``C_s`` to account for effects such as buoyant; convection. ## Anisotropic minimum dissipation models. Minimum-dissipation eddy-viscosity models are a class of LES closures that use the minimum eddy dissipation required to; dissipate the energy of sub-grid scale motion. [Rozema15](@citet) proposed the first minimum-dissipation model; appropriate for use on anisotropic grids, termed the *anisotropic minimum dissipation* (AMD) model. It has a number of desirable properties over Smagorinsky-type closures: it is more cost-effective than dynamic; Smagorinsky, it appropriately switches off in laminar and transitional flows, and it is consistent with the exact SGS; stress tensor on both isotropic and anisotropic grids. [Abkar16](@citet) extended the AMD model to model SGS scalar; fluxes for tracer transport. [Abkar17](@citet) further extended the model to include a buoyancy term that accounts for; the contribution of buoyant forces to the production and suppression of turbulence. [Vreugdenhil18](@citet) derive a modified AMD model by following the requirement suggested by [Verstappen18](@citet),; which entail normalising the displacement, the velocity, and the velocity gradi",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md:4446,energy,energy,4446,docs/src/numerical_implementation/large_eddy_simulation.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md,1,['energy'],['energy']
Energy Efficiency,"ry. Other important keyword arguments are. * `indices` for outputting subregions, two- and one-dimensional slices of fields. Specifies the indices to write to disk with a `Tuple` of `Colon`, `UnitRange`,or `Int` elements. For example, `indices = (:, :, 1)` implies outputing ``x-y``-slices of the bottom-most index (`k=1`). Defaults to `(:, :, :)`, i.e., ""all indices"".; * `with_halos :: Boolean`: whether to output the halos (`true`) or only the interior points (`false`; default). * `array_type` for specifying the type of the array that holds outputted field data. The default is; `Array{Float64}`, or arrays of single-precision floating point numbers. Once an `OutputWriter` is created, it can be used to write output by adding it the; ordered dictionary `simulation.output_writers`. prior to calling `run!(simulation)`. More specific detail about the `NetCDFOutputWriter` and `JLD2OutputWriter` is given below. !!! tip ""Time step alignment and output writing""; Oceananigans simulations will shorten the time step as needed to align model output with each; output writer's schedule. ## NetCDF output writer. Model data can be saved to NetCDF files along with associated metadata. The NetCDF output writer is generally used by; passing it a dictionary of (label, field) pairs and any indices for slicing if you don't want to save the full 3D field. ### Examples. Saving the u velocity field and temperature fields as full 3D fields, surface 2D slices, and; 1D columns to separate NetCDF files:. ```@example netcdf1; using Oceananigans. grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1)). model = NonhydrostaticModel(grid=grid, tracers=:c). simulation = Simulation(model, Œît=12, stop_time=3600). fields = Dict(""u"" => model.velocities.u, ""c"" => model.tracers.c). simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filename=""more_fields.nc"", schedule=TimeInterval(60)); ```. ```@example netcdf1; simulation.output_writers[:surface_slice_writer] =; NetCDFOutputWrite",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md:2603,schedul,schedule,2603,docs/src/model_setup/output_writers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md,1,['schedul'],['schedule']
Energy Efficiency,"s.jl); 2. [`JLD2OutputWriter`](@ref) for arbitrary julia data structures that uses [JLD2.jl](https://github.com/JuliaIO/JLD2.jl); 3. [`Checkpointer`](@ref) that automatically saves as much model data as possible, using [JLD2.jl](https://github.com/JuliaIO/JLD2.jl). The `Checkpointer` is discussed in detail on a separate [section](@ref checkpointing) of the documentation. ## Basic usage. [`NetCDFOutputWriter`](@ref) and [`JLD2OutputWriter`](@ref) require four inputs:. 1. The `model` from which output data is sourced (required to initialize the `OutputWriter`).; 2. A key-value pairing of output ""names"" and ""output"" objects. `JLD2OutputWriter` accepts `NamedTuple`s and `Dict`s;; `NetCDFOutputWriter` accepts `Dict`s with string-valued keys. Output objects are either `AbstractField`s or; functions that return data when called via `func(model)`.; 3. A `schedule` on which output is written. `TimeInterval`, `IterationInterval`, `WallTimeInterval` schedule; periodic output according to the simulation time, simulation interval, or ""wall time"" (the physical time; according to a clock on your wall). A fourth `schedule` called `AveragedTimeInterval` specifies; periodic output that is time-averaged over a `window` prior to being written.; 4. The `filename` and `dir`ectory. Other important keyword arguments are. * `indices` for outputting subregions, two- and one-dimensional slices of fields. Specifies the indices to write to disk with a `Tuple` of `Colon`, `UnitRange`,or `Int` elements. For example, `indices = (:, :, 1)` implies outputing ``x-y``-slices of the bottom-most index (`k=1`). Defaults to `(:, :, :)`, i.e., ""all indices"".; * `with_halos :: Boolean`: whether to output the halos (`true`) or only the interior points (`false`; default). * `array_type` for specifying the type of the array that holds outputted field data. The default is; `Array{Float64}`, or arrays of single-precision floating point numbers. Once an `OutputWriter` is created, it can be used to write output by",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md:1203,schedul,schedule,1203,docs/src/model_setup/output_writers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md,1,['schedul'],['schedule']
Energy Efficiency,"tWriter` is given below. !!! tip ""Time step alignment and output writing""; Oceananigans simulations will shorten the time step as needed to align model output with each; output writer's schedule. ## NetCDF output writer. Model data can be saved to NetCDF files along with associated metadata. The NetCDF output writer is generally used by; passing it a dictionary of (label, field) pairs and any indices for slicing if you don't want to save the full 3D field. ### Examples. Saving the u velocity field and temperature fields as full 3D fields, surface 2D slices, and; 1D columns to separate NetCDF files:. ```@example netcdf1; using Oceananigans. grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1)). model = NonhydrostaticModel(grid=grid, tracers=:c). simulation = Simulation(model, Œît=12, stop_time=3600). fields = Dict(""u"" => model.velocities.u, ""c"" => model.tracers.c). simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filename=""more_fields.nc"", schedule=TimeInterval(60)); ```. ```@example netcdf1; simulation.output_writers[:surface_slice_writer] =; NetCDFOutputWriter(model, fields, filename=""another_surface_xy_slice.nc"",; schedule=TimeInterval(60), indices=(:, :, grid.Nz)); ```. ```@example netcdf1; simulation.output_writers[:averaged_profile_writer] =; NetCDFOutputWriter(model, fields,; filename = ""another_averaged_z_profile.nc"",; schedule = AveragedTimeInterval(60, window=20),; indices = (1, 1, :)); ```. `NetCDFOutputWriter` also accepts output functions that write scalars and arrays to disk,; provided that their `dimensions` are provided:. ```@example; using Oceananigans. Nx, Ny, Nz = 16, 16, 16. grid = RectilinearGrid(size=(Nx, Ny, Nz), extent=(1, 2, 3)). model = NonhydrostaticModel(grid=grid). simulation = Simulation(model, Œît=1.25, stop_iteration=3). f(model) = model.clock.time^2; # scalar output. g(model) = model.clock.time .* exp.(znodes(grid, Center())) # single-column profile output (vector). xC, yF = xnodes(grid, Center()), ynod",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md:3404,schedul,schedule,3404,docs/src/model_setup/output_writers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md,1,['schedul'],['schedule']
Energy Efficiency,"the minimum eddy dissipation required to; dissipate the energy of sub-grid scale motion. [Rozema15](@citet) proposed the first minimum-dissipation model; appropriate for use on anisotropic grids, termed the *anisotropic minimum dissipation* (AMD) model. It has a number of desirable properties over Smagorinsky-type closures: it is more cost-effective than dynamic; Smagorinsky, it appropriately switches off in laminar and transitional flows, and it is consistent with the exact SGS; stress tensor on both isotropic and anisotropic grids. [Abkar16](@citet) extended the AMD model to model SGS scalar; fluxes for tracer transport. [Abkar17](@citet) further extended the model to include a buoyancy term that accounts for; the contribution of buoyant forces to the production and suppression of turbulence. [Vreugdenhil18](@citet) derive a modified AMD model by following the requirement suggested by [Verstappen18](@citet),; which entail normalising the displacement, the velocity, and the velocity gradient by the filter width to ensure that; the resulting eddy dissipation properly counteracts the spurious kinetic energy transferred by convective nonlinearity,; to derive a modified AMD model. The eddy viscosity and diffusivity are defined in terms of eddy viscosity and diffusivity *predictors*; ``\nu_e^\dagger`` and ``\kappa_e^\dagger``, such that; ```math; \nu_e = \max \lbrace 0, \nu_e^\dagger \rbrace; \quad \text{and} \quad; \kappa_e = \max \lbrace 0, \kappa_e^\dagger \rbrace \, ,; ```; to ensure that ``\nu_e \ge 0`` and ``\kappa_e \ge 0``. Leaving out the overlines and understanding that all variables; represent the resolved/filtered variables, the eddy viscosity predictor is given by; ```math; \begin{equation}; \label{eq:nu-dagger}; \nu_e^\dagger = -(C\Delta)^2; \frac; {\left( \hat{\partial}_k \hat{v}_i \right) \left( \hat{\partial}_k \hat{v}_j \right) \hat{S}_{ij}; + C_b\hat{\delta}_{i3} \alpha g \left( \hat{\partial}_k \hat{v_i} \right) \hat{\partial}_k \theta}; {\left( \hat{",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md:5507,energy,energy,5507,docs/src/numerical_implementation/large_eddy_simulation.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md,1,['energy'],['energy']
Energy Efficiency,"ttps://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/free_convection_0956.png)](https://www.youtube.com/watch?v=yq4op9h3xcU). ### [Winds blowing over the ocean](https://www.youtube.com/watch?v=IRncfbvuiy8). [![Watch winds blowing over the ocean](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_0400.png)](https://www.youtube.com/watch?v=IRncfbvuiy8). ### [Free convection with wind stress](https://www.youtube.com/watch?v=ob6OMQgPfI4). [![Watch free convection with wind stress in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_unstable_7500.png)](https://www.youtube.com/watch?v=ob6OMQgPfI4). ## Performance benchmarks. We've performed some preliminary performance benchmarks (see the [performance benchmarks](https://clima.github.io/OceananigansDocumentation/stable/appendix/benchmarks/) section of the documentation) by initializing models of various sizes and measuring the wall clock time taken per model iteration (or time step). This is not really a fair comparison as we haven't parallelized across all the CPU's cores so we will revisit these benchmarks once Oceananigans.jl can run on multiple CPUs and GPUs. To make full use of or fully saturate the computing power of a GPU such as an Nvidia Tesla V100 or; a Titan V, the model should have around ~10 million grid points or more. Sometimes counter-intuitively running with `Float32` is slower than `Float64`. This is likely due; to type mismatches causing slowdowns as floats have to be converted between 32-bit and 64-bit, an; issue that needs to be addressed meticulously. Due to other bottlenecks such as memory accesses and; GPU register pressure, `Float32` models may not provide much of a speedup so the main benefit becomes; lower memory costs (by around a factor of 2). ![Performance benchmark plots](https://user-images.githubusercontent.com/20099589/89906791-d2c85b00-dbb9-11ea-969a-4b8db2c31680.png); ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:11199,power,power,11199,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['power'],['power']
Energy Efficiency,"umerical_implementation/assets/staggered_grid.png); *A schematic of `Oceananigans.jl` finite volumes for a two-dimensional staggered grid in ``(x, z)``.; Tracers ``c`` and pressure ``p`` are defined at the center of the control volume. The ``u`` control volumes are ; centered on the left and right edges of the pressure control volume while the ``w`` control volumes are centered ; on the top and bottom edges of the pressure control volumes. The indexing convention places the ``i^{\rm{th}}`` ; ``u``-node on cell ``x``-faces to the left of the ``i`` tracer point at cell centers.*. This staggered arrangement of variables is more complicated than the collocated grid arrangement but is greatly; beneficial as it avoids the odd-even decoupling between the pressure and velocity if they are stored at the same; positions. ¬ß6.1 of [Patankar80](@citet) discusses this problem in the presence of a zigzag pressure field: on a 1D; collocated grid the velocity at the point ``i`` is influenced by the pressure at points ``i-1`` and ``i+1``, and a zigzag; pressure field will be felt as a uniform pressure, which is obviously wrong and would reduce the accuracy of the; solution. The pressure is effectively taken from a coarser grid than what is actually used. The basic problem is that; the momentum equations will use the pressure difference between two alternate points when it should be using two; adjacent points. From the viewpoint of linear algebra, these spurious pressure modes correspond to solutions in the null space of the; pressure projection operator with eigenvalue zero and are thus indistinguishable from a uniform pressure field; [Sani81](@cite). The staggered grid was first introduced by [Harlow65](@citet) with their *marker and cell* method. In meteorology; and oceanography, this particular staggered grid configuration is referred to as the Arakawa C-grid after [Arakawa77](@citet), who; investigated four different staggered grids and the unstaggered A-grid for use in an atmosp",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/staggered_grid.md:1889,reduce,reduce,1889,docs/src/appendix/staggered_grid.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/staggered_grid.md,1,['reduce'],['reduce']
Energy Efficiency,"viscosity and ``\varepsilon`` the average rate of dissipation of turbulence kinetic energy per; unit mass. As pointed out way back by [Corrsin61](@citet), to run a simulation on a horizontal domain about 10 times the size of an; ""average eddy"" with 100 vertical levels and where the grid spacing is given by ``\eta`` would require the computer to; store on the order of ``10^{14}`` variables.[^1] This is still impractical today, although may be within; reach in less than a decade. He ends by suggesting the use of an analog rather digital computer---a tank of water. [^1]: And even then, ``\eta`` gives the *maximum* allowable grid spacing. There is significant flow structure; smaller than ``\eta``. To have any hope of simulating high Reynolds number flows we need some way of resolving the sub-grid scale motions.[^2]. [^2]: In reality there is no need to resolve all motions down to the Kolmogorov length scale to achieve; acceptable accuracy. Perhaps good results can be achieved if 80\% of the kinetic energy is resolved; (¬ß13) [Pope00](@cite). ## Reynolds-averaged Navier‚ÄìStokes equations. Following [Reynolds1895](@citet), we can decompose flow variables such as velocity ``\boldsymbol{v}`` into the mean component; ``\overline{\boldsymbol{v}}`` and the fluctuating component ``\boldsymbol{v}^\prime`` so that ``\boldsymbol{v} = \overline{\boldsymbol{v}} + \boldsymbol{v}^\prime``; [see ¬ß4 of [Pope00](@citet) for a modern discussion]. Expressing the Navier-Stokes equations in tensor notation; ```math; \begin{align}; \partial_i v_i &= 0 \, ,\\; \partial_t v_i + v_j \partial_j v_i &= f_i - \alpha\partial_i p + \nu \partial_j \partial_j v_i \, ,; \end{align}; ```; where ``\alpha = \rho^{-1}`` is the specific volume and ``f_i`` represents external forces. We can plug in the Reynolds; decomposition for ``\boldsymbol{v}`` and after some manipulation arrive at the following form for the *Reynolds-averaged; Navier-Stokes equations*; ```math; \begin{align}; \partial_i \overline{u}_i &= 0 ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md:1319,energy,energy,1319,docs/src/numerical_implementation/turbulence_closures.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md,1,['energy'],['energy']
Energy Efficiency,"which if evaluated at the cell centers just returns the cell averages we already compute in the finite volume method. ## Smagorinsky-Lilly model. [Smagorinsky63](@citet) estimated the eddy viscosity ``\nu_e`` via a characteristic length scale ``\Delta`` times a velocity; scale given by ``\Delta |\overline{S}|`` where ``|\overline{S}| = \sqrt{2\overline{S}_{ij}\overline{S}_{ij}}``. Thus the; SGS stress tensor is given by; ```math; \tau_{ij} = -2 \nu_e \overline{S}_{ij} = -2 (C_s \Delta)^2 |\overline{S}| \overline{S}_{ij} \, ,; ```; where ``C_s`` is a dimensionless constant. The grid spacing is usually used for the characteristic length scale ``\Delta``.; The eddy diffusivities are calculated via ``\kappa_e = \nu_e / \text{Pr}_t`` where the turbulent Prandtl number; ``\text{Pr}_t`` is usually chosen to be ``\mathcal{O}(1)`` from experimental observations. Assuming that the SGS energy cascade is equal to the overall dissipation rate ``\varepsilon`` from the; [Kolmogorov41](@citet) theory, [Lilly66](@citet) was able to derive a value of; ```math; C_s = \left( \frac{3}{2}C_K\pi^\frac{4}{3} \right)^{-\frac{3}{4}} \approx 0.16 \, ,; ```; using an empirical value of ``C_K \approx 1.6`` for the Kolmogorov constant. This seems reasonable for isotropic; turbulence if the grid spacing ``\Delta`` falls in the inertial range. In practice, ``C_s`` is a tunable parameter. Due to the presence of the constant ``C_s``, the model is sometimes referred to as the *constant Smagorinsky* model; in contrast to *dynamic Smagorinsky* models that dynamically compute ``C_s`` to account for effects such as buoyant; convection. ## Anisotropic minimum dissipation models. Minimum-dissipation eddy-viscosity models are a class of LES closures that use the minimum eddy dissipation required to; dissipate the energy of sub-grid scale motion. [Rozema15](@citet) proposed the first minimum-dissipation model; appropriate for use on anisotropic grids, termed the *anisotropic minimum dissipation* (AMD) model.",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md:3531,energy,energy,3531,docs/src/numerical_implementation/large_eddy_simulation.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md,1,['energy'],['energy']
Energy Efficiency,"x, y, z)`` is average velocity of a fluid particle whose average position is ``(x, y, z)`` ; at time ``t``. The average position of a fluid particle ``\boldsymbol{\xi}(t) = (\xi, \eta, \zeta)`` ; is thus governed by; ```math; \partial_t \boldsymbol{\xi} + \boldsymbol{v}(\boldsymbol{\xi}, t) \boldsymbol{\cdot} \boldsymbol{\nabla} \boldsymbol{\xi} = \boldsymbol{v}(\boldsymbol{\xi}, t) \, ,; ```; which is the same relationship that holds when surface waves are not present and ``\boldsymbol{v}`` ; ceases to be an averaged velocity field. The simplicity of the governing equations for Lagrangian-mean ; momentum is the main reason we use a Lagrangian-mean formulation in Oceananigans.jl, rather ; than an Eulerian-mean formulation: for example, the tracer conservation equation is unchanged ; by the inclusion of surface wave effects. Moreover, because the effect of surface waves manifests ; either as a bulk forcing of Lagrangian-mean momentum or as a modification to the effective background ; rotation rate of the interior fluid similar to any bulk forcing or Coriolis force, we do not ; explicitly include the effects of surface waves in turbulence closures that model the effects ; of subgrid turbulence. More specifically, the effect of steady surface waves does not effect ; the conservation of Lagrangian-mean turbulent kinetic energy. The Lagrangian-mean velocity field ``\boldsymbol{v}`` contrasts with the Eulerian-mean velocity ; field ``\boldsymbol{v}^E``, which is the fluid velocity averaged at the fixed Eulerian position ; ``(x, y, z)``. The surface wave Stokes drift field supplied by the user is, in fact, defined; by the difference between the Eulerian- and Lagrangian-mean velocity:; ```math; \boldsymbol{u}^S \equiv \boldsymbol{v} - \boldsymbol{v}^E \, .; ```; The Stokes drift velocity field is typically prescribed for idealized scenarios, or determined; from a wave model for the evolution of surface waves under time-dependent atmospheric winds; in more realistic cases.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/surface_gravity_waves.md:2464,energy,energy,2464,docs/src/physics/surface_gravity_waves.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/surface_gravity_waves.md,1,['energy'],['energy']
Energy Efficiency,"y saves as much model data as possible, using [JLD2.jl](https://github.com/JuliaIO/JLD2.jl). The `Checkpointer` is discussed in detail on a separate [section](@ref checkpointing) of the documentation. ## Basic usage. [`NetCDFOutputWriter`](@ref) and [`JLD2OutputWriter`](@ref) require four inputs:. 1. The `model` from which output data is sourced (required to initialize the `OutputWriter`).; 2. A key-value pairing of output ""names"" and ""output"" objects. `JLD2OutputWriter` accepts `NamedTuple`s and `Dict`s;; `NetCDFOutputWriter` accepts `Dict`s with string-valued keys. Output objects are either `AbstractField`s or; functions that return data when called via `func(model)`.; 3. A `schedule` on which output is written. `TimeInterval`, `IterationInterval`, `WallTimeInterval` schedule; periodic output according to the simulation time, simulation interval, or ""wall time"" (the physical time; according to a clock on your wall). A fourth `schedule` called `AveragedTimeInterval` specifies; periodic output that is time-averaged over a `window` prior to being written.; 4. The `filename` and `dir`ectory. Other important keyword arguments are. * `indices` for outputting subregions, two- and one-dimensional slices of fields. Specifies the indices to write to disk with a `Tuple` of `Colon`, `UnitRange`,or `Int` elements. For example, `indices = (:, :, 1)` implies outputing ``x-y``-slices of the bottom-most index (`k=1`). Defaults to `(:, :, :)`, i.e., ""all indices"".; * `with_halos :: Boolean`: whether to output the halos (`true`) or only the interior points (`false`; default). * `array_type` for specifying the type of the array that holds outputted field data. The default is; `Array{Float64}`, or arrays of single-precision floating point numbers. Once an `OutputWriter` is created, it can be used to write output by adding it the; ordered dictionary `simulation.output_writers`. prior to calling `run!(simulation)`. More specific detail about the `NetCDFOutputWriter` and `JLD2OutputWriter",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md:1365,schedul,schedule,1365,docs/src/model_setup/output_writers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md,1,['schedul'],['schedule']
Energy Efficiency,"y‚ÇÄ = rand(Nparticles). z‚ÇÄ = -0.5 * ones(Nparticles). species = [:rock, :paper, :scissors]. dna = [""TATACCCC"", ""CCTAGGAC"", ""CGATTTAA""]. particles = StructArray{LagrangianMicrobe}((x‚ÇÄ, y‚ÇÄ, z‚ÇÄ, species, dna));. lagrangian_particles = LagrangianParticles(particles). # output; 3 LagrangianParticles with eltype LagrangianMicrobe:; ‚îú‚îÄ‚îÄ 5 properties: (:x, :y, :z, :species, :dna); ‚îú‚îÄ‚îÄ particle-wall restitution coefficient: 1.0; ‚îú‚îÄ‚îÄ 0 tracked fields: (); ‚îî‚îÄ‚îÄ dynamics: no_dynamics; ```. !!! warn ""Custom properties on GPUs""; Not all data types can be passed to GPU kernels. If you intend to advect particles on the GPU make sure; particle properties consist of only simple data types. The symbols and strings in this example won't; work on the GPU. ## Writing particle properties to disk. Particle properties can be written to disk using JLD2 or NetCDF. When writing to JLD2 you can pass `model.particles` as part of the named tuple of outputs. ```@setup particles; using Oceananigans; grid = RectilinearGrid(size=(10, 10, 10), extent=(1, 1, 1)); Nparticles = 3; x‚ÇÄ = zeros(Nparticles); y‚ÇÄ = rand(Nparticles); z‚ÇÄ = -0.5 * ones(Nparticles); lagrangian_particles = LagrangianParticles(x=x‚ÇÄ, y=y‚ÇÄ, z=z‚ÇÄ); model = NonhydrostaticModel(; grid, particles=lagrangian_particles); ```. ```@example particles; JLD2OutputWriter(model, (; particles=model.particles), filename=""particles"", schedule=TimeInterval(15)); ```. When writing to NetCDF you should write particles to a separate file as the NetCDF dimensions differ for; particle trajectories. You can just pass `model.particles` straight to `NetCDFOutputWriter`:. ```@example particles; NetCDFOutputWriter(model, model.particles, filename=""particles.nc"", schedule=TimeInterval(15)); ```. !!! warn ""Outputting custom particle properties to NetCDF""; NetCDF does not support arbitrary data types. If you need to write custom particle properties to disk; that are not supported by NetCDF then you should use JLD2 (which should support almost any Julia data type).; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/lagrangian_particles.md:3496,schedul,schedule,3496,docs/src/model_setup/lagrangian_particles.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/lagrangian_particles.md,2,['schedul'],['schedule']
Energy Efficiency,"} = 0`` ; (Neumann on ``p`` for wall-bounded directions and periodic otherwise) and where ``\mathscr{F}`` ; denotes the source term for the Poisson equation. !!! note ""Hydrostatic approximation""; For problems in which the hydrostatic approximation is invoked, the Poisson equation for; pressure above only needs to be solved for the vertically integrated flow and the pressure; field is a two dimensional term ``p_S(x, y, t)``. ## Direct method. Discretizing elliptic problems that can be solved via a classical separation-of-variables approach, such as Poisson's; equation, results in a linear system of equations ``M \boldsymbol{x} = \boldsymbol{y}`` where ``M`` is a real symmetric matrix of block; tridiagonal form. This allows for the matrix to be decomposed and solved efficiently, provided that the eigenvalues and; eigenvectors of the blocks are known (¬ß2) [Buzbee70](@cite). In the case of Poisson's equation on a rectangle,; [Hockney65](@citet) has taken advantage of the fact that the fast Fourier transform can be used to perform the matrix; multiplication steps resulting in an even more efficient method. [Schumann88](@citet) describe the implementation of such; an algorithm for Poisson's equation on a staggered grid with Dirichlet, Neumann, and periodic boundary conditions. The method can be explained easily by taking the Fourier transform of both sides of \eqref{eq:poisson-pressure} to yield; ```math; \begin{equation}; \label{eq:poisson-spectral}; -(k_x^2 + k_y^2 + k_z^2) \widehat{p}_{NH} = \widehat{\mathscr{F}}; \quad \implies \quad; \widehat{p}_{NH} = - \frac{\widehat{\mathscr{F}}}{k_x^2 + k_y^2 + k_z^2} \, ,; \end{equation}; ```; where ``\widehat{\cdot}`` denotes the Fourier component. Here ``k_x``, ``k_y``, and ``k_z`` are the wavenumbers. However, when; solving the equation on a staggered grid we require a solution for ``p_{NH}`` that is second-order accurate such that; when when its Laplacian is computed, ``\nabla^2 p_{NH}`` matches ``\mathscr{F}`` to machine pre",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:1772,efficient,efficient,1772,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['efficient'],['efficient']
Integrability," C_b\hat{\delta}_{i3} \alpha g \left( \hat{\partial}_k \hat{v_i} \right) \hat{\partial}_k \theta}; {\left( \hat{\partial}_l \hat{v}_m \right) \left( \hat{\partial}_l \hat{v}_m \right)} \, ,; \end{equation}; ```; and the eddy diffusivity predictor by; ```math; \begin{equation}; \kappa_e^\dagger = -(C\Delta)^2; \frac; {\left( \hat{\partial}_k \hat{v}_i \right) \left( \hat{\partial}_k \hat{\theta} \right) \hat{\partial}_i \theta}; {\left( \hat{\partial}_l \hat{\theta} \right) \left( \hat{\partial}_l \hat{\theta} \right)} \, ,; \end{equation}; ```; where; ```math; \begin{equation}; \hat{x}_i = \frac{x_i}{\Delta_i}, \quad; \hat{v}_i(\hat{x}, t) = \frac{v_i(x, t)}{\Delta_i}, \quad; \hat{\partial}_i \hat{v}_j(\hat{x}, t) = \frac{\Delta_i}{\Delta_j} \partial_i v_j(x, t), \quad; \hat{\delta}_{i3} = \frac{\delta_{i3}}{\Delta_3} \, ,; \end{equation}; ```; so that the normalized rate of strain tensor is; ```math; \begin{equation}; \label{eq:S-hat}; \hat{S}_{ij} =; \frac{1}{2} \left[ \hat{\partial}_i \hat{v}_j(\hat{x}, t) + \hat{\partial}_j \hat{v}_i(\hat{x}, t) \right] \, .; \end{equation}; ```. In equations \eqref{eq:nu-dagger}--\eqref{eq:S-hat}, ``C`` is a modified Poincar√© ""constant"" that is independent from; the filter width ``\Delta`` but does depend on the accuracy of the discretization method used. [Abkar16](@citet) cite; ``C^2 = \frac{1}{12}`` for a spectral method and ``C^2 = \frac{1}{3}`` for a second-order accurate scheme. ``\Delta_i`` is; the filter width in the ``x_i``-direction, and ``\Delta`` is given by the square root of the harmonic mean of the squares; of the filter widths in each direction; ```math; \frac{1}{\Delta^2} = \frac{1}{3} \left( \frac{1}{\Delta x^2} + \frac{1}{\Delta y^2} + \frac{1}{\Delta z^2} \right) \, .; ```; The term multiplying ``C_b`` is the buoyancy modification introduced by [Abkar17](@citet) and is small for weakly; stratified flows. We have introduced the ``C_b`` constant so that the buoyancy modification term may be turned on and off.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md:7536,depend,depend,7536,docs/src/numerical_implementation/large_eddy_simulation.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md,1,['depend'],['depend']
Integrability," DefaultBoundaryCondition (FluxBoundaryCondition: Nothing); ‚îú‚îÄ‚îÄ bottom: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing); ‚îú‚îÄ‚îÄ top: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing); ‚îî‚îÄ‚îÄ immersed: ImmersedBoundaryCondition with west=Nothing, east=Nothing, south=Nothing, north=Nothing, bottom=Value, top=Nothing; ```. !!! warning ""`ImmersedBoundaryCondition`""; `ImmersedBoundaryCondition` is experimental.; Therefore, one should use it only when a finer level of control over the boundary conditions; at the immersed boundary is required, and the user is familiar with the implementation of boundary ; conditions on staggered grids. For all other cases , using the `immersed` argument of; `FieldBoundaryConditions` is preferred. A boundary condition that depends on the fields may be prescribed using the `immersed`; keyword argument in [`FieldBoundaryConditions`](@ref).; We illustrate field-dependent boundary conditions with an example that imposes linear bottom drag; on `u` on both the bottom facets of cells adjacent to an immersed boundary, _and_ the bottom boundary; of the underlying grid. First we create the boundary condition for the grid's bottom:. ```julia; @inline linear_drag(x, y, t, u) = - 0.2 * u; drag_u = FluxBoundaryCondition(linear_drag, field_dependencies=:u). # output; FluxBoundaryCondition: ContinuousBoundaryFunction linear_drag at (Nothing, Nothing, Nothing); ```. Next, we create the immersed boundary condition by adding the argument `z` to `linear_drag`; and imposing drag only on ""bottom"" facets of cells that neighbor immersed cells:. ```julia; @inline immersed_linear_drag(x, y, z, t, u) = - 0.2 * u; immersed_drag_u = FluxBoundaryCondition(immersed_linear_drag, field_dependencies=:u). u_immersed_bc = ImmersedBoundaryCondition(bottom = immersed_drag_u). # output; ImmersedBoundaryCondition:; ‚îú‚îÄ‚îÄ west: Nothing; ‚îú‚îÄ‚îÄ east: Nothing; ‚îú‚îÄ‚îÄ south: Nothing; ‚îú‚îÄ‚îÄ north: Nothing; ‚îú‚îÄ‚îÄ bottom: FluxBoundaryCondition: ContinuousBoundaryFunction immersed_linear_",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md:23101,depend,dependent,23101,docs/src/model_setup/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md,1,['depend'],['dependent']
Integrability," \, ,; \end{align}; ```; while treating the rest of the terms on the right hand side of \eqref{eq:momentum-time-integral} ; explicitly. The implicit treatment of pressure ensures that the velocity field obtained at ; time step ``n+1`` is divergence-free. To effect such a fractional step method, we define an intermediate velocity field ``\boldsymbol{v}^\star`` such that; ```math; \begin{equation}; \label{eq:intermediate-velocity-field}; \boldsymbol{v}^\star - \boldsymbol{v}^n = \int_{t_n}^{t_{n+1}} \boldsymbol{G}_{\boldsymbol{v}} \, \mathrm{d} t \, ,; \end{equation}; ```. The integral on the right of the equation for ``\boldsymbol{v}^\star`` may be approximated by a variety of explicit; methods. For example, a forward Euler method approximates the integral via; ```math; \begin{equation}; \int_{t_n}^{t_{n+1}} G \, \mathrm{d} t \approx \Delta t G^n \, ,; \label{eq:forward-euler}; \end{equation}; ```; for any time-dependent function ``G(t)``, while a second-order Adams-Bashforth method uses the approximation; ```math; \begin{equation}; \label{eq:adams-bashforth}; \int_{t_n}^{t_{n+1}} G \, \mathrm{d} t \approx; \Delta t \left [ \left ( \tfrac{3}{2} + \chi \right ) G^n ; - \left ( \tfrac{1}{2} + \chi \right ) G^{n-1} \right ] \, ,; \end{equation}; ```; where ``\chi`` is a parameter. [Ascher95](@citet) claim that ``\chi = \tfrac{1}{8}`` is optimal; ; ``\chi = -\tfrac{1}{2}`` yields the forward Euler scheme. Combining the equation \eqref{eq:intermediate-velocity-field} for ``\boldsymbol{v}^\star`` and the time integral; of the non-hydrostatic pressure \eqref{eq:pnon_implicit} yields; ```math; \begin{equation}; \label{eq:fractional-step}; \boldsymbol{v}^{n+1} - \boldsymbol{v}^\star = - \Delta t \boldsymbol{\nabla} p_{\rm{non}}^{n+1} \, .; \end{equation}; ```. Taking the divergence of fractional step equation \eqref{eq:fractional-step} and requiring that ; ``\boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{v}^{n+1} = 0`` yields a Poisson equation ; for the kinematic pressur",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/time_stepping.md:2775,depend,dependent,2775,docs/src/numerical_implementation/time_stepping.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/time_stepping.md,1,['depend'],['dependent']
Integrability," `z`-boundaries.; Alternative function signatures are specified by keyword arguments to; `BoundaryCondition`, as illustrated in subsequent examples. ### 4. Spatially- and temporally-varying flux with parameters. Boundary condition functions may be 'parameterized',. ```jldoctest; julia> @inline wind_stress(x, y, t, p) = - p.œÑ * cos(p.k * x) * cos(p.œâ * t); # function with parameters. julia> top_u_bc = FluxBoundaryCondition(wind_stress, parameters=(k=4œÄ, œâ=3.0, œÑ=1e-4)); FluxBoundaryCondition: ContinuousBoundaryFunction wind_stress at (Nothing, Nothing, Nothing); ```. !!! info ""Boundary condition functions with parameters""; The keyword argument `parameters` above specifies that `wind_stress` is called; with the signature `wind_stress(x, y, t, parameters)`. In principle, `parameters` is arbitrary.; However, relatively simple objects such as floating point numbers or `NamedTuple`s must be used; when running on the GPU. ### 5. 'Field-dependent' boundary conditions. Boundary conditions may also depend on model fields. For example, a linear drag boundary condition; is implemented with. ```jldoctest; julia> @inline linear_drag(x, y, t, u) = - 0.2 * u; linear_drag (generic function with 1 method). julia> u_bottom_bc = FluxBoundaryCondition(linear_drag, field_dependencies=:u); FluxBoundaryCondition: ContinuousBoundaryFunction linear_drag at (Nothing, Nothing, Nothing); ```. `field_dependencies` specifies the name of the dependent fields either with a `Symbol` or `Tuple` of `Symbol`s. ### 6. 'Field-dependent' boundary conditions with parameters. When boundary conditions depends on fields _and_ parameters, their functions take the form. ```jldoctest; julia> @inline quadratic_drag(x, y, t, u, v, drag_coeff) = - drag_coeff * u * sqrt(u^2 + v^2); quadratic_drag (generic function with 1 method). julia> u_bottom_bc = FluxBoundaryCondition(quadratic_drag, field_dependencies=(:u, :v), parameters=1e-3); FluxBoundaryCondition: ContinuousBoundaryFunction quadratic_drag at (Nothing, Nothin",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md:12321,depend,depend,12321,docs/src/model_setup/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md,1,['depend'],['depend']
Integrability," eddy simulation are defined in; [Oceanostics.jl](https://github.com/tomchor/Oceanostics.jl/blob/3b8f67338656557877ef8ef5ebe3af9e7b2974e2/src/TurbulentKineticEnergyTerms.jl#L35-L57),. ```julia; using Oceanostics: IsotropicPseudoViscousDissipationRate; Œµ = IsotropicViscousDissipationRate(model, u, v, w, ŒΩ); compute!(Œµ); ```; [Start an issue on Github](https://github.com/CliMA/Oceananigans.jl/issues/new) if more help is needed. ### Try to decrease the memory-use of your runs. GPU runs are sometimes memory-limited. A state-of-the-art Tesla V100 GPU has 32GB of; memory -- enough memory for simulations with about 100 million points, or grids a bit smaller; than 512 √ó 512 √ó 512. (The maximum grid size depends on some user-specified factors,; like the number of passive tracers or computed diagnostics.); For large simulations on the GPU, careful management of memory allocation may be required:. - Use the [`nvidia-smi`](https://developer.nvidia.com/nvidia-system-management-interface) command; line utility to monitor the memory usage of the GPU. It should tell you how much memory there is; on your GPU and how much of it you're using and you can run it from Julia via. ```julia; julia> ;; shell> run(`nvidia-smi`); ```. - Try to use higher-order advection schemes. In general when you use a higher-order scheme you need; fewer grid points to achieve the same accuracy that you would with a lower-order one. Refer to the; [documentation](https://clima.github.io/OceananigansDocumentation/stable/appendix/library/#Advection); for available advection schemes. - Manually define scratch space to be reused in diagnostics. By default, every time a user-defined; diagnostic is calculated the compiler reserves a new chunk of memory for that calculation, usually; called scratch space. In general, the more diagnostics, the more scratch space needed and the bigger; the memory requirements. However, if you explicitly create a scratch space and pass that same; scratch space for as many diagnostics as",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:8839,interface,interface,8839,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['interface'],['interface']
Integrability," just a link -- that reproduces the bug in the latest tagged version of Oceananigans. This is sometimes called the [""minimal working example""](https://en.wikipedia.org/wiki/Minimal_working_example). Reducing bug-producing code to a minimal example can dramatically decrease the time it takes to resolve an issue. * Paste the _entire_ error received when running the code snippet, even if it's unbelievably long. * Use triple backticks (e.g., ````` ```some_code; and_some_more_code;``` `````) to enclose code snippets, and other [markdown formatting syntax](https://docs.github.com/en/github/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) to make your issue easy and quick to read. * Report the Oceananigans version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created. Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general. ## But I want to _code_!. * New users help write Oceananigans code and documentation by [forking the Oceananigans repository](https://docs.github.com/en/github/collaborating-with-pull-requests/working-with-forks), [using git](https://guides.github.com/introduction/git-handbook/) to edit code and docs, and then creating a [pull request](https://docs.github.com/en/github/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork). Pull requests are reviewed by Oceananigans collaborators. * A pull request can be merged once it is reviewed and approved by collaborators. If the pull request author has write access, they have the responsibility of merging their pull request. Otherwise, Oceananigans.jl collaborators will execute the merge with permission from the pull request author. * Note: for small or minor changes (such as fixing a typo in documentation), the",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:1737,interface,interface,1737,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['interface'],['interface']
Integrability," ŒΩ). Œµ = Field(Œµ_op). compute!(Œµ); ```. Writing kernel functions like `isotropic_viscous_dissipation_rate_ccc`; requires understanding the C-grid, but incurs only one iteration over the domain. `KernelFunctionOperation`s for some diagnostics common to large eddy simulation are defined in; [Oceanostics.jl](https://github.com/tomchor/Oceanostics.jl/blob/3b8f67338656557877ef8ef5ebe3af9e7b2974e2/src/TurbulentKineticEnergyTerms.jl#L35-L57),. ```julia; using Oceanostics: IsotropicPseudoViscousDissipationRate; Œµ = IsotropicViscousDissipationRate(model, u, v, w, ŒΩ); compute!(Œµ); ```; [Start an issue on Github](https://github.com/CliMA/Oceananigans.jl/issues/new) if more help is needed. ### Try to decrease the memory-use of your runs. GPU runs are sometimes memory-limited. A state-of-the-art Tesla V100 GPU has 32GB of; memory -- enough memory for simulations with about 100 million points, or grids a bit smaller; than 512 √ó 512 √ó 512. (The maximum grid size depends on some user-specified factors,; like the number of passive tracers or computed diagnostics.); For large simulations on the GPU, careful management of memory allocation may be required:. - Use the [`nvidia-smi`](https://developer.nvidia.com/nvidia-system-management-interface) command; line utility to monitor the memory usage of the GPU. It should tell you how much memory there is; on your GPU and how much of it you're using and you can run it from Julia via. ```julia; julia> ;; shell> run(`nvidia-smi`); ```. - Try to use higher-order advection schemes. In general when you use a higher-order scheme you need; fewer grid points to achieve the same accuracy that you would with a lower-order one. Refer to the; [documentation](https://clima.github.io/OceananigansDocumentation/stable/appendix/library/#Advection); for available advection schemes. - Manually define scratch space to be reused in diagnostics. By default, every time a user-defined; diagnostic is calculated the compiler reserves a new chunk of memory for that c",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:8565,depend,depends,8565,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['depend'],['depends']
Integrability,"""Model compatibility""; `BackgroundFields` are only supported by [`NonhydrostaticModel`](@ref). ## Specifying background fields. `BackgroundField`s are defined by functions of ``(x, y, z, t)`` and optional parameters. A ; simple example is. ```jldoctest; using Oceananigans. U(x, y, z, t) = 0.2 * z. grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). model = NonhydrostaticModel(grid = grid, background_fields = (u=U,)). model.background_fields.velocities.u. # output; FunctionField located at (Face, Center, Center); ‚îú‚îÄ‚îÄ func: U (generic function with 1 method); ‚îú‚îÄ‚îÄ grid: 1√ó1√ó1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ clock: Clock{Float64, Float64}(time=0 seconds, iteration=0, last_Œît=Inf days); ‚îî‚îÄ‚îÄ parameters: nothing; ```. `BackgroundField`s are specified by passing them to the kwarg `background_fields`; in the `NonhydrostaticModel` constructor. The kwarg `background_fields` expects; a `NamedTuple` of fields, which are internally sorted into `velocities` and `tracers`,; wrapped in `FunctionField`s, and assigned their appropriate locations. `BackgroundField`s with parameters require using the `BackgroundField` wrapper:. ```jldoctest moar_background; using Oceananigans. parameters = (Œ±=3.14, N=1.0, f=0.1). # Background fields are defined via function of x, y, z, t, and optional parameters; U(x, y, z, t, Œ±) = Œ± * z; B(x, y, z, t, p) = - p.Œ± * p.f * y + p.N^2 * z . U_field = BackgroundField(U, parameters=parameters.Œ±); B_field = BackgroundField(B, parameters=parameters). # output; BackgroundField{typeof(B), @NamedTuple{Œ±::Float64, N::Float64, f::Float64}}; ‚îú‚îÄ‚îÄ func: B (generic function with 1 method); ‚îî‚îÄ‚îÄ parameters: (Œ± = 3.14, N = 1.0, f = 0.1); ```. When inserted into `NonhydrostaticModel`, we get. ```jldoctest moar_background; grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). model = NonhydrostaticModel(grid = grid, background_fields = (u=U_field, b=B_field),; tracers=:b, buoyancy=BuoyancyTracer()). model.background",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/background_fields.md:2756,wrap,wrapped,2756,docs/src/model_setup/background_fields.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/background_fields.md,1,['wrap'],['wrapped']
Integrability,"# Buoyancy model and equations of state. The buoyancy model determines the relationship between tracers and the buoyancy ``b`` in the momentum equation. ## Buoyancy tracer. The simplest buoyancy model uses buoyancy ``b`` itself as a tracer: ``b`` obeys the tracer; conservation equation and is used directly in the momentum equations. ## Seawater buoyancy. For seawater buoyancy is, in general, modeled as a function of conservative temperature; ``T``, absolute salinity ``S``, and depth below the ocean surface ``d`` via; ```math; \begin{equation}; b = - \frac{g}{\rho_0} \rho' \left (T, S, d \right ) \, ,; \label{eq:seawater-buoyancy}; \end{equation}; ```; where ``g`` is gravitational acceleration, ``\rho_0`` is the reference density.; The function ``\rho'(T, S, d)`` in the seawater buoyancy relationship that links conservative temperature,; salinity, and depth to the density perturbation is called the *equation of state*.; Both ``T`` and ``S`` obey the tracer conservation equation. ### Linear equation of state. Buoyancy is determined from a linear equation of state via; ```math; b = g \left ( \alpha T - \beta S \right ) \, ,; ```; where ``g`` is gravitational acceleration, ``\alpha`` is the thermal expansion coefficient,; and ``\beta`` is the haline contraction coefficient. ### Nonlinear equation of state. Buoyancy is determined by the simplified equations of state introduced by [Roquet15TEOS](@citet).; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/buoyancy_and_equations_of_state.md:1266,contract,contraction,1266,docs/src/physics/buoyancy_and_equations_of_state.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/buoyancy_and_equations_of_state.md,1,['contract'],['contraction']
Integrability,"# Contributors Guide. Thank you for considering contributing to Oceananigans! . Feel free to ask us questions and chat with us at any time about any topic at all; by . * [Opening a GitHub issue](https://github.com/CliMA/Oceananigans.jl/issues/new/choose); ; * [Creating a GitHub discussion](https://github.com/CliMA/Oceananigans.jl/discussions/new). * Sending a message to the [#oceananigans channel](https://julialang.slack.com/archives/C01D24C0CAH) on [Julia Slack](https://julialang.org/slack/). We follow the [ColPrac guide](https://github.com/SciML/ColPrac) for collaborative; practices. We ask that new contributors read that guide before submitting a pull request. ## Creating issues. The simplest way to contribute to Oceananigans is to create or comment on issues and discussions. The most useful bug reports:. * Provide an explicit code snippet -- not just a link -- that reproduces the bug in the latest tagged version of Oceananigans. This is sometimes called the [""minimal working example""](https://en.wikipedia.org/wiki/Minimal_working_example). Reducing bug-producing code to a minimal example can dramatically decrease the time it takes to resolve an issue. * Paste the _entire_ error received when running the code snippet, even if it's unbelievably long. * Use triple backticks (```` ``` ````) to enclose code snippets, and other [markdown formatting syntax](https://docs.github.com/en/github/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) to make your issue easy and quick to read. * Report the Oceananigans version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created. Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general. ## But I want to _code_!. * New users help write Oceananigans code and documentation by [forking the Oceanan",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md:362,message,message,362,CONTRIBUTING.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md,1,['message'],['message']
Integrability,"# Contributors Guide. Thank you for considering contributions to Oceananigans! We hope this guide; helps you make a contribution. Feel free to ask us questions and chat with us at any time about any topic at all; by:. * [Opening a GitHub issue](https://github.com/CliMA/Oceananigans.jl/issues/new). * [Creating a GitHub discussion](https://github.com/CliMA/Oceananigans.jl/discussions/new). * Sending a message to the [#oceananigans channel](https://julialang.slack.com/archives/C01D24C0CAH) on [Julia Slack](https://julialang.org/slack/). ## Creating issues. The simplest way to contribute to Oceananigans is to create or comment on issues and discussions. The most useful bug reports:. * Provide an explicit code snippet -- not just a link -- that reproduces the bug in the latest tagged version of Oceananigans. This is sometimes called the [""minimal working example""](https://en.wikipedia.org/wiki/Minimal_working_example). Reducing bug-producing code to a minimal example can dramatically decrease the time it takes to resolve an issue. * Paste the _entire_ error received when running the code snippet, even if it's unbelievably long. * Use triple backticks (e.g., ````` ```some_code; and_some_more_code;``` `````) to enclose code snippets, and other [markdown formatting syntax](https://docs.github.com/en/github/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) to make your issue easy and quick to read. * Report the Oceananigans version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created. Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general. ## But I want to _code_!. * New users help write Oceananigans code and documentation by [forking the Oceananigans repository](https://docs.github.com/en/github/collaborating-with-pull-requests/workin",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:403,message,message,403,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['message'],['message']
Integrability,"# Convergence Tests. Convergence tests are implemented in `/validation/convergence_tests` and range; from zero-dimensional time-stepper tests to two-dimensional integration tests that; involve non-trivial pressure fields, advection, and diffusion. For all tests except point exponential decay, we use the ``L_1`` norm,. ```math; L_1 \equiv \frac{\mathrm{mean} | \phi_\mathrm{sim} - \phi_\mathrm{exact} |}{\mathrm{mean} | \phi_\mathrm{exact} |}; ```. and ``L_\infty`` norm,. ```math; L_\infty \equiv \frac{\max | \phi_\mathrm{sim} - \phi_\mathrm{exact} |}{\max | \phi_\mathrm{exact} |} \, ,; ```. to compare simulated fields, ``\phi_\mathrm{sim}``, with exact, analytically-derived solutions; ``\phi_\mathrm{exact}``.; The field ``\phi`` may be a tracer field or a velocity field. ## Point Exponential Decay. This test analyzes time-stepper convergence by simulating the zero-dimensional, or spatially-uniform equation. ```math; \partial_t c = - c \, ,; ```. with the initial condition ``c = 1``, which has the analytical solution ``c = \mathrm{e}^{-t}``. We find the expected first-order convergence with decreasing time-step ``\Delta t`` using our; first-order accurate, ""modified second-order"" Adams-Bashforth time-stepping method:. ![Point exponential decay](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/point_exponential_decay_time_stepper_convergence.png). This result validates the correctness of the `Oceananigans` implementation of Adams-Bashforth time-stepping. ## One-dimensional advection and diffusion of a Gaussian. This and the following tests focus on convergence with grid spacing, ``\Delta x``. In one dimension with constant diffusivity ``\kappa`` and in the presence of a; constant velocity ``U``, a Gaussian evolves according to. ```math; c = \frac{\mathrm{e}^{- (x - U t)^2 / 4 \kappa t}}{\sqrt{4 \pi \kappa t}} \, .; ```. For this test we take the initial time as ``t=t_0``.; We simulate this problem with advection and ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md:161,integrat,integration,161,docs/src/appendix/convergence_tests.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md,1,['integrat'],['integration']
Integrability,"# Elliptic solvers. ## The elliptic problem for the pressure. The 3D non-hydrostatic pressure field is obtained by taking the divergence of the horizontal ; component of the momentum equations and invoking the vertical component to yield an elliptic ; Poisson equation for the non-hydrostatic kinematic pressure; ```math; \begin{equation}; \label{eq:poisson-pressure}; \nabla^2 p_{NH} = \frac{\boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{v}^n}{\Delta t} + \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{G}_{\boldsymbol{v}} \equiv \mathscr{F} \, ,; \end{equation}; ```; along with homogenous Neumann boundary conditions ``\boldsymbol{v} \cdot \boldsymbol{\hat{n}} = 0`` ; (Neumann on ``p`` for wall-bounded directions and periodic otherwise) and where ``\mathscr{F}`` ; denotes the source term for the Poisson equation. !!! note ""Hydrostatic approximation""; For problems in which the hydrostatic approximation is invoked, the Poisson equation for; pressure above only needs to be solved for the vertically integrated flow and the pressure; field is a two dimensional term ``p_S(x, y, t)``. ## Direct method. Discretizing elliptic problems that can be solved via a classical separation-of-variables approach, such as Poisson's; equation, results in a linear system of equations ``M \boldsymbol{x} = \boldsymbol{y}`` where ``M`` is a real symmetric matrix of block; tridiagonal form. This allows for the matrix to be decomposed and solved efficiently, provided that the eigenvalues and; eigenvectors of the blocks are known (¬ß2) [Buzbee70](@cite). In the case of Poisson's equation on a rectangle,; [Hockney65](@citet) has taken advantage of the fact that the fast Fourier transform can be used to perform the matrix; multiplication steps resulting in an even more efficient method. [Schumann88](@citet) describe the implementation of such; an algorithm for Poisson's equation on a staggered grid with Dirichlet, Neumann, and periodic boundary conditions. The method can be explained easily by ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:1015,integrat,integrated,1015,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['integrat'],['integrated']
Integrability,"# Forcing functions. ""Forcings"" are user-defined terms appended to right-hand side of; the momentum or tracer evolution equations. In `Oceananigans`, momentum; and tracer forcings are defined via julia functions. `Oceananigans` includes; an interface for implementing forcing functions that depend on spatial coordinates,; time, model velocity and tracer fields, and external parameters. ```@meta; DocTestSetup = quote; using Oceananigans; end; ```. Forcings are added to models by passing a `NamedTuple` of functions or forcing objects; to the `forcing` keyword argument in `NonhydrostaticModel`'s constructor.; By default, momentum and tracer forcing functions are assumed to be functions of; `x, y, z, t`. A basic example is. ```jldoctest; u_forcing(x, y, z, t) = exp(z) * cos(x) * sin(t). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, forcing=(u=u_forcing,)). model.forcing.u. # output; ContinuousForcing{Nothing} at (Face, Center, Center); ‚îú‚îÄ‚îÄ func: u_forcing (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (); ```. More general forcing functions are built via the `Forcing` constructor; described below. `Oceananigans` also provides two convenience types:. * `Relaxation` for damping terms that restore a field to a; target distribution outside of a masked region of space. `Relaxation` can be; used to implement sponge layers near the boundaries of a domain.; * `AdvectiveForcing` for advecting individual quantities by a separate or; ""slip"" velocity relative to both the prognostic model velocity field and any; `BackgroundField` velocity field. ## The `Forcing` constructor. The `Forcing` constructor provides an interface for specifying forcing functions that. 1. Depend on external parameters; and; 2. Depend on model fields at the `x, y, z` location that forcing is applied; and/or; 3. Require access to discrete model data. ### Forcing functions with external parameters. Most forcings involve externa",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:241,interface,interface,241,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,2,"['depend', 'interface']","['depend', 'interface']"
Integrability,"# Library. Documenting the public user interface. ## Oceananigans.jl. ```@autodocs; Modules = [Oceananigans]; Private = false; ```. ## Abstract operations. ```@autodocs; Modules = [Oceananigans.AbstractOperations]; Private = false; ```. ## Advection. ```@autodocs; Modules = [Oceananigans.Advection]; Private = false; ```. ## Architectures. ```@autodocs; Modules = [Oceananigans.Architectures]; Private = false; ```. ## Boundary conditions. ```@autodocs; Modules = [Oceananigans.BoundaryConditions]; Private = false; ```. ## Buoyancy models. ```@autodocs; Modules = [Oceananigans.BuoyancyModels]; Private = false; ```. ## Coriolis. ```@autodocs; Modules = [Oceananigans.Coriolis]; Private = false; ```. ## Diagnostics. ```@autodocs; Modules = [Oceananigans.Diagnostics]; Private = false; ```. ## Distributed. ```@autodocs; Modules = [Oceananigans.DistributedComputations]; Private = false; ```. ## Fields. ```@autodocs; Modules = [Oceananigans.Fields]; Private = false; ```. ## Forcings. ```@autodocs; Modules = [Oceananigans.Forcings]; Private = false; ```. ## Grids. ```@autodocs; Modules = [Oceananigans.Grids]; Private = false; ```. ## Immersed boundaries. ```@autodocs; Modules = [Oceananigans.ImmersedBoundaries]; Private = false; ```. ## Logger. ```@autodocs; Modules = [Oceananigans.Logger]; Private = false; Pages = [""Logger.jl""]; ```. ## Models. ```@autodocs; Modules = [Oceananigans.Models]; Private = false; ```. ### Non-hydrostatic models. ```@autodocs; Modules = [Oceananigans.Models.NonhydrostaticModels]; Private = false; ```. ### Hydrostatic free-surface models. ```@autodocs; Modules = [Oceananigans.Models.HydrostaticFreeSurfaceModels]; Private = false; ```. ### Shallow-water models. ```@autodocs; Modules = [Oceananigans.Models.ShallowWaterModels]; Private = false; ```. ### Lagrangian particle tracking. ```@autodocs; Modules = [Oceananigans.Models.LagrangianParticleTracking]; Private = false; ```. ## MultiRegion. ```@autodocs; Modules = [Oceananigans.MultiRegion]; Private = f",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/library.md:39,interface,interface,39,docs/src/appendix/library.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/library.md,1,['interface'],['interface']
Integrability,"# Oceananigans.jl. *üåä Fast and friendly fluid dynamics on CPUs and GPUs.*. Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic; and hydrostatic Boussinesq equations on CPUs and GPUs.; It runs on GPUs (wow, fast!), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans is written in Julia by the [Climate Modeling Alliance](https://clima.caltech.edu); and heroic external collaborators. ## Quick install. Oceananigans is a [registered Julia package](https://julialang.org/packages/). So to install it,. 1. [Download Julia](https://julialang.org/downloads/). 2. Launch Julia and type. ```julia; julia> using Pkg. julia> Pkg.add(""Oceananigans""); ```. !!! compat ""Julia 1.9 is required""; Oceananigans requires Julia 1.9 or later. If you're [new to Julia](https://docs.julialang.org/en/v1/manual/getting-started/) and its [wonderful `Pkg` manager](https://docs.julialang.org/en/v1/stdlib/Pkg/), the [Oceananigans wiki](https://github.com/CliMA/Oceananigans.jl/wiki) provides [more detailed installation instructions](https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans). ## The Oceananigans ""knowledge base"". It's _deep_ and includes:. * This documentation, which provides; * example Oceananigans scripts,; * tutorials that describe key Oceananigans objects and functions,; * explanations of Oceananigans finite-volume-based numerical methods,; * details of the dynamical equations solved by Oceananigans models, and; * a library documenting all user-facing Oceananigans objects and functions.; * [Discussions on the Oceananigans github](https://github.com/CliMA/Oceananigans.jl/discussions), covering topics like; * [""Computational science""](https://github.com/CliMA/Oceananigans.jl/discussions/categories/computational-science), or how to science and set up numeric",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md:359,interface,interface,359,docs/src/index.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md,1,['interface'],['interface']
Integrability,"# [Numerical implementation of boundary conditions](@id numerical_bcs). We adopt a mixed approach for implementing boundary conditions that uses both halo regions and ""direct""; imposition of boundary conditions, depending on the condition prescribed. We illustrate how boundary conditions are implemented by considering the tracer equation; ```math; \begin{align}; \partial_t c = - \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} c; - \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{q}_c; + F_c \, ,; \label{eq:tracer}; \end{align}; ```; where ``\boldsymbol{q}_c`` is the diffusive flux of ``c`` and ``F_c`` is an arbitrary source term. See [Model setup: boundary conditions](@ref model_step_bcs) for how to create and use these; boundary conditions in Oceananigans. ## Gradient boundary conditions. Users impose gradient boundary conditions by prescribing the gradient ``\gamma`` of a field ; ``c`` across an *external boundary* ``\partial \Omega_b``. The prescribed gradient ``\gamma`` ; may be a constant, discrete array of values, or an arbitrary function. The gradient boundary ; condition is enforced setting the value of halo points located outside the domain interior ; such that; ```math; \begin{equation}; \label{eq:gradient-bc}; \hat{\boldsymbol{n}} \boldsymbol{\cdot} \boldsymbol{\nabla} c |_{\partial \Omega_b} = \gamma \, .; \end{equation}; ```; where ``\hat{\boldsymbol{n}}`` is the vector normal to ``\partial \Omega_b``. Across the bottom boundary in ``z``, for example, this requires that; ```math; \begin{equation}; \label{eq:linear-extrapolation}; c_{i, j, 0} = c_{i, j, 1} + \gamma_{i, j, 1} \tfrac{1}{2} \left ( \Delta z_{i, j, 1} + \Delta z_{i, j, 0} \right ) \, ,; \end{equation}; ```; where ``\Delta z_{i, j, 1} = \Delta z_{i, j, 0}`` are the heights of the finite volume at ``i, j`` and ``k=1`` and ``k=0``.; This prescription implies that the ``z``-derivative of ``c`` across the boundary at ``k=1`` is; ```math; \begin{equation}; \partial_z c \, |_{i, j, 1} \equiv",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md:212,depend,depending,212,docs/src/numerical_implementation/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md,1,['depend'],['depending']
Integrability,"(); ```. More general forcing functions are built via the `Forcing` constructor; described below. `Oceananigans` also provides two convenience types:. * `Relaxation` for damping terms that restore a field to a; target distribution outside of a masked region of space. `Relaxation` can be; used to implement sponge layers near the boundaries of a domain.; * `AdvectiveForcing` for advecting individual quantities by a separate or; ""slip"" velocity relative to both the prognostic model velocity field and any; `BackgroundField` velocity field. ## The `Forcing` constructor. The `Forcing` constructor provides an interface for specifying forcing functions that. 1. Depend on external parameters; and; 2. Depend on model fields at the `x, y, z` location that forcing is applied; and/or; 3. Require access to discrete model data. ### Forcing functions with external parameters. Most forcings involve external, changeable parameters.; Here are two examples of `forcing_func`tions that depend on ; _(i)_ a single scalar parameter `s`, and _(ii)_ a `NamedTuple` of parameters, `p`:. ```jldoctest parameterized_forcing; # Forcing that depends on a scalar parameter `s`; u_forcing_func(x, y, z, t, s) = s * z. u_forcing = Forcing(u_forcing_func, parameters=0.1). # Forcing that depends on a `NamedTuple` of parameters `p`; T_forcing_func(x, y, z, t, p) = - p.Œº * exp(z / p.Œª) * cos(p.k * x) * sin(p.œâ * t). T_forcing = Forcing(T_forcing_func, parameters=(Œº=1, Œª=0.5, k=2œÄ, œâ=4œÄ)). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, forcing=(u=u_forcing, T=T_forcing), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S)). model.forcing.T. # output; ContinuousForcing{@NamedTuple{Œº::Int64, Œª::Float64, k::Float64, œâ::Float64}} at (Center, Center, Center); ‚îú‚îÄ‚îÄ func: T_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: (Œº = 1, Œª = 0.5, k = 6.283185307179586, œâ = 12.566370614359172); ‚îî‚îÄ‚îÄ field dependencies: (); ```. ```jldoctest parameterized_forcing; model.f",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:2078,depend,depend,2078,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['depend'],['depend']
Integrability,") that reproduces the issue. ## Setting up your development environment. * Install [Julia](https://julialang.org/) on your system. * Install `git` on your system if it is not already there (install XCode command line tools on; a Mac or `git bash` on Windows). * Login to your GitHub account and make a fork of the; [Oceananigans repository](https://github.com/CLiMA/Oceananigans.jl) by; clicking the ""Fork"" button. * Clone your fork of the Oceananigans repository (in terminal on Mac/Linux or git shell/; GUI on Windows) in the location you'd like to keep it.; ```; git clone https://github.com/your-user-name/Oceananigans.jl.git; ```. * Navigate to that folder in the terminal or in Anaconda Prompt if you're on Windows. * Connect your repository to the upstream (main project).; ```; git remote add oceananigans https://github.com/CLiMA/Oceananigans.jl.git; ```. * Create the development environment by opening Julia via `julia --project` then; typing in `] instantiate`. This will install all the dependencies in the Project.toml; file. Your development environment is now ready!. * You can test to make sure Oceananigans works by typing in `] test`. (This is equivalent to; `using Pkg; Pkg.test()`.) Doing so will run all the tests (and this can take a while).; Alternatively, you can run only one test script file by providing its name as an environment; variable. For example, to run the tests only from the `test_coriolis.jl` file we call:. ```; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; ```. ## Pull Requests. We follow the [ColPrac guide](https://github.com/SciML/ColPrac) for collaborative practices.; We ask that new contributors read that guide before submitting a pull request. Changes and contributions should be made via GitHub pull requests against the ``main`` branch. When you're done making changes, commit the changes you made. Chris Beams has written a ; [guide](https://chris.beams.io/posts/git-commit/) on how to write good commit messages. When yo",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:7328,depend,dependencies,7328,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['depend'],['dependencies']
Integrability,"* Provide an explicit code snippet -- not just a link -- that reproduces the bug in the latest tagged version of Oceananigans. This is sometimes called the [""minimal working example""](https://en.wikipedia.org/wiki/Minimal_working_example). Reducing bug-producing code to a minimal example can dramatically decrease the time it takes to resolve an issue. * Paste the _entire_ error received when running the code snippet, even if it's unbelievably long. * Use triple backticks (```` ``` ````) to enclose code snippets, and other [markdown formatting syntax](https://docs.github.com/en/github/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) to make your issue easy and quick to read. * Report the Oceananigans version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created. Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general. ## But I want to _code_!. * New users help write Oceananigans code and documentation by [forking the Oceananigans repository](https://docs.github.com/en/github/collaborating-with-pull-requests/working-with-forks), [using git](https://guides.github.com/introduction/git-handbook/) to edit code and docs, and then creating a [pull request](https://docs.github.com/en/github/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork). Pull requests are reviewed by Oceananigans collaborators. * A pull request can be merged once it is reviewed and approved by collaborators. If the pull request author has write access, they have the responsibility of merging their pull request. Otherwise, Oceananigans.jl collaborators will execute the merge with permission from the pull request author. * Note: for small or minor changes (such as fixing a typo in documentation), the",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md:1828,interface,interface,1828,CONTRIBUTING.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md,1,['interface'],['interface']
Integrability,", 20),; z = z_faces). # output; 10√ó1√ó4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on GPU with 3√ó0√ó3 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 20.0) regularly spaced with Œîx=2.0; ‚îú‚îÄ‚îÄ Flat y; ‚îî‚îÄ‚îÄ Bounded z ‚àà [0.0, 10.0] variably spaced with min(Œîz)=1.0, max(Œîz)=4.0; ```. !!! note ""GPU architecture requires a CUDA-enabled device""; To run the above example and create a grid on the GPU, an Nvidia GPU has to be available; and [`CUDA.jl`](https://cuda.juliagpu.org/stable/) must be working). For more information; see the [`CUDA.jl` documentation](https://cuda.juliagpu.org/stable/). The ``y``-dimension is ""missing"" because it's marked `Flat` in `topology = (Periodic, Flat, Bounded)`.; So nothing varies in ``y``: `y`-derivatives are 0.; Also, the keyword argument (or ""kwarg"" for short) that specifies the ``y``-domains may be omitted, and `size` has only two elements rather than 3 as in the first example.; In the stretched cell interfaces specified by `z_interfaces`, the number of; vertical cell interfaces is `Nz + 1 = length(z_interfaces) = 5`, where `Nz = 4` is the number; of cells in the vertical. A bit later in this tutorial, we'll give examples that illustrate how to build a grid thats [`Distributed`](@ref) across _multiple_ CPUs and GPUs. ## Grid types: squares, shells, and mountains. The shape of the physical domain determines what grid type should be used:. 1. [`RectilinearGrid`](@ref Oceananigans.Grids.RectilinearGrid) can be fashioned into lines, rectangles and boxes.; 2. [`LatitudeLongitudeGrid`](@ref Oceananigans.Grids.LatitudeLongitudeGrid) represents sectors of thin spherical shells, with cells bounded by lines of constant latitude and longitude.; 3. [`OrthogonalSphericalShellGrid`](@ref Oceananigans.Grids.OrthogonalSphericalShellGrid) represents sectors of thin spherical shells divided with mesh lines that intersect at right angles (thus, orthogonal) but are otherwise arbitrary. !!! note ""OrthogonalSphericalShellGrids.jl""; See the auxiliary package [`OrthogonalSpherica",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:3320,interface,interfaces,3320,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,2,['interface'],['interfaces']
Integrability,", z, t)` on `y`-boundaries;; * `f(x, y, t)` on `z`-boundaries.; Alternative function signatures are specified by keyword arguments to; `BoundaryCondition`, as illustrated in subsequent examples. ### 4. Spatially- and temporally-varying flux with parameters. Boundary condition functions may be 'parameterized',. ```jldoctest; julia> @inline wind_stress(x, y, t, p) = - p.œÑ * cos(p.k * x) * cos(p.œâ * t); # function with parameters. julia> top_u_bc = FluxBoundaryCondition(wind_stress, parameters=(k=4œÄ, œâ=3.0, œÑ=1e-4)); FluxBoundaryCondition: ContinuousBoundaryFunction wind_stress at (Nothing, Nothing, Nothing); ```. !!! info ""Boundary condition functions with parameters""; The keyword argument `parameters` above specifies that `wind_stress` is called; with the signature `wind_stress(x, y, t, parameters)`. In principle, `parameters` is arbitrary.; However, relatively simple objects such as floating point numbers or `NamedTuple`s must be used; when running on the GPU. ### 5. 'Field-dependent' boundary conditions. Boundary conditions may also depend on model fields. For example, a linear drag boundary condition; is implemented with. ```jldoctest; julia> @inline linear_drag(x, y, t, u) = - 0.2 * u; linear_drag (generic function with 1 method). julia> u_bottom_bc = FluxBoundaryCondition(linear_drag, field_dependencies=:u); FluxBoundaryCondition: ContinuousBoundaryFunction linear_drag at (Nothing, Nothing, Nothing); ```. `field_dependencies` specifies the name of the dependent fields either with a `Symbol` or `Tuple` of `Symbol`s. ### 6. 'Field-dependent' boundary conditions with parameters. When boundary conditions depends on fields _and_ parameters, their functions take the form. ```jldoctest; julia> @inline quadratic_drag(x, y, t, u, v, drag_coeff) = - drag_coeff * u * sqrt(u^2 + v^2); quadratic_drag (generic function with 1 method). julia> u_bottom_bc = FluxBoundaryCondition(quadratic_drag, field_dependencies=(:u, :v), parameters=1e-3); FluxBoundaryCondition: ContinuousBound",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md:12260,depend,dependent,12260,docs/src/model_setup/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md,1,['depend'],['dependent']
Integrability,",\text{s}^{-2}``,; we might alternatively specify. ```jldoctest buoyancy; julia> buoyancy = SeawaterBuoyancy(gravitational_acceleration=1.3); SeawaterBuoyancy{Float64}:; ‚îú‚îÄ‚îÄ gravitational_acceleration: 1.3; ‚îî‚îÄ‚îÄ equation_of_state: LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078). julia> model = NonhydrostaticModel(; grid, buoyancy, tracers=(:T, :S)); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ‚îú‚îÄ‚îÄ grid: 8√ó8√ó8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ timestepper: RungeKutta3TimeStepper; ‚îú‚îÄ‚îÄ advection scheme: Centered reconstruction order 2; ‚îú‚îÄ‚îÄ tracers: (T, S); ‚îú‚îÄ‚îÄ closure: Nothing; ‚îú‚îÄ‚îÄ buoyancy: SeawaterBuoyancy with g=1.3 and LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078) with gÃÇ = NegativeZDirection(); ‚îî‚îÄ‚îÄ coriolis: Nothing; ```. for example. ### Linear equation of state. To specify the thermal expansion and haline contraction coefficients; ``\alpha = 2 \times 10^{-3} \; \text{K}^{-1}`` and ``\beta = 5 \times 10^{-4} \text{psu}^{-1}``,. ```jldoctest; julia> buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion=2e-3, haline_contraction=5e-4)); SeawaterBuoyancy{Float64}:; ‚îú‚îÄ‚îÄ gravitational_acceleration: 9.80665; ‚îî‚îÄ‚îÄ equation_of_state: LinearEquationOfState(thermal_expansion=0.002, haline_contraction=0.0005); ```. ### Idealized nonlinear equations of state. Instead of a linear equation of state, six idealized (second-order) nonlinear equations of state; as described by [Roquet15Idealized](@citet) may be used. These equations of state are provided; via the [SeawaterPolynomials.jl](https://github.com/CliMA/SeawaterPolynomials.jl) package. ```jldoctest buoyancy; julia> using SeawaterPolynomials.SecondOrderSeawaterPolynomials. julia> eos = RoquetEquationOfState(:Freezing); BoussinesqEquationOfState{Float64}:; ‚îú‚îÄ‚îÄ seawater_polynomial: SecondOrderSeawaterPolynomial{Float64}; ‚îî‚îÄ‚îÄ reference_density: 1024.6; ; juli",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/buoyancy_and_equation_of_state.md:7353,contract,contraction,7353,docs/src/model_setup/buoyancy_and_equation_of_state.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/buoyancy_and_equation_of_state.md,1,['contract'],['contraction']
Integrability,"- \xi) \sin y \, ,; ```; which satisfies the boundary conditions ``u_y |_{y=0} = u_y |_{y=\pi} = 0`` and; ``v |_{y=0} = v |_{y=\pi} = 0``. The vorticity forcing is; ```math; F_{\omega} = - 2 \xi^\prime f_x \sin y + 4 f \sin y \, ,; ```; which implies that; ```math; F_v = - 2 \xi^\prime f_x \cos y + 4 f \cos y \, ,; ```; and ``F_v = \tfrac{1}{2} \sin 2 y``. ## Forced, fixed-slip flow. A forced flow satisfying ""fixed-slip"" boundary conditions at ``y=0`` and ``y=1`` has; the streamfunction; ```math; \psi(x, y, t) = - \cos [x - \xi(t)] (y^3 - y^2) \, ,; ```; and thus ``g(y) = y^3 - y^2``. The velocity field ``(u, v)`` is; ```math; u = f (3y^2 - 2 y) \, , \quad \text{and} \quad v = - f_x (y^3 - y^2) \, ,; ```; which satisfies the boundary conditions; ```math; u |_{y=0} = 0 \, , \quad u |_{y=1} = f \, , \quad \text{and} \quad v |_{y=0} = v |_{y=1} = 0 \, .; ```; The vorticity forcing is; ```math; F_{\omega} = - \xi^\prime f_x (y^3 - y^2 - 6y + 2) - f f_x (12 y^3 - 12 y^2 + 4 y) + f (y^3 - y^2 - 12 y + 4) \, ,; ```; which implies that; ```math; F_v = \xi^\prime f_x (\tfrac{1}{4} y^4 - \tfrac{1}{3} y^3 - 3 y^2 + 2y); + f f_x (3 y^4 - 4 y^3 + 2y^2 ) ; - f (\tfrac{1}{4} y^4 - \tfrac{1}{3} y^3 - 6 y^2 + 4 y) \, ,; ```; and; ```math; F_v = 3 y^5 - 5 y^4 + 2y^3 \, .; ```. We set up the problem in the same manner as the forced, free-slip problem above. Note that we ; also must the no-slip boundary condition ``u |_{y=0} = 0`` and the time-dependent fixed-slip ; condition ``u |_{y=1} = f``. As for the free-slip problem, we find that the error between the ; numerical and analytical solutions decreases with ``1 / N_x^2 \sim \Delta x^2``, where ``N_x``; is the number of grid points and ``\Delta x`` is the spatial resolution:. ![Forced fixed slip convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/forced_fixed_slip_convergence.png). The convergence tests are performed using both ``y`` and ``z`` as the bounded direction.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md:10042,depend,dependent,10042,docs/src/appendix/convergence_tests.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md,1,['depend'],['dependent']
Integrability,". ""Forcings"" are user-defined terms appended to right-hand side of; the momentum or tracer evolution equations. In `Oceananigans`, momentum; and tracer forcings are defined via julia functions. `Oceananigans` includes; an interface for implementing forcing functions that depend on spatial coordinates,; time, model velocity and tracer fields, and external parameters. ```@meta; DocTestSetup = quote; using Oceananigans; end; ```. Forcings are added to models by passing a `NamedTuple` of functions or forcing objects; to the `forcing` keyword argument in `NonhydrostaticModel`'s constructor.; By default, momentum and tracer forcing functions are assumed to be functions of; `x, y, z, t`. A basic example is. ```jldoctest; u_forcing(x, y, z, t) = exp(z) * cos(x) * sin(t). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, forcing=(u=u_forcing,)). model.forcing.u. # output; ContinuousForcing{Nothing} at (Face, Center, Center); ‚îú‚îÄ‚îÄ func: u_forcing (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (); ```. More general forcing functions are built via the `Forcing` constructor; described below. `Oceananigans` also provides two convenience types:. * `Relaxation` for damping terms that restore a field to a; target distribution outside of a masked region of space. `Relaxation` can be; used to implement sponge layers near the boundaries of a domain.; * `AdvectiveForcing` for advecting individual quantities by a separate or; ""slip"" velocity relative to both the prognostic model velocity field and any; `BackgroundField` velocity field. ## The `Forcing` constructor. The `Forcing` constructor provides an interface for specifying forcing functions that. 1. Depend on external parameters; and; 2. Depend on model fields at the `x, y, z` location that forcing is applied; and/or; 3. Require access to discrete model data. ### Forcing functions with external parameters. Most forcings involve external, changeable para",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:1085,depend,dependencies,1085,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['depend'],['dependencies']
Integrability,". ```jldoctest; julia> @inline linear_drag(x, y, t, u) = - 0.2 * u; linear_drag (generic function with 1 method). julia> u_bottom_bc = FluxBoundaryCondition(linear_drag, field_dependencies=:u); FluxBoundaryCondition: ContinuousBoundaryFunction linear_drag at (Nothing, Nothing, Nothing); ```. `field_dependencies` specifies the name of the dependent fields either with a `Symbol` or `Tuple` of `Symbol`s. ### 6. 'Field-dependent' boundary conditions with parameters. When boundary conditions depends on fields _and_ parameters, their functions take the form. ```jldoctest; julia> @inline quadratic_drag(x, y, t, u, v, drag_coeff) = - drag_coeff * u * sqrt(u^2 + v^2); quadratic_drag (generic function with 1 method). julia> u_bottom_bc = FluxBoundaryCondition(quadratic_drag, field_dependencies=(:u, :v), parameters=1e-3); FluxBoundaryCondition: ContinuousBoundaryFunction quadratic_drag at (Nothing, Nothing, Nothing); ```. Put differently, `Œæ, Œ∑, t` come first in the function signature, followed by field dependencies,; followed by `parameters` is `!isnothing(parameters)`. ### 7. Discrete-form boundary condition with parameters. Discrete field data may also be accessed directly from boundary condition functions; using the `discrete_form`. For example:. ```jldoctest; @inline filtered_drag(i, j, grid, clock, model_fields) =; @inbounds - 0.05 * (model_fields.u[i-1, j, 1] + 2 * model_fields.u[i, j, 1] + model_fields.u[i-1, j, 1]). u_bottom_bc = FluxBoundaryCondition(filtered_drag, discrete_form=true). # output; FluxBoundaryCondition: DiscreteBoundaryFunction with filtered_drag; ```. !!! info ""The 'discrete form' for boundary condition functions""; The argument `discrete_form=true` indicates to [`BoundaryCondition`](@ref) that `filtered_drag`; uses the 'discrete form'. Boundary condition functions that use the 'discrete form'; are called with the signature; ```julia; f(i, j, grid, clock, model_fields); ```; where `i, j` are grid indices that vary along the boundary, `grid` is `model.g",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md:13419,depend,dependencies,13419,docs/src/model_setup/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md,1,['depend'],['dependencies']
Integrability,"0, 64.0) regularly spaced with Œîx=4.0; ‚îú‚îÄ‚îÄ Periodic y ‚àà [0.0, 32.0) regularly spaced with Œîy=4.0; ‚îî‚îÄ‚îÄ Bounded z ‚àà [0.0, 8.0] regularly spaced with Œîz=2.0; ```. This simple grid. * Has a domain that's ""periodic"" in ``x, y``, but bounded in ``z``.; * Has `16` cells in `x`, `8` cells in `y`, and `4` cells in `z`. That means there are ``16 \times 8 \times 4 = 512`` cells in all.; * Has an `x` dimension that spans from `x=0`, to `x=64`. And `y` spans `y=0` to `y=32`, and `z` spans `z=0` to `z=8`.; * Has cells that are all the same size, dividing the box in 512 that each has dimension ``4 \times 4 \times 2``.; Note that length units are whatever is used to construct the grid, so it's up to the user to make sure that all inputs use consistent units. In building our first grid, we did not specify whether it should be constructed on the [`CPU`](@ref)` or [`GPU`](@ref).; As a result, the grid was constructed by default on the CPU.; Next we build a grid on the _GPU_ that's two-dimensional in ``x, z`` and has variably-spaced cell interfaces in the `z`-direction,. ```jldoctest grids_gpu; architecture = GPU(); z_faces = [0, 1, 3, 6, 10]. grid = RectilinearGrid(architecture,; topology = (Periodic, Flat, Bounded),; size = (10, 4),; x = (0, 20),; z = z_faces). # output; 10√ó1√ó4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on GPU with 3√ó0√ó3 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 20.0) regularly spaced with Œîx=2.0; ‚îú‚îÄ‚îÄ Flat y; ‚îî‚îÄ‚îÄ Bounded z ‚àà [0.0, 10.0] variably spaced with min(Œîz)=1.0, max(Œîz)=4.0; ```. !!! note ""GPU architecture requires a CUDA-enabled device""; To run the above example and create a grid on the GPU, an Nvidia GPU has to be available; and [`CUDA.jl`](https://cuda.juliagpu.org/stable/) must be working). For more information; see the [`CUDA.jl` documentation](https://cuda.juliagpu.org/stable/). The ``y``-dimension is ""missing"" because it's marked `Flat` in `topology = (Periodic, Flat, Bounded)`.; So nothing varies in ``y``: `y`-derivatives are 0.; Also, the keyword argument (",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:2187,interface,interfaces,2187,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['interface'],['interfaces']
Integrability,"2Fjuliapkgstats.com%2Fapi%2Fv1%2Ftotal_downloads%2FOceananigans&query=total_requests&&label=Total%20Downloads&style=flat-square"">; </a>; </p>. <!-- CI/CD badges -->; <p align=""center"">; <a href=""https://buildkite.com/clima/oceananigans"">; <img alt=""Buildkite CPU+GPU build status"" src=""https://img.shields.io/buildkite/4d921fc17b95341ea5477fb62df0e6d9364b61b154e050a123/main?logo=buildkite&label=Buildkite%20CPU%2BGPU&style=flat-square"">; </a>; <a href=""https://hub.docker.com/r/aliramadhan/oceananigans"">; <img alt=""Docker build status"" src=""https://img.shields.io/docker/cloud/build/aliramadhan/oceananigans?label=Docker&logo=docker&logoColor=white&style=flat-square"">; </a>; </p>. Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic; and hydrostatic Boussinesq equations on CPUs and GPUs.; It runs on GPUs (wow, [fast!](http://arxiv.org/abs/2309.06662)), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans.jl is developed by the [Climate Modeling Alliance](https://clima.caltech.edu) and heroic external collaborators. ## Contents. - [Contents](#contents); - [Installation instructions](#installation-instructions); - [Running your first model](#running-your-first-model); - [The Oceananigans knowledge base](#the-oceananigans-knowledge-base); - [Citing](#citing); - [Contributing](#contributing); - [Movies](#movies); - [Deep convection](#deep-convection); - [Free convection](#free-convection); - [Winds blowing over the ocean](#winds-blowing-over-the-ocean); - [Free convection with wind stress](#free-convection-with-wind-stress); - [Performance benchmarks](#performance-benchmarks). ## Installation instructions. Oceananigans is a [registered Julia package](https://julialang.org/packages/). So to install it,. 1. [Download Julia](https://julialang.org/downloads/) (version 1.9 or later). 2. Laun",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:3630,interface,interface,3630,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['interface'],['interface']
Integrability,"; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 1.0) regularly spaced with Œîx=0.25; ‚îú‚îÄ‚îÄ Periodic y ‚àà [0.0, 1.0) regularly spaced with Œîy=0.2; ‚îî‚îÄ‚îÄ Bounded z ‚àà [0.0, 1.0] variably spaced with min(Œîz)=0.1, max(Œîz)=0.4; ```. The cubic domain is divided into a ""primary mesh"" of ``4 \times 5 \times 4 = 80`` cells,; which are evenly spaced in ``x, y`` but variably spaced in ``z``.; Now, in addition to the primary mesh, the grid defines also a set of ""staggered"" grids whose cells are; shifted by half a cell width relative to the primary mesh.; In other words, the staggered grid cells have a ""location"" in each direction -- either `Center`,; and therefore co-located with the primary mesh, or `Face` and located over the interfaces of the; primary mesh.; For example, the primary or `Center` cell spacings in ``z`` are. ```jldoctest fields; zspacings(grid, Center()). # output; 4-element view(OffsetArray(::Vector{Float64}, 0:5), 1:4) with eltype Float64:; 0.1; 0.19999999999999998; 0.3; 0.4; ```. corresponding to cell interfaces located at `z = [0, 0.1, 0.3, 0.6, 1]`.; But then for the grid which is staggered in `z` relative to the primary mesh,. ```jldoctest fields; zspacings(grid, Face()). # output; 5-element view(OffsetArray(::Vector{Float64}, -1:5), 1:5) with eltype Float64:; 0.1; 0.15000000000000002; 0.24999999999999994; 0.3500000000000001; 0.3999999999999999; ```. The cells for the vertically staggered grid have different spacings than the primary mesh.; That's because the _edges_ of the vertically-staggered mesh coincide with the _nodes_ (the cell centers); of the primary mesh. The nodes of the primary mesh are. ```jldoctest fields; znodes(grid, Center(), with_halos=true). # output; 6-element OffsetArray(::Vector{Float64}, 0:5) with eltype Float64 with indices 0:5:; -0.05; 0.05; 0.2; 0.44999999999999996; 0.8; 1.2; ```. The center of the leftmost ""halo cell"" is `z = -0.05`, while the center of the first cell from the left is `z = 0.05`.; This means that the width of the first cell on the vertically",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md:2123,interface,interfaces,2123,docs/src/fields.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md,1,['interface'],['interfaces']
Integrability,"Field`s are defined by functions of ``(x, y, z, t)`` and optional parameters. A ; simple example is. ```jldoctest; using Oceananigans. U(x, y, z, t) = 0.2 * z. grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). model = NonhydrostaticModel(grid = grid, background_fields = (u=U,)). model.background_fields.velocities.u. # output; FunctionField located at (Face, Center, Center); ‚îú‚îÄ‚îÄ func: U (generic function with 1 method); ‚îú‚îÄ‚îÄ grid: 1√ó1√ó1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ clock: Clock{Float64, Float64}(time=0 seconds, iteration=0, last_Œît=Inf days); ‚îî‚îÄ‚îÄ parameters: nothing; ```. `BackgroundField`s are specified by passing them to the kwarg `background_fields`; in the `NonhydrostaticModel` constructor. The kwarg `background_fields` expects; a `NamedTuple` of fields, which are internally sorted into `velocities` and `tracers`,; wrapped in `FunctionField`s, and assigned their appropriate locations. `BackgroundField`s with parameters require using the `BackgroundField` wrapper:. ```jldoctest moar_background; using Oceananigans. parameters = (Œ±=3.14, N=1.0, f=0.1). # Background fields are defined via function of x, y, z, t, and optional parameters; U(x, y, z, t, Œ±) = Œ± * z; B(x, y, z, t, p) = - p.Œ± * p.f * y + p.N^2 * z . U_field = BackgroundField(U, parameters=parameters.Œ±); B_field = BackgroundField(B, parameters=parameters). # output; BackgroundField{typeof(B), @NamedTuple{Œ±::Float64, N::Float64, f::Float64}}; ‚îú‚îÄ‚îÄ func: B (generic function with 1 method); ‚îî‚îÄ‚îÄ parameters: (Œ± = 3.14, N = 1.0, f = 0.1); ```. When inserted into `NonhydrostaticModel`, we get. ```jldoctest moar_background; grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). model = NonhydrostaticModel(grid = grid, background_fields = (u=U_field, b=B_field),; tracers=:b, buoyancy=BuoyancyTracer()). model.background_fields.tracers.b. # output; FunctionField located at (Center, Center, Center); ‚îú‚îÄ‚îÄ func: B (generic function with 1 method); ‚îú‚îÄ‚îÄ grid: 1√ó1√ó",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/background_fields.md:2898,wrap,wrapper,2898,docs/src/model_setup/background_fields.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/background_fields.md,1,['wrap'],['wrapper']
Integrability,"Float64}; ‚îú‚îÄ‚îÄ func: u_forcing_func (generic function with 1 method); ‚îî‚îÄ‚îÄ parameters: 0.001; ```. The annotation `@inbounds` is crucial for performance when accessing array indices; of the fields in `model_fields`. ## `Relaxation`. `Relaxation` defines a special forcing function that restores a field at a specified `rate` to; a `target` distribution, within a region uncovered by a `mask`ing function.; `Relaxation` is useful for implementing sponge layers, as shown in the second example. The following code constructs a model in which all components; of the velocity field are damped to zero everywhere on a time-scale of 1000 seconds, or ~17 minutes:. ```jldoctest; damping = Relaxation(rate = 1/1000). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = NonhydrostaticModel(grid=grid, forcing=(u=damping, v=damping, w=damping)). model.forcing.w. # output; ContinuousForcing{Nothing} at (Center, Center, Face); ‚îú‚îÄ‚îÄ func: Relaxation(rate=0.001, mask=1, target=0); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:w,); ```. The constructor for `Relaxation` accepts the keyword arguments `mask`, and `target`,; which specify a `mask(x, y, z)` function that multiplies the forcing, and a `target(x, y, z)`; distribution for the quantity in question. By default, `mask` uncovered the whole domain; and `target` restores the field in question to 0. We illustrate usage of `mask` and `target` by implementing a sponge layer that relaxes; velocity fields to zero and restores temperature to a linear gradient in the bottom; 1/10th of the domain:. ```jldoctest sponge_layer; grid = RectilinearGrid(size=(1, 1, 1), x=(0, 1), y=(0, 1), z=(-1, 0)). damping_rate = 1/100 # relax fields on a 100 second time-scale; temperature_gradient = 0.001 # ‚Å∞C m‚Åª¬π; surface_temperature = 20 # ‚Å∞C (at z=0). target_temperature = LinearTarget{:z}(intercept=surface_temperature, gradient=temperature_gradient); bottom_mask = GaussianMask{:z}(center=-grid.Lz, width=grid.Lz/10). uvw_sponge = Relaxation(rate=da",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:8721,depend,dependencies,8721,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['depend'],['dependencies']
Integrability,"](https://doi.org/10.31223/X5570C), _Earth arXiv_, DOI: [10.31223/X5570C](https://doi.org/10.31223/X5570C). 1. Wagner, G. L., Hillier, A., Constantinou, N. C., Silvestri, S., Souza, A., Burns, K., Hill, C., Campin, J.-M., Marshall, J., and Ferrari, R. (2024). [Formulation and calibration of CATKE, a one-equation parameterization for microscale ocean mixing](https://doi.org/10.48550/arXiv.2306.13204), _arXiv_, arXiv:2306.13204. DOI: [10.48550/arXiv.2306.13204](https://doi.org/10.48550/arXiv.2306.13204). 1. Allred, T., Li, X., Wiersdorf, A., Greenman, B., and Gopalakrishnan, G. (2024). [FlowFPX: Nimble tools for debugging floating-point exceptions](https://doi.org/10.48550/arXiv.2403.15632), _arXiv_, arXiv:2403.15632. DOI: [10.48550/arXiv.2403.15632](https://doi.org/10.48550/arXiv.2403.15632). 1. Silvestri, S., Wagner, G. L., Constantinou, N. C., Hill, C., Campin, J.-M., Souza, A., Bishnu, S., Churavy, V., Marshall, J., and Ferrari, R. (2024) [A GPU-based ocean dynamical core for routine mesoscale-resolving climate simulations](https://doi.org/10.22541/essoar.171708158.82342448/v1), _ESS Open Archive_. DOI: [10.22541/essoar.171708158.82342448/v1](https://doi.org/10.22541/essoar.171708158.82342448/v1). 1. Silvestri, S., Wagner, G. L., Campin, J.-M., Constantinou, N. C., Hill, C., Souza, A., and Ferrari, R. (2024). [A new WENO-based momentum advection scheme for simulations of ocean mesoscale turbulence](https://doi.org/10.22541/essoar.170110657.76489860/v2), _ESS Open Archive_. DOI: [10.22541/essoar.170110657.76489860/v2](https://doi.org/10.22541/essoar.170110657.76489860/v2). 1. Whitley V. and Wenegrat, J. O. (2024) [Breaking internal waves on sloping topography: connecting parcel displacements to overturn size, interior-boundary exchanges, and mixing](https://doi.org/10.31223/X5PM5Q), _Earth Arxiv_. DOI: [10.31223/X5PM5Q](https://doi.org/10.31223/X5PM5Q). 1. Chen S., Strong-Wright J., and Taylor, J. R. (2024) [Modeling carbon dioxide removal via sinking of particulate",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md:6531,rout,routine,6531,docs/src/index.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md,1,['rout'],['routine']
Integrability,"_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: (Œº = 1, Œª = 0.5, k = 6.283185307179586, œâ = 12.566370614359172); ‚îî‚îÄ‚îÄ field dependencies: (); ```. ```jldoctest parameterized_forcing; model.forcing.u. # output; ContinuousForcing{Float64} at (Face, Center, Center); ‚îú‚îÄ‚îÄ func: u_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: 0.1; ‚îî‚îÄ‚îÄ field dependencies: (); ```. In this example, the objects passed to the `parameters` keyword in the construction of; `u_forcing` and `T_forcing` -- a floating point number for `u_forcing`, and a `NamedTuple`; of parameters for `T_forcing` -- are passed on to `u_forcing_func` and `T_forcing_func` when; they are called during time-stepping. The object passed to `parameters` is in principle arbitrary.; However, if using the GPU, then `typeof(parameters)` may be restricted by the requirements; of GPU-compiliability. ### Forcing functions that depend on model fields. Forcing functions may depend on model fields (velocity, tracers or auxiliary fields) evaluated at the `x, y, z` where forcing is applied.; Here's a somewhat non-sensical example:. ```jldoctest field_dependent_forcing; # Forcing that depends on the velocity fields `u`, `v`, and `w`; w_forcing_func(x, y, z, t, u, v, w) = - (u^2 + v^2 + w^2) / 2. w_forcing = Forcing(w_forcing_func, field_dependencies=(:u, :v, :w)). # Forcing that depends on salinity `S` and a scalar parameter; S_forcing_func(x, y, z, t, S, Œº) = - Œº * S. S_forcing = Forcing(S_forcing_func, parameters=0.01, field_dependencies=:S). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, forcing=(w=w_forcing, S=S_forcing), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S)). model.forcing.w. # output; ContinuousForcing{Nothing} at (Center, Center, Face); ‚îú‚îÄ‚îÄ func: w_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:u, :v, :w); ```. ```jldoctest field_dependent_forcing; model.forcing.S. # output; ContinuousForc",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:3849,depend,depend,3849,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['depend'],['depend']
Integrability,"`M = 0``. Note that in deriving \eqref{eq:vertically-integrated-continuity},; we used the bottom boundary condition ``w_{\rm bottom} = \boldsymbol{u}_{\rm bottom} \boldsymbol{\cdot} \boldsymbol{\nabla}_h H``. To form a linear system that can be solved implicitly we recast the vertically-integrated continuity; equation \eqref{eq:vertically-integrated-continuity} into a discrete integral form. The best way to do; so is by starting from the discrete version of the continuity equation (in this case without any surface; volume flux, ``M = 0``). ```math; \begin{align}; \label{eq:continuity-discrete}; \delta_x (A_x u) + \delta_y (A_y v) + \delta_z (A_z w) = 0 \, ,; \end{align}; ```. and summing it vertically to get:. ```math; \begin{align}; \label{eq:vertically-integrated-continuity-discrete}; \delta_x \sum_k (A_x u) + \delta_y \sum_k (A_y v) + A_z \underbrace{w(k = N_z + 1)}_{w_{\rm top}} = 0 \, .; \end{align}; ```. In equations \eqref{eq:continuity-discrete} and \eqref{eq:vertically-integrated-continuity-discrete} and; here after, we have abused notation and used, e.g., ``u`` and ``v`` to denote the volume averages; over grid cells of the quantities ``u`` and ``v`` respectively. Using ``w_{\rm top} = \partial_t \eta`` and; being a bit more explicit on the locations the difference operators act on,; \eqref{eq:vertically-integrated-continuity-discrete} becomes:. ```math; \begin{equation}; \label{eq:semi-discrete-integral-continuity}; A_z \partial_t \eta + \delta_{x}^{caa} \sum_{k} (A_x u) + \delta_y^{aca} \sum_k (A_y v) = 0 \, .; \end{equation}; ```. We can now apply the velocity fractional step equation (discussed in the [Time-stepping section](@ref time_stepping)) for the [hydrostatic model](@ref hydrostatic_free_surface_model):. ```math; \begin{equation}; \label{eq:hydrostatic-fractional-step}; \boldsymbol{u}^{n+1} = \boldsymbol{u}^{\star} - g \Delta t \, \boldsymbol{\nabla} \eta^{n+1} \, .; \end{equation}; ```. We impose that the ``n+1``-th time step velocity is consist",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:13715,integrat,integrated-continuity-discrete,13715,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['integrat'],['integrated-continuity-discrete']
Integrability,"ace ; œÜ‚Çã = latitude_faces(j-1); œÜ‚Ä≤ = œÜ‚Çã + m * scale_factor(œÜ‚Çã) / 2; return œÜ‚Çã + m * scale_factor(œÜ‚Ä≤); end; end. Lx = 360; Nx = Int(Lx / m); Ny = findfirst(latitude_faces.(1:Nx) .> 90) - 2. grid = LatitudeLongitudeGrid(size = (Nx, Ny),; longitude = (0, Lx),; latitude = latitude_faces,; topology = (Bounded, Bounded, Flat)). # output; 180√ó28√ó1 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Flat} on CPU with 3√ó3√ó0 halo and with precomputed metrics; ‚îú‚îÄ‚îÄ longitude: Bounded Œª ‚àà [0.0, 360.0] regularly spaced with ŒîŒª=2.0; ‚îú‚îÄ‚îÄ latitude: Bounded œÜ ‚àà [0.0, 77.2679] variably spaced with min(ŒîœÜ)=2.0003, max(ŒîœÜ)=6.95319; ‚îî‚îÄ‚îÄ z: Flat z ; ```. We've also illustrated the construction of a grid that is `Flat` in the vertical direction.; Now let's plot the metrics for this grid,. ```@setup plot; # Mercator scale factor; scale_factor(œÜ) = 1 / cosd(œÜ). # Compute cell interfaces with Mercator spacing; m = 2 # spacing at the equator in degrees; function latitude_faces(j); if j == 1 # equator; return 0; else # crudely estimate the location of the jth face ; œÜ‚Çã = latitude_faces(j-1); œÜ‚Ä≤ = œÜ‚Çã + m * scale_factor(œÜ‚Çã) / 2; return œÜ‚Çã + m * scale_factor(œÜ‚Ä≤); end; end. Lx = 360; Nx = Int(Lx / m). # Deduce number of cells south of 90·µíN; Œªf = latitude_faces.(1:Nx); Ny = findfirst(Œªf .> 90) - 2. grid = LatitudeLongitudeGrid(size = (Nx, Ny),; longitude = (0, Lx),; latitude = latitude_faces,; topology = (Bounded, Bounded, Flat)); ```. ```@example plot; œÜ = œÜnodes(grid, Center()); Œîx = xspacings(grid, Center(), Center(), with_halos=true)[1:Ny]; Œîy = yspacings(grid, Center())[1:Ny]. using CairoMakie. fig = Figure(size=(800, 400), title=""Spacings on a Mercator grid""); axx = Axis(fig[1, 1], xlabel=""Zonal spacing (km)"", ylabel=""Latitude (degrees)""); scatter!(axx, Œîx ./ 1e3, œÜ). axy = Axis(fig[1, 2], xlabel=""Meridional spacing (km)""); scatter!(axy, Œîy ./ 1e3, œÜ). hidespines!(axx, :t, :r); hidespines!(axy, :t, :l, :r); hideydecorations!(axy, grid=false). current_figure(); ```. ## Single-precision `Rectilinea",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:20830,interface,interfaces,20830,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['interface'],['interfaces']
Integrability,"ameters=(k=4œÄ, œâ=3.0, œÑ=1e-4)); FluxBoundaryCondition: ContinuousBoundaryFunction wind_stress at (Nothing, Nothing, Nothing); ```. !!! info ""Boundary condition functions with parameters""; The keyword argument `parameters` above specifies that `wind_stress` is called; with the signature `wind_stress(x, y, t, parameters)`. In principle, `parameters` is arbitrary.; However, relatively simple objects such as floating point numbers or `NamedTuple`s must be used; when running on the GPU. ### 5. 'Field-dependent' boundary conditions. Boundary conditions may also depend on model fields. For example, a linear drag boundary condition; is implemented with. ```jldoctest; julia> @inline linear_drag(x, y, t, u) = - 0.2 * u; linear_drag (generic function with 1 method). julia> u_bottom_bc = FluxBoundaryCondition(linear_drag, field_dependencies=:u); FluxBoundaryCondition: ContinuousBoundaryFunction linear_drag at (Nothing, Nothing, Nothing); ```. `field_dependencies` specifies the name of the dependent fields either with a `Symbol` or `Tuple` of `Symbol`s. ### 6. 'Field-dependent' boundary conditions with parameters. When boundary conditions depends on fields _and_ parameters, their functions take the form. ```jldoctest; julia> @inline quadratic_drag(x, y, t, u, v, drag_coeff) = - drag_coeff * u * sqrt(u^2 + v^2); quadratic_drag (generic function with 1 method). julia> u_bottom_bc = FluxBoundaryCondition(quadratic_drag, field_dependencies=(:u, :v), parameters=1e-3); FluxBoundaryCondition: ContinuousBoundaryFunction quadratic_drag at (Nothing, Nothing, Nothing); ```. Put differently, `Œæ, Œ∑, t` come first in the function signature, followed by field dependencies,; followed by `parameters` is `!isnothing(parameters)`. ### 7. Discrete-form boundary condition with parameters. Discrete field data may also be accessed directly from boundary condition functions; using the `discrete_form`. For example:. ```jldoctest; @inline filtered_drag(i, j, grid, clock, model_fields) =; @inbounds - 0.05",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md:12751,depend,dependent,12751,docs/src/model_setup/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md,1,['depend'],['dependent']
Integrability,"arch yet simple enough; for students and first-time programmers. ``Oceananigans.jl`` is being developed; as part of the Climate Modeling Alliance project for the simulation of; small-scale ocean physics at high-resolution that affect the evolution of; Earth‚Äôs climate. ``Oceananigans.jl`` is designed for high-resolution simulations in idealized; geometries and supports direct numerical simulation, large eddy simulation,; arbitrary numbers of active and passive tracers, and linear and nonlinear; equations of state for seawater. Under the hood, ``Oceananigans.jl`` employs a; finite volume algorithm similar to that used by the Massachusetts Institute of; Technology general circulation model [@Marshall1997]. ![Fig. 1](free_convection_and_baroclinic_instability.png); Fig. 1: (Left) Large eddy simulation of small-scale oceanic boundary layer; turbulence forced by a surface cooling in a horizontally periodic domain using; $256^3$ grid points. The upper layer is well-mixed by turbulent convection and; bounded below by a strong buoyancy interface. (Right) Simulation of; instability of a horizontal density gradient in a rotating channel using; $256\times512\times128$ grid points. A similar process called baroclinic; instability acting on basin-scale temperature gradients fills the oceans with; eddies that stir carbon and heat. Plots made with `matplotlib` [@Hunter2007]; and `cmocean` [@Thyng2016]. ``Oceananigans.jl`` leverages the Julia programming language [@Bezanson2017] to; implement high-level, low-cost abstractions, a friendly user interface, and a; high-performance model in one language and a common code base for execution on; the CPU or GPU with Julia‚Äôs native GPU compiler [@Besard2019]. Because Julia is; a high-level language, development is streamlined and users can flexibly specify; model configurations, set up arbitrary diagnostics and output, extend the code; base, and implement new features. Configuring a model with `architecture=CPU()`; or `architecture=GPU()` wil",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md:2040,interface,interface,2040,paper/paper.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md,1,['interface'],['interface']
Integrability,"bounded grid of cells; that divide up a cube with dimensions ``1 \times 1 \times 1``:. ```jldoctest fields; using Oceananigans. grid = RectilinearGrid(topology = (Periodic, Periodic, Bounded),; size = (4, 5, 4),; halo = (1, 1, 1),; x = (0, 1),; y = (0, 1),; z = [0, 0.1, 0.3, 0.6, 1]). # output; 4√ó5√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 1.0) regularly spaced with Œîx=0.25; ‚îú‚îÄ‚îÄ Periodic y ‚àà [0.0, 1.0) regularly spaced with Œîy=0.2; ‚îî‚îÄ‚îÄ Bounded z ‚àà [0.0, 1.0] variably spaced with min(Œîz)=0.1, max(Œîz)=0.4; ```. The cubic domain is divided into a ""primary mesh"" of ``4 \times 5 \times 4 = 80`` cells,; which are evenly spaced in ``x, y`` but variably spaced in ``z``.; Now, in addition to the primary mesh, the grid defines also a set of ""staggered"" grids whose cells are; shifted by half a cell width relative to the primary mesh.; In other words, the staggered grid cells have a ""location"" in each direction -- either `Center`,; and therefore co-located with the primary mesh, or `Face` and located over the interfaces of the; primary mesh.; For example, the primary or `Center` cell spacings in ``z`` are. ```jldoctest fields; zspacings(grid, Center()). # output; 4-element view(OffsetArray(::Vector{Float64}, 0:5), 1:4) with eltype Float64:; 0.1; 0.19999999999999998; 0.3; 0.4; ```. corresponding to cell interfaces located at `z = [0, 0.1, 0.3, 0.6, 1]`.; But then for the grid which is staggered in `z` relative to the primary mesh,. ```jldoctest fields; zspacings(grid, Face()). # output; 5-element view(OffsetArray(::Vector{Float64}, -1:5), 1:5) with eltype Float64:; 0.1; 0.15000000000000002; 0.24999999999999994; 0.3500000000000001; 0.3999999999999999; ```. The cells for the vertically staggered grid have different spacings than the primary mesh.; That's because the _edges_ of the vertically-staggered mesh coincide with the _nodes_ (the cell centers); of the primary mesh. The nodes of the primary mesh are. ```jldoctest fi",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md:1824,interface,interfaces,1824,docs/src/fields.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md,1,['interface'],['interfaces']
Integrability,"ce_model). The [`HydrostaticFreeSurfaceModel`](@ref) solves the incompressible Navier-Stokes equations under; the Boussinesq and hydrostatic approximations and with an arbitrary number of tracer conservation ; equations. Physics associated with individual terms in the momentum and tracer conservation; equations -- the background rotation rate of the equation's reference frame,; gravitational effects associated with buoyant tracers under the Boussinesq; approximation, generalized stresses and tracer fluxes associated with viscous and; diffusive physics, and arbitrary ""forcing functions"" -- are determined by the whims of the; user. ## Mass conservation and free surface evolution equation. The mass conservation equation is; ```math; 0 = \boldsymbol{\nabla}_h \boldsymbol{\cdot} \boldsymbol{u} + \partial_z w \, . ; ```. Given the horizontal flow ``\boldsymbol{u}`` we use the above to diagnose the vertical velocity ``w``.; We integrate the mass conservation equation from the bottom of the fluid (where ``w = 0``) up to; depth ``z`` and recover ``w(x, y, z, t)``. The free surface displacement ``\eta(x, y, t)`` satisfies the linearized kinematic boundary ; condition at the surface; ```math; \partial_t \eta = w(x, y, z=0, t) \, .; ```. ## The momentum conservation equation. The equations governing the conservation of momentum in a rotating fluid, including buoyancy; via the Boussinesq approximation are; ```math; \begin{align}; \partial_t \boldsymbol{u} & = - \left ( \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} \right ) \boldsymbol{u}; - \boldsymbol{f} \times \boldsymbol{u} ; - \boldsymbol{\nabla}_h (p + g \eta); - \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{\tau}; + \boldsymbol{F_u} \, , \label{eq:momentum}\\; 0 & = b - \partial_z p \, , \label{eq:hydrostatic}; \end{align}; ```; where ``b`` the is buoyancy, ``\boldsymbol{\tau}`` is the hydrostatic kinematic stress tensor, ; ``\boldsymbol{F_u}`` denotes an internal forcing of the horizontal flow ``\boldsymbol{u",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/hydrostatic_free_surface_model.md:1002,integrat,integrate,1002,docs/src/physics/hydrostatic_free_surface_model.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/hydrostatic_free_surface_model.md,1,['integrat'],['integrate']
Integrability,"d be used for a one-dimensional grid. ### The dimensions: `x, y, z` for `RectilinearGrid`, or `latitude, longitude, z` for `LatitudeLongitudeGrid`. These keyword arguments specify the extent and location of the finite volume cells that divide up the; three dimensions of the grid.; For `RectilinearGrid`, the dimensions are called `x`, `y`, and `z`, whereas for `LatitudeLongitudeGrid` the; dimensions are called `latitude`, `longitude`, and `z`.; The type of each keyword argument determines how the dimension is divided up:. * Tuples that specify only the end points indicate that the dimension should be divided into; equally-spaced cells. For example, `x = (0, 64)` with `size = (16, 8, 4)` means that the; `x`-dimension is divided into 16 cells, where the first or leftmost cell interface is located; at `x = 0` and the last or rightmost cell interface is located at `x = 64`. The width of each cell is `Œîx=4.0`.; * Vectors and functions alternatively give the location of each cell interface, and thereby may be used; to build grids that are divided into cells of varying width. ## A complicated example: three-dimensional `RectilinearGrid` with variable spacing via functions. Next we build a grid that is both `Bounded` and stretched in both the `y` and `z` directions.; The purpose of the stretching is to increase grid resolution near the boundaries.; We'll do this by using functions to specify the keyword arguments `y` and `z`. ```jldoctest grids; Nx = Ny = 64; Nz = 32. Lx = Ly = 1e4; Lz = 1e3. # Note that j varies from 1 to Ny; chebychev_spaced_y_faces(j) = Ly * (1 - cos(œÄ * (j - 1) / Ny)) / 2. # Note that k varies from 1 to Nz; chebychev_spaced_z_faces(k) = - Lz * (1 + cos(œÄ * (k - 1) / Nz)) / 2. grid = RectilinearGrid(size = (Nx, Ny, Nz),; topology = (Periodic, Bounded, Bounded),; x = (0, Lx),; y = chebychev_spaced_y_faces,; z = chebychev_spaced_z_faces). # output; 64√ó64√ó32 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 10",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:15941,interface,interface,15941,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['interface'],['interface']
Integrability,"derSeawaterPolynomial{Float64}; ‚îî‚îÄ‚îÄ reference_density: 1024.6; ; julia> eos.seawater_polynomial # the density anomaly; œÅ' = 0.7718 S·¥¨ - 0.0491 Œò - 0.005027 Œò¬≤ - 2.5681e-5 Œò Z + 0.0 S·¥¨¬≤ + 0.0 S·¥¨ Z + 0.0 S·¥¨ Œò. julia> buoyancy = SeawaterBuoyancy(equation_of_state=eos); SeawaterBuoyancy{Float64}:; ‚îú‚îÄ‚îÄ gravitational_acceleration: 9.80665; ‚îî‚îÄ‚îÄ equation_of_state: BoussinesqEquationOfState{Float64}; ```. ### TEOS-10 equation of state. A high-accuracy 55-term polynomial approximation to the TEOS-10 equation of state suitable for use in; Boussinesq models as described by [Roquet15TEOS](@citet) is implemented in the; [SeawaterPolynomials.jl](https://github.com/CliMA/SeawaterPolynomials.jl) package and may be used. ```jldoctest buoyancy; julia> using SeawaterPolynomials.TEOS10. julia> eos = TEOS10EquationOfState(); BoussinesqEquationOfState{Float64}:; ‚îú‚îÄ‚îÄ seawater_polynomial: TEOS10SeawaterPolynomial{Float64}; ‚îî‚îÄ‚îÄ reference_density: 1020.0; ```. ## The direction of gravitational acceleration. To simulate gravitational accelerations that don't align with the vertical (`z`) coordinate,; we wrap the buoyancy model in; `Buoyancy()` function call, which takes the keyword arguments `model` and `gravity_unit_vector`,. ```jldoctest buoyancy; julia> grid = RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1));. julia> Œ∏ = 45; # degrees. julia> gÃÉ = (0, sind(Œ∏), cosd(Œ∏));. julia> buoyancy = Buoyancy(model=BuoyancyTracer(), gravity_unit_vector=gÃÉ); Buoyancy:; ‚îú‚îÄ‚îÄ model: BuoyancyTracer; ‚îî‚îÄ‚îÄ gravity_unit_vector: (0.0, 0.707107, 0.707107). julia> model = NonhydrostaticModel(; grid, buoyancy, tracers=:b); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ‚îú‚îÄ‚îÄ grid: 8√ó8√ó8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ timestepper: RungeKutta3TimeStepper; ‚îú‚îÄ‚îÄ advection scheme: Centered reconstruction order 2; ‚îú‚îÄ‚îÄ tracers: b; ‚îú‚îÄ‚îÄ closure: Nothing; ‚îú‚îÄ‚îÄ buoyancy: BuoyancyTracer with gÃÇ = (0.0, 0.707107, 0.707107); ‚îî‚îÄ‚îÄ coriolis: Nothing; ```. ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/buoyancy_and_equation_of_state.md:9416,wrap,wrap,9416,docs/src/model_setup/buoyancy_and_equation_of_state.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/buoyancy_and_equation_of_state.md,1,['wrap'],['wrap']
Integrability,"e are two examples of `forcing_func`tions that depend on ; _(i)_ a single scalar parameter `s`, and _(ii)_ a `NamedTuple` of parameters, `p`:. ```jldoctest parameterized_forcing; # Forcing that depends on a scalar parameter `s`; u_forcing_func(x, y, z, t, s) = s * z. u_forcing = Forcing(u_forcing_func, parameters=0.1). # Forcing that depends on a `NamedTuple` of parameters `p`; T_forcing_func(x, y, z, t, p) = - p.Œº * exp(z / p.Œª) * cos(p.k * x) * sin(p.œâ * t). T_forcing = Forcing(T_forcing_func, parameters=(Œº=1, Œª=0.5, k=2œÄ, œâ=4œÄ)). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, forcing=(u=u_forcing, T=T_forcing), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S)). model.forcing.T. # output; ContinuousForcing{@NamedTuple{Œº::Int64, Œª::Float64, k::Float64, œâ::Float64}} at (Center, Center, Center); ‚îú‚îÄ‚îÄ func: T_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: (Œº = 1, Œª = 0.5, k = 6.283185307179586, œâ = 12.566370614359172); ‚îî‚îÄ‚îÄ field dependencies: (); ```. ```jldoctest parameterized_forcing; model.forcing.u. # output; ContinuousForcing{Float64} at (Face, Center, Center); ‚îú‚îÄ‚îÄ func: u_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: 0.1; ‚îî‚îÄ‚îÄ field dependencies: (); ```. In this example, the objects passed to the `parameters` keyword in the construction of; `u_forcing` and `T_forcing` -- a floating point number for `u_forcing`, and a `NamedTuple`; of parameters for `T_forcing` -- are passed on to `u_forcing_func` and `T_forcing_func` when; they are called during time-stepping. The object passed to `parameters` is in principle arbitrary.; However, if using the GPU, then `typeof(parameters)` may be restricted by the requirements; of GPU-compiliability. ### Forcing functions that depend on model fields. Forcing functions may depend on model fields (velocity, tracers or auxiliary fields) evaluated at the `x, y, z` where forcing is applied.; Here's a somewhat non-sensical example:. ```jldoctest field_depen",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:3034,depend,dependencies,3034,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['depend'],['dependencies']
Integrability,"e restricted by the requirements; of GPU-compiliability. ### Forcing functions that depend on model fields. Forcing functions may depend on model fields (velocity, tracers or auxiliary fields) evaluated at the `x, y, z` where forcing is applied.; Here's a somewhat non-sensical example:. ```jldoctest field_dependent_forcing; # Forcing that depends on the velocity fields `u`, `v`, and `w`; w_forcing_func(x, y, z, t, u, v, w) = - (u^2 + v^2 + w^2) / 2. w_forcing = Forcing(w_forcing_func, field_dependencies=(:u, :v, :w)). # Forcing that depends on salinity `S` and a scalar parameter; S_forcing_func(x, y, z, t, S, Œº) = - Œº * S. S_forcing = Forcing(S_forcing_func, parameters=0.01, field_dependencies=:S). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, forcing=(w=w_forcing, S=S_forcing), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S)). model.forcing.w. # output; ContinuousForcing{Nothing} at (Center, Center, Face); ‚îú‚îÄ‚îÄ func: w_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:u, :v, :w); ```. ```jldoctest field_dependent_forcing; model.forcing.S. # output; ContinuousForcing{Float64} at (Center, Center, Center); ‚îú‚îÄ‚îÄ func: S_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: 0.01; ‚îî‚îÄ‚îÄ field dependencies: (:S,); ```. The `field_dependencies` arguments follow `x, y, z, t` in the forcing `func`tion in; the order they are specified in `Forcing`.; If both `field_dependencies` and `parameters` are specified, then the `field_dependencies`; arguments follow `x, y, z, t`, and `parameters` follow `field_dependencies`. Model fields that arise in the arguments of continuous `Forcing` `func`tions are; automatically interpolated to the staggered grid location at which the forcing is applied. ### ""Discrete form"" forcing functions. ""Discrete form"" forcing functions are either called with the signature. ```julia; func(i, j, k, grid, clock, model_fields); ```. or the parameterized form. ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:4783,depend,dependencies,4783,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['depend'],['dependencies']
Integrability,"e the projection ; of the equation right hand side onto eigenvectors. So an eigenvector based approach to solving; the Poisson equation is not computationally efficient. For problems with grids that are non uniform in multiple directions, we use instead a pre-conditioned conjugate; gradient iterative solver. Such cases include curvilinear grids on the sphere and also telescoping cartesian; grids that stretch along more than one dimension. There are two forms of the pressure operator in this approach.; One is rigid lid form and one is an implicit free-surface form. ### Rigid lid pressure operator. The rigid lid operator is based on the same continuous form as is used in the Direct Method; solver. ### Implicit free surface pressure operator. The implicit free surface solver solves for the free-surface, ``\eta(x, y, t)``, in the vertically; integrated continuity equation:. ```math; \begin{equation}; \label{eq:vertically-integrated-continuity}; \partial_t \eta + \partial_x \left ( \int_{-H}^0 u \, \mathrm{d}z \right ) + \partial_y \left ( \int_{-H}^0 v \, \mathrm{d}z \right ) = M \, ,; \end{equation}; ```. where ``H(x, y)`` is the depth of the water column (to first order with respect to the free surface; elevation) and ``M`` is some surface volume flux (e.g., terms such as precipitation, evaporation and; runoff); currently Oceananigans.jl assumes ``M = 0``. Note that in deriving \eqref{eq:vertically-integrated-continuity},; we used the bottom boundary condition ``w_{\rm bottom} = \boldsymbol{u}_{\rm bottom} \boldsymbol{\cdot} \boldsymbol{\nabla}_h H``. To form a linear system that can be solved implicitly we recast the vertically-integrated continuity; equation \eqref{eq:vertically-integrated-continuity} into a discrete integral form. The best way to do; so is by starting from the discrete version of the continuity equation (in this case without any surface; volume flux, ``M = 0``). ```math; \begin{align}; \label{eq:continuity-discrete}; \delta_x (A_x u) + \delta_y (A_y",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:12286,integrat,integrated-continuity,12286,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['integrat'],['integrated-continuity']
Integrability,"edTuple{Œº::Int64, Œª::Float64, k::Float64, œâ::Float64}} at (Center, Center, Center); ‚îú‚îÄ‚îÄ func: T_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: (Œº = 1, Œª = 0.5, k = 6.283185307179586, œâ = 12.566370614359172); ‚îî‚îÄ‚îÄ field dependencies: (); ```. ```jldoctest parameterized_forcing; model.forcing.u. # output; ContinuousForcing{Float64} at (Face, Center, Center); ‚îú‚îÄ‚îÄ func: u_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: 0.1; ‚îî‚îÄ‚îÄ field dependencies: (); ```. In this example, the objects passed to the `parameters` keyword in the construction of; `u_forcing` and `T_forcing` -- a floating point number for `u_forcing`, and a `NamedTuple`; of parameters for `T_forcing` -- are passed on to `u_forcing_func` and `T_forcing_func` when; they are called during time-stepping. The object passed to `parameters` is in principle arbitrary.; However, if using the GPU, then `typeof(parameters)` may be restricted by the requirements; of GPU-compiliability. ### Forcing functions that depend on model fields. Forcing functions may depend on model fields (velocity, tracers or auxiliary fields) evaluated at the `x, y, z` where forcing is applied.; Here's a somewhat non-sensical example:. ```jldoctest field_dependent_forcing; # Forcing that depends on the velocity fields `u`, `v`, and `w`; w_forcing_func(x, y, z, t, u, v, w) = - (u^2 + v^2 + w^2) / 2. w_forcing = Forcing(w_forcing_func, field_dependencies=(:u, :v, :w)). # Forcing that depends on salinity `S` and a scalar parameter; S_forcing_func(x, y, z, t, S, Œº) = - Œº * S. S_forcing = Forcing(S_forcing_func, parameters=0.01, field_dependencies=:S). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, forcing=(w=w_forcing, S=S_forcing), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S)). model.forcing.w. # output; ContinuousForcing{Nothing} at (Center, Center, Face); ‚îú‚îÄ‚îÄ func: w_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:u,",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:3803,depend,depend,3803,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['depend'],['depend']
Integrability,"emperature_gradient = 0.001 # ‚Å∞C m‚Åª¬π; surface_temperature = 20 # ‚Å∞C (at z=0). target_temperature = LinearTarget{:z}(intercept=surface_temperature, gradient=temperature_gradient); bottom_mask = GaussianMask{:z}(center=-grid.Lz, width=grid.Lz/10). uvw_sponge = Relaxation(rate=damping_rate, mask=bottom_mask); T_sponge = Relaxation(rate=damping_rate, mask=bottom_mask, target=target_temperature). model = NonhydrostaticModel(grid=grid, forcing=(u=uvw_sponge, v=uvw_sponge, w=uvw_sponge, T=T_sponge), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S)). model.forcing.u. # output; ContinuousForcing{Nothing} at (Face, Center, Center); ‚îú‚îÄ‚îÄ func: Relaxation(rate=0.01, mask=exp(-(z + 1.0)^2 / (2 * 0.1^2)), target=0); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:u,); ```. ```jldoctest sponge_layer; model.forcing.T. # output; ContinuousForcing{Nothing} at (Center, Center, Center); ‚îú‚îÄ‚îÄ func: Relaxation(rate=0.01, mask=exp(-(z + 1.0)^2 / (2 * 0.1^2)), target=20.0 + 0.001 * z); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:T,); ```. ## `AdvectiveForcing`. `AdvectiveForcing` defines a forcing function that represents advection by; a separate or ""slip"" velocity relative to the prognostic model velocity field.; `AdvectiveForcing` is implemented with native Oceananigans advection operators,; which means that tracers advected by the ""flux form"" advection term; ``ùõÅ‚ãÖùêÆ_{\rm slip} c``. Caution is advised when ``ùêÆ_{\rm slip}`` is not divergence free. As an example, consider a model for sediment settling at a constant rate:. ```jldoctest; using Oceananigans. r_sediment = 1e-4 # [m] ""Fine sand""; œÅ_sediment = 1200 # kg m‚Åª¬≥; œÅ_ocean = 1026 # kg m‚Åª¬≥; Œîb = 9.81 * (œÅ_ocean - œÅ_sediment) / œÅ_ocean # m s‚Åª¬≤; ŒΩ_molecular = 1.05e-6 # m¬≤ s‚Åª¬π; w_sediment = 2/9 * Œîb / ŒΩ_molecular * r_sediment^2 # m s‚Åª¬π. sinking = AdvectiveForcing(w=w_sediment). # output; AdvectiveForcing:; ‚îú‚îÄ‚îÄ u: ZeroField{Int64}; ‚îú‚îÄ‚îÄ v: ZeroField{Int64}; ‚îî‚îÄ‚îÄ w: ConstantField(-0.00352102); ```. The three keyword arguments specify the `u",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:10437,depend,dependencies,10437,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['depend'],['dependencies']
Integrability,"employs a; finite volume algorithm similar to that used by the Massachusetts Institute of; Technology general circulation model [@Marshall1997]. ![Fig. 1](free_convection_and_baroclinic_instability.png); Fig. 1: (Left) Large eddy simulation of small-scale oceanic boundary layer; turbulence forced by a surface cooling in a horizontally periodic domain using; $256^3$ grid points. The upper layer is well-mixed by turbulent convection and; bounded below by a strong buoyancy interface. (Right) Simulation of; instability of a horizontal density gradient in a rotating channel using; $256\times512\times128$ grid points. A similar process called baroclinic; instability acting on basin-scale temperature gradients fills the oceans with; eddies that stir carbon and heat. Plots made with `matplotlib` [@Hunter2007]; and `cmocean` [@Thyng2016]. ``Oceananigans.jl`` leverages the Julia programming language [@Bezanson2017] to; implement high-level, low-cost abstractions, a friendly user interface, and a; high-performance model in one language and a common code base for execution on; the CPU or GPU with Julia‚Äôs native GPU compiler [@Besard2019]. Because Julia is; a high-level language, development is streamlined and users can flexibly specify; model configurations, set up arbitrary diagnostics and output, extend the code; base, and implement new features. Configuring a model with `architecture=CPU()`; or `architecture=GPU()` will execute the model on the CPU or GPU. By pinning a; simulation script against a specific version of Oceananigans, simulation results; are reproducible up to hardware differences. Performance benchmarks show significant speedups when running on a GPU. Large; simulations on an Nvidia Tesla V100 GPU require ~1 nanosecond per grid point per; iteration. GPU simulations are therefore roughly 3x more cost-effective; than CPU simulations on cloud computing platforms such as Google Cloud. A GPU; with 32 GB of memory can time-step models with ~150 million grid points ass",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md:2549,interface,interface,2549,paper/paper.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md,1,['interface'],['interface']
Integrability,"ess at (Nothing, Nothing, Nothing); ```. !!! info ""Boundary condition functions with parameters""; The keyword argument `parameters` above specifies that `wind_stress` is called; with the signature `wind_stress(x, y, t, parameters)`. In principle, `parameters` is arbitrary.; However, relatively simple objects such as floating point numbers or `NamedTuple`s must be used; when running on the GPU. ### 5. 'Field-dependent' boundary conditions. Boundary conditions may also depend on model fields. For example, a linear drag boundary condition; is implemented with. ```jldoctest; julia> @inline linear_drag(x, y, t, u) = - 0.2 * u; linear_drag (generic function with 1 method). julia> u_bottom_bc = FluxBoundaryCondition(linear_drag, field_dependencies=:u); FluxBoundaryCondition: ContinuousBoundaryFunction linear_drag at (Nothing, Nothing, Nothing); ```. `field_dependencies` specifies the name of the dependent fields either with a `Symbol` or `Tuple` of `Symbol`s. ### 6. 'Field-dependent' boundary conditions with parameters. When boundary conditions depends on fields _and_ parameters, their functions take the form. ```jldoctest; julia> @inline quadratic_drag(x, y, t, u, v, drag_coeff) = - drag_coeff * u * sqrt(u^2 + v^2); quadratic_drag (generic function with 1 method). julia> u_bottom_bc = FluxBoundaryCondition(quadratic_drag, field_dependencies=(:u, :v), parameters=1e-3); FluxBoundaryCondition: ContinuousBoundaryFunction quadratic_drag at (Nothing, Nothing, Nothing); ```. Put differently, `Œæ, Œ∑, t` come first in the function signature, followed by field dependencies,; followed by `parameters` is `!isnothing(parameters)`. ### 7. Discrete-form boundary condition with parameters. Discrete field data may also be accessed directly from boundary condition functions; using the `discrete_form`. For example:. ```jldoctest; @inline filtered_drag(i, j, grid, clock, model_fields) =; @inbounds - 0.05 * (model_fields.u[i-1, j, 1] + 2 * model_fields.u[i, j, 1] + model_fields.u[i-1, j, 1]). u",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md:12830,depend,dependent,12830,docs/src/model_setup/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md,1,['depend'],['dependent']
Integrability,"example, the objects passed to the `parameters` keyword in the construction of; `u_forcing` and `T_forcing` -- a floating point number for `u_forcing`, and a `NamedTuple`; of parameters for `T_forcing` -- are passed on to `u_forcing_func` and `T_forcing_func` when; they are called during time-stepping. The object passed to `parameters` is in principle arbitrary.; However, if using the GPU, then `typeof(parameters)` may be restricted by the requirements; of GPU-compiliability. ### Forcing functions that depend on model fields. Forcing functions may depend on model fields (velocity, tracers or auxiliary fields) evaluated at the `x, y, z` where forcing is applied.; Here's a somewhat non-sensical example:. ```jldoctest field_dependent_forcing; # Forcing that depends on the velocity fields `u`, `v`, and `w`; w_forcing_func(x, y, z, t, u, v, w) = - (u^2 + v^2 + w^2) / 2. w_forcing = Forcing(w_forcing_func, field_dependencies=(:u, :v, :w)). # Forcing that depends on salinity `S` and a scalar parameter; S_forcing_func(x, y, z, t, S, Œº) = - Œº * S. S_forcing = Forcing(S_forcing_func, parameters=0.01, field_dependencies=:S). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, forcing=(w=w_forcing, S=S_forcing), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S)). model.forcing.w. # output; ContinuousForcing{Nothing} at (Center, Center, Face); ‚îú‚îÄ‚îÄ func: w_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:u, :v, :w); ```. ```jldoctest field_dependent_forcing; model.forcing.S. # output; ContinuousForcing{Float64} at (Center, Center, Center); ‚îú‚îÄ‚îÄ func: S_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: 0.01; ‚îî‚îÄ‚îÄ field dependencies: (:S,); ```. The `field_dependencies` arguments follow `x, y, z, t` in the forcing `func`tion in; the order they are specified in `Forcing`.; If both `field_dependencies` and `parameters` are specified, then the `field_dependencies`; arguments follow `x, ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:4258,depend,depends,4258,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['depend'],['depends']
Integrability,"g in the Reynolds; decomposition for ``\boldsymbol{v}`` and after some manipulation arrive at the following form for the *Reynolds-averaged; Navier-Stokes equations*; ```math; \begin{align}; \partial_i \overline{u}_i &= 0 \, ,\\; \partial_t \overline{u}_i + \overline{u}_j \partial_j \overline{u}_i &= \overline{f}_i -; \partial_j \left(-\alpha\overline{p}\delta_{ij} + 2\nu \overline{S}_{ij} - \overline{v_i^\prime v_j^\prime}\right) \, ,; \end{align}; ```; where; ```math; \overline{S}_{ij} = \frac{1}{2} ( \partial_j \overline{u}_i + \partial_i \overline{u}_j ) \, ,; ```; is the mean rate of strain tensor. Thanks to the non-linearity of the Navier-Stokes equations, even when averaged we are left with pesky fluctuation; terms which form the components of the *Reynolds stress tensor*; ```math; \tau_{ij} = \rho \overline{v_i^\prime v_j^\prime} \, .; ```; Attempting to close the equations leads to the *closure problem*: the time evolution of the Reynolds stresses; depends on triple covariances ``\overline{v_i^\prime v_j^\prime v_k^\prime}`` and covariances with pressure, which depend; on quadruple covariances and so on [Chou45](@cite). This is kind of hopeless so we will have to find some way to model the Reynolds stresses. ## Gradient-diffusion hypothesis and eddy viscosity models. The *gradient-diffusion hypothesis*, due to [Boussinesq1877](@citet), assumes that the transport of scalar fluxes; such as ``\overline{\boldsymbol{v}^\prime c^\prime}`` and ``\overline{v_i^\prime v_j^\prime}`` occurs down the mean scalar gradient; ``\boldsymbol{\nabla} \overline{c}`` as if they are being diffused (¬ß4.4) [Pope00](@cite). This is in analogy with how momentum transfer by; molecular motion in a gas can be described by a molecular viscosity. Taking this assumption we can express the Reynolds stresses and turbulent tracer fluxes in terms of the mean variables; and close the equations; ```math; \overline{\boldsymbol{v}^\prime c^\prime} = -\kappa_e \boldsymbol{\nabla} \overline{c}; \qu",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md:3060,depend,depends,3060,docs/src/numerical_implementation/turbulence_closures.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md,2,['depend'],"['depend', 'depends']"
Integrability,"g_func(x, y, z, t, s) = s * z. u_forcing = Forcing(u_forcing_func, parameters=0.1). # Forcing that depends on a `NamedTuple` of parameters `p`; T_forcing_func(x, y, z, t, p) = - p.Œº * exp(z / p.Œª) * cos(p.k * x) * sin(p.œâ * t). T_forcing = Forcing(T_forcing_func, parameters=(Œº=1, Œª=0.5, k=2œÄ, œâ=4œÄ)). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, forcing=(u=u_forcing, T=T_forcing), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S)). model.forcing.T. # output; ContinuousForcing{@NamedTuple{Œº::Int64, Œª::Float64, k::Float64, œâ::Float64}} at (Center, Center, Center); ‚îú‚îÄ‚îÄ func: T_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: (Œº = 1, Œª = 0.5, k = 6.283185307179586, œâ = 12.566370614359172); ‚îî‚îÄ‚îÄ field dependencies: (); ```. ```jldoctest parameterized_forcing; model.forcing.u. # output; ContinuousForcing{Float64} at (Face, Center, Center); ‚îú‚îÄ‚îÄ func: u_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: 0.1; ‚îî‚îÄ‚îÄ field dependencies: (); ```. In this example, the objects passed to the `parameters` keyword in the construction of; `u_forcing` and `T_forcing` -- a floating point number for `u_forcing`, and a `NamedTuple`; of parameters for `T_forcing` -- are passed on to `u_forcing_func` and `T_forcing_func` when; they are called during time-stepping. The object passed to `parameters` is in principle arbitrary.; However, if using the GPU, then `typeof(parameters)` may be restricted by the requirements; of GPU-compiliability. ### Forcing functions that depend on model fields. Forcing functions may depend on model fields (velocity, tracers or auxiliary fields) evaluated at the `x, y, z` where forcing is applied.; Here's a somewhat non-sensical example:. ```jldoctest field_dependent_forcing; # Forcing that depends on the velocity fields `u`, `v`, and `w`; w_forcing_func(x, y, z, t, u, v, w) = - (u^2 + v^2 + w^2) / 2. w_forcing = Forcing(w_forcing_func, field_dependencies=(:u, :v, :w)). # Forcing that depends on ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:3264,depend,dependencies,3264,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['depend'],['dependencies']
Integrability,"gs. ```@setup latlon_nodes; using Oceananigans; ```. ```@example latlon_nodes; grid = LatitudeLongitudeGrid(size = (1, 44),; longitude = (0, 1), ; latitude = (0, 88),; topology = (Bounded, Bounded, Flat)). œÜ = œÜnodes(grid, Center()); Œîx = xspacings(grid, Center(), Center()). using CairoMakie. fig = Figure(size=(600, 400)); ax = Axis(fig[1, 1], xlabel=""Zonal spacing on 2 degree grid (km)"", ylabel=""Latitude (degrees)""); scatter!(ax, Œîx ./ 1e3, œÜ). current_figure(); ```. ![](plot_lat_lon_spacings.svg). ## `LatitudeLongitudeGrid` with variable spacing. The syntax for building a grid with variably-spaced cells is the same as for `RectilinearGrid`.; In our next example, we use a function to build a Mercator grid with a spacing of 2 degrees at; the equator,. ```jldoctest latlon_nodes; # Mercator scale factor; scale_factor(œÜ) = 1 / cosd(œÜ). # Compute cell interfaces with Mercator spacing; m = 2 # spacing at the equator in degrees; function latitude_faces(j); if j == 1 # equator; return 0; else # crudely estimate the location of the jth face ; œÜ‚Çã = latitude_faces(j-1); œÜ‚Ä≤ = œÜ‚Çã + m * scale_factor(œÜ‚Çã) / 2; return œÜ‚Çã + m * scale_factor(œÜ‚Ä≤); end; end. Lx = 360; Nx = Int(Lx / m); Ny = findfirst(latitude_faces.(1:Nx) .> 90) - 2. grid = LatitudeLongitudeGrid(size = (Nx, Ny),; longitude = (0, Lx),; latitude = latitude_faces,; topology = (Bounded, Bounded, Flat)). # output; 180√ó28√ó1 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Flat} on CPU with 3√ó3√ó0 halo and with precomputed metrics; ‚îú‚îÄ‚îÄ longitude: Bounded Œª ‚àà [0.0, 360.0] regularly spaced with ŒîŒª=2.0; ‚îú‚îÄ‚îÄ latitude: Bounded œÜ ‚àà [0.0, 77.2679] variably spaced with min(ŒîœÜ)=2.0003, max(ŒîœÜ)=6.95319; ‚îî‚îÄ‚îÄ z: Flat z ; ```. We've also illustrated the construction of a grid that is `Flat` in the vertical direction.; Now let's plot the metrics for this grid,. ```@setup plot; # Mercator scale factor; scale_factor(œÜ) = 1 / cosd(œÜ). # Compute cell interfaces with Mercator spacing; m = 2 # spacing at the equator in degrees; function latitude_",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:19785,interface,interfaces,19785,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['interface'],['interfaces']
Integrability,"ic version of Oceananigans, simulation results; are reproducible up to hardware differences. Performance benchmarks show significant speedups when running on a GPU. Large; simulations on an Nvidia Tesla V100 GPU require ~1 nanosecond per grid point per; iteration. GPU simulations are therefore roughly 3x more cost-effective; than CPU simulations on cloud computing platforms such as Google Cloud. A GPU; with 32 GB of memory can time-step models with ~150 million grid points assuming; five fields are being evolved; for example, three velocity components and; tracers for temperature and salinity. These performance gains permit the; long-time integration of realistic simulations, such as large eddy simulation of; oceanic boundary layer turbulence over a seasonal cycle or the generation of; training data for turbulence parameterizations in Earth system models. ``Oceananigans.jl`` is continuously tested on CPUs and GPUs with unit tests,; integration tests, analytic solutions to the incompressible Navier-Stokes; equations, convergence tests, and verification experiments against published; scientific results. Future development plans include support for distributed; parallelism with CUDA-aware MPI as well as topography. Ocean models that are similar to ``Oceananigans.jl`` include MITgcm; [@Marshall1997] and MOM6 [@Adcroft2019], both written in Fortran. However,; ``Oceananigans.jl`` features a more efficient non-hydrostatic pressure solver; than MITgcm (and MOM6 is strictly hydrostatic). PALM [@Maronga2020] is Fortran; software for large eddy simulation of atmospheric and oceanic boundary layers; with complex boundaries on parallel CPU and GPU architectures. ``Oceananigans.jl``; is distinguished by its use of Julia which allows for a script-based interface as; opposed to a configuration-file-based interface used by MITgcm, MOM6, and PALM.; Dedalus [@Burns2020] is Python software with an intuitive script-based interface; that solves general partial differential equations, incl",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md:4031,integrat,integration,4031,paper/paper.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md,1,['integrat'],['integration']
Integrability,"ict ourselves to a class of problems in which; ```math; \psi(x, y, t) = - f(x, t) g(y) \, , \quad \text{with} \quad f \equiv \cos [x - \xi(t)] \, , \quad; \xi(t) \equiv 1 + \sin(t^2) \, .; ```; Grinding through the algebra, this particular form implies that ``F_{\omega}`` is given by; ```math; F_{\omega} = -\xi^\prime f_x (g - g^{\prime\prime}) + f f_x (g g^{\prime\prime\prime} - g^\prime g^{\prime\prime}) + f (g - 2 g^{\prime\prime} + g^{\prime\prime\prime\prime}) \, ,; ```; where primes denote derivatives of functions of a single argument. ; Setting ``\partial_y F_v = F_{\omega}``, we find that if ``F_v`` satisfies; ```math; \partial_y F_v = (g^\prime)^2 + g g^{\prime\prime} \, ,; ```; then the pressure Poisson equation becomes; ```math; \nabla^2 p = \cos [2 (x - \xi)] [(g^\prime)^2 - g g^{\prime\prime}] + \partial_x F_v \, .; ```; This completes the specification of the problem. We set up the problem by imposing the time-dependent forcing functions ``F_u`` and ``F_v``; on ``u`` and ``v``, initializing the flow at ``t=0``, and integrating the problem forwards; in time using Oceananigans. We find the expected convergence of the numerical solution to the; analytical solution: the error between the numerical and analytical solutions; decreases with ``1/N_x^2 \sim \Delta x^2``, where ``N_x`` is the number of grid; points and ``\Delta x`` is the spatial resolution:. ![Forced free slip convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/forced_free_slip_convergence.png). The convergence tests are performed using both ``y`` and ``z`` as the bounded direction. ### Forced, free-slip flow. A forced flow satisfying free-slip conditions at ``y = 0`` and ``y = \pi`` has the streamfunction; ```math; \psi(x, y, t) = - \cos [x - \xi(t)] \sin (y) \, ,; ```; and thus ``g(y) = \sin y``. The velocity field ``(u, v)`` is; ```math; u = \cos (x - \xi) \cos y \, , \quad \text{and} \quad v = \sin (x - \xi) \sin y \, ,; ```; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md:7557,depend,dependent,7557,docs/src/appendix/convergence_tests.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md,2,"['depend', 'integrat']","['dependent', 'integrating']"
Integrability,"lement sponge layers near the boundaries of a domain.; * `AdvectiveForcing` for advecting individual quantities by a separate or; ""slip"" velocity relative to both the prognostic model velocity field and any; `BackgroundField` velocity field. ## The `Forcing` constructor. The `Forcing` constructor provides an interface for specifying forcing functions that. 1. Depend on external parameters; and; 2. Depend on model fields at the `x, y, z` location that forcing is applied; and/or; 3. Require access to discrete model data. ### Forcing functions with external parameters. Most forcings involve external, changeable parameters.; Here are two examples of `forcing_func`tions that depend on ; _(i)_ a single scalar parameter `s`, and _(ii)_ a `NamedTuple` of parameters, `p`:. ```jldoctest parameterized_forcing; # Forcing that depends on a scalar parameter `s`; u_forcing_func(x, y, z, t, s) = s * z. u_forcing = Forcing(u_forcing_func, parameters=0.1). # Forcing that depends on a `NamedTuple` of parameters `p`; T_forcing_func(x, y, z, t, p) = - p.Œº * exp(z / p.Œª) * cos(p.k * x) * sin(p.œâ * t). T_forcing = Forcing(T_forcing_func, parameters=(Œº=1, Œª=0.5, k=2œÄ, œâ=4œÄ)). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, forcing=(u=u_forcing, T=T_forcing), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S)). model.forcing.T. # output; ContinuousForcing{@NamedTuple{Œº::Int64, Œª::Float64, k::Float64, œâ::Float64}} at (Center, Center, Center); ‚îú‚îÄ‚îÄ func: T_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: (Œº = 1, Œª = 0.5, k = 6.283185307179586, œâ = 12.566370614359172); ‚îî‚îÄ‚îÄ field dependencies: (); ```. ```jldoctest parameterized_forcing; model.forcing.u. # output; ContinuousForcing{Float64} at (Face, Center, Center); ‚îú‚îÄ‚îÄ func: u_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: 0.1; ‚îî‚îÄ‚îÄ field dependencies: (); ```. In this example, the objects passed to the `parameters` keyword in the construction of; `u_forcing` and `T_forcin",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:2367,depend,depends,2367,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['depend'],['depends']
Integrability,"lly-integrated continuity; equation \eqref{eq:vertically-integrated-continuity} into a discrete integral form. The best way to do; so is by starting from the discrete version of the continuity equation (in this case without any surface; volume flux, ``M = 0``). ```math; \begin{align}; \label{eq:continuity-discrete}; \delta_x (A_x u) + \delta_y (A_y v) + \delta_z (A_z w) = 0 \, ,; \end{align}; ```. and summing it vertically to get:. ```math; \begin{align}; \label{eq:vertically-integrated-continuity-discrete}; \delta_x \sum_k (A_x u) + \delta_y \sum_k (A_y v) + A_z \underbrace{w(k = N_z + 1)}_{w_{\rm top}} = 0 \, .; \end{align}; ```. In equations \eqref{eq:continuity-discrete} and \eqref{eq:vertically-integrated-continuity-discrete} and; here after, we have abused notation and used, e.g., ``u`` and ``v`` to denote the volume averages; over grid cells of the quantities ``u`` and ``v`` respectively. Using ``w_{\rm top} = \partial_t \eta`` and; being a bit more explicit on the locations the difference operators act on,; \eqref{eq:vertically-integrated-continuity-discrete} becomes:. ```math; \begin{equation}; \label{eq:semi-discrete-integral-continuity}; A_z \partial_t \eta + \delta_{x}^{caa} \sum_{k} (A_x u) + \delta_y^{aca} \sum_k (A_y v) = 0 \, .; \end{equation}; ```. We can now apply the velocity fractional step equation (discussed in the [Time-stepping section](@ref time_stepping)) for the [hydrostatic model](@ref hydrostatic_free_surface_model):. ```math; \begin{equation}; \label{eq:hydrostatic-fractional-step}; \boldsymbol{u}^{n+1} = \boldsymbol{u}^{\star} - g \Delta t \, \boldsymbol{\nabla} \eta^{n+1} \, .; \end{equation}; ```. We impose that the ``n+1``-th time step velocity is consistent with \eqref{eq:semi-discrete-integral-continuity}. ```math; \begin{equation}; A_z \frac{\eta^{n+1} - \eta^{n}}{\Delta t} = - \delta_x^{caa} \sum_k (A_x u^{n+1}) - \delta_y^{aca} \sum_k (A_y v^{n+1}) \, .; \end{equation}; ```. Substituting ``u^{n+1}`` and ``v^{n+1}`` from the disc",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:14058,integrat,integrated-continuity-discrete,14058,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['integrat'],['integrated-continuity-discrete']
Integrability,"ls than `CenterField`s:. ```jldoctest fields; w = Field{Center, Center, Face}(grid). @show znodes(c); @show znodes(w); nothing. # output; znodes(c) = [0.05, 0.2, 0.44999999999999996, 0.8]; znodes(w) = [0.0, 0.1, 0.3, 0.6, 1.0]; ```. `Field`s at `Center, Center, Face` are also called `ZFaceField`,; and the vertical velocity is a `ZFaceField` on the C-grid.; Let's visualize the situation:. ```@setup fields; using Oceananigans; using CairoMakie; set_theme!(Theme(fontsize=24)); CairoMakie.activate!(type=""svg""). grid = RectilinearGrid(topology = (Periodic, Periodic, Bounded),; size = (4, 4, 4),; halo = (1, 1, 1),; x = (0, 1),; y = (0, 1),; z = [0, 0.1, 0.3, 0.6, 1]). c = CenterField(grid). u = XFaceField(grid); ```. ```@example fields; using CairoMakie. fig = Figure(size=(600, 180)); ax = Axis(fig[1, 1], xlabel=""x""). # Visualize the domain; lines!(ax, [0, 1], [0, 0], color=:gray). xc = xnodes(c); xu = xnodes(u). scatter!(ax, xc, 0 * xc, marker=:circle, markersize=10, label=""Cell centers""); scatter!(ax, xu, 0 * xu, marker=:vline, markersize=20, label=""Cell interfaces""). ylims!(ax, -1, 1); xlims!(ax, -0.1, 1.1); hideydecorations!(ax); hidexdecorations!(ax, ticklabels=false, label=false); hidespines!(ax). Legend(fig[0, 1], ax, nbanks=2, framevisible=false). current_figure(); ```. ## Setting `Field`s. `Field`s are full of 0's when they are created, which is not very exciting.; The situation can be improved using [`set!`](@ref) to change the values of a field.; For example,. ```jldoctest fields; set!(c, 42). # output; 4√ó5√ó4 Field{Center, Center, Center} on RectilinearGrid on CPU; ‚îú‚îÄ‚îÄ grid: 4√ó5√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ boundary conditions: FieldBoundaryConditions; ‚îÇ ‚îî‚îÄ‚îÄ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; ‚îî‚îÄ‚îÄ data: 6√ó7√ó6 OffsetArray(::Array{Float64, 3}, 0:5, 0:6, 0:5) with eltype Float64 with indices 0:5√ó0:6√ó0:5; ‚îî‚îÄ‚îÄ max=42.0, min=42.0, ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md:7429,interface,interfaces,7429,docs/src/fields.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md,1,['interface'],['interfaces']
Integrability,"mensional slices of `c` showing both the interior and the halo; regions:. ```jldoctest fields; c[:, :, 1]. # output; 6√ó7 OffsetArray(::Matrix{Float64}, 0:5, 0:6) with eltype Float64 with indices 0:5√ó0:6:; 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.25 0.25 0.25 0.25 0.25 0.0; 0.0 0.75 0.75 0.75 0.75 0.75 0.0; 0.0 1.25 1.25 1.25 1.25 1.25 0.0; 0.0 1.75 1.75 1.75 1.75 1.75 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0; ```. The interior region is populated, but the surrounding halo regions are all 0.; To remedy this situation we need to `fill_halo_regions!`:. ```jldoctest fields; using Oceananigans.BoundaryConditions: fill_halo_regions!. fill_halo_regions!(c). c[:, :, 1]. # output; 6√ó7 OffsetArray(::Matrix{Float64}, 0:5, 0:6) with eltype Float64 with indices 0:5√ó0:6:; 1.75 1.75 1.75 1.75 1.75 1.75 1.75; 0.25 0.25 0.25 0.25 0.25 0.25 0.25; 0.75 0.75 0.75 0.75 0.75 0.75 0.75; 1.25 1.25 1.25 1.25 1.25 1.25 1.25; 1.75 1.75 1.75 1.75 1.75 1.75 1.75; 0.25 0.25 0.25 0.25 0.25 0.25 0.25; ```. The way the halo regions are filled depends on `c.boundary_conditions`:. ```julia; c.boundary_conditions. # output; Oceananigans.FieldBoundaryConditions, with boundary conditions; ‚îú‚îÄ‚îÄ west: PeriodicBoundaryCondition; ‚îú‚îÄ‚îÄ east: PeriodicBoundaryCondition; ‚îú‚îÄ‚îÄ south: PeriodicBoundaryCondition; ‚îú‚îÄ‚îÄ north: PeriodicBoundaryCondition; ‚îú‚îÄ‚îÄ bottom: FluxBoundaryCondition: Nothing; ‚îú‚îÄ‚îÄ top: FluxBoundaryCondition: Nothing; ‚îî‚îÄ‚îÄ immersed: FluxBoundaryCondition: Nothing; ```. Specifically for `c` above, `x` and `y` are `Periodic` while `z` has been assigned; the default ""no-flux"" boundary conditions for a `Field` with `Center` location in; a `Bounded` direction.; For no-flux boundary conditions, the halo regions of `c` are filled so that derivatives evaluated; on the boundary return 0.; To view only the interior cells of `c` we use the function `interior`,. ```jldoctest fields; interior(c, :, :, 1). # output; 4√ó5 view(::Array{Float64, 3}, 2:5, 2:6, 2) with eltype Float64:; 0.25 0.25 0.25 0.25 0.25; 0.75 0.75 0.75 0.75 0.75; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md:13345,depend,depends,13345,docs/src/fields.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md,1,['depend'],['depends']
Integrability,"n (FluxBoundaryCondition: Nothing); ‚îú‚îÄ‚îÄ east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing); ‚îú‚îÄ‚îÄ south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing); ‚îú‚îÄ‚îÄ north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing); ‚îú‚îÄ‚îÄ bottom: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing); ‚îú‚îÄ‚îÄ top: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing); ‚îî‚îÄ‚îÄ immersed: ImmersedBoundaryCondition with west=Nothing, east=Nothing, south=Nothing, north=Nothing, bottom=Value, top=Nothing; ```. !!! warning ""`ImmersedBoundaryCondition`""; `ImmersedBoundaryCondition` is experimental.; Therefore, one should use it only when a finer level of control over the boundary conditions; at the immersed boundary is required, and the user is familiar with the implementation of boundary ; conditions on staggered grids. For all other cases , using the `immersed` argument of; `FieldBoundaryConditions` is preferred. A boundary condition that depends on the fields may be prescribed using the `immersed`; keyword argument in [`FieldBoundaryConditions`](@ref).; We illustrate field-dependent boundary conditions with an example that imposes linear bottom drag; on `u` on both the bottom facets of cells adjacent to an immersed boundary, _and_ the bottom boundary; of the underlying grid. First we create the boundary condition for the grid's bottom:. ```julia; @inline linear_drag(x, y, t, u) = - 0.2 * u; drag_u = FluxBoundaryCondition(linear_drag, field_dependencies=:u). # output; FluxBoundaryCondition: ContinuousBoundaryFunction linear_drag at (Nothing, Nothing, Nothing); ```. Next, we create the immersed boundary condition by adding the argument `z` to `linear_drag`; and imposing drag only on ""bottom"" facets of cells that neighbor immersed cells:. ```julia; @inline immersed_linear_drag(x, y, z, t, u) = - 0.2 * u; immersed_drag_u = FluxBoundaryCondition(immersed_linear_drag, field_dependencies=:u). u_immersed_bc = ImmersedBoundaryCondition(bottom = immersed_drag_u). # output;",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md:22963,depend,depends,22963,docs/src/model_setup/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md,1,['depend'],['depends']
Integrability,"n at which the forcing is applied. ### ""Discrete form"" forcing functions. ""Discrete form"" forcing functions are either called with the signature. ```julia; func(i, j, k, grid, clock, model_fields); ```. or the parameterized form. ```julia; func(i, j, k, grid, clock, model_fields, parameters); ```. Discrete form forcing functions can access the entirety of model field; data through the argument `model_fields`. The object `model_fields` is a `NamedTuple`; whose properties include the velocity fields `model_fields.u`, `model_fields.v`,; `model_fields.w` and all fields in `model.tracers`. Using discrete forcing functions may require understanding the; staggered arrangement of velocity fields and tracers in `Oceananigans`.; Here's a slightly non-sensical example in which the vertical derivative of a buoyancy; tracer is used as a time-scale for damping the u-velocity field:. ```jldoctest discrete_forcing; # A damping term that depends on a ""local average"":; local_average(i, j, k, grid, c) = @inbounds (c[i, j, k] + c[i-1, j, k] + c[i+1, j, k] +; c[i, j-1, k] + c[i, j+1, k] +; c[i, j, k-1] + c[i, j, k+1]) / 7. b_forcing_func(i, j, k, grid, clock, model_fields) = - local_average(i, j, k, grid, model_fields.b). b_forcing = Forcing(b_forcing_func, discrete_form=true). # A term that damps the local velocity field in the presence of stratification; using Oceananigans.Operators: ‚àÇz·∂†·∂ú·∂†, ‚Ñëxz·∂†·µÉ·∂ú. function u_forcing_func(i, j, k, grid, clock, model_fields, Œµ); # The vertical derivative of buoyancy, interpolated to the u-velocity location:; N¬≤ = ‚Ñëxz·∂†·µÉ·∂ú(i, j, k, grid, ‚àÇz·∂†·∂ú·∂†, model_fields.b). # Set to zero in unstable stratification where N¬≤ < 0:; N¬≤ = max(N¬≤, zero(typeof(N¬≤))). return @inbounds - Œµ * sqrt(N¬≤) * model_fields.u[i, j, k]; end. u_forcing = Forcing(u_forcing_func, discrete_form=true, parameters=1e-3). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, tracers=:b, buoyancy=BuoyancyTracer(), forcing=(u=u_forcing, b=b_forcing)). mo",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:6425,depend,depends,6425,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['depend'],['depends']
Integrability,"nfigurations, set up arbitrary diagnostics and output, extend the code; base, and implement new features. Configuring a model with `architecture=CPU()`; or `architecture=GPU()` will execute the model on the CPU or GPU. By pinning a; simulation script against a specific version of Oceananigans, simulation results; are reproducible up to hardware differences. Performance benchmarks show significant speedups when running on a GPU. Large; simulations on an Nvidia Tesla V100 GPU require ~1 nanosecond per grid point per; iteration. GPU simulations are therefore roughly 3x more cost-effective; than CPU simulations on cloud computing platforms such as Google Cloud. A GPU; with 32 GB of memory can time-step models with ~150 million grid points assuming; five fields are being evolved; for example, three velocity components and; tracers for temperature and salinity. These performance gains permit the; long-time integration of realistic simulations, such as large eddy simulation of; oceanic boundary layer turbulence over a seasonal cycle or the generation of; training data for turbulence parameterizations in Earth system models. ``Oceananigans.jl`` is continuously tested on CPUs and GPUs with unit tests,; integration tests, analytic solutions to the incompressible Navier-Stokes; equations, convergence tests, and verification experiments against published; scientific results. Future development plans include support for distributed; parallelism with CUDA-aware MPI as well as topography. Ocean models that are similar to ``Oceananigans.jl`` include MITgcm; [@Marshall1997] and MOM6 [@Adcroft2019], both written in Fortran. However,; ``Oceananigans.jl`` features a more efficient non-hydrostatic pressure solver; than MITgcm (and MOM6 is strictly hydrostatic). PALM [@Maronga2020] is Fortran; software for large eddy simulation of atmospheric and oceanic boundary layers; with complex boundaries on parallel CPU and GPU architectures. ``Oceananigans.jl``; is distinguished by its use of Juli",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md:3732,integrat,integration,3732,paper/paper.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md,1,['integrat'],['integration']
Integrability,"ng; model.forcing.u. # output; ContinuousForcing{Float64} at (Face, Center, Center); ‚îú‚îÄ‚îÄ func: u_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: 0.1; ‚îî‚îÄ‚îÄ field dependencies: (); ```. In this example, the objects passed to the `parameters` keyword in the construction of; `u_forcing` and `T_forcing` -- a floating point number for `u_forcing`, and a `NamedTuple`; of parameters for `T_forcing` -- are passed on to `u_forcing_func` and `T_forcing_func` when; they are called during time-stepping. The object passed to `parameters` is in principle arbitrary.; However, if using the GPU, then `typeof(parameters)` may be restricted by the requirements; of GPU-compiliability. ### Forcing functions that depend on model fields. Forcing functions may depend on model fields (velocity, tracers or auxiliary fields) evaluated at the `x, y, z` where forcing is applied.; Here's a somewhat non-sensical example:. ```jldoctest field_dependent_forcing; # Forcing that depends on the velocity fields `u`, `v`, and `w`; w_forcing_func(x, y, z, t, u, v, w) = - (u^2 + v^2 + w^2) / 2. w_forcing = Forcing(w_forcing_func, field_dependencies=(:u, :v, :w)). # Forcing that depends on salinity `S` and a scalar parameter; S_forcing_func(x, y, z, t, S, Œº) = - Œº * S. S_forcing = Forcing(S_forcing_func, parameters=0.01, field_dependencies=:S). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, forcing=(w=w_forcing, S=S_forcing), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S)). model.forcing.w. # output; ContinuousForcing{Nothing} at (Center, Center, Face); ‚îú‚îÄ‚îÄ func: w_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:u, :v, :w); ```. ```jldoctest field_dependent_forcing; model.forcing.S. # output; ContinuousForcing{Float64} at (Center, Center, Center); ‚îú‚îÄ‚îÄ func: S_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: 0.01; ‚îî‚îÄ‚îÄ field dependencies: (:S,); ```. The `field_dependencies` arguments ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:4060,depend,depends,4060,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['depend'],['depends']
Integrability,"nience types:. * `Relaxation` for damping terms that restore a field to a; target distribution outside of a masked region of space. `Relaxation` can be; used to implement sponge layers near the boundaries of a domain.; * `AdvectiveForcing` for advecting individual quantities by a separate or; ""slip"" velocity relative to both the prognostic model velocity field and any; `BackgroundField` velocity field. ## The `Forcing` constructor. The `Forcing` constructor provides an interface for specifying forcing functions that. 1. Depend on external parameters; and; 2. Depend on model fields at the `x, y, z` location that forcing is applied; and/or; 3. Require access to discrete model data. ### Forcing functions with external parameters. Most forcings involve external, changeable parameters.; Here are two examples of `forcing_func`tions that depend on ; _(i)_ a single scalar parameter `s`, and _(ii)_ a `NamedTuple` of parameters, `p`:. ```jldoctest parameterized_forcing; # Forcing that depends on a scalar parameter `s`; u_forcing_func(x, y, z, t, s) = s * z. u_forcing = Forcing(u_forcing_func, parameters=0.1). # Forcing that depends on a `NamedTuple` of parameters `p`; T_forcing_func(x, y, z, t, p) = - p.Œº * exp(z / p.Œª) * cos(p.k * x) * sin(p.œâ * t). T_forcing = Forcing(T_forcing_func, parameters=(Œº=1, Œª=0.5, k=2œÄ, œâ=4œÄ)). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, forcing=(u=u_forcing, T=T_forcing), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S)). model.forcing.T. # output; ContinuousForcing{@NamedTuple{Œº::Int64, Œª::Float64, k::Float64, œâ::Float64}} at (Center, Center, Center); ‚îú‚îÄ‚îÄ func: T_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: (Œº = 1, Œª = 0.5, k = 6.283185307179586, œâ = 12.566370614359172); ‚îî‚îÄ‚îÄ field dependencies: (); ```. ```jldoctest parameterized_forcing; model.forcing.u. # output; ContinuousForcing{Float64} at (Face, Center, Center); ‚îú‚îÄ‚îÄ func: u_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:2225,depend,depends,2225,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['depend'],['depends']
Integrability,"nsional),; - rectangles (two-dimensional),; - boxes (three-dimensional),; - sectors of a thin spherical shells (two- or three-dimensional).; Irregular domains -- such as domains that include bathymetry or topography -- are represented by using a masking technique to ""immerse"" an irregular boundary within an ""underlying"" regular grid. Part of specifying the shape of the domain also requires specifying the nature of each dimension, which may be; - [`Periodic`](@ref), which means that the dimension circles back onto itself: information leaving the left side of the domain re-enters on the right.; - [`Bounded`](@ref), which means that the two sides of the dimension are either impenetrable (solid walls), or ""open"", representing a specified external state.; - [`Flat`](@ref), which means nothing can vary in that dimension, reducing the overall dimensionality of the grid.; * Defining the number of cells that divide each dimension. The number of cells, with or without explicit specification of the cell interfaces, determines the spatial resolution of the grid.; * The representation of floating point numbers, which can be single-precision (`Float32`) or double precision (`Float64`). Let's dive into each of these options in more detail. ### Specifying the machine architecture. The positional argument `CPU()` or `GPU()`, specifies the ""architecture"" of the simulation.; By using `architecture = GPU()`, any fields constructed on `grid` store their data on; an Nvidia [`GPU`](@ref), if one is available. By default, the grid will be constructed on; the [`CPU`](@ref) if this argument is omitted.; So, for example,. ```jldoctest grids; grid = RectilinearGrid(size=3, z=(0, 1), topology=(Flat, Flat, Bounded)); cpu_grid = RectilinearGrid(CPU(), size=3, z=(0, 1), topology=(Flat, Flat, Bounded)). grid == cpu_grid. # output; true; ```. To use more than one CPU, we use the `Distributed` architecture,. ```jldoctest grids; child_architecture = CPU(); architecture = Distributed(child_architecture)",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:11241,interface,interfaces,11241,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['interface'],['interfaces']
Integrability,"nt_forcing; # Forcing that depends on the velocity fields `u`, `v`, and `w`; w_forcing_func(x, y, z, t, u, v, w) = - (u^2 + v^2 + w^2) / 2. w_forcing = Forcing(w_forcing_func, field_dependencies=(:u, :v, :w)). # Forcing that depends on salinity `S` and a scalar parameter; S_forcing_func(x, y, z, t, S, Œº) = - Œº * S. S_forcing = Forcing(S_forcing_func, parameters=0.01, field_dependencies=:S). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, forcing=(w=w_forcing, S=S_forcing), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S)). model.forcing.w. # output; ContinuousForcing{Nothing} at (Center, Center, Face); ‚îú‚îÄ‚îÄ func: w_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:u, :v, :w); ```. ```jldoctest field_dependent_forcing; model.forcing.S. # output; ContinuousForcing{Float64} at (Center, Center, Center); ‚îú‚îÄ‚îÄ func: S_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: 0.01; ‚îî‚îÄ‚îÄ field dependencies: (:S,); ```. The `field_dependencies` arguments follow `x, y, z, t` in the forcing `func`tion in; the order they are specified in `Forcing`.; If both `field_dependencies` and `parameters` are specified, then the `field_dependencies`; arguments follow `x, y, z, t`, and `parameters` follow `field_dependencies`. Model fields that arise in the arguments of continuous `Forcing` `func`tions are; automatically interpolated to the staggered grid location at which the forcing is applied. ### ""Discrete form"" forcing functions. ""Discrete form"" forcing functions are either called with the signature. ```julia; func(i, j, k, grid, clock, model_fields); ```. or the parameterized form. ```julia; func(i, j, k, grid, clock, model_fields, parameters); ```. Discrete form forcing functions can access the entirety of model field; data through the argument `model_fields`. The object `model_fields` is a `NamedTuple`; whose properties include the velocity fields `model_fields.u`, `model_fields.v`,; `mod",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:5028,depend,dependencies,5028,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['depend'],['dependencies']
Integrability,"ore roughly 3x more cost-effective; than CPU simulations on cloud computing platforms such as Google Cloud. A GPU; with 32 GB of memory can time-step models with ~150 million grid points assuming; five fields are being evolved; for example, three velocity components and; tracers for temperature and salinity. These performance gains permit the; long-time integration of realistic simulations, such as large eddy simulation of; oceanic boundary layer turbulence over a seasonal cycle or the generation of; training data for turbulence parameterizations in Earth system models. ``Oceananigans.jl`` is continuously tested on CPUs and GPUs with unit tests,; integration tests, analytic solutions to the incompressible Navier-Stokes; equations, convergence tests, and verification experiments against published; scientific results. Future development plans include support for distributed; parallelism with CUDA-aware MPI as well as topography. Ocean models that are similar to ``Oceananigans.jl`` include MITgcm; [@Marshall1997] and MOM6 [@Adcroft2019], both written in Fortran. However,; ``Oceananigans.jl`` features a more efficient non-hydrostatic pressure solver; than MITgcm (and MOM6 is strictly hydrostatic). PALM [@Maronga2020] is Fortran; software for large eddy simulation of atmospheric and oceanic boundary layers; with complex boundaries on parallel CPU and GPU architectures. ``Oceananigans.jl``; is distinguished by its use of Julia which allows for a script-based interface as; opposed to a configuration-file-based interface used by MITgcm, MOM6, and PALM.; Dedalus [@Burns2020] is Python software with an intuitive script-based interface; that solves general partial differential equations, including the incompressible; Navier-Stokes equations, with spectral methods. # Acknowledgements. Our work is supported by the generosity of Eric and Wendy Schmidt by; recommendation of the Schmidt Futures program, and by the National Science; Foundation under grant AGS-6939393. # References; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md:4853,interface,interface,4853,paper/paper.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md,3,['interface'],['interface']
Integrability,"ould be used:. 1. [`RectilinearGrid`](@ref Oceananigans.Grids.RectilinearGrid) can be fashioned into lines, rectangles and boxes.; 2. [`LatitudeLongitudeGrid`](@ref Oceananigans.Grids.LatitudeLongitudeGrid) represents sectors of thin spherical shells, with cells bounded by lines of constant latitude and longitude.; 3. [`OrthogonalSphericalShellGrid`](@ref Oceananigans.Grids.OrthogonalSphericalShellGrid) represents sectors of thin spherical shells divided with mesh lines that intersect at right angles (thus, orthogonal) but are otherwise arbitrary. !!! note ""OrthogonalSphericalShellGrids.jl""; See the auxiliary package [`OrthogonalSphericalShellGrids.jl`](https://github.com/CliMA/OrthogonalSphericalShellGrids.jl); for recipes that implement some useful `OrthogonalSphericalShellGrid`, including the; [""tripolar"" grid](https://www.sciencedirect.com/science/article/abs/pii/S0021999196901369). For example, to make a `LatitudeLongitudeGrid` that wraps around the sphere, extends for 60 degrees latitude on either side of the equator, and also has 5 vertical levels down to 1000 meters, we write. ```jldoctest grids; architecture = CPU(). grid = LatitudeLongitudeGrid(architecture,; size = (180, 10, 5),; longitude = (-180, 180),; latitude = (-60, 60),; z = (-1000, 0)). # output; 180√ó10√ó5 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3√ó3√ó3 halo and with precomputed metrics; ‚îú‚îÄ‚îÄ longitude: Periodic Œª ‚àà [-180.0, 180.0) regularly spaced with ŒîŒª=2.0; ‚îú‚îÄ‚îÄ latitude: Bounded œÜ ‚àà [-60.0, 60.0] regularly spaced with ŒîœÜ=12.0; ‚îî‚îÄ‚îÄ z: Bounded z ‚àà [-1000.0, 0.0] regularly spaced with Œîz=200.0; ```. The main difference between the syntax for `LatitudeLongitudeGrid` versus that for the `RectilinearGrid` are the names of the horizontal coordinates:; `LatitudeLongitudeGrid` has `longitude` and `latitude` where `RectilinearGrid` has `x` and `y`. !!! note ""Extrinsic and intrinsic coordinate systems""; Every grid is associated with an ""extrinsic"" coordinate system: `Rectilinea",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:4703,wrap,wraps,4703,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['wrap'],['wraps']
Integrability,"primary mesh,. ```jldoctest fields; zspacings(grid, Face()). # output; 5-element view(OffsetArray(::Vector{Float64}, -1:5), 1:5) with eltype Float64:; 0.1; 0.15000000000000002; 0.24999999999999994; 0.3500000000000001; 0.3999999999999999; ```. The cells for the vertically staggered grid have different spacings than the primary mesh.; That's because the _edges_ of the vertically-staggered mesh coincide with the _nodes_ (the cell centers); of the primary mesh. The nodes of the primary mesh are. ```jldoctest fields; znodes(grid, Center(), with_halos=true). # output; 6-element OffsetArray(::Vector{Float64}, 0:5) with eltype Float64 with indices 0:5:; -0.05; 0.05; 0.2; 0.44999999999999996; 0.8; 1.2; ```. The center of the leftmost ""halo cell"" is `z = -0.05`, while the center of the first cell from the left is `z = 0.05`.; This means that the width of the first cell on the vertically-staggered grid is `0.05 - (-0.05) = 0.1` -- and so on.; Finally, note that the nodes of the staggered mesh coincide with the cell interfaces of the primary mesh, so:. ```jldoctest fields; znodes(grid, Center()). # output; 4-element view(OffsetArray(::Vector{Float64}, 0:5), 1:4) with eltype Float64:; 0.05; 0.2; 0.44999999999999996; 0.8; ```. In a three-dimensional domain, there are ``2¬≥ = 8`` meshes -- 1 primary mesh, and 7 meshes that are; staggered to varying degrees from the primary mesh.; This system of staggered grids is commonly used in fluid dynamics and was [invented specifically for; simulations of the atmosphere and ocean](https://en.wikipedia.org/wiki/Arakawa_grids). ### Constructing Fields at specified locations. Every `Field` is associated with either the primary mesh or one of the staggered meshes by; a three-dimensional ""location"" associated with each field.; To build a fully-centered `Field`, for example, we write. ```jldoctest fields; c = Field{Center, Center, Center}(grid). # output; 4√ó5√ó4 Field{Center, Center, Center} on RectilinearGrid on CPU; ‚îú‚îÄ‚îÄ grid: 4√ó5√ó4 RectilinearGrid",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md:3259,interface,interfaces,3259,docs/src/fields.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md,1,['interface'],['interfaces']
Integrability,"s used in the Direct Method; solver. ### Implicit free surface pressure operator. The implicit free surface solver solves for the free-surface, ``\eta(x, y, t)``, in the vertically; integrated continuity equation:. ```math; \begin{equation}; \label{eq:vertically-integrated-continuity}; \partial_t \eta + \partial_x \left ( \int_{-H}^0 u \, \mathrm{d}z \right ) + \partial_y \left ( \int_{-H}^0 v \, \mathrm{d}z \right ) = M \, ,; \end{equation}; ```. where ``H(x, y)`` is the depth of the water column (to first order with respect to the free surface; elevation) and ``M`` is some surface volume flux (e.g., terms such as precipitation, evaporation and; runoff); currently Oceananigans.jl assumes ``M = 0``. Note that in deriving \eqref{eq:vertically-integrated-continuity},; we used the bottom boundary condition ``w_{\rm bottom} = \boldsymbol{u}_{\rm bottom} \boldsymbol{\cdot} \boldsymbol{\nabla}_h H``. To form a linear system that can be solved implicitly we recast the vertically-integrated continuity; equation \eqref{eq:vertically-integrated-continuity} into a discrete integral form. The best way to do; so is by starting from the discrete version of the continuity equation (in this case without any surface; volume flux, ``M = 0``). ```math; \begin{align}; \label{eq:continuity-discrete}; \delta_x (A_x u) + \delta_y (A_y v) + \delta_z (A_z w) = 0 \, ,; \end{align}; ```. and summing it vertically to get:. ```math; \begin{align}; \label{eq:vertically-integrated-continuity-discrete}; \delta_x \sum_k (A_x u) + \delta_y \sum_k (A_y v) + A_z \underbrace{w(k = N_z + 1)}_{w_{\rm top}} = 0 \, .; \end{align}; ```. In equations \eqref{eq:continuity-discrete} and \eqref{eq:vertically-integrated-continuity-discrete} and; here after, we have abused notation and used, e.g., ``u`` and ``v`` to denote the volume averages; over grid cells of the quantities ``u`` and ``v`` respectively. Using ``w_{\rm top} = \partial_t \eta`` and; being a bit more explicit on the locations the difference opera",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:13010,integrat,integrated,13010,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,2,['integrat'],"['integrated', 'integrated-continuity']"
Integrability,"schemes that require more halo points than the default `3` in every direction.; Note that both `size` and `halo` are 2-`Tuple`s, rather than the 3-`Tuple` that would be required for a three-dimensional grid,; or the single number that would be used for a one-dimensional grid. ### The dimensions: `x, y, z` for `RectilinearGrid`, or `latitude, longitude, z` for `LatitudeLongitudeGrid`. These keyword arguments specify the extent and location of the finite volume cells that divide up the; three dimensions of the grid.; For `RectilinearGrid`, the dimensions are called `x`, `y`, and `z`, whereas for `LatitudeLongitudeGrid` the; dimensions are called `latitude`, `longitude`, and `z`.; The type of each keyword argument determines how the dimension is divided up:. * Tuples that specify only the end points indicate that the dimension should be divided into; equally-spaced cells. For example, `x = (0, 64)` with `size = (16, 8, 4)` means that the; `x`-dimension is divided into 16 cells, where the first or leftmost cell interface is located; at `x = 0` and the last or rightmost cell interface is located at `x = 64`. The width of each cell is `Œîx=4.0`.; * Vectors and functions alternatively give the location of each cell interface, and thereby may be used; to build grids that are divided into cells of varying width. ## A complicated example: three-dimensional `RectilinearGrid` with variable spacing via functions. Next we build a grid that is both `Bounded` and stretched in both the `y` and `z` directions.; The purpose of the stretching is to increase grid resolution near the boundaries.; We'll do this by using functions to specify the keyword arguments `y` and `z`. ```jldoctest grids; Nx = Ny = 64; Nz = 32. Lx = Ly = 1e4; Lz = 1e3. # Note that j varies from 1 to Ny; chebychev_spaced_y_faces(j) = Ly * (1 - cos(œÄ * (j - 1) / Ny)) / 2. # Note that k varies from 1 to Nz; chebychev_spaced_z_faces(k) = - Lz * (1 + cos(œÄ * (k - 1) / Nz)) / 2. grid = RectilinearGrid(size = (Nx, Ny, Nz),; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:15737,interface,interface,15737,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,2,['interface'],['interface']
Integrability,"sh or one of the staggered meshes by; a three-dimensional ""location"" associated with each field.; To build a fully-centered `Field`, for example, we write. ```jldoctest fields; c = Field{Center, Center, Center}(grid). # output; 4√ó5√ó4 Field{Center, Center, Center} on RectilinearGrid on CPU; ‚îú‚îÄ‚îÄ grid: 4√ó5√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ boundary conditions: FieldBoundaryConditions; ‚îÇ ‚îî‚îÄ‚îÄ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; ‚îî‚îÄ‚îÄ data: 6√ó7√ó6 OffsetArray(::Array{Float64, 3}, 0:5, 0:6, 0:5) with eltype Float64 with indices 0:5√ó0:6√ó0:5; ‚îî‚îÄ‚îÄ max=0.0, min=0.0, mean=0.0; ```. Fully-centered fields also go by the alias `CenterField`,. ```jldoctest fields; c == CenterField(grid). # output; true; ```. Many fluid dynamical variables are located at cell centers -- for example, tracers like temperature and salinity.; Another common type of `Field` we encounter have cells located over the `x`-interfaces of the primary grid,. ```jldoctest fields; u = Field{Face, Center, Center}(grid). # output; 4√ó5√ó4 Field{Face, Center, Center} on RectilinearGrid on CPU; ‚îú‚îÄ‚îÄ grid: 4√ó5√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ boundary conditions: FieldBoundaryConditions; ‚îÇ ‚îî‚îÄ‚îÄ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; ‚îî‚îÄ‚îÄ data: 6√ó7√ó6 OffsetArray(::Array{Float64, 3}, 0:5, 0:6, 0:5) with eltype Float64 with indices 0:5√ó0:6√ó0:5; ‚îî‚îÄ‚îÄ max=0.0, min=0.0, mean=0.0; ```. which also goes by the alias `u = XFaceField(grid)`.; The name `u` is suggestive: in the Arakawa type-C grid ('C-grid' for short) used by Oceananigans,; the `x`-component of the velocity field is stored at `Face, Center, Center` location. The centers of the `u` cells are shifted to the left relative to the `c` cells:. ```jldoctest fields; @show xnodes(c); @show xnodes(u); nothing. # output; xno",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md:4940,interface,interfaces,4940,docs/src/fields.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md,1,['interface'],['interfaces']
Integrability,"sic example is. ```jldoctest; u_forcing(x, y, z, t) = exp(z) * cos(x) * sin(t). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, forcing=(u=u_forcing,)). model.forcing.u. # output; ContinuousForcing{Nothing} at (Face, Center, Center); ‚îú‚îÄ‚îÄ func: u_forcing (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (); ```. More general forcing functions are built via the `Forcing` constructor; described below. `Oceananigans` also provides two convenience types:. * `Relaxation` for damping terms that restore a field to a; target distribution outside of a masked region of space. `Relaxation` can be; used to implement sponge layers near the boundaries of a domain.; * `AdvectiveForcing` for advecting individual quantities by a separate or; ""slip"" velocity relative to both the prognostic model velocity field and any; `BackgroundField` velocity field. ## The `Forcing` constructor. The `Forcing` constructor provides an interface for specifying forcing functions that. 1. Depend on external parameters; and; 2. Depend on model fields at the `x, y, z` location that forcing is applied; and/or; 3. Require access to discrete model data. ### Forcing functions with external parameters. Most forcings involve external, changeable parameters.; Here are two examples of `forcing_func`tions that depend on ; _(i)_ a single scalar parameter `s`, and _(ii)_ a `NamedTuple` of parameters, `p`:. ```jldoctest parameterized_forcing; # Forcing that depends on a scalar parameter `s`; u_forcing_func(x, y, z, t, s) = s * z. u_forcing = Forcing(u_forcing_func, parameters=0.1). # Forcing that depends on a `NamedTuple` of parameters `p`; T_forcing_func(x, y, z, t, p) = - p.Œº * exp(z / p.Œª) * cos(p.k * x) * sin(p.œâ * t). T_forcing = Forcing(T_forcing_func, parameters=(Œº=1, Œª=0.5, k=2œÄ, œâ=4œÄ)). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, forcing=(u=u_forcing, T=T_forcing), buoyancy=Se",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:1709,interface,interface,1709,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['interface'],['interface']
Integrability,"st order with respect to the free surface; elevation) and ``M`` is some surface volume flux (e.g., terms such as precipitation, evaporation and; runoff); currently Oceananigans.jl assumes ``M = 0``. Note that in deriving \eqref{eq:vertically-integrated-continuity},; we used the bottom boundary condition ``w_{\rm bottom} = \boldsymbol{u}_{\rm bottom} \boldsymbol{\cdot} \boldsymbol{\nabla}_h H``. To form a linear system that can be solved implicitly we recast the vertically-integrated continuity; equation \eqref{eq:vertically-integrated-continuity} into a discrete integral form. The best way to do; so is by starting from the discrete version of the continuity equation (in this case without any surface; volume flux, ``M = 0``). ```math; \begin{align}; \label{eq:continuity-discrete}; \delta_x (A_x u) + \delta_y (A_y v) + \delta_z (A_z w) = 0 \, ,; \end{align}; ```. and summing it vertically to get:. ```math; \begin{align}; \label{eq:vertically-integrated-continuity-discrete}; \delta_x \sum_k (A_x u) + \delta_y \sum_k (A_y v) + A_z \underbrace{w(k = N_z + 1)}_{w_{\rm top}} = 0 \, .; \end{align}; ```. In equations \eqref{eq:continuity-discrete} and \eqref{eq:vertically-integrated-continuity-discrete} and; here after, we have abused notation and used, e.g., ``u`` and ``v`` to denote the volume averages; over grid cells of the quantities ``u`` and ``v`` respectively. Using ``w_{\rm top} = \partial_t \eta`` and; being a bit more explicit on the locations the difference operators act on,; \eqref{eq:vertically-integrated-continuity-discrete} becomes:. ```math; \begin{equation}; \label{eq:semi-discrete-integral-continuity}; A_z \partial_t \eta + \delta_{x}^{caa} \sum_{k} (A_x u) + \delta_y^{aca} \sum_k (A_y v) = 0 \, .; \end{equation}; ```. We can now apply the velocity fractional step equation (discussed in the [Time-stepping section](@ref time_stepping)) for the [hydrostatic model](@ref hydrostatic_free_surface_model):. ```math; \begin{equation}; \label{eq:hydrostatic-fraction",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:13487,integrat,integrated-continuity-discrete,13487,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['integrat'],['integrated-continuity-discrete']
Integrability,"tantiate`. This will install all the dependencies in the Project.toml; file. Your development environment is now ready!. * You can test to make sure Oceananigans works by typing in `] test`. (This is equivalent to; `using Pkg; Pkg.test()`.) Doing so will run all the tests (and this can take a while).; Alternatively, you can run only one test script file by providing its name as an environment; variable. For example, to run the tests only from the `test_coriolis.jl` file we call:. ```; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; ```. ## Pull Requests. We follow the [ColPrac guide](https://github.com/SciML/ColPrac) for collaborative practices.; We ask that new contributors read that guide before submitting a pull request. Changes and contributions should be made via GitHub pull requests against the ``main`` branch. When you're done making changes, commit the changes you made. Chris Beams has written a ; [guide](https://chris.beams.io/posts/git-commit/) on how to write good commit messages. When you think your changes are ready to be merged into the main repository, push to your fork; and [submit a pull request](https://github.com/CLiMA/Oceananigans.jl/compare/). **Working on your first Pull Request?** You can learn how from this _free_ video series; [How to Contribute to an Open Source Project on GitHub](https://egghead.io/courses/how-to-contribute-to-an-open-source-project-on-github), Aaron Meurer's [tutorial on the git workflow](https://www.asmeurer.com/git-workflow/), or the guide [‚ÄúHow to Contribute to Open Source""](https://opensource.guide/how-to-contribute/). ## Documentation. Now that you've made your awesome contribution, it's time to tell the world how to use it.; Writing documentation strings is really important to make sure others use your functionality; properly. Didn't write new functions? That's fine, but be sure that the documentation for; the code you touched is still in great shape. It is not uncommon to find some strange wo",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:8312,message,messages,8312,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['message'],['messages']
Integrability,"tions with parameters""; The keyword argument `parameters` above specifies that `wind_stress` is called; with the signature `wind_stress(x, y, t, parameters)`. In principle, `parameters` is arbitrary.; However, relatively simple objects such as floating point numbers or `NamedTuple`s must be used; when running on the GPU. ### 5. 'Field-dependent' boundary conditions. Boundary conditions may also depend on model fields. For example, a linear drag boundary condition; is implemented with. ```jldoctest; julia> @inline linear_drag(x, y, t, u) = - 0.2 * u; linear_drag (generic function with 1 method). julia> u_bottom_bc = FluxBoundaryCondition(linear_drag, field_dependencies=:u); FluxBoundaryCondition: ContinuousBoundaryFunction linear_drag at (Nothing, Nothing, Nothing); ```. `field_dependencies` specifies the name of the dependent fields either with a `Symbol` or `Tuple` of `Symbol`s. ### 6. 'Field-dependent' boundary conditions with parameters. When boundary conditions depends on fields _and_ parameters, their functions take the form. ```jldoctest; julia> @inline quadratic_drag(x, y, t, u, v, drag_coeff) = - drag_coeff * u * sqrt(u^2 + v^2); quadratic_drag (generic function with 1 method). julia> u_bottom_bc = FluxBoundaryCondition(quadratic_drag, field_dependencies=(:u, :v), parameters=1e-3); FluxBoundaryCondition: ContinuousBoundaryFunction quadratic_drag at (Nothing, Nothing, Nothing); ```. Put differently, `Œæ, Œ∑, t` come first in the function signature, followed by field dependencies,; followed by `parameters` is `!isnothing(parameters)`. ### 7. Discrete-form boundary condition with parameters. Discrete field data may also be accessed directly from boundary condition functions; using the `discrete_form`. For example:. ```jldoctest; @inline filtered_drag(i, j, grid, clock, model_fields) =; @inbounds - 0.05 * (model_fields.u[i-1, j, 1] + 2 * model_fields.u[i, j, 1] + model_fields.u[i-1, j, 1]). u_bottom_bc = FluxBoundaryCondition(filtered_drag, discrete_form=true). # ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md:12903,depend,depends,12903,docs/src/model_setup/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md,1,['depend'],['depends']
Integrability,"ular grids the eigenvectors of the discrete Poisson operator are no longer simple Fourier; series sines and cosines. This means discrete Fast Fourier Transforms can't be used to generate the projection ; of the equation right hand side onto eigenvectors. So an eigenvector based approach to solving; the Poisson equation is not computationally efficient. For problems with grids that are non uniform in multiple directions, we use instead a pre-conditioned conjugate; gradient iterative solver. Such cases include curvilinear grids on the sphere and also telescoping cartesian; grids that stretch along more than one dimension. There are two forms of the pressure operator in this approach.; One is rigid lid form and one is an implicit free-surface form. ### Rigid lid pressure operator. The rigid lid operator is based on the same continuous form as is used in the Direct Method; solver. ### Implicit free surface pressure operator. The implicit free surface solver solves for the free-surface, ``\eta(x, y, t)``, in the vertically; integrated continuity equation:. ```math; \begin{equation}; \label{eq:vertically-integrated-continuity}; \partial_t \eta + \partial_x \left ( \int_{-H}^0 u \, \mathrm{d}z \right ) + \partial_y \left ( \int_{-H}^0 v \, \mathrm{d}z \right ) = M \, ,; \end{equation}; ```. where ``H(x, y)`` is the depth of the water column (to first order with respect to the free surface; elevation) and ``M`` is some surface volume flux (e.g., terms such as precipitation, evaporation and; runoff); currently Oceananigans.jl assumes ``M = 0``. Note that in deriving \eqref{eq:vertically-integrated-continuity},; we used the bottom boundary condition ``w_{\rm bottom} = \boldsymbol{u}_{\rm bottom} \boldsymbol{\cdot} \boldsymbol{\nabla}_h H``. To form a linear system that can be solved implicitly we recast the vertically-integrated continuity; equation \eqref{eq:vertically-integrated-continuity} into a discrete integral form. The best way to do; so is by starting from the discret",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:12205,integrat,integrated,12205,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['integrat'],['integrated']
Integrability,"ure operator in this approach.; One is rigid lid form and one is an implicit free-surface form. ### Rigid lid pressure operator. The rigid lid operator is based on the same continuous form as is used in the Direct Method; solver. ### Implicit free surface pressure operator. The implicit free surface solver solves for the free-surface, ``\eta(x, y, t)``, in the vertically; integrated continuity equation:. ```math; \begin{equation}; \label{eq:vertically-integrated-continuity}; \partial_t \eta + \partial_x \left ( \int_{-H}^0 u \, \mathrm{d}z \right ) + \partial_y \left ( \int_{-H}^0 v \, \mathrm{d}z \right ) = M \, ,; \end{equation}; ```. where ``H(x, y)`` is the depth of the water column (to first order with respect to the free surface; elevation) and ``M`` is some surface volume flux (e.g., terms such as precipitation, evaporation and; runoff); currently Oceananigans.jl assumes ``M = 0``. Note that in deriving \eqref{eq:vertically-integrated-continuity},; we used the bottom boundary condition ``w_{\rm bottom} = \boldsymbol{u}_{\rm bottom} \boldsymbol{\cdot} \boldsymbol{\nabla}_h H``. To form a linear system that can be solved implicitly we recast the vertically-integrated continuity; equation \eqref{eq:vertically-integrated-continuity} into a discrete integral form. The best way to do; so is by starting from the discrete version of the continuity equation (in this case without any surface; volume flux, ``M = 0``). ```math; \begin{align}; \label{eq:continuity-discrete}; \delta_x (A_x u) + \delta_y (A_y v) + \delta_z (A_z w) = 0 \, ,; \end{align}; ```. and summing it vertically to get:. ```math; \begin{align}; \label{eq:vertically-integrated-continuity-discrete}; \delta_x \sum_k (A_x u) + \delta_y \sum_k (A_y v) + A_z \underbrace{w(k = N_z + 1)}_{w_{\rm top}} = 0 \, .; \end{align}; ```. In equations \eqref{eq:continuity-discrete} and \eqref{eq:vertically-integrated-continuity-discrete} and; here after, we have abused notation and used, e.g., ``u`` and ``v`` to denote t",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:12775,integrat,integrated-continuity,12775,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['integrat'],['integrated-continuity']
Integrability,"velocity fields to zero and restores temperature to a linear gradient in the bottom; 1/10th of the domain:. ```jldoctest sponge_layer; grid = RectilinearGrid(size=(1, 1, 1), x=(0, 1), y=(0, 1), z=(-1, 0)). damping_rate = 1/100 # relax fields on a 100 second time-scale; temperature_gradient = 0.001 # ‚Å∞C m‚Åª¬π; surface_temperature = 20 # ‚Å∞C (at z=0). target_temperature = LinearTarget{:z}(intercept=surface_temperature, gradient=temperature_gradient); bottom_mask = GaussianMask{:z}(center=-grid.Lz, width=grid.Lz/10). uvw_sponge = Relaxation(rate=damping_rate, mask=bottom_mask); T_sponge = Relaxation(rate=damping_rate, mask=bottom_mask, target=target_temperature). model = NonhydrostaticModel(grid=grid, forcing=(u=uvw_sponge, v=uvw_sponge, w=uvw_sponge, T=T_sponge), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S)). model.forcing.u. # output; ContinuousForcing{Nothing} at (Face, Center, Center); ‚îú‚îÄ‚îÄ func: Relaxation(rate=0.01, mask=exp(-(z + 1.0)^2 / (2 * 0.1^2)), target=0); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:u,); ```. ```jldoctest sponge_layer; model.forcing.T. # output; ContinuousForcing{Nothing} at (Center, Center, Center); ‚îú‚îÄ‚îÄ func: Relaxation(rate=0.01, mask=exp(-(z + 1.0)^2 / (2 * 0.1^2)), target=20.0 + 0.001 * z); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:T,); ```. ## `AdvectiveForcing`. `AdvectiveForcing` defines a forcing function that represents advection by; a separate or ""slip"" velocity relative to the prognostic model velocity field.; `AdvectiveForcing` is implemented with native Oceananigans advection operators,; which means that tracers advected by the ""flux form"" advection term; ``ùõÅ‚ãÖùêÆ_{\rm slip} c``. Caution is advised when ``ùêÆ_{\rm slip}`` is not divergence free. As an example, consider a model for sediment settling at a constant rate:. ```jldoctest; using Oceananigans. r_sediment = 1e-4 # [m] ""Fine sand""; œÅ_sediment = 1200 # kg m‚Åª¬≥; œÅ_ocean = 1026 # kg m‚Åª¬≥; Œîb = 9.81 * (œÅ_ocean - œÅ_sediment) / œÅ_ocean # m s‚Åª¬≤; ŒΩ_molecular = 1.05e-6 # ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:10170,depend,dependencies,10170,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['depend'],['dependencies']
Integrability,"w_sediment). # output; AdvectiveForcing:; ‚îú‚îÄ‚îÄ u: ZeroField{Int64}; ‚îú‚îÄ‚îÄ v: ZeroField{Int64}; ‚îî‚îÄ‚îÄ w: ConstantField(-0.00352102); ```. The three keyword arguments specify the `u`, `v`, and `w` components of the separate; slip velocity field. The default for each `u, v, w` is `ZeroField`. Next we consider a dynamically-evolving slip velocity. For this we use `ZFaceField`; with appropriate boundary conditions as our slip velocity:. ```jldoctest sinking; using Oceananigans; using Oceananigans.BoundaryConditions: ImpenetrableBoundaryCondition. grid = RectilinearGrid(size=(32, 32, 32), x=(-10, 10), y=(-10, 10), z=(-4, 4),; topology=(Periodic, Periodic, Bounded)). no_penetration = ImpenetrableBoundaryCondition(); slip_bcs = FieldBoundaryConditions(grid, (Center, Center, Face),; top=no_penetration, bottom=no_penetration). w_slip = ZFaceField(grid, boundary_conditions=slip_bcs); sinking = AdvectiveForcing(w=w_slip). # output; AdvectiveForcing:; ‚îú‚îÄ‚îÄ u: ZeroField{Int64}; ‚îú‚îÄ‚îÄ v: ZeroField{Int64}; ‚îî‚îÄ‚îÄ w: 32√ó32√ó33 Field{Center, Center, Face} on RectilinearGrid on CPU; ```. To compute the slip velocity, we must add a `Callback`to `simulations.callback` that; computes `w_slip` ever iteration:. ```jldoctest sinking; using Oceananigans.BoundaryConditions: fill_halo_regions!. model = NonhydrostaticModel(; grid, tracers=(:b, :P), forcing=(; P=sinking)); simulation = Simulation(model; Œît=1, stop_iteration=100). # Build abstract operation for slip velocity; b_particle = - 1e-4 # relative buoyancy depends on reference density and initial buoyancy condition; b = model.tracers.b; R = 1e-3 # [m] mean particle radius; ŒΩ = 1.05e-6 # [m¬≤ s‚Åª¬π] molecular kinematic viscosity of water; w_slip_op = 2/9 * (b - b_particle) / ŒΩ * R^2 # Stokes terminal velocity. function compute_slip_velocity!(sim); w_slip .= w_slip_op; fill_halo_regions!(w_slip); return nothing; end. simulation.callbacks[:slip] = Callback(compute_slip_velocity!). # output; Callback of compute_slip_velocity! on IterationInterval(1); ```; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:12751,depend,depends,12751,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['depend'],['depends']
Integrability,"x, y, z)`` is average velocity of a fluid particle whose average position is ``(x, y, z)`` ; at time ``t``. The average position of a fluid particle ``\boldsymbol{\xi}(t) = (\xi, \eta, \zeta)`` ; is thus governed by; ```math; \partial_t \boldsymbol{\xi} + \boldsymbol{v}(\boldsymbol{\xi}, t) \boldsymbol{\cdot} \boldsymbol{\nabla} \boldsymbol{\xi} = \boldsymbol{v}(\boldsymbol{\xi}, t) \, ,; ```; which is the same relationship that holds when surface waves are not present and ``\boldsymbol{v}`` ; ceases to be an averaged velocity field. The simplicity of the governing equations for Lagrangian-mean ; momentum is the main reason we use a Lagrangian-mean formulation in Oceananigans.jl, rather ; than an Eulerian-mean formulation: for example, the tracer conservation equation is unchanged ; by the inclusion of surface wave effects. Moreover, because the effect of surface waves manifests ; either as a bulk forcing of Lagrangian-mean momentum or as a modification to the effective background ; rotation rate of the interior fluid similar to any bulk forcing or Coriolis force, we do not ; explicitly include the effects of surface waves in turbulence closures that model the effects ; of subgrid turbulence. More specifically, the effect of steady surface waves does not effect ; the conservation of Lagrangian-mean turbulent kinetic energy. The Lagrangian-mean velocity field ``\boldsymbol{v}`` contrasts with the Eulerian-mean velocity ; field ``\boldsymbol{v}^E``, which is the fluid velocity averaged at the fixed Eulerian position ; ``(x, y, z)``. The surface wave Stokes drift field supplied by the user is, in fact, defined; by the difference between the Eulerian- and Lagrangian-mean velocity:; ```math; \boldsymbol{u}^S \equiv \boldsymbol{v} - \boldsymbol{v}^E \, .; ```; The Stokes drift velocity field is typically prescribed for idealized scenarios, or determined; from a wave model for the evolution of surface waves under time-dependent atmospheric winds; in more realistic cases.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/surface_gravity_waves.md:3071,depend,dependent,3071,docs/src/physics/surface_gravity_waves.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/surface_gravity_waves.md,1,['depend'],['dependent']
Modifiability," 1.0) regularly spaced with Œîy=1.0; ‚îî‚îÄ‚îÄ Bounded z ‚àà [-1.0, 0.0] regularly spaced with Œîz=1.0. julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ‚îú‚îÄ‚îÄ grid: 1√ó1√ó1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ timestepper: RungeKutta3TimeStepper; ‚îú‚îÄ‚îÄ tracers: (); ‚îú‚îÄ‚îÄ closure: Nothing; ‚îú‚îÄ‚îÄ buoyancy: Nothing; ‚îî‚îÄ‚îÄ coriolis: Nothing. julia> typeof(model.velocities.u.data); OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}. julia> adapt(Array, model.velocities.u.data); 3√ó3√ó3 OffsetArray(::Array{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2√ó0:2√ó0:2:; [:, :, 0] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 1] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0; ```. Notice that to view the `CuArray` that stores values for `u` we first need to transform; it into a regular `Array` using `Adapt.adapt`. If we naively try to view the `CuArray`; without that step we get an error:. ```julia; julia> model.velocities.u.data; 3√ó3√ó3 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2√ó0:2√ó0:2:; [:, :, 0] =; Error showing value of type OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}:; ERROR: Scalar indexing is disallowed.; ```. Here `CUDA.jl` throws an error because scalar `getindex` is not `allowed`. There are ways to; overcome this limitation and allow scalar indexing (more about that ; in the [CUDA.jl documentation](https://cuda.juliagpu.org/stable/usage/workflow/#UsageWorkflowScalar)), but this option; can be very slow on GPUs, so it is advised to only use this last method when using the REPL or ; prototyping -- never in production-ready scripts. You might also need to keep these differences in mind when using arrays; to define initial conditions, boundary conditions or; forcing functio",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:12818,adapt,adapt,12818,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['adapt'],['adapt']
Modifiability," A few more time-steps, and it's starting to get a little diffuse!. ```@example cpu; simulation.stop_iteration += 400; run!(simulation). compute!(Œ∂); heatmap(Œ∂, axis=(; aspect=1)); ```. ## They always cheat with too-simple ""quick"" starts. Fine, we'll re-run this code on the GPU. But we're a little greedy, so we'll also; crank up the resolution, throw in a `TimeStepWizard` to update `simulation.Œît` adaptively,; and add a passive tracer initially concentrated in the center of the domain; which will make for an even prettier figure of the final state:. ```@setup gpu; using CairoMakie; CairoMakie.activate!(type = ""png""); ```. ```@example gpu; using Oceananigans; using CairoMakie. grid = RectilinearGrid(GPU(),; size = (1024, 1024),; x = (-œÄ, œÄ),; y = (-œÄ, œÄ),; topology = (Periodic, Periodic, Flat)). model = NonhydrostaticModel(; grid, advection=WENO(), tracers=:c). Œ¥ = 0.5; c·µ¢(x, y) = exp(-(x^2 + y^2) / 2Œ¥^2); œµ(x, y) = 2rand() - 1; set!(model, u=œµ, v=œµ, c=c·µ¢). simulation = Simulation(model; Œît=1e-3, stop_time=10); conjure_time_step_wizard!(simulation, cfl=0.2, IterationInterval(10)); run!(simulation). u, v, w = model.velocities; Œ∂ = Field(‚àÇx(v) - ‚àÇy(u)); compute!(Œ∂). fig = Figure(size=(1200, 600)); axŒ∂ = Axis(fig[1, 1], aspect=1, title=""vorticity""); axc = Axis(fig[1, 2], aspect=1, title=""tracer""); heatmap!(axŒ∂, Œ∂, colormap=:balance); heatmap!(axc, model.tracers.c); current_figure(); ```. See how we did that? We passed the positional argument `GPU()` to `RectilinearGrid`.; (This only works if a GPU is available, of course, and; [CUDA.jl is configured](https://cuda.juliagpu.org/stable/installation/overview/).). ## Well, that was tantalizing. But you'll need to know a lot more to become a productive, Oceananigans-wielding computational scientist (spherical grids, forcing, boundary conditions,; turbulence closures, output writing, actually labeling your axes... ü§Ø).; It'd be best to move on to the [one-dimensional diffusion example](@ref one_dimensional_diffusion_example).; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/quick_start.md:2699,config,configured,2699,docs/src/quick_start.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/quick_start.md,1,['config'],['configured']
Modifiability," Mechanics_, **976**, A8. DOI: [10.1017/jfm.2023.920](https://doi.org/10.1017/jfm.2023.920). 1. Jim√©nez-Urias, M. A. and Haine T. W. N. (2023) [On the non-self-adjoint and multiscale character of passive scalar mixing under laminar advection](https://doi.org/10.1017/jfm.2023.748), _Journal of Fluid Mechanics_, **973**, A44. DOI: [10.1017/jfm.2023.748](https://doi.org/10.1017/jfm.2023.748). 1. Strong-Wright, J, Chen, S., Constantinou, N. C., Silvestri, S., Wagner, G. L., and Taylor, J. R. (2023). [OceanBioME.jl: A flexible environment for modelling the coupled interactions between ocean biogeochemistry and physics](https://doi.org/10.21105/joss.05669), _Journal of Open Source Software_, **90(8)**, 5669. DOI: [10.21105/joss.05669](https://doi.org/10.21105/joss.05669). 1. Ramadhan, A., Marshall, J. C., Souza, A. N., Lee, X. K., Piterbarg, U., Hillier, A., Wagner, G. L., Rackauckas, C., Hill, C., Campin, J.-M., and Ferrari, R. (2022). [Capturing missing physics in climate model parameterizations using neural differential equations](https://doi.org/10.1002/essoar.10512533.1), _ESS Open Archive_. DOI: [10.1002/essoar.10512533.1](https://doi.org/10.1002/essoar.10512533.1). 1. Gupta, M. and Thompson, A. F. (2022). [Regimes of sea-ice floe melt: Ice-ocean coupling at the submesoscales](https://doi.org/10.1029/2022JC018894), _Journal of Geophysical Research: Oceans_, **127**, e2022JC018894. DOI: [10.1029/2022JC018894](https://doi.org/10.1029/2022JC018894). 1. Simoes-Sousa, I. T., Tandon, A., Pereira, F., Lazaneo, C. Z., and Mahadevan, A. (2022). [Mixed layer eddies supply nutrients to enhance the spring phytoplankton bloom](https://doi.org/10.3389/fmars.2022.825027), _Frontiers in Marine Sciences_, **9**, 825027. DOI: [10.3389/fmars.2022.825027](https://doi.org/10.3389/fmars.2022.825027). 1. Chor, T., Wenegrat, J. O., and Taylor, J. (2022). [Insights into the mixing efficiency of submesoscale Centrifugal-Symmetric instabilities.](https://doi.org/10.1175/JPO-D-21-0259.1), _Jou",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md:9197,parameteriz,parameterizations,9197,docs/src/index.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md,1,['parameteriz'],['parameterizations']
Modifiability," and Thompson, A. F. (2024). [Eddy-induced dispersion of sea ice floes at the marginal ice zone](https://doi.org/10.1029/2023GL105656), _Geophysical Research Letters_, **51**, e2023GL105656. DOI: [10.1029/2023GL105656](https://doi.org/10.1029/2023GL105656). 1. Wagner, G. L., Pizzo, N. E., Lenain, L., and Veron, F. (2023) [Transition to turbulence in wind-drift layers](https://doi.org/10.1017/jfm.2023.920), _Journal of Fluid Mechanics_, **976**, A8. DOI: [10.1017/jfm.2023.920](https://doi.org/10.1017/jfm.2023.920). 1. Jim√©nez-Urias, M. A. and Haine T. W. N. (2023) [On the non-self-adjoint and multiscale character of passive scalar mixing under laminar advection](https://doi.org/10.1017/jfm.2023.748), _Journal of Fluid Mechanics_, **973**, A44. DOI: [10.1017/jfm.2023.748](https://doi.org/10.1017/jfm.2023.748). 1. Strong-Wright, J, Chen, S., Constantinou, N. C., Silvestri, S., Wagner, G. L., and Taylor, J. R. (2023). [OceanBioME.jl: A flexible environment for modelling the coupled interactions between ocean biogeochemistry and physics](https://doi.org/10.21105/joss.05669), _Journal of Open Source Software_, **90(8)**, 5669. DOI: [10.21105/joss.05669](https://doi.org/10.21105/joss.05669). 1. Ramadhan, A., Marshall, J. C., Souza, A. N., Lee, X. K., Piterbarg, U., Hillier, A., Wagner, G. L., Rackauckas, C., Hill, C., Campin, J.-M., and Ferrari, R. (2022). [Capturing missing physics in climate model parameterizations using neural differential equations](https://doi.org/10.1002/essoar.10512533.1), _ESS Open Archive_. DOI: [10.1002/essoar.10512533.1](https://doi.org/10.1002/essoar.10512533.1). 1. Gupta, M. and Thompson, A. F. (2022). [Regimes of sea-ice floe melt: Ice-ocean coupling at the submesoscales](https://doi.org/10.1029/2022JC018894), _Journal of Geophysical Research: Oceans_, **127**, e2022JC018894. DOI: [10.1029/2022JC018894](https://doi.org/10.1029/2022JC018894). 1. Simoes-Sousa, I. T., Tandon, A., Pereira, F., Lazaneo, C. Z., and Mahadevan, A. (2022). [Mixed layer",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md:8727,flexible,flexible,8727,docs/src/index.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md,1,['flexible'],['flexible']
Modifiability," are rewritten via the vector identity:; ```math; \boldsymbol{u} \boldsymbol{\cdot} \boldsymbol{\nabla} \boldsymbol{u} = (\boldsymbol{\nabla} \times \boldsymbol{u}) \times \boldsymbol{u} + \boldsymbol{\nabla} \left( \frac1{2} \boldsymbol{u} \boldsymbol{\cdot} \boldsymbol{u} \right ) \, .; ```; Thus, the shallow water dynamics in vector-invariant form become:. ```math; \begin{align}; \partial_t \boldsymbol{u} + (\zeta \boldsymbol{\hat z} + \boldsymbol{f}) \times\boldsymbol{u} & = ; - \boldsymbol{\nabla} \left [ g (h +b) + \frac12 \boldsymbol{u} \cdot \boldsymbol{u} \right ] \, , \\; \partial_t h + \boldsymbol{\nabla} \boldsymbol{\cdot} (\boldsymbol{u} h) & = 0 \, ,; \end{align}; ```; where ``\zeta(x, y, t) = \partial_x v - \partial_y u`` is the vertical component of the relative vorticity. The elevation of the bottom bathymetry, measured with respect to the free-surface at rest, is ``b(x, y)``.; The free-surface elevation ``\eta`` is then:. ```math; \eta(x, y, t) = h(x, y, t) + b(x, y) \, .; ```. The `ConservativeFormulation()` uses the volume transport along each direction ``\boldsymbol{u} h = (u h, v h)`` and the total; depth of the fluid ``h`` as the dynamical variables. The shallow water dynamics in conservative form is:; ```math; \begin{align}; \partial_t (\boldsymbol{u} h) + \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \boldsymbol{u} \boldsymbol{u} h \right ) + \boldsymbol{f} \times (\boldsymbol{u} h) & = - g h \boldsymbol{\nabla} \left ( h + b \right ) \, ,\\; \partial_t h + \boldsymbol{\nabla} \boldsymbol{\cdot} (\boldsymbol{u} h) & = 0 \, ,; \end{align}; ```; where ``\boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \boldsymbol{u} \boldsymbol{u} h \right )``; denotes a vector whose components are ``[\boldsymbol{\nabla} \boldsymbol{\cdot} (\boldsymbol{u} \boldsymbol{u} h)]_i = \boldsymbol{\nabla} \boldsymbol{\cdot} (u_i \boldsymbol{u} h)``. We can retrieve the flow velocities; by dividing the corresponding transport by the fluid's height, e.g., `v = vh / h`.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/shallow_water_model.md:1859,variab,variables,1859,docs/src/physics/shallow_water_model.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/shallow_water_model.md,1,['variab'],['variables']
Modifiability," as the one we constructed above, one would probably like to have finer resolution near; the channel walls. We construct a grid that has non-regular spacing in the bounded dimensions, here ``y`` and ``z``; by prescribing functions for `y` and `z` keyword arguments. For example, we can use the Chebychev nodes, which are more closely stacked near boundaries, to prescribe the; ``y``- and ``z``-faces. ```jldoctest; julia> Nx, Ny, Nz = 64, 64, 32;. julia> Lx, Ly, Lz = 1e4, 1e4, 1e3;. julia> chebychev_spaced_y_faces(j) = - Ly/2 * cos(œÄ * (j - 1) / Ny);. julia> chebychev_spaced_z_faces(k) = - Lz/2 - Lz/2 * cos(œÄ * (k - 1) / Nz);. julia> grid = RectilinearGrid(size = (Nx, Ny, Nz),; topology = (Periodic, Bounded, Bounded),; x = (0, Lx),; y = chebychev_spaced_y_faces,; z = chebychev_spaced_z_faces); 64√ó64√ó32 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 10000.0) regularly spaced with Œîx=156.25; ‚îú‚îÄ‚îÄ Bounded y ‚àà [-5000.0, 5000.0] variably spaced with min(Œîy)=6.02272, max(Œîy)=245.338; ‚îî‚îÄ‚îÄ Bounded z ‚àà [-1000.0, 0.0] variably spaced with min(Œîz)=2.40764, max(Œîz)=49.0086; ```. ```@setup 1; using Oceananigans; using CairoMakie; CairoMakie.activate!(type = ""svg""); Nx, Ny, Nz = 64, 64, 32; Lx, Ly, Lz = 1e4, 1e4, 1e3; chebychev_spaced_y_faces(j) = - Ly/2 * cos(œÄ * (j - 1) / Ny);; chebychev_spaced_z_faces(k) = - Lz/2 - Lz/2 * cos(œÄ * (k - 1) / Nz);; grid = RectilinearGrid(size = (Nx, Ny, Nz),; topology = (Periodic, Bounded, Bounded),; x = (0, Lx),; y = chebychev_spaced_y_faces,; z = chebychev_spaced_z_faces); ```. We can easily visualize the spacings of ``y`` and ``z`` directions. We can use, e.g.,; [`ynodes`](@ref) and [`yspacings`](@ref) to extract the positions and spacings of the; nodes from the grid. ```@example 1; y·∂ú = ynodes(grid, Center()); Œîy·∂ú = yspacings(grid, Center()). z·∂ú = znodes(grid, Center()); Œîz·∂ú = zspacings(grid, Center()). using CairoMakie. fig = Figure(size=(800, 900)). ax1 = Axis(fig[1, 1]; xlabel = ""y (m)"", ylab",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/legacy_grids.md:5563,variab,variably,5563,docs/src/model_setup/legacy_grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/legacy_grids.md,1,['variab'],['variably']
Modifiability," readable code. ## What is a ""collaborator"" and how can I become one?. * Collaborators have permissions to review pull requests and status allows a contributor to review pull requests in addition to opening them. Collaborators can also create branches in the main Oceananigans repository. * We ask that new contributors try their hand at forking Oceananigans, and opening and merging a pull request before requesting collaborator status. ## What's a good way to start developing Oceananigans?. * Tackle an existing issue. We keep a list of [good first issues](https://github.com/CLiMA/Oceananigans.jl/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22); that are self-contained and suitable for a newcomer to try and work on. * Try to run Oceananigans and play around with it to simulate your favorite; fluids and ocean physics. If you run into any problems or find it difficult; to use or understand, please open an issue!. * Write up an example or tutorial on how to do something useful with; Oceananigans, like how to set up a new physical configuration. * Improve documentation or comments if you found something hard to use. * Implement a new feature if you need it to use Oceananigans. If you're interested in working on something, let us know by commenting on existing issues or ; by opening a new issue. This is to make sure no one else is working on the same issue and so ; we can help and guide you in case there is anything you need to know beforehand. ## Ground Rules. * Each pull request should consist of a logical collection of changes. You can; include multiple bug fixes in a single pull request, but they should be related.; For unrelated changes, please submit multiple pull requests. * Do not commit changes to files that are irrelevant to your feature or bugfix; (eg: `.gitignore`). * Be willing to accept criticism and work on improving your code; we don't want; to break other users' code, so care must be taken not to introduce bugs. We; discuss pull requests and kee",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:4461,config,configuration,4461,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['config'],['configuration']
Modifiability," same as for `RectilinearGrid`.; In our next example, we use a function to build a Mercator grid with a spacing of 2 degrees at; the equator,. ```jldoctest latlon_nodes; # Mercator scale factor; scale_factor(œÜ) = 1 / cosd(œÜ). # Compute cell interfaces with Mercator spacing; m = 2 # spacing at the equator in degrees; function latitude_faces(j); if j == 1 # equator; return 0; else # crudely estimate the location of the jth face ; œÜ‚Çã = latitude_faces(j-1); œÜ‚Ä≤ = œÜ‚Çã + m * scale_factor(œÜ‚Çã) / 2; return œÜ‚Çã + m * scale_factor(œÜ‚Ä≤); end; end. Lx = 360; Nx = Int(Lx / m); Ny = findfirst(latitude_faces.(1:Nx) .> 90) - 2. grid = LatitudeLongitudeGrid(size = (Nx, Ny),; longitude = (0, Lx),; latitude = latitude_faces,; topology = (Bounded, Bounded, Flat)). # output; 180√ó28√ó1 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Flat} on CPU with 3√ó3√ó0 halo and with precomputed metrics; ‚îú‚îÄ‚îÄ longitude: Bounded Œª ‚àà [0.0, 360.0] regularly spaced with ŒîŒª=2.0; ‚îú‚îÄ‚îÄ latitude: Bounded œÜ ‚àà [0.0, 77.2679] variably spaced with min(ŒîœÜ)=2.0003, max(ŒîœÜ)=6.95319; ‚îî‚îÄ‚îÄ z: Flat z ; ```. We've also illustrated the construction of a grid that is `Flat` in the vertical direction.; Now let's plot the metrics for this grid,. ```@setup plot; # Mercator scale factor; scale_factor(œÜ) = 1 / cosd(œÜ). # Compute cell interfaces with Mercator spacing; m = 2 # spacing at the equator in degrees; function latitude_faces(j); if j == 1 # equator; return 0; else # crudely estimate the location of the jth face ; œÜ‚Çã = latitude_faces(j-1); œÜ‚Ä≤ = œÜ‚Çã + m * scale_factor(œÜ‚Çã) / 2; return œÜ‚Çã + m * scale_factor(œÜ‚Ä≤); end; end. Lx = 360; Nx = Int(Lx / m). # Deduce number of cells south of 90·µíN; Œªf = latitude_faces.(1:Nx); Ny = findfirst(Œªf .> 90) - 2. grid = LatitudeLongitudeGrid(size = (Nx, Ny),; longitude = (0, Lx),; latitude = latitude_faces,; topology = (Bounded, Bounded, Flat)); ```. ```@example plot; œÜ = œÜnodes(grid, Center()); Œîx = xspacings(grid, Center(), Center(), with_halos=true)[1:Ny]; Œîy = yspacings(grid, Center())[1:Ny]. usi",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:20532,variab,variably,20532,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['variab'],['variably']
Modifiability," title=""z-grid""); lines!(axz, [-Lz, 0], [0, 0], color=:gray); scatter!(axz, zf, 0 * zf, marker=:vline, color=:gray, markersize=20); scatter!(axz, zc, 0 * zc); hidedecorations!(axz); hidespines!(axz). axŒîz = Axis(fig[4, 1]; xlabel = ""z (m)"", ylabel = ""z-spacing (m)""); scatter!(axŒîz, zc, Œîz); hidespines!(axŒîz, :t, :r). rowsize!(fig.layout, 1, Relative(0.1)); rowsize!(fig.layout, 3, Relative(0.1)). current_figure(); ```. ## Inspecting `LatitudeLongitudeGrid` cell spacings. ```@setup latlon_nodes; using Oceananigans; ```. ```@example latlon_nodes; grid = LatitudeLongitudeGrid(size = (1, 44),; longitude = (0, 1), ; latitude = (0, 88),; topology = (Bounded, Bounded, Flat)). œÜ = œÜnodes(grid, Center()); Œîx = xspacings(grid, Center(), Center()). using CairoMakie. fig = Figure(size=(600, 400)); ax = Axis(fig[1, 1], xlabel=""Zonal spacing on 2 degree grid (km)"", ylabel=""Latitude (degrees)""); scatter!(ax, Œîx ./ 1e3, œÜ). current_figure(); ```. ![](plot_lat_lon_spacings.svg). ## `LatitudeLongitudeGrid` with variable spacing. The syntax for building a grid with variably-spaced cells is the same as for `RectilinearGrid`.; In our next example, we use a function to build a Mercator grid with a spacing of 2 degrees at; the equator,. ```jldoctest latlon_nodes; # Mercator scale factor; scale_factor(œÜ) = 1 / cosd(œÜ). # Compute cell interfaces with Mercator spacing; m = 2 # spacing at the equator in degrees; function latitude_faces(j); if j == 1 # equator; return 0; else # crudely estimate the location of the jth face ; œÜ‚Çã = latitude_faces(j-1); œÜ‚Ä≤ = œÜ‚Çã + m * scale_factor(œÜ‚Çã) / 2; return œÜ‚Çã + m * scale_factor(œÜ‚Ä≤); end; end. Lx = 360; Nx = Int(Lx / m); Ny = findfirst(latitude_faces.(1:Nx) .> 90) - 2. grid = LatitudeLongitudeGrid(size = (Nx, Ny),; longitude = (0, Lx),; latitude = latitude_faces,; topology = (Bounded, Bounded, Flat)). # output; 180√ó28√ó1 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Flat} on CPU with 3√ó3√ó0 halo and with precomputed metrics; ‚îú‚îÄ‚îÄ longitude: Bounded Œª ‚àà [0.0, ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:19462,variab,variable,19462,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['variab'],['variable']
Modifiability," unfamiliar with Julia can get away with efficient simulations by; learning a few rules of thumb. It is nonetheless recommended that users go through Julia's; [performance tips](https://docs.julialang.org/en/v1/manual/performance-tips/), which contains more; in-depth explanations of some of the aspects discussed here. ## General (CPU/GPU) simulation tips. ### Avoid global variables whenever possible. In general using a [global; variable](https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Global-Scope) (which can be; loosely defined as a variable defined in the main script) inside functions slows down the code. One; way to circumvent this is to always [use local variables or pass them as arguments to; functions](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). This; helps the compiler optimize the code. Another way around this is to [define global variables as constants whenever; possible](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). One; thing to keep in mind when doing this is that when a `const` is defined, its value can't be changed; until you restart the Julia session. So this latter approach is good for production-ready code, but; may be undesirable in the early stages of development while you still have to change the parameters; of the simulation for exploration. It is especially important to avoid global variables in functions that are meant to be executed in; GPU kernels (such as functions defining boundary conditions and forcings). Otherwise the Julia GPU; compiler can fail with obscure errors. This is explained in more detail in the GPU simulation tips; section below. ### Consider inlining small functions. Inlining is when the compiler [replaces a function call with the body of the function that is being; called before compiling](https://en.wikipedia.org/wiki/Inline_expansion). The advantage of inlining; (which in julia can be done with the [`@inline`; macro](https://docs.ju",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:1564,variab,variables,1564,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['variab'],['variables']
Modifiability," use `TitleCase` for types, `snake_case` for objects, and always.put.spaces.after.commas. For formatting decisions we loosely follow the [YASGuide](https://github.com/jrevels/YASGuide). It's worth few extra minutes of our time to leave future generations with well-written, readable code. ## What is a ""collaborator"" and how can I become one?. * Collaborators have permissions to review pull requests and status allows a contributor to review pull requests in addition to opening them. Collaborators can also create branches in the main Oceananigans repository. * We ask that new contributors try their hand at forking Oceananigans, and opening and merging a pull request before requesting collaborator status. ## What's a good way to start developing Oceananigans?. * Tackle an existing issue. We keep a list of [good first issues](https://github.com/CLiMA/Oceananigans.jl/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22); that are self-contained and suitable for a newcomer to try and work on. * Try to run Oceananigans and play around with it to simulate your favorite; fluids and ocean physics. If you run into any bugs/problems or find it difficult; to use or understand, please open an issue!. * Write up an example or tutorial on how to do something useful with; Oceananigans, like how to set up a new physical configuration. * Improve documentation or comments if you found something hard to use. * Implement a new feature if you need it to use Oceananigans. If you're interested in working on something, let us know by commenting on; existing issues or by opening a new issue. This is to make sure no one else; is working on the same issue and so we can help and guide you in case there; is anything you need to know beforehand. We also hang out on the #oceananigans channel on Julia Slack, which is a great; place to discuss anything Oceananigans-related, especially contributions! To; join the Julia Slack, go to [https://julialang.org/slack/](https://julialang.org/slack/).; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md:4546,config,configuration,4546,CONTRIBUTING.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md,1,['config'],['configuration']
Modifiability," viscosity and diffusivity *predictors*; ``\nu_e^\dagger`` and ``\kappa_e^\dagger``, such that; ```math; \nu_e = \max \lbrace 0, \nu_e^\dagger \rbrace; \quad \text{and} \quad; \kappa_e = \max \lbrace 0, \kappa_e^\dagger \rbrace \, ,; ```; to ensure that ``\nu_e \ge 0`` and ``\kappa_e \ge 0``. Leaving out the overlines and understanding that all variables; represent the resolved/filtered variables, the eddy viscosity predictor is given by; ```math; \begin{equation}; \label{eq:nu-dagger}; \nu_e^\dagger = -(C\Delta)^2; \frac; {\left( \hat{\partial}_k \hat{v}_i \right) \left( \hat{\partial}_k \hat{v}_j \right) \hat{S}_{ij}; + C_b\hat{\delta}_{i3} \alpha g \left( \hat{\partial}_k \hat{v_i} \right) \hat{\partial}_k \theta}; {\left( \hat{\partial}_l \hat{v}_m \right) \left( \hat{\partial}_l \hat{v}_m \right)} \, ,; \end{equation}; ```; and the eddy diffusivity predictor by; ```math; \begin{equation}; \kappa_e^\dagger = -(C\Delta)^2; \frac; {\left( \hat{\partial}_k \hat{v}_i \right) \left( \hat{\partial}_k \hat{\theta} \right) \hat{\partial}_i \theta}; {\left( \hat{\partial}_l \hat{\theta} \right) \left( \hat{\partial}_l \hat{\theta} \right)} \, ,; \end{equation}; ```; where; ```math; \begin{equation}; \hat{x}_i = \frac{x_i}{\Delta_i}, \quad; \hat{v}_i(\hat{x}, t) = \frac{v_i(x, t)}{\Delta_i}, \quad; \hat{\partial}_i \hat{v}_j(\hat{x}, t) = \frac{\Delta_i}{\Delta_j} \partial_i v_j(x, t), \quad; \hat{\delta}_{i3} = \frac{\delta_{i3}}{\Delta_3} \, ,; \end{equation}; ```; so that the normalized rate of strain tensor is; ```math; \begin{equation}; \label{eq:S-hat}; \hat{S}_{ij} =; \frac{1}{2} \left[ \hat{\partial}_i \hat{v}_j(\hat{x}, t) + \hat{\partial}_j \hat{v}_i(\hat{x}, t) \right] \, .; \end{equation}; ```. In equations \eqref{eq:nu-dagger}--\eqref{eq:S-hat}, ``C`` is a modified Poincar√© ""constant"" that is independent from; the filter width ``\Delta`` but does depend on the accuracy of the discretization method used. [Abkar16](@citet) cite; ``C^2 = \frac{1}{12}`` for a spe",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md:5997,variab,variables,5997,docs/src/numerical_implementation/large_eddy_simulation.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md,2,['variab'],['variables']
Modifiability,"# A complicated example: three-dimensional `RectilinearGrid` with variable spacing via functions. Next we build a grid that is both `Bounded` and stretched in both the `y` and `z` directions.; The purpose of the stretching is to increase grid resolution near the boundaries.; We'll do this by using functions to specify the keyword arguments `y` and `z`. ```jldoctest grids; Nx = Ny = 64; Nz = 32. Lx = Ly = 1e4; Lz = 1e3. # Note that j varies from 1 to Ny; chebychev_spaced_y_faces(j) = Ly * (1 - cos(œÄ * (j - 1) / Ny)) / 2. # Note that k varies from 1 to Nz; chebychev_spaced_z_faces(k) = - Lz * (1 + cos(œÄ * (k - 1) / Nz)) / 2. grid = RectilinearGrid(size = (Nx, Ny, Nz),; topology = (Periodic, Bounded, Bounded),; x = (0, Lx),; y = chebychev_spaced_y_faces,; z = chebychev_spaced_z_faces). # output; 64√ó64√ó32 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 10000.0) regularly spaced with Œîx=156.25; ‚îú‚îÄ‚îÄ Bounded y ‚àà [0.0, 10000.0] variably spaced with min(Œîy)=6.02272, max(Œîy)=245.338; ‚îî‚îÄ‚îÄ Bounded z ‚àà [-1000.0, -0.0] variably spaced with min(Œîz)=2.40764, max(Œîz)=49.0086; ```. ```@setup plot; using Oceananigans; using CairoMakie; CairoMakie.activate!(type = ""svg""); set_theme!(Theme(fontsize=24)). Nx, Ny, Nz = 64, 64, 32; Lx, Ly, Lz = 1e4, 1e4, 1e3. chebychev_spaced_y_faces(j) = Ly * (1 - cos(œÄ * (j - 1) / Ny)) / 2; chebychev_spaced_z_faces(k) = - Lz * (1 + cos(œÄ * (k - 1) / Nz)) / 2. grid = RectilinearGrid(size = (Nx, Ny, Nz),; topology = (Periodic, Bounded, Bounded),; x = (0, Lx),; y = chebychev_spaced_y_faces,; z = chebychev_spaced_z_faces); ```. We can easily visualize the spacings of ``y`` and ``z`` directions. We can use, e.g.,; [`ynodes`](@ref) and [`yspacings`](@ref) to extract the positions and spacings of the; nodes from the grid. ```@example plot; yc = ynodes(grid, Center()); zc = znodes(grid, Center()). yf = ynodes(grid, Face()); zf = znodes(grid, Face()). Œîy = yspacings(grid, Center()); Œîz = zspacings(grid, Center()",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:17025,variab,variably,17025,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['variab'],['variably']
Modifiability,"# Background fields. `BackgroundField`s are velocity and tracer fields around which the resolved; velocity and tracer fields evolve. Only the _advective_ terms associated with; the interaction between background and resolved fields are included.; For example, tracer advection is described by. ```math; \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \boldsymbol{v} c \right ) \, ,; ```. where ``\boldsymbol{v}`` is the resolved velocity field and ``c`` is the resolved; tracer field corresponding to `model.tracers.c`. . When a background field ``C`` is provided, the tracer advection term becomes. ```math; \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \boldsymbol{v} c \right ) ; + \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \boldsymbol{v} C \right ) \, .; ```. When both a background field velocity field ``\boldsymbol{U}`` and a background tracer field ``C``; are provided, then the tracer advection term becomes. ```math; \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \boldsymbol{v} c \right ) ; + \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \boldsymbol{v} C \right ); + \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \boldsymbol{U} c \right ) \, .; ```. Notice that the term ``\boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \boldsymbol{U} C \right )`` ; is neglected: only the terms describing the advection of resolved tracer by the background ; velocity field and the advection of background tracer by the resolved velocity field are included.; An analogous statement holds for the advection of background momentum by the resolved; velocity field.; Other possible terms associated with the Coriolis force, buoyancy, turbulence closures,; and surface waves acting on background fields are neglected. !!! compat ""Model compatibility""; `BackgroundFields` are only supported by [`NonhydrostaticModel`](@ref). ## Specifying background fields. `BackgroundField`s are defined by functions of ``(x, y, z, t)`` and optional parameters. A ; simple example is. ```jldoctest; using Oceananigans. ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/background_fields.md:125,evolve,evolve,125,docs/src/model_setup/background_fields.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/background_fields.md,1,['evolve'],['evolve']
Modifiability,"# Buoyancy models and equations of state. The buoyancy option selects how buoyancy is treated in `NonhydrostaticModel`s and; `HydrostaticFreeSurfaceModel`s (`ShallowWaterModel`s do not have that option given the physics of; the model). There are currently three alternatives:. 1. No buoyancy (and no gravity).; 2. Evolve buoyancy as a tracer.; 3. _Seawater buoyancy_: evolve temperature ``T`` and salinity ``S`` as tracers with a value for the gravitational; acceleration ``g`` and an equation of state of your choosing. ## No buoyancy. To turn off buoyancy (and gravity) you can simply pass `buoyancy = nothing` to the model; constructor. For example to create a `NonhydrostaticModel`:. ```@meta; DocTestSetup = quote; using Oceananigans; end; ```. ```jldoctest buoyancy; julia> grid = RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1));. julia> model = NonhydrostaticModel(; grid, buoyancy=nothing); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ‚îú‚îÄ‚îÄ grid: 8√ó8√ó8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ timestepper: RungeKutta3TimeStepper; ‚îú‚îÄ‚îÄ advection scheme: Centered reconstruction order 2; ‚îú‚îÄ‚îÄ tracers: (); ‚îú‚îÄ‚îÄ closure: Nothing; ‚îú‚îÄ‚îÄ buoyancy: Nothing; ‚îî‚îÄ‚îÄ coriolis: Nothing; ```. The option `buoyancy = nothing` is the default for [`NonhydrostaticModel`](@ref), so omitting the; `buoyancy` keyword argument from the `NonhydrostaticModel` constructor yields the same:. ```jldoctest buoyancy; julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ‚îú‚îÄ‚îÄ grid: 8√ó8√ó8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ timestepper: RungeKutta3TimeStepper; ‚îú‚îÄ‚îÄ advection scheme: Centered reconstruction order 2; ‚îú‚îÄ‚îÄ tracers: (); ‚îú‚îÄ‚îÄ closure: Nothing; ‚îú‚îÄ‚îÄ buoyancy: Nothing; ‚îî‚îÄ‚îÄ coriolis: Nothing; ```. The same is true for `HydrostaticFreeSurfaceModel`,. ```jldoctest buoyancy; julia> model = HydrostaticFreeSurfaceModel(; grid); Hydro",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/buoyancy_and_equation_of_state.md:368,evolve,evolve,368,docs/src/model_setup/buoyancy_and_equation_of_state.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/buoyancy_and_equation_of_state.md,1,['evolve'],['evolve']
Modifiability,"# Grids. The grids currently supported are:; - `RectilinearGrid`s with either constant or variable grid spacings and; - `LatitudeLongitudeGrid` on the sphere. ## `RectilinearGrid`. A `RectilinearGrid` is constructed by specifying the `size` of the grid (a `Tuple` specifying; the number of grid points in each direction) and either the `extent` (a `Tuple` specifying the; physical extent of the grid in each direction), or by prescribing `x`, `y`, and `z`. Keyword; arguments `x`, `y`, and `z` could be either *(i)* 2-`Tuple`s that define the the _end points_ in; each direction, or *(ii)* arrays or functions of the corresponding indices `i`, `j`, or `k` that; specify the locations of cell faces in the `x`-, `y`-, or `z`-direction, respectively. A regular rectilinear grid with ``N_x \times N_y \times N_z = 32 \times 64 \times 256`` grid points; and an `extent` of ``L_x = 128`` meters, ``L_y = 256`` meters, and ``L_z = 512`` meters is constructed; by. ```@meta; DocTestSetup = quote; using Oceananigans; end; ```. ```jldoctest; julia> grid = RectilinearGrid(size = (32, 64, 256), extent = (128, 256, 512)); 32√ó64√ó256 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 128.0) regularly spaced with Œîx=4.0; ‚îú‚îÄ‚îÄ Periodic y ‚àà [0.0, 256.0) regularly spaced with Œîy=4.0; ‚îî‚îÄ‚îÄ Bounded z ‚àà [-512.0, 0.0] regularly spaced with Œîz=2.0; ```. !!! info ""Default domain""; When using the `extent` keyword, e.g., `extent = (Lx, Ly, Lz)`, then the ``x \in [0, L_x]``,; ``y \in [0, L_y]``, and ``z \in [-L_z, 0]`` -- a sensible choice for oceanographic applications. ### Specifying the grid's architecture. The first positional argument in either `RectilinearGrid` or `LatitudeLongitudeGrid` is the grid's; architecture. By default `architecture = CPU()`. By providing `GPU()` as the `architecture` argument; we can construct the grid on GPU:. ```julia; julia> grid = RectilinearGrid(GPU(), size = (32, 64, 256), extent = (128, 256, 512)); 32√ó64√ó256 RectilinearGri",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/legacy_grids.md:90,variab,variable,90,docs/src/model_setup/legacy_grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/legacy_grids.md,1,['variab'],['variable']
Modifiability,"# Oceananigans.jl. *üåä Fast and friendly fluid dynamics on CPUs and GPUs.*. Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic; and hydrostatic Boussinesq equations on CPUs and GPUs.; It runs on GPUs (wow, fast!), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans is written in Julia by the [Climate Modeling Alliance](https://clima.caltech.edu); and heroic external collaborators. ## Quick install. Oceananigans is a [registered Julia package](https://julialang.org/packages/). So to install it,. 1. [Download Julia](https://julialang.org/downloads/). 2. Launch Julia and type. ```julia; julia> using Pkg. julia> Pkg.add(""Oceananigans""); ```. !!! compat ""Julia 1.9 is required""; Oceananigans requires Julia 1.9 or later. If you're [new to Julia](https://docs.julialang.org/en/v1/manual/getting-started/) and its [wonderful `Pkg` manager](https://docs.julialang.org/en/v1/stdlib/Pkg/), the [Oceananigans wiki](https://github.com/CliMA/Oceananigans.jl/wiki) provides [more detailed installation instructions](https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans). ## The Oceananigans ""knowledge base"". It's _deep_ and includes:. * This documentation, which provides; * example Oceananigans scripts,; * tutorials that describe key Oceananigans objects and functions,; * explanations of Oceananigans finite-volume-based numerical methods,; * details of the dynamical equations solved by Oceananigans models, and; * a library documenting all user-facing Oceananigans objects and functions.; * [Discussions on the Oceananigans github](https://github.com/CliMA/Oceananigans.jl/discussions), covering topics like; * [""Computational science""](https://github.com/CliMA/Oceananigans.jl/discussions/categories/computational-science), or how to science and set up numeric",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md:109,flexible,flexible,109,docs/src/index.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md,2,['flexible'],['flexible']
Modifiability,"# Shallow water model. The [`ShallowWaterModel`](@ref) simulates the shallow water dynamics for a fluid of constant density; but with varying fluid depth ``h(x, y, t)`` and whose velocity only varies in the horizontal,; ``\boldsymbol{u}(x, y, t) = u(x, y, t) \boldsymbol{\hat x} + v(x, y, t) \boldsymbol{\hat y}``. [`ShallowWaterModel`](@ref) allows users to prescribe the shallow water dynamics using two different formulations:; `VectorInvariantFormulation()` and `ConservativeFormulation()`. The `VectorInvariantFormulation` uses the horizontal velocity ``\boldsymbol{u}`` and the total depth of the fluid, ``h``,; as the dynamical variables. Furthermore, the advective terms are rewritten via the vector identity:; ```math; \boldsymbol{u} \boldsymbol{\cdot} \boldsymbol{\nabla} \boldsymbol{u} = (\boldsymbol{\nabla} \times \boldsymbol{u}) \times \boldsymbol{u} + \boldsymbol{\nabla} \left( \frac1{2} \boldsymbol{u} \boldsymbol{\cdot} \boldsymbol{u} \right ) \, .; ```; Thus, the shallow water dynamics in vector-invariant form become:. ```math; \begin{align}; \partial_t \boldsymbol{u} + (\zeta \boldsymbol{\hat z} + \boldsymbol{f}) \times\boldsymbol{u} & = ; - \boldsymbol{\nabla} \left [ g (h +b) + \frac12 \boldsymbol{u} \cdot \boldsymbol{u} \right ] \, , \\; \partial_t h + \boldsymbol{\nabla} \boldsymbol{\cdot} (\boldsymbol{u} h) & = 0 \, ,; \end{align}; ```; where ``\zeta(x, y, t) = \partial_x v - \partial_y u`` is the vertical component of the relative vorticity. The elevation of the bottom bathymetry, measured with respect to the free-surface at rest, is ``b(x, y)``.; The free-surface elevation ``\eta`` is then:. ```math; \eta(x, y, t) = h(x, y, t) + b(x, y) \, .; ```. The `ConservativeFormulation()` uses the volume transport along each direction ``\boldsymbol{u} h = (u h, v h)`` and the total; depth of the fluid ``h`` as the dynamical variables. The shallow water dynamics in conservative form is:; ```math; \begin{align}; \partial_t (\boldsymbol{u} h) + \boldsymbol{\nabla} \b",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/shallow_water_model.md:635,variab,variables,635,docs/src/physics/shallow_water_model.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/shallow_water_model.md,1,['variab'],['variables']
Modifiability,"# Spatial operators. To calculate the various terms and perform the time-stepping, discrete difference and interpolation ; operators must be designed from which all the terms, such as momentum advection and Laplacian ; diffusion, may be constructed. Much of the material in this section is derived from [Marshall97FV](@citet). ## Differences. Difference operators act as the discrete form of the derivative operator. Care must be taken ; when calculating differences on a staggered grid. For example, the the difference of a cell-centered ; variable such as temperature ``T`` lies on the faces in the direction of the difference, and ; vice versa. In principle, there are three difference operators, one for each direction; ```math; \delta_x f = f_E - f_W , \quad; \delta_y f = f_N - f_S , \quad; \delta_z f = f_T - f_B ,; ```; where the ``E`` and ``W`` subscripts indicate that the value is evaluated the eastern or western ; wall of the cell, ``N`` and ``S`` indicate the northern and southern walls, and ``T`` and ``B`` ; indicate the top and bottom walls. Additionally, two ``\delta`` operators must be defined for each direction to account for the ; staggered nature of the grid. One for taking the difference of a cell-centered variable and ; projecting it onto the cell faces; ```math; \begin{align}; \delta_x^{faa} f_{i, j, k} &= f_{i, j, k} - f_{i-1, j, k} \, , \\; \delta_y^{afa} f_{i, j, k} &= f_{i, j, k} - f_{i, j-1, k} \, , \\; \delta_z^{aaf} f_{i, j, k} &= f_{i, j, k} - f_{i, j, k-1} \, , ; \end{align}; ```; and another for taking the difference of a face-centered variable and projecting it onto the; cell centers; ```math; \begin{align}; \delta_x^{caa} f_{i, j, k} &= f_{i+1, j, k} - f_{i, j, k} \, , \\; \delta_y^{aca} f_{i, j, k} &= f_{i, j+1, k} - f_{i, j, k} \, , \\; \delta_z^{aac} f_{i, j, k} &= f_{i, j, k+1} - f_{i, j, k} \, .; \end{align}; ```. ## Interpolation. In order to add or multiply variables that are defined at different points they are interpolated. ; In our cas",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/spatial_operators.md:541,variab,variable,541,docs/src/numerical_implementation/spatial_operators.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/spatial_operators.md,1,['variab'],['variable']
Modifiability,"# Staggered grid. Velocities ``u``, ``v``, and ``w`` are defined on the faces of the cells, which are coincident with three orthogonal; coordinate axes (the Cartesian axes in the case of Oceananigans). Pressure ``p`` and tracers ``c`` are stored at; the cell centers as cell averages. See schematic below of the different control; volumes. Other quantities may be defined at other locations. For example, vorticity ``\boldsymbol{\omega} = \boldsymbol{\nabla} \times \boldsymbol{v}``; is defined at the cell edges.[^1]. [^1]: In 2D it would more correct to say the cell corners. In 3D, variables like vorticity lie at the same vertical; levels as the cell-centered variables and so they really lie at the cell edges. ![Schematic of control volumes](../numerical_implementation/assets/staggered_grid.png); *A schematic of `Oceananigans.jl` finite volumes for a two-dimensional staggered grid in ``(x, z)``.; Tracers ``c`` and pressure ``p`` are defined at the center of the control volume. The ``u`` control volumes are ; centered on the left and right edges of the pressure control volume while the ``w`` control volumes are centered ; on the top and bottom edges of the pressure control volumes. The indexing convention places the ``i^{\rm{th}}`` ; ``u``-node on cell ``x``-faces to the left of the ``i`` tracer point at cell centers.*. This staggered arrangement of variables is more complicated than the collocated grid arrangement but is greatly; beneficial as it avoids the odd-even decoupling between the pressure and velocity if they are stored at the same; positions. ¬ß6.1 of [Patankar80](@citet) discusses this problem in the presence of a zigzag pressure field: on a 1D; collocated grid the velocity at the point ``i`` is influenced by the pressure at points ``i-1`` and ``i+1``, and a zigzag; pressure field will be felt as a uniform pressure, which is obviously wrong and would reduce the accuracy of the; solution. The pressure is effectively taken from a coarser grid than what is actuall",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/staggered_grid.md:585,variab,variables,585,docs/src/appendix/staggered_grid.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/staggered_grid.md,2,['variab'],['variables']
Modifiability,"# Tracers. The tracers to be advected around can be specified via a list of symbols. By default the model doesn't evolve any; tracers. ```@meta; DocTestSetup = quote; using Oceananigans; end; ```. ```jldoctest tracers; julia> grid = RectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1));. julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ‚îú‚îÄ‚îÄ grid: 16√ó16√ó16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ timestepper: RungeKutta3TimeStepper; ‚îú‚îÄ‚îÄ advection scheme: Centered reconstruction order 2; ‚îú‚îÄ‚îÄ tracers: (); ‚îú‚îÄ‚îÄ closure: Nothing; ‚îú‚îÄ‚îÄ buoyancy: Nothing; ‚îî‚îÄ‚îÄ coriolis: Nothing; ```. But tracers can be added with the `tracers` keyword.; For example, to add conservative temperature `T` and absolute salinity `S`:. ```jldoctest tracers; julia> model = NonhydrostaticModel(; grid, tracers=(:T, :S)); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ‚îú‚îÄ‚îÄ grid: 16√ó16√ó16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ timestepper: RungeKutta3TimeStepper; ‚îú‚îÄ‚îÄ advection scheme: Centered reconstruction order 2; ‚îú‚îÄ‚îÄ tracers: (T, S); ‚îú‚îÄ‚îÄ closure: Nothing; ‚îú‚îÄ‚îÄ buoyancy: Nothing; ‚îî‚îÄ‚îÄ coriolis: Nothing; ```. whose fields can be accessed via `model.tracers.T` and `model.tracers.S`. ```jldoctest tracers; julia> model.tracers.T; 16√ó16√ó16 Field{Center, Center, Center} on RectilinearGrid on CPU; ‚îú‚îÄ‚îÄ grid: 16√ó16√ó16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ boundary conditions: FieldBoundaryConditions; ‚îÇ ‚îî‚îÄ‚îÄ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; ‚îî‚îÄ‚îÄ data: 22√ó22√ó22 OffsetArray(::Array{Float64, 3}, -2:19, -2:19, -2:19) with eltype Float64 with indices -2:19√ó-2:19√ó-2:19; ‚îî‚îÄ‚îÄ max=0.0, min=0.0, mean=0.0. julia> model.tracers.S; 16√ó16√ó16 Field{Center, Center, Center} on RectilinearGrid on CPU; ‚îú‚îÄ‚îÄ grid: 16√ó16√ó16 Rectilin",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/tracers.md:114,evolve,evolve,114,docs/src/model_setup/tracers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/tracers.md,1,['evolve'],['evolve']
Modifiability,"# [Simulation tips](@id simulation_tips). Oceananigans attempts to optimize computations as much as possible ""behind the scenes"".; Yet Oceananigans' flexibility places some responsibility on users to ensure high performance simulations,; especially for complex setups with user-defined forcing functions, boundary condition functions, and diagnostics.; Furthermore, in case of more complex GPU runs, some details could; sometimes prevent your simulation from running altogether. While Julia knowledge is obviously; desirable here, a user that is unfamiliar with Julia can get away with efficient simulations by; learning a few rules of thumb. It is nonetheless recommended that users go through Julia's; [performance tips](https://docs.julialang.org/en/v1/manual/performance-tips/), which contains more; in-depth explanations of some of the aspects discussed here. ## General (CPU/GPU) simulation tips. ### Avoid global variables whenever possible. In general using a [global; variable](https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Global-Scope) (which can be; loosely defined as a variable defined in the main script) inside functions slows down the code. One; way to circumvent this is to always [use local variables or pass them as arguments to; functions](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). This; helps the compiler optimize the code. Another way around this is to [define global variables as constants whenever; possible](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). One; thing to keep in mind when doing this is that when a `const` is defined, its value can't be changed; until you restart the Julia session. So this latter approach is good for production-ready code, but; may be undesirable in the early stages of development while you still have to change the parameters; of the simulation for exploration. It is especially important to avoid global variables in functions that are meant t",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:920,variab,variables,920,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,2,['variab'],"['variable', 'variables']"
Modifiability,"# [Time-stepping and the fractional step method](@id time_stepping). With the [pressure decomposition](@ref pressure_decomposition) as discussed, the momentum evolves via:. ```math; \begin{equation}; \label{eq:momentum-time-derivative}; \partial_t \boldsymbol{v} = \boldsymbol{G}_{\boldsymbol{v}} - \boldsymbol{\nabla} p_{\rm{non}} \, ,; \end{equation}; ```. where, e.g., for the non-hydrostatic model (ignoring background velocities and surface-wave effects). ```math; \boldsymbol{G}_{\boldsymbol{v}} \equiv - \boldsymbol{\nabla}_h p_{\rm{hyd}} ; - \left ( \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} \right ) \boldsymbol{v} ; - \boldsymbol{f} \times \boldsymbol{v} ; + \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{\tau} ; + \boldsymbol{F}_{\boldsymbol{v}}; ```. collects all terms on the right side of the momentum equation \eqref{eq:momentum-time-derivative}, *except* the ; contribution of non-hydrostatic pressure ``\boldsymbol{\nabla} p_{\rm{non}}``. The time-integral of the momentum equation \eqref{eq:momentum-time-derivative} from time step ``n`` at ``t = t_n``; to time step ``n+1`` at ``t_{n+1}`` is:; ```math; \begin{equation}; \label{eq:momentum-time-integral}; \boldsymbol{v}^{n+1} - \boldsymbol{v}^n = ; \int_{t_n}^{t_{n+1}} \Big [ - \boldsymbol{\nabla} p_{\rm{non}} + \boldsymbol{G}_{\boldsymbol{v}} \Big ] \, \mathrm{d} t \, ,; \end{equation}; ```; where the superscript ``n`` and ``n+1`` imply evaluation at ``t_n`` and ``t_{n+1}``, such that ; ``\boldsymbol{v}^n \equiv \boldsymbol{v}(t=t_n)``. The crux of the fractional step method is ; to treat the pressure term ``\boldsymbol{\nabla} p_{\rm{non}}`` implicitly using the approximation; ```math; \begin{align}; \label{eq:pnon_implicit}; \int_{t_n}^{t_{n+1}} \boldsymbol{\nabla} p_{\rm{non}} \, \mathrm{d} t \approx; \Delta t \boldsymbol{\nabla} p_{\rm{non}}^{n+1} \, ,; \end{align}; ```; while treating the rest of the terms on the right hand side of \eqref{eq:momentum-time-integral} ; explicitly. The implicit t",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/time_stepping.md:159,evolve,evolves,159,docs/src/numerical_implementation/time_stepping.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/time_stepping.md,1,['evolve'],['evolves']
Modifiability,"# [Turbulence closures](@id numerical_closures). To truly simulate and resolve turbulence at high Reynolds number (so basically all interesting flows) would require; you resolve all motions down to the [Kolmogorov41](@citet) length scale ``\eta = (\nu^3 / \varepsilon)^{1/4}`` where; ``\nu`` is the kinematic viscosity and ``\varepsilon`` the average rate of dissipation of turbulence kinetic energy per; unit mass. As pointed out way back by [Corrsin61](@citet), to run a simulation on a horizontal domain about 10 times the size of an; ""average eddy"" with 100 vertical levels and where the grid spacing is given by ``\eta`` would require the computer to; store on the order of ``10^{14}`` variables.[^1] This is still impractical today, although may be within; reach in less than a decade. He ends by suggesting the use of an analog rather digital computer---a tank of water. [^1]: And even then, ``\eta`` gives the *maximum* allowable grid spacing. There is significant flow structure; smaller than ``\eta``. To have any hope of simulating high Reynolds number flows we need some way of resolving the sub-grid scale motions.[^2]. [^2]: In reality there is no need to resolve all motions down to the Kolmogorov length scale to achieve; acceptable accuracy. Perhaps good results can be achieved if 80\% of the kinetic energy is resolved; (¬ß13) [Pope00](@cite). ## Reynolds-averaged Navier‚ÄìStokes equations. Following [Reynolds1895](@citet), we can decompose flow variables such as velocity ``\boldsymbol{v}`` into the mean component; ``\overline{\boldsymbol{v}}`` and the fluctuating component ``\boldsymbol{v}^\prime`` so that ``\boldsymbol{v} = \overline{\boldsymbol{v}} + \boldsymbol{v}^\prime``; [see ¬ß4 of [Pope00](@citet) for a modern discussion]. Expressing the Navier-Stokes equations in tensor notation; ```math; \begin{align}; \partial_i v_i &= 0 \, ,\\; \partial_t v_i + v_j \partial_j v_i &= f_i - \alpha\partial_i p + \nu \partial_j \partial_j v_i \, ,; \end{align}; ```; where ``\alpha ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md:691,variab,variables,691,docs/src/numerical_implementation/turbulence_closures.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md,1,['variab'],['variables']
Modifiability,", .; \end{equation}; ```; In the definitions of the eddy viscosity and eddy diffusivity predictor, ``C`` and ``C_b`` are; user-specified model constants, ``\Delta_f`` is a ""filter width"" associated with the finite volume; grid spacing, and the hat decorators on partial derivatives, velocities, and the Kronecker; delta ``\hat \delta_{i3}`` are defined such that; ```math; \hat \partial_i \equiv \Delta_i \partial_i, \qquad; \hat{v}_i(x, t) \equiv \frac{v_i(x, t)}{\Delta_i}, \quad \text{and} \quad; \hat{\delta}_{i3} \equiv \frac{\delta_{i3}}{\Delta_3} \, .; ```; A velocity gradient, for example, is therefore; ``\hat{\partial}_i \hat{v}_j(x, t) = \frac{\Delta_i}{\Delta_j} \partial_i v_j(x, t)``,; while the normalized strain tensor is; ```math; \hat{\Sigma}_{ij} =; \frac{1}{2} \left[ \hat{\partial}_i \hat{v}_j(x, t) + \hat{\partial}_j \hat{v}_i(x, t) \right] \, .; ```; The filter width ``\Delta_f`` in that appears in the viscosity and diffusivity predictors; is taken as the square root of the harmonic mean of the squares of the filter widths in; each direction:; ```math; \frac{1}{\Delta_f^2} = \frac{1}{3} \left( \frac{1}{\Delta x^2}; + \frac{1}{\Delta y^2}; + \frac{1}{\Delta z^2} \right) \, .; ```; The constant ``C_b`` permits the ""buoyancy modification"" term it multiplies to be omitted; from a calculation. By default we use the model constants ``C = 1/12`` and ``C_b = 0``. ## Convective adjustment vertical diffusivity. This closure aims to model the enhanced mixing that occurs due to convection.; At every point and for every time instance, the closure diagnoses the gravitational stability of the fluid and; applies the vertical diffusivities (i) `background_ŒΩz` to `u, v` and `background_Œ∫z` to all tracers if the fluid; is gravitationally neutral or stable with ``‚àÇb/‚àÇz ‚â• 0``, or (ii) `convective_ŒΩz` and `convective_Œ∫z` if ``‚àÇb/‚àÇz < 0``. This closure is a plausible model for convection if `convective_Œ∫z` ``\gg`` `background_Œ∫z` and `convective_ŒΩz` ``\gg`` `background_ŒΩz`.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/turbulence_closures.md:7906,enhance,enhanced,7906,docs/src/physics/turbulence_closures.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/turbulence_closures.md,1,['enhance'],['enhanced']
Modifiability,", if can be difficult to just view a `CuArray` since Julia needs to access ; its elements to do that. Consider the example below:. ```julia; julia> using Oceananigans, Adapt. julia> grid = RectilinearGrid(GPU(); size=(1, 1, 1), extent=(1, 1, 1), halo=(1, 1, 1)); 1√ó1√ó1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 1.0) regularly spaced with Œîx=1.0; ‚îú‚îÄ‚îÄ Periodic y ‚àà [0.0, 1.0) regularly spaced with Œîy=1.0; ‚îî‚îÄ‚îÄ Bounded z ‚àà [-1.0, 0.0] regularly spaced with Œîz=1.0. julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ‚îú‚îÄ‚îÄ grid: 1√ó1√ó1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ timestepper: RungeKutta3TimeStepper; ‚îú‚îÄ‚îÄ tracers: (); ‚îú‚îÄ‚îÄ closure: Nothing; ‚îú‚îÄ‚îÄ buoyancy: Nothing; ‚îî‚îÄ‚îÄ coriolis: Nothing. julia> typeof(model.velocities.u.data); OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}. julia> adapt(Array, model.velocities.u.data); 3√ó3√ó3 OffsetArray(::Array{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2√ó0:2√ó0:2:; [:, :, 0] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 1] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0; ```. Notice that to view the `CuArray` that stores values for `u` we first need to transform; it into a regular `Array` using `Adapt.adapt`. If we naively try to view the `CuArray`; without that step we get an error:. ```julia; julia> model.velocities.u.data; 3√ó3√ó3 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2√ó0:2√ó0:2:; [:, :, 0] =; Error showing value of type OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}:; ERROR: Scalar indexing is disallowed.; ```. Here `CUDA.jl` throws an error because scalar `getindex` is not `allowed`. There are ways to; overcome this limitation and allow scalar indexing (",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:12389,adapt,adapt,12389,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['adapt'],['adapt']
Modifiability,"0, 64.0) regularly spaced with Œîx=4.0; ‚îú‚îÄ‚îÄ Periodic y ‚àà [0.0, 32.0) regularly spaced with Œîy=4.0; ‚îî‚îÄ‚îÄ Bounded z ‚àà [0.0, 8.0] regularly spaced with Œîz=2.0; ```. This simple grid. * Has a domain that's ""periodic"" in ``x, y``, but bounded in ``z``.; * Has `16` cells in `x`, `8` cells in `y`, and `4` cells in `z`. That means there are ``16 \times 8 \times 4 = 512`` cells in all.; * Has an `x` dimension that spans from `x=0`, to `x=64`. And `y` spans `y=0` to `y=32`, and `z` spans `z=0` to `z=8`.; * Has cells that are all the same size, dividing the box in 512 that each has dimension ``4 \times 4 \times 2``.; Note that length units are whatever is used to construct the grid, so it's up to the user to make sure that all inputs use consistent units. In building our first grid, we did not specify whether it should be constructed on the [`CPU`](@ref)` or [`GPU`](@ref).; As a result, the grid was constructed by default on the CPU.; Next we build a grid on the _GPU_ that's two-dimensional in ``x, z`` and has variably-spaced cell interfaces in the `z`-direction,. ```jldoctest grids_gpu; architecture = GPU(); z_faces = [0, 1, 3, 6, 10]. grid = RectilinearGrid(architecture,; topology = (Periodic, Flat, Bounded),; size = (10, 4),; x = (0, 20),; z = z_faces). # output; 10√ó1√ó4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on GPU with 3√ó0√ó3 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 20.0) regularly spaced with Œîx=2.0; ‚îú‚îÄ‚îÄ Flat y; ‚îî‚îÄ‚îÄ Bounded z ‚àà [0.0, 10.0] variably spaced with min(Œîz)=1.0, max(Œîz)=4.0; ```. !!! note ""GPU architecture requires a CUDA-enabled device""; To run the above example and create a grid on the GPU, an Nvidia GPU has to be available; and [`CUDA.jl`](https://cuda.juliagpu.org/stable/) must be working). For more information; see the [`CUDA.jl` documentation](https://cuda.juliagpu.org/stable/). The ``y``-dimension is ""missing"" because it's marked `Flat` in `topology = (Periodic, Flat, Bounded)`.; So nothing varies in ``y``: `y`-derivatives are 0.; Also, the keyword argument (",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:2166,variab,variably-spaced,2166,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['variab'],['variably-spaced']
Modifiability,"2Fjuliapkgstats.com%2Fapi%2Fv1%2Ftotal_downloads%2FOceananigans&query=total_requests&&label=Total%20Downloads&style=flat-square"">; </a>; </p>. <!-- CI/CD badges -->; <p align=""center"">; <a href=""https://buildkite.com/clima/oceananigans"">; <img alt=""Buildkite CPU+GPU build status"" src=""https://img.shields.io/buildkite/4d921fc17b95341ea5477fb62df0e6d9364b61b154e050a123/main?logo=buildkite&label=Buildkite%20CPU%2BGPU&style=flat-square"">; </a>; <a href=""https://hub.docker.com/r/aliramadhan/oceananigans"">; <img alt=""Docker build status"" src=""https://img.shields.io/docker/cloud/build/aliramadhan/oceananigans?label=Docker&logo=docker&logoColor=white&style=flat-square"">; </a>; </p>. Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic; and hydrostatic Boussinesq equations on CPUs and GPUs.; It runs on GPUs (wow, [fast!](http://arxiv.org/abs/2309.06662)), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans.jl is developed by the [Climate Modeling Alliance](https://clima.caltech.edu) and heroic external collaborators. ## Contents. - [Contents](#contents); - [Installation instructions](#installation-instructions); - [Running your first model](#running-your-first-model); - [The Oceananigans knowledge base](#the-oceananigans-knowledge-base); - [Citing](#citing); - [Contributing](#contributing); - [Movies](#movies); - [Deep convection](#deep-convection); - [Free convection](#free-convection); - [Winds blowing over the ocean](#winds-blowing-over-the-ocean); - [Free convection with wind stress](#free-convection-with-wind-stress); - [Performance benchmarks](#performance-benchmarks). ## Installation instructions. Oceananigans is a [registered Julia package](https://julialang.org/packages/). So to install it,. 1. [Download Julia](https://julialang.org/downloads/) (version 1.9 or later). 2. Laun",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:3616,flexible,flexible,3616,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['flexible'],['flexible']
Modifiability,"860/v2). 1. Whitley V. and Wenegrat, J. O. (2024) [Breaking internal waves on sloping topography: connecting parcel displacements to overturn size, interior-boundary exchanges, and mixing](https://doi.org/10.31223/X5PM5Q), _Earth Arxiv_. DOI: [10.31223/X5PM5Q](https://doi.org/10.31223/X5PM5Q). 1. Chen S., Strong-Wright J., and Taylor, J. R. (2024) [Modeling carbon dioxide removal via sinking of particulate organic carbon from macroalgae cultivation](https://doi.org/10.3389/fmars.2024.1359614), _Frontiers in Marine Science_, **11**, 1359614. DOI: [10.3389/fmars.2024.1359614](https://doi.org/10.3389/fmars.2024.1359614). 1. Gupta, M., G√ºrcan, E., and Thompson, A. F. (2024). [Eddy-induced dispersion of sea ice floes at the marginal ice zone](https://doi.org/10.1029/2023GL105656), _Geophysical Research Letters_, **51**, e2023GL105656. DOI: [10.1029/2023GL105656](https://doi.org/10.1029/2023GL105656). 1. Wagner, G. L., Pizzo, N. E., Lenain, L., and Veron, F. (2023) [Transition to turbulence in wind-drift layers](https://doi.org/10.1017/jfm.2023.920), _Journal of Fluid Mechanics_, **976**, A8. DOI: [10.1017/jfm.2023.920](https://doi.org/10.1017/jfm.2023.920). 1. Jim√©nez-Urias, M. A. and Haine T. W. N. (2023) [On the non-self-adjoint and multiscale character of passive scalar mixing under laminar advection](https://doi.org/10.1017/jfm.2023.748), _Journal of Fluid Mechanics_, **973**, A44. DOI: [10.1017/jfm.2023.748](https://doi.org/10.1017/jfm.2023.748). 1. Strong-Wright, J, Chen, S., Constantinou, N. C., Silvestri, S., Wagner, G. L., and Taylor, J. R. (2023). [OceanBioME.jl: A flexible environment for modelling the coupled interactions between ocean biogeochemistry and physics](https://doi.org/10.21105/joss.05669), _Journal of Open Source Software_, **90(8)**, 5669. DOI: [10.21105/joss.05669](https://doi.org/10.21105/joss.05669). 1. Ramadhan, A., Marshall, J. C., Souza, A. N., Lee, X. K., Piterbarg, U., Hillier, A., Wagner, G. L., Rackauckas, C., Hill, C., Campin, J.-M., a",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md:8144,layers,layers,8144,docs/src/index.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md,1,['layers'],['layers']
Modifiability,"; & = \div{u \boldsymbol{v}} \, ,; \end{align}; ```; which can then be discretized similarly to the flux divergence operator, however, they must ; be discretized differently for each direction. For example, the ``x``-momentum advection operator is discretized as; ```math; \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} u; = \frac{1}{\overline{V}^x} \left[; \delta_x^{faa} \left( \overline{A_x u}^{caa} \overline{u}^{caa} \right); + \delta_y^{afa} \left( \overline{A_y v}^{aca} \overline{u}^{aca} \right); + \delta_z^{aaf} \left( \overline{A_z w}^{aac} \overline{u}^{aac} \right); \right] \, ,; ```; where ``\overline{V}^x`` is the average of the volumes of the cells on either side of the face ; in question. Calculating ``\partial_x (uu)`` can be performed by interpolating ``A_x u`` and ; ``u`` onto the cell centers then multiplying them and differencing them back onto the faces. ; However, in the case of the the two other terms, ``\partial_y (vu)`` and ``\partial_z (wu)``, ; the two variables must be interpolated onto the cell edges to be multiplied then differenced ; back onto the cell faces. ## Discretization of isotropic diffusion operators. An isotropic viscosity operator acting on vertical momentum is discretized via; ```math; \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \nu \boldsymbol{\nabla} w \right ); = \frac{1}{V} \left[; \delta_x^{faa} ( \nu \overline{A_x}^{caa} \partial_x^{caa} w ); + \delta_y^{afa} ( \nu \overline{A_y}^{aca} \partial_y^{aca} w ); + \delta_z^{aaf} ( \nu \overline{A_z}^{aac} \partial_z^{aac} w ); \right ] \, ,; ```; where ``\nu`` is the kinematic viscosity. An isotropic diffusion operator acting on a tracer ``c``, on the other hand, is discretized via; ```math; \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \kappa \boldsymbol{\nabla} c \right ); = \frac{1}{V} \left[ \vphantom{\overline{A_x}^{caa}}; \delta_x^{caa} ( \kappa A_x \partial_x^{faa} c ); + \delta_y^{aca} ( \kappa A_y \partial_y^{afa} c ); + \delta_z^{aac} ( \kappa A_z \partial",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/spatial_operators.md:5839,variab,variables,5839,docs/src/numerical_implementation/spatial_operators.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/spatial_operators.md,1,['variab'],['variables']
Modifiability,"; in GPU simulations by following a few simple principles. ### Global variables that need to be used in GPU computations need to be defined as constants or passed as parameters. Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation; will crash. This includes any variables that are referenced as global variables in functions; used for forcing of boundary conditions. For example,. ```julia; T‚ÇÄ = 20 # ·µíC; surface_temperature(x, y, t) = T‚ÇÄ * sin(2œÄ / 86400 * t); T_bcs = FieldBoundaryConditions(bottom = GradientBoundaryCondition(surface_temperature)); ```. will throw an error if run on the GPU (and will run more slowly than it should on the CPU).; Replacing the first line above with. ```julia; const T‚ÇÄ = 20 # ·µíC; ```. fixes the issue by indicating to the compiler that `T‚ÇÄ` will not change. Note that the _literal_ `2œÄ / 86400` is not an issue -- it's only the; _variable_ `T‚ÇÄ` that must be declared `const`. Alternatively, we can pass the variable as a parameter to `GradientBoundaryCondition`. To do that; we need to pass a named tuple as `parameter` keyword argument:. ```julia; T‚ÇÄ = 20 # ·µíC; surface_temperature(x, y, t, p) = p.T‚ÇÄ * sin(2œÄ / 86400 * t); T_bcs = FieldBoundaryConditions(bottom = GradientBoundaryCondition(surface_temperature, parameters=(; T‚ÇÄ))); ```. ### Complex diagnostics using computed `Field`s may not work on GPUs. `Field`s are the most convenient way to calculate diagnostics for your simulation. They will; always work on CPUs, but when their complexity is high (in terms of number of abstract operations); the compiler can't translate them into GPU code and they fail for GPU runs. (This limitation is summarized ; in [this Github issue](https://github.com/CliMA/Oceananigans.jl/issues/1886) and contributions are welcome.); For example, in the example below, calculating `u¬≤` works in both CPUs and GPUs, but calculating ; `Œµ` will not compile on GPUs when we call the command `compute!`:. ```julia; using Oceananigans; g",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:4933,variab,variable,4933,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['variab'],['variable']
Modifiability,"= f_{i, j+1, k} - f_{i, j, k} \, , \\; \delta_z^{aac} f_{i, j, k} &= f_{i, j, k+1} - f_{i, j, k} \, .; \end{align}; ```. ## Interpolation. In order to add or multiply variables that are defined at different points they are interpolated. ; In our case, linear interpolation or averaging is employed. Once again, there are two averaging ; operators, one for each direction,; ```math; \begin{equation}; \overline{f}^x = \frac{f_E + f_W}{2} \, , \quad; \overline{f}^y = \frac{f_N + f_S}{2} \, , \quad; \overline{f}^z = \frac{f_T + f_B}{2} \, .; \end{equation}; ```. Additionally, three averaging operators must be defined for each direction. One for taking the ; average of a cell-centered variable and projecting it onto the cell faces; ```math; \begin{align}; \overline{f_{i, j, k}}^{faa} = \frac{f_{i, j, k} + f_{i-1, j, k}}{2} \, , \\; \overline{f_{i, j, k}}^{afa} = \frac{f_{i, j, k} + f_{i, j-1, k}}{2} \, , \\; \overline{f_{i, j, k}}^{aaf} = \frac{f_{i, j, k} + f_{i, j, k-1}}{2} \, ,; \end{align}; ```; and another for taking the average of a face-centered variable and projecting it onto the cell centers; ```math; \begin{align}; \overline{f_{i, j, k}}^{caa} = \frac{f_{i+1, j, k} + f_{i, j, k}}{2} \, , \\; \overline{f_{i, j, k}}^{aca} = \frac{f_{i, j+1, k} + f_{i, j, k}}{2} \, , \\; \overline{f_{i, j, k}}^{aac} = \frac{f_{i, j, k+1} + f_{i, j, k}}{2} \, .; \end{align}; ```. ## Divergence and flux divergence. The divergence of the flux of a cell-centered quantity over the cell can be calculated as; ```math; \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{f}; = \frac{1}{V} \left[ \delta_x^{faa} (A_x f_x); + \delta_y^{afa} (A_y f_y); + \delta_z^{aaf} (A_z f_z) \right] \, ,; ```; where ``\boldsymbol{f} = (f_x, f_y, f_z)`` is the flux with components defined normal to the ; faces, and ``V`` is the volume of the cell. The presence of a solid boundary is indicated by ; setting the appropriate flux normal to the boundary to zero. A similar divergence operator can be defined for a face",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/spatial_operators.md:2438,variab,variable,2438,docs/src/numerical_implementation/spatial_operators.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/spatial_operators.md,2,['variab'],['variable']
Modifiability,"NO advection scheme](https://en.wikipedia.org/wiki/WENO_methods).; It's quite similar to the [two-dimensional turbulence example](https://clima.github.io/OceananigansDocumentation/stable/generated/two_dimensional_turbulence/). ## Visualization. They say that a [Makie](https://makie.juliaplots.org/stable/) visualization is worth a thousand Unicode characters, so let's plot vorticity,. ```@example cpu; using CairoMakie. u, v, w = model.velocities; Œ∂ = Field(‚àÇx(v) - ‚àÇy(u)); compute!(Œ∂). heatmap(Œ∂, axis=(; aspect=1)); ```. A few more time-steps, and it's starting to get a little diffuse!. ```@example cpu; simulation.stop_iteration += 400; run!(simulation). compute!(Œ∂); heatmap(Œ∂, axis=(; aspect=1)); ```. ## They always cheat with too-simple ""quick"" starts. Fine, we'll re-run this code on the GPU. But we're a little greedy, so we'll also; crank up the resolution, throw in a `TimeStepWizard` to update `simulation.Œît` adaptively,; and add a passive tracer initially concentrated in the center of the domain; which will make for an even prettier figure of the final state:. ```@setup gpu; using CairoMakie; CairoMakie.activate!(type = ""png""); ```. ```@example gpu; using Oceananigans; using CairoMakie. grid = RectilinearGrid(GPU(),; size = (1024, 1024),; x = (-œÄ, œÄ),; y = (-œÄ, œÄ),; topology = (Periodic, Periodic, Flat)). model = NonhydrostaticModel(; grid, advection=WENO(), tracers=:c). Œ¥ = 0.5; c·µ¢(x, y) = exp(-(x^2 + y^2) / 2Œ¥^2); œµ(x, y) = 2rand() - 1; set!(model, u=œµ, v=œµ, c=c·µ¢). simulation = Simulation(model; Œît=1e-3, stop_time=10); conjure_time_step_wizard!(simulation, cfl=0.2, IterationInterval(10)); run!(simulation). u, v, w = model.velocities; Œ∂ = Field(‚àÇx(v) - ‚àÇy(u)); compute!(Œ∂). fig = Figure(size=(1200, 600)); axŒ∂ = Axis(fig[1, 1], aspect=1, title=""vorticity""); axc = Axis(fig[1, 2], aspect=1, title=""tracer""); heatmap!(axŒ∂, Œ∂, colormap=:balance); heatmap!(axc, model.tracers.c); current_figure(); ```. See how we did that? We passed the positional argument `GPU()` to `Re",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/quick_start.md:1539,adapt,adaptively,1539,docs/src/quick_start.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/quick_start.md,1,['adapt'],['adaptively']
Modifiability,"Oceananigans repository](https://github.com/CLiMA/Oceananigans.jl) by; clicking the ""Fork"" button. * Clone your fork of the Oceananigans repository (in terminal on Mac/Linux or git shell/; GUI on Windows) in the location you'd like to keep it.; ```; git clone https://github.com/your-user-name/Oceananigans.jl.git; ```. * Navigate to that folder in the terminal or in Anaconda Prompt if you're on Windows. * Connect your repository to the upstream (main project).; ```; git remote add oceananigans https://github.com/CLiMA/Oceananigans.jl.git; ```. * Create the development environment by opening Julia via `julia --project` then; typing in `] instantiate`. This will install all the dependencies in the Project.toml; file. Your development environment is now ready!. * You can test to make sure Oceananigans works by typing in `] test`. (This is equivalent to; `using Pkg; Pkg.test()`.) Doing so will run all the tests (and this can take a while).; Alternatively, you can run only one test script file by providing its name as an environment; variable. For example, to run the tests only from the `test_coriolis.jl` file we call:. ```; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; ```. ## Pull Requests. We follow the [ColPrac guide](https://github.com/SciML/ColPrac) for collaborative practices.; We ask that new contributors read that guide before submitting a pull request. Changes and contributions should be made via GitHub pull requests against the ``main`` branch. When you're done making changes, commit the changes you made. Chris Beams has written a ; [guide](https://chris.beams.io/posts/git-commit/) on how to write good commit messages. When you think your changes are ready to be merged into the main repository, push to your fork; and [submit a pull request](https://github.com/CLiMA/Oceananigans.jl/compare/). **Working on your first Pull Request?** You can learn how from this _free_ video series; [How to Contribute to an Open Source Project on GitHub](ht",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:7688,variab,variable,7688,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['variab'],['variable']
Modifiability,"```. The example above sets a viscosity of `1e-6`, a diffusivity for a tracer called `T` of `1e-7`,; and a diffusivity for a tracer called `S` of `1e-10`. Specifying diffusivities this way is also valid; for `HorizontalScalarDiffusivity` and `VerticalScalarDiffusivity`. If this method is used, diffusivities; for all tracers need to be specified. ## Smagorinsky-Lilly. To use the default Smagorinsky-Lilly LES closure, we write. ```jldoctest; julia> using Oceananigans.TurbulenceClosures. julia> closure = SmagorinskyLilly(); SmagorinskyLilly: C=0.16, Cb=1.0, Pr=1.0; ```. The parameters `C`, `Cb`, and `Pr` may alternatively be specified explicitly.; For more details see [`SmagorinskyLilly`](@ref). ## Anisotropic minimum dissipation. To use the constant anisotropic minimum dissipation (AMD) LES closure,. ```jldoctest; julia> using Oceananigans.TurbulenceClosures. julia> closure = AnisotropicMinimumDissipation(); AnisotropicMinimumDissipation{ExplicitTimeDiscretization} turbulence closure with:; PoincareÃÅ constant for momentum eddy viscosity CŒΩ: 0.08333333333333333; PoincareÃÅ constant for tracer(s) eddy diffusivit(ies) CŒ∫: 0.08333333333333333; Buoyancy modification multiplier Cb: nothing; ```. no parameters are required although they may be specified. By default, the background viscosity and diffusivity; are assumed to be the molecular values for seawater. For more details see [`AnisotropicMinimumDissipation`](@ref). ## Convective Adjustment Vertical Diffusivity--Viscosity. To use the a convective adjustment scheme that applies enhanced values for vertical diffusivity ``\kappa_z`` and/or; viscosity ``\nu_z``, anytime and anywhere the background stratification becomes unstable. ```jldoctest; julia> using Oceananigans. julia> closure = ConvectiveAdjustmentVerticalDiffusivity(convective_Œ∫z = 1.0, background_Œ∫z = 1e-3); ConvectiveAdjustmentVerticalDiffusivity{VerticallyImplicitTimeDiscretization}(background_Œ∫z=0.001 convective_Œ∫z=1.0 background_ŒΩz=0.0 convective_ŒΩz=0.0); ```; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/turbulent_diffusivity_closures_and_les_models.md:3757,enhance,enhanced,3757,docs/src/model_setup/turbulent_diffusivity_closures_and_les_models.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/turbulent_diffusivity_closures_and_les_models.md,1,['enhance'],['enhanced']
Modifiability,"a_grids). ### Constructing Fields at specified locations. Every `Field` is associated with either the primary mesh or one of the staggered meshes by; a three-dimensional ""location"" associated with each field.; To build a fully-centered `Field`, for example, we write. ```jldoctest fields; c = Field{Center, Center, Center}(grid). # output; 4√ó5√ó4 Field{Center, Center, Center} on RectilinearGrid on CPU; ‚îú‚îÄ‚îÄ grid: 4√ó5√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ boundary conditions: FieldBoundaryConditions; ‚îÇ ‚îî‚îÄ‚îÄ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; ‚îî‚îÄ‚îÄ data: 6√ó7√ó6 OffsetArray(::Array{Float64, 3}, 0:5, 0:6, 0:5) with eltype Float64 with indices 0:5√ó0:6√ó0:5; ‚îî‚îÄ‚îÄ max=0.0, min=0.0, mean=0.0; ```. Fully-centered fields also go by the alias `CenterField`,. ```jldoctest fields; c == CenterField(grid). # output; true; ```. Many fluid dynamical variables are located at cell centers -- for example, tracers like temperature and salinity.; Another common type of `Field` we encounter have cells located over the `x`-interfaces of the primary grid,. ```jldoctest fields; u = Field{Face, Center, Center}(grid). # output; 4√ó5√ó4 Field{Face, Center, Center} on RectilinearGrid on CPU; ‚îú‚îÄ‚îÄ grid: 4√ó5√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ boundary conditions: FieldBoundaryConditions; ‚îÇ ‚îî‚îÄ‚îÄ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; ‚îî‚îÄ‚îÄ data: 6√ó7√ó6 OffsetArray(::Array{Float64, 3}, 0:5, 0:6, 0:5) with eltype Float64 with indices 0:5√ó0:6√ó0:5; ‚îî‚îÄ‚îÄ max=0.0, min=0.0, mean=0.0; ```. which also goes by the alias `u = XFaceField(grid)`.; The name `u` is suggestive: in the Arakawa type-C grid ('C-grid' for short) used by Oceananigans,; the `x`-component of the velocity field is stored at `Face, Center, Center` location. The centers of the `u` cells are shifted to th",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md:4770,variab,variables,4770,docs/src/fields.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md,1,['variab'],['variables']
Modifiability,"cale oceanic boundary layer; turbulence forced by a surface cooling in a horizontally periodic domain using; $256^3$ grid points. The upper layer is well-mixed by turbulent convection and; bounded below by a strong buoyancy interface. (Right) Simulation of; instability of a horizontal density gradient in a rotating channel using; $256\times512\times128$ grid points. A similar process called baroclinic; instability acting on basin-scale temperature gradients fills the oceans with; eddies that stir carbon and heat. Plots made with `matplotlib` [@Hunter2007]; and `cmocean` [@Thyng2016]. ``Oceananigans.jl`` leverages the Julia programming language [@Bezanson2017] to; implement high-level, low-cost abstractions, a friendly user interface, and a; high-performance model in one language and a common code base for execution on; the CPU or GPU with Julia‚Äôs native GPU compiler [@Besard2019]. Because Julia is; a high-level language, development is streamlined and users can flexibly specify; model configurations, set up arbitrary diagnostics and output, extend the code; base, and implement new features. Configuring a model with `architecture=CPU()`; or `architecture=GPU()` will execute the model on the CPU or GPU. By pinning a; simulation script against a specific version of Oceananigans, simulation results; are reproducible up to hardware differences. Performance benchmarks show significant speedups when running on a GPU. Large; simulations on an Nvidia Tesla V100 GPU require ~1 nanosecond per grid point per; iteration. GPU simulations are therefore roughly 3x more cost-effective; than CPU simulations on cloud computing platforms such as Google Cloud. A GPU; with 32 GB of memory can time-step models with ~150 million grid points assuming; five fields are being evolved; for example, three velocity components and; tracers for temperature and salinity. These performance gains permit the; long-time integration of realistic simulations, such as large eddy simulation of; oceanic boun",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md:2816,config,configurations,2816,paper/paper.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md,2,"['config', 'extend']","['configurations', 'extend']"
Modifiability,"cell, ``N`` and ``S`` indicate the northern and southern walls, and ``T`` and ``B`` ; indicate the top and bottom walls. Additionally, two ``\delta`` operators must be defined for each direction to account for the ; staggered nature of the grid. One for taking the difference of a cell-centered variable and ; projecting it onto the cell faces; ```math; \begin{align}; \delta_x^{faa} f_{i, j, k} &= f_{i, j, k} - f_{i-1, j, k} \, , \\; \delta_y^{afa} f_{i, j, k} &= f_{i, j, k} - f_{i, j-1, k} \, , \\; \delta_z^{aaf} f_{i, j, k} &= f_{i, j, k} - f_{i, j, k-1} \, , ; \end{align}; ```; and another for taking the difference of a face-centered variable and projecting it onto the; cell centers; ```math; \begin{align}; \delta_x^{caa} f_{i, j, k} &= f_{i+1, j, k} - f_{i, j, k} \, , \\; \delta_y^{aca} f_{i, j, k} &= f_{i, j+1, k} - f_{i, j, k} \, , \\; \delta_z^{aac} f_{i, j, k} &= f_{i, j, k+1} - f_{i, j, k} \, .; \end{align}; ```. ## Interpolation. In order to add or multiply variables that are defined at different points they are interpolated. ; In our case, linear interpolation or averaging is employed. Once again, there are two averaging ; operators, one for each direction,; ```math; \begin{equation}; \overline{f}^x = \frac{f_E + f_W}{2} \, , \quad; \overline{f}^y = \frac{f_N + f_S}{2} \, , \quad; \overline{f}^z = \frac{f_T + f_B}{2} \, .; \end{equation}; ```. Additionally, three averaging operators must be defined for each direction. One for taking the ; average of a cell-centered variable and projecting it onto the cell faces; ```math; \begin{align}; \overline{f_{i, j, k}}^{faa} = \frac{f_{i, j, k} + f_{i-1, j, k}}{2} \, , \\; \overline{f_{i, j, k}}^{afa} = \frac{f_{i, j, k} + f_{i, j-1, k}}{2} \, , \\; \overline{f_{i, j, k}}^{aaf} = \frac{f_{i, j, k} + f_{i, j, k-1}}{2} \, ,; \end{align}; ```; and another for taking the average of a face-centered variable and projecting it onto the cell centers; ```math; \begin{align}; \overline{f_{i, j, k}}^{caa} = \frac{f_{i+1, j, k} +",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/spatial_operators.md:1919,variab,variables,1919,docs/src/numerical_implementation/spatial_operators.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/spatial_operators.md,1,['variab'],['variables']
Modifiability,"d where the grid spacing is given by ``\eta`` would require the computer to; store on the order of ``10^{14}`` variables.[^1] This is still impractical today, although may be within; reach in less than a decade. He ends by suggesting the use of an analog rather digital computer---a tank of water. [^1]: And even then, ``\eta`` gives the *maximum* allowable grid spacing. There is significant flow structure; smaller than ``\eta``. To have any hope of simulating high Reynolds number flows we need some way of resolving the sub-grid scale motions.[^2]. [^2]: In reality there is no need to resolve all motions down to the Kolmogorov length scale to achieve; acceptable accuracy. Perhaps good results can be achieved if 80\% of the kinetic energy is resolved; (¬ß13) [Pope00](@cite). ## Reynolds-averaged Navier‚ÄìStokes equations. Following [Reynolds1895](@citet), we can decompose flow variables such as velocity ``\boldsymbol{v}`` into the mean component; ``\overline{\boldsymbol{v}}`` and the fluctuating component ``\boldsymbol{v}^\prime`` so that ``\boldsymbol{v} = \overline{\boldsymbol{v}} + \boldsymbol{v}^\prime``; [see ¬ß4 of [Pope00](@citet) for a modern discussion]. Expressing the Navier-Stokes equations in tensor notation; ```math; \begin{align}; \partial_i v_i &= 0 \, ,\\; \partial_t v_i + v_j \partial_j v_i &= f_i - \alpha\partial_i p + \nu \partial_j \partial_j v_i \, ,; \end{align}; ```; where ``\alpha = \rho^{-1}`` is the specific volume and ``f_i`` represents external forces. We can plug in the Reynolds; decomposition for ``\boldsymbol{v}`` and after some manipulation arrive at the following form for the *Reynolds-averaged; Navier-Stokes equations*; ```math; \begin{align}; \partial_i \overline{u}_i &= 0 \, ,\\; \partial_t \overline{u}_i + \overline{u}_j \partial_j \overline{u}_i &= \overline{f}_i -; \partial_j \left(-\alpha\overline{p}\delta_{ij} + 2\nu \overline{S}_{ij} - \overline{v_i^\prime v_j^\prime}\right) \, ,; \end{align}; ```; where; ```math; \overline{S}_{ij} ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md:1464,variab,variables,1464,docs/src/numerical_implementation/turbulence_closures.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md,1,['variab'],['variables']
Modifiability,"e *constant Smagorinsky* model; in contrast to *dynamic Smagorinsky* models that dynamically compute ``C_s`` to account for effects such as buoyant; convection. ## Anisotropic minimum dissipation models. Minimum-dissipation eddy-viscosity models are a class of LES closures that use the minimum eddy dissipation required to; dissipate the energy of sub-grid scale motion. [Rozema15](@citet) proposed the first minimum-dissipation model; appropriate for use on anisotropic grids, termed the *anisotropic minimum dissipation* (AMD) model. It has a number of desirable properties over Smagorinsky-type closures: it is more cost-effective than dynamic; Smagorinsky, it appropriately switches off in laminar and transitional flows, and it is consistent with the exact SGS; stress tensor on both isotropic and anisotropic grids. [Abkar16](@citet) extended the AMD model to model SGS scalar; fluxes for tracer transport. [Abkar17](@citet) further extended the model to include a buoyancy term that accounts for; the contribution of buoyant forces to the production and suppression of turbulence. [Vreugdenhil18](@citet) derive a modified AMD model by following the requirement suggested by [Verstappen18](@citet),; which entail normalising the displacement, the velocity, and the velocity gradient by the filter width to ensure that; the resulting eddy dissipation properly counteracts the spurious kinetic energy transferred by convective nonlinearity,; to derive a modified AMD model. The eddy viscosity and diffusivity are defined in terms of eddy viscosity and diffusivity *predictors*; ``\nu_e^\dagger`` and ``\kappa_e^\dagger``, such that; ```math; \nu_e = \max \lbrace 0, \nu_e^\dagger \rbrace; \quad \text{and} \quad; \kappa_e = \max \lbrace 0, \kappa_e^\dagger \rbrace \, ,; ```; to ensure that ``\nu_e \ge 0`` and ``\kappa_e \ge 0``. Leaving out the overlines and understanding that all variables; represent the resolved/filtered variables, the eddy viscosity predictor is given by; ```math; \begin",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md:5047,extend,extended,5047,docs/src/numerical_implementation/large_eddy_simulation.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md,1,['extend'],['extended']
Modifiability,"e near-surface temperature gradient and the temperature diffusivity;; * constant velocity tangential to a boundary as in a driven-cavity flow (for example), ; where the top boundary is moving. Momentum will flux into the domain do the difference; between the top boundary velocity and the interior velocity, and the prescribed viscosity. 3. `GradientBoundaryCondition` (Neumann) specifies the gradient of a field on a boundary.; For example, if there is a known `diffusivity`, we can express `FluxBoundaryCondition(flux)`; using `GradientBoundaryCondition(-flux / diffusivity)` (aka ""Neumann"" boundary condition). In addition to these primary boundary conditions, `ImpenetrableBoundaryCondition` applies to velocity; components in wall-normal directions. !!! warn ""`ImpenetrableBoundaryCondition`""; `ImpenetrableBoundaryCondition` is internally enforced for fields created inside the model constructor.; As a result, `ImpenetrableBoundaryCondition` is only used for _additional_ velocity components; that are not evolved by a model, such as a velocity component used for (`AdvectiveForcing`)[@ref]. Finally, note that `Periodic` boundary conditions are internally enforced for `Periodic` directions,; and `DefaultBoundaryCondition`s may exist before boundary conditions are ""materialized"" by a model. ## Default boundary conditions. The default boundary condition in `Bounded` directions is no-flux, or `FluxBoundaryCondition(nothing)`.; The default boundary condition can be changed by passing a positional argument to `FieldBoundaryConditions`,; as in. ```jldoctest; julia> no_slip_bc = ValueBoundaryCondition(0.0); ValueBoundaryCondition: 0.0. julia> free_slip_surface_bcs = FieldBoundaryConditions(no_slip_bc, top=FluxBoundaryCondition(nothing)); Oceananigans.FieldBoundaryConditions, with boundary conditions; ‚îú‚îÄ‚îÄ west: DefaultBoundaryCondition (ValueBoundaryCondition: 0.0); ‚îú‚îÄ‚îÄ east: DefaultBoundaryCondition (ValueBoundaryCondition: 0.0); ‚îú‚îÄ‚îÄ south: DefaultBoundaryCondition (ValueBoundaryCon",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md:6566,evolve,evolved,6566,docs/src/model_setup/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md,1,['evolve'],['evolved']
Modifiability,"e of a cell-centered ; variable such as temperature ``T`` lies on the faces in the direction of the difference, and ; vice versa. In principle, there are three difference operators, one for each direction; ```math; \delta_x f = f_E - f_W , \quad; \delta_y f = f_N - f_S , \quad; \delta_z f = f_T - f_B ,; ```; where the ``E`` and ``W`` subscripts indicate that the value is evaluated the eastern or western ; wall of the cell, ``N`` and ``S`` indicate the northern and southern walls, and ``T`` and ``B`` ; indicate the top and bottom walls. Additionally, two ``\delta`` operators must be defined for each direction to account for the ; staggered nature of the grid. One for taking the difference of a cell-centered variable and ; projecting it onto the cell faces; ```math; \begin{align}; \delta_x^{faa} f_{i, j, k} &= f_{i, j, k} - f_{i-1, j, k} \, , \\; \delta_y^{afa} f_{i, j, k} &= f_{i, j, k} - f_{i, j-1, k} \, , \\; \delta_z^{aaf} f_{i, j, k} &= f_{i, j, k} - f_{i, j, k-1} \, , ; \end{align}; ```; and another for taking the difference of a face-centered variable and projecting it onto the; cell centers; ```math; \begin{align}; \delta_x^{caa} f_{i, j, k} &= f_{i+1, j, k} - f_{i, j, k} \, , \\; \delta_y^{aca} f_{i, j, k} &= f_{i, j+1, k} - f_{i, j, k} \, , \\; \delta_z^{aac} f_{i, j, k} &= f_{i, j, k+1} - f_{i, j, k} \, .; \end{align}; ```. ## Interpolation. In order to add or multiply variables that are defined at different points they are interpolated. ; In our case, linear interpolation or averaging is employed. Once again, there are two averaging ; operators, one for each direction,; ```math; \begin{equation}; \overline{f}^x = \frac{f_E + f_W}{2} \, , \quad; \overline{f}^y = \frac{f_N + f_S}{2} \, , \quad; \overline{f}^z = \frac{f_T + f_B}{2} \, .; \end{equation}; ```. Additionally, three averaging operators must be defined for each direction. One for taking the ; average of a cell-centered variable and projecting it onto the cell faces; ```math; \begin{align}; \overline",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/spatial_operators.md:1234,variab,variable,1234,docs/src/numerical_implementation/spatial_operators.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/spatial_operators.md,2,['variab'],['variable']
Modifiability,"e, please open a pull request to add it or let us know!. 1. Bisits, J. I., Zika, J. D., and Evans, D. G. (2024) [Does cabbeling shape the thermohaline structure of high-latitude oceans?](https://doi.org/10.1175/JPO-D-24-0061.1) _Journal of Physical Oceanography_, in press. DOI: [10.1175/JPO-D-24-0061.1](https://doi.org/10.1175/JPO-D-24-0061.1). 1. Strong-Wright J. and Taylor, J. R. (2024) [A model of tidal flow and tracer release in a giant kelp forest](https://doi.org/10.1017/flo.2024.13), _Flow_, **4**, E21. DOI: [10.1017/flo.2024.13](https://doi.org/10.1017/flo.2024.13). 1. Chor, T. and Wenegrat, J. (2024). [The turbulent dynamics of anticyclonic submesoscale headland wakes](https://doi.org/10.31223/X5570C), _Earth arXiv_, DOI: [10.31223/X5570C](https://doi.org/10.31223/X5570C). 1. Wagner, G. L., Hillier, A., Constantinou, N. C., Silvestri, S., Souza, A., Burns, K., Hill, C., Campin, J.-M., Marshall, J., and Ferrari, R. (2024). [Formulation and calibration of CATKE, a one-equation parameterization for microscale ocean mixing](https://doi.org/10.48550/arXiv.2306.13204), _arXiv_, arXiv:2306.13204. DOI: [10.48550/arXiv.2306.13204](https://doi.org/10.48550/arXiv.2306.13204). 1. Allred, T., Li, X., Wiersdorf, A., Greenman, B., and Gopalakrishnan, G. (2024). [FlowFPX: Nimble tools for debugging floating-point exceptions](https://doi.org/10.48550/arXiv.2403.15632), _arXiv_, arXiv:2403.15632. DOI: [10.48550/arXiv.2403.15632](https://doi.org/10.48550/arXiv.2403.15632). 1. Silvestri, S., Wagner, G. L., Constantinou, N. C., Hill, C., Campin, J.-M., Souza, A., Bishnu, S., Churavy, V., Marshall, J., and Ferrari, R. (2024) [A GPU-based ocean dynamical core for routine mesoscale-resolving climate simulations](https://doi.org/10.22541/essoar.171708158.82342448/v1), _ESS Open Archive_. DOI: [10.22541/essoar.171708158.82342448/v1](https://doi.org/10.22541/essoar.171708158.82342448/v1). 1. Silvestri, S., Wagner, G. L., Campin, J.-M., Constantinou, N. C., Hill, C., Souza, A., and Fer",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md:5852,parameteriz,parameterization,5852,docs/src/index.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md,1,['parameteriz'],['parameterization']
Modifiability,"e. In practice, ``C_s`` is a tunable parameter. Due to the presence of the constant ``C_s``, the model is sometimes referred to as the *constant Smagorinsky* model; in contrast to *dynamic Smagorinsky* models that dynamically compute ``C_s`` to account for effects such as buoyant; convection. ## Anisotropic minimum dissipation models. Minimum-dissipation eddy-viscosity models are a class of LES closures that use the minimum eddy dissipation required to; dissipate the energy of sub-grid scale motion. [Rozema15](@citet) proposed the first minimum-dissipation model; appropriate for use on anisotropic grids, termed the *anisotropic minimum dissipation* (AMD) model. It has a number of desirable properties over Smagorinsky-type closures: it is more cost-effective than dynamic; Smagorinsky, it appropriately switches off in laminar and transitional flows, and it is consistent with the exact SGS; stress tensor on both isotropic and anisotropic grids. [Abkar16](@citet) extended the AMD model to model SGS scalar; fluxes for tracer transport. [Abkar17](@citet) further extended the model to include a buoyancy term that accounts for; the contribution of buoyant forces to the production and suppression of turbulence. [Vreugdenhil18](@citet) derive a modified AMD model by following the requirement suggested by [Verstappen18](@citet),; which entail normalising the displacement, the velocity, and the velocity gradient by the filter width to ensure that; the resulting eddy dissipation properly counteracts the spurious kinetic energy transferred by convective nonlinearity,; to derive a modified AMD model. The eddy viscosity and diffusivity are defined in terms of eddy viscosity and diffusivity *predictors*; ``\nu_e^\dagger`` and ``\kappa_e^\dagger``, such that; ```math; \nu_e = \max \lbrace 0, \nu_e^\dagger \rbrace; \quad \text{and} \quad; \kappa_e = \max \lbrace 0, \kappa_e^\dagger \rbrace \, ,; ```; to ensure that ``\nu_e \ge 0`` and ``\kappa_e \ge 0``. Leaving out the overlines and u",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md:4948,extend,extended,4948,docs/src/numerical_implementation/large_eddy_simulation.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md,1,['extend'],['extended']
Modifiability,"ence of a zigzag pressure field: on a 1D; collocated grid the velocity at the point ``i`` is influenced by the pressure at points ``i-1`` and ``i+1``, and a zigzag; pressure field will be felt as a uniform pressure, which is obviously wrong and would reduce the accuracy of the; solution. The pressure is effectively taken from a coarser grid than what is actually used. The basic problem is that; the momentum equations will use the pressure difference between two alternate points when it should be using two; adjacent points. From the viewpoint of linear algebra, these spurious pressure modes correspond to solutions in the null space of the; pressure projection operator with eigenvalue zero and are thus indistinguishable from a uniform pressure field; [Sani81](@cite). The staggered grid was first introduced by [Harlow65](@citet) with their *marker and cell* method. In meteorology; and oceanography, this particular staggered grid configuration is referred to as the Arakawa C-grid after [Arakawa77](@citet), who; investigated four different staggered grids and the unstaggered A-grid for use in an atmospheric model. [Arakawa77](@citet) investigated the dispersion relation of inertia-gravity waves[^2] traveling in the ``x``-direction; ```math; \omega^2 = f^2 + gHk^2 \, ,; ```; in the linearized rotating shallow-water equations for five grids. Here ``\omega`` is the angular frequency, ``H`` is the; height of the fluid and ``k`` is the wavenumber in the ``x``-direction. Looking at the effect of spatial discretization; error on the frequency of these waves they find that the B and C-grids reproduce the dispersion relation most closely; out of the five [Arakawa77](@citet) (Figure 5). In particular, the dispersion relation for the C-grid is given by; ```math; \omega^2 = f^2 \left[ \cos^2 \left( \frac{k\Delta}{2} \right); + 4 \left( \frac{\lambda}{\Delta} \right)^2 \sin^2 \left( \frac{k\Delta}{2} \right) \right] \, ,; ```; where ``\lambda`` is the wavelength and ``\Delta`` is the",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/staggered_grid.md:2578,config,configuration,2578,docs/src/appendix/staggered_grid.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/staggered_grid.md,1,['config'],['configuration']
Modifiability,"file output (vector). xC, yF = xnodes(grid, Center()), ynodes(grid, Face()). XC = [xC[i] for i in 1:Nx, j in 1:Ny]; YF = [yF[j] for i in 1:Nx, j in 1:Ny]. h(model) = @. model.clock.time * sin(XC) * cos(YF) # x-y slice output (2D array). outputs = Dict(""scalar"" => f, ""profile"" => g, ""slice"" => h). dims = Dict(""scalar"" => (), ""profile"" => (""zC"",), ""slice"" => (""xC"", ""yC"")). output_attributes = Dict(; ""scalar"" => Dict(""longname"" => ""Some scalar"", ""units"" => ""bananas""),; ""profile"" => Dict(""longname"" => ""Some vertical profile"", ""units"" => ""watermelons""),; ""slice"" => Dict(""longname"" => ""Some slice"", ""units"" => ""mushrooms""); ). global_attributes = Dict(""location"" => ""Bay of Fundy"", ""onions"" => 7). simulation.output_writers[:things] =; NetCDFOutputWriter(model, outputs,; schedule=IterationInterval(1), filename=""things.nc"", dimensions=dims, verbose=true,; global_attributes=global_attributes, output_attributes=output_attributes); ```. `NetCDFOutputWriter` can also be configured for `outputs` that are interpolated or regridded; to a different grid than `model.grid`. To use this functionality, include the keyword argument; `grid = output_grid`. ```@example; using Oceananigans; using Oceananigans.Fields: interpolate!. grid = RectilinearGrid(size=(1, 1, 8), extent=(1, 1, 1));; model = NonhydrostaticModel(; grid). coarse_grid = RectilinearGrid(size=(grid.Nx, grid.Ny, grid.Nz√∑2), extent=(grid.Lx, grid.Ly, grid.Lz)); coarse_u = Field{Face, Center, Center}(coarse_grid). interpolate_u(model) = interpolate!(coarse_u, model.velocities.u); outputs = (; u = interpolate_u). output_writer = NetCDFOutputWriter(model, outputs;; grid = coarse_grid,; filename = ""coarse_u.nc"",; schedule = IterationInterval(1)); ```. See [`NetCDFOutputWriter`](@ref) for more information. ## JLD2 output writer. JLD2 is a fast HDF5 compatible file format written in pure Julia.; JLD2 files can be opened in Julia with the [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) package; and in Python with the [h5py](https://www.h",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md:5330,config,configured,5330,docs/src/model_setup/output_writers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/output_writers.md,1,['config'],['configured']
Modifiability,"functions. Next we build a grid that is both `Bounded` and stretched in both the `y` and `z` directions.; The purpose of the stretching is to increase grid resolution near the boundaries.; We'll do this by using functions to specify the keyword arguments `y` and `z`. ```jldoctest grids; Nx = Ny = 64; Nz = 32. Lx = Ly = 1e4; Lz = 1e3. # Note that j varies from 1 to Ny; chebychev_spaced_y_faces(j) = Ly * (1 - cos(œÄ * (j - 1) / Ny)) / 2. # Note that k varies from 1 to Nz; chebychev_spaced_z_faces(k) = - Lz * (1 + cos(œÄ * (k - 1) / Nz)) / 2. grid = RectilinearGrid(size = (Nx, Ny, Nz),; topology = (Periodic, Bounded, Bounded),; x = (0, Lx),; y = chebychev_spaced_y_faces,; z = chebychev_spaced_z_faces). # output; 64√ó64√ó32 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 10000.0) regularly spaced with Œîx=156.25; ‚îú‚îÄ‚îÄ Bounded y ‚àà [0.0, 10000.0] variably spaced with min(Œîy)=6.02272, max(Œîy)=245.338; ‚îî‚îÄ‚îÄ Bounded z ‚àà [-1000.0, -0.0] variably spaced with min(Œîz)=2.40764, max(Œîz)=49.0086; ```. ```@setup plot; using Oceananigans; using CairoMakie; CairoMakie.activate!(type = ""svg""); set_theme!(Theme(fontsize=24)). Nx, Ny, Nz = 64, 64, 32; Lx, Ly, Lz = 1e4, 1e4, 1e3. chebychev_spaced_y_faces(j) = Ly * (1 - cos(œÄ * (j - 1) / Ny)) / 2; chebychev_spaced_z_faces(k) = - Lz * (1 + cos(œÄ * (k - 1) / Nz)) / 2. grid = RectilinearGrid(size = (Nx, Ny, Nz),; topology = (Periodic, Bounded, Bounded),; x = (0, Lx),; y = chebychev_spaced_y_faces,; z = chebychev_spaced_z_faces); ```. We can easily visualize the spacings of ``y`` and ``z`` directions. We can use, e.g.,; [`ynodes`](@ref) and [`yspacings`](@ref) to extract the positions and spacings of the; nodes from the grid. ```@example plot; yc = ynodes(grid, Center()); zc = znodes(grid, Center()). yf = ynodes(grid, Face()); zf = znodes(grid, Face()). Œîy = yspacings(grid, Center()); Œîz = zspacings(grid, Center()). using CairoMakie. fig = Figure(size=(1200, 1200)). axy = Axis(fig[1, 1], title=""y-gr",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:17112,variab,variably,17112,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['variab'],['variably']
Modifiability,"gans&query=total_requests&suffix=%2Fmonth&label=Downloads&style=flat-square"">; </a>; <a href=""https://juliapkgstats.com/pkg/Oceananigans"">; <img alt=""Downloads per month"" src=""https://img.shields.io/badge/dynamic/json?url=http%3A%2F%2Fjuliapkgstats.com%2Fapi%2Fv1%2Ftotal_downloads%2FOceananigans&query=total_requests&&label=Total%20Downloads&style=flat-square"">; </a>; </p>. <!-- CI/CD badges -->; <p align=""center"">; <a href=""https://buildkite.com/clima/oceananigans"">; <img alt=""Buildkite CPU+GPU build status"" src=""https://img.shields.io/buildkite/4d921fc17b95341ea5477fb62df0e6d9364b61b154e050a123/main?logo=buildkite&label=Buildkite%20CPU%2BGPU&style=flat-square"">; </a>; <a href=""https://hub.docker.com/r/aliramadhan/oceananigans"">; <img alt=""Docker build status"" src=""https://img.shields.io/docker/cloud/build/aliramadhan/oceananigans?label=Docker&logo=docker&logoColor=white&style=flat-square"">; </a>; </p>. Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic; and hydrostatic Boussinesq equations on CPUs and GPUs.; It runs on GPUs (wow, [fast!](http://arxiv.org/abs/2309.06662)), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans.jl is developed by the [Climate Modeling Alliance](https://clima.caltech.edu) and heroic external collaborators. ## Contents. - [Contents](#contents); - [Installation instructions](#installation-instructions); - [Running your first model](#running-your-first-model); - [The Oceananigans knowledge base](#the-oceananigans-knowledge-base); - [Citing](#citing); - [Contributing](#contributing); - [Movies](#movies); - [Deep convection](#deep-convection); - [Free convection](#free-convection); - [Winds blowing over the ocean](#winds-blowing-over-the-ocean); - [Free convection with wind stress](#free-convection-with-wind-stress); - [Performance benchmarks](#perf",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:3345,flexible,flexible,3345,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['flexible'],['flexible']
Modifiability,"gans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))). simulation = Simulation(model, Œît=1, stop_iteration=10). show_time(sim) = @info ""Time is $(prettytime(sim.model.clock.time))"". simulation.callbacks[:total_A] = Callback(show_time, IterationInterval(2)). simulation; ```. Now when simulation runs the simulation the callback is called. ```@example checkpointing; run!(simulation); ```. We can also use the convenience [`add_callback!`](@ref):. ```@example checkpointing; add_callback!(simulation, show_time, name=:total_A_via_convenience, IterationInterval(2)). simulation; ```. The keyword argument `callsite` determines the moment at which the callback is executed.; By default, `callsite = TimeStepCallsite()`, indicating execution _after_ the completion of; a timestep. The other options are `callsite = TendencyCallsite()` that executes the callback; after the tendencies are computed but _before_ taking a timestep and `callsite = UpdateStateCallsite()`; that executes the callback within `update_state!`, after auxiliary variables have been computed; (for multi-stage time-steppers, `update_state!` may be called multiple times per timestep). As an example of a callback with `callsite = TendencyCallsite()` , we show below how we can; manually add to the tendency field of one of the velocity components. Here we've chosen; the `:u` field using parameters:. ```@example checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))). simulation = Simulation(model, Œît=1, stop_iteration=10). function modify_tendency!(model, params); model.timestepper.G‚Åø[params.c] .+= params.Œ¥; return nothing; end. simulation.callbacks[:modify_u] = Callback(modify_tendency!, IterationInterval(1),; callsite = TendencyCallsite(),; parameters = (c = :u, Œ¥ = 1)). run!(simulation); ```. Above there is no forcing at all, but due to the callback the ``u``-velocity is increased. ```@example checkpointing; @info mode",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/callbacks.md:1392,variab,variables,1392,docs/src/model_setup/callbacks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/callbacks.md,1,['variab'],['variables']
Modifiability,"grid: 16√ó16√ó16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ boundary conditions: FieldBoundaryConditions; ‚îÇ ‚îî‚îÄ‚îÄ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; ‚îî‚îÄ‚îÄ data: 22√ó22√ó22 OffsetArray(::Array{Float64, 3}, -2:19, -2:19, -2:19) with eltype Float64 with indices -2:19√ó-2:19√ó-2:19; ‚îî‚îÄ‚îÄ max=0.0, min=0.0, mean=0.0. julia> model.tracers.S; 16√ó16√ó16 Field{Center, Center, Center} on RectilinearGrid on CPU; ‚îú‚îÄ‚îÄ grid: 16√ó16√ó16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ boundary conditions: FieldBoundaryConditions; ‚îÇ ‚îî‚îÄ‚îÄ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; ‚îî‚îÄ‚îÄ data: 22√ó22√ó22 OffsetArray(::Array{Float64, 3}, -2:19, -2:19, -2:19) with eltype Float64 with indices -2:19√ó-2:19√ó-2:19; ‚îî‚îÄ‚îÄ max=0.0, min=0.0, mean=0.0; ```. An arbitrary number of tracers may be simulated. For example, to simulate; ``C_1``, ``CO‚ÇÇ``, and `nitrogen` as additional passive tracers,. ```jldoctest tracers; julia> model = NonhydrostaticModel(; grid, tracers=(:T, :S, :C‚ÇÅ, :CO‚ÇÇ, :nitrogen)); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ‚îú‚îÄ‚îÄ grid: 16√ó16√ó16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ timestepper: RungeKutta3TimeStepper; ‚îú‚îÄ‚îÄ advection scheme: Centered reconstruction order 2; ‚îú‚îÄ‚îÄ tracers: (T, S, C‚ÇÅ, CO‚ÇÇ, nitrogen); ‚îú‚îÄ‚îÄ closure: Nothing; ‚îú‚îÄ‚îÄ buoyancy: Nothing; ‚îî‚îÄ‚îÄ coriolis: Nothing; ```. !!! info ""Active versus passive tracers""; An active tracer is a tracer whose distribution affects the evolution of momentum and other tracers.; Typical ocean models evolve conservative temperature and absolute salinity as active tracers,; which effect momentum through buoyancy forces.; Passive tracers are ""passive"" in the sense that their distribution does not affect; the evolution of other tracers or flow quantities.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/tracers.md:3201,evolve,evolve,3201,docs/src/model_setup/tracers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/tracers.md,1,['evolve'],['evolve']
Modifiability,"he domain.; Conversely, a positive flux at a _bottom_ boundary acts to increase the interior; values of a quantity. ### 3. Spatially- and temporally-varying flux. Boundary conditions may be specified by functions,. ```jldoctest; julia> @inline surface_flux(x, y, t) = cos(2œÄ * x) * cos(t);. julia> top_tracer_bc = FluxBoundaryCondition(surface_flux); FluxBoundaryCondition: ContinuousBoundaryFunction surface_flux at (Nothing, Nothing, Nothing); ```. !!! info ""Boundary condition functions""; By default, a function boundary condition is called with the signature; ```julia; f(Œæ, Œ∑, t); ```; where `t` is time and `Œæ, Œ∑` are spatial coordinates that vary along the boundary:; * `f(y, z, t)` on `x`-boundaries;; * `f(x, z, t)` on `y`-boundaries;; * `f(x, y, t)` on `z`-boundaries.; Alternative function signatures are specified by keyword arguments to; `BoundaryCondition`, as illustrated in subsequent examples. ### 4. Spatially- and temporally-varying flux with parameters. Boundary condition functions may be 'parameterized',. ```jldoctest; julia> @inline wind_stress(x, y, t, p) = - p.œÑ * cos(p.k * x) * cos(p.œâ * t); # function with parameters. julia> top_u_bc = FluxBoundaryCondition(wind_stress, parameters=(k=4œÄ, œâ=3.0, œÑ=1e-4)); FluxBoundaryCondition: ContinuousBoundaryFunction wind_stress at (Nothing, Nothing, Nothing); ```. !!! info ""Boundary condition functions with parameters""; The keyword argument `parameters` above specifies that `wind_stress` is called; with the signature `wind_stress(x, y, t, parameters)`. In principle, `parameters` is arbitrary.; However, relatively simple objects such as floating point numbers or `NamedTuple`s must be used; when running on the GPU. ### 5. 'Field-dependent' boundary conditions. Boundary conditions may also depend on model fields. For example, a linear drag boundary condition; is implemented with. ```jldoctest; julia> @inline linear_drag(x, y, t, u) = - 0.2 * u; linear_drag (generic function with 1 method). julia> u_bottom_bc = FluxBound",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md:11566,parameteriz,parameterized,11566,docs/src/model_setup/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md,1,['parameteriz'],['parameterized']
Modifiability,"ince Julia and KernelAbstractions.jl (needed for GPU runs) already inline some; functions automatically. However, it is generally a good idea to at least investigate this aspect in; your code as the benefits can potentially be significant. ## GPU simulation tips. Running on GPUs can be very different from running on CPUs. Oceananigans makes most of the necessary; changes in the background, so that for very simple simulations changing between CPUs and GPUs is; just a matter of changing the `architecture` argument in the model from `CPU()` to `GPU()`. However,; for more complex simulations some care needs to be taken on the part of the user. While knowledge of; GPU computing (and Julia) is again desirable, an inexperienced user can also achieve high efficiency; in GPU simulations by following a few simple principles. ### Global variables that need to be used in GPU computations need to be defined as constants or passed as parameters. Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation; will crash. This includes any variables that are referenced as global variables in functions; used for forcing of boundary conditions. For example,. ```julia; T‚ÇÄ = 20 # ·µíC; surface_temperature(x, y, t) = T‚ÇÄ * sin(2œÄ / 86400 * t); T_bcs = FieldBoundaryConditions(bottom = GradientBoundaryCondition(surface_temperature)); ```. will throw an error if run on the GPU (and will run more slowly than it should on the CPU).; Replacing the first line above with. ```julia; const T‚ÇÄ = 20 # ·µíC; ```. fixes the issue by indicating to the compiler that `T‚ÇÄ` will not change. Note that the _literal_ `2œÄ / 86400` is not an issue -- it's only the; _variable_ `T‚ÇÄ` that must be declared `const`. Alternatively, we can pass the variable as a parameter to `GradientBoundaryCondition`. To do that; we need to pass a named tuple as `parameter` keyword argument:. ```julia; T‚ÇÄ = 20 # ·µíC; surface_temperature(x, y, t, p) = p.T‚ÇÄ * sin(2œÄ / 86400 * t); T_bcs = FieldBoundaryCondi",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:4133,variab,variable,4133,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['variab'],['variable']
Modifiability,"ing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:u, :v, :w); ```. ```jldoctest field_dependent_forcing; model.forcing.S. # output; ContinuousForcing{Float64} at (Center, Center, Center); ‚îú‚îÄ‚îÄ func: S_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: 0.01; ‚îî‚îÄ‚îÄ field dependencies: (:S,); ```. The `field_dependencies` arguments follow `x, y, z, t` in the forcing `func`tion in; the order they are specified in `Forcing`.; If both `field_dependencies` and `parameters` are specified, then the `field_dependencies`; arguments follow `x, y, z, t`, and `parameters` follow `field_dependencies`. Model fields that arise in the arguments of continuous `Forcing` `func`tions are; automatically interpolated to the staggered grid location at which the forcing is applied. ### ""Discrete form"" forcing functions. ""Discrete form"" forcing functions are either called with the signature. ```julia; func(i, j, k, grid, clock, model_fields); ```. or the parameterized form. ```julia; func(i, j, k, grid, clock, model_fields, parameters); ```. Discrete form forcing functions can access the entirety of model field; data through the argument `model_fields`. The object `model_fields` is a `NamedTuple`; whose properties include the velocity fields `model_fields.u`, `model_fields.v`,; `model_fields.w` and all fields in `model.tracers`. Using discrete forcing functions may require understanding the; staggered arrangement of velocity fields and tracers in `Oceananigans`.; Here's a slightly non-sensical example in which the vertical derivative of a buoyancy; tracer is used as a time-scale for damping the u-velocity field:. ```jldoctest discrete_forcing; # A damping term that depends on a ""local average"":; local_average(i, j, k, grid, c) = @inbounds (c[i, j, k] + c[i-1, j, k] + c[i+1, j, k] +; c[i, j-1, k] + c[i, j+1, k] +; c[i, j, k-1] + c[i, j, k+1]) / 7. b_forcing_func(i, j, k, grid, clock, model_fields) = - local_average(i, j, k, grid, model_fields",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:5700,parameteriz,parameterized,5700,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['parameteriz'],['parameterized']
Modifiability,"is generally a good idea to at least investigate this aspect in; your code as the benefits can potentially be significant. ## GPU simulation tips. Running on GPUs can be very different from running on CPUs. Oceananigans makes most of the necessary; changes in the background, so that for very simple simulations changing between CPUs and GPUs is; just a matter of changing the `architecture` argument in the model from `CPU()` to `GPU()`. However,; for more complex simulations some care needs to be taken on the part of the user. While knowledge of; GPU computing (and Julia) is again desirable, an inexperienced user can also achieve high efficiency; in GPU simulations by following a few simple principles. ### Global variables that need to be used in GPU computations need to be defined as constants or passed as parameters. Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation; will crash. This includes any variables that are referenced as global variables in functions; used for forcing of boundary conditions. For example,. ```julia; T‚ÇÄ = 20 # ·µíC; surface_temperature(x, y, t) = T‚ÇÄ * sin(2œÄ / 86400 * t); T_bcs = FieldBoundaryConditions(bottom = GradientBoundaryCondition(surface_temperature)); ```. will throw an error if run on the GPU (and will run more slowly than it should on the CPU).; Replacing the first line above with. ```julia; const T‚ÇÄ = 20 # ·µíC; ```. fixes the issue by indicating to the compiler that `T‚ÇÄ` will not change. Note that the _literal_ `2œÄ / 86400` is not an issue -- it's only the; _variable_ `T‚ÇÄ` that must be declared `const`. Alternatively, we can pass the variable as a parameter to `GradientBoundaryCondition`. To do that; we need to pass a named tuple as `parameter` keyword argument:. ```julia; T‚ÇÄ = 20 # ·µíC; surface_temperature(x, y, t, p) = p.T‚ÇÄ * sin(2œÄ / 86400 * t); T_bcs = FieldBoundaryConditions(bottom = GradientBoundaryCondition(surface_temperature, parameters=(; T‚ÇÄ))); ```. ### Complex diagnostics using",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:4251,variab,variables,4251,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,2,['variab'],['variables']
Modifiability,"jfm.2023.748), _Journal of Fluid Mechanics_, **973**, A44. DOI: [10.1017/jfm.2023.748](https://doi.org/10.1017/jfm.2023.748). 1. Strong-Wright, J, Chen, S., Constantinou, N. C., Silvestri, S., Wagner, G. L., and Taylor, J. R. (2023). [OceanBioME.jl: A flexible environment for modelling the coupled interactions between ocean biogeochemistry and physics](https://doi.org/10.21105/joss.05669), _Journal of Open Source Software_, **90(8)**, 5669. DOI: [10.21105/joss.05669](https://doi.org/10.21105/joss.05669). 1. Ramadhan, A., Marshall, J. C., Souza, A. N., Lee, X. K., Piterbarg, U., Hillier, A., Wagner, G. L., Rackauckas, C., Hill, C., Campin, J.-M., and Ferrari, R. (2022). [Capturing missing physics in climate model parameterizations using neural differential equations](https://doi.org/10.1002/essoar.10512533.1), _ESS Open Archive_. DOI: [10.1002/essoar.10512533.1](https://doi.org/10.1002/essoar.10512533.1). 1. Gupta, M. and Thompson, A. F. (2022). [Regimes of sea-ice floe melt: Ice-ocean coupling at the submesoscales](https://doi.org/10.1029/2022JC018894), _Journal of Geophysical Research: Oceans_, **127**, e2022JC018894. DOI: [10.1029/2022JC018894](https://doi.org/10.1029/2022JC018894). 1. Simoes-Sousa, I. T., Tandon, A., Pereira, F., Lazaneo, C. Z., and Mahadevan, A. (2022). [Mixed layer eddies supply nutrients to enhance the spring phytoplankton bloom](https://doi.org/10.3389/fmars.2022.825027), _Frontiers in Marine Sciences_, **9**, 825027. DOI: [10.3389/fmars.2022.825027](https://doi.org/10.3389/fmars.2022.825027). 1. Chor, T., Wenegrat, J. O., and Taylor, J. (2022). [Insights into the mixing efficiency of submesoscale Centrifugal-Symmetric instabilities.](https://doi.org/10.1175/JPO-D-21-0259.1), _Journal of Physical Oceanography_, **52(10)**, 2273-2287. DOI: [10.1175/JPO-D-21-0259.1](https://doi.org/10.1175/JPO-D-21-0259.1). 1. Bire, S., Kang, W., Ramadhan, A., Campin, J.-M., and Marshall, J. (2022). [Exploring ocean circulation on icy moons heated from below.](h",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md:9475,coupling,coupling,9475,docs/src/index.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md,1,['coupling'],['coupling']
Modifiability,"lang.org/en/v1/manual/variables-and-scoping/#Global-Scope) (which can be; loosely defined as a variable defined in the main script) inside functions slows down the code. One; way to circumvent this is to always [use local variables or pass them as arguments to; functions](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). This; helps the compiler optimize the code. Another way around this is to [define global variables as constants whenever; possible](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). One; thing to keep in mind when doing this is that when a `const` is defined, its value can't be changed; until you restart the Julia session. So this latter approach is good for production-ready code, but; may be undesirable in the early stages of development while you still have to change the parameters; of the simulation for exploration. It is especially important to avoid global variables in functions that are meant to be executed in; GPU kernels (such as functions defining boundary conditions and forcings). Otherwise the Julia GPU; compiler can fail with obscure errors. This is explained in more detail in the GPU simulation tips; section below. ### Consider inlining small functions. Inlining is when the compiler [replaces a function call with the body of the function that is being; called before compiling](https://en.wikipedia.org/wiki/Inline_expansion). The advantage of inlining; (which in julia can be done with the [`@inline`; macro](https://docs.julialang.org/en/v1/devdocs/meta/)) is that gets rid of the time spent calling; the function. The Julia compiler automatically makes some calls as to what functions it should or; shouldn't inline, but you can force a function to be inlined by including the macro `@inline` before; its definition. This is more suited for small functions that are called often. Here's an example of; an implementation of the Heaviside function that forces it to be inlined:. ```ju",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:1962,variab,variables,1962,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['variab'],['variables']
Modifiability,"la} \times \boldsymbol{v}``; is defined at the cell edges.[^1]. [^1]: In 2D it would more correct to say the cell corners. In 3D, variables like vorticity lie at the same vertical; levels as the cell-centered variables and so they really lie at the cell edges. ![Schematic of control volumes](../numerical_implementation/assets/staggered_grid.png); *A schematic of `Oceananigans.jl` finite volumes for a two-dimensional staggered grid in ``(x, z)``.; Tracers ``c`` and pressure ``p`` are defined at the center of the control volume. The ``u`` control volumes are ; centered on the left and right edges of the pressure control volume while the ``w`` control volumes are centered ; on the top and bottom edges of the pressure control volumes. The indexing convention places the ``i^{\rm{th}}`` ; ``u``-node on cell ``x``-faces to the left of the ``i`` tracer point at cell centers.*. This staggered arrangement of variables is more complicated than the collocated grid arrangement but is greatly; beneficial as it avoids the odd-even decoupling between the pressure and velocity if they are stored at the same; positions. ¬ß6.1 of [Patankar80](@citet) discusses this problem in the presence of a zigzag pressure field: on a 1D; collocated grid the velocity at the point ``i`` is influenced by the pressure at points ``i-1`` and ``i+1``, and a zigzag; pressure field will be felt as a uniform pressure, which is obviously wrong and would reduce the accuracy of the; solution. The pressure is effectively taken from a coarser grid than what is actually used. The basic problem is that; the momentum equations will use the pressure difference between two alternate points when it should be using two; adjacent points. From the viewpoint of linear algebra, these spurious pressure modes correspond to solutions in the null space of the; pressure projection operator with eigenvalue zero and are thus indistinguishable from a uniform pressure field; [Sani81](@cite). The staggered grid was first introduced b",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/staggered_grid.md:1367,variab,variables,1367,docs/src/appendix/staggered_grid.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/staggered_grid.md,1,['variab'],['variables']
Modifiability,"le: 'Oceananigans.jl: Fast and friendly geophysical fluid dynamics on GPUs'; tags:; - fluid; - ocean; - climate; - Julia; - gpu; authors:; - name: Ali Ramadhan; orcid: 0000-0003-1102-1520; affiliation: 1; - name: Gregory LeClaire Wagner; orcid: 0000-0001-5317-2445; affiliation: 1; - name: Chris Hill; affiliation: 1; - name: Jean-Michel Campin; affiliation: 1; - name: Valentin Churavy; affiliation: 1; - name: Tim Besard; affiliation: 2; - name: Andre Souza; affiliation: 1; - name: Alan Edelman; affiliation: 1; - name: Raffaele Ferrari; affiliation: 1; - name: John Marshall; affiliation: 1; affiliations:; - name: Massachusetts Institute of Technology; index: 1; - name: Julia Computing, Inc.; index: 2; date: 11 August 2020; bibliography: paper.bib; ---. # Summary. ``Oceananigans.jl`` is a fast and friendly software package for the numerical; simulation of incompressible, stratified, rotating fluid flows on CPUs and GPUs.; ``Oceananigans.jl`` is fast and flexible enough for research yet simple enough; for students and first-time programmers. ``Oceananigans.jl`` is being developed; as part of the Climate Modeling Alliance project for the simulation of; small-scale ocean physics at high-resolution that affect the evolution of; Earth‚Äôs climate. ``Oceananigans.jl`` is designed for high-resolution simulations in idealized; geometries and supports direct numerical simulation, large eddy simulation,; arbitrary numbers of active and passive tracers, and linear and nonlinear; equations of state for seawater. Under the hood, ``Oceananigans.jl`` employs a; finite volume algorithm similar to that used by the Massachusetts Institute of; Technology general circulation model [@Marshall1997]. ![Fig. 1](free_convection_and_baroclinic_instability.png); Fig. 1: (Left) Large eddy simulation of small-scale oceanic boundary layer; turbulence forced by a surface cooling in a horizontally periodic domain using; $256^3$ grid points. The upper layer is well-mixed by turbulent convection and; boun",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md:973,flexible,flexible,973,paper/paper.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md,1,['flexible'],['flexible']
Modifiability,"max(N¬≤, zero(typeof(N¬≤))). return @inbounds - Œµ * sqrt(N¬≤) * model_fields.u[i, j, k]; end. u_forcing = Forcing(u_forcing_func, discrete_form=true, parameters=1e-3). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, tracers=:b, buoyancy=BuoyancyTracer(), forcing=(u=u_forcing, b=b_forcing)). model.forcing.b. # output; DiscreteForcing{Nothing}; ‚îú‚îÄ‚îÄ func: b_forcing_func (generic function with 1 method); ‚îî‚îÄ‚îÄ parameters: nothing; ```. ```jldoctest discrete_forcing; model.forcing.u. # output; DiscreteForcing{Float64}; ‚îú‚îÄ‚îÄ func: u_forcing_func (generic function with 1 method); ‚îî‚îÄ‚îÄ parameters: 0.001; ```. The annotation `@inbounds` is crucial for performance when accessing array indices; of the fields in `model_fields`. ## `Relaxation`. `Relaxation` defines a special forcing function that restores a field at a specified `rate` to; a `target` distribution, within a region uncovered by a `mask`ing function.; `Relaxation` is useful for implementing sponge layers, as shown in the second example. The following code constructs a model in which all components; of the velocity field are damped to zero everywhere on a time-scale of 1000 seconds, or ~17 minutes:. ```jldoctest; damping = Relaxation(rate = 1/1000). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = NonhydrostaticModel(grid=grid, forcing=(u=damping, v=damping, w=damping)). model.forcing.w. # output; ContinuousForcing{Nothing} at (Center, Center, Face); ‚îú‚îÄ‚îÄ func: Relaxation(rate=0.001, mask=1, target=0); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:w,); ```. The constructor for `Relaxation` accepts the keyword arguments `mask`, and `target`,; which specify a `mask(x, y, z)` function that multiplies the forcing, and a `target(x, y, z)`; distribution for the quantity in question. By default, `mask` uncovered the whole domain; and `target` restores the field in question to 0. We illustrate usage of `mask` and `target` by implementing a sponge layer that rel",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:8155,layers,layers,8155,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['layers'],['layers']
Modifiability,"model in one language and a common code base for execution on; the CPU or GPU with Julia‚Äôs native GPU compiler [@Besard2019]. Because Julia is; a high-level language, development is streamlined and users can flexibly specify; model configurations, set up arbitrary diagnostics and output, extend the code; base, and implement new features. Configuring a model with `architecture=CPU()`; or `architecture=GPU()` will execute the model on the CPU or GPU. By pinning a; simulation script against a specific version of Oceananigans, simulation results; are reproducible up to hardware differences. Performance benchmarks show significant speedups when running on a GPU. Large; simulations on an Nvidia Tesla V100 GPU require ~1 nanosecond per grid point per; iteration. GPU simulations are therefore roughly 3x more cost-effective; than CPU simulations on cloud computing platforms such as Google Cloud. A GPU; with 32 GB of memory can time-step models with ~150 million grid points assuming; five fields are being evolved; for example, three velocity components and; tracers for temperature and salinity. These performance gains permit the; long-time integration of realistic simulations, such as large eddy simulation of; oceanic boundary layer turbulence over a seasonal cycle or the generation of; training data for turbulence parameterizations in Earth system models. ``Oceananigans.jl`` is continuously tested on CPUs and GPUs with unit tests,; integration tests, analytic solutions to the incompressible Navier-Stokes; equations, convergence tests, and verification experiments against published; scientific results. Future development plans include support for distributed; parallelism with CUDA-aware MPI as well as topography. Ocean models that are similar to ``Oceananigans.jl`` include MITgcm; [@Marshall1997] and MOM6 [@Adcroft2019], both written in Fortran. However,; ``Oceananigans.jl`` features a more efficient non-hydrostatic pressure solver; than MITgcm (and MOM6 is strictly hydrostat",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md:3595,evolve,evolved,3595,paper/paper.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md,1,['evolve'],['evolved']
Modifiability,"much as possible ""behind the scenes"".; Yet Oceananigans' flexibility places some responsibility on users to ensure high performance simulations,; especially for complex setups with user-defined forcing functions, boundary condition functions, and diagnostics.; Furthermore, in case of more complex GPU runs, some details could; sometimes prevent your simulation from running altogether. While Julia knowledge is obviously; desirable here, a user that is unfamiliar with Julia can get away with efficient simulations by; learning a few rules of thumb. It is nonetheless recommended that users go through Julia's; [performance tips](https://docs.julialang.org/en/v1/manual/performance-tips/), which contains more; in-depth explanations of some of the aspects discussed here. ## General (CPU/GPU) simulation tips. ### Avoid global variables whenever possible. In general using a [global; variable](https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Global-Scope) (which can be; loosely defined as a variable defined in the main script) inside functions slows down the code. One; way to circumvent this is to always [use local variables or pass them as arguments to; functions](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). This; helps the compiler optimize the code. Another way around this is to [define global variables as constants whenever; possible](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). One; thing to keep in mind when doing this is that when a `const` is defined, its value can't be changed; until you restart the Julia session. So this latter approach is good for production-ready code, but; may be undesirable in the early stages of development while you still have to change the parameters; of the simulation for exploration. It is especially important to avoid global variables in functions that are meant to be executed in; GPU kernels (such as functions defining boundary conditions and forcings)",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:1027,variab,variables-and-scoping,1027,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,2,['variab'],"['variable', 'variables-and-scoping']"
Modifiability,"n, S., and Lim, H. S. (2021). [Observation-Large eddy simulation comparison of ocean mixing under Typhoon Soulik (2018)](https://doi.org/10.23919/OCEANS44145.2021.9705670), _OCEANS 2021: San Diego ‚Äì Porto, 2021_, pp. 1-7. DOI: [10.23919/OCEANS44145.2021.9705670](https://doi.org/10.23919/OCEANS44145.2021.9705670). 1. Arnscheidt, C. W., Marshall, J., Dutrieux, P., Rye, C. D., and Ramadhan, A. (2021). [On the settling depth of meltwater escaping from beneath Antarctic ice shelves](https://doi.org/10.1175/JPO-D-20-0286.1), _Journal of Physical Oceanography_, **51(7)**, 2257‚Äì2270. DOI: [10.1175/JPO-D-20-0178.1](https://doi.org/10.1175/JPO-D-20-0286.1). 1. Wagner, G. L., Chini, G. P., Ramadhan, A., Gallet, B., and Ferrari, R. (2021). [Near-inertial waves and turbulence driven by the growth of swell](https://doi.org/10.1175/JPO-D-20-0178.1), _Journal of Physical Oceanography_, **51(5)**, 1337-1351. DOI: [10.1175/JPO-D-20-0178.1](https://doi.org/10.1175/JPO-D-20-0178.1). 1. Buffett, B. A. (2021). [Conditions for turbulent Ekman layers in precessionally driven flow](https://doi.org/10.1093/gji/ggab088), _Geophysical Journal International_, **226(1)**, 56‚Äì65. DOI: [10.1093/gji/ggab088](https://doi.org/10.1093/gji/ggab088). 1. Bhamidipati, N., Souza, A.N., and Flierl, G.R. (2020). [Turbulent mixing of a passive scalar in the ocean mixed layer](https://doi.org/10.1016/j.ocemod.2020.101615), _Ocean Modelling_, **149**, 101615. DOI: [10.1016/j.ocemod.2020.101615](https://doi.org/10.1016/j.ocemod.2020.101615). 1. Souza, A. N., Wagner, G. L., Ramadhan, A., Allen, B., Churavy, V., Schloss, J., Campin, J. M., Hill, C., Edelman, A., Marshall, J., Flierl, G., and Ferrari, R. (2020). [Uncertainty quantification of ocean parameterizations: Application to the K‚ÄêProfile‚ÄêParameterization for penetrative convection](https://doi.org/10.1029/2020MS002108), _Journal of Advances in Modeling Earth Systems_, **12**, e2020MS002108. DOI: [10.1029/2020MS002108](https://doi.org/10.1029/2020MS002108); ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md:12062,layers,layers,12062,docs/src/index.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md,2,"['layers', 'parameteriz']","['layers', 'parameterizations']"
Modifiability,"nd `z` spans `z=0` to `z=8`.; * Has cells that are all the same size, dividing the box in 512 that each has dimension ``4 \times 4 \times 2``.; Note that length units are whatever is used to construct the grid, so it's up to the user to make sure that all inputs use consistent units. In building our first grid, we did not specify whether it should be constructed on the [`CPU`](@ref)` or [`GPU`](@ref).; As a result, the grid was constructed by default on the CPU.; Next we build a grid on the _GPU_ that's two-dimensional in ``x, z`` and has variably-spaced cell interfaces in the `z`-direction,. ```jldoctest grids_gpu; architecture = GPU(); z_faces = [0, 1, 3, 6, 10]. grid = RectilinearGrid(architecture,; topology = (Periodic, Flat, Bounded),; size = (10, 4),; x = (0, 20),; z = z_faces). # output; 10√ó1√ó4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on GPU with 3√ó0√ó3 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 20.0) regularly spaced with Œîx=2.0; ‚îú‚îÄ‚îÄ Flat y; ‚îî‚îÄ‚îÄ Bounded z ‚àà [0.0, 10.0] variably spaced with min(Œîz)=1.0, max(Œîz)=4.0; ```. !!! note ""GPU architecture requires a CUDA-enabled device""; To run the above example and create a grid on the GPU, an Nvidia GPU has to be available; and [`CUDA.jl`](https://cuda.juliagpu.org/stable/) must be working). For more information; see the [`CUDA.jl` documentation](https://cuda.juliagpu.org/stable/). The ``y``-dimension is ""missing"" because it's marked `Flat` in `topology = (Periodic, Flat, Bounded)`.; So nothing varies in ``y``: `y`-derivatives are 0.; Also, the keyword argument (or ""kwarg"" for short) that specifies the ``y``-domains may be omitted, and `size` has only two elements rather than 3 as in the first example.; In the stretched cell interfaces specified by `z_interfaces`, the number of; vertical cell interfaces is `Nz + 1 = length(z_interfaces) = 5`, where `Nz = 4` is the number; of cells in the vertical. A bit later in this tutorial, we'll give examples that illustrate how to build a grid thats [`Distributed`](@ref) across _mul",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:2607,variab,variably,2607,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['variab'],['variably']
Modifiability,"nfigurations, set up arbitrary diagnostics and output, extend the code; base, and implement new features. Configuring a model with `architecture=CPU()`; or `architecture=GPU()` will execute the model on the CPU or GPU. By pinning a; simulation script against a specific version of Oceananigans, simulation results; are reproducible up to hardware differences. Performance benchmarks show significant speedups when running on a GPU. Large; simulations on an Nvidia Tesla V100 GPU require ~1 nanosecond per grid point per; iteration. GPU simulations are therefore roughly 3x more cost-effective; than CPU simulations on cloud computing platforms such as Google Cloud. A GPU; with 32 GB of memory can time-step models with ~150 million grid points assuming; five fields are being evolved; for example, three velocity components and; tracers for temperature and salinity. These performance gains permit the; long-time integration of realistic simulations, such as large eddy simulation of; oceanic boundary layer turbulence over a seasonal cycle or the generation of; training data for turbulence parameterizations in Earth system models. ``Oceananigans.jl`` is continuously tested on CPUs and GPUs with unit tests,; integration tests, analytic solutions to the incompressible Navier-Stokes; equations, convergence tests, and verification experiments against published; scientific results. Future development plans include support for distributed; parallelism with CUDA-aware MPI as well as topography. Ocean models that are similar to ``Oceananigans.jl`` include MITgcm; [@Marshall1997] and MOM6 [@Adcroft2019], both written in Fortran. However,; ``Oceananigans.jl`` features a more efficient non-hydrostatic pressure solver; than MITgcm (and MOM6 is strictly hydrostatic). PALM [@Maronga2020] is Fortran; software for large eddy simulation of atmospheric and oceanic boundary layers; with complex boundaries on parallel CPU and GPU architectures. ``Oceananigans.jl``; is distinguished by its use of Juli",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md:3911,parameteriz,parameterizations,3911,paper/paper.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md,1,['parameteriz'],['parameterizations']
Modifiability,"ns`, may be computed from an `operand` ; or expression involving other fields, and may cover only a portion of the total; `indices` spanned by the grid. ## Staggered grids and field locations. Oceananigans ocean-flavored fluids simulations rely fundamentally on; ""staggered grid"" numerical methods. Recall that [grids](@ref grids_tutorial) represent a physical domain divided into finite volumes.; For example, let's consider a horizontally-periodic, vertically-bounded grid of cells; that divide up a cube with dimensions ``1 \times 1 \times 1``:. ```jldoctest fields; using Oceananigans. grid = RectilinearGrid(topology = (Periodic, Periodic, Bounded),; size = (4, 5, 4),; halo = (1, 1, 1),; x = (0, 1),; y = (0, 1),; z = [0, 0.1, 0.3, 0.6, 1]). # output; 4√ó5√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 1.0) regularly spaced with Œîx=0.25; ‚îú‚îÄ‚îÄ Periodic y ‚àà [0.0, 1.0) regularly spaced with Œîy=0.2; ‚îî‚îÄ‚îÄ Bounded z ‚àà [0.0, 1.0] variably spaced with min(Œîz)=0.1, max(Œîz)=0.4; ```. The cubic domain is divided into a ""primary mesh"" of ``4 \times 5 \times 4 = 80`` cells,; which are evenly spaced in ``x, y`` but variably spaced in ``z``.; Now, in addition to the primary mesh, the grid defines also a set of ""staggered"" grids whose cells are; shifted by half a cell width relative to the primary mesh.; In other words, the staggered grid cells have a ""location"" in each direction -- either `Center`,; and therefore co-located with the primary mesh, or `Face` and located over the interfaces of the; primary mesh.; For example, the primary or `Center` cell spacings in ``z`` are. ```jldoctest fields; zspacings(grid, Center()). # output; 4-element view(OffsetArray(::Vector{Float64}, 0:5), 1:4) with eltype Float64:; 0.1; 0.19999999999999998; 0.3; 0.4; ```. corresponding to cell interfaces located at `z = [0, 0.1, 0.3, 0.6, 1]`.; But then for the grid which is staggered in `z` relative to the primary mesh,. ```jldoctest fields; zspacings(gri",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md:1274,variab,variably,1274,docs/src/fields.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md,1,['variab'],['variably']
Modifiability,"oisson equation for the non-hydrostatic kinematic pressure; ```math; \begin{equation}; \label{eq:poisson-pressure}; \nabla^2 p_{NH} = \frac{\boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{v}^n}{\Delta t} + \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{G}_{\boldsymbol{v}} \equiv \mathscr{F} \, ,; \end{equation}; ```; along with homogenous Neumann boundary conditions ``\boldsymbol{v} \cdot \boldsymbol{\hat{n}} = 0`` ; (Neumann on ``p`` for wall-bounded directions and periodic otherwise) and where ``\mathscr{F}`` ; denotes the source term for the Poisson equation. !!! note ""Hydrostatic approximation""; For problems in which the hydrostatic approximation is invoked, the Poisson equation for; pressure above only needs to be solved for the vertically integrated flow and the pressure; field is a two dimensional term ``p_S(x, y, t)``. ## Direct method. Discretizing elliptic problems that can be solved via a classical separation-of-variables approach, such as Poisson's; equation, results in a linear system of equations ``M \boldsymbol{x} = \boldsymbol{y}`` where ``M`` is a real symmetric matrix of block; tridiagonal form. This allows for the matrix to be decomposed and solved efficiently, provided that the eigenvalues and; eigenvectors of the blocks are known (¬ß2) [Buzbee70](@cite). In the case of Poisson's equation on a rectangle,; [Hockney65](@citet) has taken advantage of the fact that the fast Fourier transform can be used to perform the matrix; multiplication steps resulting in an even more efficient method. [Schumann88](@citet) describe the implementation of such; an algorithm for Poisson's equation on a staggered grid with Dirichlet, Neumann, and periodic boundary conditions. The method can be explained easily by taking the Fourier transform of both sides of \eqref{eq:poisson-pressure} to yield; ```math; \begin{equation}; \label{eq:poisson-spectral}; -(k_x^2 + k_y^2 + k_z^2) \widehat{p}_{NH} = \widehat{\mathscr{F}}; \quad \implies \quad; \widehat{p}_{NH} = - \f",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:1197,variab,variables,1197,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['variab'],['variables']
Modifiability,"ongitudeGrid`. These keyword arguments specify the extent and location of the finite volume cells that divide up the; three dimensions of the grid.; For `RectilinearGrid`, the dimensions are called `x`, `y`, and `z`, whereas for `LatitudeLongitudeGrid` the; dimensions are called `latitude`, `longitude`, and `z`.; The type of each keyword argument determines how the dimension is divided up:. * Tuples that specify only the end points indicate that the dimension should be divided into; equally-spaced cells. For example, `x = (0, 64)` with `size = (16, 8, 4)` means that the; `x`-dimension is divided into 16 cells, where the first or leftmost cell interface is located; at `x = 0` and the last or rightmost cell interface is located at `x = 64`. The width of each cell is `Œîx=4.0`.; * Vectors and functions alternatively give the location of each cell interface, and thereby may be used; to build grids that are divided into cells of varying width. ## A complicated example: three-dimensional `RectilinearGrid` with variable spacing via functions. Next we build a grid that is both `Bounded` and stretched in both the `y` and `z` directions.; The purpose of the stretching is to increase grid resolution near the boundaries.; We'll do this by using functions to specify the keyword arguments `y` and `z`. ```jldoctest grids; Nx = Ny = 64; Nz = 32. Lx = Ly = 1e4; Lz = 1e3. # Note that j varies from 1 to Ny; chebychev_spaced_y_faces(j) = Ly * (1 - cos(œÄ * (j - 1) / Ny)) / 2. # Note that k varies from 1 to Nz; chebychev_spaced_z_faces(k) = - Lz * (1 + cos(œÄ * (k - 1) / Nz)) / 2. grid = RectilinearGrid(size = (Nx, Ny, Nz),; topology = (Periodic, Bounded, Bounded),; x = (0, Lx),; y = chebychev_spaced_y_faces,; z = chebychev_spaced_z_faces). # output; 64√ó64√ó32 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 10000.0) regularly spaced with Œîx=156.25; ‚îú‚îÄ‚îÄ Bounded y ‚àà [0.0, 10000.0] variably spaced with min(Œîy)=6.02272, max(Œîy)=245.338; ‚îî‚îÄ‚îÄ Bou",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:16105,variab,variable,16105,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['variab'],['variable']
Modifiability,"ons, and diagnostics.; Furthermore, in case of more complex GPU runs, some details could; sometimes prevent your simulation from running altogether. While Julia knowledge is obviously; desirable here, a user that is unfamiliar with Julia can get away with efficient simulations by; learning a few rules of thumb. It is nonetheless recommended that users go through Julia's; [performance tips](https://docs.julialang.org/en/v1/manual/performance-tips/), which contains more; in-depth explanations of some of the aspects discussed here. ## General (CPU/GPU) simulation tips. ### Avoid global variables whenever possible. In general using a [global; variable](https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Global-Scope) (which can be; loosely defined as a variable defined in the main script) inside functions slows down the code. One; way to circumvent this is to always [use local variables or pass them as arguments to; functions](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). This; helps the compiler optimize the code. Another way around this is to [define global variables as constants whenever; possible](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). One; thing to keep in mind when doing this is that when a `const` is defined, its value can't be changed; until you restart the Julia session. So this latter approach is good for production-ready code, but; may be undesirable in the early stages of development while you still have to change the parameters; of the simulation for exploration. It is especially important to avoid global variables in functions that are meant to be executed in; GPU kernels (such as functions defining boundary conditions and forcings). Otherwise the Julia GPU; compiler can fail with obscure errors. This is explained in more detail in the GPU simulation tips; section below. ### Consider inlining small functions. Inlining is when the compiler [replaces a function call wi",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:1349,variab,variables,1349,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['variab'],['variables']
Modifiability,"ons,; especially for complex setups with user-defined forcing functions, boundary condition functions, and diagnostics.; Furthermore, in case of more complex GPU runs, some details could; sometimes prevent your simulation from running altogether. While Julia knowledge is obviously; desirable here, a user that is unfamiliar with Julia can get away with efficient simulations by; learning a few rules of thumb. It is nonetheless recommended that users go through Julia's; [performance tips](https://docs.julialang.org/en/v1/manual/performance-tips/), which contains more; in-depth explanations of some of the aspects discussed here. ## General (CPU/GPU) simulation tips. ### Avoid global variables whenever possible. In general using a [global; variable](https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Global-Scope) (which can be; loosely defined as a variable defined in the main script) inside functions slows down the code. One; way to circumvent this is to always [use local variables or pass them as arguments to; functions](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). This; helps the compiler optimize the code. Another way around this is to [define global variables as constants whenever; possible](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). One; thing to keep in mind when doing this is that when a `const` is defined, its value can't be changed; until you restart the Julia session. So this latter approach is good for production-ready code, but; may be undesirable in the early stages of development while you still have to change the parameters; of the simulation for exploration. It is especially important to avoid global variables in functions that are meant to be executed in; GPU kernels (such as functions defining boundary conditions and forcings). Otherwise the Julia GPU; compiler can fail with obscure errors. This is explained in more detail in the GPU simulation tips; section below.",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:1227,variab,variables,1227,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['variab'],['variables']
Modifiability,"ore roughly 3x more cost-effective; than CPU simulations on cloud computing platforms such as Google Cloud. A GPU; with 32 GB of memory can time-step models with ~150 million grid points assuming; five fields are being evolved; for example, three velocity components and; tracers for temperature and salinity. These performance gains permit the; long-time integration of realistic simulations, such as large eddy simulation of; oceanic boundary layer turbulence over a seasonal cycle or the generation of; training data for turbulence parameterizations in Earth system models. ``Oceananigans.jl`` is continuously tested on CPUs and GPUs with unit tests,; integration tests, analytic solutions to the incompressible Navier-Stokes; equations, convergence tests, and verification experiments against published; scientific results. Future development plans include support for distributed; parallelism with CUDA-aware MPI as well as topography. Ocean models that are similar to ``Oceananigans.jl`` include MITgcm; [@Marshall1997] and MOM6 [@Adcroft2019], both written in Fortran. However,; ``Oceananigans.jl`` features a more efficient non-hydrostatic pressure solver; than MITgcm (and MOM6 is strictly hydrostatic). PALM [@Maronga2020] is Fortran; software for large eddy simulation of atmospheric and oceanic boundary layers; with complex boundaries on parallel CPU and GPU architectures. ``Oceananigans.jl``; is distinguished by its use of Julia which allows for a script-based interface as; opposed to a configuration-file-based interface used by MITgcm, MOM6, and PALM.; Dedalus [@Burns2020] is Python software with an intuitive script-based interface; that solves general partial differential equations, including the incompressible; Navier-Stokes equations, with spectral methods. # Acknowledgements. Our work is supported by the generosity of Eric and Wendy Schmidt by; recommendation of the Schmidt Futures program, and by the National Science; Foundation under grant AGS-6939393. # References; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md:4692,layers,layers,4692,paper/paper.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md,2,"['config', 'layers']","['configuration-file-based', 'layers']"
Modifiability,"ould be used:. 1. [`RectilinearGrid`](@ref Oceananigans.Grids.RectilinearGrid) can be fashioned into lines, rectangles and boxes.; 2. [`LatitudeLongitudeGrid`](@ref Oceananigans.Grids.LatitudeLongitudeGrid) represents sectors of thin spherical shells, with cells bounded by lines of constant latitude and longitude.; 3. [`OrthogonalSphericalShellGrid`](@ref Oceananigans.Grids.OrthogonalSphericalShellGrid) represents sectors of thin spherical shells divided with mesh lines that intersect at right angles (thus, orthogonal) but are otherwise arbitrary. !!! note ""OrthogonalSphericalShellGrids.jl""; See the auxiliary package [`OrthogonalSphericalShellGrids.jl`](https://github.com/CliMA/OrthogonalSphericalShellGrids.jl); for recipes that implement some useful `OrthogonalSphericalShellGrid`, including the; [""tripolar"" grid](https://www.sciencedirect.com/science/article/abs/pii/S0021999196901369). For example, to make a `LatitudeLongitudeGrid` that wraps around the sphere, extends for 60 degrees latitude on either side of the equator, and also has 5 vertical levels down to 1000 meters, we write. ```jldoctest grids; architecture = CPU(). grid = LatitudeLongitudeGrid(architecture,; size = (180, 10, 5),; longitude = (-180, 180),; latitude = (-60, 60),; z = (-1000, 0)). # output; 180√ó10√ó5 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3√ó3√ó3 halo and with precomputed metrics; ‚îú‚îÄ‚îÄ longitude: Periodic Œª ‚àà [-180.0, 180.0) regularly spaced with ŒîŒª=2.0; ‚îú‚îÄ‚îÄ latitude: Bounded œÜ ‚àà [-60.0, 60.0] regularly spaced with ŒîœÜ=12.0; ‚îî‚îÄ‚îÄ z: Bounded z ‚àà [-1000.0, 0.0] regularly spaced with Œîz=200.0; ```. The main difference between the syntax for `LatitudeLongitudeGrid` versus that for the `RectilinearGrid` are the names of the horizontal coordinates:; `LatitudeLongitudeGrid` has `longitude` and `latitude` where `RectilinearGrid` has `x` and `y`. !!! note ""Extrinsic and intrinsic coordinate systems""; Every grid is associated with an ""extrinsic"" coordinate system: `Rectilinea",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:4728,extend,extends,4728,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['extend'],['extends']
Modifiability,"ow the horizontally averaged temperature profile (top right), horizontally averaged turbulent kinetic energy; (middle right), and the horizontally averaged buoyancy flux (or temperature flux). [![Watch winds blowing over the ocean](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_0400.png)](https://www.youtube.com/watch?v=IRncfbvuiy8). ## [Free convection with wind stress](https://www.youtube.com/watch?v=ob6OMQgPfI4). An idealized simulation of a strong wind stress acting on the surface of a stratified ocean along with a cooling flux; that sucks heat out of the surface. The simulation employs a resolution of 256x256x256 volumes in a 100x100x100 m; horizontally periodic domain. A pretty strong wind stress of 0.1 N/m¬≤ is applied in the x direction which mechanically; mixes the upper layer of the ocean. Also, heat is sucked out of the ocean surface at a rate of 75 W/m¬≤ which cools the; surface water and making it denser. This cold dense water then sinks into the ocean interior, initiating a convective; process that keeps mixing the upper layer of the ocean. This leads to a ""mixed layer"" of constant temperature near the; surface of the ocean. You can also see the onset of Kelvin-Helmholtz instabilities as the mechanical mixing sets in. The video shows the temperature field and the domain is sliced in half for visualization. The line plots show the; horizontally averaged temperature profile (top right), horizontally averaged turbulent kinetic energy (middle right),; and the horizontally averaged buoyancy flux (or temperature flux). The unusual periodic prism colormap is used to show; the fine details at the surface as it cools and the layers of different temperatures (the isopycnals) being perturbed; by internal waves. [![Watch free convection with wind stress in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_unstable_7500.png)](https://www.youtube.com/watch?v=ob6OMQgPfI4). ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/gallery.md:4290,layers,layers,4290,docs/src/gallery.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/gallery.md,1,['layers'],['layers']
Modifiability,"p = quote; using Oceananigans; end; ```. Forcings are added to models by passing a `NamedTuple` of functions or forcing objects; to the `forcing` keyword argument in `NonhydrostaticModel`'s constructor.; By default, momentum and tracer forcing functions are assumed to be functions of; `x, y, z, t`. A basic example is. ```jldoctest; u_forcing(x, y, z, t) = exp(z) * cos(x) * sin(t). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, forcing=(u=u_forcing,)). model.forcing.u. # output; ContinuousForcing{Nothing} at (Face, Center, Center); ‚îú‚îÄ‚îÄ func: u_forcing (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (); ```. More general forcing functions are built via the `Forcing` constructor; described below. `Oceananigans` also provides two convenience types:. * `Relaxation` for damping terms that restore a field to a; target distribution outside of a masked region of space. `Relaxation` can be; used to implement sponge layers near the boundaries of a domain.; * `AdvectiveForcing` for advecting individual quantities by a separate or; ""slip"" velocity relative to both the prognostic model velocity field and any; `BackgroundField` velocity field. ## The `Forcing` constructor. The `Forcing` constructor provides an interface for specifying forcing functions that. 1. Depend on external parameters; and; 2. Depend on model fields at the `x, y, z` location that forcing is applied; and/or; 3. Require access to discrete model data. ### Forcing functions with external parameters. Most forcings involve external, changeable parameters.; Here are two examples of `forcing_func`tions that depend on ; _(i)_ a single scalar parameter `s`, and _(ii)_ a `NamedTuple` of parameters, `p`:. ```jldoctest parameterized_forcing; # Forcing that depends on a scalar parameter `s`; u_forcing_func(x, y, z, t, s) = s * z. u_forcing = Forcing(u_forcing_func, parameters=0.1). # Forcing that depends on a `NamedTuple` of parameters `p",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:1413,layers,layers,1413,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['layers'],['layers']
Modifiability,"quest](https://docs.github.com/en/github/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork). Pull requests are reviewed by Oceananigans collaborators. * A pull request can be merged once it is reviewed and approved by collaborators. If the pull request author has write access, they have the responsibility of merging their pull request. Otherwise, Oceananigans.jl collaborators will execute the merge with permission from the pull request author. * Note: for small or minor changes (such as fixing a typo in documentation), the [GitHub editor](https://docs.github.com/en/github/managing-files-in-a-repository/managing-files-on-github/editing-files-in-your-repository) is super useful for forking and opening a pull request with a single click. * Write your code with love and care. In particular, conform to existing Oceananigans style and formatting conventions. For example, we love verbose and explicit variable names, use `TitleCase` for types, `snake_case` for objects, and always,put,spaces.after.commas,or.periods. For formatting decisions we loosely follow the [YASGuide](https://github.com/jrevels/YASGuide). It's worth few extra minutes of our time to leave future generations with well-written, readable code. ## What is a ""collaborator"" and how can I become one?. * Collaborators have permissions to review pull requests and status allows a contributor to review pull requests in addition to opening them. Collaborators can also create branches in the main Oceananigans repository. * We ask that new contributors try their hand at forking Oceananigans, and opening and merging a pull request before requesting collaborator status. ## What's a good way to start developing Oceananigans?. * Tackle an existing issue. We keep a list of [good first issues](https://github.com/CLiMA/Oceananigans.jl/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22); that are self-contained and suitable for a newcomer to try an",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:3109,variab,variable,3109,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['variab'],['variable']
Modifiability,"r; the channel walls. We construct a grid that has non-regular spacing in the bounded dimensions, here ``y`` and ``z``; by prescribing functions for `y` and `z` keyword arguments. For example, we can use the Chebychev nodes, which are more closely stacked near boundaries, to prescribe the; ``y``- and ``z``-faces. ```jldoctest; julia> Nx, Ny, Nz = 64, 64, 32;. julia> Lx, Ly, Lz = 1e4, 1e4, 1e3;. julia> chebychev_spaced_y_faces(j) = - Ly/2 * cos(œÄ * (j - 1) / Ny);. julia> chebychev_spaced_z_faces(k) = - Lz/2 - Lz/2 * cos(œÄ * (k - 1) / Nz);. julia> grid = RectilinearGrid(size = (Nx, Ny, Nz),; topology = (Periodic, Bounded, Bounded),; x = (0, Lx),; y = chebychev_spaced_y_faces,; z = chebychev_spaced_z_faces); 64√ó64√ó32 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 10000.0) regularly spaced with Œîx=156.25; ‚îú‚îÄ‚îÄ Bounded y ‚àà [-5000.0, 5000.0] variably spaced with min(Œîy)=6.02272, max(Œîy)=245.338; ‚îî‚îÄ‚îÄ Bounded z ‚àà [-1000.0, 0.0] variably spaced with min(Œîz)=2.40764, max(Œîz)=49.0086; ```. ```@setup 1; using Oceananigans; using CairoMakie; CairoMakie.activate!(type = ""svg""); Nx, Ny, Nz = 64, 64, 32; Lx, Ly, Lz = 1e4, 1e4, 1e3; chebychev_spaced_y_faces(j) = - Ly/2 * cos(œÄ * (j - 1) / Ny);; chebychev_spaced_z_faces(k) = - Lz/2 - Lz/2 * cos(œÄ * (k - 1) / Nz);; grid = RectilinearGrid(size = (Nx, Ny, Nz),; topology = (Periodic, Bounded, Bounded),; x = (0, Lx),; y = chebychev_spaced_y_faces,; z = chebychev_spaced_z_faces); ```. We can easily visualize the spacings of ``y`` and ``z`` directions. We can use, e.g.,; [`ynodes`](@ref) and [`yspacings`](@ref) to extract the positions and spacings of the; nodes from the grid. ```@example 1; y·∂ú = ynodes(grid, Center()); Œîy·∂ú = yspacings(grid, Center()). z·∂ú = znodes(grid, Center()); Œîz·∂ú = zspacings(grid, Center()). using CairoMakie. fig = Figure(size=(800, 900)). ax1 = Axis(fig[1, 1]; xlabel = ""y (m)"", ylabel = ""y-spacing (m)"", limits = (nothing, (0, 250))); lines!(ax1, y·∂ú, Œîy·∂ú); scatter!(ax",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/legacy_grids.md:5649,variab,variably,5649,docs/src/model_setup/legacy_grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/legacy_grids.md,1,['variab'],['variably']
Modifiability,"rmed on a staggered grid, DCT-II (`REDFT10`) is used to perform the forward cosine transform and DCT-III; (`REDFT01`) is used to perform the inverse cosine transform. ## Direct method with a vertically stretched grid. Using Fourier transforms for all three dimensions results in a method requiring ``\mathcal{O}(N \log_2 N)`` operations; where ``N`` is the total number of grid points. This algorithm can be made even more efficient by solving a tridiagonal; system along one of the dimensions and utilizing cyclic reduction. This results in the *Fourier analysis cyclic; reduction* or ``\text{FACR}(\ell)`` algorithm (with ``\ell`` cyclic reduction steps) which requires only; ``\mathcal{O}(N \log_2\log_2 N)`` operations provided the optimal number of cyclic reduction steps is taken, which is; ``\ell = \log_2 \log_2 n`` where ``n`` is the number of grid points in the cyclic reduction dimension. The FACR algorithm; was first developed by [Hockney69](@citet) and is well reviewed by [Swarztrauber77](@citet) then further benchmarked and; extended by [Temperton79](@citet) and [Temperton80](@citet). Furthermore, the FACR algorithm removes the restriction that the grid is uniform in one of the dimensions so it can; be utilized to implement a fast Poisson solver for vertically stretched grids if the cyclic reduction is applied in the; along the vertical dimension. Expanding ``p_{NH}`` and ``\mathscr{F}`` into Fourier modes along the ``x`` and ``y`` directions; ```math; p_{ijk} = \sum_{m=1}^{N_x} \sum_{n=1}^{N_y} \tilde{p}_{mnk} \; e^{-\mathrm{i} 2\pi i m / N_x} \; e^{-\mathrm{i} 2\pi j n / N_y} \, ,; ```; and recalling that Fourier transforms do ``\partial_x \rightarrow \mathrm{i} k_x`` and ``\partial_y \rightarrow \mathrm{i} k_y`` we can write; \eqref{eq:poisson-pressure} as; ```math; \sum_{m=1}^{N_x} \sum_{n=1}^{N_y}; \left\lbrace; \partial_z^2 \tilde{p}_{mnk} - (k_x^2 + k_y^2) \tilde{p}_{mnk} - \tilde{\mathscr{F}}_{mnk}; \right\rbrace e^{-\mathrm{i} 2 \pi i m / N_x} e^{-\mathrm{i",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:5744,extend,extended,5744,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['extend'],['extended']
Modifiability,"rom running altogether. While Julia knowledge is obviously; desirable here, a user that is unfamiliar with Julia can get away with efficient simulations by; learning a few rules of thumb. It is nonetheless recommended that users go through Julia's; [performance tips](https://docs.julialang.org/en/v1/manual/performance-tips/), which contains more; in-depth explanations of some of the aspects discussed here. ## General (CPU/GPU) simulation tips. ### Avoid global variables whenever possible. In general using a [global; variable](https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Global-Scope) (which can be; loosely defined as a variable defined in the main script) inside functions slows down the code. One; way to circumvent this is to always [use local variables or pass them as arguments to; functions](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). This; helps the compiler optimize the code. Another way around this is to [define global variables as constants whenever; possible](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). One; thing to keep in mind when doing this is that when a `const` is defined, its value can't be changed; until you restart the Julia session. So this latter approach is good for production-ready code, but; may be undesirable in the early stages of development while you still have to change the parameters; of the simulation for exploration. It is especially important to avoid global variables in functions that are meant to be executed in; GPU kernels (such as functions defining boundary conditions and forcings). Otherwise the Julia GPU; compiler can fail with obscure errors. This is explained in more detail in the GPU simulation tips; section below. ### Consider inlining small functions. Inlining is when the compiler [replaces a function call with the body of the function that is being; called before compiling](https://en.wikipedia.org/wiki/Inline_expansion). The adv",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:1450,variab,variables,1450,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['variab'],['variables']
Modifiability,"the *closure problem*: the time evolution of the Reynolds stresses; depends on triple covariances ``\overline{v_i^\prime v_j^\prime v_k^\prime}`` and covariances with pressure, which depend; on quadruple covariances and so on [Chou45](@cite). This is kind of hopeless so we will have to find some way to model the Reynolds stresses. ## Gradient-diffusion hypothesis and eddy viscosity models. The *gradient-diffusion hypothesis*, due to [Boussinesq1877](@citet), assumes that the transport of scalar fluxes; such as ``\overline{\boldsymbol{v}^\prime c^\prime}`` and ``\overline{v_i^\prime v_j^\prime}`` occurs down the mean scalar gradient; ``\boldsymbol{\nabla} \overline{c}`` as if they are being diffused (¬ß4.4) [Pope00](@cite). This is in analogy with how momentum transfer by; molecular motion in a gas can be described by a molecular viscosity. Taking this assumption we can express the Reynolds stresses and turbulent tracer fluxes in terms of the mean variables; and close the equations; ```math; \overline{\boldsymbol{v}^\prime c^\prime} = -\kappa_e \boldsymbol{\nabla} \overline{c}; \quad \text{and} \quad; \overline{v_i^\prime v_j^\prime} = -2\nu_e \overline{S}_{ij} \, ,; ```; where ``\nu_e = \nu_e(\boldsymbol{x}, t)`` is the turbulent or *eddy viscosity* and ``\kappa_e = \kappa_e(\boldsymbol{x}, t)``; is the *eddy diffusivity*. The effective diffusivity ends up being the sum of the molecular and eddy diffusivities. So just by using an elevated; value for the viscosity and diffusivity, you are already using an eddy viscosity model. The eddy viscosity model is simple and for that reason is very popular. It can work well even with a constant eddy; diffusivity. However, it does assume that the flux is aligned down gradient, which is not true even in simple turbulent; flows as the physics of turbulence is quite different from that of colliding molecules leading to the viscous stress law; (¬ß4.4,10.1) [Pope00](@cite). So we might want something a little bit more sophisticated.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md:3952,variab,variables,3952,docs/src/numerical_implementation/turbulence_closures.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md,1,['variab'],['variables']
Modifiability,"total; `indices` spanned by the grid. ## Staggered grids and field locations. Oceananigans ocean-flavored fluids simulations rely fundamentally on; ""staggered grid"" numerical methods. Recall that [grids](@ref grids_tutorial) represent a physical domain divided into finite volumes.; For example, let's consider a horizontally-periodic, vertically-bounded grid of cells; that divide up a cube with dimensions ``1 \times 1 \times 1``:. ```jldoctest fields; using Oceananigans. grid = RectilinearGrid(topology = (Periodic, Periodic, Bounded),; size = (4, 5, 4),; halo = (1, 1, 1),; x = (0, 1),; y = (0, 1),; z = [0, 0.1, 0.3, 0.6, 1]). # output; 4√ó5√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 1.0) regularly spaced with Œîx=0.25; ‚îú‚îÄ‚îÄ Periodic y ‚àà [0.0, 1.0) regularly spaced with Œîy=0.2; ‚îî‚îÄ‚îÄ Bounded z ‚àà [0.0, 1.0] variably spaced with min(Œîz)=0.1, max(Œîz)=0.4; ```. The cubic domain is divided into a ""primary mesh"" of ``4 \times 5 \times 4 = 80`` cells,; which are evenly spaced in ``x, y`` but variably spaced in ``z``.; Now, in addition to the primary mesh, the grid defines also a set of ""staggered"" grids whose cells are; shifted by half a cell width relative to the primary mesh.; In other words, the staggered grid cells have a ""location"" in each direction -- either `Center`,; and therefore co-located with the primary mesh, or `Face` and located over the interfaces of the; primary mesh.; For example, the primary or `Center` cell spacings in ``z`` are. ```jldoctest fields; zspacings(grid, Center()). # output; 4-element view(OffsetArray(::Vector{Float64}, 0:5), 1:4) with eltype Float64:; 0.1; 0.19999999999999998; 0.3; 0.4; ```. corresponding to cell interfaces located at `z = [0, 0.1, 0.3, 0.6, 1]`.; But then for the grid which is staggered in `z` relative to the primary mesh,. ```jldoctest fields; zspacings(grid, Face()). # output; 5-element view(OffsetArray(::Vector{Float64}, -1:5), 1:5) with eltype Float64:; 0.1; 0.150000",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md:1456,variab,variably,1456,docs/src/fields.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md,1,['variab'],['variably']
Modifiability,"u made. Chris Beams has written a ; [guide](https://chris.beams.io/posts/git-commit/) on how to write good commit messages. When you think your changes are ready to be merged into the main repository, push to your fork; and [submit a pull request](https://github.com/CLiMA/Oceananigans.jl/compare/). **Working on your first Pull Request?** You can learn how from this _free_ video series; [How to Contribute to an Open Source Project on GitHub](https://egghead.io/courses/how-to-contribute-to-an-open-source-project-on-github), Aaron Meurer's [tutorial on the git workflow](https://www.asmeurer.com/git-workflow/), or the guide [‚ÄúHow to Contribute to Open Source""](https://opensource.guide/how-to-contribute/). ## Documentation. Now that you've made your awesome contribution, it's time to tell the world how to use it.; Writing documentation strings is really important to make sure others use your functionality; properly. Didn't write new functions? That's fine, but be sure that the documentation for; the code you touched is still in great shape. It is not uncommon to find some strange wording; or clarification that you can take care of while you are here. You can preview how the Documentation will look like after merging by building the documentation ; locally. From the main directory of your local repository call. ```; julia --project=docs/ -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'; ```. to instantiate the documentation environment and then. ```; JULIA_DEBUG=Documenter julia --project=docs/ docs/make.jl; ```. If the documentation built is successful, you can open `docs/build/index.html` in your favorite browser.Providing the environment variable ; `JULIA_DEBUG=Documenter` will provide with more information in the documentation build process and; thus help figuring out a potential bug. ## Credits. This contributor's guide is heavily based on the excellent [MetPy contributor's guide](https://github.com/Unidata/MetPy/blob/master/CONTRIBUTING.md).; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:9884,variab,variable,9884,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['variab'],['variable']
Modifiability,"ull request](https://docs.github.com/en/github/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork). Pull requests are reviewed by Oceananigans collaborators. * A pull request can be merged once it is reviewed and approved by collaborators. If the pull request author has write access, they have the responsibility of merging their pull request. Otherwise, Oceananigans.jl collaborators will execute the merge with permission from the pull request author. * Note: for small or minor changes (such as fixing a typo in documentation), the [GitHub editor](https://docs.github.com/en/github/managing-files-in-a-repository/managing-files-on-github/editing-files-in-your-repository) is super useful for forking and opening a pull request with a single click. * Write your code with love and care. In particular, conform to existing Oceananigans style and formatting conventions. For example, we love verbose and explicit variable names, use `TitleCase` for types, `snake_case` for objects, and always.put.spaces.after.commas. For formatting decisions we loosely follow the [YASGuide](https://github.com/jrevels/YASGuide). It's worth few extra minutes of our time to leave future generations with well-written, readable code. ## What is a ""collaborator"" and how can I become one?. * Collaborators have permissions to review pull requests and status allows a contributor to review pull requests in addition to opening them. Collaborators can also create branches in the main Oceananigans repository. * We ask that new contributors try their hand at forking Oceananigans, and opening and merging a pull request before requesting collaborator status. ## What's a good way to start developing Oceananigans?. * Tackle an existing issue. We keep a list of [good first issues](https://github.com/CLiMA/Oceananigans.jl/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22); that are self-contained and suitable for a newcomer to try and work",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md:3200,variab,variable,3200,CONTRIBUTING.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md,1,['variab'],['variable']
Modifiability,"x)); ```. In practice it's hard to say whether inlining a function will bring runtime benefits _with; certainty_, since Julia and KernelAbstractions.jl (needed for GPU runs) already inline some; functions automatically. However, it is generally a good idea to at least investigate this aspect in; your code as the benefits can potentially be significant. ## GPU simulation tips. Running on GPUs can be very different from running on CPUs. Oceananigans makes most of the necessary; changes in the background, so that for very simple simulations changing between CPUs and GPUs is; just a matter of changing the `architecture` argument in the model from `CPU()` to `GPU()`. However,; for more complex simulations some care needs to be taken on the part of the user. While knowledge of; GPU computing (and Julia) is again desirable, an inexperienced user can also achieve high efficiency; in GPU simulations by following a few simple principles. ### Global variables that need to be used in GPU computations need to be defined as constants or passed as parameters. Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation; will crash. This includes any variables that are referenced as global variables in functions; used for forcing of boundary conditions. For example,. ```julia; T‚ÇÄ = 20 # ·µíC; surface_temperature(x, y, t) = T‚ÇÄ * sin(2œÄ / 86400 * t); T_bcs = FieldBoundaryConditions(bottom = GradientBoundaryCondition(surface_temperature)); ```. will throw an error if run on the GPU (and will run more slowly than it should on the CPU).; Replacing the first line above with. ```julia; const T‚ÇÄ = 20 # ·µíC; ```. fixes the issue by indicating to the compiler that `T‚ÇÄ` will not change. Note that the _literal_ `2œÄ / 86400` is not an issue -- it's only the; _variable_ `T‚ÇÄ` that must be declared `const`. Alternatively, we can pass the variable as a parameter to `GradientBoundaryCondition`. To do that; we need to pass a named tuple as `parameter` keyword argument",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:4014,variab,variables,4014,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['variab'],['variables']
Modifiability,"y and physics](https://doi.org/10.21105/joss.05669), _Journal of Open Source Software_, **90(8)**, 5669. DOI: [10.21105/joss.05669](https://doi.org/10.21105/joss.05669). 1. Ramadhan, A., Marshall, J. C., Souza, A. N., Lee, X. K., Piterbarg, U., Hillier, A., Wagner, G. L., Rackauckas, C., Hill, C., Campin, J.-M., and Ferrari, R. (2022). [Capturing missing physics in climate model parameterizations using neural differential equations](https://doi.org/10.1002/essoar.10512533.1), _ESS Open Archive_. DOI: [10.1002/essoar.10512533.1](https://doi.org/10.1002/essoar.10512533.1). 1. Gupta, M. and Thompson, A. F. (2022). [Regimes of sea-ice floe melt: Ice-ocean coupling at the submesoscales](https://doi.org/10.1029/2022JC018894), _Journal of Geophysical Research: Oceans_, **127**, e2022JC018894. DOI: [10.1029/2022JC018894](https://doi.org/10.1029/2022JC018894). 1. Simoes-Sousa, I. T., Tandon, A., Pereira, F., Lazaneo, C. Z., and Mahadevan, A. (2022). [Mixed layer eddies supply nutrients to enhance the spring phytoplankton bloom](https://doi.org/10.3389/fmars.2022.825027), _Frontiers in Marine Sciences_, **9**, 825027. DOI: [10.3389/fmars.2022.825027](https://doi.org/10.3389/fmars.2022.825027). 1. Chor, T., Wenegrat, J. O., and Taylor, J. (2022). [Insights into the mixing efficiency of submesoscale Centrifugal-Symmetric instabilities.](https://doi.org/10.1175/JPO-D-21-0259.1), _Journal of Physical Oceanography_, **52(10)**, 2273-2287. DOI: [10.1175/JPO-D-21-0259.1](https://doi.org/10.1175/JPO-D-21-0259.1). 1. Bire, S., Kang, W., Ramadhan, A., Campin, J.-M., and Marshall, J. (2022). [Exploring ocean circulation on icy moons heated from below.](https://doi.org/10.1029/2021JE007025), _Journal of Geophysical Research: Planets_, **127**, e2021JE007025. DOI: [10.1029/2021JE007025](https://doi.org/10.1029/2021JE007025). 1. Rackauckas, C., Ma, Y., Martensen, J., Warner, C., Zubov, K., Supekar, R., Skinner, D., Ramadhan, A., and Edelman, A. (2021) [Universal differential equations for s",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md:9810,enhance,enhance,9810,docs/src/index.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md,1,['enhance'],['enhance']
Modifiability,"y be a tracer field or a velocity field. ## Point Exponential Decay. This test analyzes time-stepper convergence by simulating the zero-dimensional, or spatially-uniform equation. ```math; \partial_t c = - c \, ,; ```. with the initial condition ``c = 1``, which has the analytical solution ``c = \mathrm{e}^{-t}``. We find the expected first-order convergence with decreasing time-step ``\Delta t`` using our; first-order accurate, ""modified second-order"" Adams-Bashforth time-stepping method:. ![Point exponential decay](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/point_exponential_decay_time_stepper_convergence.png). This result validates the correctness of the `Oceananigans` implementation of Adams-Bashforth time-stepping. ## One-dimensional advection and diffusion of a Gaussian. This and the following tests focus on convergence with grid spacing, ``\Delta x``. In one dimension with constant diffusivity ``\kappa`` and in the presence of a; constant velocity ``U``, a Gaussian evolves according to. ```math; c = \frac{\mathrm{e}^{- (x - U t)^2 / 4 \kappa t}}{\sqrt{4 \pi \kappa t}} \, .; ```. For this test we take the initial time as ``t=t_0``.; We simulate this problem with advection and diffusion, as well as with ``U=0`` and thus diffusion only, as well as with; ``\kappa \approx 0`` and thus ""advection only"".; The solutions are. ![Gaussian advection diffusion solutions](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png). which exhibit the expected second-order convergence with ``\Delta x^2 \propto 1 / N_x^2``:. ![Gaussian advection diffusion convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png). These results validate the correctness of time-stepping, constant diffusivity operators, and advection operat",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md:1787,evolve,evolves,1787,docs/src/appendix/convergence_tests.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md,1,['evolve'],['evolves']
Modifiability,"z, zf, 0 * zf, marker=:vline, color=:gray, markersize=20); scatter!(axz, zc, 0 * zc); hidedecorations!(axz); hidespines!(axz). axŒîz = Axis(fig[4, 1]; xlabel = ""z (m)"", ylabel = ""z-spacing (m)""); scatter!(axŒîz, zc, Œîz); hidespines!(axŒîz, :t, :r). rowsize!(fig.layout, 1, Relative(0.1)); rowsize!(fig.layout, 3, Relative(0.1)). current_figure(); ```. ## Inspecting `LatitudeLongitudeGrid` cell spacings. ```@setup latlon_nodes; using Oceananigans; ```. ```@example latlon_nodes; grid = LatitudeLongitudeGrid(size = (1, 44),; longitude = (0, 1), ; latitude = (0, 88),; topology = (Bounded, Bounded, Flat)). œÜ = œÜnodes(grid, Center()); Œîx = xspacings(grid, Center(), Center()). using CairoMakie. fig = Figure(size=(600, 400)); ax = Axis(fig[1, 1], xlabel=""Zonal spacing on 2 degree grid (km)"", ylabel=""Latitude (degrees)""); scatter!(ax, Œîx ./ 1e3, œÜ). current_figure(); ```. ![](plot_lat_lon_spacings.svg). ## `LatitudeLongitudeGrid` with variable spacing. The syntax for building a grid with variably-spaced cells is the same as for `RectilinearGrid`.; In our next example, we use a function to build a Mercator grid with a spacing of 2 degrees at; the equator,. ```jldoctest latlon_nodes; # Mercator scale factor; scale_factor(œÜ) = 1 / cosd(œÜ). # Compute cell interfaces with Mercator spacing; m = 2 # spacing at the equator in degrees; function latitude_faces(j); if j == 1 # equator; return 0; else # crudely estimate the location of the jth face ; œÜ‚Çã = latitude_faces(j-1); œÜ‚Ä≤ = œÜ‚Çã + m * scale_factor(œÜ‚Çã) / 2; return œÜ‚Çã + m * scale_factor(œÜ‚Ä≤); end; end. Lx = 360; Nx = Int(Lx / m); Ny = findfirst(latitude_faces.(1:Nx) .> 90) - 2. grid = LatitudeLongitudeGrid(size = (Nx, Ny),; longitude = (0, Lx),; latitude = latitude_faces,; topology = (Bounded, Bounded, Flat)). # output; 180√ó28√ó1 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Flat} on CPU with 3√ó3√ó0 halo and with precomputed metrics; ‚îú‚îÄ‚îÄ longitude: Bounded Œª ‚àà [0.0, 360.0] regularly spaced with ŒîŒª=2.0; ‚îú‚îÄ‚îÄ latitude: Bounded œÜ ‚àà [0.0, 77.2",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:19516,variab,variably-spaced,19516,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['variab'],['variably-spaced']
Modifiability,"}{\sqrt{4 \pi \kappa t}} \, .; ```. For this test we take the initial time as ``t=t_0``.; We simulate this problem with advection and diffusion, as well as with ``U=0`` and thus diffusion only, as well as with; ``\kappa \approx 0`` and thus ""advection only"".; The solutions are. ![Gaussian advection diffusion solutions](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png). which exhibit the expected second-order convergence with ``\Delta x^2 \propto 1 / N_x^2``:. ![Gaussian advection diffusion convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png). These results validate the correctness of time-stepping, constant diffusivity operators, and advection operators. ## One-dimensional advection and diffusion of a cosine. In one dimension with constant diffusivity ``\kappa`` and in the presence of a; constant velocity ``U``, a cosine evolves according to. ```math; c = \mathrm{e}^{-\kappa t} \cos (x - U t) \, .; ```. The solutions are. ![Cosine advection diffusion solutions](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png). which exhibit the expected second-order convergence with ``\Delta x^2 \propto 1 / N_x^2``:. ![Cosine advection diffusion convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png). These results validate the correctness of time-stepping, constant diffusivity operators, and advection operators. ## Two-dimensional diffusion. With zero velocity field and constant diffusivity ``\kappa``, the tracer field. ```math; c(x, y, t=0) = \cos(x) \cos(y) \, ,; ```. decays according to. ```math; c(x, y, t) = \mathrm{e}^{-2 \kappa t} \cos(x) \cos(y) \, ,; ```. with",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md:2914,evolve,evolves,2914,docs/src/appendix/convergence_tests.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md,1,['evolve'],['evolves']
Performance," 0.408879 ‚îÇ 0.992685 ‚îÇ 1.33816 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 64, 1) ‚îÇ 17.0612 ‚îÇ 0.266582 ‚îÇ 1.03519 ‚îÇ 1.5735 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 128, 1) ‚îÇ 25.409 ‚îÇ 0.198508 ‚îÇ 1.16772 ‚îÇ 2.03693 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò; ```. ![ss_nonhydrostatic_efficiency](https://user-images.githubusercontent.com/45054739/130146219-b354fa25-7d77-4206-8e7e-ec639b2250fa.png). ## Multithreading. Oceananigans can also achieve parallelism via multithreading. Though its efficiencies are less than that of the MPI distributed architectures, its simple setup still makes it a viable option for achieving speedups on simple systems. ### Weak Scaling Multithreaded Shallow Water Model. The initial drop and then rise in efficiencies going from 1 to 2 to 4 threads is likely caused by the 2 threads being automatically allocated onto only one physical CPU core. Though one physical CPU core may contain 2 logical cores each capable of running a separate thread, having 2 threads run on one core will still reduce efficiencies as many resources such as caches and buses must be shared by both threads. Note that there are as many CPU cores allocated as the maximum number of threads. ```; Oceananigans v0.58.9; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :. Shallow water model weak scaling with multithreading benchmark; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ threads ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allo",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:25881,cache,caches,25881,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['cache'],['caches']
Performance," an approximation to ; the discretized momentum equation for an intermediate velocity field ``\boldsymbol{v}^\star`` ; without worrying about satisfying the incompressibility constraint. We then project ``\boldsymbol{v}^\star`` ; onto the space of divergence-free velocity fields to obtain a value for ``\boldsymbol{v}^{n+1}`` ; that satisfies continuity. For example, for the `NonhydrostaticModel`, if we ignore the background velocity fields and the; surface waves, we thus discretize the momentum equation as; ```math; \frac{\boldsymbol{v}^\star - \boldsymbol{v}^n}{\Delta t}; = - \left[ \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} \boldsymbol{v} \right]^{n+\frac{1}{2}}; - \boldsymbol{f} \times \boldsymbol{v}^{n+\frac{1}{2}}; + \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \nu \boldsymbol{\nabla} \boldsymbol{v}^{n+\frac{1}{2}} \right ); + \boldsymbol{F}_{\boldsymbol{v}}^{n+\frac{1}{2}} \, ,; ```; where the superscript ``n + \frac{1}{2}`` indicates that these terms are evaluated at time step ; ``n + \frac{1}{2}``, which we compute explicitly (see [Time-stepping section](@ref time_stepping)). The projection is then performed; ```math; \boldsymbol{v}^{n+1} = \boldsymbol{v}^\star - \Delta t \, \boldsymbol{\nabla} p^{n+1} \, ,; ```; to obtain a divergence-free velocity field ``\boldsymbol{v}^{n+1}``. Here the projection is performed by solving an elliptic; problem for the pressure ``p^{n+1}`` with the boundary condition; ```math; \boldsymbol{\hat{n}} \boldsymbol{\cdot} \boldsymbol{\nabla} p^{n+1} |_{\partial\Omega} = 0 \, .; ```. [Orszag86](@citet) and [Brown01](@citet) raise an important issue regarding these fractional step ; methods, which is that ""*while the velocity can be reliably computed to second-order accuracy ; in time and space, the pressure is typically only first-order accurate in the ``L_\infty``-norm.*"" ; The numerical boundary conditions must be carefully accounted for to ensure the second-order ; accuracy promised by the fractional step methods.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/fractional_step.md:1462,perform,performed,1462,docs/src/appendix/fractional_step.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/fractional_step.md,2,['perform'],['performed']
Performance," appropriate for; typical applications: we only do it here for illustration purposes. ```@repl checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1))). simulation = Simulation(model, Œît=1, stop_iteration=8). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=IterationInterval(5), prefix=""model_checkpoint""); ```. Again, for illustration purposes of this example, we also add another callback so we can see the iteration; of the simulation. ```@repl checkpointing; show_iteration(sim) = @info ""iteration: $(iteration(sim)); time: $(prettytime(sim.model.clock.time))""; add_callback!(simulation, show_iteration, name=:info, IterationInterval(1)); ```. Now let's run. ```@repl checkpointing; run!(simulation); ```. The default options should provide checkpoint files that are easy to restore from (in most cases).; For more advanced options and features, see [`Checkpointer`](@ref). ## Picking up a simulation from a checkpoint file. Picking up a simulation from a checkpoint requires the original script that was used to generate; the checkpoint data. Change the first instance of [`run!`](@ref) in the script to take `pickup=true`. When `pickup=true` is provided to `run!` then it finds the latest checkpoint file in the current working; directory, loads prognostic fields and their tendencies from file, resets the model clock and iteration,; to the clock time and iteration that the checkpoint corresponds to, and updates the model auxiliary state.; After that, the time-stepping loop. In this simple example, although the simulation run up to iteration 8,; the latest checkpoint is associated with iteration 5. ```@repl checkpointing; simulation.stop_iteration = 12. run!(simulation, pickup=true); ```. Use `pickup=iteration`, where `iteration` is an `Integer`, to pick up from a specific iteration.; Or, use `pickup=filepath`, where `filepath` is a string, to pickup from a specific file located; at `filepath`.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md:2046,load,loads,2046,docs/src/model_setup/checkpointing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md,1,['load'],['loads']
Performance," unfamiliar with Julia can get away with efficient simulations by; learning a few rules of thumb. It is nonetheless recommended that users go through Julia's; [performance tips](https://docs.julialang.org/en/v1/manual/performance-tips/), which contains more; in-depth explanations of some of the aspects discussed here. ## General (CPU/GPU) simulation tips. ### Avoid global variables whenever possible. In general using a [global; variable](https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Global-Scope) (which can be; loosely defined as a variable defined in the main script) inside functions slows down the code. One; way to circumvent this is to always [use local variables or pass them as arguments to; functions](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). This; helps the compiler optimize the code. Another way around this is to [define global variables as constants whenever; possible](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). One; thing to keep in mind when doing this is that when a `const` is defined, its value can't be changed; until you restart the Julia session. So this latter approach is good for production-ready code, but; may be undesirable in the early stages of development while you still have to change the parameters; of the simulation for exploration. It is especially important to avoid global variables in functions that are meant to be executed in; GPU kernels (such as functions defining boundary conditions and forcings). Otherwise the Julia GPU; compiler can fail with obscure errors. This is explained in more detail in the GPU simulation tips; section below. ### Consider inlining small functions. Inlining is when the compiler [replaces a function call with the body of the function that is being; called before compiling](https://en.wikipedia.org/wiki/Inline_expansion). The advantage of inlining; (which in julia can be done with the [`@inline`; macro](https://docs.ju",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:1533,perform,performance-tips,1533,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['perform'],['performance-tips']
Performance,"# Number type. Passing `Float64` or `Float32` to the grid constructor causes the grid to store all numbers; with 64-bit or 32-bit floating point precision. !!! note ""Avoiding mixed-precision operations""; When not using `Float64` be careful to not mix different precisions as it could introduce implicit type conversions; which can negatively effect performance. You can pass the number type desires to many constructors to enforce; the type you want: e.g. `RectilinearGrid(CPU(), Float32; size=(16, 16, 16), extent=(1, 1, 1))` and; `ScalarDiffusivity(Float16; Œ∫=1//7, ŒΩ=2//7)`. !!! warning ""Effect of floating point precision on simulation accuracy""; While we run many tests with both `Float32` and `Float64` it is not clear whether `Float32` is precise enough to; provide similar accuracy in all use cases. If accuracy is a concern, stick to `Float64`. We will be actively investigating the possibility of using lower precision floating point numbers such as `Float32`; and `Float16` for fluid dynamics as well as the use of alternative number types such as Posits and Sonums.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/number_type.md:349,perform,performance,349,docs/src/model_setup/number_type.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/number_type.md,1,['perform'],['performance']
Performance,"# Oceananigans.jl performance benchmarks. This directory contains scripts and modules for benchmarking various features of Oceananigans. To instantiate the benchmarks environment, run. ```; julia -e 'using Pkg; Pkg.activate(pwd()); Pkg.instantiate(); Pkg.develop(PackageSpec(path=joinpath(@__DIR__, "".."")))'; ```. Once the environment has been instantiated, benchmarks can be run via, e.g. ```; julia --project benchmark_nonhydrostatic_model.jl; ```. Most scripts benchmark one feature (e.g. advection schemes, arbitrary tracers). If your machine contains a CUDA-compatible GPU, benchmarks will also run on the GPU. Tables with benchmark results will be printed (and each table will also be saved to an HTML file). ## Distributed benchmarks. Run distributed benchmarks by running the launcher scripts for either the shallow water model: `distributed_shallow_water_model.jl` or the nonhydrostatic model: `distributed_nonhydrostatic_model.jl`. Change settings within the scripts to toggle between strong or weak scaling and threaded or MPI architecture. The single and serial scripts executed by the launcher scripts can also be executed manually from the command line with the appropriate arguments. ## Measuring performance regression. Running the `benchmark_regression.jl` script will run the nonhydrostatic model tests on the current branch and on the main branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression. ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/benchmark/README.md:18,perform,performance,18,benchmark/README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/benchmark/README.md,3,['perform'],['performance']
Performance,"# Operations and averaging. `Field`s are more than mere vessels for data.; They come equipped with a powerful infrastructure for assembling expression trees that represent; arithmetic and discrete calculus operations.; We also supply a system for computing reductions (averages, integrals, and cumulative integrals) of `Field`s.; This infrastructure can be used to construct initial conditions, set up diagnostic calculations that are performed; and saved to disk while a simulation runs, and also for post-processing. We start by constructing a `CenterField` on a simple grid,. ```jldoctest operations; using Oceananigans. grid = RectilinearGrid(topology = (Periodic, Flat, Bounded),; size = (4, 4),; x = (0, 2œÄ),; z = (-4, 0)). c = CenterField(grid). periodic_but_decaying(x, z) = sin(x) * exp(z); set!(c, periodic_but_decaying). # output; 4√ó1√ó4 Field{Center, Center, Center} on RectilinearGrid on CPU; ‚îú‚îÄ‚îÄ grid: 4√ó1√ó4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3√ó0√ó3 halo; ‚îú‚îÄ‚îÄ boundary conditions: FieldBoundaryConditions; ‚îÇ ‚îî‚îÄ‚îÄ west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; ‚îî‚îÄ‚îÄ data: 10√ó1√ó10 OffsetArray(::Array{Float64, 3}, -2:7, 1:1, -2:7) with eltype Float64 with indices -2:7√ó1:1√ó-2:7; ‚îî‚îÄ‚îÄ max=0.428882, min=-0.428882, mean=1.04083e-17; ```. An `AbstractOperation` (or _operation_ for short) differs from a `Field` in that only represents a computation.; Unlike `Field`s, `AbstractOperation`s do not have any data, and are associated only with minimal memory allocation.; `AbstractOperations` are generated by inflicting `Field`s with ordinary arithmetic expressions,. ```jldoctest operations; two_c = 2 * c. # output; BinaryOperation at (Center, Center, Center); ‚îú‚îÄ‚îÄ grid: 4√ó1√ó4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3√ó0√ó3 halo; ‚îî‚îÄ‚îÄ tree:; * at (Center, Center, Center); ¬†¬† ‚îú‚îÄ‚îÄ 2; ¬†¬† ‚îî‚îÄ‚îÄ 4√ó1√ó4 Field{Center, Center, Center} on RectilinearGrid on CPU; ```. and even by chaining e",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/operations.md:435,perform,performed,435,docs/src/operations.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/operations.md,1,['perform'],['performed']
Performance,"# Spatial operators. To calculate the various terms and perform the time-stepping, discrete difference and interpolation ; operators must be designed from which all the terms, such as momentum advection and Laplacian ; diffusion, may be constructed. Much of the material in this section is derived from [Marshall97FV](@citet). ## Differences. Difference operators act as the discrete form of the derivative operator. Care must be taken ; when calculating differences on a staggered grid. For example, the the difference of a cell-centered ; variable such as temperature ``T`` lies on the faces in the direction of the difference, and ; vice versa. In principle, there are three difference operators, one for each direction; ```math; \delta_x f = f_E - f_W , \quad; \delta_y f = f_N - f_S , \quad; \delta_z f = f_T - f_B ,; ```; where the ``E`` and ``W`` subscripts indicate that the value is evaluated the eastern or western ; wall of the cell, ``N`` and ``S`` indicate the northern and southern walls, and ``T`` and ``B`` ; indicate the top and bottom walls. Additionally, two ``\delta`` operators must be defined for each direction to account for the ; staggered nature of the grid. One for taking the difference of a cell-centered variable and ; projecting it onto the cell faces; ```math; \begin{align}; \delta_x^{faa} f_{i, j, k} &= f_{i, j, k} - f_{i-1, j, k} \, , \\; \delta_y^{afa} f_{i, j, k} &= f_{i, j, k} - f_{i, j-1, k} \, , \\; \delta_z^{aaf} f_{i, j, k} &= f_{i, j, k} - f_{i, j, k-1} \, , ; \end{align}; ```; and another for taking the difference of a face-centered variable and projecting it onto the; cell centers; ```math; \begin{align}; \delta_x^{caa} f_{i, j, k} &= f_{i+1, j, k} - f_{i, j, k} \, , \\; \delta_y^{aca} f_{i, j, k} &= f_{i, j+1, k} - f_{i, j, k} \, , \\; \delta_z^{aac} f_{i, j, k} &= f_{i, j, k+1} - f_{i, j, k} \, .; \end{align}; ```. ## Interpolation. In order to add or multiply variables that are defined at different points they are interpolated. ; In our cas",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/spatial_operators.md:56,perform,perform,56,docs/src/numerical_implementation/spatial_operators.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/spatial_operators.md,1,['perform'],['perform']
Performance,"# [Simulation tips](@id simulation_tips). Oceananigans attempts to optimize computations as much as possible ""behind the scenes"".; Yet Oceananigans' flexibility places some responsibility on users to ensure high performance simulations,; especially for complex setups with user-defined forcing functions, boundary condition functions, and diagnostics.; Furthermore, in case of more complex GPU runs, some details could; sometimes prevent your simulation from running altogether. While Julia knowledge is obviously; desirable here, a user that is unfamiliar with Julia can get away with efficient simulations by; learning a few rules of thumb. It is nonetheless recommended that users go through Julia's; [performance tips](https://docs.julialang.org/en/v1/manual/performance-tips/), which contains more; in-depth explanations of some of the aspects discussed here. ## General (CPU/GPU) simulation tips. ### Avoid global variables whenever possible. In general using a [global; variable](https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Global-Scope) (which can be; loosely defined as a variable defined in the main script) inside functions slows down the code. One; way to circumvent this is to always [use local variables or pass them as arguments to; functions](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). This; helps the compiler optimize the code. Another way around this is to [define global variables as constants whenever; possible](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). One; thing to keep in mind when doing this is that when a `const` is defined, its value can't be changed; until you restart the Julia session. So this latter approach is good for production-ready code, but; may be undesirable in the early stages of development while you still have to change the parameters; of the simulation for exploration. It is especially important to avoid global variables in functions that are meant t",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:67,optimiz,optimize,67,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,4,"['optimiz', 'perform']","['optimize', 'performance', 'performance-tips']"
Performance,"## Differentiation and interpolation operators. The geometry of the staggerd grid used by Oceananigans.jl (sometimes called the ""C grid""); is (in one dimension) shown below; ```; face cell face cell face. i-1 i; ‚Üì ‚Üì; | √ó | √ó |; ‚Üë ‚Üë ‚Üë; i-1 i i+1; ```; Difference operators are denoted by a `Œ¥` (`\delta`). Calculating the difference; of a cell-centered quantity `c` at cell `i` returns the difference at face `i`; ```; Œ¥c·µ¢ = c·µ¢ - c·µ¢‚Çã‚ÇÅ; ```; and so this operation, if applied along the x-dimension, is denoted by `Œ¥x·∂†·µÉ·µÉ`. The difference of a face-centered quantity `u` at face `i` returns the difference at cell `i`; ```; Œ¥u·µ¢ = u·µ¢‚Çä‚ÇÅ - u·µ¢; ```; and is thus denoted `Œ¥x·∂ú·µÉ·µÉ` when applied along the x-dimension. The three characters at the end of the function name, `faa` for example, indicates that the; output lies on the cell faces in the x-dimension but remains at their original positions in ; the y- and z-dimensions. Thus we further identify this operator by the superscript `·∂†·µÉ·µÉ`, where; the `a` stands for ""any"" as the location is unchanged by the operator and is determined by; the input. As a result, the interpolation of a quantity `c` from a cell `i` to face `i` (which is denoted; ""`‚Ñëx·∂†·µÉ·µÉ`"" in the code below) is; ```; ‚Ñëx·∂†·µÉ·µÉ(c)·µ¢ = (c·µ¢ + c·µ¢‚Çã‚ÇÅ) / 2; ```; Conversely, the interpolation of a quantity `u` from a face `i` to cell `i` is given by; ```; ‚Ñëx·∂ú·µÉ·µÉ(u)·µ¢ = (u·µ¢‚Çä‚ÇÅ + u·µ¢) / 2; ```; The `‚Ñë` (`\Im`) symbol indicates that an interpolation is being performed. For example, `‚Ñëx`; indicates that the interpolation is performed along the x-dimension.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/src/Operators/README.md:1453,perform,performed,1453,src/Operators/README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/src/Operators/README.md,2,['perform'],['performed']
Performance,"- \xi) \sin y \, ,; ```; which satisfies the boundary conditions ``u_y |_{y=0} = u_y |_{y=\pi} = 0`` and; ``v |_{y=0} = v |_{y=\pi} = 0``. The vorticity forcing is; ```math; F_{\omega} = - 2 \xi^\prime f_x \sin y + 4 f \sin y \, ,; ```; which implies that; ```math; F_v = - 2 \xi^\prime f_x \cos y + 4 f \cos y \, ,; ```; and ``F_v = \tfrac{1}{2} \sin 2 y``. ## Forced, fixed-slip flow. A forced flow satisfying ""fixed-slip"" boundary conditions at ``y=0`` and ``y=1`` has; the streamfunction; ```math; \psi(x, y, t) = - \cos [x - \xi(t)] (y^3 - y^2) \, ,; ```; and thus ``g(y) = y^3 - y^2``. The velocity field ``(u, v)`` is; ```math; u = f (3y^2 - 2 y) \, , \quad \text{and} \quad v = - f_x (y^3 - y^2) \, ,; ```; which satisfies the boundary conditions; ```math; u |_{y=0} = 0 \, , \quad u |_{y=1} = f \, , \quad \text{and} \quad v |_{y=0} = v |_{y=1} = 0 \, .; ```; The vorticity forcing is; ```math; F_{\omega} = - \xi^\prime f_x (y^3 - y^2 - 6y + 2) - f f_x (12 y^3 - 12 y^2 + 4 y) + f (y^3 - y^2 - 12 y + 4) \, ,; ```; which implies that; ```math; F_v = \xi^\prime f_x (\tfrac{1}{4} y^4 - \tfrac{1}{3} y^3 - 3 y^2 + 2y); + f f_x (3 y^4 - 4 y^3 + 2y^2 ) ; - f (\tfrac{1}{4} y^4 - \tfrac{1}{3} y^3 - 6 y^2 + 4 y) \, ,; ```; and; ```math; F_v = 3 y^5 - 5 y^4 + 2y^3 \, .; ```. We set up the problem in the same manner as the forced, free-slip problem above. Note that we ; also must the no-slip boundary condition ``u |_{y=0} = 0`` and the time-dependent fixed-slip ; condition ``u |_{y=1} = f``. As for the free-slip problem, we find that the error between the ; numerical and analytical solutions decreases with ``1 / N_x^2 \sim \Delta x^2``, where ``N_x``; is the number of grid points and ``\Delta x`` is the spatial resolution:. ![Forced fixed slip convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/forced_fixed_slip_convergence.png). The convergence tests are performed using both ``y`` and ``z`` as the bounded direction.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md:10530,perform,performed,10530,docs/src/appendix/convergence_tests.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md,1,['perform'],['performed']
Performance,"2 ‚îÇ 50.8995 ‚îÇ 1.33771 ‚îÇ 2.49028 ‚îÇ; ‚îÇ Float64 ‚îÇ 1024 ‚îÇ 290.085 ‚îÇ 1.33809 ‚îÇ 2.50497 ‚îÇ; ‚îÇ Float64 ‚îÇ 2048 ‚îÇ 370.777 ‚îÇ 1.45575 ‚îÇ 7.0432 ‚îÇ; ‚îÇ Float64 ‚îÇ 4096 ‚îÇ 390.617 ‚îÇ 1.95667 ‚îÇ 26.3641 ‚îÇ; ‚îÇ Float64 ‚îÇ 8192 ‚îÇ 387.632 ‚îÇ 3.82201 ‚îÇ 98.3123 ‚îÇ; ‚îÇ Float64 ‚îÇ 16384 ‚îÇ 426.31 ‚îÇ 12.177 ‚îÇ 420.573 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò; ```; As shown in the graph below, speedups increase sharply starting at grid size `512^2` and then plateau off at around 400 times at grid size `4096^2` and beyond. ![shallow_water_speedup](https://user-images.githubusercontent.com/45054739/128793049-7bcbabaa-2d66-4209-a311-b02729fb93fa.png). The time graph below shows that execution times on GPU are negligibly small up until grid size `1024^2` where it starts to scale similarly to times on CPU. ![shallow_water_times](https://user-images.githubusercontent.com/45054739/128793311-e4bbfd5a-aea8-4cdc-bee8-cb71128ff5fe.png). ## Nonhydrostatic Model. Similar to to shallow water model, the nonhydrostatic model benchmark tests for its performance on both a CPU and a GPU. It was also benchmarked with the `WENO` advection scheme. The nonhydrostatic model is 3-dimensional unlike the 2-dimensional shallow water model. Total number of grid points is Ns cubed. ```; Oceananigans v0.58.8; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.1; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Nonhydrostatic model benchmarks; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:5204,perform,performance,5204,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['perform'],['performance']
Performance,"256 ‚îÇ 16 ‚îÇ 642.225 ms ‚îÇ 645.458 ms ‚îÇ 648.685 ms ‚îÇ 674.259 ms ‚îÇ 3.60 MiB ‚îÇ 40992 ‚îÇ 8 ‚îÇ; ‚îÇ 256 ‚îÇ 32 ‚îÇ 680.938 ms ‚îÇ 694.376 ms ‚îÇ 701.272 ms ‚îÇ 746.599 ms ‚îÇ 4.88 MiB ‚îÇ 36729 ‚îÇ 8 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò. Nonhydrostatic Strong Scaling Multithreading speedup; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ threads ‚îÇ slowdown ‚îÇ efficiency ‚îÇ memory ‚îÇ allocs ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ 256 ‚îÇ 1 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ; ‚îÇ 256 ‚îÇ 2 ‚îÇ 0.992966 ‚îÇ 0.503542 ‚îÇ 4.14014 ‚îÇ 152.109 ‚îÇ; ‚îÇ 256 ‚îÇ 4 ‚îÇ 0.501089 ‚îÇ 0.498913 ‚îÇ 2.17724 ‚îÇ 50.2532 ‚îÇ; ‚îÇ 256 ‚îÇ 8 ‚îÇ 0.324366 ‚îÇ 0.385367 ‚îÇ 1.94899 ‚îÇ 29.191 ‚îÇ; ‚îÇ 256 ‚îÇ 16 ‚îÇ 0.244788 ‚îÇ 0.255323 ‚îÇ 2.12262 ‚îÇ 18.2106 ‚îÇ; ‚îÇ 256 ‚îÇ 32 ‚îÇ 0.263339 ‚îÇ 0.118668 ‚îÇ 2.87624 ‚îÇ 16.3167 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò; ```. ## Tracers. This benchmark tests the performance impacts of running with various amounts of active; and passive tracers and compares the difference in speedup going from CPU to GPU. Number of tracers are listed in the tracers column as (active, passive). . ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Arbitrary tracers benchmarks; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ Architectures ‚îÇ tracers ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ samples ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:30973,perform,performance,30973,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['perform'],['performance']
Performance,"4 ‚îÇ 1.38949 ‚îÇ; ‚îÇ CPU ‚îÇ (2, 3) ‚îÇ 1.55493 ‚îÇ 4.04677 ‚îÇ 2.37198 ‚îÇ; ‚îÇ CPU ‚îÇ (2, 5) ‚îÇ 1.97115 ‚îÇ 5.84537 ‚îÇ 2.96377 ‚îÇ; ‚îÇ CPU ‚îÇ (2, 10) ‚îÇ 2.6031 ‚îÇ 11.7179 ‚îÇ 4.63889 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò. Arbitrary tracers relative performance (GPU); ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ Architectures ‚îÇ tracers ‚îÇ slowdown ‚îÇ memory ‚îÇ allocs ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ GPU ‚îÇ (0, 0) ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ; ‚îÇ GPU ‚îÇ (0, 1) ‚îÇ 1.0941 ‚îÇ 1.39053 ‚îÇ 1.16013 ‚îÇ; ‚îÇ GPU ‚îÇ (0, 2) ‚îÇ 1.19399 ‚îÇ 1.85081 ‚îÇ 1.29592 ‚îÇ; ‚îÇ GPU ‚îÇ (1, 0) ‚îÇ 1.08489 ‚îÇ 1.39037 ‚îÇ 1.15883 ‚îÇ; ‚îÇ GPU ‚îÇ (2, 0) ‚îÇ 1.19157 ‚îÇ 1.85109 ‚îÇ 1.29153 ‚îÇ; ‚îÇ GPU ‚îÇ (2, 3) ‚îÇ 1.47824 ‚îÇ 3.50924 ‚îÇ 1.45881 ‚îÇ; ‚îÇ GPU ‚îÇ (2, 5) ‚îÇ 1.66293 ‚îÇ 4.95474 ‚îÇ 1.94286 ‚îÇ; ‚îÇ GPU ‚îÇ (2, 10) ‚îÇ 2.13524 ‚îÇ 9.47276 ‚îÇ 2.52301 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò; ```. ## Turbulence closures. This benchmark tests the performance impacts of various turbulent diffusivity closures; and large eddy simulation (LES) models as well as how much speedup they experience going from CPU to GPU. ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Turbulence closure benchmarks; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ Architectures ‚îÇ Closures ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ samples ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:35511,perform,performance,35511,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['perform'],['performance']
Performance,"520 ms ‚îÇ 20.519 ms ‚îÇ 5.56 MiB ‚îÇ 17974 ‚îÇ 10 ‚îÇ; ‚îÇ GPU ‚îÇ (2, 5) ‚îÇ 15.824 ms ‚îÇ 21.211 ms ‚îÇ 21.064 ms ‚îÇ 24.897 ms ‚îÇ 7.86 MiB ‚îÇ 23938 ‚îÇ 10 ‚îÇ; ‚îÇ GPU ‚îÇ (2, 10) ‚îÇ 22.085 ms ‚îÇ 27.236 ms ‚îÇ 28.231 ms ‚îÇ 38.295 ms ‚îÇ 15.02 MiB ‚îÇ 31086 ‚îÇ 10 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò. Arbitrary tracers CPU to GPU speedup; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ tracers ‚îÇ speedup ‚îÇ memory ‚îÇ allocs ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ (0, 0) ‚îÇ 112.881 ‚îÇ 1.78792 ‚îÇ 7.44022 ‚îÇ; ‚îÇ (0, 1) ‚îÇ 112.761 ‚îÇ 1.77743 ‚îÇ 7.36045 ‚îÇ; ‚îÇ (0, 2) ‚îÇ 109.618 ‚îÇ 1.6627 ‚îÇ 6.96945 ‚îÇ; ‚îÇ (1, 0) ‚îÇ 110.717 ‚îÇ 1.77723 ‚îÇ 7.35221 ‚îÇ; ‚îÇ (2, 0) ‚îÇ 111.678 ‚îÇ 1.66267 ‚îÇ 6.91569 ‚îÇ; ‚îÇ (2, 3) ‚îÇ 118.737 ‚îÇ 1.55043 ‚îÇ 4.57587 ‚îÇ; ‚îÇ (2, 5) ‚îÇ 133.803 ‚îÇ 1.5155 ‚îÇ 4.87734 ‚îÇ; ‚îÇ (2, 10) ‚îÇ 137.615 ‚îÇ 1.44535 ‚îÇ 4.0466 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò. Arbitrary tracers relative performance (CPU); ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ Architectures ‚îÇ tracers ‚îÇ slowdown ‚îÇ memory ‚îÇ allocs ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ CPU ‚îÇ (0, 0) ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ; ‚îÇ CPU ‚îÇ (0, 1) ‚îÇ 1.09293 ‚îÇ 1.39873 ‚îÇ 1.17271 ‚îÇ; ‚îÇ CPU ‚îÇ (0, 2) ‚îÇ 1.15948 ‚îÇ 1.99019 ‚îÇ 1.38345 ‚îÇ; ‚îÇ CPU ‚îÇ (1, 0) ‚îÇ 1.06409 ‚îÇ 1.39873 ‚îÇ 1.17271 ‚îÇ; ‚îÇ CPU ‚îÇ (2, 0) ‚îÇ 1.17887 ‚îÇ 1.99054 ‚îÇ 1.38949 ‚îÇ; ‚îÇ CPU ‚îÇ (2, 3) ‚îÇ 1.55493 ‚îÇ 4.04677 ‚îÇ 2.37198 ‚îÇ; ‚îÇ CPU ‚îÇ (2, 5) ‚îÇ 1.97115 ‚îÇ 5.84537 ‚îÇ 2.96377 ‚îÇ; ‚îÇ CPU ‚îÇ (2, 10) ‚îÇ 2.6031 ‚îÇ 11.7179 ‚îÇ 4.63889 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò. Arbitrary tracers relative performance (GPU); ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ Architectures ‚îÇ tracers ‚îÇ slowdown ‚îÇ memory ‚îÇ allocs ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ GPU ‚îÇ (0, 0) ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ; ‚îÇ GPU ‚îÇ (0, 1) ‚îÇ 1.0941 ‚îÇ 1.39053 ‚îÇ 1.16013 ‚îÇ; ‚îÇ GPU ‚îÇ (0, 2) ‚îÇ 1.19399 ‚îÇ 1.85081 ‚îÇ 1.29592 ‚îÇ; ‚îÇ GPU ‚îÇ (1, 0) ‚îÇ 1.08489 ‚îÇ 1.39037 ‚îÇ 1.15883 ‚îÇ; ‚îÇ GPU ‚îÇ (2, 0) ‚îÇ 1.19157 ‚îÇ 1.85109 ‚îÇ 1.29153 ‚îÇ; ‚îÇ GPU ‚îÇ (2, 3)",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:34172,perform,performance,34172,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['perform'],['performance']
Performance,"; # [Performance benchmarks](@id performance_benchmarks). The performance benchmarking scripts in the; [`benchmarks`](https://github.com/CliMA/Oceananigans.jl/tree/main/benchmark); directory of the git repository can be run to benchmark Oceananigans.jl on your machine.; They use [BenchmarkTools.jl](https://github.com/JuliaCI/BenchmarkTools.jl) to collect data and [PrettyTables.jl](https://github.com/ronisbr/PrettyTables.jl) to nicely; format the benchmark results. ## Shallow Water Model. This benchmark tests the performance of the shallow water model run in a doubly periodic domain (`topology = (Periodic, Periodic, Flat)`); on a CPU versus a GPU. We find that with the `WENO` advection scheme we get a maximum speedup of more than 400 times on a `16384^2` grid. ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Shallow water model benchmarks; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ Architectures ‚îÇ Float_types ‚îÇ Ns ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ samples ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ CPU ‚îÇ Float64 ‚îÇ 32 ‚îÇ 2.677 ms ‚îÇ 2.876 ms ‚îÇ 3.047 ms ‚îÇ 4.806 ms ‚îÇ 1.36 MiB ‚îÇ 2253 ‚îÇ 10 ‚îÇ; ‚îÇ CPU ‚îÇ Float64 ‚îÇ 64 ‚îÇ 5.795 ms ‚îÇ 5.890 ms ‚îÇ 6.073 ms ‚îÇ 7.770 ms ‚îÇ 1.36 MiB ‚îÇ 2255 ‚îÇ 10 ‚îÇ; ‚îÇ CPU ‚îÇ Float64 ‚îÇ 128 ‚îÇ 16.979 ms ‚îÇ 17.350 ms ‚îÇ 17.578 ms ‚îÇ 19.993 ms ‚îÇ ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:62,perform,performance,62,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,2,['perform'],['performance']
Performance,"; end; end. Lx = 360; Nx = Int(Lx / m). # Deduce number of cells south of 90·µíN; Œªf = latitude_faces.(1:Nx); Ny = findfirst(Œªf .> 90) - 2. grid = LatitudeLongitudeGrid(size = (Nx, Ny),; longitude = (0, Lx),; latitude = latitude_faces,; topology = (Bounded, Bounded, Flat)); ```. ```@example plot; œÜ = œÜnodes(grid, Center()); Œîx = xspacings(grid, Center(), Center(), with_halos=true)[1:Ny]; Œîy = yspacings(grid, Center())[1:Ny]. using CairoMakie. fig = Figure(size=(800, 400), title=""Spacings on a Mercator grid""); axx = Axis(fig[1, 1], xlabel=""Zonal spacing (km)"", ylabel=""Latitude (degrees)""); scatter!(axx, Œîx ./ 1e3, œÜ). axy = Axis(fig[1, 2], xlabel=""Meridional spacing (km)""); scatter!(axy, Œîy ./ 1e3, œÜ). hidespines!(axx, :t, :r); hidespines!(axy, :t, :l, :r); hideydecorations!(axy, grid=false). current_figure(); ```. ## Single-precision `RectilinearGrid`. To build a grid whose fields are represented with single-precision floating point values,; we specify the `float_type` argument along with the (optional) `architecture` argument,. ```jldoctest grids; architecture = CPU(); float_type = Float32. grid = RectilinearGrid(architecture, float_type,; topology = (Periodic, Periodic, Bounded),; size = (16, 8, 4),; x = (0, 64),; y = (0, 32),; z = (0, 8)). # output; 16√ó8√ó4 RectilinearGrid{Float32, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 64.0) regularly spaced with Œîx=4.0; ‚îú‚îÄ‚îÄ Periodic y ‚àà [0.0, 32.0) regularly spaced with Œîy=4.0; ‚îî‚îÄ‚îÄ Bounded z ‚àà [0.0, 8.0] regularly spaced with Œîz=2.0; ```. !!! warn ""Using single precision""; Single precision should be used with care.; Users interested in performing single-precision simulations should get in touch via; [Discussions](https://github.com/CliMA/Oceananigans.jl/discussions),; and should subject their work to extensive testing and validation. For more examples see [`RectilinearGrid`](@ref Oceananigans.Grids.RectilinearGrid); and [`LatitudeLongitudeGrid`](@ref Oceananigans.Grids.LatitudeLongitudeGrid).; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:22750,perform,performing,22750,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['perform'],['performing']
Performance,"complex GPU runs, some details could; sometimes prevent your simulation from running altogether. While Julia knowledge is obviously; desirable here, a user that is unfamiliar with Julia can get away with efficient simulations by; learning a few rules of thumb. It is nonetheless recommended that users go through Julia's; [performance tips](https://docs.julialang.org/en/v1/manual/performance-tips/), which contains more; in-depth explanations of some of the aspects discussed here. ## General (CPU/GPU) simulation tips. ### Avoid global variables whenever possible. In general using a [global; variable](https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Global-Scope) (which can be; loosely defined as a variable defined in the main script) inside functions slows down the code. One; way to circumvent this is to always [use local variables or pass them as arguments to; functions](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). This; helps the compiler optimize the code. Another way around this is to [define global variables as constants whenever; possible](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). One; thing to keep in mind when doing this is that when a `const` is defined, its value can't be changed; until you restart the Julia session. So this latter approach is good for production-ready code, but; may be undesirable in the early stages of development while you still have to change the parameters; of the simulation for exploration. It is especially important to avoid global variables in functions that are meant to be executed in; GPU kernels (such as functions defining boundary conditions and forcings). Otherwise the Julia GPU; compiler can fail with obscure errors. This is explained in more detail in the GPU simulation tips; section below. ### Consider inlining small functions. Inlining is when the compiler [replaces a function call with the body of the function that is being; called b",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:1386,optimiz,optimize,1386,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['optimiz'],['optimize']
Performance,"dd(""Oceananigans""); ```. This installs the latest version that's _compatible with your current environment_.; Don't forget to *be careful* üèÑ and check which Oceananigans you installed:. ```julia; julia> Pkg.status(""Oceananigans""); ```. ## Running your first model. Let's run a two-dimensional, horizontally-periodic simulation of turbulence using 128¬≤ finite volume cells for 4 non-dimensional time units:. ```julia; using Oceananigans; grid = RectilinearGrid(CPU(), size=(128, 128), x=(0, 2œÄ), y=(0, 2œÄ), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO()); œµ(x, y) = 2rand() - 1; set!(model, u=œµ, v=œµ); simulation = Simulation(model; Œît=0.01, stop_time=4); run!(simulation); ```. But there's more: changing `CPU()` to `GPU()` makes this code run on a CUDA-enabled Nvidia GPU. Dive into [the documentation](https://clima.github.io/OceananigansDocumentation/stable/) for more code examples and tutorials.; Below, you'll find movies from GPU simulations along with CPU and GPU [performance benchmarks](https://github.com/clima/Oceananigans.jl#performance-benchmarks). ## The Oceananigans knowledge base. It's _deep_ and includes:. * [Documentation](https://clima.github.io/OceananigansDocumentation/stable) that provides; * example Oceananigans scripts,; * tutorials that describe key Oceananigans objects and functions,; * explanations of Oceananigans finite-volume-based numerical methods,; * details of the dynamical equations solved by Oceananigans models, and; * a library documenting all user-facing Oceananigans objects and functions.; * [Discussions on the Oceananigans github](https://github.com/CliMA/Oceananigans.jl/discussions), covering topics like; * [""Computational science""](https://github.com/CliMA/Oceananigans.jl/discussions/categories/computational-science), or how to science and set up numerical simulations in Oceananigans, and; * [""Experimental features""](https://github.com/CliMA/Oceananigans.jl/discussions?discussions_q=experimental+f",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:5704,perform,performance,5704,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['perform'],['performance']
Performance,"employs a; finite volume algorithm similar to that used by the Massachusetts Institute of; Technology general circulation model [@Marshall1997]. ![Fig. 1](free_convection_and_baroclinic_instability.png); Fig. 1: (Left) Large eddy simulation of small-scale oceanic boundary layer; turbulence forced by a surface cooling in a horizontally periodic domain using; $256^3$ grid points. The upper layer is well-mixed by turbulent convection and; bounded below by a strong buoyancy interface. (Right) Simulation of; instability of a horizontal density gradient in a rotating channel using; $256\times512\times128$ grid points. A similar process called baroclinic; instability acting on basin-scale temperature gradients fills the oceans with; eddies that stir carbon and heat. Plots made with `matplotlib` [@Hunter2007]; and `cmocean` [@Thyng2016]. ``Oceananigans.jl`` leverages the Julia programming language [@Bezanson2017] to; implement high-level, low-cost abstractions, a friendly user interface, and a; high-performance model in one language and a common code base for execution on; the CPU or GPU with Julia‚Äôs native GPU compiler [@Besard2019]. Because Julia is; a high-level language, development is streamlined and users can flexibly specify; model configurations, set up arbitrary diagnostics and output, extend the code; base, and implement new features. Configuring a model with `architecture=CPU()`; or `architecture=GPU()` will execute the model on the CPU or GPU. By pinning a; simulation script against a specific version of Oceananigans, simulation results; are reproducible up to hardware differences. Performance benchmarks show significant speedups when running on a GPU. Large; simulations on an Nvidia Tesla V100 GPU require ~1 nanosecond per grid point per; iteration. GPU simulations are therefore roughly 3x more cost-effective; than CPU simulations on cloud computing platforms such as Google Cloud. A GPU; with 32 GB of memory can time-step models with ~150 million grid points ass",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md:2572,perform,performance,2572,paper/paper.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md,1,['perform'],['performance']
Performance,"hat if ``F_v`` satisfies; ```math; \partial_y F_v = (g^\prime)^2 + g g^{\prime\prime} \, ,; ```; then the pressure Poisson equation becomes; ```math; \nabla^2 p = \cos [2 (x - \xi)] [(g^\prime)^2 - g g^{\prime\prime}] + \partial_x F_v \, .; ```; This completes the specification of the problem. We set up the problem by imposing the time-dependent forcing functions ``F_u`` and ``F_v``; on ``u`` and ``v``, initializing the flow at ``t=0``, and integrating the problem forwards; in time using Oceananigans. We find the expected convergence of the numerical solution to the; analytical solution: the error between the numerical and analytical solutions; decreases with ``1/N_x^2 \sim \Delta x^2``, where ``N_x`` is the number of grid; points and ``\Delta x`` is the spatial resolution:. ![Forced free slip convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/forced_free_slip_convergence.png). The convergence tests are performed using both ``y`` and ``z`` as the bounded direction. ### Forced, free-slip flow. A forced flow satisfying free-slip conditions at ``y = 0`` and ``y = \pi`` has the streamfunction; ```math; \psi(x, y, t) = - \cos [x - \xi(t)] \sin (y) \, ,; ```; and thus ``g(y) = \sin y``. The velocity field ``(u, v)`` is; ```math; u = \cos (x - \xi) \cos y \, , \quad \text{and} \quad v = \sin (x - \xi) \sin y \, ,; ```; which satisfies the boundary conditions ``u_y |_{y=0} = u_y |_{y=\pi} = 0`` and; ``v |_{y=0} = v |_{y=\pi} = 0``. The vorticity forcing is; ```math; F_{\omega} = - 2 \xi^\prime f_x \sin y + 4 f \sin y \, ,; ```; which implies that; ```math; F_v = - 2 \xi^\prime f_x \cos y + 4 f \cos y \, ,; ```; and ``F_v = \tfrac{1}{2} \sin 2 y``. ## Forced, fixed-slip flow. A forced flow satisfying ""fixed-slip"" boundary conditions at ``y=0`` and ``y=1`` has; the streamfunction; ```math; \psi(x, y, t) = - \cos [x - \xi(t)] (y^3 - y^2) \, ,; ```; and thus ``g(y) = y^3 - y^2``. The velocity field ``(u, v)`` is; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md:8202,perform,performed,8202,docs/src/appendix/convergence_tests.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md,1,['perform'],['performed']
Performance,"io/master/img/surface_temp_3d_00130_halfsize.png)](https://www.youtube.com/watch?v=kpUrxnKKMjI). ### [Free convection](https://www.youtube.com/watch?v=yq4op9h3xcU). [![Watch free convection in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/free_convection_0956.png)](https://www.youtube.com/watch?v=yq4op9h3xcU). ### [Winds blowing over the ocean](https://www.youtube.com/watch?v=IRncfbvuiy8). [![Watch winds blowing over the ocean](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_0400.png)](https://www.youtube.com/watch?v=IRncfbvuiy8). ### [Free convection with wind stress](https://www.youtube.com/watch?v=ob6OMQgPfI4). [![Watch free convection with wind stress in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_unstable_7500.png)](https://www.youtube.com/watch?v=ob6OMQgPfI4). ## Performance benchmarks. We've performed some preliminary performance benchmarks (see the [performance benchmarks](https://clima.github.io/OceananigansDocumentation/stable/appendix/benchmarks/) section of the documentation) by initializing models of various sizes and measuring the wall clock time taken per model iteration (or time step). This is not really a fair comparison as we haven't parallelized across all the CPU's cores so we will revisit these benchmarks once Oceananigans.jl can run on multiple CPUs and GPUs. To make full use of or fully saturate the computing power of a GPU such as an Nvidia Tesla V100 or; a Titan V, the model should have around ~10 million grid points or more. Sometimes counter-intuitively running with `Float32` is slower than `Float64`. This is likely due; to type mismatches causing slowdowns as floats have to be converted between 32-bit and 64-bit, an; issue that needs to be addressed meticulously. Due to other bottlenecks such as memory accesses and; GPU register pressure, `Float32` models may not provide much of a speedup so the m",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:10655,perform,performed,10655,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,3,['perform'],"['performance', 'performed']"
Performance,"mg alt=""Docker build status"" src=""https://img.shields.io/docker/cloud/build/aliramadhan/oceananigans?label=Docker&logo=docker&logoColor=white&style=flat-square"">; </a>; </p>. Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic; and hydrostatic Boussinesq equations on CPUs and GPUs.; It runs on GPUs (wow, [fast!](http://arxiv.org/abs/2309.06662)), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans.jl is developed by the [Climate Modeling Alliance](https://clima.caltech.edu) and heroic external collaborators. ## Contents. - [Contents](#contents); - [Installation instructions](#installation-instructions); - [Running your first model](#running-your-first-model); - [The Oceananigans knowledge base](#the-oceananigans-knowledge-base); - [Citing](#citing); - [Contributing](#contributing); - [Movies](#movies); - [Deep convection](#deep-convection); - [Free convection](#free-convection); - [Winds blowing over the ocean](#winds-blowing-over-the-ocean); - [Free convection with wind stress](#free-convection-with-wind-stress); - [Performance benchmarks](#performance-benchmarks). ## Installation instructions. Oceananigans is a [registered Julia package](https://julialang.org/packages/). So to install it,. 1. [Download Julia](https://julialang.org/downloads/) (version 1.9 or later). 2. Launch Julia and type. ```julia; julia> using Pkg. julia> Pkg.add(""Oceananigans""); ```. This installs the latest version that's _compatible with your current environment_.; Don't forget to *be careful* üèÑ and check which Oceananigans you installed:. ```julia; julia> Pkg.status(""Oceananigans""); ```. ## Running your first model. Let's run a two-dimensional, horizontally-periodic simulation of turbulence using 128¬≤ finite volume cells for 4 non-dimensional time units:. ```julia; using Oceananigans; grid = Recti",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:4390,perform,performance-benchmarks,4390,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['perform'],['performance-benchmarks']
Performance,"nanigans.Operators: ‚àÇz·∂†·∂ú·∂†, ‚Ñëxz·∂†·µÉ·∂ú. function u_forcing_func(i, j, k, grid, clock, model_fields, Œµ); # The vertical derivative of buoyancy, interpolated to the u-velocity location:; N¬≤ = ‚Ñëxz·∂†·µÉ·∂ú(i, j, k, grid, ‚àÇz·∂†·∂ú·∂†, model_fields.b). # Set to zero in unstable stratification where N¬≤ < 0:; N¬≤ = max(N¬≤, zero(typeof(N¬≤))). return @inbounds - Œµ * sqrt(N¬≤) * model_fields.u[i, j, k]; end. u_forcing = Forcing(u_forcing_func, discrete_form=true, parameters=1e-3). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, tracers=:b, buoyancy=BuoyancyTracer(), forcing=(u=u_forcing, b=b_forcing)). model.forcing.b. # output; DiscreteForcing{Nothing}; ‚îú‚îÄ‚îÄ func: b_forcing_func (generic function with 1 method); ‚îî‚îÄ‚îÄ parameters: nothing; ```. ```jldoctest discrete_forcing; model.forcing.u. # output; DiscreteForcing{Float64}; ‚îú‚îÄ‚îÄ func: u_forcing_func (generic function with 1 method); ‚îî‚îÄ‚îÄ parameters: 0.001; ```. The annotation `@inbounds` is crucial for performance when accessing array indices; of the fields in `model_fields`. ## `Relaxation`. `Relaxation` defines a special forcing function that restores a field at a specified `rate` to; a `target` distribution, within a region uncovered by a `mask`ing function.; `Relaxation` is useful for implementing sponge layers, as shown in the second example. The following code constructs a model in which all components; of the velocity field are damped to zero everywhere on a time-scale of 1000 seconds, or ~17 minutes:. ```jldoctest; damping = Relaxation(rate = 1/1000). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = NonhydrostaticModel(grid=grid, forcing=(u=damping, v=damping, w=damping)). model.forcing.w. # output; ContinuousForcing{Nothing} at (Center, Center, Face); ‚îú‚îÄ‚îÄ func: Relaxation(rate=0.001, mask=1, target=0); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:w,); ```. The constructor for `Relaxation` accepts the keyword arguments `mask`, and `target`,; which specify a `mask(x, y",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:7843,perform,performance,7843,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['perform'],['performance']
Performance,"nfigurations, set up arbitrary diagnostics and output, extend the code; base, and implement new features. Configuring a model with `architecture=CPU()`; or `architecture=GPU()` will execute the model on the CPU or GPU. By pinning a; simulation script against a specific version of Oceananigans, simulation results; are reproducible up to hardware differences. Performance benchmarks show significant speedups when running on a GPU. Large; simulations on an Nvidia Tesla V100 GPU require ~1 nanosecond per grid point per; iteration. GPU simulations are therefore roughly 3x more cost-effective; than CPU simulations on cloud computing platforms such as Google Cloud. A GPU; with 32 GB of memory can time-step models with ~150 million grid points assuming; five fields are being evolved; for example, three velocity components and; tracers for temperature and salinity. These performance gains permit the; long-time integration of realistic simulations, such as large eddy simulation of; oceanic boundary layer turbulence over a seasonal cycle or the generation of; training data for turbulence parameterizations in Earth system models. ``Oceananigans.jl`` is continuously tested on CPUs and GPUs with unit tests,; integration tests, analytic solutions to the incompressible Navier-Stokes; equations, convergence tests, and verification experiments against published; scientific results. Future development plans include support for distributed; parallelism with CUDA-aware MPI as well as topography. Ocean models that are similar to ``Oceananigans.jl`` include MITgcm; [@Marshall1997] and MOM6 [@Adcroft2019], both written in Fortran. However,; ``Oceananigans.jl`` features a more efficient non-hydrostatic pressure solver; than MITgcm (and MOM6 is strictly hydrostatic). PALM [@Maronga2020] is Fortran; software for large eddy simulation of atmospheric and oceanic boundary layers; with complex boundaries on parallel CPU and GPU architectures. ``Oceananigans.jl``; is distinguished by its use of Juli",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md:3692,perform,performance,3692,paper/paper.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md,1,['perform'],['performance']
Performance,"nt environment_.; Don't forget to *be careful* üèÑ and check which Oceananigans you installed:. ```julia; julia> Pkg.status(""Oceananigans""); ```. ## Running your first model. Let's run a two-dimensional, horizontally-periodic simulation of turbulence using 128¬≤ finite volume cells for 4 non-dimensional time units:. ```julia; using Oceananigans; grid = RectilinearGrid(CPU(), size=(128, 128), x=(0, 2œÄ), y=(0, 2œÄ), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO()); œµ(x, y) = 2rand() - 1; set!(model, u=œµ, v=œµ); simulation = Simulation(model; Œît=0.01, stop_time=4); run!(simulation); ```. But there's more: changing `CPU()` to `GPU()` makes this code run on a CUDA-enabled Nvidia GPU. Dive into [the documentation](https://clima.github.io/OceananigansDocumentation/stable/) for more code examples and tutorials.; Below, you'll find movies from GPU simulations along with CPU and GPU [performance benchmarks](https://github.com/clima/Oceananigans.jl#performance-benchmarks). ## The Oceananigans knowledge base. It's _deep_ and includes:. * [Documentation](https://clima.github.io/OceananigansDocumentation/stable) that provides; * example Oceananigans scripts,; * tutorials that describe key Oceananigans objects and functions,; * explanations of Oceananigans finite-volume-based numerical methods,; * details of the dynamical equations solved by Oceananigans models, and; * a library documenting all user-facing Oceananigans objects and functions.; * [Discussions on the Oceananigans github](https://github.com/CliMA/Oceananigans.jl/discussions), covering topics like; * [""Computational science""](https://github.com/CliMA/Oceananigans.jl/discussions/categories/computational-science), or how to science and set up numerical simulations in Oceananigans, and; * [""Experimental features""](https://github.com/CliMA/Oceananigans.jl/discussions?discussions_q=experimental+features), which covers new and sparsely-documented features for those who like to live danger",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:5769,perform,performance-benchmarks,5769,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['perform'],['performance-benchmarks']
Performance,"ons, and diagnostics.; Furthermore, in case of more complex GPU runs, some details could; sometimes prevent your simulation from running altogether. While Julia knowledge is obviously; desirable here, a user that is unfamiliar with Julia can get away with efficient simulations by; learning a few rules of thumb. It is nonetheless recommended that users go through Julia's; [performance tips](https://docs.julialang.org/en/v1/manual/performance-tips/), which contains more; in-depth explanations of some of the aspects discussed here. ## General (CPU/GPU) simulation tips. ### Avoid global variables whenever possible. In general using a [global; variable](https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Global-Scope) (which can be; loosely defined as a variable defined in the main script) inside functions slows down the code. One; way to circumvent this is to always [use local variables or pass them as arguments to; functions](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). This; helps the compiler optimize the code. Another way around this is to [define global variables as constants whenever; possible](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). One; thing to keep in mind when doing this is that when a `const` is defined, its value can't be changed; until you restart the Julia session. So this latter approach is good for production-ready code, but; may be undesirable in the early stages of development while you still have to change the parameters; of the simulation for exploration. It is especially important to avoid global variables in functions that are meant to be executed in; GPU kernels (such as functions defining boundary conditions and forcings). Otherwise the Julia GPU; compiler can fail with obscure errors. This is explained in more detail in the GPU simulation tips; section below. ### Consider inlining small functions. Inlining is when the compiler [replaces a function call wi",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:1318,perform,performance-tips,1318,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['perform'],['performance-tips']
Performance,"s, N_y-1 \, , \\; \lambda^z_k &= 4\frac{N_z^2}{L_z^2} \sin^2 \left [ \frac{(k-1) \pi}{2N_z} \right ], \quad k=0, 1, \dots, N_z-1 \, ,; \end{align}; ```; where ``\lambda^x`` and ``\lambda^y`` correspond to periodic boundary conditions in the horizontal and ``\lambda^z`` to; Neumann boundary conditions in the vertical. There is also an ambiguity in the solution to Poisson's equation as it's only defined up to a constant. To resolve this; ambiguity we choose the solution with zero mean by setting the zeroth Fourier coefficient ``p_{000}`` (corresponding to; ``k_x = k_y = k_z = 0``) to zero. This also has the added benefit of discarding the zero eigenvalue so we don't divide by; it. The Fast Fourier transforms are computed using FFTW.jl [[Frigo98](@cite) and [Frigo05](@cite)] on the CPU and using the; cuFFT library on the GPU. Along wall-bounded dimensions, the cosine transform is used. In particular, as the transforms; are performed on a staggered grid, DCT-II (`REDFT10`) is used to perform the forward cosine transform and DCT-III; (`REDFT01`) is used to perform the inverse cosine transform. ## Direct method with a vertically stretched grid. Using Fourier transforms for all three dimensions results in a method requiring ``\mathcal{O}(N \log_2 N)`` operations; where ``N`` is the total number of grid points. This algorithm can be made even more efficient by solving a tridiagonal; system along one of the dimensions and utilizing cyclic reduction. This results in the *Fourier analysis cyclic; reduction* or ``\text{FACR}(\ell)`` algorithm (with ``\ell`` cyclic reduction steps) which requires only; ``\mathcal{O}(N \log_2\log_2 N)`` operations provided the optimal number of cyclic reduction steps is taken, which is; ``\ell = \log_2 \log_2 n`` where ``n`` is the number of grid points in the cyclic reduction dimension. The FACR algorithm; was first developed by [Hockney69](@citet) and is well reviewed by [Swarztrauber77](@citet) then further benchmarked and; extended by [Temper",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:4697,perform,performed,4697,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,3,['perform'],"['perform', 'performed']"
Performance,"ses the 'discrete form'. Boundary condition functions that use the 'discrete form'; are called with the signature; ```julia; f(i, j, grid, clock, model_fields); ```; where `i, j` are grid indices that vary along the boundary, `grid` is `model.grid`,; `clock` is the `model.clock`, and `model_fields` is a `NamedTuple`; containing `u, v, w` and the fields in `model.tracers`.; The signature is similar for ``x`` and ``y`` boundary conditions expect that `i, j` is replaced; with `j, k` and `i, k` respectively. ### 8. Discrete-form boundary condition with parameters. ```jldoctest; julia> Cd = 0.2; # drag coefficient. julia> @inline linear_drag(i, j, grid, clock, model_fields, Cd) = @inbounds - Cd * model_fields.u[i, j, 1];. julia> u_bottom_bc = FluxBoundaryCondition(linear_drag, discrete_form=true, parameters=Cd); FluxBoundaryCondition: DiscreteBoundaryFunction linear_drag with parameters 0.2; ```. !!! info ""Inlining and avoiding bounds-checking in boundary condition functions""; Boundary condition functions should be decorated with `@inline` when running on CPUs for performance reasons.; On the GPU, all functions are force-inlined by default.; In addition, the annotation `@inbounds` should be used when accessing the elements of an array; in a boundary condition function (such as `model_fields.u[i, j, 1]` in the above example).; Using `@inbounds` will avoid a relatively expensive check that the index `i, j, 1` is 'in bounds'. ### 9. A random, spatially-varying, constant-in-time temperature flux specified by an array. ```jldoctest; julia> Nx = Ny = 16; # Number of grid points. julia> Q = randn(Nx, Ny); # temperature flux. julia> white_noise_T_bc = FluxBoundaryCondition(Q); FluxBoundaryCondition: 16√ó16 Matrix{Float64}; ```. When running on the GPU, `Q` must be converted to a `CuArray`. ## Building boundary conditions on a field. To create a set of [`FieldBoundaryConditions`](@ref) for a temperature field,; we write. ```jldoctest; julia> T_bcs = FieldBoundaryConditions(top = V",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md:15243,perform,performance,15243,docs/src/model_setup/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md,1,['perform'],['performance']
Performance,"ttps://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/free_convection_0956.png)](https://www.youtube.com/watch?v=yq4op9h3xcU). ### [Winds blowing over the ocean](https://www.youtube.com/watch?v=IRncfbvuiy8). [![Watch winds blowing over the ocean](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_0400.png)](https://www.youtube.com/watch?v=IRncfbvuiy8). ### [Free convection with wind stress](https://www.youtube.com/watch?v=ob6OMQgPfI4). [![Watch free convection with wind stress in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_unstable_7500.png)](https://www.youtube.com/watch?v=ob6OMQgPfI4). ## Performance benchmarks. We've performed some preliminary performance benchmarks (see the [performance benchmarks](https://clima.github.io/OceananigansDocumentation/stable/appendix/benchmarks/) section of the documentation) by initializing models of various sizes and measuring the wall clock time taken per model iteration (or time step). This is not really a fair comparison as we haven't parallelized across all the CPU's cores so we will revisit these benchmarks once Oceananigans.jl can run on multiple CPUs and GPUs. To make full use of or fully saturate the computing power of a GPU such as an Nvidia Tesla V100 or; a Titan V, the model should have around ~10 million grid points or more. Sometimes counter-intuitively running with `Float32` is slower than `Float64`. This is likely due; to type mismatches causing slowdowns as floats have to be converted between 32-bit and 64-bit, an; issue that needs to be addressed meticulously. Due to other bottlenecks such as memory accesses and; GPU register pressure, `Float32` models may not provide much of a speedup so the main benefit becomes; lower memory costs (by around a factor of 2). ![Performance benchmark plots](https://user-images.githubusercontent.com/20099589/89906791-d2c85b00-dbb9-11ea-969a-4b8db2c31680.png); ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:11578,bottleneck,bottlenecks,11578,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['bottleneck'],['bottlenecks']
Performance,"t} \left ( #1 \right )}; \begin{align}; \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} u & = \div{u \boldsymbol{v}} - u ( \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{v} ) \nonumber \\; & = \div{u \boldsymbol{v}} \, ,; \end{align}; ```; which can then be discretized similarly to the flux divergence operator, however, they must ; be discretized differently for each direction. For example, the ``x``-momentum advection operator is discretized as; ```math; \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} u; = \frac{1}{\overline{V}^x} \left[; \delta_x^{faa} \left( \overline{A_x u}^{caa} \overline{u}^{caa} \right); + \delta_y^{afa} \left( \overline{A_y v}^{aca} \overline{u}^{aca} \right); + \delta_z^{aaf} \left( \overline{A_z w}^{aac} \overline{u}^{aac} \right); \right] \, ,; ```; where ``\overline{V}^x`` is the average of the volumes of the cells on either side of the face ; in question. Calculating ``\partial_x (uu)`` can be performed by interpolating ``A_x u`` and ; ``u`` onto the cell centers then multiplying them and differencing them back onto the faces. ; However, in the case of the the two other terms, ``\partial_y (vu)`` and ``\partial_z (wu)``, ; the two variables must be interpolated onto the cell edges to be multiplied then differenced ; back onto the cell faces. ## Discretization of isotropic diffusion operators. An isotropic viscosity operator acting on vertical momentum is discretized via; ```math; \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \nu \boldsymbol{\nabla} w \right ); = \frac{1}{V} \left[; \delta_x^{faa} ( \nu \overline{A_x}^{caa} \partial_x^{caa} w ); + \delta_y^{afa} ( \nu \overline{A_y}^{aca} \partial_y^{aca} w ); + \delta_z^{aaf} ( \nu \overline{A_z}^{aac} \partial_z^{aac} w ); \right ] \, ,; ```; where ``\nu`` is the kinematic viscosity. An isotropic diffusion operator acting on a tracer ``c``, on the other hand, is discretized via; ```math; \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \kappa \boldsymbol{\nabla} c \right ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/spatial_operators.md:5597,perform,performed,5597,docs/src/numerical_implementation/spatial_operators.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/spatial_operators.md,1,['perform'],['performed']
Performance,"} = 0`` ; (Neumann on ``p`` for wall-bounded directions and periodic otherwise) and where ``\mathscr{F}`` ; denotes the source term for the Poisson equation. !!! note ""Hydrostatic approximation""; For problems in which the hydrostatic approximation is invoked, the Poisson equation for; pressure above only needs to be solved for the vertically integrated flow and the pressure; field is a two dimensional term ``p_S(x, y, t)``. ## Direct method. Discretizing elliptic problems that can be solved via a classical separation-of-variables approach, such as Poisson's; equation, results in a linear system of equations ``M \boldsymbol{x} = \boldsymbol{y}`` where ``M`` is a real symmetric matrix of block; tridiagonal form. This allows for the matrix to be decomposed and solved efficiently, provided that the eigenvalues and; eigenvectors of the blocks are known (¬ß2) [Buzbee70](@cite). In the case of Poisson's equation on a rectangle,; [Hockney65](@citet) has taken advantage of the fact that the fast Fourier transform can be used to perform the matrix; multiplication steps resulting in an even more efficient method. [Schumann88](@citet) describe the implementation of such; an algorithm for Poisson's equation on a staggered grid with Dirichlet, Neumann, and periodic boundary conditions. The method can be explained easily by taking the Fourier transform of both sides of \eqref{eq:poisson-pressure} to yield; ```math; \begin{equation}; \label{eq:poisson-spectral}; -(k_x^2 + k_y^2 + k_z^2) \widehat{p}_{NH} = \widehat{\mathscr{F}}; \quad \implies \quad; \widehat{p}_{NH} = - \frac{\widehat{\mathscr{F}}}{k_x^2 + k_y^2 + k_z^2} \, ,; \end{equation}; ```; where ``\widehat{\cdot}`` denotes the Fourier component. Here ``k_x``, ``k_y``, and ``k_z`` are the wavenumbers. However, when; solving the equation on a staggered grid we require a solution for ``p_{NH}`` that is second-order accurate such that; when when its Laplacian is computed, ``\nabla^2 p_{NH}`` matches ``\mathscr{F}`` to machine pre",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:1705,perform,perform,1705,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['perform'],['perform']
Performance,"‚îÇ 7.35221 ‚îÇ; ‚îÇ (2, 0) ‚îÇ 111.678 ‚îÇ 1.66267 ‚îÇ 6.91569 ‚îÇ; ‚îÇ (2, 3) ‚îÇ 118.737 ‚îÇ 1.55043 ‚îÇ 4.57587 ‚îÇ; ‚îÇ (2, 5) ‚îÇ 133.803 ‚îÇ 1.5155 ‚îÇ 4.87734 ‚îÇ; ‚îÇ (2, 10) ‚îÇ 137.615 ‚îÇ 1.44535 ‚îÇ 4.0466 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò. Arbitrary tracers relative performance (CPU); ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ Architectures ‚îÇ tracers ‚îÇ slowdown ‚îÇ memory ‚îÇ allocs ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ CPU ‚îÇ (0, 0) ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ; ‚îÇ CPU ‚îÇ (0, 1) ‚îÇ 1.09293 ‚îÇ 1.39873 ‚îÇ 1.17271 ‚îÇ; ‚îÇ CPU ‚îÇ (0, 2) ‚îÇ 1.15948 ‚îÇ 1.99019 ‚îÇ 1.38345 ‚îÇ; ‚îÇ CPU ‚îÇ (1, 0) ‚îÇ 1.06409 ‚îÇ 1.39873 ‚îÇ 1.17271 ‚îÇ; ‚îÇ CPU ‚îÇ (2, 0) ‚îÇ 1.17887 ‚îÇ 1.99054 ‚îÇ 1.38949 ‚îÇ; ‚îÇ CPU ‚îÇ (2, 3) ‚îÇ 1.55493 ‚îÇ 4.04677 ‚îÇ 2.37198 ‚îÇ; ‚îÇ CPU ‚îÇ (2, 5) ‚îÇ 1.97115 ‚îÇ 5.84537 ‚îÇ 2.96377 ‚îÇ; ‚îÇ CPU ‚îÇ (2, 10) ‚îÇ 2.6031 ‚îÇ 11.7179 ‚îÇ 4.63889 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò. Arbitrary tracers relative performance (GPU); ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ Architectures ‚îÇ tracers ‚îÇ slowdown ‚îÇ memory ‚îÇ allocs ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ GPU ‚îÇ (0, 0) ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ; ‚îÇ GPU ‚îÇ (0, 1) ‚îÇ 1.0941 ‚îÇ 1.39053 ‚îÇ 1.16013 ‚îÇ; ‚îÇ GPU ‚îÇ (0, 2) ‚îÇ 1.19399 ‚îÇ 1.85081 ‚îÇ 1.29592 ‚îÇ; ‚îÇ GPU ‚îÇ (1, 0) ‚îÇ 1.08489 ‚îÇ 1.39037 ‚îÇ 1.15883 ‚îÇ; ‚îÇ GPU ‚îÇ (2, 0) ‚îÇ 1.19157 ‚îÇ 1.85109 ‚îÇ 1.29153 ‚îÇ; ‚îÇ GPU ‚îÇ (2, 3) ‚îÇ 1.47824 ‚îÇ 3.50924 ‚îÇ 1.45881 ‚îÇ; ‚îÇ GPU ‚îÇ (2, 5) ‚îÇ 1.66293 ‚îÇ 4.95474 ‚îÇ 1.94286 ‚îÇ; ‚îÇ GPU ‚îÇ (2, 10) ‚îÇ 2.13524 ‚îÇ 9.47276 ‚îÇ 2.52301 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò; ```. ## Turbulence closures. This benchmark tests the performance impacts of various turbulent diffusivity closures; and large eddy simulation (LES) models as well as how much speedup they experience going from CPU to GPU. ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:34828,perform,performance,34828,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['perform'],['performance']
Safety," viscosity and diffusivity *predictors*; ``\nu_e^\dagger`` and ``\kappa_e^\dagger``, such that; ```math; \nu_e = \max \lbrace 0, \nu_e^\dagger \rbrace; \quad \text{and} \quad; \kappa_e = \max \lbrace 0, \kappa_e^\dagger \rbrace \, ,; ```; to ensure that ``\nu_e \ge 0`` and ``\kappa_e \ge 0``. Leaving out the overlines and understanding that all variables; represent the resolved/filtered variables, the eddy viscosity predictor is given by; ```math; \begin{equation}; \label{eq:nu-dagger}; \nu_e^\dagger = -(C\Delta)^2; \frac; {\left( \hat{\partial}_k \hat{v}_i \right) \left( \hat{\partial}_k \hat{v}_j \right) \hat{S}_{ij}; + C_b\hat{\delta}_{i3} \alpha g \left( \hat{\partial}_k \hat{v_i} \right) \hat{\partial}_k \theta}; {\left( \hat{\partial}_l \hat{v}_m \right) \left( \hat{\partial}_l \hat{v}_m \right)} \, ,; \end{equation}; ```; and the eddy diffusivity predictor by; ```math; \begin{equation}; \kappa_e^\dagger = -(C\Delta)^2; \frac; {\left( \hat{\partial}_k \hat{v}_i \right) \left( \hat{\partial}_k \hat{\theta} \right) \hat{\partial}_i \theta}; {\left( \hat{\partial}_l \hat{\theta} \right) \left( \hat{\partial}_l \hat{\theta} \right)} \, ,; \end{equation}; ```; where; ```math; \begin{equation}; \hat{x}_i = \frac{x_i}{\Delta_i}, \quad; \hat{v}_i(\hat{x}, t) = \frac{v_i(x, t)}{\Delta_i}, \quad; \hat{\partial}_i \hat{v}_j(\hat{x}, t) = \frac{\Delta_i}{\Delta_j} \partial_i v_j(x, t), \quad; \hat{\delta}_{i3} = \frac{\delta_{i3}}{\Delta_3} \, ,; \end{equation}; ```; so that the normalized rate of strain tensor is; ```math; \begin{equation}; \label{eq:S-hat}; \hat{S}_{ij} =; \frac{1}{2} \left[ \hat{\partial}_i \hat{v}_j(\hat{x}, t) + \hat{\partial}_j \hat{v}_i(\hat{x}, t) \right] \, .; \end{equation}; ```. In equations \eqref{eq:nu-dagger}--\eqref{eq:S-hat}, ``C`` is a modified Poincar√© ""constant"" that is independent from; the filter width ``\Delta`` but does depend on the accuracy of the discretization method used. [Abkar16](@citet) cite; ``C^2 = \frac{1}{12}`` for a spe",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md:6070,predict,predictor,6070,docs/src/numerical_implementation/large_eddy_simulation.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md,2,['predict'],['predictor']
Safety,", .; \end{equation}; ```; In the definitions of the eddy viscosity and eddy diffusivity predictor, ``C`` and ``C_b`` are; user-specified model constants, ``\Delta_f`` is a ""filter width"" associated with the finite volume; grid spacing, and the hat decorators on partial derivatives, velocities, and the Kronecker; delta ``\hat \delta_{i3}`` are defined such that; ```math; \hat \partial_i \equiv \Delta_i \partial_i, \qquad; \hat{v}_i(x, t) \equiv \frac{v_i(x, t)}{\Delta_i}, \quad \text{and} \quad; \hat{\delta}_{i3} \equiv \frac{\delta_{i3}}{\Delta_3} \, .; ```; A velocity gradient, for example, is therefore; ``\hat{\partial}_i \hat{v}_j(x, t) = \frac{\Delta_i}{\Delta_j} \partial_i v_j(x, t)``,; while the normalized strain tensor is; ```math; \hat{\Sigma}_{ij} =; \frac{1}{2} \left[ \hat{\partial}_i \hat{v}_j(x, t) + \hat{\partial}_j \hat{v}_i(x, t) \right] \, .; ```; The filter width ``\Delta_f`` in that appears in the viscosity and diffusivity predictors; is taken as the square root of the harmonic mean of the squares of the filter widths in; each direction:; ```math; \frac{1}{\Delta_f^2} = \frac{1}{3} \left( \frac{1}{\Delta x^2}; + \frac{1}{\Delta y^2}; + \frac{1}{\Delta z^2} \right) \, .; ```; The constant ``C_b`` permits the ""buoyancy modification"" term it multiplies to be omitted; from a calculation. By default we use the model constants ``C = 1/12`` and ``C_b = 0``. ## Convective adjustment vertical diffusivity. This closure aims to model the enhanced mixing that occurs due to convection.; At every point and for every time instance, the closure diagnoses the gravitational stability of the fluid and; applies the vertical diffusivities (i) `background_ŒΩz` to `u, v` and `background_Œ∫z` to all tracers if the fluid; is gravitationally neutral or stable with ``‚àÇb/‚àÇz ‚â• 0``, or (ii) `convective_ŒΩz` and `convective_Œ∫z` if ``‚àÇb/‚àÇz < 0``. This closure is a plausible model for convection if `convective_Œ∫z` ``\gg`` `background_Œ∫z` and `convective_ŒΩz` ``\gg`` `background_ŒΩz`.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/turbulence_closures.md:7392,predict,predictors,7392,docs/src/physics/turbulence_closures.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/turbulence_closures.md,1,['predict'],['predictors']
Safety,"ce_model). The [`HydrostaticFreeSurfaceModel`](@ref) solves the incompressible Navier-Stokes equations under; the Boussinesq and hydrostatic approximations and with an arbitrary number of tracer conservation ; equations. Physics associated with individual terms in the momentum and tracer conservation; equations -- the background rotation rate of the equation's reference frame,; gravitational effects associated with buoyant tracers under the Boussinesq; approximation, generalized stresses and tracer fluxes associated with viscous and; diffusive physics, and arbitrary ""forcing functions"" -- are determined by the whims of the; user. ## Mass conservation and free surface evolution equation. The mass conservation equation is; ```math; 0 = \boldsymbol{\nabla}_h \boldsymbol{\cdot} \boldsymbol{u} + \partial_z w \, . ; ```. Given the horizontal flow ``\boldsymbol{u}`` we use the above to diagnose the vertical velocity ``w``.; We integrate the mass conservation equation from the bottom of the fluid (where ``w = 0``) up to; depth ``z`` and recover ``w(x, y, z, t)``. The free surface displacement ``\eta(x, y, t)`` satisfies the linearized kinematic boundary ; condition at the surface; ```math; \partial_t \eta = w(x, y, z=0, t) \, .; ```. ## The momentum conservation equation. The equations governing the conservation of momentum in a rotating fluid, including buoyancy; via the Boussinesq approximation are; ```math; \begin{align}; \partial_t \boldsymbol{u} & = - \left ( \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} \right ) \boldsymbol{u}; - \boldsymbol{f} \times \boldsymbol{u} ; - \boldsymbol{\nabla}_h (p + g \eta); - \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{\tau}; + \boldsymbol{F_u} \, , \label{eq:momentum}\\; 0 & = b - \partial_z p \, , \label{eq:hydrostatic}; \end{align}; ```; where ``b`` the is buoyancy, ``\boldsymbol{\tau}`` is the hydrostatic kinematic stress tensor, ; ``\boldsymbol{F_u}`` denotes an internal forcing of the horizontal flow ``\boldsymbol{u",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/hydrostatic_free_surface_model.md:1113,recover,recover,1113,docs/src/physics/hydrostatic_free_surface_model.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/hydrostatic_free_surface_model.md,1,['recover'],['recover']
Safety,"d by the boundary condition is the point lying on the boundary, where as for a ; tracer on `(Center, Center, Center)` points the open boundary condition specifies a point outside; of the domain (hence the difference with `Value` boundary conditions). The other important detail is that open (including no-penetration) boundary conditions are the ; only conditions used on wall normal velocities when the domain is not periodic. This means that ; their value affects the pressure calculation for nonhydrostatic models as it is involved in ; calculating the divergence in the boundary adjacent center point (as described in the ; [fractional step method](@ref time_stepping) documentation). Usually boundary points are filled; for the predictor velocity (i.e. before the pressure is calculated), and on the corrected field; (i.e. after the pressure correction is applied), but for open boundaries this would result in; the boundary adjacent center point becoming divergent so open boundaries are only filled for the ; predictor velocity and stay the same after the pressure correction (so the boundary point is filled; with the final corrected velocity at the predictor step). The restriction arrises as the boundary condition is specifying the wall normal velocity, ; ``\hat{\boldsymbol{n}}\cdot\boldsymbol{u}``, which leads to the pressure boundary condition; ```math; \begin{equation}; \label{eq:pressure_boundary_condition}; \Delta t \, \hat{\boldsymbol{n}}\cdot\boldsymbol{\nabla}p^{n+1}\big |_{\partial\Omega} = \left[\Delta t \, \hat{\boldsymbol{n}}\cdot\boldsymbol{u}^\star - \hat{\boldsymbol{n}}\cdot\boldsymbol{u}^{n+1}\right],; \end{equation}; ```; implying that there is a pressure gradient across the boundary. Since we solve the pressure poisson ; equation (``\nabla^2p^{n+1}=\frac{\boldsymbol{\nabla}\cdot\boldsymbol{u}^\star}{\Delta t}``); using the method described by [Schumann88](@citet) we have to move inhomogeneus boundary conditions; on the pressure to the right hand side. In ord",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md:7919,predict,predictor,7919,docs/src/numerical_implementation/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md,2,['predict'],['predictor']
Safety,"er_ constant_fluxes.jl#L380-L383) and how it can be; [used in calculations](https://github.com/CliMA/LESbrary.jl/blob/cf31b0ec20219d5ad698af334811d448c27213b0/src/TurbulenceStatistics/first_through_third_order.jl#L109-L112). ### Arrays in GPUs are usually different from arrays in CPUs. Oceananigans.jl uses [`CUDA.CuArray`](https://cuda.juliagpu.org/stable/usage/array/) to store ; data for GPU computations. One limitation of `CuArray`s compared to the `Array`s used for ; CPU computations is that `CuArray` elements in general cannot be accessed outside kernels; launched through CUDA.jl or KernelAbstractions.jl. (You can learn more about GPU kernels ; [here](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#kernels) and ; [here](https://cuda.juliagpu.org/stable/usage/overview/#Kernel-programming-with-@cuda).); Doing so requires individual elements to be copied from or to the GPU for processing,; which is very slow and can result in huge slowdowns. To avoid such unintentional slowdowns,; Oceananigans.jl disables CUDA scalar indexing by default. See the; [scalar indexing](https://juliagpu.github.io/CUDA.jl/dev/usage/workflow/#UsageWorkflowScalar); section of the CUDA.jl documentation for more information on scalar indexing. For example, if can be difficult to just view a `CuArray` since Julia needs to access ; its elements to do that. Consider the example below:. ```julia; julia> using Oceananigans, Adapt. julia> grid = RectilinearGrid(GPU(); size=(1, 1, 1), extent=(1, 1, 1), halo=(1, 1, 1)); 1√ó1√ó1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 1.0) regularly spaced with Œîx=1.0; ‚îú‚îÄ‚îÄ Periodic y ‚àà [0.0, 1.0) regularly spaced with Œîy=1.0; ‚îî‚îÄ‚îÄ Bounded z ‚àà [-1.0, 0.0] regularly spaced with Œîz=1.0. julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ‚îú‚îÄ‚îÄ grid: 1√ó1√ó1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1√ó1√ó1 halo; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:11106,avoid,avoid,11106,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['avoid'],['avoid']
Safety,"he completion of; a timestep. The other options are `callsite = TendencyCallsite()` that executes the callback; after the tendencies are computed but _before_ taking a timestep and `callsite = UpdateStateCallsite()`; that executes the callback within `update_state!`, after auxiliary variables have been computed; (for multi-stage time-steppers, `update_state!` may be called multiple times per timestep). As an example of a callback with `callsite = TendencyCallsite()` , we show below how we can; manually add to the tendency field of one of the velocity components. Here we've chosen; the `:u` field using parameters:. ```@example checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))). simulation = Simulation(model, Œît=1, stop_iteration=10). function modify_tendency!(model, params); model.timestepper.G‚Åø[params.c] .+= params.Œ¥; return nothing; end. simulation.callbacks[:modify_u] = Callback(modify_tendency!, IterationInterval(1),; callsite = TendencyCallsite(),; parameters = (c = :u, Œ¥ = 1)). run!(simulation); ```. Above there is no forcing at all, but due to the callback the ``u``-velocity is increased. ```@example checkpointing; @info model.velocities.u; ```. !!! note ""Example only for illustration purposes""; The above is a redundant example since it could be implemented better with a simple forcing function.; We include it here though for illustration purposes of how one can use callbacks. ## Functions. Callback functions can only take one or two parameters `sim` - a simulation, or `model` for state callbacks, and optionally may also accept a NamedTuple of parameters. ## Scheduling. The time that callbacks are called at are specified by schedule functions which can be:; - [`IterationInterval`](@ref) : runs every `n` iterations; - [`TimeInterval`](@ref) : runs every `n`s of model run time; - [`SpecifiedTimes`](@ref) : runs at the specified times; - [`WallTimeInterval`](@ref) : runs every `n`s of wall time; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/callbacks.md:2412,redund,redundant,2412,docs/src/model_setup/callbacks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/callbacks.md,1,['redund'],['redundant']
Safety,"ing the method described by [Schumann88](@citet) we have to move inhomogeneus boundary conditions; on the pressure to the right hand side. In order to do this we define a new field ``\phi`` where; ```math; \begin{equation}; \label{eq:modified_pressure_field}; \phi = p^{n+1} \quad \text{inside} \quad \Omega \quad \text{but} \quad \boldsymbol{\nabla} \cdot \boldsymbol{\nabla} \phi \, \big |_{\partial\Omega} = 0.; \end{equation}; ```; This moves the boundary condition to the right hand side as ``\phi`` becomes; ```math; \begin{equation}; \label{eq:modified_pressure_poisson}; \boldsymbol{\nabla}^2\phi^{n+1} = \boldsymbol{\nabla}\cdot\left[\frac{\boldsymbol{u}^\star}{\Delta t} - \delta\left(\boldsymbol{x} - \boldsymbol{x}_\Omega\right)\boldsymbol{\nabla}p\right].; \end{equation}; ```; Given the boundary condition on pressure given above, we can define a new modified predictor velocity; which is equal to the predictor velocity within the domain but shares boundary conditions with the ; corrected field,; ```math; \begin{equation}; \label{eq:quasi_predictor_velocity}; \tilde{\boldsymbol{u}}^\star:=\boldsymbol{u}^\star + \delta\left(\boldsymbol{x} - \boldsymbol{x}_\Omega\right)(\boldsymbol{u}^{n+1} - \boldsymbol{u}^\star).; \end{equation}; ```; The modified pressure poisson equation becomes ``\nabla^2p^{n+1}=\frac{\boldsymbol{\nabla}\cdot\tilde{\boldsymbol{u}}^\star}{\Delta t}``; which can easily be solved. . Perhaps a more intuitive way to consider this is to recall that the corrector step projects ``\boldsymbol{u}^\star``; to the space of divergenece free velocity by applying; ```math; \begin{equation}; \label{eq:pressure_correction_step}; \boldsymbol{u}^{n+1} = \boldsymbol{u}^\star - \Delta t\boldsymbol{\nabla}p^{n+1},; \end{equation}; ```; but we have changed ``p^{n+1}`` to ``\phi`` and ``\boldsymbol{u}^\star`` to ``\tilde{\boldsymbol{u}}^\star``; so for ``\boldsymbol{\nabla}\phi \big |_{\partial\Omega} = 0`` the modified predictor velocity must; equal the corrected veloc",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md:9633,predict,predictor,9633,docs/src/numerical_implementation/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md,2,['predict'],['predictor']
Safety,"lang.org/en/v1/manual/variables-and-scoping/#Global-Scope) (which can be; loosely defined as a variable defined in the main script) inside functions slows down the code. One; way to circumvent this is to always [use local variables or pass them as arguments to; functions](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). This; helps the compiler optimize the code. Another way around this is to [define global variables as constants whenever; possible](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). One; thing to keep in mind when doing this is that when a `const` is defined, its value can't be changed; until you restart the Julia session. So this latter approach is good for production-ready code, but; may be undesirable in the early stages of development while you still have to change the parameters; of the simulation for exploration. It is especially important to avoid global variables in functions that are meant to be executed in; GPU kernels (such as functions defining boundary conditions and forcings). Otherwise the Julia GPU; compiler can fail with obscure errors. This is explained in more detail in the GPU simulation tips; section below. ### Consider inlining small functions. Inlining is when the compiler [replaces a function call with the body of the function that is being; called before compiling](https://en.wikipedia.org/wiki/Inline_expansion). The advantage of inlining; (which in julia can be done with the [`@inline`; macro](https://docs.julialang.org/en/v1/devdocs/meta/)) is that gets rid of the time spent calling; the function. The Julia compiler automatically makes some calls as to what functions it should or; shouldn't inline, but you can force a function to be inlined by including the macro `@inline` before; its definition. This is more suited for small functions that are called often. Here's an example of; an implementation of the Heaviside function that forces it to be inlined:. ```ju",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:1949,avoid,avoid,1949,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['avoid'],['avoid']
Safety,"la} \times \boldsymbol{v}``; is defined at the cell edges.[^1]. [^1]: In 2D it would more correct to say the cell corners. In 3D, variables like vorticity lie at the same vertical; levels as the cell-centered variables and so they really lie at the cell edges. ![Schematic of control volumes](../numerical_implementation/assets/staggered_grid.png); *A schematic of `Oceananigans.jl` finite volumes for a two-dimensional staggered grid in ``(x, z)``.; Tracers ``c`` and pressure ``p`` are defined at the center of the control volume. The ``u`` control volumes are ; centered on the left and right edges of the pressure control volume while the ``w`` control volumes are centered ; on the top and bottom edges of the pressure control volumes. The indexing convention places the ``i^{\rm{th}}`` ; ``u``-node on cell ``x``-faces to the left of the ``i`` tracer point at cell centers.*. This staggered arrangement of variables is more complicated than the collocated grid arrangement but is greatly; beneficial as it avoids the odd-even decoupling between the pressure and velocity if they are stored at the same; positions. ¬ß6.1 of [Patankar80](@citet) discusses this problem in the presence of a zigzag pressure field: on a 1D; collocated grid the velocity at the point ``i`` is influenced by the pressure at points ``i-1`` and ``i+1``, and a zigzag; pressure field will be felt as a uniform pressure, which is obviously wrong and would reduce the accuracy of the; solution. The pressure is effectively taken from a coarser grid than what is actually used. The basic problem is that; the momentum equations will use the pressure difference between two alternate points when it should be using two; adjacent points. From the viewpoint of linear algebra, these spurious pressure modes correspond to solutions in the null space of the; pressure projection operator with eigenvalue zero and are thus indistinguishable from a uniform pressure field; [Sani81](@cite). The staggered grid was first introduced b",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/staggered_grid.md:1467,avoid,avoids,1467,docs/src/appendix/staggered_grid.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/staggered_grid.md,1,['avoid'],['avoids']
Safety,"l{x}_\Omega\right)\boldsymbol{\nabla}p\right].; \end{equation}; ```; Given the boundary condition on pressure given above, we can define a new modified predictor velocity; which is equal to the predictor velocity within the domain but shares boundary conditions with the ; corrected field,; ```math; \begin{equation}; \label{eq:quasi_predictor_velocity}; \tilde{\boldsymbol{u}}^\star:=\boldsymbol{u}^\star + \delta\left(\boldsymbol{x} - \boldsymbol{x}_\Omega\right)(\boldsymbol{u}^{n+1} - \boldsymbol{u}^\star).; \end{equation}; ```; The modified pressure poisson equation becomes ``\nabla^2p^{n+1}=\frac{\boldsymbol{\nabla}\cdot\tilde{\boldsymbol{u}}^\star}{\Delta t}``; which can easily be solved. . Perhaps a more intuitive way to consider this is to recall that the corrector step projects ``\boldsymbol{u}^\star``; to the space of divergenece free velocity by applying; ```math; \begin{equation}; \label{eq:pressure_correction_step}; \boldsymbol{u}^{n+1} = \boldsymbol{u}^\star - \Delta t\boldsymbol{\nabla}p^{n+1},; \end{equation}; ```; but we have changed ``p^{n+1}`` to ``\phi`` and ``\boldsymbol{u}^\star`` to ``\tilde{\boldsymbol{u}}^\star``; so for ``\boldsymbol{\nabla}\phi \big |_{\partial\Omega} = 0`` the modified predictor velocity must; equal the corrected velocity on the boundary. For simple open boundary conditions such as no penetration or a straight forward prescription of; a known velocity at ``t^{n+1}`` this is simple to implement as we just set the boundary condition; on the predictor velocity and don't change it after the correction. But some open boundary methods; calculate the boundary value based on the interior solution. As a simple example, if we wanted to ; set the wall normal veloicty gradient to zero at the west boundary then we would set the boundary ; point to; ```math; \begin{equation}; \label{eq:zero_wall_normal_velocity_gradient}; u^\star_{1jk} \approx u^\star_{3jk} + (u^\star_{2jk} - u^\star_{jk4}) / 2 + \mathcal{O}(\Delta x^2),; \end{equation}; `",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md:10710,predict,predictor,10710,docs/src/numerical_implementation/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md,1,['predict'],['predictor']
Safety,"pa`` are the; constant isotropic background viscosity and diffusivities for each tracer. The eddy viscosity ; predictor is; ```math; \begin{equation}; \nu_e^\dagger = C \Delta_f^2; \frac; {(\hat{\partial}_k \hat{v}_i) (\hat{\partial}_k \hat{v}_j) \hat{\Sigma}_{ij}; + C_b \hat{\delta}_{i3} (\hat{\partial}_k \hat{v_i}) (\hat{\partial}_k b)}; {(\hat{\partial}_l \hat{v}_m) (\hat{\partial}_l \hat{v}_m)} \, ,; \label{eq:nu-dagger}; \end{equation}; ```; while the eddy diffusivity predictor for tracer ``c`` is; ```math; \begin{equation}; \label{eq:kappa-dagger}; \kappa_e^\dagger = C \Delta_f^2; \frac; {(\hat{\partial}_k \hat{v}_i) (\hat{\partial}_k c) (\hat{\partial}_i c)}; {(\hat{\partial}_l c) (\hat{\partial}_l c)} \, .; \end{equation}; ```; In the definitions of the eddy viscosity and eddy diffusivity predictor, ``C`` and ``C_b`` are; user-specified model constants, ``\Delta_f`` is a ""filter width"" associated with the finite volume; grid spacing, and the hat decorators on partial derivatives, velocities, and the Kronecker; delta ``\hat \delta_{i3}`` are defined such that; ```math; \hat \partial_i \equiv \Delta_i \partial_i, \qquad; \hat{v}_i(x, t) \equiv \frac{v_i(x, t)}{\Delta_i}, \quad \text{and} \quad; \hat{\delta}_{i3} \equiv \frac{\delta_{i3}}{\Delta_3} \, .; ```; A velocity gradient, for example, is therefore; ``\hat{\partial}_i \hat{v}_j(x, t) = \frac{\Delta_i}{\Delta_j} \partial_i v_j(x, t)``,; while the normalized strain tensor is; ```math; \hat{\Sigma}_{ij} =; \frac{1}{2} \left[ \hat{\partial}_i \hat{v}_j(x, t) + \hat{\partial}_j \hat{v}_i(x, t) \right] \, .; ```; The filter width ``\Delta_f`` in that appears in the viscosity and diffusivity predictors; is taken as the square root of the harmonic mean of the squares of the filter widths in; each direction:; ```math; \frac{1}{\Delta_f^2} = \frac{1}{3} \left( \frac{1}{\Delta x^2}; + \frac{1}{\Delta y^2}; + \frac{1}{\Delta z^2} \right) \, .; ```; The constant ``C_b`` permits the ""buoyancy modification"" term it mult",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/turbulence_closures.md:6525,predict,predictor,6525,docs/src/physics/turbulence_closures.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/turbulence_closures.md,1,['predict'],['predictor']
Safety,"pen boundaries behave differently for fields on face points in the ; boundary direction due to the [staggered grid](@ref finite_volume). For example, the u-component; of velocity lies on `(Face, Center, Center)` points so for open `west` or `east` boundaries the ; point specified by the boundary condition is the point lying on the boundary, where as for a ; tracer on `(Center, Center, Center)` points the open boundary condition specifies a point outside; of the domain (hence the difference with `Value` boundary conditions). The other important detail is that open (including no-penetration) boundary conditions are the ; only conditions used on wall normal velocities when the domain is not periodic. This means that ; their value affects the pressure calculation for nonhydrostatic models as it is involved in ; calculating the divergence in the boundary adjacent center point (as described in the ; [fractional step method](@ref time_stepping) documentation). Usually boundary points are filled; for the predictor velocity (i.e. before the pressure is calculated), and on the corrected field; (i.e. after the pressure correction is applied), but for open boundaries this would result in; the boundary adjacent center point becoming divergent so open boundaries are only filled for the ; predictor velocity and stay the same after the pressure correction (so the boundary point is filled; with the final corrected velocity at the predictor step). The restriction arrises as the boundary condition is specifying the wall normal velocity, ; ``\hat{\boldsymbol{n}}\cdot\boldsymbol{u}``, which leads to the pressure boundary condition; ```math; \begin{equation}; \label{eq:pressure_boundary_condition}; \Delta t \, \hat{\boldsymbol{n}}\cdot\boldsymbol{\nabla}p^{n+1}\big |_{\partial\Omega} = \left[\Delta t \, \hat{\boldsymbol{n}}\cdot\boldsymbol{u}^\star - \hat{\boldsymbol{n}}\cdot\boldsymbol{u}^{n+1}\right],; \end{equation}; ```; implying that there is a pressure gradient across the boundary. ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md:7636,predict,predictor,7636,docs/src/numerical_implementation/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md,1,['predict'],['predictor']
Safety,"ppen18](@citet) and was; described and tested by [Vreugdenhil18](@citet). The AMD model uses an eddy diffusivity hypothesis; similar the Smagorinsky-Lilly model. In the AMD model, the eddy viscosity and diffusivity for each; tracer are defined in terms of eddy viscosity and diffusivity *predictors* ``\nu_e^\dagger`` and ``\kappa_e^\dagger``,; such that; ```math; \nu_e = \max \left ( 0, \nu_e^\dagger \right ) + \nu; \quad \text{and} \quad; \kappa_e = \max \left ( 0, \kappa_e^\dagger \right ) + \kappa \, ,; ```; to ensure that ``\nu_e \ge 0`` and ``\kappa_e \ge 0``, where ``\nu`` and ``\kappa`` are the; constant isotropic background viscosity and diffusivities for each tracer. The eddy viscosity ; predictor is; ```math; \begin{equation}; \nu_e^\dagger = C \Delta_f^2; \frac; {(\hat{\partial}_k \hat{v}_i) (\hat{\partial}_k \hat{v}_j) \hat{\Sigma}_{ij}; + C_b \hat{\delta}_{i3} (\hat{\partial}_k \hat{v_i}) (\hat{\partial}_k b)}; {(\hat{\partial}_l \hat{v}_m) (\hat{\partial}_l \hat{v}_m)} \, ,; \label{eq:nu-dagger}; \end{equation}; ```; while the eddy diffusivity predictor for tracer ``c`` is; ```math; \begin{equation}; \label{eq:kappa-dagger}; \kappa_e^\dagger = C \Delta_f^2; \frac; {(\hat{\partial}_k \hat{v}_i) (\hat{\partial}_k c) (\hat{\partial}_i c)}; {(\hat{\partial}_l c) (\hat{\partial}_l c)} \, .; \end{equation}; ```; In the definitions of the eddy viscosity and eddy diffusivity predictor, ``C`` and ``C_b`` are; user-specified model constants, ``\Delta_f`` is a ""filter width"" associated with the finite volume; grid spacing, and the hat decorators on partial derivatives, velocities, and the Kronecker; delta ``\hat \delta_{i3}`` are defined such that; ```math; \hat \partial_i \equiv \Delta_i \partial_i, \qquad; \hat{v}_i(x, t) \equiv \frac{v_i(x, t)}{\Delta_i}, \quad \text{and} \quad; \hat{\delta}_{i3} \equiv \frac{\delta_{i3}}{\Delta_3} \, .; ```; A velocity gradient, for example, is therefore; ``\hat{\partial}_i \hat{v}_j(x, t) = \frac{\Delta_i}{\Delta_j} \partial_i",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/turbulence_closures.md:5827,predict,predictor,5827,docs/src/physics/turbulence_closures.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/turbulence_closures.md,2,['predict'],['predictor']
Safety,"s similar for ``x`` and ``y`` boundary conditions expect that `i, j` is replaced; with `j, k` and `i, k` respectively. ### 8. Discrete-form boundary condition with parameters. ```jldoctest; julia> Cd = 0.2; # drag coefficient. julia> @inline linear_drag(i, j, grid, clock, model_fields, Cd) = @inbounds - Cd * model_fields.u[i, j, 1];. julia> u_bottom_bc = FluxBoundaryCondition(linear_drag, discrete_form=true, parameters=Cd); FluxBoundaryCondition: DiscreteBoundaryFunction linear_drag with parameters 0.2; ```. !!! info ""Inlining and avoiding bounds-checking in boundary condition functions""; Boundary condition functions should be decorated with `@inline` when running on CPUs for performance reasons.; On the GPU, all functions are force-inlined by default.; In addition, the annotation `@inbounds` should be used when accessing the elements of an array; in a boundary condition function (such as `model_fields.u[i, j, 1]` in the above example).; Using `@inbounds` will avoid a relatively expensive check that the index `i, j, 1` is 'in bounds'. ### 9. A random, spatially-varying, constant-in-time temperature flux specified by an array. ```jldoctest; julia> Nx = Ny = 16; # Number of grid points. julia> Q = randn(Nx, Ny); # temperature flux. julia> white_noise_T_bc = FluxBoundaryCondition(Q); FluxBoundaryCondition: 16√ó16 Matrix{Float64}; ```. When running on the GPU, `Q` must be converted to a `CuArray`. ## Building boundary conditions on a field. To create a set of [`FieldBoundaryConditions`](@ref) for a temperature field,; we write. ```jldoctest; julia> T_bcs = FieldBoundaryConditions(top = ValueBoundaryCondition(20.0),; bottom = GradientBoundaryCondition(0.01)); Oceananigans.FieldBoundaryConditions, with boundary conditions; ‚îú‚îÄ‚îÄ west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing); ‚îú‚îÄ‚îÄ east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing); ‚îú‚îÄ‚îÄ south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing); ‚îú‚îÄ‚îÄ north: DefaultBoundaryCondition (FluxBound",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md:15533,avoid,avoid,15533,docs/src/model_setup/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md,1,['avoid'],['avoid']
Safety,"ses the 'discrete form'. Boundary condition functions that use the 'discrete form'; are called with the signature; ```julia; f(i, j, grid, clock, model_fields); ```; where `i, j` are grid indices that vary along the boundary, `grid` is `model.grid`,; `clock` is the `model.clock`, and `model_fields` is a `NamedTuple`; containing `u, v, w` and the fields in `model.tracers`.; The signature is similar for ``x`` and ``y`` boundary conditions expect that `i, j` is replaced; with `j, k` and `i, k` respectively. ### 8. Discrete-form boundary condition with parameters. ```jldoctest; julia> Cd = 0.2; # drag coefficient. julia> @inline linear_drag(i, j, grid, clock, model_fields, Cd) = @inbounds - Cd * model_fields.u[i, j, 1];. julia> u_bottom_bc = FluxBoundaryCondition(linear_drag, discrete_form=true, parameters=Cd); FluxBoundaryCondition: DiscreteBoundaryFunction linear_drag with parameters 0.2; ```. !!! info ""Inlining and avoiding bounds-checking in boundary condition functions""; Boundary condition functions should be decorated with `@inline` when running on CPUs for performance reasons.; On the GPU, all functions are force-inlined by default.; In addition, the annotation `@inbounds` should be used when accessing the elements of an array; in a boundary condition function (such as `model_fields.u[i, j, 1]` in the above example).; Using `@inbounds` will avoid a relatively expensive check that the index `i, j, 1` is 'in bounds'. ### 9. A random, spatially-varying, constant-in-time temperature flux specified by an array. ```jldoctest; julia> Nx = Ny = 16; # Number of grid points. julia> Q = randn(Nx, Ny); # temperature flux. julia> white_noise_T_bc = FluxBoundaryCondition(Q); FluxBoundaryCondition: 16√ó16 Matrix{Float64}; ```. When running on the GPU, `Q` must be converted to a `CuArray`. ## Building boundary conditions on a field. To create a set of [`FieldBoundaryConditions`](@ref) for a temperature field,; we write. ```jldoctest; julia> T_bcs = FieldBoundaryConditions(top = V",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md:15095,avoid,avoiding,15095,docs/src/model_setup/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md,1,['avoid'],['avoiding']
Safety,"sky, it appropriately switches off in laminar and transitional flows, and it is consistent with the exact SGS; stress tensor on both isotropic and anisotropic grids. [Abkar16](@citet) extended the AMD model to model SGS scalar; fluxes for tracer transport. [Abkar17](@citet) further extended the model to include a buoyancy term that accounts for; the contribution of buoyant forces to the production and suppression of turbulence. [Vreugdenhil18](@citet) derive a modified AMD model by following the requirement suggested by [Verstappen18](@citet),; which entail normalising the displacement, the velocity, and the velocity gradient by the filter width to ensure that; the resulting eddy dissipation properly counteracts the spurious kinetic energy transferred by convective nonlinearity,; to derive a modified AMD model. The eddy viscosity and diffusivity are defined in terms of eddy viscosity and diffusivity *predictors*; ``\nu_e^\dagger`` and ``\kappa_e^\dagger``, such that; ```math; \nu_e = \max \lbrace 0, \nu_e^\dagger \rbrace; \quad \text{and} \quad; \kappa_e = \max \lbrace 0, \kappa_e^\dagger \rbrace \, ,; ```; to ensure that ``\nu_e \ge 0`` and ``\kappa_e \ge 0``. Leaving out the overlines and understanding that all variables; represent the resolved/filtered variables, the eddy viscosity predictor is given by; ```math; \begin{equation}; \label{eq:nu-dagger}; \nu_e^\dagger = -(C\Delta)^2; \frac; {\left( \hat{\partial}_k \hat{v}_i \right) \left( \hat{\partial}_k \hat{v}_j \right) \hat{S}_{ij}; + C_b\hat{\delta}_{i3} \alpha g \left( \hat{\partial}_k \hat{v_i} \right) \hat{\partial}_k \theta}; {\left( \hat{\partial}_l \hat{v}_m \right) \left( \hat{\partial}_l \hat{v}_m \right)} \, ,; \end{equation}; ```; and the eddy diffusivity predictor by; ```math; \begin{equation}; \kappa_e^\dagger = -(C\Delta)^2; \frac; {\left( \hat{\partial}_k \hat{v}_i \right) \left( \hat{\partial}_k \hat{\theta} \right) \hat{\partial}_i \theta}; {\left( \hat{\partial}_l \hat{\theta} \right) \left( \",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md:5678,predict,predictors,5678,docs/src/numerical_implementation/large_eddy_simulation.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md,1,['predict'],['predictors']
Safety,"ymbol{\hat x}``, ``\boldsymbol{\hat y}``, and ``\boldsymbol{\hat z}`` directions at location ``\boldsymbol{x} = (x, y, z)``. The effect of subgrid turbulence on tracer mixing is also modeled diffusively via; ```math; \boldsymbol{q}_c = - \kappa_e \boldsymbol{\nabla} c \, ,; ```; where the eddy diffusivity ``\kappa_e`` is; ```math; \kappa_e = \frac{\nu_e}{Pr} + \kappa \, .; ```; Both ``Pr`` and ``\kappa`` may be set independently for each tracer. ## Anisotropic minimum dissipation (AMD) turbulence closure. The anisotropic minimum dissipation (AMD) model proposed by [Verstappen18](@citet) and was; described and tested by [Vreugdenhil18](@citet). The AMD model uses an eddy diffusivity hypothesis; similar the Smagorinsky-Lilly model. In the AMD model, the eddy viscosity and diffusivity for each; tracer are defined in terms of eddy viscosity and diffusivity *predictors* ``\nu_e^\dagger`` and ``\kappa_e^\dagger``,; such that; ```math; \nu_e = \max \left ( 0, \nu_e^\dagger \right ) + \nu; \quad \text{and} \quad; \kappa_e = \max \left ( 0, \kappa_e^\dagger \right ) + \kappa \, ,; ```; to ensure that ``\nu_e \ge 0`` and ``\kappa_e \ge 0``, where ``\nu`` and ``\kappa`` are the; constant isotropic background viscosity and diffusivities for each tracer. The eddy viscosity ; predictor is; ```math; \begin{equation}; \nu_e^\dagger = C \Delta_f^2; \frac; {(\hat{\partial}_k \hat{v}_i) (\hat{\partial}_k \hat{v}_j) \hat{\Sigma}_{ij}; + C_b \hat{\delta}_{i3} (\hat{\partial}_k \hat{v_i}) (\hat{\partial}_k b)}; {(\hat{\partial}_l \hat{v}_m) (\hat{\partial}_l \hat{v}_m)} \, ,; \label{eq:nu-dagger}; \end{equation}; ```; while the eddy diffusivity predictor for tracer ``c`` is; ```math; \begin{equation}; \label{eq:kappa-dagger}; \kappa_e^\dagger = C \Delta_f^2; \frac; {(\hat{\partial}_k \hat{v}_i) (\hat{\partial}_k c) (\hat{\partial}_i c)}; {(\hat{\partial}_l c) (\hat{\partial}_l c)} \, .; \end{equation}; ```; In the definitions of the eddy viscosity and eddy diffusivity predictor, ``C`` an",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/turbulence_closures.md:5410,predict,predictors,5410,docs/src/physics/turbulence_closures.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/turbulence_closures.md,1,['predict'],['predictors']
Safety,"{x} - \boldsymbol{x}_\Omega\right)(\boldsymbol{u}^{n+1} - \boldsymbol{u}^\star).; \end{equation}; ```; The modified pressure poisson equation becomes ``\nabla^2p^{n+1}=\frac{\boldsymbol{\nabla}\cdot\tilde{\boldsymbol{u}}^\star}{\Delta t}``; which can easily be solved. . Perhaps a more intuitive way to consider this is to recall that the corrector step projects ``\boldsymbol{u}^\star``; to the space of divergenece free velocity by applying; ```math; \begin{equation}; \label{eq:pressure_correction_step}; \boldsymbol{u}^{n+1} = \boldsymbol{u}^\star - \Delta t\boldsymbol{\nabla}p^{n+1},; \end{equation}; ```; but we have changed ``p^{n+1}`` to ``\phi`` and ``\boldsymbol{u}^\star`` to ``\tilde{\boldsymbol{u}}^\star``; so for ``\boldsymbol{\nabla}\phi \big |_{\partial\Omega} = 0`` the modified predictor velocity must; equal the corrected velocity on the boundary. For simple open boundary conditions such as no penetration or a straight forward prescription of; a known velocity at ``t^{n+1}`` this is simple to implement as we just set the boundary condition; on the predictor velocity and don't change it after the correction. But some open boundary methods; calculate the boundary value based on the interior solution. As a simple example, if we wanted to ; set the wall normal veloicty gradient to zero at the west boundary then we would set the boundary ; point to; ```math; \begin{equation}; \label{eq:zero_wall_normal_velocity_gradient}; u^\star_{1jk} \approx u^\star_{3jk} + (u^\star_{2jk} - u^\star_{jk4}) / 2 + \mathcal{O}(\Delta x^2),; \end{equation}; ```; but we then pressure correct the interior so a new ``\mathcal{O}(\Delta t)`` error is introduced as; ```math; \begin{equation}; \begin{align}; u^{n+1}_{1jk} &\approx u^{n+1}_{3jk} + (u^{n+1}_{2jk} - u^{n+1}_{jk4}) / 2 + \mathcal{O}(\Delta x^2),\\; &= u^\star_{1jk} - \Delta t \left(\boldsymbol{\nabla}p^{n+1}_{3jk} + (\boldsymbol{\nabla}p^{n+1}_{2jk} - \boldsymbol{\nabla}p^{n+1}_{4jk}) / 2\right) + \mathcal{O}(\Delta x^2),\\; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md:10985,predict,predictor,10985,docs/src/numerical_implementation/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md,1,['predict'],['predictor']
Security,"# Convergence Tests. Convergence tests are implemented in `/validation/convergence_tests` and range; from zero-dimensional time-stepper tests to two-dimensional integration tests that; involve non-trivial pressure fields, advection, and diffusion. For all tests except point exponential decay, we use the ``L_1`` norm,. ```math; L_1 \equiv \frac{\mathrm{mean} | \phi_\mathrm{sim} - \phi_\mathrm{exact} |}{\mathrm{mean} | \phi_\mathrm{exact} |}; ```. and ``L_\infty`` norm,. ```math; L_\infty \equiv \frac{\max | \phi_\mathrm{sim} - \phi_\mathrm{exact} |}{\max | \phi_\mathrm{exact} |} \, ,; ```. to compare simulated fields, ``\phi_\mathrm{sim}``, with exact, analytically-derived solutions; ``\phi_\mathrm{exact}``.; The field ``\phi`` may be a tracer field or a velocity field. ## Point Exponential Decay. This test analyzes time-stepper convergence by simulating the zero-dimensional, or spatially-uniform equation. ```math; \partial_t c = - c \, ,; ```. with the initial condition ``c = 1``, which has the analytical solution ``c = \mathrm{e}^{-t}``. We find the expected first-order convergence with decreasing time-step ``\Delta t`` using our; first-order accurate, ""modified second-order"" Adams-Bashforth time-stepping method:. ![Point exponential decay](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/point_exponential_decay_time_stepper_convergence.png). This result validates the correctness of the `Oceananigans` implementation of Adams-Bashforth time-stepping. ## One-dimensional advection and diffusion of a Gaussian. This and the following tests focus on convergence with grid spacing, ``\Delta x``. In one dimension with constant diffusivity ``\kappa`` and in the presence of a; constant velocity ``U``, a Gaussian evolves according to. ```math; c = \frac{\mathrm{e}^{- (x - U t)^2 / 4 \kappa t}}{\sqrt{4 \pi \kappa t}} \, .; ```. For this test we take the initial time as ``t=t_0``.; We simulate this problem with advection and ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md:60,validat,validation,60,docs/src/appendix/convergence_tests.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md,1,['validat'],['validation']
Security,"# Model setup. This section describes all the options and features that can be used to set up a model. For ; more detailed information consult the API documentation. Each structure covered in this section can be constructed and passed to the models' constructors. ; For examples of model construction, see the examples. The validation experiments provide more ; advanced examples. For reference, here are all the option or keyword arguments that can be passed to the; currently implemented models. See the different sections on the sidebar for more ; details and examples for each keyword argument. ### `NonhydrostaticModel`. ```@docs; NonhydrostaticModel; ```. ### `HydrostaticFreeSurfaceModel`. ```@docs; HydrostaticFreeSurfaceModel; ```. ### `ShallowWaterModel`. ```@docs; ShallowWaterModel; ```; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/overview.md:324,validat,validation,324,docs/src/model_setup/overview.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/overview.md,1,['validat'],['validation']
Security,"5; 0.75 0.75 0.75 0.75 0.75 0.75 0.75; 1.25 1.25 1.25 1.25 1.25 1.25 1.25; 1.75 1.75 1.75 1.75 1.75 1.75 1.75; 0.25 0.25 0.25 0.25 0.25 0.25 0.25; ```. The way the halo regions are filled depends on `c.boundary_conditions`:. ```julia; c.boundary_conditions. # output; Oceananigans.FieldBoundaryConditions, with boundary conditions; ‚îú‚îÄ‚îÄ west: PeriodicBoundaryCondition; ‚îú‚îÄ‚îÄ east: PeriodicBoundaryCondition; ‚îú‚îÄ‚îÄ south: PeriodicBoundaryCondition; ‚îú‚îÄ‚îÄ north: PeriodicBoundaryCondition; ‚îú‚îÄ‚îÄ bottom: FluxBoundaryCondition: Nothing; ‚îú‚îÄ‚îÄ top: FluxBoundaryCondition: Nothing; ‚îî‚îÄ‚îÄ immersed: FluxBoundaryCondition: Nothing; ```. Specifically for `c` above, `x` and `y` are `Periodic` while `z` has been assigned; the default ""no-flux"" boundary conditions for a `Field` with `Center` location in; a `Bounded` direction.; For no-flux boundary conditions, the halo regions of `c` are filled so that derivatives evaluated; on the boundary return 0.; To view only the interior cells of `c` we use the function `interior`,. ```jldoctest fields; interior(c, :, :, 1). # output; 4√ó5 view(::Array{Float64, 3}, 2:5, 2:6, 2) with eltype Float64:; 0.25 0.25 0.25 0.25 0.25; 0.75 0.75 0.75 0.75 0.75; 1.25 1.25 1.25 1.25 1.25; 1.75 1.75 1.75 1.75 1.75; ```. Note that the indices of `c` (and the indices of `c.data`) are ""offset"" so that index `1`; corresponds to the first interior cell.; As a result,. ```jldoctest fields; c[1:4, 1:5, 1] == interior(c, :, :, 1). # output; true; ```. and more generally. ```jldoctest fields; typeof(c.data). # output; OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}; ```. Thus, for example, the `x`-indices of `c.data` vary from `1 - Hx` to `Nx + Hx` -- in this; case, from `0` to `5`.; The underlying array can be accessed with `parent(c)`.; But note that the ""parent"" array does not have offset indices, so. ```jldoctest fields; @show parent(c)[1:2, 2, 2]; @show c.data[1:2, 1, 1]; nothing. # output; (parent(c))[1:2, 2, 2] = [1.75, 0.25]; c.data[1:2, 1, 1] = [0.25, 0.75]; ```; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md:14891,access,accessed,14891,docs/src/fields.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md,1,['access'],['accessed']
Security,":u); FluxBoundaryCondition: ContinuousBoundaryFunction linear_drag at (Nothing, Nothing, Nothing); ```. `field_dependencies` specifies the name of the dependent fields either with a `Symbol` or `Tuple` of `Symbol`s. ### 6. 'Field-dependent' boundary conditions with parameters. When boundary conditions depends on fields _and_ parameters, their functions take the form. ```jldoctest; julia> @inline quadratic_drag(x, y, t, u, v, drag_coeff) = - drag_coeff * u * sqrt(u^2 + v^2); quadratic_drag (generic function with 1 method). julia> u_bottom_bc = FluxBoundaryCondition(quadratic_drag, field_dependencies=(:u, :v), parameters=1e-3); FluxBoundaryCondition: ContinuousBoundaryFunction quadratic_drag at (Nothing, Nothing, Nothing); ```. Put differently, `Œæ, Œ∑, t` come first in the function signature, followed by field dependencies,; followed by `parameters` is `!isnothing(parameters)`. ### 7. Discrete-form boundary condition with parameters. Discrete field data may also be accessed directly from boundary condition functions; using the `discrete_form`. For example:. ```jldoctest; @inline filtered_drag(i, j, grid, clock, model_fields) =; @inbounds - 0.05 * (model_fields.u[i-1, j, 1] + 2 * model_fields.u[i, j, 1] + model_fields.u[i-1, j, 1]). u_bottom_bc = FluxBoundaryCondition(filtered_drag, discrete_form=true). # output; FluxBoundaryCondition: DiscreteBoundaryFunction with filtered_drag; ```. !!! info ""The 'discrete form' for boundary condition functions""; The argument `discrete_form=true` indicates to [`BoundaryCondition`](@ref) that `filtered_drag`; uses the 'discrete form'. Boundary condition functions that use the 'discrete form'; are called with the signature; ```julia; f(i, j, grid, clock, model_fields); ```; where `i, j` are grid indices that vary along the boundary, `grid` is `model.grid`,; `clock` is the `model.clock`, and `model_fields` is a `NamedTuple`; containing `u, v, w` and the fields in `model.tracers`.; The signature is similar for ``x`` and ``y`` boundary con",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md:13577,access,accessed,13577,docs/src/model_setup/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md,1,['access'],['accessed']
Security,"; end; end. Lx = 360; Nx = Int(Lx / m). # Deduce number of cells south of 90·µíN; Œªf = latitude_faces.(1:Nx); Ny = findfirst(Œªf .> 90) - 2. grid = LatitudeLongitudeGrid(size = (Nx, Ny),; longitude = (0, Lx),; latitude = latitude_faces,; topology = (Bounded, Bounded, Flat)); ```. ```@example plot; œÜ = œÜnodes(grid, Center()); Œîx = xspacings(grid, Center(), Center(), with_halos=true)[1:Ny]; Œîy = yspacings(grid, Center())[1:Ny]. using CairoMakie. fig = Figure(size=(800, 400), title=""Spacings on a Mercator grid""); axx = Axis(fig[1, 1], xlabel=""Zonal spacing (km)"", ylabel=""Latitude (degrees)""); scatter!(axx, Œîx ./ 1e3, œÜ). axy = Axis(fig[1, 2], xlabel=""Meridional spacing (km)""); scatter!(axy, Œîy ./ 1e3, œÜ). hidespines!(axx, :t, :r); hidespines!(axy, :t, :l, :r); hideydecorations!(axy, grid=false). current_figure(); ```. ## Single-precision `RectilinearGrid`. To build a grid whose fields are represented with single-precision floating point values,; we specify the `float_type` argument along with the (optional) `architecture` argument,. ```jldoctest grids; architecture = CPU(); float_type = Float32. grid = RectilinearGrid(architecture, float_type,; topology = (Periodic, Periodic, Bounded),; size = (16, 8, 4),; x = (0, 64),; y = (0, 32),; z = (0, 8)). # output; 16√ó8√ó4 RectilinearGrid{Float32, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 64.0) regularly spaced with Œîx=4.0; ‚îú‚îÄ‚îÄ Periodic y ‚àà [0.0, 32.0) regularly spaced with Œîy=4.0; ‚îî‚îÄ‚îÄ Bounded z ‚àà [0.0, 8.0] regularly spaced with Œîz=2.0; ```. !!! warn ""Using single precision""; Single precision should be used with care.; Users interested in performing single-precision simulations should get in touch via; [Discussions](https://github.com/CliMA/Oceananigans.jl/discussions),; and should subject their work to extensive testing and validation. For more examples see [`RectilinearGrid`](@ref Oceananigans.Grids.RectilinearGrid); and [`LatitudeLongitudeGrid`](@ref Oceananigans.Grids.LatitudeLongitudeGrid).; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:22940,validat,validation,22940,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['validat'],['validation']
Security,"`CUDA.CuArray`](https://cuda.juliagpu.org/stable/usage/array/) to store ; data for GPU computations. One limitation of `CuArray`s compared to the `Array`s used for ; CPU computations is that `CuArray` elements in general cannot be accessed outside kernels; launched through CUDA.jl or KernelAbstractions.jl. (You can learn more about GPU kernels ; [here](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#kernels) and ; [here](https://cuda.juliagpu.org/stable/usage/overview/#Kernel-programming-with-@cuda).); Doing so requires individual elements to be copied from or to the GPU for processing,; which is very slow and can result in huge slowdowns. To avoid such unintentional slowdowns,; Oceananigans.jl disables CUDA scalar indexing by default. See the; [scalar indexing](https://juliagpu.github.io/CUDA.jl/dev/usage/workflow/#UsageWorkflowScalar); section of the CUDA.jl documentation for more information on scalar indexing. For example, if can be difficult to just view a `CuArray` since Julia needs to access ; its elements to do that. Consider the example below:. ```julia; julia> using Oceananigans, Adapt. julia> grid = RectilinearGrid(GPU(); size=(1, 1, 1), extent=(1, 1, 1), halo=(1, 1, 1)); 1√ó1√ó1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 1.0) regularly spaced with Œîx=1.0; ‚îú‚îÄ‚îÄ Periodic y ‚àà [0.0, 1.0) regularly spaced with Œîy=1.0; ‚îî‚îÄ‚îÄ Bounded z ‚àà [-1.0, 0.0] regularly spaced with Œîz=1.0. julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ‚îú‚îÄ‚îÄ grid: 1√ó1√ó1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ timestepper: RungeKutta3TimeStepper; ‚îú‚îÄ‚îÄ tracers: (); ‚îú‚îÄ‚îÄ closure: Nothing; ‚îú‚îÄ‚îÄ buoyancy: Nothing; ‚îî‚îÄ‚îÄ coriolis: Nothing. julia> typeof(model.velocities.u.data); OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}. julia> adapt(Array, model.velocities.u.data); 3√ó3√ó3 Offse",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:11462,access,access,11462,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['access'],['access']
Security,"```math; L_\infty \equiv \frac{\max | \phi_\mathrm{sim} - \phi_\mathrm{exact} |}{\max | \phi_\mathrm{exact} |} \, ,; ```. to compare simulated fields, ``\phi_\mathrm{sim}``, with exact, analytically-derived solutions; ``\phi_\mathrm{exact}``.; The field ``\phi`` may be a tracer field or a velocity field. ## Point Exponential Decay. This test analyzes time-stepper convergence by simulating the zero-dimensional, or spatially-uniform equation. ```math; \partial_t c = - c \, ,; ```. with the initial condition ``c = 1``, which has the analytical solution ``c = \mathrm{e}^{-t}``. We find the expected first-order convergence with decreasing time-step ``\Delta t`` using our; first-order accurate, ""modified second-order"" Adams-Bashforth time-stepping method:. ![Point exponential decay](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/point_exponential_decay_time_stepper_convergence.png). This result validates the correctness of the `Oceananigans` implementation of Adams-Bashforth time-stepping. ## One-dimensional advection and diffusion of a Gaussian. This and the following tests focus on convergence with grid spacing, ``\Delta x``. In one dimension with constant diffusivity ``\kappa`` and in the presence of a; constant velocity ``U``, a Gaussian evolves according to. ```math; c = \frac{\mathrm{e}^{- (x - U t)^2 / 4 \kappa t}}{\sqrt{4 \pi \kappa t}} \, .; ```. For this test we take the initial time as ``t=t_0``.; We simulate this problem with advection and diffusion, as well as with ``U=0`` and thus diffusion only, as well as with; ``\kappa \approx 0`` and thus ""advection only"".; The solutions are. ![Gaussian advection diffusion solutions](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png). which exhibit the expected second-order convergence with ``\Delta x^2 \propto 1 / N_x^2``:. ![Gaussian advection diffusion convergence](ht",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md:1433,validat,validates,1433,docs/src/appendix/convergence_tests.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md,1,['validat'],['validates']
Security,"ceananigans version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created. Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general. ## But I want to _code_!. * New users help write Oceananigans code and documentation by [forking the Oceananigans repository](https://docs.github.com/en/github/collaborating-with-pull-requests/working-with-forks), [using git](https://guides.github.com/introduction/git-handbook/) to edit code and docs, and then creating a [pull request](https://docs.github.com/en/github/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork). Pull requests are reviewed by Oceananigans collaborators. * A pull request can be merged once it is reviewed and approved by collaborators. If the pull request author has write access, they have the responsibility of merging their pull request. Otherwise, Oceananigans.jl collaborators will execute the merge with permission from the pull request author. * Note: for small or minor changes (such as fixing a typo in documentation), the [GitHub editor](https://docs.github.com/en/github/managing-files-in-a-repository/managing-files-on-github/editing-files-in-your-repository) is super useful for forking and opening a pull request with a single click. * Write your code with love and care. In particular, conform to existing Oceananigans style and formatting conventions. For example, we love verbose and explicit variable names, use `TitleCase` for types, `snake_case` for objects, and always,put,spaces.after.commas,or.periods. For formatting decisions we loosely follow the [YASGuide](https://github.com/jrevels/YASGuide). It's worth few extra minutes of our time to leave future generations with well-written, readable code. ## What is a ""collaborator"" and how can I become one?. * Collab",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:2472,access,access,2472,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['access'],['access']
Security,"ceananigans version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created. Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general. ## But I want to _code_!. * New users help write Oceananigans code and documentation by [forking the Oceananigans repository](https://docs.github.com/en/github/collaborating-with-pull-requests/working-with-forks), [using git](https://guides.github.com/introduction/git-handbook/) to edit code and docs, and then creating a [pull request](https://docs.github.com/en/github/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork). Pull requests are reviewed by Oceananigans collaborators. * A pull request can be merged once it is reviewed and approved by collaborators. If the pull request author has write access, they have the responsibility of merging their pull request. Otherwise, Oceananigans.jl collaborators will execute the merge with permission from the pull request author. * Note: for small or minor changes (such as fixing a typo in documentation), the [GitHub editor](https://docs.github.com/en/github/managing-files-in-a-repository/managing-files-on-github/editing-files-in-your-repository) is super useful for forking and opening a pull request with a single click. * Write your code with love and care. In particular, conform to existing Oceananigans style and formatting conventions. For example, we love verbose and explicit variable names, use `TitleCase` for types, `snake_case` for objects, and always.put.spaces.after.commas. For formatting decisions we loosely follow the [YASGuide](https://github.com/jrevels/YASGuide). It's worth few extra minutes of our time to leave future generations with well-written, readable code. ## What is a ""collaborator"" and how can I become one?. * Collaborators hav",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md:2563,access,access,2563,CONTRIBUTING.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md,1,['access'],['access']
Security,"d` is `model.grid`,; `clock` is the `model.clock`, and `model_fields` is a `NamedTuple`; containing `u, v, w` and the fields in `model.tracers`.; The signature is similar for ``x`` and ``y`` boundary conditions expect that `i, j` is replaced; with `j, k` and `i, k` respectively. ### 8. Discrete-form boundary condition with parameters. ```jldoctest; julia> Cd = 0.2; # drag coefficient. julia> @inline linear_drag(i, j, grid, clock, model_fields, Cd) = @inbounds - Cd * model_fields.u[i, j, 1];. julia> u_bottom_bc = FluxBoundaryCondition(linear_drag, discrete_form=true, parameters=Cd); FluxBoundaryCondition: DiscreteBoundaryFunction linear_drag with parameters 0.2; ```. !!! info ""Inlining and avoiding bounds-checking in boundary condition functions""; Boundary condition functions should be decorated with `@inline` when running on CPUs for performance reasons.; On the GPU, all functions are force-inlined by default.; In addition, the annotation `@inbounds` should be used when accessing the elements of an array; in a boundary condition function (such as `model_fields.u[i, j, 1]` in the above example).; Using `@inbounds` will avoid a relatively expensive check that the index `i, j, 1` is 'in bounds'. ### 9. A random, spatially-varying, constant-in-time temperature flux specified by an array. ```jldoctest; julia> Nx = Ny = 16; # Number of grid points. julia> Q = randn(Nx, Ny); # temperature flux. julia> white_noise_T_bc = FluxBoundaryCondition(Q); FluxBoundaryCondition: 16√ó16 Matrix{Float64}; ```. When running on the GPU, `Q` must be converted to a `CuArray`. ## Building boundary conditions on a field. To create a set of [`FieldBoundaryConditions`](@ref) for a temperature field,; we write. ```jldoctest; julia> T_bcs = FieldBoundaryConditions(top = ValueBoundaryCondition(20.0),; bottom = GradientBoundaryCondition(0.01)); Oceananigans.FieldBoundaryConditions, with boundary conditions; ‚îú‚îÄ‚îÄ west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing); ‚îú‚îÄ‚îÄ east: DefaultBoundar",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md:15382,access,accessing,15382,docs/src/model_setup/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md,1,['access'],['accessing']
Security,"forcing,)). model.forcing.u. # output; ContinuousForcing{Nothing} at (Face, Center, Center); ‚îú‚îÄ‚îÄ func: u_forcing (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (); ```. More general forcing functions are built via the `Forcing` constructor; described below. `Oceananigans` also provides two convenience types:. * `Relaxation` for damping terms that restore a field to a; target distribution outside of a masked region of space. `Relaxation` can be; used to implement sponge layers near the boundaries of a domain.; * `AdvectiveForcing` for advecting individual quantities by a separate or; ""slip"" velocity relative to both the prognostic model velocity field and any; `BackgroundField` velocity field. ## The `Forcing` constructor. The `Forcing` constructor provides an interface for specifying forcing functions that. 1. Depend on external parameters; and; 2. Depend on model fields at the `x, y, z` location that forcing is applied; and/or; 3. Require access to discrete model data. ### Forcing functions with external parameters. Most forcings involve external, changeable parameters.; Here are two examples of `forcing_func`tions that depend on ; _(i)_ a single scalar parameter `s`, and _(ii)_ a `NamedTuple` of parameters, `p`:. ```jldoctest parameterized_forcing; # Forcing that depends on a scalar parameter `s`; u_forcing_func(x, y, z, t, s) = s * z. u_forcing = Forcing(u_forcing_func, parameters=0.1). # Forcing that depends on a `NamedTuple` of parameters `p`; T_forcing_func(x, y, z, t, p) = - p.Œº * exp(z / p.Œª) * cos(p.k * x) * sin(p.œâ * t). T_forcing = Forcing(T_forcing_func, parameters=(Œº=1, Œª=0.5, k=2œÄ, œâ=4œÄ)). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, forcing=(u=u_forcing, T=T_forcing), buoyancy=SeawaterBuoyancy(), tracers=(:T, :S)). model.forcing.T. # output; ContinuousForcing{@NamedTuple{Œº::Int64, Œª::Float64, k::Float64, œâ::Float64}} at (Center, Center, Center); ‚îú‚îÄ‚îÄ func: T_forcing_",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:1893,access,access,1893,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['access'],['access']
Security,"forcing; model.forcing.S. # output; ContinuousForcing{Float64} at (Center, Center, Center); ‚îú‚îÄ‚îÄ func: S_forcing_func (generic function with 1 method); ‚îú‚îÄ‚îÄ parameters: 0.01; ‚îî‚îÄ‚îÄ field dependencies: (:S,); ```. The `field_dependencies` arguments follow `x, y, z, t` in the forcing `func`tion in; the order they are specified in `Forcing`.; If both `field_dependencies` and `parameters` are specified, then the `field_dependencies`; arguments follow `x, y, z, t`, and `parameters` follow `field_dependencies`. Model fields that arise in the arguments of continuous `Forcing` `func`tions are; automatically interpolated to the staggered grid location at which the forcing is applied. ### ""Discrete form"" forcing functions. ""Discrete form"" forcing functions are either called with the signature. ```julia; func(i, j, k, grid, clock, model_fields); ```. or the parameterized form. ```julia; func(i, j, k, grid, clock, model_fields, parameters); ```. Discrete form forcing functions can access the entirety of model field; data through the argument `model_fields`. The object `model_fields` is a `NamedTuple`; whose properties include the velocity fields `model_fields.u`, `model_fields.v`,; `model_fields.w` and all fields in `model.tracers`. Using discrete forcing functions may require understanding the; staggered arrangement of velocity fields and tracers in `Oceananigans`.; Here's a slightly non-sensical example in which the vertical derivative of a buoyancy; tracer is used as a time-scale for damping the u-velocity field:. ```jldoctest discrete_forcing; # A damping term that depends on a ""local average"":; local_average(i, j, k, grid, c) = @inbounds (c[i, j, k] + c[i-1, j, k] + c[i+1, j, k] +; c[i, j-1, k] + c[i, j+1, k] +; c[i, j, k-1] + c[i, j, k+1]) / 7. b_forcing_func(i, j, k, grid, clock, model_fields) = - local_average(i, j, k, grid, model_fields.b). b_forcing = Forcing(b_forcing_func, discrete_form=true). # A term that damps the local velocity field in the presence of stratificatio",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:5825,access,access,5825,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['access'],['access']
Security,"ic boundary conditions, or insulating boundary conditions in either ``x`` or ``y``. The expected convergence with ``\Delta x^2 \propto 1 / N_x^2`` is observed:. ![Two dimensional diffusion convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/two_dimensional_diffusion_convergence.png). This validates the correctness of multi-dimensional diffusion operators. ## Decaying, advected Taylor-Green vortex. The velocity field. ```math; \begin{align}; u(x, y, t) & = U + \mathrm{e}^{-t} \cos(x - U t) \sin(y) \, , \\; v(x, y, t) & = - \mathrm{e}^{-t} \sin(x - U t) \cos(y) \, ,; \end{align}; ```. is a solution to the Navier-Stokes equations with viscosity ``\nu = 1``. The expected convergence with spatial resolution is observed:. ![Decaying advected Taylor Green](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/taylor_green_convergence.png). This validates the correctness of the advection and diffusion of a velocity field. ## Forced two-dimensional flows. We introduce two convergence tests associated with forced flows in domains that are ; bounded in ``y``, and periodic in ``x`` with no tracers. *Note: in this section, subscripts are used to denote derivatives to make reading ; and typing equations easier.*. In a two-dimensional flow in ``(x, y)``, the velocity field ``(u, v)`` can be expressed in terms; of a streamfunction ``\psi(x, y, t)`` such that. ```math; u \equiv - \psi_y \, , \quad \text{and} \quad v \equiv \psi_x \, ,; ```; where subscript denote derivatives such that ``\psi_y \equiv \partial_y \psi``, for example.; With an isotropic Laplacian viscosity ``\nu = 1``, the momentum and continuity equations are; ```math; \begin{align}; \boldsymbol{v}_t + \left ( \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} \right ) \boldsymbol{v} + \boldsymbol{\nabla} p & = \nabla^2 \boldsymbol{v} + \boldsymbol{F}_v \, , \\; \boldsymbol{\nabla} \boldsymbol{\cdot} \b",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md:4846,validat,validates,4846,docs/src/appendix/convergence_tests.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md,1,['validat'],['validates']
Security,"ification/convergence_plots/gaussian_advection_diffusion_error_convergence.png). These results validate the correctness of time-stepping, constant diffusivity operators, and advection operators. ## One-dimensional advection and diffusion of a cosine. In one dimension with constant diffusivity ``\kappa`` and in the presence of a; constant velocity ``U``, a cosine evolves according to. ```math; c = \mathrm{e}^{-\kappa t} \cos (x - U t) \, .; ```. The solutions are. ![Cosine advection diffusion solutions](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png). which exhibit the expected second-order convergence with ``\Delta x^2 \propto 1 / N_x^2``:. ![Cosine advection diffusion convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png). These results validate the correctness of time-stepping, constant diffusivity operators, and advection operators. ## Two-dimensional diffusion. With zero velocity field and constant diffusivity ``\kappa``, the tracer field. ```math; c(x, y, t=0) = \cos(x) \cos(y) \, ,; ```. decays according to. ```math; c(x, y, t) = \mathrm{e}^{-2 \kappa t} \cos(x) \cos(y) \, ,; ```. with either periodic boundary conditions, or insulating boundary conditions in either ``x`` or ``y``. The expected convergence with ``\Delta x^2 \propto 1 / N_x^2`` is observed:. ![Two dimensional diffusion convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/two_dimensional_diffusion_convergence.png). This validates the correctness of multi-dimensional diffusion operators. ## Decaying, advected Taylor-Green vortex. The velocity field. ```math; \begin{align}; u(x, y, t) & = U + \mathrm{e}^{-t} \cos(x - U t) \sin(y) \, , \\; v(x, y, t) & = - \mathrm{e}^{-t} \sin(x - U t) \cos(y) \, ,; \end{align}; ```. is a solution",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md:3507,validat,validate,3507,docs/src/appendix/convergence_tests.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md,1,['validat'],['validate']
Security,"igans models, and; * a library documenting all user-facing Oceananigans objects and functions.; * [Discussions on the Oceananigans github](https://github.com/CliMA/Oceananigans.jl/discussions), covering topics like; * [""Computational science""](https://github.com/CliMA/Oceananigans.jl/discussions/categories/computational-science), or how to science and set up numerical simulations in Oceananigans, and; * [""Experimental features""](https://github.com/CliMA/Oceananigans.jl/discussions?discussions_q=experimental+features), which covers new and sparsely-documented features for those who like to live dangerously.; ; If you've got a question or something to talk about, don't hesitate to [start a new discussion](https://github.com/CliMA/Oceananigans.jl/discussions/new?)!; * The [Oceananigans wiki](https://github.com/CliMA/Oceananigans.jl/wiki), which contains practical tips for [getting started with Julia](https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans), [accessing and using GPUs](https://github.com/CliMA/Oceananigans.jl/wiki/Oceananigans-on-GPUs), and [productive workflows when using Oceananigans](https://github.com/CliMA/Oceananigans.jl/wiki/Productive-Oceananigans-workflows-and-Julia-environments).; * [Issues](https://github.com/CliMA/Oceananigans.jl/issues) and [pull requests](https://github.com/CliMA/Oceananigans.jl/pulls) also contain lots of information about problems we've found, solutions we're trying to implement, and dreams we're dreaming to make tomorrow better üåà. ## Getting in touch. Whether you need help getting started with Oceananigans, found a bug, want Oceananigans to be more awesome, or just want to chat about computational oceanography, you've got a few options for getting in touch:. * [Start a discussion](https://github.com/CliMA/Oceananigans.jl/discussions). This is great for general questions about numerics, science, experimental or under-documented features, and for getting help setting up a neat new nu",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md:2644,access,accessing,2644,docs/src/index.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md,1,['access'],['accessing']
Security,"ince Julia and KernelAbstractions.jl (needed for GPU runs) already inline some; functions automatically. However, it is generally a good idea to at least investigate this aspect in; your code as the benefits can potentially be significant. ## GPU simulation tips. Running on GPUs can be very different from running on CPUs. Oceananigans makes most of the necessary; changes in the background, so that for very simple simulations changing between CPUs and GPUs is; just a matter of changing the `architecture` argument in the model from `CPU()` to `GPU()`. However,; for more complex simulations some care needs to be taken on the part of the user. While knowledge of; GPU computing (and Julia) is again desirable, an inexperienced user can also achieve high efficiency; in GPU simulations by following a few simple principles. ### Global variables that need to be used in GPU computations need to be defined as constants or passed as parameters. Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation; will crash. This includes any variables that are referenced as global variables in functions; used for forcing of boundary conditions. For example,. ```julia; T‚ÇÄ = 20 # ·µíC; surface_temperature(x, y, t) = T‚ÇÄ * sin(2œÄ / 86400 * t); T_bcs = FieldBoundaryConditions(bottom = GradientBoundaryCondition(surface_temperature)); ```. will throw an error if run on the GPU (and will run more slowly than it should on the CPU).; Replacing the first line above with. ```julia; const T‚ÇÄ = 20 # ·µíC; ```. fixes the issue by indicating to the compiler that `T‚ÇÄ` will not change. Note that the _literal_ `2œÄ / 86400` is not an issue -- it's only the; _variable_ `T‚ÇÄ` that must be declared `const`. Alternatively, we can pass the variable as a parameter to `GradientBoundaryCondition`. To do that; we need to pass a named tuple as `parameter` keyword argument:. ```julia; T‚ÇÄ = 20 # ·µíC; surface_temperature(x, y, t, p) = p.T‚ÇÄ * sin(2œÄ / 86400 * t); T_bcs = FieldBoundaryCondi",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:4159,access,accessed,4159,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['access'],['accessed']
Security,"julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ‚îú‚îÄ‚îÄ grid: 16√ó16√ó16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ timestepper: RungeKutta3TimeStepper; ‚îú‚îÄ‚îÄ advection scheme: Centered reconstruction order 2; ‚îú‚îÄ‚îÄ tracers: (); ‚îú‚îÄ‚îÄ closure: Nothing; ‚îú‚îÄ‚îÄ buoyancy: Nothing; ‚îî‚îÄ‚îÄ coriolis: Nothing; ```. But tracers can be added with the `tracers` keyword.; For example, to add conservative temperature `T` and absolute salinity `S`:. ```jldoctest tracers; julia> model = NonhydrostaticModel(; grid, tracers=(:T, :S)); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ‚îú‚îÄ‚îÄ grid: 16√ó16√ó16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ timestepper: RungeKutta3TimeStepper; ‚îú‚îÄ‚îÄ advection scheme: Centered reconstruction order 2; ‚îú‚îÄ‚îÄ tracers: (T, S); ‚îú‚îÄ‚îÄ closure: Nothing; ‚îú‚îÄ‚îÄ buoyancy: Nothing; ‚îî‚îÄ‚îÄ coriolis: Nothing; ```. whose fields can be accessed via `model.tracers.T` and `model.tracers.S`. ```jldoctest tracers; julia> model.tracers.T; 16√ó16√ó16 Field{Center, Center, Center} on RectilinearGrid on CPU; ‚îú‚îÄ‚îÄ grid: 16√ó16√ó16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ boundary conditions: FieldBoundaryConditions; ‚îÇ ‚îî‚îÄ‚îÄ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; ‚îî‚îÄ‚îÄ data: 22√ó22√ó22 OffsetArray(::Array{Float64, 3}, -2:19, -2:19, -2:19) with eltype Float64 with indices -2:19√ó-2:19√ó-2:19; ‚îî‚îÄ‚îÄ max=0.0, min=0.0, mean=0.0. julia> model.tracers.S; 16√ó16√ó16 Field{Center, Center, Center} on RectilinearGrid on CPU; ‚îú‚îÄ‚îÄ grid: 16√ó16√ó16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ boundary conditions: FieldBoundaryConditions; ‚îÇ ‚îî‚îÄ‚îÄ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; ‚îî‚îÄ‚îÄ data: 22√ó22√ó22 OffsetArray(::Array{Floa",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/tracers.md:1289,access,accessed,1289,docs/src/model_setup/tracers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/tracers.md,1,['access'],['accessed']
Security,"led scratch space. In general, the more diagnostics, the more scratch space needed and the bigger; the memory requirements. However, if you explicitly create a scratch space and pass that same; scratch space for as many diagnostics as you can, you minimize the memory requirements of your; calculations by reusing the same chunk of memory. Have a look at an; [example for how to create scratch space](https://github.com/CliMA/LESbrary.jl/blob/cf31b0ec20219d5ad698af334811d448c27213b0/examples/three_layer_ constant_fluxes.jl#L380-L383) and how it can be; [used in calculations](https://github.com/CliMA/LESbrary.jl/blob/cf31b0ec20219d5ad698af334811d448c27213b0/src/TurbulenceStatistics/first_through_third_order.jl#L109-L112). ### Arrays in GPUs are usually different from arrays in CPUs. Oceananigans.jl uses [`CUDA.CuArray`](https://cuda.juliagpu.org/stable/usage/array/) to store ; data for GPU computations. One limitation of `CuArray`s compared to the `Array`s used for ; CPU computations is that `CuArray` elements in general cannot be accessed outside kernels; launched through CUDA.jl or KernelAbstractions.jl. (You can learn more about GPU kernels ; [here](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#kernels) and ; [here](https://cuda.juliagpu.org/stable/usage/overview/#Kernel-programming-with-@cuda).); Doing so requires individual elements to be copied from or to the GPU for processing,; which is very slow and can result in huge slowdowns. To avoid such unintentional slowdowns,; Oceananigans.jl disables CUDA scalar indexing by default. See the; [scalar indexing](https://juliagpu.github.io/CUDA.jl/dev/usage/workflow/#UsageWorkflowScalar); section of the CUDA.jl documentation for more information on scalar indexing. For example, if can be difficult to just view a `CuArray` since Julia needs to access ; its elements to do that. Consider the example below:. ```julia; julia> using Oceananigans, Adapt. julia> grid = RectilinearGrid(GPU(); size=(1, 1, 1), extent",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:10669,access,accessed,10669,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['access'],['accessed']
Security,"lta x^2 \propto 1 / N_x^2``:. ![Cosine advection diffusion convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png). These results validate the correctness of time-stepping, constant diffusivity operators, and advection operators. ## Two-dimensional diffusion. With zero velocity field and constant diffusivity ``\kappa``, the tracer field. ```math; c(x, y, t=0) = \cos(x) \cos(y) \, ,; ```. decays according to. ```math; c(x, y, t) = \mathrm{e}^{-2 \kappa t} \cos(x) \cos(y) \, ,; ```. with either periodic boundary conditions, or insulating boundary conditions in either ``x`` or ``y``. The expected convergence with ``\Delta x^2 \propto 1 / N_x^2`` is observed:. ![Two dimensional diffusion convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/two_dimensional_diffusion_convergence.png). This validates the correctness of multi-dimensional diffusion operators. ## Decaying, advected Taylor-Green vortex. The velocity field. ```math; \begin{align}; u(x, y, t) & = U + \mathrm{e}^{-t} \cos(x - U t) \sin(y) \, , \\; v(x, y, t) & = - \mathrm{e}^{-t} \sin(x - U t) \cos(y) \, ,; \end{align}; ```. is a solution to the Navier-Stokes equations with viscosity ``\nu = 1``. The expected convergence with spatial resolution is observed:. ![Decaying advected Taylor Green](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/taylor_green_convergence.png). This validates the correctness of the advection and diffusion of a velocity field. ## Forced two-dimensional flows. We introduce two convergence tests associated with forced flows in domains that are ; bounded in ``y``, and periodic in ``x`` with no tracers. *Note: in this section, subscripts are used to denote derivatives to make reading ; and typing equations easier.*. In a two-dimensional flow in ``(x, y)``, the velocit",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md:4236,validat,validates,4236,docs/src/appendix/convergence_tests.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md,1,['validat'],['validates']
Security,"n with constant diffusivity ``\kappa`` and in the presence of a; constant velocity ``U``, a Gaussian evolves according to. ```math; c = \frac{\mathrm{e}^{- (x - U t)^2 / 4 \kappa t}}{\sqrt{4 \pi \kappa t}} \, .; ```. For this test we take the initial time as ``t=t_0``.; We simulate this problem with advection and diffusion, as well as with ``U=0`` and thus diffusion only, as well as with; ``\kappa \approx 0`` and thus ""advection only"".; The solutions are. ![Gaussian advection diffusion solutions](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png). which exhibit the expected second-order convergence with ``\Delta x^2 \propto 1 / N_x^2``:. ![Gaussian advection diffusion convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png). These results validate the correctness of time-stepping, constant diffusivity operators, and advection operators. ## One-dimensional advection and diffusion of a cosine. In one dimension with constant diffusivity ``\kappa`` and in the presence of a; constant velocity ``U``, a cosine evolves according to. ```math; c = \mathrm{e}^{-\kappa t} \cos (x - U t) \, .; ```. The solutions are. ![Cosine advection diffusion solutions](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png). which exhibit the expected second-order convergence with ``\Delta x^2 \propto 1 / N_x^2``:. ![Cosine advection diffusion convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png). These results validate the correctness of time-stepping, constant diffusivity operators, and advection operators. ## Two-dimensional diffusion. With zero velocity field and constant diffusivity",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md:2644,validat,validate,2644,docs/src/appendix/convergence_tests.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md,1,['validat'],['validate']
Security,"nanigans.Operators: ‚àÇz·∂†·∂ú·∂†, ‚Ñëxz·∂†·µÉ·∂ú. function u_forcing_func(i, j, k, grid, clock, model_fields, Œµ); # The vertical derivative of buoyancy, interpolated to the u-velocity location:; N¬≤ = ‚Ñëxz·∂†·µÉ·∂ú(i, j, k, grid, ‚àÇz·∂†·∂ú·∂†, model_fields.b). # Set to zero in unstable stratification where N¬≤ < 0:; N¬≤ = max(N¬≤, zero(typeof(N¬≤))). return @inbounds - Œµ * sqrt(N¬≤) * model_fields.u[i, j, k]; end. u_forcing = Forcing(u_forcing_func, discrete_form=true, parameters=1e-3). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = NonhydrostaticModel(grid=grid, tracers=:b, buoyancy=BuoyancyTracer(), forcing=(u=u_forcing, b=b_forcing)). model.forcing.b. # output; DiscreteForcing{Nothing}; ‚îú‚îÄ‚îÄ func: b_forcing_func (generic function with 1 method); ‚îî‚îÄ‚îÄ parameters: nothing; ```. ```jldoctest discrete_forcing; model.forcing.u. # output; DiscreteForcing{Float64}; ‚îú‚îÄ‚îÄ func: u_forcing_func (generic function with 1 method); ‚îî‚îÄ‚îÄ parameters: 0.001; ```. The annotation `@inbounds` is crucial for performance when accessing array indices; of the fields in `model_fields`. ## `Relaxation`. `Relaxation` defines a special forcing function that restores a field at a specified `rate` to; a `target` distribution, within a region uncovered by a `mask`ing function.; `Relaxation` is useful for implementing sponge layers, as shown in the second example. The following code constructs a model in which all components; of the velocity field are damped to zero everywhere on a time-scale of 1000 seconds, or ~17 minutes:. ```jldoctest; damping = Relaxation(rate = 1/1000). grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = NonhydrostaticModel(grid=grid, forcing=(u=damping, v=damping, w=damping)). model.forcing.w. # output; ContinuousForcing{Nothing} at (Center, Center, Face); ‚îú‚îÄ‚îÄ func: Relaxation(rate=0.001, mask=1, target=0); ‚îú‚îÄ‚îÄ parameters: nothing; ‚îî‚îÄ‚îÄ field dependencies: (:w,); ```. The constructor for `Relaxation` accepts the keyword arguments `mask`, and `target`,; which specify a `mask(x, y",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md:7860,access,accessing,7860,docs/src/model_setup/forcing_functions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/forcing_functions.md,1,['access'],['accessing']
Security,"ntal features""](https://github.com/CliMA/Oceananigans.jl/discussions?discussions_q=experimental+features), which covers new and sparsely-documented features for those who like to live dangerously.; ; If you've got a question or something, anything! to talk about, don't hesitate to [start a new discussion](https://github.com/CliMA/Oceananigans.jl/discussions/new?).; * The [Oceananigans wiki](https://github.com/CliMA/Oceananigans.jl/wiki) contains practical tips for [getting started with Julia](https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans), [accessing and using GPUs](https://github.com/CliMA/Oceananigans.jl/wiki/Accessing-GPUs-and-using-Oceananigans-on-GPUs), and [productive workflows when using Oceananigans](https://github.com/CliMA/Oceananigans.jl/wiki/Productive-Oceananigans-workflows-and-Julia-environments).; * The `#oceananigans` channel on the [Julia Slack](https://julialang.org/slack/), which accesses ""institutional knowledge"" stored in the minds of the amazing Oceananigans community.; * [Issues](https://github.com/CliMA/Oceananigans.jl/issues) and [pull requests](https://github.com/CliMA/Oceananigans.jl/pulls) also contain lots of information about problems we've found, solutions we're trying to implement, and dreams we're dreaming to make tomorrow better üåà. ## Citing. If you use Oceananigans.jl as part of your research, teaching, or other activities, we would be grateful if you could cite our work and mention Oceananigans.jl by name. ```bibtex; @article{OceananigansJOSS,; doi = {10.21105/joss.02018},; url = {https://doi.org/10.21105/joss.02018},; year = {2020},; publisher = {The Open Journal},; volume = {5},; number = {53},; pages = {2018},; author = {Ali Ramadhan and Gregory LeClaire Wagner and Chris Hill and Jean-Michel Campin and Valentin Churavy and Tim Besard and Andre Souza and Alan Edelman and Raffaele Ferrari and John Marshall},; title = {{Oceananigans.jl: Fast and friendly geophysical fluid dynamics",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:7553,access,accesses,7553,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['access'],['accesses']
Security,"s models, and; * a library documenting all user-facing Oceananigans objects and functions.; * [Discussions on the Oceananigans github](https://github.com/CliMA/Oceananigans.jl/discussions), covering topics like; * [""Computational science""](https://github.com/CliMA/Oceananigans.jl/discussions/categories/computational-science), or how to science and set up numerical simulations in Oceananigans, and; * [""Experimental features""](https://github.com/CliMA/Oceananigans.jl/discussions?discussions_q=experimental+features), which covers new and sparsely-documented features for those who like to live dangerously.; ; If you've got a question or something, anything! to talk about, don't hesitate to [start a new discussion](https://github.com/CliMA/Oceananigans.jl/discussions/new?).; * The [Oceananigans wiki](https://github.com/CliMA/Oceananigans.jl/wiki) contains practical tips for [getting started with Julia](https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans), [accessing and using GPUs](https://github.com/CliMA/Oceananigans.jl/wiki/Accessing-GPUs-and-using-Oceananigans-on-GPUs), and [productive workflows when using Oceananigans](https://github.com/CliMA/Oceananigans.jl/wiki/Productive-Oceananigans-workflows-and-Julia-environments).; * The `#oceananigans` channel on the [Julia Slack](https://julialang.org/slack/), which accesses ""institutional knowledge"" stored in the minds of the amazing Oceananigans community.; * [Issues](https://github.com/CliMA/Oceananigans.jl/issues) and [pull requests](https://github.com/CliMA/Oceananigans.jl/pulls) also contain lots of information about problems we've found, solutions we're trying to implement, and dreams we're dreaming to make tomorrow better üåà. ## Citing. If you use Oceananigans.jl as part of your research, teaching, or other activities, we would be grateful if you could cite our work and mention Oceananigans.jl by name. ```bibtex; @article{OceananigansJOSS,; doi = {10.21105/joss.02018},; ur",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:7188,access,accessing,7188,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['access'],['accessing']
Security,"ttps://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/free_convection_0956.png)](https://www.youtube.com/watch?v=yq4op9h3xcU). ### [Winds blowing over the ocean](https://www.youtube.com/watch?v=IRncfbvuiy8). [![Watch winds blowing over the ocean](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_0400.png)](https://www.youtube.com/watch?v=IRncfbvuiy8). ### [Free convection with wind stress](https://www.youtube.com/watch?v=ob6OMQgPfI4). [![Watch free convection with wind stress in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_unstable_7500.png)](https://www.youtube.com/watch?v=ob6OMQgPfI4). ## Performance benchmarks. We've performed some preliminary performance benchmarks (see the [performance benchmarks](https://clima.github.io/OceananigansDocumentation/stable/appendix/benchmarks/) section of the documentation) by initializing models of various sizes and measuring the wall clock time taken per model iteration (or time step). This is not really a fair comparison as we haven't parallelized across all the CPU's cores so we will revisit these benchmarks once Oceananigans.jl can run on multiple CPUs and GPUs. To make full use of or fully saturate the computing power of a GPU such as an Nvidia Tesla V100 or; a Titan V, the model should have around ~10 million grid points or more. Sometimes counter-intuitively running with `Float32` is slower than `Float64`. This is likely due; to type mismatches causing slowdowns as floats have to be converted between 32-bit and 64-bit, an; issue that needs to be addressed meticulously. Due to other bottlenecks such as memory accesses and; GPU register pressure, `Float32` models may not provide much of a speedup so the main benefit becomes; lower memory costs (by around a factor of 2). ![Performance benchmark plots](https://user-images.githubusercontent.com/20099589/89906791-d2c85b00-dbb9-11ea-969a-4b8db2c31680.png); ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:11605,access,accesses,11605,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['access'],['accesses']
Testability," ""Fork"" button. * Clone your fork of the Oceananigans repository (in terminal on Mac/Linux or git shell/; GUI on Windows) in the location you'd like to keep it.; ```; git clone https://github.com/your-user-name/Oceananigans.jl.git; ```. * Navigate to that folder in the terminal or in Anaconda Prompt if you're on Windows. * Connect your repository to the upstream (main project).; ```; git remote add oceananigans https://github.com/CLiMA/Oceananigans.jl.git; ```. * Create the development environment by opening Julia via `julia --project` then; typing in `] instantiate`. This will install all the dependencies in the Project.toml; file. Your development environment is now ready!. * You can test to make sure Oceananigans works by typing in `] test`. (This is equivalent to; `using Pkg; Pkg.test()`.) Doing so will run all the tests (and this can take a while).; Alternatively, you can run only one test script file by providing its name as an environment; variable. For example, to run the tests only from the `test_coriolis.jl` file we call:. ```; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; ```. ## Pull Requests. We follow the [ColPrac guide](https://github.com/SciML/ColPrac) for collaborative practices.; We ask that new contributors read that guide before submitting a pull request. Changes and contributions should be made via GitHub pull requests against the ``main`` branch. When you're done making changes, commit the changes you made. Chris Beams has written a ; [guide](https://chris.beams.io/posts/git-commit/) on how to write good commit messages. When you think your changes are ready to be merged into the main repository, push to your fork; and [submit a pull request](https://github.com/CLiMA/Oceananigans.jl/compare/). **Working on your first Pull Request?** You can learn how from this _free_ video series; [How to Contribute to an Open Source Project on GitHub](https://egghead.io/courses/how-to-contribute-to-an-open-source-project-on-github), A",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:7722,test,tests,7722,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['test'],['tests']
Testability," 0.408879 ‚îÇ 0.992685 ‚îÇ 1.33816 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 64, 1) ‚îÇ 17.0612 ‚îÇ 0.266582 ‚îÇ 1.03519 ‚îÇ 1.5735 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 128, 1) ‚îÇ 25.409 ‚îÇ 0.198508 ‚îÇ 1.16772 ‚îÇ 2.03693 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò; ```. ![ss_nonhydrostatic_efficiency](https://user-images.githubusercontent.com/45054739/130146219-b354fa25-7d77-4206-8e7e-ec639b2250fa.png). ## Multithreading. Oceananigans can also achieve parallelism via multithreading. Though its efficiencies are less than that of the MPI distributed architectures, its simple setup still makes it a viable option for achieving speedups on simple systems. ### Weak Scaling Multithreaded Shallow Water Model. The initial drop and then rise in efficiencies going from 1 to 2 to 4 threads is likely caused by the 2 threads being automatically allocated onto only one physical CPU core. Though one physical CPU core may contain 2 logical cores each capable of running a separate thread, having 2 threads run on one core will still reduce efficiencies as many resources such as caches and buses must be shared by both threads. Note that there are as many CPU cores allocated as the maximum number of threads. ```; Oceananigans v0.58.9; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :. Shallow water model weak scaling with multithreading benchmark; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ threads ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allo",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:25734,log,logical,25734,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['log'],['logical']
Testability," 256) ‚îÇ (1, 1) ‚îÇ 2.702 ms‚îÇ 2.728 ms‚îÇ 2.801 ms‚îÇ 3.446 ms‚îÇ 2.03 MiB ‚îÇ 5535 ‚îÇ 10 ‚îÇ; ‚îÇ (4096, 512) ‚îÇ (1, 2) ‚îÇ 3.510 ms‚îÇ 3.612 ms‚îÇ 4.287 ms‚îÇ16.546 ms‚îÇ 2.03 MiB ‚îÇ 5859 ‚îÇ 20 ‚îÇ; ‚îÇ (4096, 768) ‚îÇ (1, 3) ‚îÇ 3.553 ms‚îÇ 3.653 ms‚îÇ 5.195 ms‚îÇ39.152 ms‚îÇ 2.03 MiB ‚îÇ 5859 ‚îÇ 30 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò. Shallow water model weak scaling speedup; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ ranks ‚îÇ slowdown ‚îÇ efficiency ‚îÇ memory ‚îÇ allocs ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ (4096, 256) ‚îÇ (1, 1) ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ; ‚îÇ (4096, 512) ‚îÇ (1, 2) ‚îÇ 1.32399 ‚îÇ 0.755293 ‚îÇ 1.00271 ‚îÇ 1.05854 ‚îÇ; ‚îÇ (4096, 768) ‚îÇ (1, 3) ‚îÇ 1.33901 ‚îÇ 0.746818 ‚îÇ 1.00271 ‚îÇ 1.05854 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò; ```. ## Distributed Nonhydrostatic Model. Similar to the distributed shallow water model benchmark results shown above, the distributed nonhydrostatic model was also benchmarked with the strong and weak scaling methods. ### Weak Scaling Nonhydrostatic Model. Weak scaling efficiencies can be improved for the nonhydrostatic model. ```; Oceananigans v0.60.1; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; JULIA_MPI_PATH = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3; EBVERSIONJULIA = 1.6.1; JULIA_DEPOT_PATH = :; JULIA_MPI_BINARY = system; JULIA_MPI_LIBRARY = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3/lib64/libmpi.so; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1; JULIA_MPI_ABI = OpenMPI; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybui",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:18099,benchmark,benchmark,18099,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,2,['benchmark'],"['benchmark', 'benchmarked']"
Testability," is observed:. ![Two dimensional diffusion convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/two_dimensional_diffusion_convergence.png). This validates the correctness of multi-dimensional diffusion operators. ## Decaying, advected Taylor-Green vortex. The velocity field. ```math; \begin{align}; u(x, y, t) & = U + \mathrm{e}^{-t} \cos(x - U t) \sin(y) \, , \\; v(x, y, t) & = - \mathrm{e}^{-t} \sin(x - U t) \cos(y) \, ,; \end{align}; ```. is a solution to the Navier-Stokes equations with viscosity ``\nu = 1``. The expected convergence with spatial resolution is observed:. ![Decaying advected Taylor Green](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/taylor_green_convergence.png). This validates the correctness of the advection and diffusion of a velocity field. ## Forced two-dimensional flows. We introduce two convergence tests associated with forced flows in domains that are ; bounded in ``y``, and periodic in ``x`` with no tracers. *Note: in this section, subscripts are used to denote derivatives to make reading ; and typing equations easier.*. In a two-dimensional flow in ``(x, y)``, the velocity field ``(u, v)`` can be expressed in terms; of a streamfunction ``\psi(x, y, t)`` such that. ```math; u \equiv - \psi_y \, , \quad \text{and} \quad v \equiv \psi_x \, ,; ```; where subscript denote derivatives such that ``\psi_y \equiv \partial_y \psi``, for example.; With an isotropic Laplacian viscosity ``\nu = 1``, the momentum and continuity equations are; ```math; \begin{align}; \boldsymbol{v}_t + \left ( \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} \right ) \boldsymbol{v} + \boldsymbol{\nabla} p & = \nabla^2 \boldsymbol{v} + \boldsymbol{F}_v \, , \\; \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{v} & = 0 \, ,; \end{align}; ```; while the equation for vorticity, ``\omega = v_x - u_y = \nabla^2 \psi``, is; ```math; \omega_t + \math",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md:4986,test,tests,4986,docs/src/appendix/convergence_tests.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md,1,['test'],['tests']
Testability," periodic domain (`topology = (Periodic, Periodic, Flat)`); on a CPU versus a GPU. We find that with the `WENO` advection scheme we get a maximum speedup of more than 400 times on a `16384^2` grid. ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Shallow water model benchmarks; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ Architectures ‚îÇ Float_types ‚îÇ Ns ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ samples ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ CPU ‚îÇ Float64 ‚îÇ 32 ‚îÇ 2.677 ms ‚îÇ 2.876 ms ‚îÇ 3.047 ms ‚îÇ 4.806 ms ‚îÇ 1.36 MiB ‚îÇ 2253 ‚îÇ 10 ‚îÇ; ‚îÇ CPU ‚îÇ Float64 ‚îÇ 64 ‚îÇ 5.795 ms ‚îÇ 5.890 ms ‚îÇ 6.073 ms ‚îÇ 7.770 ms ‚îÇ 1.36 MiB ‚îÇ 2255 ‚îÇ 10 ‚îÇ; ‚îÇ CPU ‚îÇ Float64 ‚îÇ 128 ‚îÇ 16.979 ms ‚îÇ 17.350 ms ‚îÇ 17.578 ms ‚îÇ 19.993 ms ‚îÇ 1.36 MiB ‚îÇ 2255 ‚îÇ 10 ‚îÇ; ‚îÇ CPU ‚îÇ Float64 ‚îÇ 256 ‚îÇ 62.543 ms ‚îÇ 63.222 ms ‚îÇ 63.544 ms ‚îÇ 67.347 ms ‚îÇ 1.36 MiB ‚îÇ 2255 ‚îÇ 10 ‚îÇ; ‚îÇ CPU ‚îÇ Float64 ‚îÇ 512 ‚îÇ 250.149 ms ‚îÇ 251.023 ms ‚îÇ 251.092 ms ‚îÇ 252.389 ms ‚îÇ 1.36 MiB ‚îÇ 2315 ‚îÇ 10 ‚îÇ; ‚îÇ CPU ‚îÇ Float64 ‚îÇ 1024 ‚îÇ 990.901 ms ‚îÇ 993.115 ms ‚îÇ 993.360 ms ‚îÇ 996.091 ms ‚îÇ 1.36 MiB ‚îÇ 2315 ‚îÇ 6 ‚îÇ; ‚îÇ CPU ‚îÇ Float64 ‚îÇ 2048 ‚îÇ 4.002 s ‚îÇ 4.004 s ‚îÇ 4.004 s ‚îÇ 4.007 s ‚îÇ 1.36 MiB ‚îÇ 2315 ‚îÇ 2 ‚îÇ; ‚îÇ CPU ‚îÇ Float64 ‚îÇ 4096 ‚îÇ 16.371 s ‚îÇ 16.371 s ‚îÇ 16.371 s ‚îÇ 16.371 s ‚îÇ 1.36 MiB ‚îÇ 2315 ‚îÇ 1 ‚îÇ; ‚îÇ CPU ‚îÇ Float64 ‚îÇ 8192 ‚îÇ 64.657 s ‚îÇ 64.657 s ‚îÇ 64.657 s ‚îÇ 64.657 s ‚îÇ 1.",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:1393,benchmark,benchmarks,1393,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['benchmark'],['benchmarks']
Testability,"# Convergence Tests. Convergence tests are implemented in `/validation/convergence_tests` and range; from zero-dimensional time-stepper tests to two-dimensional integration tests that; involve non-trivial pressure fields, advection, and diffusion. For all tests except point exponential decay, we use the ``L_1`` norm,. ```math; L_1 \equiv \frac{\mathrm{mean} | \phi_\mathrm{sim} - \phi_\mathrm{exact} |}{\mathrm{mean} | \phi_\mathrm{exact} |}; ```. and ``L_\infty`` norm,. ```math; L_\infty \equiv \frac{\max | \phi_\mathrm{sim} - \phi_\mathrm{exact} |}{\max | \phi_\mathrm{exact} |} \, ,; ```. to compare simulated fields, ``\phi_\mathrm{sim}``, with exact, analytically-derived solutions; ``\phi_\mathrm{exact}``.; The field ``\phi`` may be a tracer field or a velocity field. ## Point Exponential Decay. This test analyzes time-stepper convergence by simulating the zero-dimensional, or spatially-uniform equation. ```math; \partial_t c = - c \, ,; ```. with the initial condition ``c = 1``, which has the analytical solution ``c = \mathrm{e}^{-t}``. We find the expected first-order convergence with decreasing time-step ``\Delta t`` using our; first-order accurate, ""modified second-order"" Adams-Bashforth time-stepping method:. ![Point exponential decay](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/point_exponential_decay_time_stepper_convergence.png). This result validates the correctness of the `Oceananigans` implementation of Adams-Bashforth time-stepping. ## One-dimensional advection and diffusion of a Gaussian. This and the following tests focus on convergence with grid spacing, ``\Delta x``. In one dimension with constant diffusivity ``\kappa`` and in the presence of a; constant velocity ``U``, a Gaussian evolves according to. ```math; c = \frac{\mathrm{e}^{- (x - U t)^2 / 4 \kappa t}}{\sqrt{4 \pi \kappa t}} \, .; ```. For this test we take the initial time as ``t=t_0``.; We simulate this problem with advection and ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md:33,test,tests,33,docs/src/appendix/convergence_tests.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md,5,['test'],"['test', 'tests']"
Testability,"# Convergence Tests. This directory contains scripts and modules for testing the numerical; convergence of `Oceananigans` time stepping algorithms and spatial discretiation. To instantiate the convergence test environment, run. ```; julia -e 'using Pkg; Pkg.activate(pwd()); Pkg.instantiate(); Pkg.develop(PackageSpec(path=joinpath(@__DIR__, "".."", "".."")))'; ```. ## Time stepping convergence tests. ```; julia --project point_exponential_decay.jl; ```. produces `figs/point_exponential_decay_time_stepper_convergence.png`. ## One-dimensional advection-diffusion tests. ### Advection and diffusion of a cosine. ```; julia --project one_dimensional_cosine_advection_diffusion.jl; ```. produces. * `figs/cosine_advection_diffusion_solutions.png`; * `figs/cosine_advection_diffusion_error_convergence.png`. ### Advection and diffusion of a Gaussian. ```; julia --project one_dimensional_gaussian_advection_diffusion.jl; ```. produces. * `figs/gaussian_advection_diffusion_solutions.png`; * `figs/gaussian_advection_diffusion_error_convergence.png`. ## Two-dimensional diffusion. ```; julia --project two_dimensional_diffusion.jl; ```. produces `figs/two_dimensional_diffusion_convergence.png`. ## Two-dimensional Taylor-Green vortex. ```; julia --project run_taylor_green.jl; ```. and then. ```; julia --project analyze_taylor_green.jl; ```. produces `figs/taylor_green_convergence.png`. ## Two-dimensional forced flow with free-slip boundary conditions. ```; julia --project run_forced_free_slip.jl; ```. followed by. ```; julia --project analyze_forced_free_slip.jl; ```. produces `figs/forced_free_slip_convergence.png`. ## Two-dimensional forced flow with fixed-slip boundary conditions. ```; julia --project run_forced_fixed_slip.jl; ```. followed by. ```; julia --project analyze_forced_fixed_slip.jl; ```. produces `figs/forced_fixed_slip_convergence.png`.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/validation/convergence_tests/README.md:69,test,testing,69,validation/convergence_tests/README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/validation/convergence_tests/README.md,4,['test'],"['test', 'testing', 'tests']"
Testability,"# Number type. Passing `Float64` or `Float32` to the grid constructor causes the grid to store all numbers; with 64-bit or 32-bit floating point precision. !!! note ""Avoiding mixed-precision operations""; When not using `Float64` be careful to not mix different precisions as it could introduce implicit type conversions; which can negatively effect performance. You can pass the number type desires to many constructors to enforce; the type you want: e.g. `RectilinearGrid(CPU(), Float32; size=(16, 16, 16), extent=(1, 1, 1))` and; `ScalarDiffusivity(Float16; Œ∫=1//7, ŒΩ=2//7)`. !!! warning ""Effect of floating point precision on simulation accuracy""; While we run many tests with both `Float32` and `Float64` it is not clear whether `Float32` is precise enough to; provide similar accuracy in all use cases. If accuracy is a concern, stick to `Float64`. We will be actively investigating the possibility of using lower precision floating point numbers such as `Float32`; and `Float16` for fluid dynamics as well as the use of alternative number types such as Posits and Sonums.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/number_type.md:669,test,tests,669,docs/src/model_setup/number_type.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/number_type.md,1,['test'],['tests']
Testability,"# Oceananigans.jl performance benchmarks. This directory contains scripts and modules for benchmarking various features of Oceananigans. To instantiate the benchmarks environment, run. ```; julia -e 'using Pkg; Pkg.activate(pwd()); Pkg.instantiate(); Pkg.develop(PackageSpec(path=joinpath(@__DIR__, "".."")))'; ```. Once the environment has been instantiated, benchmarks can be run via, e.g. ```; julia --project benchmark_nonhydrostatic_model.jl; ```. Most scripts benchmark one feature (e.g. advection schemes, arbitrary tracers). If your machine contains a CUDA-compatible GPU, benchmarks will also run on the GPU. Tables with benchmark results will be printed (and each table will also be saved to an HTML file). ## Distributed benchmarks. Run distributed benchmarks by running the launcher scripts for either the shallow water model: `distributed_shallow_water_model.jl` or the nonhydrostatic model: `distributed_nonhydrostatic_model.jl`. Change settings within the scripts to toggle between strong or weak scaling and threaded or MPI architecture. The single and serial scripts executed by the launcher scripts can also be executed manually from the command line with the appropriate arguments. ## Measuring performance regression. Running the `benchmark_regression.jl` script will run the nonhydrostatic model tests on the current branch and on the main branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression. ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/benchmark/README.md:30,benchmark,benchmarks,30,benchmark/README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/benchmark/README.md,11,"['benchmark', 'test']","['benchmark', 'benchmarking', 'benchmarks', 'test', 'tests']"
Testability,"- \xi) \sin y \, ,; ```; which satisfies the boundary conditions ``u_y |_{y=0} = u_y |_{y=\pi} = 0`` and; ``v |_{y=0} = v |_{y=\pi} = 0``. The vorticity forcing is; ```math; F_{\omega} = - 2 \xi^\prime f_x \sin y + 4 f \sin y \, ,; ```; which implies that; ```math; F_v = - 2 \xi^\prime f_x \cos y + 4 f \cos y \, ,; ```; and ``F_v = \tfrac{1}{2} \sin 2 y``. ## Forced, fixed-slip flow. A forced flow satisfying ""fixed-slip"" boundary conditions at ``y=0`` and ``y=1`` has; the streamfunction; ```math; \psi(x, y, t) = - \cos [x - \xi(t)] (y^3 - y^2) \, ,; ```; and thus ``g(y) = y^3 - y^2``. The velocity field ``(u, v)`` is; ```math; u = f (3y^2 - 2 y) \, , \quad \text{and} \quad v = - f_x (y^3 - y^2) \, ,; ```; which satisfies the boundary conditions; ```math; u |_{y=0} = 0 \, , \quad u |_{y=1} = f \, , \quad \text{and} \quad v |_{y=0} = v |_{y=1} = 0 \, .; ```; The vorticity forcing is; ```math; F_{\omega} = - \xi^\prime f_x (y^3 - y^2 - 6y + 2) - f f_x (12 y^3 - 12 y^2 + 4 y) + f (y^3 - y^2 - 12 y + 4) \, ,; ```; which implies that; ```math; F_v = \xi^\prime f_x (\tfrac{1}{4} y^4 - \tfrac{1}{3} y^3 - 3 y^2 + 2y); + f f_x (3 y^4 - 4 y^3 + 2y^2 ) ; - f (\tfrac{1}{4} y^4 - \tfrac{1}{3} y^3 - 6 y^2 + 4 y) \, ,; ```; and; ```math; F_v = 3 y^5 - 5 y^4 + 2y^3 \, .; ```. We set up the problem in the same manner as the forced, free-slip problem above. Note that we ; also must the no-slip boundary condition ``u |_{y=0} = 0`` and the time-dependent fixed-slip ; condition ``u |_{y=1} = f``. As for the free-slip problem, we find that the error between the ; numerical and analytical solutions decreases with ``1 / N_x^2 \sim \Delta x^2``, where ``N_x``; is the number of grid points and ``\Delta x`` is the spatial resolution:. ![Forced fixed slip convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/forced_fixed_slip_convergence.png). The convergence tests are performed using both ``y`` and ``z`` as the bounded direction.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md:10520,test,tests,10520,docs/src/appendix/convergence_tests.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md,1,['test'],['tests']
Testability,"128 ranks. GPUs are not used in this or the next benchmark setup. . ![ws_shallow_water_efficiency](https://user-images.githubusercontent.com/45054739/129826042-6ed4345b-b53a-49af-b375-6b7f11f53f31.png). ### Strong Scaling Shallow Water Model; ```; Oceananigans v0.58.2; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :. Shallow water model strong scaling benchmark; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ ranks ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ samples ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ (4096, 4096) ‚îÇ (1, 1) ‚îÇ 5.694 s ‚îÇ 5.694 s ‚îÇ 5.694 s ‚îÇ 5.694 s ‚îÇ 1.60 MiB ‚îÇ 2804 ‚îÇ 1 ‚îÇ; ‚îÇ (4096, 4096) ‚îÇ (1, 2) ‚îÇ 2.865 s ‚îÇ 2.865 s ‚îÇ 2.866 s ‚îÇ 2.869 s ‚îÇ 1.49 MiB ‚îÇ 3146 ‚îÇ 4 ‚îÇ; ‚îÇ (4096, 4096) ‚îÇ (1, 4) ‚îÇ 1.435 s ‚îÇ 1.437 s ‚îÇ 1.441 s ‚îÇ 1.475 s ‚îÇ 1.49 MiB ‚îÇ 3146 ‚îÇ 16 ‚îÇ; ‚îÇ (4096, 4096) ‚îÇ (1, 8) ‚îÇ 732.711 ms ‚îÇ 736.394 ms ‚îÇ 738.930 ms ‚îÇ 776.773 ms ‚îÇ 1.49 MiB ‚îÇ 3146 ‚îÇ 56 ‚îÇ; ‚îÇ (4096, 4096) ‚îÇ (1, 16) ‚îÇ 389.211 ms ‚îÇ 395.749 ms ‚îÇ 396.813 ms ‚îÇ 433.332 ms ‚îÇ 1.49 MiB ‚îÇ 3116 ‚îÇ 160 ‚îÇ; ‚îÇ (4096, 4096) ‚îÇ (1, 32) ‚îÇ 197.894 ms ‚îÇ 219.211 ms ‚îÇ 236.780 ms ‚îÇ 367.188 ms ‚îÇ 1.49 MiB ‚îÇ 3116 ‚îÇ 320 ‚îÇ; ‚îÇ (4096, 4096) ‚îÇ (1, 64) ‚îÇ 101.520 ms ‚îÇ 112.606 ms ‚îÇ 116.809 ms ‚îÇ 221.497 ms ‚îÇ 1.49 MiB ‚îÇ 3125 ‚îÇ 640 ‚îÇ; ‚îÇ (4096, 4096) ‚îÇ (1, 128) ‚îÇ 51.452 ms ‚îÇ 60.256 ms ‚îÇ 70.959 ms ‚îÇ 232.309 ms ‚îÇ 1.49 MiB ‚îÇ 3125 ‚îÇ 1280 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:13248,benchmark,benchmark,13248,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['benchmark'],['benchmark']
Testability,"2 ‚îÇ 50.8995 ‚îÇ 1.33771 ‚îÇ 2.49028 ‚îÇ; ‚îÇ Float64 ‚îÇ 1024 ‚îÇ 290.085 ‚îÇ 1.33809 ‚îÇ 2.50497 ‚îÇ; ‚îÇ Float64 ‚îÇ 2048 ‚îÇ 370.777 ‚îÇ 1.45575 ‚îÇ 7.0432 ‚îÇ; ‚îÇ Float64 ‚îÇ 4096 ‚îÇ 390.617 ‚îÇ 1.95667 ‚îÇ 26.3641 ‚îÇ; ‚îÇ Float64 ‚îÇ 8192 ‚îÇ 387.632 ‚îÇ 3.82201 ‚îÇ 98.3123 ‚îÇ; ‚îÇ Float64 ‚îÇ 16384 ‚îÇ 426.31 ‚îÇ 12.177 ‚îÇ 420.573 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò; ```; As shown in the graph below, speedups increase sharply starting at grid size `512^2` and then plateau off at around 400 times at grid size `4096^2` and beyond. ![shallow_water_speedup](https://user-images.githubusercontent.com/45054739/128793049-7bcbabaa-2d66-4209-a311-b02729fb93fa.png). The time graph below shows that execution times on GPU are negligibly small up until grid size `1024^2` where it starts to scale similarly to times on CPU. ![shallow_water_times](https://user-images.githubusercontent.com/45054739/128793311-e4bbfd5a-aea8-4cdc-bee8-cb71128ff5fe.png). ## Nonhydrostatic Model. Similar to to shallow water model, the nonhydrostatic model benchmark tests for its performance on both a CPU and a GPU. It was also benchmarked with the `WENO` advection scheme. The nonhydrostatic model is 3-dimensional unlike the 2-dimensional shallow water model. Total number of grid points is Ns cubed. ```; Oceananigans v0.58.8; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.1; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Nonhydrostatic model benchmarks; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:5180,benchmark,benchmark,5180,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,2,"['benchmark', 'test']","['benchmark', 'tests']"
Testability,"256 ‚îÇ 16 ‚îÇ 642.225 ms ‚îÇ 645.458 ms ‚îÇ 648.685 ms ‚îÇ 674.259 ms ‚îÇ 3.60 MiB ‚îÇ 40992 ‚îÇ 8 ‚îÇ; ‚îÇ 256 ‚îÇ 32 ‚îÇ 680.938 ms ‚îÇ 694.376 ms ‚îÇ 701.272 ms ‚îÇ 746.599 ms ‚îÇ 4.88 MiB ‚îÇ 36729 ‚îÇ 8 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò. Nonhydrostatic Strong Scaling Multithreading speedup; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ threads ‚îÇ slowdown ‚îÇ efficiency ‚îÇ memory ‚îÇ allocs ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ 256 ‚îÇ 1 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ; ‚îÇ 256 ‚îÇ 2 ‚îÇ 0.992966 ‚îÇ 0.503542 ‚îÇ 4.14014 ‚îÇ 152.109 ‚îÇ; ‚îÇ 256 ‚îÇ 4 ‚îÇ 0.501089 ‚îÇ 0.498913 ‚îÇ 2.17724 ‚îÇ 50.2532 ‚îÇ; ‚îÇ 256 ‚îÇ 8 ‚îÇ 0.324366 ‚îÇ 0.385367 ‚îÇ 1.94899 ‚îÇ 29.191 ‚îÇ; ‚îÇ 256 ‚îÇ 16 ‚îÇ 0.244788 ‚îÇ 0.255323 ‚îÇ 2.12262 ‚îÇ 18.2106 ‚îÇ; ‚îÇ 256 ‚îÇ 32 ‚îÇ 0.263339 ‚îÇ 0.118668 ‚îÇ 2.87624 ‚îÇ 16.3167 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò; ```. ## Tracers. This benchmark tests the performance impacts of running with various amounts of active; and passive tracers and compares the difference in speedup going from CPU to GPU. Number of tracers are listed in the tracers column as (active, passive). . ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Arbitrary tracers benchmarks; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ Architectures ‚îÇ tracers ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ samples ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:30953,benchmark,benchmark,30953,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,2,"['benchmark', 'test']","['benchmark', 'tests']"
Testability,"4 ‚îÇ 1.38949 ‚îÇ; ‚îÇ CPU ‚îÇ (2, 3) ‚îÇ 1.55493 ‚îÇ 4.04677 ‚îÇ 2.37198 ‚îÇ; ‚îÇ CPU ‚îÇ (2, 5) ‚îÇ 1.97115 ‚îÇ 5.84537 ‚îÇ 2.96377 ‚îÇ; ‚îÇ CPU ‚îÇ (2, 10) ‚îÇ 2.6031 ‚îÇ 11.7179 ‚îÇ 4.63889 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò. Arbitrary tracers relative performance (GPU); ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ Architectures ‚îÇ tracers ‚îÇ slowdown ‚îÇ memory ‚îÇ allocs ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ GPU ‚îÇ (0, 0) ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ; ‚îÇ GPU ‚îÇ (0, 1) ‚îÇ 1.0941 ‚îÇ 1.39053 ‚îÇ 1.16013 ‚îÇ; ‚îÇ GPU ‚îÇ (0, 2) ‚îÇ 1.19399 ‚îÇ 1.85081 ‚îÇ 1.29592 ‚îÇ; ‚îÇ GPU ‚îÇ (1, 0) ‚îÇ 1.08489 ‚îÇ 1.39037 ‚îÇ 1.15883 ‚îÇ; ‚îÇ GPU ‚îÇ (2, 0) ‚îÇ 1.19157 ‚îÇ 1.85109 ‚îÇ 1.29153 ‚îÇ; ‚îÇ GPU ‚îÇ (2, 3) ‚îÇ 1.47824 ‚îÇ 3.50924 ‚îÇ 1.45881 ‚îÇ; ‚îÇ GPU ‚îÇ (2, 5) ‚îÇ 1.66293 ‚îÇ 4.95474 ‚îÇ 1.94286 ‚îÇ; ‚îÇ GPU ‚îÇ (2, 10) ‚îÇ 2.13524 ‚îÇ 9.47276 ‚îÇ 2.52301 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò; ```. ## Turbulence closures. This benchmark tests the performance impacts of various turbulent diffusivity closures; and large eddy simulation (LES) models as well as how much speedup they experience going from CPU to GPU. ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Turbulence closure benchmarks; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ Architectures ‚îÇ Closures ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ samples ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:35491,benchmark,benchmark,35491,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,2,"['benchmark', 'test']","['benchmark', 'tests']"
Testability,"4 ‚îÇ 64 ‚îÇ 78.9952 ‚îÇ 1.51646 ‚îÇ 2.63727 ‚îÇ; ‚îÇ Float64 ‚îÇ 128 ‚îÇ 317.663 ‚îÇ 1.53759 ‚îÇ 3.69896 ‚îÇ; ‚îÇ Float64 ‚îÇ 256 ‚îÇ 346.554 ‚îÇ 1.79466 ‚îÇ 16.6173 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò; ```. Like the shallow water model, it can be seen at grid size `64^3` that the GPU is beginning to be saturated as speedups rapidly increase. At grid sizes `128^3` and `256^3` we see the speedup stabilize to around 400 times. ![incompressible_speedup](https://user-images.githubusercontent.com/45054739/129825248-adb8dfe5-e9ea-4321-bd11-fb415d81e2cb.png). For both float types, the benchmarked GPU times of the nonhydrostatic model starts to scale like its CPU times when grid size reaches `128^3`. ![incompressible_times](https://user-images.githubusercontent.com/45054739/129825253-0d5739d9-f0a7-476e-8152-4ee462b71ad5.png). ## Distributed Shallow Water Model. By using `MPI.jl` the shallow water model can be run on multiple CPUs and multiple GPUs. For the benchmark results shown below, each rank is run on one CPU core and each uses a distinct GPU if applicable. . ### Weak Scaling Shallow Water Model; ```; Oceananigans v0.58.2; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :. Shallow water model weak scaling benchmark; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ ranks ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ samples ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:9407,benchmark,benchmark,9407,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['benchmark'],['benchmark']
Testability,"5db.png). ### Multi-GPU Shallow Water Model. While still a work in progress, it is possible to use CUDA-aware MPI to run the shallow water model on multiple GPUs. Though efficiencies may not be as high as multi-CPU, the multi-GPU architecture is still worthwhile when keeping in mind the baseline speedups generated by using a single GPU. Note that though it is possible for multiple ranks to share the use of a single GPU, efficiencies would significantly decrease and memory may be insufficient. The results below show up to three ranks each using a separate GPU. ```; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); Environment:; JULIA_MPI_PATH = /home/software/spack/openmpi/3.1.4-nhjzelonyovxks5ydtrxehceqxsbf7ik; JULIA_CUDA_USE_BINARYBUILDER = false; JULIA_DEPOT_PATH = /nobackup/users/henryguo/projects/henry-test/Oceananigans.jl/benchmark/.julia; GPU: Tesla V100-SXM2-32GB; ; Shallow water model weak scaling benchmark; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ ranks ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ samples ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ (4096, 256) ‚îÇ (1, 1) ‚îÇ 2.702 ms‚îÇ 2.728 ms‚îÇ 2.801 ms‚îÇ 3.446 ms‚îÇ 2.03 MiB ‚îÇ 5535 ‚îÇ 10 ‚îÇ; ‚îÇ (4096, 512) ‚îÇ (1, 2) ‚îÇ 3.510 ms‚îÇ 3.612 ms‚îÇ 4.287 ms‚îÇ16.546 ms‚îÇ 2.03 MiB ‚îÇ 5859 ‚îÇ 20 ‚îÇ; ‚îÇ (4096, 768) ‚îÇ (1, 3) ‚îÇ 3.553 ms‚îÇ 3.653 ms‚îÇ 5.195 ms‚îÇ39.152 ms‚îÇ 2.03 MiB ‚îÇ 5859 ‚îÇ 30 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò. Shallow water model weak scaling speedup; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ ranks ‚îÇ slowdown ‚îÇ efficiency ‚îÇ memory ‚îÇ allocs ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ (4096, 256) ‚îÇ (1, ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:16767,benchmark,benchmark,16767,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['benchmark'],['benchmark']
Testability,"; # [Performance benchmarks](@id performance_benchmarks). The performance benchmarking scripts in the; [`benchmarks`](https://github.com/CliMA/Oceananigans.jl/tree/main/benchmark); directory of the git repository can be run to benchmark Oceananigans.jl on your machine.; They use [BenchmarkTools.jl](https://github.com/JuliaCI/BenchmarkTools.jl) to collect data and [PrettyTables.jl](https://github.com/ronisbr/PrettyTables.jl) to nicely; format the benchmark results. ## Shallow Water Model. This benchmark tests the performance of the shallow water model run in a doubly periodic domain (`topology = (Periodic, Periodic, Flat)`); on a CPU versus a GPU. We find that with the `WENO` advection scheme we get a maximum speedup of more than 400 times on a `16384^2` grid. ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Shallow water model benchmarks; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ Architectures ‚îÇ Float_types ‚îÇ Ns ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ samples ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ CPU ‚îÇ Float64 ‚îÇ 32 ‚îÇ 2.677 ms ‚îÇ 2.876 ms ‚îÇ 3.047 ms ‚îÇ 4.806 ms ‚îÇ 1.36 MiB ‚îÇ 2253 ‚îÇ 10 ‚îÇ; ‚îÇ CPU ‚îÇ Float64 ‚îÇ 64 ‚îÇ 5.795 ms ‚îÇ 5.890 ms ‚îÇ 6.073 ms ‚îÇ 7.770 ms ‚îÇ 1.36 MiB ‚îÇ 2255 ‚îÇ 10 ‚îÇ; ‚îÇ CPU ‚îÇ Float64 ‚îÇ 128 ‚îÇ 16.979 ms ‚îÇ 17.350 ms ‚îÇ 17.578 ms ‚îÇ 19.993 ms ‚îÇ ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:17,benchmark,benchmarks,17,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,8,"['benchmark', 'test']","['benchmark', 'benchmarking', 'benchmarks', 'tests']"
Testability,"; end; end. Lx = 360; Nx = Int(Lx / m). # Deduce number of cells south of 90·µíN; Œªf = latitude_faces.(1:Nx); Ny = findfirst(Œªf .> 90) - 2. grid = LatitudeLongitudeGrid(size = (Nx, Ny),; longitude = (0, Lx),; latitude = latitude_faces,; topology = (Bounded, Bounded, Flat)); ```. ```@example plot; œÜ = œÜnodes(grid, Center()); Œîx = xspacings(grid, Center(), Center(), with_halos=true)[1:Ny]; Œîy = yspacings(grid, Center())[1:Ny]. using CairoMakie. fig = Figure(size=(800, 400), title=""Spacings on a Mercator grid""); axx = Axis(fig[1, 1], xlabel=""Zonal spacing (km)"", ylabel=""Latitude (degrees)""); scatter!(axx, Œîx ./ 1e3, œÜ). axy = Axis(fig[1, 2], xlabel=""Meridional spacing (km)""); scatter!(axy, Œîy ./ 1e3, œÜ). hidespines!(axx, :t, :r); hidespines!(axy, :t, :l, :r); hideydecorations!(axy, grid=false). current_figure(); ```. ## Single-precision `RectilinearGrid`. To build a grid whose fields are represented with single-precision floating point values,; we specify the `float_type` argument along with the (optional) `architecture` argument,. ```jldoctest grids; architecture = CPU(); float_type = Float32. grid = RectilinearGrid(architecture, float_type,; topology = (Periodic, Periodic, Bounded),; size = (16, 8, 4),; x = (0, 64),; y = (0, 32),; z = (0, 8)). # output; 16√ó8√ó4 RectilinearGrid{Float32, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 64.0) regularly spaced with Œîx=4.0; ‚îú‚îÄ‚îÄ Periodic y ‚àà [0.0, 32.0) regularly spaced with Œîy=4.0; ‚îî‚îÄ‚îÄ Bounded z ‚àà [0.0, 8.0] regularly spaced with Œîz=2.0; ```. !!! warn ""Using single precision""; Single precision should be used with care.; Users interested in performing single-precision simulations should get in touch via; [Discussions](https://github.com/CliMA/Oceananigans.jl/discussions),; and should subject their work to extensive testing and validation. For more examples see [`RectilinearGrid`](@ref Oceananigans.Grids.RectilinearGrid); and [`LatitudeLongitudeGrid`](@ref Oceananigans.Grids.LatitudeLongitudeGrid).; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:22928,test,testing,22928,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['test'],['testing']
Testability,"<a href=""https://mit-license.org"">; <img alt=""MIT license"" src=""https://img.shields.io/badge/License-MIT-blue.svg?style=flat-square"">; </a>; <a href=""https://github.com/CliMA/Oceananigans.jl/discussions"">; <img alt=""Ask us anything"" src=""https://img.shields.io/badge/Ask%20us-anything-1abc9c.svg?style=flat-square"">; </a>; <a href=""https://github.com/SciML/ColPrac"">; <img alt=""ColPrac: Contributor's Guide on Collaborative Practices for Community Packages"" src=""https://img.shields.io/badge/ColPrac-Contributor's%20Guide-blueviolet?style=flat-square"">; </a>; <a href=""https://doi.org/10.21105/joss.02018"">; <img alt=""JOSS"" src=""https://joss.theoj.org/papers/10.21105/joss.02018/status.svg"">; </a>; </p>. <!-- Version and documentation badges -->; <p align=""center"">; <a href=""https://github.com/CliMA/Oceananigans.jl/releases"">; <img alt=""GitHub tag (latest SemVer pre-release)"" src=""https://img.shields.io/github/v/tag/CliMA/Oceananigans.jl?include_prereleases&label=latest%20version&logo=github&sort=semver&style=flat-square"">; </a>; <a href=""https://clima.github.io/OceananigansDocumentation/stable"">; <img alt=""Stable documentation"" src=""https://img.shields.io/badge/documentation-stable%20release-blue?style=flat-square"">; </a>; <a href=""https://clima.github.io/OceananigansDocumentation/dev"">; <img alt=""Development documentation"" src=""https://img.shields.io/badge/documentation-in%20development-orange?style=flat-square"">; </a>; </p>. <!-- Downloads -->; <!-- counts downloads from individual IPs excluding bots (eg, CI) -->; <!-- see https://discourse.julialang.org/t/announcing-package-download-stats/69073 -->. <p align=""center"">; <a href=""https://juliapkgstats.com/pkg/Oceananigans"">; <img alt=""Downloads per month"" src=""https://img.shields.io/badge/dynamic/json?url=http%3A%2F%2Fjuliapkgstats.com%2Fapi%2Fv1%2Fmonthly_downloads%2FOceananigans&query=total_requests&suffix=%2Fmonth&label=Downloads&style=flat-square"">; </a>; <a href=""https://juliapkgstats.com/pkg/Oceananigans"">; <img alt=",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:1529,log,logo,1529,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['log'],['logo']
Testability,"@ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; JULIA_MPI_PATH = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3; EBVERSIONJULIA = 1.6.1; JULIA_DEPOT_PATH = :; JULIA_MPI_BINARY = system; JULIA_MPI_LIBRARY = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3/lib64/libmpi.so; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1; JULIA_MPI_ABI = OpenMPI; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel; JULIA_LOAD_PATH = :; JULIA_MPIEXEC = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3/bin/mpiexec. Nonhydrostatic model strong scaling benchmark; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ ranks ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ samples ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ (256, 256, 256) ‚îÇ (1, 1, 1) ‚îÇ 3.049 s ‚îÇ 3.053 s ‚îÇ 3.053 s ‚îÇ 3.057 s ‚îÇ 2.05 MiB ‚îÇ 2762 ‚îÇ 2 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 2, 1) ‚îÇ 1.609 s ‚îÇ 1.610 s ‚îÇ 1.611 s ‚îÇ 1.620 s ‚îÇ 1.99 MiB ‚îÇ 3096 ‚îÇ 8 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 4, 1) ‚îÇ 814.290 ms ‚îÇ 817.305 ms ‚îÇ 818.685 ms ‚îÇ 833.792 ms ‚îÇ 1.99 MiB ‚îÇ 3136 ‚îÇ 28 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 8, 1) ‚îÇ 434.521 ms ‚îÇ 439.352 ms ‚îÇ 443.049 ms ‚îÇ 508.913 ms ‚îÇ 1.99 MiB ‚îÇ 3216 ‚îÇ 80 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 16, 1) ‚îÇ 251.632 ms ‚îÇ 272.364 ms ‚îÇ 277.555 ms ‚îÇ 370.059 ms ‚îÇ 2.01 MiB ‚îÇ 3376 ‚îÇ 160 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 32, 1) ‚îÇ 182.380 ms ‚îÇ 233.322 ms ‚îÇ 247.325 ms ‚îÇ 441.971 ms ‚îÇ 2.04 MiB ‚îÇ 3696 ‚îÇ 320 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 64, 1) ‚îÇ 119.546 ms ‚îÇ 178.933 ms ‚îÇ 204.036 ms ‚îÇ 564.097 ms ‚îÇ 2.12 MiB ‚îÇ 4346 ‚îÇ 640 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 128, 1) ‚îÇ 73.802 ms ‚îÇ 120.147 ms ‚îÇ 136.395 ms ‚îÇ 378.697 ms ‚îÇ 2.39 MiB ‚îÇ 5626 ‚îÇ ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:22865,benchmark,benchmark,22865,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['benchmark'],['benchmark']
Testability,"@ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; JULIA_MPI_PATH = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3; EBVERSIONJULIA = 1.6.1; JULIA_DEPOT_PATH = :; JULIA_MPI_BINARY = system; JULIA_MPI_LIBRARY = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3/lib64/libmpi.so; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1; JULIA_MPI_ABI = OpenMPI; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel; JULIA_LOAD_PATH = :; JULIA_MPIEXEC = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Compiler/intel2020/openmpi/4.0.3/bin/mpiexec. Nonhydrostatic model weak scaling benchmark; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ ranks ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ samples ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ (128, 128, 16) ‚îÇ (1, 1, 1) ‚îÇ 33.568 ms ‚îÇ 34.087 ms ‚îÇ 34.173 ms ‚îÇ 34.894 ms ‚îÇ 2.05 MiB ‚îÇ 2762 ‚îÇ 10 ‚îÇ; ‚îÇ (128, 128, 32) ‚îÇ (1, 2, 1) ‚îÇ 36.650 ms ‚îÇ 37.161 ms ‚îÇ 37.393 ms ‚îÇ 42.411 ms ‚îÇ 1.99 MiB ‚îÇ 3096 ‚îÇ 20 ‚îÇ; ‚îÇ (128, 128, 64) ‚îÇ (1, 4, 1) ‚îÇ 41.861 ms ‚îÇ 43.440 ms ‚îÇ 46.176 ms ‚îÇ 97.578 ms ‚îÇ 1.99 MiB ‚îÇ 3136 ‚îÇ 40 ‚îÇ; ‚îÇ (128, 128, 128) ‚îÇ (1, 8, 1) ‚îÇ 59.995 ms ‚îÇ 64.110 ms ‚îÇ 68.021 ms ‚îÇ 138.422 ms ‚îÇ 1.99 MiB ‚îÇ 3216 ‚îÇ 80 ‚îÇ; ‚îÇ (128, 128, 256) ‚îÇ (1, 16, 1) ‚îÇ 62.633 ms ‚îÇ 71.266 ms ‚îÇ 74.775 ms ‚îÇ 164.206 ms ‚îÇ 2.01 MiB ‚îÇ 3376 ‚îÇ 160 ‚îÇ; ‚îÇ (128, 128, 512) ‚îÇ (1, 32, 1) ‚îÇ 108.253 ms ‚îÇ 135.611 ms ‚îÇ 139.384 ms ‚îÇ 225.336 ms ‚îÇ 2.04 MiB ‚îÇ 3722 ‚îÇ 320 ‚îÇ; ‚îÇ (128, 128, 1024) ‚îÇ (1, 64, 1) ‚îÇ 138.504 ms ‚îÇ 181.043 ms ‚îÇ 186.386 ms ‚îÇ 335.170 ms ‚îÇ 2.12 MiB ‚îÇ 4372 ‚îÇ 640 ‚îÇ; ‚îÇ (128, 128, 2048) ‚îÇ (1, 128, 1) ‚îÇ 218.592 ms ‚îÇ 285.293 ms ‚îÇ 290.989 ms ‚îÇ 434.878 ms ‚îÇ 2.39 MiB ‚îÇ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:19357,benchmark,benchmark,19357,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['benchmark'],['benchmark']
Testability,"Downloads per month"" src=""https://img.shields.io/badge/dynamic/json?url=http%3A%2F%2Fjuliapkgstats.com%2Fapi%2Fv1%2Fmonthly_downloads%2FOceananigans&query=total_requests&suffix=%2Fmonth&label=Downloads&style=flat-square"">; </a>; <a href=""https://juliapkgstats.com/pkg/Oceananigans"">; <img alt=""Downloads per month"" src=""https://img.shields.io/badge/dynamic/json?url=http%3A%2F%2Fjuliapkgstats.com%2Fapi%2Fv1%2Ftotal_downloads%2FOceananigans&query=total_requests&&label=Total%20Downloads&style=flat-square"">; </a>; </p>. <!-- CI/CD badges -->; <p align=""center"">; <a href=""https://buildkite.com/clima/oceananigans"">; <img alt=""Buildkite CPU+GPU build status"" src=""https://img.shields.io/buildkite/4d921fc17b95341ea5477fb62df0e6d9364b61b154e050a123/main?logo=buildkite&label=Buildkite%20CPU%2BGPU&style=flat-square"">; </a>; <a href=""https://hub.docker.com/r/aliramadhan/oceananigans"">; <img alt=""Docker build status"" src=""https://img.shields.io/docker/cloud/build/aliramadhan/oceananigans?label=Docker&logo=docker&logoColor=white&style=flat-square"">; </a>; </p>. Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic; and hydrostatic Boussinesq equations on CPUs and GPUs.; It runs on GPUs (wow, [fast!](http://arxiv.org/abs/2309.06662)), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans.jl is developed by the [Climate Modeling Alliance](https://clima.caltech.edu) and heroic external collaborators. ## Contents. - [Contents](#contents); - [Installation instructions](#installation-instructions); - [Running your first model](#running-your-first-model); - [The Oceananigans knowledge base](#the-oceananigans-knowledge-base); - [Citing](#citing); - [Contributing](#contributing); - [Movies](#movies); - [Deep convection](#deep-convection); - [Free convection](#free-convection); - [Winds blowing over the ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:3250,log,logo,3250,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,2,['log'],"['logo', 'logoColor']"
Testability,"Oceananigans repository](https://github.com/CLiMA/Oceananigans.jl) by; clicking the ""Fork"" button. * Clone your fork of the Oceananigans repository (in terminal on Mac/Linux or git shell/; GUI on Windows) in the location you'd like to keep it.; ```; git clone https://github.com/your-user-name/Oceananigans.jl.git; ```. * Navigate to that folder in the terminal or in Anaconda Prompt if you're on Windows. * Connect your repository to the upstream (main project).; ```; git remote add oceananigans https://github.com/CLiMA/Oceananigans.jl.git; ```. * Create the development environment by opening Julia via `julia --project` then; typing in `] instantiate`. This will install all the dependencies in the Project.toml; file. Your development environment is now ready!. * You can test to make sure Oceananigans works by typing in `] test`. (This is equivalent to; `using Pkg; Pkg.test()`.) Doing so will run all the tests (and this can take a while).; Alternatively, you can run only one test script file by providing its name as an environment; variable. For example, to run the tests only from the `test_coriolis.jl` file we call:. ```; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; ```. ## Pull Requests. We follow the [ColPrac guide](https://github.com/SciML/ColPrac) for collaborative practices.; We ask that new contributors read that guide before submitting a pull request. Changes and contributions should be made via GitHub pull requests against the ``main`` branch. When you're done making changes, commit the changes you made. Chris Beams has written a ; [guide](https://chris.beams.io/posts/git-commit/) on how to write good commit messages. When you think your changes are ready to be merged into the main repository, push to your fork; and [submit a pull request](https://github.com/CLiMA/Oceananigans.jl/compare/). **Working on your first Pull Request?** You can learn how from this _free_ video series; [How to Contribute to an Open Source Project on GitHub](ht",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:7630,test,test,7630,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['test'],['test']
Testability,"U and a GPU. It was also benchmarked with the `WENO` advection scheme. The nonhydrostatic model is 3-dimensional unlike the 2-dimensional shallow water model. Total number of grid points is Ns cubed. ```; Oceananigans v0.58.8; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.1; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Nonhydrostatic model benchmarks; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ Architectures ‚îÇ Float_types ‚îÇ Ns ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ samples ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ CPU ‚îÇ Float32 ‚îÇ 32 ‚îÇ 34.822 ms ‚îÇ 34.872 ms ‚îÇ 35.278 ms ‚îÇ 38.143 ms ‚îÇ 1.38 MiB ‚îÇ 2302 ‚îÇ 10 ‚îÇ; ‚îÇ CPU ‚îÇ Float32 ‚îÇ 64 ‚îÇ 265.408 ms ‚îÇ 265.571 ms ‚îÇ 265.768 ms ‚îÇ 267.765 ms ‚îÇ 1.38 MiB ‚îÇ 2302 ‚îÇ 10 ‚îÇ; ‚îÇ CPU ‚îÇ Float32 ‚îÇ 128 ‚îÇ 2.135 s ‚îÇ 2.135 s ‚îÇ 2.136 s ‚îÇ 2.138 s ‚îÇ 1.38 MiB ‚îÇ 2302 ‚îÇ 3 ‚îÇ; ‚îÇ CPU ‚îÇ Float32 ‚îÇ 256 ‚îÇ 17.405 s ‚îÇ 17.405 s ‚îÇ 17.405 s ‚îÇ 17.405 s ‚îÇ 1.38 MiB ‚îÇ 2302 ‚îÇ 1 ‚îÇ; ‚îÇ CPU ‚îÇ Float64 ‚îÇ 32 ‚îÇ 37.022 ms ‚îÇ 37.179 ms ‚îÇ 37.335 ms ‚îÇ 39.017 ms ‚îÇ 1.77 MiB ‚îÇ 2302 ‚îÇ 10 ‚îÇ; ‚îÇ CPU ‚îÇ Float64 ‚îÇ 64 ‚îÇ 287.944 ms ‚îÇ 288.154 ms ‚îÇ 288.469 ms ‚îÇ 290.838 ms ‚îÇ 1.77 MiB ‚îÇ 2302 ‚îÇ 10 ‚îÇ; ‚îÇ CPU ‚îÇ Float64 ‚îÇ 128 ‚îÇ 2.326 s ‚îÇ 2.326 s ‚îÇ 2.326 s ‚îÇ 2.327 s ‚îÇ 1.77 MiB ‚îÇ 2302 ‚îÇ 3 ‚îÇ; ‚îÇ CPU ‚îÇ Float64 ‚îÇ 256 ‚îÇ 19.561 s ‚îÇ 19.561 s ‚îÇ 19.561 s ‚îÇ 19.561 s ‚îÇ 1.77 MiB ‚îÇ 2302 ‚îÇ 1 ‚îÇ; ‚îÇ GPU ‚îÇ Float32 ‚îÇ 32 ‚îÇ 4.154 ms ‚îÇ 4.250 ms ‚îÇ 4.361 ms ‚îÇ 5.557 ms ‚îÇ 2.13 MiB ‚îÇ 6033 ‚îÇ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:6052,benchmark,benchmarks,6052,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['benchmark'],['benchmarks']
Testability,"U). [![Watch free convection in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/free_convection_0956.png)](https://www.youtube.com/watch?v=yq4op9h3xcU). ### [Winds blowing over the ocean](https://www.youtube.com/watch?v=IRncfbvuiy8). [![Watch winds blowing over the ocean](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_0400.png)](https://www.youtube.com/watch?v=IRncfbvuiy8). ### [Free convection with wind stress](https://www.youtube.com/watch?v=ob6OMQgPfI4). [![Watch free convection with wind stress in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_unstable_7500.png)](https://www.youtube.com/watch?v=ob6OMQgPfI4). ## Performance benchmarks. We've performed some preliminary performance benchmarks (see the [performance benchmarks](https://clima.github.io/OceananigansDocumentation/stable/appendix/benchmarks/) section of the documentation) by initializing models of various sizes and measuring the wall clock time taken per model iteration (or time step). This is not really a fair comparison as we haven't parallelized across all the CPU's cores so we will revisit these benchmarks once Oceananigans.jl can run on multiple CPUs and GPUs. To make full use of or fully saturate the computing power of a GPU such as an Nvidia Tesla V100 or; a Titan V, the model should have around ~10 million grid points or more. Sometimes counter-intuitively running with `Float32` is slower than `Float64`. This is likely due; to type mismatches causing slowdowns as floats have to be converted between 32-bit and 64-bit, an; issue that needs to be addressed meticulously. Due to other bottlenecks such as memory accesses and; GPU register pressure, `Float32` models may not provide much of a speedup so the main benefit becomes; lower memory costs (by around a factor of 2). ![Performance benchmark plots](https://user-images.githubusercontent.com/20099589/89906791-d2c",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:10805,benchmark,benchmarks,10805,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['benchmark'],['benchmarks']
Testability,"XCode command line tools on; a Mac or `git bash` on Windows). * Login to your GitHub account and make a fork of the; [Oceananigans repository](https://github.com/CLiMA/Oceananigans.jl) by; clicking the ""Fork"" button. * Clone your fork of the Oceananigans repository (in terminal on Mac/Linux or git shell/; GUI on Windows) in the location you'd like to keep it.; ```; git clone https://github.com/your-user-name/Oceananigans.jl.git; ```. * Navigate to that folder in the terminal or in Anaconda Prompt if you're on Windows. * Connect your repository to the upstream (main project).; ```; git remote add oceananigans https://github.com/CLiMA/Oceananigans.jl.git; ```. * Create the development environment by opening Julia via `julia --project` then; typing in `] instantiate`. This will install all the dependencies in the Project.toml; file. Your development environment is now ready!. * You can test to make sure Oceananigans works by typing in `] test`. (This is equivalent to; `using Pkg; Pkg.test()`.) Doing so will run all the tests (and this can take a while).; Alternatively, you can run only one test script file by providing its name as an environment; variable. For example, to run the tests only from the `test_coriolis.jl` file we call:. ```; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; ```. ## Pull Requests. We follow the [ColPrac guide](https://github.com/SciML/ColPrac) for collaborative practices.; We ask that new contributors read that guide before submitting a pull request. Changes and contributions should be made via GitHub pull requests against the ``main`` branch. When you're done making changes, commit the changes you made. Chris Beams has written a ; [guide](https://chris.beams.io/posts/git-commit/) on how to write good commit messages. When you think your changes are ready to be merged into the main repository, push to your fork; and [submit a pull request](https://github.com/CLiMA/Oceananigans.jl/compare/). **Working on your first Pull",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:7522,test,test,7522,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['test'],['test']
Testability,"\partial_t c = - c \, ,; ```. with the initial condition ``c = 1``, which has the analytical solution ``c = \mathrm{e}^{-t}``. We find the expected first-order convergence with decreasing time-step ``\Delta t`` using our; first-order accurate, ""modified second-order"" Adams-Bashforth time-stepping method:. ![Point exponential decay](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/point_exponential_decay_time_stepper_convergence.png). This result validates the correctness of the `Oceananigans` implementation of Adams-Bashforth time-stepping. ## One-dimensional advection and diffusion of a Gaussian. This and the following tests focus on convergence with grid spacing, ``\Delta x``. In one dimension with constant diffusivity ``\kappa`` and in the presence of a; constant velocity ``U``, a Gaussian evolves according to. ```math; c = \frac{\mathrm{e}^{- (x - U t)^2 / 4 \kappa t}}{\sqrt{4 \pi \kappa t}} \, .; ```. For this test we take the initial time as ``t=t_0``.; We simulate this problem with advection and diffusion, as well as with ``U=0`` and thus diffusion only, as well as with; ``\kappa \approx 0`` and thus ""advection only"".; The solutions are. ![Gaussian advection diffusion solutions](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png). which exhibit the expected second-order convergence with ``\Delta x^2 \propto 1 / N_x^2``:. ![Gaussian advection diffusion convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png). These results validate the correctness of time-stepping, constant diffusivity operators, and advection operators. ## One-dimensional advection and diffusion of a cosine. In one dimension with constant diffusivity ``\kappa`` and in the presence of a; constant velocity ``U``, a cosine evolves accordi",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md:1912,test,test,1912,docs/src/appendix/convergence_tests.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md,1,['test'],['test']
Testability,"at64 ‚îÇ 2048 ‚îÇ 370.777 ‚îÇ 1.45575 ‚îÇ 7.0432 ‚îÇ; ‚îÇ Float64 ‚îÇ 4096 ‚îÇ 390.617 ‚îÇ 1.95667 ‚îÇ 26.3641 ‚îÇ; ‚îÇ Float64 ‚îÇ 8192 ‚îÇ 387.632 ‚îÇ 3.82201 ‚îÇ 98.3123 ‚îÇ; ‚îÇ Float64 ‚îÇ 16384 ‚îÇ 426.31 ‚îÇ 12.177 ‚îÇ 420.573 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò; ```; As shown in the graph below, speedups increase sharply starting at grid size `512^2` and then plateau off at around 400 times at grid size `4096^2` and beyond. ![shallow_water_speedup](https://user-images.githubusercontent.com/45054739/128793049-7bcbabaa-2d66-4209-a311-b02729fb93fa.png). The time graph below shows that execution times on GPU are negligibly small up until grid size `1024^2` where it starts to scale similarly to times on CPU. ![shallow_water_times](https://user-images.githubusercontent.com/45054739/128793311-e4bbfd5a-aea8-4cdc-bee8-cb71128ff5fe.png). ## Nonhydrostatic Model. Similar to to shallow water model, the nonhydrostatic model benchmark tests for its performance on both a CPU and a GPU. It was also benchmarked with the `WENO` advection scheme. The nonhydrostatic model is 3-dimensional unlike the 2-dimensional shallow water model. Total number of grid points is Ns cubed. ```; Oceananigans v0.58.8; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.1; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Nonhydrostatic model benchmarks; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ Architectures ‚îÇ Float_types ‚îÇ Ns ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ s",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:5253,benchmark,benchmarked,5253,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['benchmark'],['benchmarked']
Testability,"caling speedup; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ ranks ‚îÇ slowdown ‚îÇ efficiency ‚îÇ memory ‚îÇ allocs ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ (4096, 256) ‚îÇ (1, 1) ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ; ‚îÇ (4096, 512) ‚îÇ (1, 2) ‚îÇ 1.02978 ‚îÇ 0.971077 ‚îÇ 0.930602 ‚îÇ 1.12329 ‚îÇ; ‚îÇ (4096, 1024) ‚îÇ (1, 4) ‚îÇ 1.01589 ‚îÇ 0.984355 ‚îÇ 0.930602 ‚îÇ 1.12329 ‚îÇ; ‚îÇ (4096, 2048) ‚îÇ (1, 8) ‚îÇ 1.04338 ‚îÇ 0.958427 ‚îÇ 0.930602 ‚îÇ 1.12329 ‚îÇ; ‚îÇ (4096, 4096) ‚îÇ (1, 16) ‚îÇ 1.08591 ‚îÇ 0.920886 ‚îÇ 0.930602 ‚îÇ 1.12329 ‚îÇ; ‚îÇ (4096, 8192) ‚îÇ (1, 32) ‚îÇ 1.22777 ‚îÇ 0.814484 ‚îÇ 0.930602 ‚îÇ 1.12329 ‚îÇ; ‚îÇ (4096, 16384) ‚îÇ (1, 64) ‚îÇ 1.21264 ‚îÇ 0.824644 ‚îÇ 0.930687 ‚îÇ 1.12653 ‚îÇ; ‚îÇ (4096, 32768) ‚îÇ (1, 128) ‚îÇ 1.22957 ‚îÇ 0.813296 ‚îÇ 0.930687 ‚îÇ 1.12653 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò; ```. As seen in the tables above and in the graph below, efficiency drops off to around 80% and remains as such from 16 to 128 ranks. GPUs are not used in this or the next benchmark setup. . ![ws_shallow_water_efficiency](https://user-images.githubusercontent.com/45054739/129826042-6ed4345b-b53a-49af-b375-6b7f11f53f31.png). ### Strong Scaling Shallow Water Model; ```; Oceananigans v0.58.2; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :. Shallow water model strong scaling benchmark; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ ranks ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ sa",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:12446,benchmark,benchmark,12446,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['benchmark'],['benchmark']
Testability,"dd(""Oceananigans""); ```. This installs the latest version that's _compatible with your current environment_.; Don't forget to *be careful* üèÑ and check which Oceananigans you installed:. ```julia; julia> Pkg.status(""Oceananigans""); ```. ## Running your first model. Let's run a two-dimensional, horizontally-periodic simulation of turbulence using 128¬≤ finite volume cells for 4 non-dimensional time units:. ```julia; using Oceananigans; grid = RectilinearGrid(CPU(), size=(128, 128), x=(0, 2œÄ), y=(0, 2œÄ), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO()); œµ(x, y) = 2rand() - 1; set!(model, u=œµ, v=œµ); simulation = Simulation(model; Œît=0.01, stop_time=4); run!(simulation); ```. But there's more: changing `CPU()` to `GPU()` makes this code run on a CUDA-enabled Nvidia GPU. Dive into [the documentation](https://clima.github.io/OceananigansDocumentation/stable/) for more code examples and tutorials.; Below, you'll find movies from GPU simulations along with CPU and GPU [performance benchmarks](https://github.com/clima/Oceananigans.jl#performance-benchmarks). ## The Oceananigans knowledge base. It's _deep_ and includes:. * [Documentation](https://clima.github.io/OceananigansDocumentation/stable) that provides; * example Oceananigans scripts,; * tutorials that describe key Oceananigans objects and functions,; * explanations of Oceananigans finite-volume-based numerical methods,; * details of the dynamical equations solved by Oceananigans models, and; * a library documenting all user-facing Oceananigans objects and functions.; * [Discussions on the Oceananigans github](https://github.com/CliMA/Oceananigans.jl/discussions), covering topics like; * [""Computational science""](https://github.com/CliMA/Oceananigans.jl/discussions/categories/computational-science), or how to science and set up numerical simulations in Oceananigans, and; * [""Experimental features""](https://github.com/CliMA/Oceananigans.jl/discussions?discussions_q=experimental+f",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:5716,benchmark,benchmarks,5716,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['benchmark'],['benchmarks']
Testability,"e performance impacts of running with various amounts of active; and passive tracers and compares the difference in speedup going from CPU to GPU. Number of tracers are listed in the tracers column as (active, passive). . ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Arbitrary tracers benchmarks; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ Architectures ‚îÇ tracers ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ samples ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ CPU ‚îÇ (0, 0) ‚îÇ 1.439 s ‚îÇ 1.440 s ‚îÇ 1.440 s ‚îÇ 1.441 s ‚îÇ 908.03 KiB ‚îÇ 1656 ‚îÇ 4 ‚îÇ; ‚îÇ CPU ‚îÇ (0, 1) ‚îÇ 1.539 s ‚îÇ 1.574 s ‚îÇ 1.575 s ‚îÇ 1.613 s ‚îÇ 1.24 MiB ‚îÇ 1942 ‚îÇ 4 ‚îÇ; ‚îÇ CPU ‚îÇ (0, 2) ‚îÇ 1.668 s ‚îÇ 1.669 s ‚îÇ 1.670 s ‚îÇ 1.671 s ‚îÇ 1.76 MiB ‚îÇ 2291 ‚îÇ 3 ‚îÇ; ‚îÇ CPU ‚îÇ (1, 0) ‚îÇ 1.527 s ‚îÇ 1.532 s ‚îÇ 1.532 s ‚îÇ 1.536 s ‚îÇ 1.24 MiB ‚îÇ 1942 ‚îÇ 4 ‚îÇ; ‚îÇ CPU ‚îÇ (2, 0) ‚îÇ 1.690 s ‚îÇ 1.697 s ‚îÇ 1.695 s ‚îÇ 1.698 s ‚îÇ 1.77 MiB ‚îÇ 2301 ‚îÇ 3 ‚îÇ; ‚îÇ CPU ‚îÇ (2, 3) ‚îÇ 2.234 s ‚îÇ 2.239 s ‚îÇ 2.241 s ‚îÇ 2.251 s ‚îÇ 3.59 MiB ‚îÇ 3928 ‚îÇ 3 ‚îÇ; ‚îÇ CPU ‚îÇ (2, 5) ‚îÇ 2.755 s ‚îÇ 2.838 s ‚îÇ 2.838 s ‚îÇ 2.921 s ‚îÇ 5.18 MiB ‚îÇ 4908 ‚îÇ 2 ‚îÇ; ‚îÇ CPU ‚îÇ (2, 10) ‚îÇ 3.588 s ‚îÇ 3.748 s ‚îÇ 3.748 s ‚îÇ 3.908 s ‚îÇ 10.39 MiB ‚îÇ 7682 ‚îÇ 2 ‚îÇ; ‚îÇ GPU ‚îÇ (0, 0) ‚îÇ 9.702 ms ‚îÇ 12.755 ms ‚îÇ 12.458 ms ‚îÇ 12.894 ms ‚îÇ 1.59 MiB ‚îÇ 12321 ‚îÇ 10 ‚îÇ; ‚îÇ GPU ‚îÇ (0, 1) ‚îÇ 13.863 ms ‚îÇ 13.956 ms ‚îÇ 14.184 ms ‚îÇ 16.297 ms ‚îÇ 2.20 MiB ‚îÇ 14294 ‚îÇ 10 ‚îÇ; ‚îÇ GPU ‚îÇ (0, 2) ‚îÇ 15.",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:31814,benchmark,benchmarks,31814,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['benchmark'],['benchmarks']
Testability,"hat if ``F_v`` satisfies; ```math; \partial_y F_v = (g^\prime)^2 + g g^{\prime\prime} \, ,; ```; then the pressure Poisson equation becomes; ```math; \nabla^2 p = \cos [2 (x - \xi)] [(g^\prime)^2 - g g^{\prime\prime}] + \partial_x F_v \, .; ```; This completes the specification of the problem. We set up the problem by imposing the time-dependent forcing functions ``F_u`` and ``F_v``; on ``u`` and ``v``, initializing the flow at ``t=0``, and integrating the problem forwards; in time using Oceananigans. We find the expected convergence of the numerical solution to the; analytical solution: the error between the numerical and analytical solutions; decreases with ``1/N_x^2 \sim \Delta x^2``, where ``N_x`` is the number of grid; points and ``\Delta x`` is the spatial resolution:. ![Forced free slip convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/forced_free_slip_convergence.png). The convergence tests are performed using both ``y`` and ``z`` as the bounded direction. ### Forced, free-slip flow. A forced flow satisfying free-slip conditions at ``y = 0`` and ``y = \pi`` has the streamfunction; ```math; \psi(x, y, t) = - \cos [x - \xi(t)] \sin (y) \, ,; ```; and thus ``g(y) = \sin y``. The velocity field ``(u, v)`` is; ```math; u = \cos (x - \xi) \cos y \, , \quad \text{and} \quad v = \sin (x - \xi) \sin y \, ,; ```; which satisfies the boundary conditions ``u_y |_{y=0} = u_y |_{y=\pi} = 0`` and; ``v |_{y=0} = v |_{y=\pi} = 0``. The vorticity forcing is; ```math; F_{\omega} = - 2 \xi^\prime f_x \sin y + 4 f \sin y \, ,; ```; which implies that; ```math; F_v = - 2 \xi^\prime f_x \cos y + 4 f \cos y \, ,; ```; and ``F_v = \tfrac{1}{2} \sin 2 y``. ## Forced, fixed-slip flow. A forced flow satisfying ""fixed-slip"" boundary conditions at ``y=0`` and ``y=1`` has; the streamfunction; ```math; \psi(x, y, t) = - \cos [x - \xi(t)] (y^3 - y^2) \, ,; ```; and thus ``g(y) = y^3 - y^2``. The velocity field ``(u, v)`` is; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md:8192,test,tests,8192,docs/src/appendix/convergence_tests.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md,1,['test'],['tests']
Testability,"high as multi-CPU, the multi-GPU architecture is still worthwhile when keeping in mind the baseline speedups generated by using a single GPU. Note that though it is possible for multiple ranks to share the use of a single GPU, efficiencies would significantly decrease and memory may be insufficient. The results below show up to three ranks each using a separate GPU. ```; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); Environment:; JULIA_MPI_PATH = /home/software/spack/openmpi/3.1.4-nhjzelonyovxks5ydtrxehceqxsbf7ik; JULIA_CUDA_USE_BINARYBUILDER = false; JULIA_DEPOT_PATH = /nobackup/users/henryguo/projects/henry-test/Oceananigans.jl/benchmark/.julia; GPU: Tesla V100-SXM2-32GB; ; Shallow water model weak scaling benchmark; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ ranks ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ samples ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ (4096, 256) ‚îÇ (1, 1) ‚îÇ 2.702 ms‚îÇ 2.728 ms‚îÇ 2.801 ms‚îÇ 3.446 ms‚îÇ 2.03 MiB ‚îÇ 5535 ‚îÇ 10 ‚îÇ; ‚îÇ (4096, 512) ‚îÇ (1, 2) ‚îÇ 3.510 ms‚îÇ 3.612 ms‚îÇ 4.287 ms‚îÇ16.546 ms‚îÇ 2.03 MiB ‚îÇ 5859 ‚îÇ 20 ‚îÇ; ‚îÇ (4096, 768) ‚îÇ (1, 3) ‚îÇ 3.553 ms‚îÇ 3.653 ms‚îÇ 5.195 ms‚îÇ39.152 ms‚îÇ 2.03 MiB ‚îÇ 5859 ‚îÇ 30 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò. Shallow water model weak scaling speedup; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ ranks ‚îÇ slowdown ‚îÇ efficiency ‚îÇ memory ‚îÇ allocs ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ (4096, 256) ‚îÇ (1, 1) ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ; ‚îÇ (4096, 512) ‚îÇ (1, 2) ‚îÇ 1.32399 ‚îÇ 0.755293 ‚îÇ 1.00271 ‚îÇ 1.05854 ‚îÇ; ‚îÇ (4096, 768) ‚îÇ (1, 3) ‚îÇ 1.33901 ‚îÇ 0.746818 ‚îÇ 1.00271 ‚îÇ 1.05854 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:16847,benchmark,benchmark,16847,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['benchmark'],['benchmark']
Testability,"hmark tests the performance impacts of various turbulent diffusivity closures; and large eddy simulation (LES) models as well as how much speedup they experience going from CPU to GPU. ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Turbulence closure benchmarks; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ Architectures ‚îÇ Closures ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ samples ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ CPU ‚îÇ AnisotropicBiharmonicDiffusivity ‚îÇ 3.634 s ‚îÇ 3.637 s ‚îÇ 3.637 s ‚îÇ 3.639 s ‚îÇ 1.77 MiB ‚îÇ 2316 ‚îÇ 2 ‚îÇ; ‚îÇ CPU ‚îÇ AnisotropicDiffusivity ‚îÇ 2.045 s ‚îÇ 2.052 s ‚îÇ 2.059 s ‚îÇ 2.079 s ‚îÇ 1.77 MiB ‚îÇ 2316 ‚îÇ 3 ‚îÇ; ‚îÇ CPU ‚îÇ AnisotropicMinimumDissipation ‚îÇ 3.240 s ‚îÇ 3.240 s ‚îÇ 3.240 s ‚îÇ 3.241 s ‚îÇ 2.09 MiB ‚îÇ 2763 ‚îÇ 2 ‚îÇ; ‚îÇ CPU ‚îÇ IsotropicDiffusivity ‚îÇ 2.342 s ‚îÇ 2.344 s ‚îÇ 2.344 s ‚îÇ 2.345 s ‚îÇ 1.77 MiB ‚îÇ 2316 ‚îÇ 3 ‚îÇ; ‚îÇ CPU ‚îÇ SmagorinskyLilly ‚îÇ 3.501 s ‚îÇ 3.504 s ‚îÇ 3.504 s ‚îÇ 3.507 s ‚îÇ 2.03 MiB ‚îÇ 2486 ‚îÇ 2 ‚îÇ; ‚îÇ CPU ‚îÇ TwoDimensionalLeith ‚îÇ 4.813 s ‚îÇ 4.820 s ‚îÇ 4.820 s ‚îÇ 4.828 s ‚îÇ 1.88 MiB ‚îÇ 2481 ‚îÇ 2 ‚îÇ; ‚îÇ GPU ‚îÇ AnisotropicBiharmonicDiffusivity ‚îÇ 24.699 ms ‚îÇ 24.837 ms ‚îÇ 26.946 ms ‚îÇ 46.029 ms ‚îÇ 3.16 MiB ‚îÇ 29911 ‚îÇ 10 ‚îÇ; ‚îÇ GPU ‚îÇ AnisotropicDiffusivity ‚îÇ 16.115 ms ‚îÇ 16.184 ms ‚îÇ 16.454 ms ‚îÇ 18.978 ms ‚îÇ 2.97 MiB ‚îÇ 17169 ‚îÇ 10 ‚îÇ; ‚îÇ GPU ‚îÇ AnisotropicMinimumDi",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:36302,benchmark,benchmarks,36302,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['benchmark'],['benchmarks']
Testability,"ic version of Oceananigans, simulation results; are reproducible up to hardware differences. Performance benchmarks show significant speedups when running on a GPU. Large; simulations on an Nvidia Tesla V100 GPU require ~1 nanosecond per grid point per; iteration. GPU simulations are therefore roughly 3x more cost-effective; than CPU simulations on cloud computing platforms such as Google Cloud. A GPU; with 32 GB of memory can time-step models with ~150 million grid points assuming; five fields are being evolved; for example, three velocity components and; tracers for temperature and salinity. These performance gains permit the; long-time integration of realistic simulations, such as large eddy simulation of; oceanic boundary layer turbulence over a seasonal cycle or the generation of; training data for turbulence parameterizations in Earth system models. ``Oceananigans.jl`` is continuously tested on CPUs and GPUs with unit tests,; integration tests, analytic solutions to the incompressible Navier-Stokes; equations, convergence tests, and verification experiments against published; scientific results. Future development plans include support for distributed; parallelism with CUDA-aware MPI as well as topography. Ocean models that are similar to ``Oceananigans.jl`` include MITgcm; [@Marshall1997] and MOM6 [@Adcroft2019], both written in Fortran. However,; ``Oceananigans.jl`` features a more efficient non-hydrostatic pressure solver; than MITgcm (and MOM6 is strictly hydrostatic). PALM [@Maronga2020] is Fortran; software for large eddy simulation of atmospheric and oceanic boundary layers; with complex boundaries on parallel CPU and GPU architectures. ``Oceananigans.jl``; is distinguished by its use of Julia which allows for a script-based interface as; opposed to a configuration-file-based interface used by MITgcm, MOM6, and PALM.; Dedalus [@Burns2020] is Python software with an intuitive script-based interface; that solves general partial differential equations, incl",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md:3989,test,tested,3989,paper/paper.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md,4,['test'],"['tested', 'tests']"
Testability,"io/master/img/surface_temp_3d_00130_halfsize.png)](https://www.youtube.com/watch?v=kpUrxnKKMjI). ### [Free convection](https://www.youtube.com/watch?v=yq4op9h3xcU). [![Watch free convection in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/free_convection_0956.png)](https://www.youtube.com/watch?v=yq4op9h3xcU). ### [Winds blowing over the ocean](https://www.youtube.com/watch?v=IRncfbvuiy8). [![Watch winds blowing over the ocean](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_0400.png)](https://www.youtube.com/watch?v=IRncfbvuiy8). ### [Free convection with wind stress](https://www.youtube.com/watch?v=ob6OMQgPfI4). [![Watch free convection with wind stress in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_unstable_7500.png)](https://www.youtube.com/watch?v=ob6OMQgPfI4). ## Performance benchmarks. We've performed some preliminary performance benchmarks (see the [performance benchmarks](https://clima.github.io/OceananigansDocumentation/stable/appendix/benchmarks/) section of the documentation) by initializing models of various sizes and measuring the wall clock time taken per model iteration (or time step). This is not really a fair comparison as we haven't parallelized across all the CPU's cores so we will revisit these benchmarks once Oceananigans.jl can run on multiple CPUs and GPUs. To make full use of or fully saturate the computing power of a GPU such as an Nvidia Tesla V100 or; a Titan V, the model should have around ~10 million grid points or more. Sometimes counter-intuitively running with `Float32` is slower than `Float64`. This is likely due; to type mismatches causing slowdowns as floats have to be converted between 32-bit and 64-bit, an; issue that needs to be addressed meticulously. Due to other bottlenecks such as memory accesses and; GPU register pressure, `Float32` models may not provide much of a speedup so the m",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:10694,benchmark,benchmarks,10694,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,2,['benchmark'],['benchmarks']
Testability,"keep a list of [good first issues](https://github.com/CLiMA/Oceananigans.jl/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22); that are self-contained and suitable for a newcomer to try and work on. * Try to run Oceananigans and play around with it to simulate your favorite; fluids and ocean physics. If you run into any problems or find it difficult; to use or understand, please open an issue!. * Write up an example or tutorial on how to do something useful with; Oceananigans, like how to set up a new physical configuration. * Improve documentation or comments if you found something hard to use. * Implement a new feature if you need it to use Oceananigans. If you're interested in working on something, let us know by commenting on existing issues or ; by opening a new issue. This is to make sure no one else is working on the same issue and so ; we can help and guide you in case there is anything you need to know beforehand. ## Ground Rules. * Each pull request should consist of a logical collection of changes. You can; include multiple bug fixes in a single pull request, but they should be related.; For unrelated changes, please submit multiple pull requests. * Do not commit changes to files that are irrelevant to your feature or bugfix; (eg: `.gitignore`). * Be willing to accept criticism and work on improving your code; we don't want; to break other users' code, so care must be taken not to introduce bugs. We; discuss pull requests and keep working on them until we believe we've done a; good job. * Be aware that the pull request review process is not immediate, and is; generally proportional to the size of the pull request. ## Reporting a bug. The easiest way to get involved is to report issues you encounter when using; Oceananigans or by requesting something you think is missing. * Head over to the [issues](https://github.com/CLiMA/Oceananigans.jl/issues) page. * Search to see if your issue already exists or has even been solved previously. * If you ind",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:4939,log,logical,4939,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['log'],['logical']
Testability,"mg alt=""Docker build status"" src=""https://img.shields.io/docker/cloud/build/aliramadhan/oceananigans?label=Docker&logo=docker&logoColor=white&style=flat-square"">; </a>; </p>. Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic; and hydrostatic Boussinesq equations on CPUs and GPUs.; It runs on GPUs (wow, [fast!](http://arxiv.org/abs/2309.06662)), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans.jl is developed by the [Climate Modeling Alliance](https://clima.caltech.edu) and heroic external collaborators. ## Contents. - [Contents](#contents); - [Installation instructions](#installation-instructions); - [Running your first model](#running-your-first-model); - [The Oceananigans knowledge base](#the-oceananigans-knowledge-base); - [Citing](#citing); - [Contributing](#contributing); - [Movies](#movies); - [Deep convection](#deep-convection); - [Free convection](#free-convection); - [Winds blowing over the ocean](#winds-blowing-over-the-ocean); - [Free convection with wind stress](#free-convection-with-wind-stress); - [Performance benchmarks](#performance-benchmarks). ## Installation instructions. Oceananigans is a [registered Julia package](https://julialang.org/packages/). So to install it,. 1. [Download Julia](https://julialang.org/downloads/) (version 1.9 or later). 2. Launch Julia and type. ```julia; julia> using Pkg. julia> Pkg.add(""Oceananigans""); ```. This installs the latest version that's _compatible with your current environment_.; Don't forget to *be careful* üèÑ and check which Oceananigans you installed:. ```julia; julia> Pkg.status(""Oceananigans""); ```. ## Running your first model. Let's run a two-dimensional, horizontally-periodic simulation of turbulence using 128¬≤ finite volume cells for 4 non-dimensional time units:. ```julia; using Oceananigans; grid = Recti",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:4377,benchmark,benchmarks,4377,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,2,['benchmark'],['benchmarks']
Testability,"n the location you'd like to keep it.; ```; git clone https://github.com/your-user-name/Oceananigans.jl.git; ```. * Navigate to that folder in the terminal or in Anaconda Prompt if you're on Windows. * Connect your repository to the upstream (main project).; ```; git remote add oceananigans https://github.com/CLiMA/Oceananigans.jl.git; ```. * Create the development environment by opening Julia via `julia --project` then; typing in `] instantiate`. This will install all the dependencies in the Project.toml; file. Your development environment is now ready!. * You can test to make sure Oceananigans works by typing in `] test`. (This is equivalent to; `using Pkg; Pkg.test()`.) Doing so will run all the tests (and this can take a while).; Alternatively, you can run only one test script file by providing its name as an environment; variable. For example, to run the tests only from the `test_coriolis.jl` file we call:. ```; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; ```. ## Pull Requests. We follow the [ColPrac guide](https://github.com/SciML/ColPrac) for collaborative practices.; We ask that new contributors read that guide before submitting a pull request. Changes and contributions should be made via GitHub pull requests against the ``main`` branch. When you're done making changes, commit the changes you made. Chris Beams has written a ; [guide](https://chris.beams.io/posts/git-commit/) on how to write good commit messages. When you think your changes are ready to be merged into the main repository, push to your fork; and [submit a pull request](https://github.com/CLiMA/Oceananigans.jl/compare/). **Working on your first Pull Request?** You can learn how from this _free_ video series; [How to Contribute to an Open Source Project on GitHub](https://egghead.io/courses/how-to-contribute-to-an-open-source-project-on-github), Aaron Meurer's [tutorial on the git workflow](https://www.asmeurer.com/git-workflow/), or the guide [‚ÄúHow to Contribute to Op",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:7844,test,test,7844,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['test'],['test']
Testability,"nning a separate thread, having 2 threads run on one core will still reduce efficiencies as many resources such as caches and buses must be shared by both threads. Note that there are as many CPU cores allocated as the maximum number of threads. ```; Oceananigans v0.58.9; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :. Shallow water model weak scaling with multithreading benchmark; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ threads ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ samples ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ (8192, 512) ‚îÇ 1 ‚îÇ 1.458 s ‚îÇ 1.458 s ‚îÇ 1.458 s ‚îÇ 1.458 s ‚îÇ 1.37 MiB ‚îÇ 2318 ‚îÇ 4 ‚îÇ; ‚îÇ (8192, 1024) ‚îÇ 2 ‚îÇ 2.925 s ‚îÇ 2.989 s ‚îÇ 2.989 s ‚îÇ 3.052 s ‚îÇ 18.06 MiB ‚îÇ 1076944 ‚îÇ 2 ‚îÇ; ‚îÇ (8192, 2048) ‚îÇ 4 ‚îÇ 2.296 s ‚îÇ 2.381 s ‚îÇ 2.397 s ‚îÇ 2.515 s ‚îÇ 13.60 MiB ‚îÇ 760190 ‚îÇ 3 ‚îÇ; ‚îÇ (8192, 4096) ‚îÇ 8 ‚îÇ 2.347 s ‚îÇ 2.369 s ‚îÇ 2.377 s ‚îÇ 2.415 s ‚îÇ 16.36 MiB ‚îÇ 891860 ‚îÇ 3 ‚îÇ; ‚îÇ (8192, 8192) ‚îÇ 16 ‚îÇ 2.407 s ‚îÇ 2.548 s ‚îÇ 2.517 s ‚îÇ 2.595 s ‚îÇ 17.44 MiB ‚îÇ 863941 ‚îÇ 3 ‚îÇ; ‚îÇ (8192, 16384) ‚îÇ 32 ‚îÇ 3.023 s ‚îÇ 3.069 s ‚îÇ 3.069 s ‚îÇ 3.115 s ‚îÇ 23.03 MiB ‚îÇ 1034063 ‚îÇ 2 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò. Shallow water model weak multithreading scaling speedup; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ threads ‚îÇ slowdown ‚îÇ efficiency ‚îÇ memory ‚îÇ allocs ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:26638,benchmark,benchmark,26638,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['benchmark'],['benchmark']
Testability,"nt environment_.; Don't forget to *be careful* üèÑ and check which Oceananigans you installed:. ```julia; julia> Pkg.status(""Oceananigans""); ```. ## Running your first model. Let's run a two-dimensional, horizontally-periodic simulation of turbulence using 128¬≤ finite volume cells for 4 non-dimensional time units:. ```julia; using Oceananigans; grid = RectilinearGrid(CPU(), size=(128, 128), x=(0, 2œÄ), y=(0, 2œÄ), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO()); œµ(x, y) = 2rand() - 1; set!(model, u=œµ, v=œµ); simulation = Simulation(model; Œît=0.01, stop_time=4); run!(simulation); ```. But there's more: changing `CPU()` to `GPU()` makes this code run on a CUDA-enabled Nvidia GPU. Dive into [the documentation](https://clima.github.io/OceananigansDocumentation/stable/) for more code examples and tutorials.; Below, you'll find movies from GPU simulations along with CPU and GPU [performance benchmarks](https://github.com/clima/Oceananigans.jl#performance-benchmarks). ## The Oceananigans knowledge base. It's _deep_ and includes:. * [Documentation](https://clima.github.io/OceananigansDocumentation/stable) that provides; * example Oceananigans scripts,; * tutorials that describe key Oceananigans objects and functions,; * explanations of Oceananigans finite-volume-based numerical methods,; * details of the dynamical equations solved by Oceananigans models, and; * a library documenting all user-facing Oceananigans objects and functions.; * [Discussions on the Oceananigans github](https://github.com/CliMA/Oceananigans.jl/discussions), covering topics like; * [""Computational science""](https://github.com/CliMA/Oceananigans.jl/discussions/categories/computational-science), or how to science and set up numerical simulations in Oceananigans, and; * [""Experimental features""](https://github.com/CliMA/Oceananigans.jl/discussions?discussions_q=experimental+features), which covers new and sparsely-documented features for those who like to live danger",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:5781,benchmark,benchmarks,5781,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['benchmark'],['benchmarks']
Testability,"oclinic; instability acting on basin-scale temperature gradients fills the oceans with; eddies that stir carbon and heat. Plots made with `matplotlib` [@Hunter2007]; and `cmocean` [@Thyng2016]. ``Oceananigans.jl`` leverages the Julia programming language [@Bezanson2017] to; implement high-level, low-cost abstractions, a friendly user interface, and a; high-performance model in one language and a common code base for execution on; the CPU or GPU with Julia‚Äôs native GPU compiler [@Besard2019]. Because Julia is; a high-level language, development is streamlined and users can flexibly specify; model configurations, set up arbitrary diagnostics and output, extend the code; base, and implement new features. Configuring a model with `architecture=CPU()`; or `architecture=GPU()` will execute the model on the CPU or GPU. By pinning a; simulation script against a specific version of Oceananigans, simulation results; are reproducible up to hardware differences. Performance benchmarks show significant speedups when running on a GPU. Large; simulations on an Nvidia Tesla V100 GPU require ~1 nanosecond per grid point per; iteration. GPU simulations are therefore roughly 3x more cost-effective; than CPU simulations on cloud computing platforms such as Google Cloud. A GPU; with 32 GB of memory can time-step models with ~150 million grid points assuming; five fields are being evolved; for example, three velocity components and; tracers for temperature and salinity. These performance gains permit the; long-time integration of realistic simulations, such as large eddy simulation of; oceanic boundary layer turbulence over a seasonal cycle or the generation of; training data for turbulence parameterizations in Earth system models. ``Oceananigans.jl`` is continuously tested on CPUs and GPUs with unit tests,; integration tests, analytic solutions to the incompressible Navier-Stokes; equations, convergence tests, and verification experiments against published; scientific results. Future de",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md:3190,benchmark,benchmarks,3190,paper/paper.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md,1,['benchmark'],['benchmarks']
Testability,"onhydrostatic and shallow water models is still an active area of improvement. Please use the appropriate scripts found in [`benchmarks`](https://github.com/CliMA/Oceananigans.jl/tree/main/benchmark) to obtain more recent and hopefully ameliorated benchmark results. ```; Oceananigans v0.58.9; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; EBVERSIONJULIA = 1.6.1; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel; JULIA_LOAD_PATH = :. Multithreading benchmarks; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ threads ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ samples ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ 256 ‚îÇ 1 ‚îÇ 2.496 s ‚îÇ 2.637 s ‚îÇ 2.637 s ‚îÇ 2.777 s ‚îÇ 1.70 MiB ‚îÇ 2251 ‚îÇ 2 ‚îÇ; ‚îÇ 256 ‚îÇ 2 ‚îÇ 2.385 s ‚îÇ 2.618 s ‚îÇ 2.618 s ‚îÇ 2.851 s ‚îÇ 7.03 MiB ‚îÇ 342397 ‚îÇ 2 ‚îÇ; ‚îÇ 256 ‚îÇ 4 ‚îÇ 1.320 s ‚îÇ 1.321 s ‚îÇ 1.333 s ‚îÇ 1.371 s ‚îÇ 3.69 MiB ‚îÇ 113120 ‚îÇ 4 ‚îÇ; ‚îÇ 256 ‚îÇ 8 ‚îÇ 850.438 ms ‚îÇ 855.292 ms ‚îÇ 855.952 ms ‚îÇ 861.966 ms ‚îÇ 3.31 MiB ‚îÇ 65709 ‚îÇ 6 ‚îÇ; ‚îÇ 256 ‚îÇ 16 ‚îÇ 642.225 ms ‚îÇ 645.458 ms ‚îÇ 648.685 ms ‚îÇ 674.259 ms ‚îÇ 3.60 MiB ‚îÇ 40992 ‚îÇ 8 ‚îÇ; ‚îÇ 256 ‚îÇ 32 ‚îÇ 680.938 ms ‚îÇ 694.376 ms ‚îÇ 701.272 ms ‚îÇ 746.599 ms ‚îÇ 4.88 MiB ‚îÇ 36729 ‚îÇ 8 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò. Nonhydrostatic Strong Scaling Multithreading speedup; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ threads ‚îÇ slowdown ‚îÇ efficiency ‚îÇ memory ‚îÇ allocs ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ 256 ‚îÇ 1 ‚îÇ ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:29421,benchmark,benchmarks,29421,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['benchmark'],['benchmarks']
Testability,"or `git bash` on Windows). * Login to your GitHub account and make a fork of the; [Oceananigans repository](https://github.com/CLiMA/Oceananigans.jl) by; clicking the ""Fork"" button. * Clone your fork of the Oceananigans repository (in terminal on Mac/Linux or git shell/; GUI on Windows) in the location you'd like to keep it.; ```; git clone https://github.com/your-user-name/Oceananigans.jl.git; ```. * Navigate to that folder in the terminal or in Anaconda Prompt if you're on Windows. * Connect your repository to the upstream (main project).; ```; git remote add oceananigans https://github.com/CLiMA/Oceananigans.jl.git; ```. * Create the development environment by opening Julia via `julia --project` then; typing in `] instantiate`. This will install all the dependencies in the Project.toml; file. Your development environment is now ready!. * You can test to make sure Oceananigans works by typing in `] test`. (This is equivalent to; `using Pkg; Pkg.test()`.) Doing so will run all the tests (and this can take a while).; Alternatively, you can run only one test script file by providing its name as an environment; variable. For example, to run the tests only from the `test_coriolis.jl` file we call:. ```; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; ```. ## Pull Requests. We follow the [ColPrac guide](https://github.com/SciML/ColPrac) for collaborative practices.; We ask that new contributors read that guide before submitting a pull request. Changes and contributions should be made via GitHub pull requests against the ``main`` branch. When you're done making changes, commit the changes you made. Chris Beams has written a ; [guide](https://chris.beams.io/posts/git-commit/) on how to write good commit messages. When you think your changes are ready to be merged into the main repository, push to your fork; and [submit a pull request](https://github.com/CLiMA/Oceananigans.jl/compare/). **Working on your first Pull Request?** You can learn how from ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:7558,test,tests,7558,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['test'],['tests']
Testability,"phi_\mathrm{sim}``, with exact, analytically-derived solutions; ``\phi_\mathrm{exact}``.; The field ``\phi`` may be a tracer field or a velocity field. ## Point Exponential Decay. This test analyzes time-stepper convergence by simulating the zero-dimensional, or spatially-uniform equation. ```math; \partial_t c = - c \, ,; ```. with the initial condition ``c = 1``, which has the analytical solution ``c = \mathrm{e}^{-t}``. We find the expected first-order convergence with decreasing time-step ``\Delta t`` using our; first-order accurate, ""modified second-order"" Adams-Bashforth time-stepping method:. ![Point exponential decay](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/point_exponential_decay_time_stepper_convergence.png). This result validates the correctness of the `Oceananigans` implementation of Adams-Bashforth time-stepping. ## One-dimensional advection and diffusion of a Gaussian. This and the following tests focus on convergence with grid spacing, ``\Delta x``. In one dimension with constant diffusivity ``\kappa`` and in the presence of a; constant velocity ``U``, a Gaussian evolves according to. ```math; c = \frac{\mathrm{e}^{- (x - U t)^2 / 4 \kappa t}}{\sqrt{4 \pi \kappa t}} \, .; ```. For this test we take the initial time as ``t=t_0``.; We simulate this problem with advection and diffusion, as well as with ``U=0`` and thus diffusion only, as well as with; ``\kappa \approx 0`` and thus ""advection only"".; The solutions are. ![Gaussian advection diffusion solutions](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png). which exhibit the expected second-order convergence with ``\Delta x^2 \propto 1 / N_x^2``:. ![Gaussian advection diffusion convergence](https://raw.githubusercontent.com/CliMA/Oceananigans.jl/v0.35.0/docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png).",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md:1611,test,tests,1611,docs/src/appendix/convergence_tests.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/convergence_tests.md,1,['test'],['tests']
Testability,"r-images.githubusercontent.com/45054739/129826134-3c526b9f-efd1-436c-9dc1-bde376a035db.png). ### Multi-GPU Shallow Water Model. While still a work in progress, it is possible to use CUDA-aware MPI to run the shallow water model on multiple GPUs. Though efficiencies may not be as high as multi-CPU, the multi-GPU architecture is still worthwhile when keeping in mind the baseline speedups generated by using a single GPU. Note that though it is possible for multiple ranks to share the use of a single GPU, efficiencies would significantly decrease and memory may be insufficient. The results below show up to three ranks each using a separate GPU. ```; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); Environment:; JULIA_MPI_PATH = /home/software/spack/openmpi/3.1.4-nhjzelonyovxks5ydtrxehceqxsbf7ik; JULIA_CUDA_USE_BINARYBUILDER = false; JULIA_DEPOT_PATH = /nobackup/users/henryguo/projects/henry-test/Oceananigans.jl/benchmark/.julia; GPU: Tesla V100-SXM2-32GB; ; Shallow water model weak scaling benchmark; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ ranks ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ samples ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ (4096, 256) ‚îÇ (1, 1) ‚îÇ 2.702 ms‚îÇ 2.728 ms‚îÇ 2.801 ms‚îÇ 3.446 ms‚îÇ 2.03 MiB ‚îÇ 5535 ‚îÇ 10 ‚îÇ; ‚îÇ (4096, 512) ‚îÇ (1, 2) ‚îÇ 3.510 ms‚îÇ 3.612 ms‚îÇ 4.287 ms‚îÇ16.546 ms‚îÇ 2.03 MiB ‚îÇ 5859 ‚îÇ 20 ‚îÇ; ‚îÇ (4096, 768) ‚îÇ (1, 3) ‚îÇ 3.553 ms‚îÇ 3.653 ms‚îÇ 5.195 ms‚îÇ39.152 ms‚îÇ 2.03 MiB ‚îÇ 5859 ‚îÇ 30 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò. Shallow water model weak scaling speedup; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ ranks ‚îÇ slowdown ‚îÇ efficiency ‚îÇ memory ‚îÇ allocs ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:16746,test,test,16746,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['test'],['test']
Testability,"rmed on a staggered grid, DCT-II (`REDFT10`) is used to perform the forward cosine transform and DCT-III; (`REDFT01`) is used to perform the inverse cosine transform. ## Direct method with a vertically stretched grid. Using Fourier transforms for all three dimensions results in a method requiring ``\mathcal{O}(N \log_2 N)`` operations; where ``N`` is the total number of grid points. This algorithm can be made even more efficient by solving a tridiagonal; system along one of the dimensions and utilizing cyclic reduction. This results in the *Fourier analysis cyclic; reduction* or ``\text{FACR}(\ell)`` algorithm (with ``\ell`` cyclic reduction steps) which requires only; ``\mathcal{O}(N \log_2\log_2 N)`` operations provided the optimal number of cyclic reduction steps is taken, which is; ``\ell = \log_2 \log_2 n`` where ``n`` is the number of grid points in the cyclic reduction dimension. The FACR algorithm; was first developed by [Hockney69](@citet) and is well reviewed by [Swarztrauber77](@citet) then further benchmarked and; extended by [Temperton79](@citet) and [Temperton80](@citet). Furthermore, the FACR algorithm removes the restriction that the grid is uniform in one of the dimensions so it can; be utilized to implement a fast Poisson solver for vertically stretched grids if the cyclic reduction is applied in the; along the vertical dimension. Expanding ``p_{NH}`` and ``\mathscr{F}`` into Fourier modes along the ``x`` and ``y`` directions; ```math; p_{ijk} = \sum_{m=1}^{N_x} \sum_{n=1}^{N_y} \tilde{p}_{mnk} \; e^{-\mathrm{i} 2\pi i m / N_x} \; e^{-\mathrm{i} 2\pi j n / N_y} \, ,; ```; and recalling that Fourier transforms do ``\partial_x \rightarrow \mathrm{i} k_x`` and ``\partial_y \rightarrow \mathrm{i} k_y`` we can write; \eqref{eq:poisson-pressure} as; ```math; \sum_{m=1}^{N_x} \sum_{n=1}^{N_y}; \left\lbrace; \partial_z^2 \tilde{p}_{mnk} - (k_x^2 + k_y^2) \tilde{p}_{mnk} - \tilde{\mathscr{F}}_{mnk}; \right\rbrace e^{-\mathrm{i} 2 \pi i m / N_x} e^{-\mathrm{i",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:5727,benchmark,benchmarked,5727,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['benchmark'],['benchmarked']
Testability,"ttps://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/free_convection_0956.png)](https://www.youtube.com/watch?v=yq4op9h3xcU). ### [Winds blowing over the ocean](https://www.youtube.com/watch?v=IRncfbvuiy8). [![Watch winds blowing over the ocean](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_0400.png)](https://www.youtube.com/watch?v=IRncfbvuiy8). ### [Free convection with wind stress](https://www.youtube.com/watch?v=ob6OMQgPfI4). [![Watch free convection with wind stress in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_unstable_7500.png)](https://www.youtube.com/watch?v=ob6OMQgPfI4). ## Performance benchmarks. We've performed some preliminary performance benchmarks (see the [performance benchmarks](https://clima.github.io/OceananigansDocumentation/stable/appendix/benchmarks/) section of the documentation) by initializing models of various sizes and measuring the wall clock time taken per model iteration (or time step). This is not really a fair comparison as we haven't parallelized across all the CPU's cores so we will revisit these benchmarks once Oceananigans.jl can run on multiple CPUs and GPUs. To make full use of or fully saturate the computing power of a GPU such as an Nvidia Tesla V100 or; a Titan V, the model should have around ~10 million grid points or more. Sometimes counter-intuitively running with `Float32` is slower than `Float64`. This is likely due; to type mismatches causing slowdowns as floats have to be converted between 32-bit and 64-bit, an; issue that needs to be addressed meticulously. Due to other bottlenecks such as memory accesses and; GPU register pressure, `Float32` models may not provide much of a speedup so the main benefit becomes; lower memory costs (by around a factor of 2). ![Performance benchmark plots](https://user-images.githubusercontent.com/20099589/89906791-d2c85b00-dbb9-11ea-969a-4b8db2c31680.png); ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:11080,benchmark,benchmarks,11080,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,2,['benchmark'],"['benchmark', 'benchmarks']"
Testability,"ttps://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/surface_temp_3d_00130_halfsize.png)](https://www.youtube.com/watch?v=kpUrxnKKMjI). ### [Free convection](https://www.youtube.com/watch?v=yq4op9h3xcU). [![Watch free convection in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/free_convection_0956.png)](https://www.youtube.com/watch?v=yq4op9h3xcU). ### [Winds blowing over the ocean](https://www.youtube.com/watch?v=IRncfbvuiy8). [![Watch winds blowing over the ocean](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_0400.png)](https://www.youtube.com/watch?v=IRncfbvuiy8). ### [Free convection with wind stress](https://www.youtube.com/watch?v=ob6OMQgPfI4). [![Watch free convection with wind stress in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_unstable_7500.png)](https://www.youtube.com/watch?v=ob6OMQgPfI4). ## Performance benchmarks. We've performed some preliminary performance benchmarks (see the [performance benchmarks](https://clima.github.io/OceananigansDocumentation/stable/appendix/benchmarks/) section of the documentation) by initializing models of various sizes and measuring the wall clock time taken per model iteration (or time step). This is not really a fair comparison as we haven't parallelized across all the CPU's cores so we will revisit these benchmarks once Oceananigans.jl can run on multiple CPUs and GPUs. To make full use of or fully saturate the computing power of a GPU such as an Nvidia Tesla V100 or; a Titan V, the model should have around ~10 million grid points or more. Sometimes counter-intuitively running with `Float32` is slower than `Float64`. This is likely due; to type mismatches causing slowdowns as floats have to be converted between 32-bit and 64-bit, an; issue that needs to be addressed meticulously. Due to other bottlenecks such as memory accesses and; GPU register pre",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:10637,benchmark,benchmarks,10637,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['benchmark'],['benchmarks']
Testability,"unts downloads from individual IPs excluding bots (eg, CI) -->; <!-- see https://discourse.julialang.org/t/announcing-package-download-stats/69073 -->. <p align=""center"">; <a href=""https://juliapkgstats.com/pkg/Oceananigans"">; <img alt=""Downloads per month"" src=""https://img.shields.io/badge/dynamic/json?url=http%3A%2F%2Fjuliapkgstats.com%2Fapi%2Fv1%2Fmonthly_downloads%2FOceananigans&query=total_requests&suffix=%2Fmonth&label=Downloads&style=flat-square"">; </a>; <a href=""https://juliapkgstats.com/pkg/Oceananigans"">; <img alt=""Downloads per month"" src=""https://img.shields.io/badge/dynamic/json?url=http%3A%2F%2Fjuliapkgstats.com%2Fapi%2Fv1%2Ftotal_downloads%2FOceananigans&query=total_requests&&label=Total%20Downloads&style=flat-square"">; </a>; </p>. <!-- CI/CD badges -->; <p align=""center"">; <a href=""https://buildkite.com/clima/oceananigans"">; <img alt=""Buildkite CPU+GPU build status"" src=""https://img.shields.io/buildkite/4d921fc17b95341ea5477fb62df0e6d9364b61b154e050a123/main?logo=buildkite&label=Buildkite%20CPU%2BGPU&style=flat-square"">; </a>; <a href=""https://hub.docker.com/r/aliramadhan/oceananigans"">; <img alt=""Docker build status"" src=""https://img.shields.io/docker/cloud/build/aliramadhan/oceananigans?label=Docker&logo=docker&logoColor=white&style=flat-square"">; </a>; </p>. Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic; and hydrostatic Boussinesq equations on CPUs and GPUs.; It runs on GPUs (wow, [fast!](http://arxiv.org/abs/2309.06662)), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans.jl is developed by the [Climate Modeling Alliance](https://clima.caltech.edu) and heroic external collaborators. ## Contents. - [Contents](#contents); - [Installation instructions](#installation-instructions); - [Running your first model](#running-your-first-model); - [The Oceana",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:3002,log,logo,3002,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['log'],['logo']
Testability,"using `MPI.jl` the shallow water model can be run on multiple CPUs and multiple GPUs. For the benchmark results shown below, each rank is run on one CPU core and each uses a distinct GPU if applicable. . ### Weak Scaling Shallow Water Model; ```; Oceananigans v0.58.2; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :. Shallow water model weak scaling benchmark; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ ranks ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ samples ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ (4096, 256) ‚îÇ (1, 1) ‚îÇ 363.885 ms ‚îÇ 364.185 ms ‚îÇ 364.911 ms ‚îÇ 370.414 ms ‚îÇ 1.60 MiB ‚îÇ 2774 ‚îÇ 10 ‚îÇ; ‚îÇ (4096, 512) ‚îÇ (1, 2) ‚îÇ 370.782 ms ‚îÇ 375.032 ms ‚îÇ 375.801 ms ‚îÇ 394.781 ms ‚îÇ 1.49 MiB ‚îÇ 3116 ‚îÇ 20 ‚îÇ; ‚îÇ (4096, 1024) ‚îÇ (1, 4) ‚îÇ 369.648 ms ‚îÇ 369.973 ms ‚îÇ 371.613 ms ‚îÇ 399.526 ms ‚îÇ 1.49 MiB ‚îÇ 3116 ‚îÇ 40 ‚îÇ; ‚îÇ (4096, 2048) ‚îÇ (1, 8) ‚îÇ 377.386 ms ‚îÇ 379.982 ms ‚îÇ 382.732 ms ‚îÇ 432.787 ms ‚îÇ 1.49 MiB ‚îÇ 3116 ‚îÇ 80 ‚îÇ; ‚îÇ (4096, 4096) ‚îÇ (1, 16) ‚îÇ 388.336 ms ‚îÇ 395.473 ms ‚îÇ 400.079 ms ‚îÇ 496.598 ms ‚îÇ 1.49 MiB ‚îÇ 3116 ‚îÇ 160 ‚îÇ; ‚îÇ (4096, 8192) ‚îÇ (1, 32) ‚îÇ 403.565 ms ‚îÇ 447.136 ms ‚îÇ 449.138 ms ‚îÇ 545.945 ms ‚îÇ 1.49 MiB ‚îÇ 3116 ‚îÇ 320 ‚îÇ; ‚îÇ (4096, 16384) ‚îÇ (1, 64) ‚îÇ 397.965 ms ‚îÇ 441.627 ms ‚îÇ 453.465 ms ‚îÇ 619.493 ms ‚îÇ 1.49 MiB ‚îÇ 3125 ‚îÇ 640 ‚îÇ; ‚îÇ (4096, 32768) ‚îÇ (1, 128) ‚îÇ 400.481 ms ‚îÇ 447.789 ms ‚îÇ 448.692 ms ‚îÇ 590.028 ms ‚îÇ 1.49 MiB ‚îÇ 3125 ‚îÇ 1280 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:10161,benchmark,benchmark,10161,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['benchmark'],['benchmark']
Testability,"weak multithreading scaling speedup; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ threads ‚îÇ slowdown ‚îÇ efficiency ‚îÇ memory ‚îÇ allocs ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ (8192, 512) ‚îÇ 1 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ; ‚îÇ (8192, 1024) ‚îÇ 2 ‚îÇ 2.04972 ‚îÇ 0.487872 ‚îÇ 13.2156 ‚îÇ 464.601 ‚îÇ; ‚îÇ (8192, 2048) ‚îÇ 4 ‚îÇ 1.63302 ‚îÇ 0.612363 ‚îÇ 9.95278 ‚îÇ 327.951 ‚îÇ; ‚îÇ (8192, 4096) ‚îÇ 8 ‚îÇ 1.62507 ‚îÇ 0.615359 ‚îÇ 11.9706 ‚îÇ 384.754 ‚îÇ; ‚îÇ (8192, 8192) ‚îÇ 16 ‚îÇ 1.74747 ‚îÇ 0.572257 ‚îÇ 12.755 ‚îÇ 372.71 ‚îÇ; ‚îÇ (8192, 16384) ‚îÇ 32 ‚îÇ 2.10486 ‚îÇ 0.47509 ‚îÇ 16.846 ‚îÇ 446.101 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò; ```. ### Strong Scaling Multithreaded Nonhydrostatic Model. The notable and continuous decrease in efficiencies for the strong scaling nonhydrostatic model is likely caused by the `256^3` grid not sufficiently saturating 32 threads running on 32 CPUs. At the time this benchmark was produced, multithreading for both nonhydrostatic and shallow water models is still an active area of improvement. Please use the appropriate scripts found in [`benchmarks`](https://github.com/CliMA/Oceananigans.jl/tree/main/benchmark) to obtain more recent and hopefully ameliorated benchmark results. ```; Oceananigans v0.58.9; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; EBVERSIONJULIA = 1.6.1; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel; JULIA_LOAD_PATH = :. Multithreading benchmarks; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ threads ‚îÇ min ‚îÇ median ‚îÇ mea",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:28517,benchmark,benchmark,28517,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['benchmark'],['benchmark']
Testability,"y for stable; stratification with ``\partial_z b > 0`` and ``C_b`` is a user-specified constant. Lilly (1962); proposed ``C_b = 1/Pr``, where ``Pr`` is a turbulent Prandtl number.; The filter width for the Smagorinsky-Lilly closure is; ```math; \Delta_f(\boldsymbol{x}) = \left ( \Delta x \Delta y \Delta z \right)^{1/3} \, ,; ```; where ``\Delta x``, ``\Delta y``, and ``\Delta z`` are the grid spacing in the; ``\boldsymbol{\hat x}``, ``\boldsymbol{\hat y}``, and ``\boldsymbol{\hat z}`` directions at location ``\boldsymbol{x} = (x, y, z)``. The effect of subgrid turbulence on tracer mixing is also modeled diffusively via; ```math; \boldsymbol{q}_c = - \kappa_e \boldsymbol{\nabla} c \, ,; ```; where the eddy diffusivity ``\kappa_e`` is; ```math; \kappa_e = \frac{\nu_e}{Pr} + \kappa \, .; ```; Both ``Pr`` and ``\kappa`` may be set independently for each tracer. ## Anisotropic minimum dissipation (AMD) turbulence closure. The anisotropic minimum dissipation (AMD) model proposed by [Verstappen18](@citet) and was; described and tested by [Vreugdenhil18](@citet). The AMD model uses an eddy diffusivity hypothesis; similar the Smagorinsky-Lilly model. In the AMD model, the eddy viscosity and diffusivity for each; tracer are defined in terms of eddy viscosity and diffusivity *predictors* ``\nu_e^\dagger`` and ``\kappa_e^\dagger``,; such that; ```math; \nu_e = \max \left ( 0, \nu_e^\dagger \right ) + \nu; \quad \text{and} \quad; \kappa_e = \max \left ( 0, \kappa_e^\dagger \right ) + \kappa \, ,; ```; to ensure that ``\nu_e \ge 0`` and ``\kappa_e \ge 0``, where ``\nu`` and ``\kappa`` are the; constant isotropic background viscosity and diffusivities for each tracer. The eddy viscosity ; predictor is; ```math; \begin{equation}; \nu_e^\dagger = C \Delta_f^2; \frac; {(\hat{\partial}_k \hat{v}_i) (\hat{\partial}_k \hat{v}_j) \hat{\Sigma}_{ij}; + C_b \hat{\delta}_{i3} (\hat{\partial}_k \hat{v_i}) (\hat{\partial}_k b)}; {(\hat{\partial}_l \hat{v}_m) (\hat{\partial}_l \hat{v}_m)} \, ,; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/turbulence_closures.md:5161,test,tested,5161,docs/src/physics/turbulence_closures.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/turbulence_closures.md,1,['test'],['tested']
Testability,"your system. * Install `git` on your system if it is not already there (install XCode command line tools on; a Mac or `git bash` on Windows). * Login to your GitHub account and make a fork of the; [Oceananigans repository](https://github.com/CLiMA/Oceananigans.jl) by; clicking the ""Fork"" button. * Clone your fork of the Oceananigans repository (in terminal on Mac/Linux or git shell/; GUI on Windows) in the location you'd like to keep it.; ```; git clone https://github.com/your-user-name/Oceananigans.jl.git; ```. * Navigate to that folder in the terminal or in Anaconda Prompt if you're on Windows. * Connect your repository to the upstream (main project).; ```; git remote add oceananigans https://github.com/CLiMA/Oceananigans.jl.git; ```. * Create the development environment by opening Julia via `julia --project` then; typing in `] instantiate`. This will install all the dependencies in the Project.toml; file. Your development environment is now ready!. * You can test to make sure Oceananigans works by typing in `] test`. (This is equivalent to; `using Pkg; Pkg.test()`.) Doing so will run all the tests (and this can take a while).; Alternatively, you can run only one test script file by providing its name as an environment; variable. For example, to run the tests only from the `test_coriolis.jl` file we call:. ```; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; ```. ## Pull Requests. We follow the [ColPrac guide](https://github.com/SciML/ColPrac) for collaborative practices.; We ask that new contributors read that guide before submitting a pull request. Changes and contributions should be made via GitHub pull requests against the ``main`` branch. When you're done making changes, commit the changes you made. Chris Beams has written a ; [guide](https://chris.beams.io/posts/git-commit/) on how to write good commit messages. When you think your changes are ready to be merged into the main repository, push to your fork; and [submit a pull request](",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:7422,test,test,7422,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,2,['test'],['test']
Testability,"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ Float_types ‚îÇ Ns ‚îÇ speedup ‚îÇ memory ‚îÇ allocs ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ Float32 ‚îÇ 32 ‚îÇ 8.20434 ‚îÇ 1.53786 ‚îÇ 2.62076 ‚îÇ; ‚îÇ Float32 ‚îÇ 64 ‚îÇ 77.5308 ‚îÇ 1.53835 ‚îÇ 2.63988 ‚îÇ; ‚îÇ Float32 ‚îÇ 128 ‚îÇ 382.591 ‚îÇ 1.55378 ‚îÇ 3.24805 ‚îÇ; ‚îÇ Float32 ‚îÇ 256 ‚îÇ 448.619 ‚îÇ 1.77688 ‚îÇ 12.0421 ‚îÇ; ‚îÇ Float64 ‚îÇ 32 ‚îÇ 10.2308 ‚îÇ 1.51613 ‚îÇ 2.62076 ‚îÇ; ‚îÇ Float64 ‚îÇ 64 ‚îÇ 78.9952 ‚îÇ 1.51646 ‚îÇ 2.63727 ‚îÇ; ‚îÇ Float64 ‚îÇ 128 ‚îÇ 317.663 ‚îÇ 1.53759 ‚îÇ 3.69896 ‚îÇ; ‚îÇ Float64 ‚îÇ 256 ‚îÇ 346.554 ‚îÇ 1.79466 ‚îÇ 16.6173 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò; ```. Like the shallow water model, it can be seen at grid size `64^3` that the GPU is beginning to be saturated as speedups rapidly increase. At grid sizes `128^3` and `256^3` we see the speedup stabilize to around 400 times. ![incompressible_speedup](https://user-images.githubusercontent.com/45054739/129825248-adb8dfe5-e9ea-4321-bd11-fb415d81e2cb.png). For both float types, the benchmarked GPU times of the nonhydrostatic model starts to scale like its CPU times when grid size reaches `128^3`. ![incompressible_times](https://user-images.githubusercontent.com/45054739/129825253-0d5739d9-f0a7-476e-8152-4ee462b71ad5.png). ## Distributed Shallow Water Model. By using `MPI.jl` the shallow water model can be run on multiple CPUs and multiple GPUs. For the benchmark results shown below, each rank is run on one CPU core and each uses a distinct GPU if applicable. . ### Weak Scaling Shallow Water Model; ```; Oceananigans v0.58.2; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-C",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:9029,benchmark,benchmarked,9029,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['benchmark'],['benchmarked']
Testability,"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ (8192, 512) ‚îÇ 1 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ; ‚îÇ (8192, 1024) ‚îÇ 2 ‚îÇ 2.04972 ‚îÇ 0.487872 ‚îÇ 13.2156 ‚îÇ 464.601 ‚îÇ; ‚îÇ (8192, 2048) ‚îÇ 4 ‚îÇ 1.63302 ‚îÇ 0.612363 ‚îÇ 9.95278 ‚îÇ 327.951 ‚îÇ; ‚îÇ (8192, 4096) ‚îÇ 8 ‚îÇ 1.62507 ‚îÇ 0.615359 ‚îÇ 11.9706 ‚îÇ 384.754 ‚îÇ; ‚îÇ (8192, 8192) ‚îÇ 16 ‚îÇ 1.74747 ‚îÇ 0.572257 ‚îÇ 12.755 ‚îÇ 372.71 ‚îÇ; ‚îÇ (8192, 16384) ‚îÇ 32 ‚îÇ 2.10486 ‚îÇ 0.47509 ‚îÇ 16.846 ‚îÇ 446.101 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò; ```. ### Strong Scaling Multithreaded Nonhydrostatic Model. The notable and continuous decrease in efficiencies for the strong scaling nonhydrostatic model is likely caused by the `256^3` grid not sufficiently saturating 32 threads running on 32 CPUs. At the time this benchmark was produced, multithreading for both nonhydrostatic and shallow water models is still an active area of improvement. Please use the appropriate scripts found in [`benchmarks`](https://github.com/CliMA/Oceananigans.jl/tree/main/benchmark) to obtain more recent and hopefully ameliorated benchmark results. ```; Oceananigans v0.58.9; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; EBVERSIONJULIA = 1.6.1; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel; JULIA_LOAD_PATH = :. Multithreading benchmarks; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ threads ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ samples ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ 256 ‚îÇ 1 ‚îÇ 2.496 s ‚îÇ 2.637 s ‚îÇ 2.637 s ‚îÇ 2.777 s ‚îÇ 1.70 MiB ‚îÇ 2251 ‚îÇ 2 ‚îÇ;",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:28755,benchmark,benchmark,28755,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,2,['benchmark'],['benchmark']
Testability,"‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò. Shallow water model strong scaling speedup; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ ranks ‚îÇ speedup ‚îÇ efficiency ‚îÇ memory ‚îÇ allocs ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ (4096, 4096) ‚îÇ (1, 1) ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ; ‚îÇ (4096, 4096) ‚îÇ (1, 2) ‚îÇ 1.98728 ‚îÇ 0.993641 ‚îÇ 0.930621 ‚îÇ 1.12197 ‚îÇ; ‚îÇ (4096, 4096) ‚îÇ (1, 4) ‚îÇ 3.96338 ‚îÇ 0.990845 ‚îÇ 0.930621 ‚îÇ 1.12197 ‚îÇ; ‚îÇ (4096, 4096) ‚îÇ (1, 8) ‚îÇ 7.73237 ‚îÇ 0.966547 ‚îÇ 0.930621 ‚îÇ 1.12197 ‚îÇ; ‚îÇ (4096, 4096) ‚îÇ (1, 16) ‚îÇ 14.3881 ‚îÇ 0.899255 ‚îÇ 0.930336 ‚îÇ 1.11127 ‚îÇ; ‚îÇ (4096, 4096) ‚îÇ (1, 32) ‚îÇ 25.9754 ‚îÇ 0.811731 ‚îÇ 0.930336 ‚îÇ 1.11127 ‚îÇ; ‚îÇ (4096, 4096) ‚îÇ (1, 64) ‚îÇ 50.5666 ‚îÇ 0.790102 ‚îÇ 0.930421 ‚îÇ 1.11448 ‚îÇ; ‚îÇ (4096, 4096) ‚îÇ (1, 128) ‚îÇ 94.4984 ‚îÇ 0.738269 ‚îÇ 0.930421 ‚îÇ 1.11448 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò; ```. Slightly differing from the weak scaling results, efficiencies drop below 80% to around 74% at 128 ranks for the strong scaling distributed shallow water model benchmark. This is likely caused by the 128 CPU cores not being sufficiently saturated anymore by the constant `4096^2` grid size thus losing some efficiency overheads. ![ss_shallow_water_efficiency](https://user-images.githubusercontent.com/45054739/129826134-3c526b9f-efd1-436c-9dc1-bde376a035db.png). ### Multi-GPU Shallow Water Model. While still a work in progress, it is possible to use CUDA-aware MPI to run the shallow water model on multiple GPUs. Though efficiencies may not be as high as multi-CPU, the multi-GPU architecture is still worthwhile when keeping in mind the baseline speedups generated by using a single GPU. Note that though it is possible for multiple ranks to share the use of a single GPU, efficiencies would significantly decrease and memory may be insufficient. The results below show up to three ranks each using a separate GPU. ```; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:15477,benchmark,benchmark,15477,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['benchmark'],['benchmark']
Testability,"‚îÇ size ‚îÇ threads ‚îÇ slowdown ‚îÇ efficiency ‚îÇ memory ‚îÇ allocs ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ (8192, 512) ‚îÇ 1 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ; ‚îÇ (8192, 1024) ‚îÇ 2 ‚îÇ 2.04972 ‚îÇ 0.487872 ‚îÇ 13.2156 ‚îÇ 464.601 ‚îÇ; ‚îÇ (8192, 2048) ‚îÇ 4 ‚îÇ 1.63302 ‚îÇ 0.612363 ‚îÇ 9.95278 ‚îÇ 327.951 ‚îÇ; ‚îÇ (8192, 4096) ‚îÇ 8 ‚îÇ 1.62507 ‚îÇ 0.615359 ‚îÇ 11.9706 ‚îÇ 384.754 ‚îÇ; ‚îÇ (8192, 8192) ‚îÇ 16 ‚îÇ 1.74747 ‚îÇ 0.572257 ‚îÇ 12.755 ‚îÇ 372.71 ‚îÇ; ‚îÇ (8192, 16384) ‚îÇ 32 ‚îÇ 2.10486 ‚îÇ 0.47509 ‚îÇ 16.846 ‚îÇ 446.101 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò; ```. ### Strong Scaling Multithreaded Nonhydrostatic Model. The notable and continuous decrease in efficiencies for the strong scaling nonhydrostatic model is likely caused by the `256^3` grid not sufficiently saturating 32 threads running on 32 CPUs. At the time this benchmark was produced, multithreading for both nonhydrostatic and shallow water models is still an active area of improvement. Please use the appropriate scripts found in [`benchmarks`](https://github.com/CliMA/Oceananigans.jl/tree/main/benchmark) to obtain more recent and hopefully ameliorated benchmark results. ```; Oceananigans v0.58.9; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; EBVERSIONJULIA = 1.6.1; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel; JULIA_LOAD_PATH = :. Multithreading benchmarks; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê; ‚îÇ size ‚îÇ threads ‚îÇ min ‚îÇ median ‚îÇ mean ‚îÇ max ‚îÇ memory ‚îÇ allocs ‚îÇ samples ‚îÇ; ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:28691,benchmark,benchmarks,28691,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,1,['benchmark'],['benchmarks']
Usability," appropriate for; typical applications: we only do it here for illustration purposes. ```@repl checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1))). simulation = Simulation(model, Œît=1, stop_iteration=8). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=IterationInterval(5), prefix=""model_checkpoint""); ```. Again, for illustration purposes of this example, we also add another callback so we can see the iteration; of the simulation. ```@repl checkpointing; show_iteration(sim) = @info ""iteration: $(iteration(sim)); time: $(prettytime(sim.model.clock.time))""; add_callback!(simulation, show_iteration, name=:info, IterationInterval(1)); ```. Now let's run. ```@repl checkpointing; run!(simulation); ```. The default options should provide checkpoint files that are easy to restore from (in most cases).; For more advanced options and features, see [`Checkpointer`](@ref). ## Picking up a simulation from a checkpoint file. Picking up a simulation from a checkpoint requires the original script that was used to generate; the checkpoint data. Change the first instance of [`run!`](@ref) in the script to take `pickup=true`. When `pickup=true` is provided to `run!` then it finds the latest checkpoint file in the current working; directory, loads prognostic fields and their tendencies from file, resets the model clock and iteration,; to the clock time and iteration that the checkpoint corresponds to, and updates the model auxiliary state.; After that, the time-stepping loop. In this simple example, although the simulation run up to iteration 8,; the latest checkpoint is associated with iteration 5. ```@repl checkpointing; simulation.stop_iteration = 12. run!(simulation, pickup=true); ```. Use `pickup=iteration`, where `iteration` is an `Integer`, to pick up from a specific iteration.; Or, use `pickup=filepath`, where `filepath` is a string, to pickup from a specific file located; at `filepath`.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md:2293,simpl,simple,2293,docs/src/model_setup/checkpointing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/checkpointing.md,1,['simpl'],['simple']
Usability," in Anaconda Prompt if you're on Windows. * Connect your repository to the upstream (main project).; ```; git remote add oceananigans https://github.com/CLiMA/Oceananigans.jl.git; ```. * Create the development environment by opening Julia via `julia --project` then; typing in `] instantiate`. This will install all the dependencies in the Project.toml; file. Your development environment is now ready!. * You can test to make sure Oceananigans works by typing in `] test`. (This is equivalent to; `using Pkg; Pkg.test()`.) Doing so will run all the tests (and this can take a while).; Alternatively, you can run only one test script file by providing its name as an environment; variable. For example, to run the tests only from the `test_coriolis.jl` file we call:. ```; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; ```. ## Pull Requests. We follow the [ColPrac guide](https://github.com/SciML/ColPrac) for collaborative practices.; We ask that new contributors read that guide before submitting a pull request. Changes and contributions should be made via GitHub pull requests against the ``main`` branch. When you're done making changes, commit the changes you made. Chris Beams has written a ; [guide](https://chris.beams.io/posts/git-commit/) on how to write good commit messages. When you think your changes are ready to be merged into the main repository, push to your fork; and [submit a pull request](https://github.com/CLiMA/Oceananigans.jl/compare/). **Working on your first Pull Request?** You can learn how from this _free_ video series; [How to Contribute to an Open Source Project on GitHub](https://egghead.io/courses/how-to-contribute-to-an-open-source-project-on-github), Aaron Meurer's [tutorial on the git workflow](https://www.asmeurer.com/git-workflow/), or the guide [‚ÄúHow to Contribute to Open Source""](https://opensource.guide/how-to-contribute/). ## Documentation. Now that you've made your awesome contribution, it's time to tell the world how t",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:8009,guid,guide,8009,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['guid'],['guide']
Usability," simulation = Simulation(model; Œît=0.01, stop_iteration=100); run!(simulation); ```. runs 100 time steps of a two-dimensional turbulence simulation with `128¬≤` [finite volume](https://en.wikipedia.org/wiki/Finite_volume_method) cells; and a fifth-order upwinded [WENO advection scheme](https://en.wikipedia.org/wiki/WENO_methods).; It's quite similar to the [two-dimensional turbulence example](https://clima.github.io/OceananigansDocumentation/stable/generated/two_dimensional_turbulence/). ## Visualization. They say that a [Makie](https://makie.juliaplots.org/stable/) visualization is worth a thousand Unicode characters, so let's plot vorticity,. ```@example cpu; using CairoMakie. u, v, w = model.velocities; Œ∂ = Field(‚àÇx(v) - ‚àÇy(u)); compute!(Œ∂). heatmap(Œ∂, axis=(; aspect=1)); ```. A few more time-steps, and it's starting to get a little diffuse!. ```@example cpu; simulation.stop_iteration += 400; run!(simulation). compute!(Œ∂); heatmap(Œ∂, axis=(; aspect=1)); ```. ## They always cheat with too-simple ""quick"" starts. Fine, we'll re-run this code on the GPU. But we're a little greedy, so we'll also; crank up the resolution, throw in a `TimeStepWizard` to update `simulation.Œît` adaptively,; and add a passive tracer initially concentrated in the center of the domain; which will make for an even prettier figure of the final state:. ```@setup gpu; using CairoMakie; CairoMakie.activate!(type = ""png""); ```. ```@example gpu; using Oceananigans; using CairoMakie. grid = RectilinearGrid(GPU(),; size = (1024, 1024),; x = (-œÄ, œÄ),; y = (-œÄ, œÄ),; topology = (Periodic, Periodic, Flat)). model = NonhydrostaticModel(; grid, advection=WENO(), tracers=:c). Œ¥ = 0.5; c·µ¢(x, y) = exp(-(x^2 + y^2) / 2Œ¥^2); œµ(x, y) = 2rand() - 1; set!(model, u=œµ, v=œµ, c=c·µ¢). simulation = Simulation(model; Œît=1e-3, stop_time=10); conjure_time_step_wizard!(simulation, cfl=0.2, IterationInterval(10)); run!(simulation). u, v, w = model.velocities; Œ∂ = Field(‚àÇx(v) - ‚àÇy(u)); compute!(Œ∂). fig = Figure(size=(1200, 600))",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/quick_start.md:1354,simpl,simple,1354,docs/src/quick_start.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/quick_start.md,1,['simpl'],['simple']
Usability," use `TitleCase` for types, `snake_case` for objects, and always.put.spaces.after.commas. For formatting decisions we loosely follow the [YASGuide](https://github.com/jrevels/YASGuide). It's worth few extra minutes of our time to leave future generations with well-written, readable code. ## What is a ""collaborator"" and how can I become one?. * Collaborators have permissions to review pull requests and status allows a contributor to review pull requests in addition to opening them. Collaborators can also create branches in the main Oceananigans repository. * We ask that new contributors try their hand at forking Oceananigans, and opening and merging a pull request before requesting collaborator status. ## What's a good way to start developing Oceananigans?. * Tackle an existing issue. We keep a list of [good first issues](https://github.com/CLiMA/Oceananigans.jl/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22); that are self-contained and suitable for a newcomer to try and work on. * Try to run Oceananigans and play around with it to simulate your favorite; fluids and ocean physics. If you run into any bugs/problems or find it difficult; to use or understand, please open an issue!. * Write up an example or tutorial on how to do something useful with; Oceananigans, like how to set up a new physical configuration. * Improve documentation or comments if you found something hard to use. * Implement a new feature if you need it to use Oceananigans. If you're interested in working on something, let us know by commenting on; existing issues or by opening a new issue. This is to make sure no one else; is working on the same issue and so we can help and guide you in case there; is anything you need to know beforehand. We also hang out on the #oceananigans channel on Julia Slack, which is a great; place to discuss anything Oceananigans-related, especially contributions! To; join the Julia Slack, go to [https://julialang.org/slack/](https://julialang.org/slack/).; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md:4900,guid,guide,4900,CONTRIBUTING.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md,1,['guid'],['guide']
Usability," volumes or ""cells"".; The first decision we make when setting up a simulation is: on what _grid_ are we going to run our simulation?; The ""grid"" captures the. 1. The geometry of the physical domain;; 2. The way that domain is divided into a mesh of finite volumes;; 3. The machine architecture (CPU, GPU, lots of CPUs or lots of GPUs); and; 4. The precision of floating point numbers (double precision or single precision). We start by making a simple grid that divides a three-dimensional rectangular domain -- ""a box"" -- into evenly-spaced cells,. ```jldoctest grids; using Oceananigans. grid = RectilinearGrid(topology = (Periodic, Periodic, Bounded),; size = (16, 8, 4),; x = (0, 64),; y = (0, 32),; z = (0, 8)). # output; 16√ó8√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 64.0) regularly spaced with Œîx=4.0; ‚îú‚îÄ‚îÄ Periodic y ‚àà [0.0, 32.0) regularly spaced with Œîy=4.0; ‚îî‚îÄ‚îÄ Bounded z ‚àà [0.0, 8.0] regularly spaced with Œîz=2.0; ```. This simple grid. * Has a domain that's ""periodic"" in ``x, y``, but bounded in ``z``.; * Has `16` cells in `x`, `8` cells in `y`, and `4` cells in `z`. That means there are ``16 \times 8 \times 4 = 512`` cells in all.; * Has an `x` dimension that spans from `x=0`, to `x=64`. And `y` spans `y=0` to `y=32`, and `z` spans `z=0` to `z=8`.; * Has cells that are all the same size, dividing the box in 512 that each has dimension ``4 \times 4 \times 2``.; Note that length units are whatever is used to construct the grid, so it's up to the user to make sure that all inputs use consistent units. In building our first grid, we did not specify whether it should be constructed on the [`CPU`](@ref)` or [`GPU`](@ref).; As a result, the grid was constructed by default on the CPU.; Next we build a grid on the _GPU_ that's two-dimensional in ``x, z`` and has variably-spaced cell interfaces in the `z`-direction,. ```jldoctest grids_gpu; architecture = GPU(); z_faces = [0, 1, 3, 6, 10]. grid = RectilinearGrid(arc",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:1318,simpl,simple,1318,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['simpl'],['simple']
Usability,"# Buoyancy model and equations of state. The buoyancy model determines the relationship between tracers and the buoyancy ``b`` in the momentum equation. ## Buoyancy tracer. The simplest buoyancy model uses buoyancy ``b`` itself as a tracer: ``b`` obeys the tracer; conservation equation and is used directly in the momentum equations. ## Seawater buoyancy. For seawater buoyancy is, in general, modeled as a function of conservative temperature; ``T``, absolute salinity ``S``, and depth below the ocean surface ``d`` via; ```math; \begin{equation}; b = - \frac{g}{\rho_0} \rho' \left (T, S, d \right ) \, ,; \label{eq:seawater-buoyancy}; \end{equation}; ```; where ``g`` is gravitational acceleration, ``\rho_0`` is the reference density.; The function ``\rho'(T, S, d)`` in the seawater buoyancy relationship that links conservative temperature,; salinity, and depth to the density perturbation is called the *equation of state*.; Both ``T`` and ``S`` obey the tracer conservation equation. ### Linear equation of state. Buoyancy is determined from a linear equation of state via; ```math; b = g \left ( \alpha T - \beta S \right ) \, ,; ```; where ``g`` is gravitational acceleration, ``\alpha`` is the thermal expansion coefficient,; and ``\beta`` is the haline contraction coefficient. ### Nonlinear equation of state. Buoyancy is determined by the simplified equations of state introduced by [Roquet15TEOS](@citet).; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/buoyancy_and_equations_of_state.md:177,simpl,simplest,177,docs/src/physics/buoyancy_and_equations_of_state.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/buoyancy_and_equations_of_state.md,2,['simpl'],"['simplest', 'simplified']"
Usability,"# Buoyancy models and equations of state. The buoyancy option selects how buoyancy is treated in `NonhydrostaticModel`s and; `HydrostaticFreeSurfaceModel`s (`ShallowWaterModel`s do not have that option given the physics of; the model). There are currently three alternatives:. 1. No buoyancy (and no gravity).; 2. Evolve buoyancy as a tracer.; 3. _Seawater buoyancy_: evolve temperature ``T`` and salinity ``S`` as tracers with a value for the gravitational; acceleration ``g`` and an equation of state of your choosing. ## No buoyancy. To turn off buoyancy (and gravity) you can simply pass `buoyancy = nothing` to the model; constructor. For example to create a `NonhydrostaticModel`:. ```@meta; DocTestSetup = quote; using Oceananigans; end; ```. ```jldoctest buoyancy; julia> grid = RectilinearGrid(size=(8, 8, 8), extent=(1, 1, 1));. julia> model = NonhydrostaticModel(; grid, buoyancy=nothing); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ‚îú‚îÄ‚îÄ grid: 8√ó8√ó8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ timestepper: RungeKutta3TimeStepper; ‚îú‚îÄ‚îÄ advection scheme: Centered reconstruction order 2; ‚îú‚îÄ‚îÄ tracers: (); ‚îú‚îÄ‚îÄ closure: Nothing; ‚îú‚îÄ‚îÄ buoyancy: Nothing; ‚îî‚îÄ‚îÄ coriolis: Nothing; ```. The option `buoyancy = nothing` is the default for [`NonhydrostaticModel`](@ref), so omitting the; `buoyancy` keyword argument from the `NonhydrostaticModel` constructor yields the same:. ```jldoctest buoyancy; julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ‚îú‚îÄ‚îÄ grid: 8√ó8√ó8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ timestepper: RungeKutta3TimeStepper; ‚îú‚îÄ‚îÄ advection scheme: Centered reconstruction order 2; ‚îú‚îÄ‚îÄ tracers: (); ‚îú‚îÄ‚îÄ closure: Nothing; ‚îú‚îÄ‚îÄ buoyancy: Nothing; ‚îî‚îÄ‚îÄ coriolis: Nothing; ```. The same is true for `HydrostaticFreeSurfaceModel`,. ```jldoctest buoyancy; julia> model = HydrostaticFreeSurfaceModel(; grid); Hydro",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/buoyancy_and_equation_of_state.md:580,simpl,simply,580,docs/src/model_setup/buoyancy_and_equation_of_state.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/buoyancy_and_equation_of_state.md,1,['simpl'],['simply']
Usability,"# Contributors Guide. Thank you for considering contributing to Oceananigans! . Feel free to ask us questions and chat with us at any time about any topic at all; by . * [Opening a GitHub issue](https://github.com/CliMA/Oceananigans.jl/issues/new/choose); ; * [Creating a GitHub discussion](https://github.com/CliMA/Oceananigans.jl/discussions/new). * Sending a message to the [#oceananigans channel](https://julialang.slack.com/archives/C01D24C0CAH) on [Julia Slack](https://julialang.org/slack/). We follow the [ColPrac guide](https://github.com/SciML/ColPrac) for collaborative; practices. We ask that new contributors read that guide before submitting a pull request. ## Creating issues. The simplest way to contribute to Oceananigans is to create or comment on issues and discussions. The most useful bug reports:. * Provide an explicit code snippet -- not just a link -- that reproduces the bug in the latest tagged version of Oceananigans. This is sometimes called the [""minimal working example""](https://en.wikipedia.org/wiki/Minimal_working_example). Reducing bug-producing code to a minimal example can dramatically decrease the time it takes to resolve an issue. * Paste the _entire_ error received when running the code snippet, even if it's unbelievably long. * Use triple backticks (```` ``` ````) to enclose code snippets, and other [markdown formatting syntax](https://docs.github.com/en/github/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) to make your issue easy and quick to read. * Report the Oceananigans version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created. Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general. ## But I want to _code_!. * New users help write Oceananigans code and documentation by [forking the Oceanan",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md:522,guid,guide,522,CONTRIBUTING.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md,3,"['guid', 'simpl']","['guide', 'simplest']"
Usability,"# Contributors Guide. Thank you for considering contributions to Oceananigans! We hope this guide; helps you make a contribution. Feel free to ask us questions and chat with us at any time about any topic at all; by:. * [Opening a GitHub issue](https://github.com/CliMA/Oceananigans.jl/issues/new). * [Creating a GitHub discussion](https://github.com/CliMA/Oceananigans.jl/discussions/new). * Sending a message to the [#oceananigans channel](https://julialang.slack.com/archives/C01D24C0CAH) on [Julia Slack](https://julialang.org/slack/). ## Creating issues. The simplest way to contribute to Oceananigans is to create or comment on issues and discussions. The most useful bug reports:. * Provide an explicit code snippet -- not just a link -- that reproduces the bug in the latest tagged version of Oceananigans. This is sometimes called the [""minimal working example""](https://en.wikipedia.org/wiki/Minimal_working_example). Reducing bug-producing code to a minimal example can dramatically decrease the time it takes to resolve an issue. * Paste the _entire_ error received when running the code snippet, even if it's unbelievably long. * Use triple backticks (e.g., ````` ```some_code; and_some_more_code;``` `````) to enclose code snippets, and other [markdown formatting syntax](https://docs.github.com/en/github/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) to make your issue easy and quick to read. * Report the Oceananigans version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created. Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general. ## But I want to _code_!. * New users help write Oceananigans code and documentation by [forking the Oceananigans repository](https://docs.github.com/en/github/collaborating-with-pull-requests/workin",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:92,guid,guide,92,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,2,"['guid', 'simpl']","['guide', 'simplest']"
Usability,"# Gallery. Collection of cool movies!. ## [Deep convection](https://www.youtube.com/watch?v=kpUrxnKKMjI). An idealized simulation of deep convection in the ocean. The simulation employs a resolution of 256x256x128 volumes in; a 2x2x1 km horizontally periodic domain. Heat is sucked out of the ocean surface within a cooling disk of radius 600 m; at a rate of 800 W/m¬≤ which cools the surface water and making it denser. This cold dense water then sinks into the; ocean interior, initiating a convective process that penetrates deep into the ocean. This deep convection process can happen when a cold storm passes through warmer waters, which happens for example in; the Labrador Sea. The video shows the temperature field and the domain is sliced in half so the convection happening under the cooling; disk is clear. [![Watch deep convection in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/surface_temp_3d_00130_halfsize.png)](https://www.youtube.com/watch?v=kpUrxnKKMjI). ## [Free convection](https://www.youtube.com/watch?v=yq4op9h3xcU). An idealized simulation of free convection in the ocean. The simulation employs a resolution of 256x256x256 volumes in; a 100x100x100 m horizontally periodic domain. Heat is sucked out of the ocean surface at a rate of 75 W/m¬≤ which cools; the surface water and making it denser. This cold dense water then sinks into the ocean interior, initiating a; convective process that keeps mixing the upper layer of the ocean. This ""mixed layer"" has a relatively constant; temperature and keeps deepening as the surface is cooled. The video shows the temperature field and the domain is sliced in half. [![Watch free convection in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/free_convection_0956.png)](https://www.youtube.com/watch?v=yq4op9h3xcU). ## [Winds blowing over the ocean](https://www.youtube.com/watch?v=IRncfbvuiy8). An idealized simulation of a strong wind stress acti",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/gallery.md:810,clear,clear,810,docs/src/gallery.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/gallery.md,1,['clear'],['clear']
Usability,"# Number type. Passing `Float64` or `Float32` to the grid constructor causes the grid to store all numbers; with 64-bit or 32-bit floating point precision. !!! note ""Avoiding mixed-precision operations""; When not using `Float64` be careful to not mix different precisions as it could introduce implicit type conversions; which can negatively effect performance. You can pass the number type desires to many constructors to enforce; the type you want: e.g. `RectilinearGrid(CPU(), Float32; size=(16, 16, 16), extent=(1, 1, 1))` and; `ScalarDiffusivity(Float16; Œ∫=1//7, ŒΩ=2//7)`. !!! warning ""Effect of floating point precision on simulation accuracy""; While we run many tests with both `Float32` and `Float64` it is not clear whether `Float32` is precise enough to; provide similar accuracy in all use cases. If accuracy is a concern, stick to `Float64`. We will be actively investigating the possibility of using lower precision floating point numbers such as `Float32`; and `Float16` for fluid dynamics as well as the use of alternative number types such as Posits and Sonums.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/number_type.md:719,clear,clear,719,docs/src/model_setup/number_type.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/number_type.md,1,['clear'],['clear']
Usability,"# Oceananigans.jl. *üåä Fast and friendly fluid dynamics on CPUs and GPUs.*. Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic; and hydrostatic Boussinesq equations on CPUs and GPUs.; It runs on GPUs (wow, fast!), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans is written in Julia by the [Climate Modeling Alliance](https://clima.caltech.edu); and heroic external collaborators. ## Quick install. Oceananigans is a [registered Julia package](https://julialang.org/packages/). So to install it,. 1. [Download Julia](https://julialang.org/downloads/). 2. Launch Julia and type. ```julia; julia> using Pkg. julia> Pkg.add(""Oceananigans""); ```. !!! compat ""Julia 1.9 is required""; Oceananigans requires Julia 1.9 or later. If you're [new to Julia](https://docs.julialang.org/en/v1/manual/getting-started/) and its [wonderful `Pkg` manager](https://docs.julialang.org/en/v1/stdlib/Pkg/), the [Oceananigans wiki](https://github.com/CliMA/Oceananigans.jl/wiki) provides [more detailed installation instructions](https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans). ## The Oceananigans ""knowledge base"". It's _deep_ and includes:. * This documentation, which provides; * example Oceananigans scripts,; * tutorials that describe key Oceananigans objects and functions,; * explanations of Oceananigans finite-volume-based numerical methods,; * details of the dynamical equations solved by Oceananigans models, and; * a library documenting all user-facing Oceananigans objects and functions.; * [Discussions on the Oceananigans github](https://github.com/CliMA/Oceananigans.jl/discussions), covering topics like; * [""Computational science""](https://github.com/CliMA/Oceananigans.jl/discussions/categories/computational-science), or how to science and set up numeric",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md:380,simpl,simple,380,docs/src/index.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md,1,['simpl'],['simple']
Usability,"# Operations and averaging. `Field`s are more than mere vessels for data.; They come equipped with a powerful infrastructure for assembling expression trees that represent; arithmetic and discrete calculus operations.; We also supply a system for computing reductions (averages, integrals, and cumulative integrals) of `Field`s.; This infrastructure can be used to construct initial conditions, set up diagnostic calculations that are performed; and saved to disk while a simulation runs, and also for post-processing. We start by constructing a `CenterField` on a simple grid,. ```jldoctest operations; using Oceananigans. grid = RectilinearGrid(topology = (Periodic, Flat, Bounded),; size = (4, 4),; x = (0, 2œÄ),; z = (-4, 0)). c = CenterField(grid). periodic_but_decaying(x, z) = sin(x) * exp(z); set!(c, periodic_but_decaying). # output; 4√ó1√ó4 Field{Center, Center, Center} on RectilinearGrid on CPU; ‚îú‚îÄ‚îÄ grid: 4√ó1√ó4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3√ó0√ó3 halo; ‚îú‚îÄ‚îÄ boundary conditions: FieldBoundaryConditions; ‚îÇ ‚îî‚îÄ‚îÄ west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; ‚îî‚îÄ‚îÄ data: 10√ó1√ó10 OffsetArray(::Array{Float64, 3}, -2:7, 1:1, -2:7) with eltype Float64 with indices -2:7√ó1:1√ó-2:7; ‚îî‚îÄ‚îÄ max=0.428882, min=-0.428882, mean=1.04083e-17; ```. An `AbstractOperation` (or _operation_ for short) differs from a `Field` in that only represents a computation.; Unlike `Field`s, `AbstractOperation`s do not have any data, and are associated only with minimal memory allocation.; `AbstractOperations` are generated by inflicting `Field`s with ordinary arithmetic expressions,. ```jldoctest operations; two_c = 2 * c. # output; BinaryOperation at (Center, Center, Center); ‚îú‚îÄ‚îÄ grid: 4√ó1√ó4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3√ó0√ó3 halo; ‚îî‚îÄ‚îÄ tree:; * at (Center, Center, Center); ¬†¬† ‚îú‚îÄ‚îÄ 2; ¬†¬† ‚îî‚îÄ‚îÄ 4√ó1√ó4 Field{Center, Center, Center} on RectilinearGrid on CPU; ```. and even by chaining e",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/operations.md:565,simpl,simple,565,docs/src/operations.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/operations.md,1,['simpl'],['simple']
Usability,"# [Grids](@id grids_tutorial). ```@meta; DocTestSetup = quote; using Oceananigans; using CairoMakie; CairoMakie.activate!(type = ""svg""); set_theme!(Theme(fontsize=24)); end; ```. Oceananigans simulates the dynamics of ocean-flavored fluids by solving equations that conserve momentum, mass, and energy on a grid of finite volumes or ""cells"".; The first decision we make when setting up a simulation is: on what _grid_ are we going to run our simulation?; The ""grid"" captures the. 1. The geometry of the physical domain;; 2. The way that domain is divided into a mesh of finite volumes;; 3. The machine architecture (CPU, GPU, lots of CPUs or lots of GPUs); and; 4. The precision of floating point numbers (double precision or single precision). We start by making a simple grid that divides a three-dimensional rectangular domain -- ""a box"" -- into evenly-spaced cells,. ```jldoctest grids; using Oceananigans. grid = RectilinearGrid(topology = (Periodic, Periodic, Bounded),; size = (16, 8, 4),; x = (0, 64),; y = (0, 32),; z = (0, 8)). # output; 16√ó8√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 64.0) regularly spaced with Œîx=4.0; ‚îú‚îÄ‚îÄ Periodic y ‚àà [0.0, 32.0) regularly spaced with Œîy=4.0; ‚îî‚îÄ‚îÄ Bounded z ‚àà [0.0, 8.0] regularly spaced with Œîz=2.0; ```. This simple grid. * Has a domain that's ""periodic"" in ``x, y``, but bounded in ``z``.; * Has `16` cells in `x`, `8` cells in `y`, and `4` cells in `z`. That means there are ``16 \times 8 \times 4 = 512`` cells in all.; * Has an `x` dimension that spans from `x=0`, to `x=64`. And `y` spans `y=0` to `y=32`, and `z` spans `z=0` to `z=8`.; * Has cells that are all the same size, dividing the box in 512 that each has dimension ``4 \times 4 \times 2``.; Note that length units are whatever is used to construct the grid, so it's up to the user to make sure that all inputs use consistent units. In building our first grid, we did not specify whether it should be constructed on the [`CPU`](",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md:766,simpl,simple,766,docs/src/grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/grids.md,1,['simpl'],['simple']
Usability,"# [Simulation tips](@id simulation_tips). Oceananigans attempts to optimize computations as much as possible ""behind the scenes"".; Yet Oceananigans' flexibility places some responsibility on users to ensure high performance simulations,; especially for complex setups with user-defined forcing functions, boundary condition functions, and diagnostics.; Furthermore, in case of more complex GPU runs, some details could; sometimes prevent your simulation from running altogether. While Julia knowledge is obviously; desirable here, a user that is unfamiliar with Julia can get away with efficient simulations by; learning a few rules of thumb. It is nonetheless recommended that users go through Julia's; [performance tips](https://docs.julialang.org/en/v1/manual/performance-tips/), which contains more; in-depth explanations of some of the aspects discussed here. ## General (CPU/GPU) simulation tips. ### Avoid global variables whenever possible. In general using a [global; variable](https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Global-Scope) (which can be; loosely defined as a variable defined in the main script) inside functions slows down the code. One; way to circumvent this is to always [use local variables or pass them as arguments to; functions](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). This; helps the compiler optimize the code. Another way around this is to [define global variables as constants whenever; possible](https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables). One; thing to keep in mind when doing this is that when a `const` is defined, its value can't be changed; until you restart the Julia session. So this latter approach is good for production-ready code, but; may be undesirable in the early stages of development while you still have to change the parameters; of the simulation for exploration. It is especially important to avoid global variables in functions that are meant t",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:612,learn,learning,612,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['learn'],['learning']
Usability,", -2:19) with eltype Float64 with indices -2:19√ó-2:19√ó-2:19; ‚îî‚îÄ‚îÄ max=0.0, min=0.0, mean=0.0. julia> model.tracers.c; 16√ó16√ó16 Field{Center, Center, Center} on RectilinearGrid on CPU; ‚îú‚îÄ‚îÄ grid: 16√ó16√ó16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3√ó3√ó3 halo; ‚îú‚îÄ‚îÄ boundary conditions: FieldBoundaryConditions; ‚îÇ ‚îî‚îÄ‚îÄ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Gradient, top: Value, immersed: ZeroFlux; ‚îî‚îÄ‚îÄ data: 22√ó22√ó22 OffsetArray(::Array{Float64, 3}, -2:19, -2:19, -2:19) with eltype Float64 with indices -2:19√ó-2:19√ó-2:19; ‚îî‚îÄ‚îÄ max=0.0, min=0.0, mean=0.0; ```. Notice that the specified non-default boundary conditions have been applied at; top and bottom of both `model.velocities.u` and `model.tracers.c`. ## Immersed boundary conditions. Immersed boundary conditions are supported experimentally. A no-slip boundary condition is specified; with. ```@meta; DocTestFilters = r""‚îå Warning:[\s\S]*\.jl:[0-9]*""; ```. ```julia; # Generate a simple ImmersedBoundaryGrid; hill(x, y) = 0.1 + 0.1 * exp(-x^2 - y^2); underlying_grid = RectilinearGrid(size=(32, 32, 16), x=(-3, 3), y=(-3, 3), z=(0, 1), topology=(Periodic, Periodic, Bounded)); grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(hill)). # Create a no-slip boundary condition for velocity fields.; # Note that the no-slip boundary condition is _only_ applied on immersed boundaries.; velocity_bcs = FieldBoundaryConditions(immersed=ValueBoundaryCondition(0)); model = NonhydrostaticModel(; grid, boundary_conditions=(u=velocity_bcs, v=velocity_bcs, w=velocity_bcs)). # Insepct the boundary condition on the vertical velocity:; model.velocities.w.boundary_conditions.immersed. # output; ImmersedBoundaryCondition:; ‚îú‚îÄ‚îÄ west: ValueBoundaryCondition: 0.0; ‚îú‚îÄ‚îÄ east: ValueBoundaryCondition: 0.0; ‚îú‚îÄ‚îÄ south: ValueBoundaryCondition: 0.0; ‚îú‚îÄ‚îÄ north: ValueBoundaryCondition: 0.0; ‚îú‚îÄ‚îÄ bottom: Nothing; ‚îî‚îÄ‚îÄ top: Nothing; ```. !!! warning ""`NonhydrostaticModel` on `ImmersedBoundaryGrid`""; Th",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md:19768,simpl,simple,19768,docs/src/model_setup/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md,1,['simpl'],['simple']
Usability,", t) G(\boldsymbol{x} - \boldsymbol{x}^\prime, t - \tau) \, \mathrm{d}\boldsymbol{x}^\prime \, \mathrm{d} \tau \, ,; ```; as described by [Leonard75](@citet) who introduced the general filtering formalism. The ``\overline{v_i^\prime v_j^\prime}`` terms are now components of what is called the sub-grid scale (SGS) stress; tensor ``\tau^\text{SGS}_{ij}``, which looks the same as the Reynolds stress tensor so we will drop the SGS superscript. It is probably important to note that the large eddy simulation filtering operation does not satisfy the properties; of a Reynolds operator (¬ß2.1) [sagaut06](@cite) and that in general, the filtered residual is not zero:; ``\overline{\boldsymbol{v}^\prime(\boldsymbol{x}, t)} \ne 0``. ¬ß13.2 of [Pope00](@citet) lists a number of popular choices for the filter function ``G``. For practical reasons we; simply employ the box kernel; ```math; \begin{equation}; \label{eq:box-kernel}; G_\Delta = G(\boldsymbol{x}, t) = \frac{1}{\Delta} H \left( \frac{1}{2}\Delta - |\boldsymbol{x}| \right) \delta(t - t_n) \, ,; \end{equation}; ```; where ``H`` is the Heaviside function, ``\Delta`` is the grid spacing, and ``t_n`` is the current time step. With; \eqref{eq:box-kernel} we get back the averaging operator originally used by [Deardorff70](@citet); ```math; \overline{\boldsymbol{v}(x, y, z, t)} =; \frac{1}{\Delta x \Delta y \Delta z}; \int_{x - \frac{1}{2}\Delta x}^{x + \frac{1}{2}\Delta x}; \int_{y - \frac{1}{2}\Delta y}^{y + \frac{1}{2}\Delta y}; \int_{z - \frac{1}{2}\Delta z}^{z + \frac{1}{2}\Delta z}; \boldsymbol{v}(\xi, \eta, \zeta, t) \, \mathrm{d} \xi \, \mathrm{d} \eta \, \mathrm{d} \zeta \, ,; ```; which if evaluated at the cell centers just returns the cell averages we already compute in the finite volume method. ## Smagorinsky-Lilly model. [Smagorinsky63](@citet) estimated the eddy viscosity ``\nu_e`` via a characteristic length scale ``\Delta`` times a velocity; scale given by ``\Delta |\overline{S}|`` where ``|\overline{S}| = \sqrt{2\o",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md:1835,simpl,simply,1835,docs/src/numerical_implementation/large_eddy_simulation.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/large_eddy_simulation.md,1,['simpl'],['simply']
Usability,"2Fjuliapkgstats.com%2Fapi%2Fv1%2Ftotal_downloads%2FOceananigans&query=total_requests&&label=Total%20Downloads&style=flat-square"">; </a>; </p>. <!-- CI/CD badges -->; <p align=""center"">; <a href=""https://buildkite.com/clima/oceananigans"">; <img alt=""Buildkite CPU+GPU build status"" src=""https://img.shields.io/buildkite/4d921fc17b95341ea5477fb62df0e6d9364b61b154e050a123/main?logo=buildkite&label=Buildkite%20CPU%2BGPU&style=flat-square"">; </a>; <a href=""https://hub.docker.com/r/aliramadhan/oceananigans"">; <img alt=""Docker build status"" src=""https://img.shields.io/docker/cloud/build/aliramadhan/oceananigans?label=Docker&logo=docker&logoColor=white&style=flat-square"">; </a>; </p>. Oceananigans is a fast, friendly, flexible software package for finite volume simulations of the nonhydrostatic; and hydrostatic Boussinesq equations on CPUs and GPUs.; It runs on GPUs (wow, [fast!](http://arxiv.org/abs/2309.06662)), though we believe Oceananigans makes the biggest waves; with its ultra-flexible user interface that makes simple simulations easy, and complex, creative simulations possible. Oceananigans.jl is developed by the [Climate Modeling Alliance](https://clima.caltech.edu) and heroic external collaborators. ## Contents. - [Contents](#contents); - [Installation instructions](#installation-instructions); - [Running your first model](#running-your-first-model); - [The Oceananigans knowledge base](#the-oceananigans-knowledge-base); - [Citing](#citing); - [Contributing](#contributing); - [Movies](#movies); - [Deep convection](#deep-convection); - [Free convection](#free-convection); - [Winds blowing over the ocean](#winds-blowing-over-the-ocean); - [Free convection with wind stress](#free-convection-with-wind-stress); - [Performance benchmarks](#performance-benchmarks). ## Installation instructions. Oceananigans is a [registered Julia package](https://julialang.org/packages/). So to install it,. 1. [Download Julia](https://julialang.org/downloads/) (version 1.9 or later). 2. Laun",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:3651,simpl,simple,3651,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['simpl'],['simple']
Usability,"=; \frac{1}{4} \text{Re} \left\lbrace; \omega_{4N_1}^{-k} \omega_{4N_2}^{-k}; \left( \tilde{X} - M_1 M_2 \tilde{X}^{--} \right); - \mathrm{i} \left( M_1 \tilde{X}^{-+} + M_2 \tilde{X}^{+-} \right); \right\rbrace \, ,; ```; where ``\tilde{X} = \text{IFFT}(X)`` here, ``\tilde{X}^{-+}`` is indexed in reverse along the first dimension,; ``\tilde{X}^{-+}`` along the second dimension, and ``\tilde{X}^{--}`` along both. ``M_1`` and ``M_2`` are masks of lengths; ``N_1`` and ``N_2`` respectively, both containing ones except at the first element where ``M_0 = 0``. Afterwards, the inverse; permutation of \eqref{eq:permutation} must be applied. Due to the extra steps involved in calculating the cosine transform in 2D, running with two ; wall-bounded dimensions typically slows the model down by a factor of 2. Switching to the FACR ; algorithm may help here as a 2D cosine transform won't be necessary anymore. ## Iterative Solvers. For problems with irregular grids the eigenvectors of the discrete Poisson operator are no longer simple Fourier; series sines and cosines. This means discrete Fast Fourier Transforms can't be used to generate the projection ; of the equation right hand side onto eigenvectors. So an eigenvector based approach to solving; the Poisson equation is not computationally efficient. For problems with grids that are non uniform in multiple directions, we use instead a pre-conditioned conjugate; gradient iterative solver. Such cases include curvilinear grids on the sphere and also telescoping cartesian; grids that stretch along more than one dimension. There are two forms of the pressure operator in this approach.; One is rigid lid form and one is an implicit free-surface form. ### Rigid lid pressure operator. The rigid lid operator is based on the same continuous form as is used in the Direct Method; solver. ### Implicit free surface pressure operator. The implicit free surface solver solves for the free-surface, ``\eta(x, y, t)``, in the vertically; integrated ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md:11245,simpl,simple,11245,docs/src/numerical_implementation/elliptic_solvers.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/elliptic_solvers.md,1,['simpl'],['simple']
Usability,"agrangian particle; representing a microbe in an agent-based model, then you can create your own custom particle type; and pass a `StructArray` to the `LagrangianParticles` constructor. ```jldoctest particles; using Oceananigans; using StructArrays. struct LagrangianMicrobe{T, S, D}; x :: T; y :: T; z :: T; species :: S; dna :: D; end. Nparticles = 3. x‚ÇÄ = zeros(Nparticles). y‚ÇÄ = rand(Nparticles). z‚ÇÄ = -0.5 * ones(Nparticles). species = [:rock, :paper, :scissors]. dna = [""TATACCCC"", ""CCTAGGAC"", ""CGATTTAA""]. particles = StructArray{LagrangianMicrobe}((x‚ÇÄ, y‚ÇÄ, z‚ÇÄ, species, dna));. lagrangian_particles = LagrangianParticles(particles). # output; 3 LagrangianParticles with eltype LagrangianMicrobe:; ‚îú‚îÄ‚îÄ 5 properties: (:x, :y, :z, :species, :dna); ‚îú‚îÄ‚îÄ particle-wall restitution coefficient: 1.0; ‚îú‚îÄ‚îÄ 0 tracked fields: (); ‚îî‚îÄ‚îÄ dynamics: no_dynamics; ```. !!! warn ""Custom properties on GPUs""; Not all data types can be passed to GPU kernels. If you intend to advect particles on the GPU make sure; particle properties consist of only simple data types. The symbols and strings in this example won't; work on the GPU. ## Writing particle properties to disk. Particle properties can be written to disk using JLD2 or NetCDF. When writing to JLD2 you can pass `model.particles` as part of the named tuple of outputs. ```@setup particles; using Oceananigans; grid = RectilinearGrid(size=(10, 10, 10), extent=(1, 1, 1)); Nparticles = 3; x‚ÇÄ = zeros(Nparticles); y‚ÇÄ = rand(Nparticles); z‚ÇÄ = -0.5 * ones(Nparticles); lagrangian_particles = LagrangianParticles(x=x‚ÇÄ, y=y‚ÇÄ, z=z‚ÇÄ); model = NonhydrostaticModel(; grid, particles=lagrangian_particles); ```. ```@example particles; JLD2OutputWriter(model, (; particles=model.particles), filename=""particles"", schedule=TimeInterval(15)); ```. When writing to NetCDF you should write particles to a separate file as the NetCDF dimensions differ for; particle trajectories. You can just pass `model.particles` straight to `NetCDFOutputWriter`:. ```@example particle",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/lagrangian_particles.md:2786,simpl,simple,2786,docs/src/model_setup/lagrangian_particles.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/lagrangian_particles.md,1,['simpl'],['simple']
Usability,"by opening Julia via `julia --project` then; typing in `] instantiate`. This will install all the dependencies in the Project.toml; file. Your development environment is now ready!. * You can test to make sure Oceananigans works by typing in `] test`. (This is equivalent to; `using Pkg; Pkg.test()`.) Doing so will run all the tests (and this can take a while).; Alternatively, you can run only one test script file by providing its name as an environment; variable. For example, to run the tests only from the `test_coriolis.jl` file we call:. ```; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; ```. ## Pull Requests. We follow the [ColPrac guide](https://github.com/SciML/ColPrac) for collaborative practices.; We ask that new contributors read that guide before submitting a pull request. Changes and contributions should be made via GitHub pull requests against the ``main`` branch. When you're done making changes, commit the changes you made. Chris Beams has written a ; [guide](https://chris.beams.io/posts/git-commit/) on how to write good commit messages. When you think your changes are ready to be merged into the main repository, push to your fork; and [submit a pull request](https://github.com/CLiMA/Oceananigans.jl/compare/). **Working on your first Pull Request?** You can learn how from this _free_ video series; [How to Contribute to an Open Source Project on GitHub](https://egghead.io/courses/how-to-contribute-to-an-open-source-project-on-github), Aaron Meurer's [tutorial on the git workflow](https://www.asmeurer.com/git-workflow/), or the guide [‚ÄúHow to Contribute to Open Source""](https://opensource.guide/how-to-contribute/). ## Documentation. Now that you've made your awesome contribution, it's time to tell the world how to use it.; Writing documentation strings is really important to make sure others use your functionality; properly. Didn't write new functions? That's fine, but be sure that the documentation for; the code you touched is sti",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:8235,guid,guide,8235,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['guid'],['guide']
Usability,"calling; the function. The Julia compiler automatically makes some calls as to what functions it should or; shouldn't inline, but you can force a function to be inlined by including the macro `@inline` before; its definition. This is more suited for small functions that are called often. Here's an example of; an implementation of the Heaviside function that forces it to be inlined:. ```julia; @inline heaviside(x) = ifelse(x < 0, zero(x), one(x)); ```. In practice it's hard to say whether inlining a function will bring runtime benefits _with; certainty_, since Julia and KernelAbstractions.jl (needed for GPU runs) already inline some; functions automatically. However, it is generally a good idea to at least investigate this aspect in; your code as the benefits can potentially be significant. ## GPU simulation tips. Running on GPUs can be very different from running on CPUs. Oceananigans makes most of the necessary; changes in the background, so that for very simple simulations changing between CPUs and GPUs is; just a matter of changing the `architecture` argument in the model from `CPU()` to `GPU()`. However,; for more complex simulations some care needs to be taken on the part of the user. While knowledge of; GPU computing (and Julia) is again desirable, an inexperienced user can also achieve high efficiency; in GPU simulations by following a few simple principles. ### Global variables that need to be used in GPU computations need to be defined as constants or passed as parameters. Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation; will crash. This includes any variables that are referenced as global variables in functions; used for forcing of boundary conditions. For example,. ```julia; T‚ÇÄ = 20 # ·µíC; surface_temperature(x, y, t) = T‚ÇÄ * sin(2œÄ / 86400 * t); T_bcs = FieldBoundaryConditions(bottom = GradientBoundaryCondition(surface_temperature)); ```. will throw an error if run on the GPU (and will run more slowly than ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:3586,simpl,simple,3586,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['simpl'],['simple']
Usability,"clone https://github.com/your-user-name/Oceananigans.jl.git; ```. * Navigate to that folder in the terminal or in Anaconda Prompt if you're on Windows. * Connect your repository to the upstream (main project).; ```; git remote add oceananigans https://github.com/CLiMA/Oceananigans.jl.git; ```. * Create the development environment by opening Julia via `julia --project` then; typing in `] instantiate`. This will install all the dependencies in the Project.toml; file. Your development environment is now ready!. * You can test to make sure Oceananigans works by typing in `] test`. (This is equivalent to; `using Pkg; Pkg.test()`.) Doing so will run all the tests (and this can take a while).; Alternatively, you can run only one test script file by providing its name as an environment; variable. For example, to run the tests only from the `test_coriolis.jl` file we call:. ```; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; ```. ## Pull Requests. We follow the [ColPrac guide](https://github.com/SciML/ColPrac) for collaborative practices.; We ask that new contributors read that guide before submitting a pull request. Changes and contributions should be made via GitHub pull requests against the ``main`` branch. When you're done making changes, commit the changes you made. Chris Beams has written a ; [guide](https://chris.beams.io/posts/git-commit/) on how to write good commit messages. When you think your changes are ready to be merged into the main repository, push to your fork; and [submit a pull request](https://github.com/CLiMA/Oceananigans.jl/compare/). **Working on your first Pull Request?** You can learn how from this _free_ video series; [How to Contribute to an Open Source Project on GitHub](https://egghead.io/courses/how-to-contribute-to-an-open-source-project-on-github), Aaron Meurer's [tutorial on the git workflow](https://www.asmeurer.com/git-workflow/), or the guide [‚ÄúHow to Contribute to Open Source""](https://opensource.guide/how-to-con",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:7899,guid,guide,7899,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['guid'],['guide']
Usability,"e for as many diagnostics as you can, you minimize the memory requirements of your; calculations by reusing the same chunk of memory. Have a look at an; [example for how to create scratch space](https://github.com/CliMA/LESbrary.jl/blob/cf31b0ec20219d5ad698af334811d448c27213b0/examples/three_layer_ constant_fluxes.jl#L380-L383) and how it can be; [used in calculations](https://github.com/CliMA/LESbrary.jl/blob/cf31b0ec20219d5ad698af334811d448c27213b0/src/TurbulenceStatistics/first_through_third_order.jl#L109-L112). ### Arrays in GPUs are usually different from arrays in CPUs. Oceananigans.jl uses [`CUDA.CuArray`](https://cuda.juliagpu.org/stable/usage/array/) to store ; data for GPU computations. One limitation of `CuArray`s compared to the `Array`s used for ; CPU computations is that `CuArray` elements in general cannot be accessed outside kernels; launched through CUDA.jl or KernelAbstractions.jl. (You can learn more about GPU kernels ; [here](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#kernels) and ; [here](https://cuda.juliagpu.org/stable/usage/overview/#Kernel-programming-with-@cuda).); Doing so requires individual elements to be copied from or to the GPU for processing,; which is very slow and can result in huge slowdowns. To avoid such unintentional slowdowns,; Oceananigans.jl disables CUDA scalar indexing by default. See the; [scalar indexing](https://juliagpu.github.io/CUDA.jl/dev/usage/workflow/#UsageWorkflowScalar); section of the CUDA.jl documentation for more information on scalar indexing. For example, if can be difficult to just view a `CuArray` since Julia needs to access ; its elements to do that. Consider the example below:. ```julia; julia> using Oceananigans, Adapt. julia> grid = RectilinearGrid(GPU(); size=(1, 1, 1), extent=(1, 1, 1), halo=(1, 1, 1)); 1√ó1√ó1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 1.0) regularly spaced with Œîx=1.0; ‚îú‚îÄ‚îÄ Periodic y ‚àà [0.0, 1.0) regula",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:10841,guid,guide,10841,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['guid'],['guide']
Usability,"e space of divergenece free velocity by applying; ```math; \begin{equation}; \label{eq:pressure_correction_step}; \boldsymbol{u}^{n+1} = \boldsymbol{u}^\star - \Delta t\boldsymbol{\nabla}p^{n+1},; \end{equation}; ```; but we have changed ``p^{n+1}`` to ``\phi`` and ``\boldsymbol{u}^\star`` to ``\tilde{\boldsymbol{u}}^\star``; so for ``\boldsymbol{\nabla}\phi \big |_{\partial\Omega} = 0`` the modified predictor velocity must; equal the corrected velocity on the boundary. For simple open boundary conditions such as no penetration or a straight forward prescription of; a known velocity at ``t^{n+1}`` this is simple to implement as we just set the boundary condition; on the predictor velocity and don't change it after the correction. But some open boundary methods; calculate the boundary value based on the interior solution. As a simple example, if we wanted to ; set the wall normal veloicty gradient to zero at the west boundary then we would set the boundary ; point to; ```math; \begin{equation}; \label{eq:zero_wall_normal_velocity_gradient}; u^\star_{1jk} \approx u^\star_{3jk} + (u^\star_{2jk} - u^\star_{jk4}) / 2 + \mathcal{O}(\Delta x^2),; \end{equation}; ```; but we then pressure correct the interior so a new ``\mathcal{O}(\Delta t)`` error is introduced as; ```math; \begin{equation}; \begin{align}; u^{n+1}_{1jk} &\approx u^{n+1}_{3jk} + (u^{n+1}_{2jk} - u^{n+1}_{jk4}) / 2 + \mathcal{O}(\Delta x^2),\\; &= u^\star_{1jk} - \Delta t \left(\boldsymbol{\nabla}p^{n+1}_{3jk} + (\boldsymbol{\nabla}p^{n+1}_{2jk} - \boldsymbol{\nabla}p^{n+1}_{4jk}) / 2\right) + \mathcal{O}(\Delta x^2),\\; &\approx u^\star_{1jk} + \mathcal{O}(\Delta x^2) + \mathcal{O}(\Delta t).; \end{align}; \end{equation}; ```; This is prefered to a divergent interior solution as open boundary conditions (except no penetration); are typlically already unphysical and only used in an attempt to allow information to enter or exit; the domain. Open boundary conditions are represented by the [`Open`](@ref) type.",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md:11144,simpl,simple,11144,docs/src/numerical_implementation/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md,1,['simpl'],['simple']
Usability,"e to a minimal example can dramatically decrease the time it takes to resolve an issue. * Paste the _entire_ error received when running the code snippet, even if it's unbelievably long. * Use triple backticks (```` ``` ````) to enclose code snippets, and other [markdown formatting syntax](https://docs.github.com/en/github/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) to make your issue easy and quick to read. * Report the Oceananigans version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created. Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general. ## But I want to _code_!. * New users help write Oceananigans code and documentation by [forking the Oceananigans repository](https://docs.github.com/en/github/collaborating-with-pull-requests/working-with-forks), [using git](https://guides.github.com/introduction/git-handbook/) to edit code and docs, and then creating a [pull request](https://docs.github.com/en/github/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork). Pull requests are reviewed by Oceananigans collaborators. * A pull request can be merged once it is reviewed and approved by collaborators. If the pull request author has write access, they have the responsibility of merging their pull request. Otherwise, Oceananigans.jl collaborators will execute the merge with permission from the pull request author. * Note: for small or minor changes (such as fixing a typo in documentation), the [GitHub editor](https://docs.github.com/en/github/managing-files-in-a-repository/managing-files-on-github/editing-files-in-your-repository) is super useful for forking and opening a pull request with a single click. * Write your code with love and care. In particul",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md:2127,guid,guides,2127,CONTRIBUTING.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/CONTRIBUTING.md,1,['guid'],['guides']
Usability,"ecrease the time it takes to resolve an issue. * Paste the _entire_ error received when running the code snippet, even if it's unbelievably long. * Use triple backticks (e.g., ````` ```some_code; and_some_more_code;``` `````) to enclose code snippets, and other [markdown formatting syntax](https://docs.github.com/en/github/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) to make your issue easy and quick to read. * Report the Oceananigans version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created. Discussions are recommended for asking questions about (for example) the user interface, implementation details, science, and life in general. ## But I want to _code_!. * New users help write Oceananigans code and documentation by [forking the Oceananigans repository](https://docs.github.com/en/github/collaborating-with-pull-requests/working-with-forks), [using git](https://guides.github.com/introduction/git-handbook/) to edit code and docs, and then creating a [pull request](https://docs.github.com/en/github/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork). Pull requests are reviewed by Oceananigans collaborators. * A pull request can be merged once it is reviewed and approved by collaborators. If the pull request author has write access, they have the responsibility of merging their pull request. Otherwise, Oceananigans.jl collaborators will execute the merge with permission from the pull request author. * Note: for small or minor changes (such as fixing a typo in documentation), the [GitHub editor](https://docs.github.com/en/github/managing-files-in-a-repository/managing-files-on-github/editing-files-in-your-repository) is super useful for forking and opening a pull request with a single click. * Write your code with love and care. In particul",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:2036,guid,guides,2036,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['guid'],['guides']
Usability,"g; Pkg.test()""; ```. ## Pull Requests. We follow the [ColPrac guide](https://github.com/SciML/ColPrac) for collaborative practices.; We ask that new contributors read that guide before submitting a pull request. Changes and contributions should be made via GitHub pull requests against the ``main`` branch. When you're done making changes, commit the changes you made. Chris Beams has written a ; [guide](https://chris.beams.io/posts/git-commit/) on how to write good commit messages. When you think your changes are ready to be merged into the main repository, push to your fork; and [submit a pull request](https://github.com/CLiMA/Oceananigans.jl/compare/). **Working on your first Pull Request?** You can learn how from this _free_ video series; [How to Contribute to an Open Source Project on GitHub](https://egghead.io/courses/how-to-contribute-to-an-open-source-project-on-github), Aaron Meurer's [tutorial on the git workflow](https://www.asmeurer.com/git-workflow/), or the guide [‚ÄúHow to Contribute to Open Source""](https://opensource.guide/how-to-contribute/). ## Documentation. Now that you've made your awesome contribution, it's time to tell the world how to use it.; Writing documentation strings is really important to make sure others use your functionality; properly. Didn't write new functions? That's fine, but be sure that the documentation for; the code you touched is still in great shape. It is not uncommon to find some strange wording; or clarification that you can take care of while you are here. You can preview how the Documentation will look like after merging by building the documentation ; locally. From the main directory of your local repository call. ```; julia --project=docs/ -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'; ```. to instantiate the documentation environment and then. ```; JULIA_DEBUG=Documenter julia --project=docs/ docs/make.jl; ```. If the documentation built is successful, you can open `docs/build/index.html` in yo",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:8820,guid,guide,8820,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['guid'],['guide']
Usability,"hance the spring phytoplankton bloom](https://doi.org/10.3389/fmars.2022.825027), _Frontiers in Marine Sciences_, **9**, 825027. DOI: [10.3389/fmars.2022.825027](https://doi.org/10.3389/fmars.2022.825027). 1. Chor, T., Wenegrat, J. O., and Taylor, J. (2022). [Insights into the mixing efficiency of submesoscale Centrifugal-Symmetric instabilities.](https://doi.org/10.1175/JPO-D-21-0259.1), _Journal of Physical Oceanography_, **52(10)**, 2273-2287. DOI: [10.1175/JPO-D-21-0259.1](https://doi.org/10.1175/JPO-D-21-0259.1). 1. Bire, S., Kang, W., Ramadhan, A., Campin, J.-M., and Marshall, J. (2022). [Exploring ocean circulation on icy moons heated from below.](https://doi.org/10.1029/2021JE007025), _Journal of Geophysical Research: Planets_, **127**, e2021JE007025. DOI: [10.1029/2021JE007025](https://doi.org/10.1029/2021JE007025). 1. Rackauckas, C., Ma, Y., Martensen, J., Warner, C., Zubov, K., Supekar, R., Skinner, D., Ramadhan, A., and Edelman, A. (2021) [Universal differential equations for scientific machine learning](https://doi.org/10.48550/arXiv.2001.04385), _arXiv_, arXiv.2001.04385. DOI: [10.48550/arXiv.2001.04385](https://doi.org/10.48550/arXiv.2001.04385). 1. Coakley, S., Miles, T. N., Glenn, S., and Lim, H. S. (2021). [Observation-Large eddy simulation comparison of ocean mixing under Typhoon Soulik (2018)](https://doi.org/10.23919/OCEANS44145.2021.9705670), _OCEANS 2021: San Diego ‚Äì Porto, 2021_, pp. 1-7. DOI: [10.23919/OCEANS44145.2021.9705670](https://doi.org/10.23919/OCEANS44145.2021.9705670). 1. Arnscheidt, C. W., Marshall, J., Dutrieux, P., Rye, C. D., and Ramadhan, A. (2021). [On the settling depth of meltwater escaping from beneath Antarctic ice shelves](https://doi.org/10.1175/JPO-D-20-0286.1), _Journal of Physical Oceanography_, **51(7)**, 2257‚Äì2270. DOI: [10.1175/JPO-D-20-0178.1](https://doi.org/10.1175/JPO-D-20-0286.1). 1. Wagner, G. L., Chini, G. P., Ramadhan, A., Gallet, B., and Ferrari, R. (2021). [Near-inertial waves and turbulence driven by the",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md:10834,learn,learning,10834,docs/src/index.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/index.md,1,['learn'],['learning']
Usability,"he completion of; a timestep. The other options are `callsite = TendencyCallsite()` that executes the callback; after the tendencies are computed but _before_ taking a timestep and `callsite = UpdateStateCallsite()`; that executes the callback within `update_state!`, after auxiliary variables have been computed; (for multi-stage time-steppers, `update_state!` may be called multiple times per timestep). As an example of a callback with `callsite = TendencyCallsite()` , we show below how we can; manually add to the tendency field of one of the velocity components. Here we've chosen; the `:u` field using parameters:. ```@example checkpointing; using Oceananigans. model = NonhydrostaticModel(grid=RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))). simulation = Simulation(model, Œît=1, stop_iteration=10). function modify_tendency!(model, params); model.timestepper.G‚Åø[params.c] .+= params.Œ¥; return nothing; end. simulation.callbacks[:modify_u] = Callback(modify_tendency!, IterationInterval(1),; callsite = TendencyCallsite(),; parameters = (c = :u, Œ¥ = 1)). run!(simulation); ```. Above there is no forcing at all, but due to the callback the ``u``-velocity is increased. ```@example checkpointing; @info model.velocities.u; ```. !!! note ""Example only for illustration purposes""; The above is a redundant example since it could be implemented better with a simple forcing function.; We include it here though for illustration purposes of how one can use callbacks. ## Functions. Callback functions can only take one or two parameters `sim` - a simulation, or `model` for state callbacks, and optionally may also accept a NamedTuple of parameters. ## Scheduling. The time that callbacks are called at are specified by schedule functions which can be:; - [`IterationInterval`](@ref) : runs every `n` iterations; - [`TimeInterval`](@ref) : runs every `n`s of model run time; - [`SpecifiedTimes`](@ref) : runs at the specified times; - [`WallTimeInterval`](@ref) : runs every `n`s of wall time; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/callbacks.md:2474,simpl,simple,2474,docs/src/model_setup/callbacks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/callbacks.md,1,['simpl'],['simple']
Usability,"herefore, are not present in the resolved velocity field ``\boldsymbol{v}``, and only the ; steady, averaged effect of surface waves that manifests over several or more wave oscillations ; are modeled. When surface waves are included, the resolved velocity field ``\boldsymbol{v}`` is the ; Lagrangian-mean velocity field. The Lagrangian-mean velocity field at a particular location ; ``(x, y, z)`` is average velocity of a fluid particle whose average position is ``(x, y, z)`` ; at time ``t``. The average position of a fluid particle ``\boldsymbol{\xi}(t) = (\xi, \eta, \zeta)`` ; is thus governed by; ```math; \partial_t \boldsymbol{\xi} + \boldsymbol{v}(\boldsymbol{\xi}, t) \boldsymbol{\cdot} \boldsymbol{\nabla} \boldsymbol{\xi} = \boldsymbol{v}(\boldsymbol{\xi}, t) \, ,; ```; which is the same relationship that holds when surface waves are not present and ``\boldsymbol{v}`` ; ceases to be an averaged velocity field. The simplicity of the governing equations for Lagrangian-mean ; momentum is the main reason we use a Lagrangian-mean formulation in Oceananigans.jl, rather ; than an Eulerian-mean formulation: for example, the tracer conservation equation is unchanged ; by the inclusion of surface wave effects. Moreover, because the effect of surface waves manifests ; either as a bulk forcing of Lagrangian-mean momentum or as a modification to the effective background ; rotation rate of the interior fluid similar to any bulk forcing or Coriolis force, we do not ; explicitly include the effects of surface waves in turbulence closures that model the effects ; of subgrid turbulence. More specifically, the effect of steady surface waves does not effect ; the conservation of Lagrangian-mean turbulent kinetic energy. The Lagrangian-mean velocity field ``\boldsymbol{v}`` contrasts with the Eulerian-mean velocity ; field ``\boldsymbol{v}^E``, which is the fluid velocity averaged at the fixed Eulerian position ; ``(x, y, z)``. The surface wave Stokes drift field supplied by the use",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/surface_gravity_waves.md:1670,simpl,simplicity,1670,docs/src/physics/surface_gravity_waves.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/surface_gravity_waves.md,1,['simpl'],['simplicity']
Usability,"ial coordinates that vary along the boundary:; * `f(y, z, t)` on `x`-boundaries;; * `f(x, z, t)` on `y`-boundaries;; * `f(x, y, t)` on `z`-boundaries.; Alternative function signatures are specified by keyword arguments to; `BoundaryCondition`, as illustrated in subsequent examples. ### 4. Spatially- and temporally-varying flux with parameters. Boundary condition functions may be 'parameterized',. ```jldoctest; julia> @inline wind_stress(x, y, t, p) = - p.œÑ * cos(p.k * x) * cos(p.œâ * t); # function with parameters. julia> top_u_bc = FluxBoundaryCondition(wind_stress, parameters=(k=4œÄ, œâ=3.0, œÑ=1e-4)); FluxBoundaryCondition: ContinuousBoundaryFunction wind_stress at (Nothing, Nothing, Nothing); ```. !!! info ""Boundary condition functions with parameters""; The keyword argument `parameters` above specifies that `wind_stress` is called; with the signature `wind_stress(x, y, t, parameters)`. In principle, `parameters` is arbitrary.; However, relatively simple objects such as floating point numbers or `NamedTuple`s must be used; when running on the GPU. ### 5. 'Field-dependent' boundary conditions. Boundary conditions may also depend on model fields. For example, a linear drag boundary condition; is implemented with. ```jldoctest; julia> @inline linear_drag(x, y, t, u) = - 0.2 * u; linear_drag (generic function with 1 method). julia> u_bottom_bc = FluxBoundaryCondition(linear_drag, field_dependencies=:u); FluxBoundaryCondition: ContinuousBoundaryFunction linear_drag at (Nothing, Nothing, Nothing); ```. `field_dependencies` specifies the name of the dependent fields either with a `Symbol` or `Tuple` of `Symbol`s. ### 6. 'Field-dependent' boundary conditions with parameters. When boundary conditions depends on fields _and_ parameters, their functions take the form. ```jldoctest; julia> @inline quadratic_drag(x, y, t, u, v, drag_coeff) = - drag_coeff * u * sqrt(u^2 + v^2); quadratic_drag (generic function with 1 method). julia> u_bottom_bc = FluxBoundaryCondition(quadratic_dra",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md:12144,simpl,simple,12144,docs/src/model_setup/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/boundary_conditions.md,1,['simpl'],['simple']
Usability,"ime = 0 seconds, iteration = 0); ‚îú‚îÄ‚îÄ grid: 1√ó1√ó1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ timestepper: RungeKutta3TimeStepper; ‚îú‚îÄ‚îÄ tracers: (); ‚îú‚îÄ‚îÄ closure: Nothing; ‚îú‚îÄ‚îÄ buoyancy: Nothing; ‚îî‚îÄ‚îÄ coriolis: Nothing. julia> typeof(model.velocities.u.data); OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}. julia> adapt(Array, model.velocities.u.data); 3√ó3√ó3 OffsetArray(::Array{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2√ó0:2√ó0:2:; [:, :, 0] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 1] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0; ```. Notice that to view the `CuArray` that stores values for `u` we first need to transform; it into a regular `Array` using `Adapt.adapt`. If we naively try to view the `CuArray`; without that step we get an error:. ```julia; julia> model.velocities.u.data; 3√ó3√ó3 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2√ó0:2√ó0:2:; [:, :, 0] =; Error showing value of type OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}:; ERROR: Scalar indexing is disallowed.; ```. Here `CUDA.jl` throws an error because scalar `getindex` is not `allowed`. There are ways to; overcome this limitation and allow scalar indexing (more about that ; in the [CUDA.jl documentation](https://cuda.juliagpu.org/stable/usage/workflow/#UsageWorkflowScalar)), but this option; can be very slow on GPUs, so it is advised to only use this last method when using the REPL or ; prototyping -- never in production-ready scripts. You might also need to keep these differences in mind when using arrays; to define initial conditions, boundary conditions or; forcing functions on a GPU. To learn more about working with `CuArray`s, see the; [array programming](https://juliagpu.github.io/CUDA.jl/dev/usage/array/) section; of the CUDA.jl documentation.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:13838,learn,learn,13838,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['learn'],['learn']
Usability,"label=""Cell interfaces""). ylims!(ax, -1, 1); xlims!(ax, -0.1, 1.1); hideydecorations!(ax); hidexdecorations!(ax, ticklabels=false, label=false); hidespines!(ax). Legend(fig[0, 1], ax, nbanks=2, framevisible=false). current_figure(); ```. ## Setting `Field`s. `Field`s are full of 0's when they are created, which is not very exciting.; The situation can be improved using [`set!`](@ref) to change the values of a field.; For example,. ```jldoctest fields; set!(c, 42). # output; 4√ó5√ó4 Field{Center, Center, Center} on RectilinearGrid on CPU; ‚îú‚îÄ‚îÄ grid: 4√ó5√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ boundary conditions: FieldBoundaryConditions; ‚îÇ ‚îî‚îÄ‚îÄ west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; ‚îî‚îÄ‚îÄ data: 6√ó7√ó6 OffsetArray(::Array{Float64, 3}, 0:5, 0:6, 0:5) with eltype Float64 with indices 0:5√ó0:6√ó0:5; ‚îî‚îÄ‚îÄ max=42.0, min=42.0, mean=42.0; ```. Now `c` is filled with `42`s (for this simple case, we could also have used `c .= 42`).; Let's confirm that:. ```jldoctest fields; c[1, 1, 1]. # output; 42.0; ```. Looks good. And. ```jldoctest fields; c[1:4, 1:5, 1]. # output; 4√ó5 Matrix{Float64}:; 42.0 42.0 42.0 42.0 42.0; 42.0 42.0 42.0 42.0 42.0; 42.0 42.0 42.0 42.0 42.0; 42.0 42.0 42.0 42.0 42.0; ```. Note that indexing into `c` is the same as indexing into `c.data`. ```jldoctest fields; c[:, :, :] == c.data; ; # output; true; ```. We can also `set!` with arrays,. ```@setup fields; using Random; Random.seed!(123); ```. ```@example fields; random_stuff = rand(size(c)...); set!(c, random_stuff). heatmap(view(c, :, :, 1)); ```. or even use functions to set,. ```jldoctest fields; fun_stuff(x, y, z) = 2x; set!(c, fun_stuff). # output. 4√ó5√ó4 Field{Center, Center, Center} on RectilinearGrid on CPU; ‚îú‚îÄ‚îÄ grid: 4√ó5√ó4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ boundary conditions: FieldBoundaryConditions; ‚îÇ ‚îî‚îÄ‚îÄ west: Periodic, east: Periodic,",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md:8417,simpl,simple,8417,docs/src/fields.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/fields.md,1,['simpl'],['simple']
Usability,"le: 'Oceananigans.jl: Fast and friendly geophysical fluid dynamics on GPUs'; tags:; - fluid; - ocean; - climate; - Julia; - gpu; authors:; - name: Ali Ramadhan; orcid: 0000-0003-1102-1520; affiliation: 1; - name: Gregory LeClaire Wagner; orcid: 0000-0001-5317-2445; affiliation: 1; - name: Chris Hill; affiliation: 1; - name: Jean-Michel Campin; affiliation: 1; - name: Valentin Churavy; affiliation: 1; - name: Tim Besard; affiliation: 2; - name: Andre Souza; affiliation: 1; - name: Alan Edelman; affiliation: 1; - name: Raffaele Ferrari; affiliation: 1; - name: John Marshall; affiliation: 1; affiliations:; - name: Massachusetts Institute of Technology; index: 1; - name: Julia Computing, Inc.; index: 2; date: 11 August 2020; bibliography: paper.bib; ---. # Summary. ``Oceananigans.jl`` is a fast and friendly software package for the numerical; simulation of incompressible, stratified, rotating fluid flows on CPUs and GPUs.; ``Oceananigans.jl`` is fast and flexible enough for research yet simple enough; for students and first-time programmers. ``Oceananigans.jl`` is being developed; as part of the Climate Modeling Alliance project for the simulation of; small-scale ocean physics at high-resolution that affect the evolution of; Earth‚Äôs climate. ``Oceananigans.jl`` is designed for high-resolution simulations in idealized; geometries and supports direct numerical simulation, large eddy simulation,; arbitrary numbers of active and passive tracers, and linear and nonlinear; equations of state for seawater. Under the hood, ``Oceananigans.jl`` employs a; finite volume algorithm similar to that used by the Massachusetts Institute of; Technology general circulation model [@Marshall1997]. ![Fig. 1](free_convection_and_baroclinic_instability.png); Fig. 1: (Left) Large eddy simulation of small-scale oceanic boundary layer; turbulence forced by a surface cooling in a horizontally periodic domain using; $256^3$ grid points. The upper layer is well-mixed by turbulent convection and; boun",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md:1006,simpl,simple,1006,paper/paper.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md,1,['simpl'],['simple']
Usability,"ly create a scratch space and pass that same; scratch space for as many diagnostics as you can, you minimize the memory requirements of your; calculations by reusing the same chunk of memory. Have a look at an; [example for how to create scratch space](https://github.com/CliMA/LESbrary.jl/blob/cf31b0ec20219d5ad698af334811d448c27213b0/examples/three_layer_ constant_fluxes.jl#L380-L383) and how it can be; [used in calculations](https://github.com/CliMA/LESbrary.jl/blob/cf31b0ec20219d5ad698af334811d448c27213b0/src/TurbulenceStatistics/first_through_third_order.jl#L109-L112). ### Arrays in GPUs are usually different from arrays in CPUs. Oceananigans.jl uses [`CUDA.CuArray`](https://cuda.juliagpu.org/stable/usage/array/) to store ; data for GPU computations. One limitation of `CuArray`s compared to the `Array`s used for ; CPU computations is that `CuArray` elements in general cannot be accessed outside kernels; launched through CUDA.jl or KernelAbstractions.jl. (You can learn more about GPU kernels ; [here](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#kernels) and ; [here](https://cuda.juliagpu.org/stable/usage/overview/#Kernel-programming-with-@cuda).); Doing so requires individual elements to be copied from or to the GPU for processing,; which is very slow and can result in huge slowdowns. To avoid such unintentional slowdowns,; Oceananigans.jl disables CUDA scalar indexing by default. See the; [scalar indexing](https://juliagpu.github.io/CUDA.jl/dev/usage/workflow/#UsageWorkflowScalar); section of the CUDA.jl documentation for more information on scalar indexing. For example, if can be difficult to just view a `CuArray` since Julia needs to access ; its elements to do that. Consider the example below:. ```julia; julia> using Oceananigans, Adapt. julia> grid = RectilinearGrid(GPU(); size=(1, 1, 1), extent=(1, 1, 1), halo=(1, 1, 1)); 1√ó1√ó1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ Periodic x ‚àà [0.0, 1.0) regular",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:10755,learn,learn,10755,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['learn'],['learn']
Usability,"l{x}_\Omega\right)\boldsymbol{\nabla}p\right].; \end{equation}; ```; Given the boundary condition on pressure given above, we can define a new modified predictor velocity; which is equal to the predictor velocity within the domain but shares boundary conditions with the ; corrected field,; ```math; \begin{equation}; \label{eq:quasi_predictor_velocity}; \tilde{\boldsymbol{u}}^\star:=\boldsymbol{u}^\star + \delta\left(\boldsymbol{x} - \boldsymbol{x}_\Omega\right)(\boldsymbol{u}^{n+1} - \boldsymbol{u}^\star).; \end{equation}; ```; The modified pressure poisson equation becomes ``\nabla^2p^{n+1}=\frac{\boldsymbol{\nabla}\cdot\tilde{\boldsymbol{u}}^\star}{\Delta t}``; which can easily be solved. . Perhaps a more intuitive way to consider this is to recall that the corrector step projects ``\boldsymbol{u}^\star``; to the space of divergenece free velocity by applying; ```math; \begin{equation}; \label{eq:pressure_correction_step}; \boldsymbol{u}^{n+1} = \boldsymbol{u}^\star - \Delta t\boldsymbol{\nabla}p^{n+1},; \end{equation}; ```; but we have changed ``p^{n+1}`` to ``\phi`` and ``\boldsymbol{u}^\star`` to ``\tilde{\boldsymbol{u}}^\star``; so for ``\boldsymbol{\nabla}\phi \big |_{\partial\Omega} = 0`` the modified predictor velocity must; equal the corrected velocity on the boundary. For simple open boundary conditions such as no penetration or a straight forward prescription of; a known velocity at ``t^{n+1}`` this is simple to implement as we just set the boundary condition; on the predictor velocity and don't change it after the correction. But some open boundary methods; calculate the boundary value based on the interior solution. As a simple example, if we wanted to ; set the wall normal veloicty gradient to zero at the west boundary then we would set the boundary ; point to; ```math; \begin{equation}; \label{eq:zero_wall_normal_velocity_gradient}; u^\star_{1jk} \approx u^\star_{3jk} + (u^\star_{2jk} - u^\star_{jk4}) / 2 + \mathcal{O}(\Delta x^2),; \end{equation}; `",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md:10198,intuit,intuitive,10198,docs/src/numerical_implementation/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md,1,['intuit'],['intuitive']
Usability,"n example of; an implementation of the Heaviside function that forces it to be inlined:. ```julia; @inline heaviside(x) = ifelse(x < 0, zero(x), one(x)); ```. In practice it's hard to say whether inlining a function will bring runtime benefits _with; certainty_, since Julia and KernelAbstractions.jl (needed for GPU runs) already inline some; functions automatically. However, it is generally a good idea to at least investigate this aspect in; your code as the benefits can potentially be significant. ## GPU simulation tips. Running on GPUs can be very different from running on CPUs. Oceananigans makes most of the necessary; changes in the background, so that for very simple simulations changing between CPUs and GPUs is; just a matter of changing the `architecture` argument in the model from `CPU()` to `GPU()`. However,; for more complex simulations some care needs to be taken on the part of the user. While knowledge of; GPU computing (and Julia) is again desirable, an inexperienced user can also achieve high efficiency; in GPU simulations by following a few simple principles. ### Global variables that need to be used in GPU computations need to be defined as constants or passed as parameters. Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation; will crash. This includes any variables that are referenced as global variables in functions; used for forcing of boundary conditions. For example,. ```julia; T‚ÇÄ = 20 # ·µíC; surface_temperature(x, y, t) = T‚ÇÄ * sin(2œÄ / 86400 * t); T_bcs = FieldBoundaryConditions(bottom = GradientBoundaryCondition(surface_temperature)); ```. will throw an error if run on the GPU (and will run more slowly than it should on the CPU).; Replacing the first line above with. ```julia; const T‚ÇÄ = 20 # ·µíC; ```. fixes the issue by indicating to the compiler that `T‚ÇÄ` will not change. Note that the _literal_ `2œÄ / 86400` is not an issue -- it's only the; _variable_ `T‚ÇÄ` that must be declared `const`. Alternative",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md:3984,simpl,simple,3984,docs/src/simulation_tips.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/simulation_tips.md,1,['simpl'],['simple']
Usability,"oldsymbol{\cdot} \left ( \boldsymbol{v} c \right ) ; + \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \boldsymbol{v} C \right ); + \boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \boldsymbol{U} c \right ) \, .; ```. Notice that the term ``\boldsymbol{\nabla} \boldsymbol{\cdot} \left ( \boldsymbol{U} C \right )`` ; is neglected: only the terms describing the advection of resolved tracer by the background ; velocity field and the advection of background tracer by the resolved velocity field are included.; An analogous statement holds for the advection of background momentum by the resolved; velocity field.; Other possible terms associated with the Coriolis force, buoyancy, turbulence closures,; and surface waves acting on background fields are neglected. !!! compat ""Model compatibility""; `BackgroundFields` are only supported by [`NonhydrostaticModel`](@ref). ## Specifying background fields. `BackgroundField`s are defined by functions of ``(x, y, z, t)`` and optional parameters. A ; simple example is. ```jldoctest; using Oceananigans. U(x, y, z, t) = 0.2 * z. grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). model = NonhydrostaticModel(grid = grid, background_fields = (u=U,)). model.background_fields.velocities.u. # output; FunctionField located at (Face, Center, Center); ‚îú‚îÄ‚îÄ func: U (generic function with 1 method); ‚îú‚îÄ‚îÄ grid: 1√ó1√ó1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1√ó1√ó1 halo; ‚îú‚îÄ‚îÄ clock: Clock{Float64, Float64}(time=0 seconds, iteration=0, last_Œît=Inf days); ‚îî‚îÄ‚îÄ parameters: nothing; ```. `BackgroundField`s are specified by passing them to the kwarg `background_fields`; in the `NonhydrostaticModel` constructor. The kwarg `background_fields` expects; a `NamedTuple` of fields, which are internally sorted into `velocities` and `tracers`,; wrapped in `FunctionField`s, and assigned their appropriate locations. `BackgroundField`s with parameters require using the `BackgroundField` wrapper:. ```jldoctest moar_background; using Oceananigan",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/background_fields.md:1948,simpl,simple,1948,docs/src/model_setup/background_fields.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/background_fields.md,1,['simpl'],['simple']
Usability,"ore roughly 3x more cost-effective; than CPU simulations on cloud computing platforms such as Google Cloud. A GPU; with 32 GB of memory can time-step models with ~150 million grid points assuming; five fields are being evolved; for example, three velocity components and; tracers for temperature and salinity. These performance gains permit the; long-time integration of realistic simulations, such as large eddy simulation of; oceanic boundary layer turbulence over a seasonal cycle or the generation of; training data for turbulence parameterizations in Earth system models. ``Oceananigans.jl`` is continuously tested on CPUs and GPUs with unit tests,; integration tests, analytic solutions to the incompressible Navier-Stokes; equations, convergence tests, and verification experiments against published; scientific results. Future development plans include support for distributed; parallelism with CUDA-aware MPI as well as topography. Ocean models that are similar to ``Oceananigans.jl`` include MITgcm; [@Marshall1997] and MOM6 [@Adcroft2019], both written in Fortran. However,; ``Oceananigans.jl`` features a more efficient non-hydrostatic pressure solver; than MITgcm (and MOM6 is strictly hydrostatic). PALM [@Maronga2020] is Fortran; software for large eddy simulation of atmospheric and oceanic boundary layers; with complex boundaries on parallel CPU and GPU architectures. ``Oceananigans.jl``; is distinguished by its use of Julia which allows for a script-based interface as; opposed to a configuration-file-based interface used by MITgcm, MOM6, and PALM.; Dedalus [@Burns2020] is Python software with an intuitive script-based interface; that solves general partial differential equations, including the incompressible; Navier-Stokes equations, with spectral methods. # Acknowledgements. Our work is supported by the generosity of Eric and Wendy Schmidt by; recommendation of the Schmidt Futures program, and by the National Science; Foundation under grant AGS-6939393. # References; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md:4996,intuit,intuitive,4996,paper/paper.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/paper/paper.md,1,['intuit'],['intuitive']
Usability,"rac guide](https://github.com/SciML/ColPrac) for collaborative practices.; We ask that new contributors read that guide before submitting a pull request. Changes and contributions should be made via GitHub pull requests against the ``main`` branch. When you're done making changes, commit the changes you made. Chris Beams has written a ; [guide](https://chris.beams.io/posts/git-commit/) on how to write good commit messages. When you think your changes are ready to be merged into the main repository, push to your fork; and [submit a pull request](https://github.com/CLiMA/Oceananigans.jl/compare/). **Working on your first Pull Request?** You can learn how from this _free_ video series; [How to Contribute to an Open Source Project on GitHub](https://egghead.io/courses/how-to-contribute-to-an-open-source-project-on-github), Aaron Meurer's [tutorial on the git workflow](https://www.asmeurer.com/git-workflow/), or the guide [‚ÄúHow to Contribute to Open Source""](https://opensource.guide/how-to-contribute/). ## Documentation. Now that you've made your awesome contribution, it's time to tell the world how to use it.; Writing documentation strings is really important to make sure others use your functionality; properly. Didn't write new functions? That's fine, but be sure that the documentation for; the code you touched is still in great shape. It is not uncommon to find some strange wording; or clarification that you can take care of while you are here. You can preview how the Documentation will look like after merging by building the documentation ; locally. From the main directory of your local repository call. ```; julia --project=docs/ -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'; ```. to instantiate the documentation environment and then. ```; JULIA_DEBUG=Documenter julia --project=docs/ docs/make.jl; ```. If the documentation built is successful, you can open `docs/build/index.html` in your favorite browser.Providing the environment variable ; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:8882,guid,guide,8882,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['guid'],['guide']
Usability,"t before requesting collaborator status. ## What's a good way to start developing Oceananigans?. * Tackle an existing issue. We keep a list of [good first issues](https://github.com/CLiMA/Oceananigans.jl/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22); that are self-contained and suitable for a newcomer to try and work on. * Try to run Oceananigans and play around with it to simulate your favorite; fluids and ocean physics. If you run into any problems or find it difficult; to use or understand, please open an issue!. * Write up an example or tutorial on how to do something useful with; Oceananigans, like how to set up a new physical configuration. * Improve documentation or comments if you found something hard to use. * Implement a new feature if you need it to use Oceananigans. If you're interested in working on something, let us know by commenting on existing issues or ; by opening a new issue. This is to make sure no one else is working on the same issue and so ; we can help and guide you in case there is anything you need to know beforehand. ## Ground Rules. * Each pull request should consist of a logical collection of changes. You can; include multiple bug fixes in a single pull request, but they should be related.; For unrelated changes, please submit multiple pull requests. * Do not commit changes to files that are irrelevant to your feature or bugfix; (eg: `.gitignore`). * Be willing to accept criticism and work on improving your code; we don't want; to break other users' code, so care must be taken not to introduce bugs. We; discuss pull requests and keep working on them until we believe we've done a; good job. * Be aware that the pull request review process is not immediate, and is; generally proportional to the size of the pull request. ## Reporting a bug. The easiest way to get involved is to report issues you encounter when using; Oceananigans or by requesting something you think is missing. * Head over to the [issues](https://github.com/",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:4817,guid,guide,4817,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['guid'],['guide']
Usability,"take a while).; Alternatively, you can run only one test script file by providing its name as an environment; variable. For example, to run the tests only from the `test_coriolis.jl` file we call:. ```; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; ```. ## Pull Requests. We follow the [ColPrac guide](https://github.com/SciML/ColPrac) for collaborative practices.; We ask that new contributors read that guide before submitting a pull request. Changes and contributions should be made via GitHub pull requests against the ``main`` branch. When you're done making changes, commit the changes you made. Chris Beams has written a ; [guide](https://chris.beams.io/posts/git-commit/) on how to write good commit messages. When you think your changes are ready to be merged into the main repository, push to your fork; and [submit a pull request](https://github.com/CLiMA/Oceananigans.jl/compare/). **Working on your first Pull Request?** You can learn how from this _free_ video series; [How to Contribute to an Open Source Project on GitHub](https://egghead.io/courses/how-to-contribute-to-an-open-source-project-on-github), Aaron Meurer's [tutorial on the git workflow](https://www.asmeurer.com/git-workflow/), or the guide [‚ÄúHow to Contribute to Open Source""](https://opensource.guide/how-to-contribute/). ## Documentation. Now that you've made your awesome contribution, it's time to tell the world how to use it.; Writing documentation strings is really important to make sure others use your functionality; properly. Didn't write new functions? That's fine, but be sure that the documentation for; the code you touched is still in great shape. It is not uncommon to find some strange wording; or clarification that you can take care of while you are here. You can preview how the Documentation will look like after merging by building the documentation ; locally. From the main directory of your local repository call. ```; julia --project=docs/ -e 'using Pkg; Pkg.develop",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:8546,learn,learn,8546,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,1,['learn'],['learn']
Usability,"the *closure problem*: the time evolution of the Reynolds stresses; depends on triple covariances ``\overline{v_i^\prime v_j^\prime v_k^\prime}`` and covariances with pressure, which depend; on quadruple covariances and so on [Chou45](@cite). This is kind of hopeless so we will have to find some way to model the Reynolds stresses. ## Gradient-diffusion hypothesis and eddy viscosity models. The *gradient-diffusion hypothesis*, due to [Boussinesq1877](@citet), assumes that the transport of scalar fluxes; such as ``\overline{\boldsymbol{v}^\prime c^\prime}`` and ``\overline{v_i^\prime v_j^\prime}`` occurs down the mean scalar gradient; ``\boldsymbol{\nabla} \overline{c}`` as if they are being diffused (¬ß4.4) [Pope00](@cite). This is in analogy with how momentum transfer by; molecular motion in a gas can be described by a molecular viscosity. Taking this assumption we can express the Reynolds stresses and turbulent tracer fluxes in terms of the mean variables; and close the equations; ```math; \overline{\boldsymbol{v}^\prime c^\prime} = -\kappa_e \boldsymbol{\nabla} \overline{c}; \quad \text{and} \quad; \overline{v_i^\prime v_j^\prime} = -2\nu_e \overline{S}_{ij} \, ,; ```; where ``\nu_e = \nu_e(\boldsymbol{x}, t)`` is the turbulent or *eddy viscosity* and ``\kappa_e = \kappa_e(\boldsymbol{x}, t)``; is the *eddy diffusivity*. The effective diffusivity ends up being the sum of the molecular and eddy diffusivities. So just by using an elevated; value for the viscosity and diffusivity, you are already using an eddy viscosity model. The eddy viscosity model is simple and for that reason is very popular. It can work well even with a constant eddy; diffusivity. However, it does assume that the flux is aligned down gradient, which is not true even in simple turbulent; flows as the physics of turbulence is quite different from that of colliding molecules leading to the viscous stress law; (¬ß4.4,10.1) [Pope00](@cite). So we might want something a little bit more sophisticated.; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md:4571,simpl,simple,4571,docs/src/numerical_implementation/turbulence_closures.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/turbulence_closures.md,2,['simpl'],['simple']
Usability,"ttps://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/free_convection_0956.png)](https://www.youtube.com/watch?v=yq4op9h3xcU). ### [Winds blowing over the ocean](https://www.youtube.com/watch?v=IRncfbvuiy8). [![Watch winds blowing over the ocean](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_0400.png)](https://www.youtube.com/watch?v=IRncfbvuiy8). ### [Free convection with wind stress](https://www.youtube.com/watch?v=ob6OMQgPfI4). [![Watch free convection with wind stress in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_unstable_7500.png)](https://www.youtube.com/watch?v=ob6OMQgPfI4). ## Performance benchmarks. We've performed some preliminary performance benchmarks (see the [performance benchmarks](https://clima.github.io/OceananigansDocumentation/stable/appendix/benchmarks/) section of the documentation) by initializing models of various sizes and measuring the wall clock time taken per model iteration (or time step). This is not really a fair comparison as we haven't parallelized across all the CPU's cores so we will revisit these benchmarks once Oceananigans.jl can run on multiple CPUs and GPUs. To make full use of or fully saturate the computing power of a GPU such as an Nvidia Tesla V100 or; a Titan V, the model should have around ~10 million grid points or more. Sometimes counter-intuitively running with `Float32` is slower than `Float64`. This is likely due; to type mismatches causing slowdowns as floats have to be converted between 32-bit and 64-bit, an; issue that needs to be addressed meticulously. Due to other bottlenecks such as memory accesses and; GPU register pressure, `Float32` models may not provide much of a speedup so the main benefit becomes; lower memory costs (by around a factor of 2). ![Performance benchmark plots](https://user-images.githubusercontent.com/20099589/89906791-d2c85b00-dbb9-11ea-969a-4b8db2c31680.png); ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:11338,intuit,intuitively,11338,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['intuit'],['intuitively']
Usability,"u made. Chris Beams has written a ; [guide](https://chris.beams.io/posts/git-commit/) on how to write good commit messages. When you think your changes are ready to be merged into the main repository, push to your fork; and [submit a pull request](https://github.com/CLiMA/Oceananigans.jl/compare/). **Working on your first Pull Request?** You can learn how from this _free_ video series; [How to Contribute to an Open Source Project on GitHub](https://egghead.io/courses/how-to-contribute-to-an-open-source-project-on-github), Aaron Meurer's [tutorial on the git workflow](https://www.asmeurer.com/git-workflow/), or the guide [‚ÄúHow to Contribute to Open Source""](https://opensource.guide/how-to-contribute/). ## Documentation. Now that you've made your awesome contribution, it's time to tell the world how to use it.; Writing documentation strings is really important to make sure others use your functionality; properly. Didn't write new functions? That's fine, but be sure that the documentation for; the code you touched is still in great shape. It is not uncommon to find some strange wording; or clarification that you can take care of while you are here. You can preview how the Documentation will look like after merging by building the documentation ; locally. From the main directory of your local repository call. ```; julia --project=docs/ -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'; ```. to instantiate the documentation environment and then. ```; JULIA_DEBUG=Documenter julia --project=docs/ docs/make.jl; ```. If the documentation built is successful, you can open `docs/build/index.html` in your favorite browser.Providing the environment variable ; `JULIA_DEBUG=Documenter` will provide with more information in the documentation build process and; thus help figuring out a potential bug. ## Credits. This contributor's guide is heavily based on the excellent [MetPy contributor's guide](https://github.com/Unidata/MetPy/blob/master/CONTRIBUTING.md).; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md:10066,guid,guide,10066,docs/src/contributing.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/contributing.md,2,['guid'],['guide']
Usability,"uravy and Tim Besard and Andre Souza and Alan Edelman and Raffaele Ferrari and John Marshall},; title = {{Oceananigans.jl: Fast and friendly geophysical fluid dynamics on GPUs}},; journal = {Journal of Open Source Software}; }; ```. We also maintain a [list of publications using Oceananigans.jl](https://clima.github.io/OceananigansDocumentation/stable/#Papers-and-preprints-using-Oceananigans). If you have work using Oceananigans.jl that you would like to have listed there, please open a pull request to add it or let us know!. ## Contributing. If you're interested in contributing to the development of Oceananigans we want your help no matter how big or small a contribution you make!; Cause we're all in this together. If you'd like to work on a new feature, or if you're new to open source and want to crowd-source neat projects that fit your interests, you should [start a discussion](https://github.com/CliMA/Oceananigans.jl/discussions/new?) right away. For more information check out our [contributor's guide](https://clima.github.io/OceananigansDocumentation/stable/contributing/). ## Movies. ### [Deep convection](https://www.youtube.com/watch?v=kpUrxnKKMjI). [![Watch deep convection in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/surface_temp_3d_00130_halfsize.png)](https://www.youtube.com/watch?v=kpUrxnKKMjI). ### [Free convection](https://www.youtube.com/watch?v=yq4op9h3xcU). [![Watch free convection in action](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/free_convection_0956.png)](https://www.youtube.com/watch?v=yq4op9h3xcU). ### [Winds blowing over the ocean](https://www.youtube.com/watch?v=IRncfbvuiy8). [![Watch winds blowing over the ocean](https://raw.githubusercontent.com/ali-ramadhan/ali-ramadhan.Github.io/master/img/wind_stress_0400.png)](https://www.youtube.com/watch?v=IRncfbvuiy8). ### [Free convection with wind stress](https://www.youtube.com/watch?v=ob6OMQgPfI4). [![Watch free",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md:9438,guid,guide,9438,README.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/README.md,1,['guid'],['guide']
Usability,"with the buoyant acceleration of fluid, is; defined in terms of ``\rho'`` as; ```math; b = - \frac{g \rho'}{\rho_0} \, ,; ```; where ``g`` is gravitational acceleration. The Boussinesq approximation is valid when ``\rho_* + \rho' \ll \rho_0``, which implies the; fluid is _approximately_ incompressible, and thus does not support acoustic waves. In this case, ; the mass conservation equation reduces to the continuity equation; ```math; \begin{equation}; \boldsymbol{\nabla} \boldsymbol{\cdot} \boldsymbol{v} = \partial_x u + \partial_y v + \partial_z w = 0 \, .; \label{eq:continuity}; \end{equation}; ```. Similarly, in the the momentum equations we can divide through with ``\rho_0`` and use that ``\rho_* + \rho' \ll \rho_0`` to get:; ```math; \begin{equation}; \partial_t \boldsymbol{v} + \boldsymbol{v} \boldsymbol{\cdot} \boldsymbol{\nabla} \boldsymbol{v} + \dotsb = - \frac1{\rho_0} \boldsymbol{\nabla} p - g \frac{\rho}{\rho_0} \hat{\boldsymbol{z}} + \dotsb \, .; \label{eq:momentum}; \end{equation}; ```. We refer to ``p / \rho_0`` as the ""kinematic pressure"" with dimensions of velocity squared. Hereafter, we; abuse notation a bit and denote the kinematic pressure simply as ``p``. !!! info ""Convention on dynamic versus kinematic pressure""; In Oceananigans, the pressure ``p`` refers to ""kinematic pressure"" (with dimensions velocity squared),; i.e., the dynamic pressure scaled with the reference fluid density ``\rho_0``. [^1]: Named after Boussinesq (1903) although used earlier by Oberbeck (1879), the Boussinesq; approximation neglects density differences in the momentum equation except when associated; with the gravitational term. It is an accurate approximation for many flows, and especially; so for oceanic flows where density differences are very small. See Vallis (2017, section 2.4); for an oceanographic introduction to the Boussinesq equations and Vallis (2017, Section 2.A); for an asymptotic derivation. See Kundu (2015, Section 4.9) for an engineering; introduction. ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/boussinesq.md:1920,simpl,simply,1920,docs/src/physics/boussinesq.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/physics/boussinesq.md,1,['simpl'],['simply']
Usability,"y spaced with min(Œîy)=6.02272, max(Œîy)=245.338; ‚îî‚îÄ‚îÄ Bounded z ‚àà [-1000.0, 0.0] variably spaced with min(Œîz)=2.40764, max(Œîz)=49.0086; ```. ```@setup 1; using Oceananigans; using CairoMakie; CairoMakie.activate!(type = ""svg""); Nx, Ny, Nz = 64, 64, 32; Lx, Ly, Lz = 1e4, 1e4, 1e3; chebychev_spaced_y_faces(j) = - Ly/2 * cos(œÄ * (j - 1) / Ny);; chebychev_spaced_z_faces(k) = - Lz/2 - Lz/2 * cos(œÄ * (k - 1) / Nz);; grid = RectilinearGrid(size = (Nx, Ny, Nz),; topology = (Periodic, Bounded, Bounded),; x = (0, Lx),; y = chebychev_spaced_y_faces,; z = chebychev_spaced_z_faces); ```. We can easily visualize the spacings of ``y`` and ``z`` directions. We can use, e.g.,; [`ynodes`](@ref) and [`yspacings`](@ref) to extract the positions and spacings of the; nodes from the grid. ```@example 1; y·∂ú = ynodes(grid, Center()); Œîy·∂ú = yspacings(grid, Center()). z·∂ú = znodes(grid, Center()); Œîz·∂ú = zspacings(grid, Center()). using CairoMakie. fig = Figure(size=(800, 900)). ax1 = Axis(fig[1, 1]; xlabel = ""y (m)"", ylabel = ""y-spacing (m)"", limits = (nothing, (0, 250))); lines!(ax1, y·∂ú, Œîy·∂ú); scatter!(ax1, y·∂ú, Œîy·∂ú). ax2 = Axis(fig[2, 1]; xlabel = ""z-spacing (m)"", ylabel = ""z (m)"", limits = ((0, 50), nothing)); lines!(ax2, z·∂ú, Œîz·∂ú); scatter!(ax2, z·∂ú, Œîz·∂ú). save(""plot_stretched_grid.svg"", fig); nothing #hide; ```. ![](plot_stretched_grid.svg). ## `LatitudeLongitudeGrid`. A simple latitude-longitude grid with `Float64` type can be constructed by. ```jldoctest; julia> grid = LatitudeLongitudeGrid(size = (36, 34, 25),; longitude = (-180, 180),; latitude = (-85, 85),; z = (-1000, 0)); 36√ó34√ó25 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 3√ó3√ó3 halo and with precomputed metrics; ‚îú‚îÄ‚îÄ longitude: Periodic Œª ‚àà [-180.0, 180.0) regularly spaced with ŒîŒª=10.0; ‚îú‚îÄ‚îÄ latitude: Bounded œÜ ‚àà [-85.0, 85.0] regularly spaced with ŒîœÜ=5.0; ‚îî‚îÄ‚îÄ z: Bounded z ‚àà [-1000.0, 0.0] regularly spaced with Œîz=40.0; ```. For more examples see [`RectilinearGrid`](@ref) and [`LatitudeLongitudeGrid`](@ref).; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/legacy_grids.md:6936,simpl,simple,6936,docs/src/model_setup/legacy_grids.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/model_setup/legacy_grids.md,1,['simpl'],['simple']
Usability,"{x} - \boldsymbol{x}_\Omega\right)(\boldsymbol{u}^{n+1} - \boldsymbol{u}^\star).; \end{equation}; ```; The modified pressure poisson equation becomes ``\nabla^2p^{n+1}=\frac{\boldsymbol{\nabla}\cdot\tilde{\boldsymbol{u}}^\star}{\Delta t}``; which can easily be solved. . Perhaps a more intuitive way to consider this is to recall that the corrector step projects ``\boldsymbol{u}^\star``; to the space of divergenece free velocity by applying; ```math; \begin{equation}; \label{eq:pressure_correction_step}; \boldsymbol{u}^{n+1} = \boldsymbol{u}^\star - \Delta t\boldsymbol{\nabla}p^{n+1},; \end{equation}; ```; but we have changed ``p^{n+1}`` to ``\phi`` and ``\boldsymbol{u}^\star`` to ``\tilde{\boldsymbol{u}}^\star``; so for ``\boldsymbol{\nabla}\phi \big |_{\partial\Omega} = 0`` the modified predictor velocity must; equal the corrected velocity on the boundary. For simple open boundary conditions such as no penetration or a straight forward prescription of; a known velocity at ``t^{n+1}`` this is simple to implement as we just set the boundary condition; on the predictor velocity and don't change it after the correction. But some open boundary methods; calculate the boundary value based on the interior solution. As a simple example, if we wanted to ; set the wall normal veloicty gradient to zero at the west boundary then we would set the boundary ; point to; ```math; \begin{equation}; \label{eq:zero_wall_normal_velocity_gradient}; u^\star_{1jk} \approx u^\star_{3jk} + (u^\star_{2jk} - u^\star_{jk4}) / 2 + \mathcal{O}(\Delta x^2),; \end{equation}; ```; but we then pressure correct the interior so a new ``\mathcal{O}(\Delta t)`` error is introduced as; ```math; \begin{equation}; \begin{align}; u^{n+1}_{1jk} &\approx u^{n+1}_{3jk} + (u^{n+1}_{2jk} - u^{n+1}_{jk4}) / 2 + \mathcal{O}(\Delta x^2),\\; &= u^\star_{1jk} - \Delta t \left(\boldsymbol{\nabla}p^{n+1}_{3jk} + (\boldsymbol{\nabla}p^{n+1}_{2jk} - \boldsymbol{\nabla}p^{n+1}_{4jk}) / 2\right) + \mathcal{O}(\Delta x^2),\\; ",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md:10785,simpl,simple,10785,docs/src/numerical_implementation/boundary_conditions.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/numerical_implementation/boundary_conditions.md,2,['simpl'],['simple']
Usability,"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§; ‚îÇ (256, 256, 256) ‚îÇ (1, 1, 1) ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ 1.0 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 2, 1) ‚îÇ 1.89655 ‚îÇ 0.948276 ‚îÇ 0.968543 ‚îÇ 1.12093 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 4, 1) ‚îÇ 3.73522 ‚îÇ 0.933804 ‚îÇ 0.969719 ‚îÇ 1.13541 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 8, 1) ‚îÇ 6.94845 ‚îÇ 0.868556 ‚îÇ 0.972279 ‚îÇ 1.16437 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 16, 1) ‚îÇ 11.2086 ‚îÇ 0.700536 ‚îÇ 0.978143 ‚îÇ 1.2223 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 32, 1) ‚îÇ 13.0841 ‚îÇ 0.408879 ‚îÇ 0.992685 ‚îÇ 1.33816 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 64, 1) ‚îÇ 17.0612 ‚îÇ 0.266582 ‚îÇ 1.03519 ‚îÇ 1.5735 ‚îÇ; ‚îÇ (256, 256, 256) ‚îÇ (1, 128, 1) ‚îÇ 25.409 ‚îÇ 0.198508 ‚îÇ 1.16772 ‚îÇ 2.03693 ‚îÇ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò; ```. ![ss_nonhydrostatic_efficiency](https://user-images.githubusercontent.com/45054739/130146219-b354fa25-7d77-4206-8e7e-ec639b2250fa.png). ## Multithreading. Oceananigans can also achieve parallelism via multithreading. Though its efficiencies are less than that of the MPI distributed architectures, its simple setup still makes it a viable option for achieving speedups on simple systems. ### Weak Scaling Multithreaded Shallow Water Model. The initial drop and then rise in efficiencies going from 1 to 2 to 4 threads is likely caused by the 2 threads being automatically allocated onto only one physical CPU core. Though one physical CPU core may contain 2 logical cores each capable of running a separate thread, having 2 threads run on one core will still reduce efficiencies as many resources such as caches and buses must be shared by both threads. Note that there are as many CPU cores allocated as the maximum number of threads. ```; Oceananigans v0.58.9; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/",MatchSource.DOCS,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md:25378,simpl,simple,25378,docs/src/appendix/benchmarks.md,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/tree/v0.93.2/docs/src/appendix/benchmarks.md,2,['simpl'],['simple']
