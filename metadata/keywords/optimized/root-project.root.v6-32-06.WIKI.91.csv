quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Performance,"ar in variadic function (like printf). So when using printf you should either explicitly cast the value or use any intermediary variable: fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);; Also, optionally, the generated selector will also call methods named macrofilename_methodname in each of 6 main selector methods if the method macrofilename_methodname exist (Where macrofilename is stripped of its extension).; Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> bool h1analysisProxy_Notify();; Process -> bool h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist it is included before the declaration of the proxy class. This can be used in particular to insure that the include files needed by the macro file are properly loaded.; The default histogram is accessible via the variable named 'htemp'.; If the library of the classes describing the data in the branch is loaded, the skeleton will add the needed include statements and give the ability to access the object stored in the branches.; To draw px using the file `hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx:; double hsimple() {; return px;; }; hsimpleDefinition hsimple.py:1; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; Drawth1 Draw(); A more complete example is available in the tutorials directory: h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C ; Implements TVirtualTreePlayer.; Definition at line 1925 of file TTreePlayer.cxx. ◆ MakeReader(). Int_t TTreePlayer::MakeReader ; (; const char * ; classname, . Opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePlayer.html:35641,load,loaded,35641,doc/master/classTTreePlayer.html,https://root.cern,https://root.cern/doc/master/classTTreePlayer.html,1,['load'],['loaded']
Performance,"ar when connection broken.Definition RGeomData.cxx:1381; ROOT::RGeomDescription::ClearDescriptionvoid ClearDescription()Clear geometry description.Definition RGeomData.cxx:478; ROOT::RGeomDescription::MakeStackByIdsstd::vector< int > MakeStackByIds(const std::vector< int > &ids)Creates stack for given array of ids, first element always should be 0.Definition RGeomData.cxx:1621; ROOT::RGeomDescription::SetMaxVisFacesvoid SetMaxVisFaces(int cnt)Set maximal number of faces which should be selected for drawing.Definition RGeomData.hxx:322; ROOT::RGeomDescription::IsPreferredOfflinebool IsPreferredOffline() constIs offline operations preferred.Definition RGeomData.hxx:361; ROOT::RGeomDescription::fShapesstd::vector< ShapeDescr > fShapes! shapes with created descriptionsDefinition RGeomData.hxx:253; ROOT::RGeomDescription::fJsonCompint fJsonComp! default JSON compressionDefinition RGeomData.hxx:261; ROOT::RGeomDescription::ChangeNodeVisibilitybool ChangeNodeVisibility(const std::vector< std::string > &path, bool on)Change visibility for specified element Returns true if changes was performed.Definition RGeomData.cxx:1850; ROOT::RGeomDescription::fSearchstd::string fSearch! search string in hierarchyDefinition RGeomData.hxx:255; ROOT::RGeomDescription::fSearchJsonstd::string fSearchJson! drawing json for searchDefinition RGeomData.hxx:256; ROOT::RGeomDescription::SavePrimitivevoid SavePrimitive(std::ostream &fs, const std::string &name)Save geometry configuration as C++ macro.Definition RGeomData.cxx:2143; ROOT::RGeomDescription::ClearAllPhysVisibilitybool ClearAllPhysVisibility()Reset all custom visibility settings.Definition RGeomData.cxx:2089; ROOT::RGeomDescription::MakeDrawingJsonstd::string MakeDrawingJson(RGeomDrawing &drawing, bool has_shapes=false)Produce JSON for the drawing If TGeoShape appears in the drawing, one has to keep typeinfo But in thi...Definition RGeomData.cxx:1826; ROOT::RGeomDescription::fActualLevelint fActualLevel! level can be reduced when select",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:78507,perform,performed,78507,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['perform'],['performed']
Performance,"ar' p.d.f.s in product. ;  ; std::unique_ptr< RooAbsReal > makeCondPdfRatioCorr (RooAbsReal &term, const RooArgSet &termNset, const RooArgSet &termImpSet, const char *normRange, const char *refRange) const;  For single normalization ranges. ;  ; std::string makeRGPPName (const char *pfx, const RooArgSet &term, const RooArgSet &iset, const RooArgSet &nset, const char *isetRangeName) const;  Make an appropriate automatic name for a RooGenProdProj object in getPartIntList() ;  ; std::vector< RooAbsReal * > processProductTerm (const RooArgSet *nset, const RooArgSet *iset, const char *isetRangeName, const RooArgSet *term, const RooArgSet &termNSet, const RooArgSet &termISet, bool &isOwned, bool forceWrap=false) const;  Calculate integrals of factorized product terms over observables iset while normalized to observables in nset. ;  ; void rearrangeProduct (CacheElem &) const;  ; void setCacheAndTrackHints (RooArgSet &) override;  Label OK'ed components of a RooProdPdf with cache-and-track, and label all RooProdPdf descendants with extra information about (conditional) normalization, needed to be able to Cache-And-Track them outside the RooProdPdf context. ;  ; std::unique_ptr< RooAbsReal > specializeIntegral (RooAbsReal &orig, const char *targetRangeName) const;  ; std::unique_ptr< RooAbsReal > specializeRatio (RooFormulaVar &input, const char *targetRangeName) const;  ; void useDefaultGen (bool flag=true);  . Private Attributes; RooObjCacheManager _cacheMgr;  ; double _cutOff = 0.0;  Cutoff parameter for running product. ;  ; RooArgSet _defNormSet;  Default normalization set. ;  ; Int_t _extendedIndex = -1;  Index of extended PDF (if any) ;  ; RooAICRegistry _genCode;  ! Registry of composite direct generator codes ;  ; RooListProxy _pdfList;  List of PDF components. ;  ; std::vector< std::unique_ptr< RooArgSet > > _pdfNSetList;  List of PDF component normalization sets. ;  ; TNamed * _refRangeName = nullptr;  Reference range name for interpretation of conditional product",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:65531,cache,cache-and-track,65531,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,1,['cache'],['cache-and-track']
Performance,"ar* decform = ""9.9"") const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). void ResetLoading(); Tell the formula that we are going to request a new entry. void SetAxis(TAxis* axis = 0); Set the axis (in particular get the type). void Streamer(TBuffer& ); Stream an object of class TTreeFormula. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void UpdateFormulaLeaves(); this function is called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void ResetDimensions(); Populate the TTreeFormulaManager with the dimension information. void LoadBranches(); Make sure that all the branches have been loaded properly. Bool_t LoadCurrentDim(). void Convert(UInt_t fromVersion); Convert the fOper of a TTTreeFormula version fromVersion to the current in memory version. Bool_t SwitchToFormLeafInfo(Int_t code); Convert the underlying lookup method from the direct technique; (dereferencing the address held by the branch) to the method using; TFormLeafInfo. This is in particular usefull in the case where we; need to append an additional TFormLeafInfo (for example to call a; method).; Return false if the switch was unsuccessfull (basically in the; case of an old style split tree). TTreeFormula(const char* name, const char* formula, TTree* tree, const vector<std::string>& aliases). TTreeFormula& operator=(const TTreeFormula& ). Long64_t EvalInstance64(Int_t i = 0, const char** stringStack = 0); {return EvalInstance<Long64_t>(i, stringStack); }. LongDouble_t EvalInstanceLD(Int_t i = 0, const char** stringStack = 0); {return EvalInstance<LongDouble_t>(i, stringStack); }.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeFormula.html:26547,load,loaded,26547,root/html534/TTreeFormula.html,https://root.cern,https://root.cern/root/html534/TTreeFormula.html,1,['load'],['loaded']
Performance,"ar* decform = ""9.9"") const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). void ResetLoading(); Tell the formula that we are going to request a new entry. void SetAxis(TAxis* axis = 0); Set the axis (in particular get the type). void Streamer(TBuffer& ); Stream an object of class TTreeFormula. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void UpdateFormulaLeaves(); this function is called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void ResetDimensions(); Populate the TTreeFormulaManager with the dimension information. void LoadBranches(); Make sure that all the branches have been loaded properly. Bool_t LoadCurrentDim(). void Convert(UInt_t fromVersion); Convert the fOper of a TTTreeFormula version fromVersion to the current in memory version. Bool_t SwitchToFormLeafInfo(Int_t code); Convert the underlying lookup method from the direct technique; (dereferencing the address held by the branch) to the method using; TFormLeafInfo. This is in particular usefull in the case where we; need to append an additional TFormLeafInfo (for example to call a; method).; Return false if the switch was unsuccessfull (basically in the; case of an old style split tree). TTreeFormula(const char* name, const char* formula, TTree* tree, const vector<string>& aliases). TTreeFormula& operator=(const TTreeFormula& ). Long64_t EvalInstance64(Int_t i = 0, const char*[] stringStack = 0); {return EvalInstance<Long64_t>(i, stringStack); }. LongDouble_t EvalInstanceLD(Int_t i = 0, const char*[] stringStack = 0); {return EvalInstance<LongDouble_t>(i, stringStack); }. TT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeFormula.html:31798,load,loaded,31798,root/html602/TTreeFormula.html,https://root.cern,https://root.cern/root/html602/TTreeFormula.html,2,['load'],['loaded']
Performance,"ar* dset); Physically remove the dataset 'dset', i.e. remove the dataset and the files; it describes; Return 0 on success, -1 on error. Int_t MakeDataSet(const char* dset = 0, Long64_t nevt = -1, const char* fnroot = ""event"", Bool_t regenerate = kFALSE); Create the largest dataset for the run.; Defaults for; dataset name, filename root; are; ""BenchDataSet"", ""event""; respectively.; Default selector is TSelEventGen. Use SetDataGenSel and SetDataGenOar to change it; and to pass the list of PARs defining the alternative selector.; These can be changed via dset, sel and fnroot, respectively.; The argument 'nevt' controls the number of events per file (-1 for the default,; which is 30000).; Return 0 on success, -1 on error. Int_t CopyDataSet(const char* dset, const char* dsetdst, const char* destdir); Copy the files of dataset 'dset' to 'destdir' and create a new dataset named 'dsetdst'; decribing them.; Return 0 on success, -1 on error. void SetProofDS(TProof* p); Set the PROOF instance to be used for dataset operations, like releasing; cache ...; Use SetProofDS(0) to reset and using the default PROOF. TProofBench(const char* url, const char* outfile = ""<default>"", const char* proofopt = 0). const char * GetOutFileName() const; { return fOutFileName; }. void SetNFilesWrk(Int_t nf = 0); { fNFilesWrk = (nf > 0) ? nf : 4; }. void SetNTries(Int_t nt); { if (nt > 0) fNtries = nt; }. void SetHistType(TPBHistType* histtype); { fHistType = histtype; }. void SetNHist(Int_t nh); { fNHist = nh; }. void SetReadType(TPBReadType* readtype); { fReadType = readtype; }. void SetCPUSel(const char* sel); { fCPUSel = sel; }. void SetCPUPar(const char* par); { fCPUPar = par; }. void SetDataSel(const char* sel); { fDataSel = sel; }. void SetDataPar(const char* par); { fDataPar = par; }. void SetDataGenSel(const char* sel); { fDataGenSel = sel; }. void SetDataGenPar(const char* par); { fDataGenPar = par; }. void SetDebug(Bool_t debug = kTRUE); { fDebug = debug; }. Bool_t GetDebug(); { return f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofBench.html:10856,cache,cache,10856,root/html532/TProofBench.html,https://root.cern,https://root.cern/root/html532/TProofBench.html,1,['cache'],['cache']
Performance,"ar* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetErrorTolerance(Double_t t); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidSetForceSum(Bool_t flag); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidSetMaxIters(Int_t mi); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNonCentralChiSquare.html:28701,cache,cache,28701,root/html532/RooNonCentralChiSquare.html,https://root.cern,https://root.cern/root/html532/RooNonCentralChiSquare.html,1,['cache'],['cache']
Performance,"ar* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetCacheAlpha(Bool_t flag); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsCachedPdf::setInterpolationOrder(Int_t order); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooIntegralMorph.html:33082,cache,cache,33082,root/html534/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html534/RooIntegralMorph.html,3,['cache'],['cache']
Performance,"ar* image, const char* workdir); TSlave*CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd, Int_t nwk = 1); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TList*GetEnabledPackages() const; static Bool_tGetFileInCmd(const char* cmd, TString& fn); static Int_tGetInputData(TList* input, const char* cachedir, TString& emsg); TList*GetListOfActiveSlaves() const; TVirtualProofPlayer*GetPlayer() const; TPluginHandler*GetProgressDialog() const; Int_tGetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidHandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tHandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidInitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); virtual Int_tPollForNewWorkers(); voidPrepareInputDataFile(TString& dataFile); Int_tRemoveWorkers(TList* wrks); static Int_tSaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidSaveWorkerInfo(); Int_tSendFile(const char* file, Int_t opt = (kBinary | kForward | kCp | kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tSendInputData(TQueryResult* qr, TProof* p, TString& emsg); virtual voidSendInputDataFile(); voidSetDSet(TDSet* dset); voidSetFeedback(TString& opt, TString& optfb, Int_t action); voidSetPlayer(TVirtualProofPlayer* player); voidSetupWorkersEnv(TList* wrks, Bool_t increasingpool = kFALSE); static void*SlaveStartupThread(void* arg); virtual Bool_tStartSlaves(Bool_t attach = kFALSE); static voidSystemCmd(const char* cmd, Int_t fdout); TProof(); voidUpdateDialog(); virtual voidValidateDSet(TDSet* dset); Int_tVerifyDataSetParallel(const char* uri, const char* optStr).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProof.html:20808,cache,cachedir,20808,root/html604/TProof.html,https://root.cern,https://root.cern/root/html604/TProof.html,1,['cache'],['cachedir']
Performance,"ar* isetRangeName) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAddModel::CacheElem*getProjCache(const RooArgSet* nset, const RooArgSet* iset = 0, const char* rangeName = 0) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddModel.html:33952,optimiz,optimizeDirtyHook,33952,root/html526/RooAddModel.html,https://root.cern,https://root.cern/root/html526/RooAddModel.html,4,['optimiz'],['optimizeDirtyHook']
Performance,"ar* location, const char* fmt, va_list va) const; TList*TProof::GetEnabledPackages() const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::HandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tTProof::Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); virtual Int_tTProof::PollForNewWorkers(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary | kForward | kCp | kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString& emsg); virtual voidTProof::SendInputDataFile(); voidTProof::SetDSet(TDSet* dset); voidTProof::SetFeedback(TString& opt, TString& optfb, Int_t action); voidTProof::SetPlayer(TVirtualProofPlayer* player); voidTProof::SetupWorkersEnv(TList* wrks, Bool_t increasingpool = kFALSE); static void*TProof::SlaveStartupThread(void* arg); virtual Bool_tStartSlaves(Bool_t); static voidTProof::SystemCmd(const char* cmd, Int_t fdout); voidTProof::UpdateDialog(); virtual voidValidateDSet(TDSet* dset); Int_tTProof::VerifyDataSetParallel(const char* uri, const char* optStr).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofSuperMaster.html:22571,cache,cachedir,22571,root/html604/TProofSuperMaster.html,https://root.cern,https://root.cern/root/html604/TProofSuperMaster.html,1,['cache'],['cachedir']
Performance,"ar* msgfmt) const; virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTTree::AddClone(TTree*); virtual TBranch*TTree::BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); virtual Int_tTTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tTTree::GetCacheAutoSize(Bool_t withDefault = kFALSE) const; virtual TLeaf*TTree::GetLeafImpl(const char* branchname, const char* leafname); charTTree::GetNewlineValue(istream& inputStream); TTreeCache*TTree::GetReadCache(TFile* file, Bool_t create = kFALSE); voidTTree::ImportClusterRanges(TTree* fromtree); voidInvalidateCurrentTree(); virtual voidTTree::KeepCircular(); voidTObject::MakeZombie(); voidTTree::MoveReadCache(TFile* src, TDirectory* dir); voidReleaseChainProof(); Int_tTTree::SetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); Int_tTTree::SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). private:. TChain&operator=(const TChain&); voidParseTreeFilename(const char* name, TString& filename, TString& treename, TString& query, TString& suffix, Bool_t wildcards) const; TChain(const TChain&). Data ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TChain.html:22000,cache,cacheSize,22000,root/html604/TChain.html,https://root.cern,https://root.cern/root/html604/TChain.html,1,['cache'],['cacheSize']
Performance,"ar* msgfmt) const; virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTTree::AddClone(TTree*); virtual TBranch*TTree::BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); virtual Int_tTTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tTTree::GetCacheAutoSize(Bool_t withDefault = kFALSE) const; virtual TLeaf*TTree::GetLeafImpl(const char* branchname, const char* leafname); charTTree::GetNewlineValue(istream& inputStream); TTreeCache*TTree::GetReadCache(TFile* file, Bool_t create = kFALSE); voidTTree::ImportClusterRanges(TTree* fromtree); voidInvalidateCurrentTree(); virtual voidTTree::KeepCircular(); voidTObject::MakeZombie(); voidTTree::MoveReadCache(TFile* src, TDirectory* dir); voidReleaseChainProof(); Int_tTTree::SetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); voidTTree::SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). private:. TChain&operator=(const TChain&); voidParseTreeFilename(const char* name, TString& filename, TString& treename, TString& query, TString& suffix, Bool_t wildcards) const; TChain(const TChain&). Data ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TChain.html:21991,cache,cacheSize,21991,root/html602/TChain.html,https://root.cern,https://root.cern/root/html602/TChain.html,1,['cache'],['cacheSize']
Performance,"ar* msgfmt) const; virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTTree::AddClone(TTree*); virtual TBranch*TTree::BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); virtual Int_tTTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tTTree::GetCacheAutoSize(Bool_t withDefault = kFALSE) const; virtual TLeaf*TTree::GetLeafImpl(const char* branchname, const char* leafname); charTTree::GetNewlineValue(istream& inputStream); TTreeCache*TTree::GetReadCache(TFile* file, Bool_t create = kFALSE); voidTTree::ImportClusterRanges(TTree* fromtree); voidInvalidateCurrentTree(); virtual voidTTree::KeepCircular(); voidTObject::MakeZombie(); voidTTree::MoveReadCache(TFile* src, TDirectory* dir); voidReleaseChainProof(); Int_tTTree::SetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); voidTTree::SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). private:. TChain(const TChain&); TChain&operator=(const TChain&); voidParseTreeFilename(const char* name, TString& filename, TString& treename, TString& query, TString& suffix, Bool_t wildcards) const. Data ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TChain.html:21755,cache,cacheSize,21755,root/html534/TChain.html,https://root.cern,https://root.cern/root/html534/TChain.html,1,['cache'],['cacheSize']
Performance,"ar* newname). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree *t, const RooFormulaVar* select, const char* /*rangeName*/, Int_t /*nStart*/, Int_t /*nStop*/); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore *ads, const RooFormulaVar* select, 				 const char* rangeName, Int_t nStart, Int_t nStop); Load values from dataset 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of the n-th data point (n='index') in memory. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add a new column to the data set which holds the pre-calculated values; of 'newVar'. This operation is only meaningful if 'newVar' is a derived; value. The re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeDataStore.html:14041,load,loaded,14041,root/html526/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html526/RooTreeDataStore.html,1,['load'],['loaded']
Performance,"ar* package, Int_t opt = 0, TString* path = 0, Int_t chkveropt = 2); Build specified package on the client. Executes the PROOF-INF/BUILD.sh; script if it exists on the client.; If opt == 0, both the preparation and building phases are run.; If opt == 1, only the preparation phase (asserting and, eventually, downloading; of the package) is done; '*path' contains the full path to the; package to be passed in the next call; If opt == 2, only the building phase is run using *path .; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kBuildPackage; case). Keep in sync in case of changes. Int_t LoadPackage(const char* package, Bool_t notOnClient = kFALSE, TList* loadopts = 0, TList* workers = 0); Load specified package. Executes the PROOF-INF/SETUP.C script; on all active nodes. If notOnClient = true, don't load package; on the client. The default is to load the package also on the client.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t LoadPackageOnClient(const char* package, TList* loadopts = 0); Load specified package in the client. Executes the PROOF-INF/SETUP.C; script on the client. Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kLoadPackage; case). Keep in sync in case of changes.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackage(const char* package); Unload specified package.; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackageOnClient(const char* package); Unload a specific package on the client.; Returns ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:72582,load,loadopts,72582,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,1,['load'],['loadopts']
Performance,"ar* user, const char* dsName, TString& md5path, Bool_t local = kFALSE); Returns path of the indicated dataset. The extension is '.root' for all files; except for 'dsName==ls' which have extension '.txt'.; If 'local' is kTRUE the local cache path is returned instead in the form; <cachedir>/<group>.<user>.<dsName>.<ext>.; NB: contains a static TString for result, so copy result before using twice. Int_t NotifyUpdate(const char* group, const char* user, const char* dspath, Long_t mtime, const char* checksum = 0); Save into the <datasetdir>/kDataSet_DataSetList file the name of the updated; or created or modified dataset. For still existing datasets, fill the; modification date in seconds anf the checksum.; Returns 0 on success, -1 on error. Int_t CreateLsFile(const char* group, const char* user, Long_t& mtime, TString& checksum); Create or recreate the dataset lists for 'uri'.; The list are saved in text form in 'uri'/ls.txt for fast browsing and in; 'uri'/ls.root in form of TMacro for optimized and portable transfer.; Return 0 on success, 1 if the file was empty, -1 on error. Bool_t BrowseDataSets(const char* group, const char* user, const char* dsName, UInt_t option, TObject* target); Adds the dataset in the folder of group, user to the list in target.; If dsName is defined, only the information about the specified dataset; is processed. The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet.; Available options (to be .or.ed):; kPrint print the dataset content; kQuotaUpdate update quotas; kExport use export naming; kList get a list of dataset names. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuotaUpdate"" return is null. TMap * GetDataSets(const char* group, const char* user, const char* dsName = 0, UInt_t option = 0); General purpose call to go through the existing datasets.; If <user> is 0 or ""*"", act on all datasets for the given <group>.; If <group> is 0 or ""*"", act on all datasets.; I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSetManagerFile.html:13439,optimiz,optimized,13439,root/html528/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html528/TDataSetManagerFile.html,6,['optimiz'],['optimized']
Performance,"ar* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Execute the specified drawing action on a data set (TDSet).; Event- or Entry-lists should be set in the data set object using; TDSet::SetEntryList.; Returns -1 in case of error or number of selected events otherwise. Long64_t Process(TDSet* dset, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0); Process a data set (TDSet) using the specified selector (.C) file.; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Int_t CreateSymLinks(TList* files); Create in each worker sandbox symlinks to the files in the list; Used to make the caceh information available to workers. Int_t InitDataSetManager(); Initialize the dataset manager from directives or from defaults; Return 0 on success, -1 on failure. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove files from all file caches. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Copy the specified macro in the cache directory. The macro file is; uploaded if new or updated. If existing, the corresponding header; basename(macro).h or .hh, is also uploaded. For the other arguments; see TProof::Load().; Returns 0 in case of success and -1 in case of error. Int_t CopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0); Copy a macro, and its possible associated .h[h] file,; to the cache directory, from where the workers can get the file.; If headerRequired is 1, return -1 in case the header is not found.; If headerRequired is 0, try to copy header too.; If headerRequired is -1, don't look for header, only copy macr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:28198,cache,cache,28198,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,3,['cache'],['cache']
Performance,"ar* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Execute the specified drawing action on a data set (TDSet).; Event- or Entry-lists should be set in the data set object using; TDSet::SetEntryList.; Returns -1 in case of error or number of selected events otherwise. Long64_t Process(TDSet* dset, const char* sel, Option_t* o = """", Long64_t nent = -1, Long64_t fst = 0); Process a data set (TDSet) using the specified selector (.C) file.; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Int_t CreateSymLinks(TList* files); Create in each worker sandbox symlinks to the files in the list; Used to make the cache information available to workers. Int_t InitDataSetManager(); Initialize the dataset manager from directives or from defaults; Return 0 on success, -1 on failure. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove files from all file caches. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Copy the specified macro in the cache directory. The macro file is; uploaded if new or updated. If existing, the corresponding header; basename(macro).h or .hh, is also uploaded. For the other arguments; see TProof::Load().; Returns 0 in case of success and -1 in case of error. Int_t CopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0); Copy a macro, and its possible associated .h[h] file,; to the cache directory, from where the workers can get the file.; If headerRequired is 1, return -1 in case the header is not found.; If headerRequired is 0, try to copy header too.; If headerRequired is -1, don't look for header, only copy macr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofLite.html:32195,cache,cache,32195,root/html602/TProofLite.html,https://root.cern,https://root.cern/root/html602/TProofLite.html,1,['cache'],['cache']
Performance,"ar*& buffer); virtual TKey*TDirectory::FindKey(const char*) const; virtual TKey*TDirectory::FindKeyAny(const char*) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual TObject*TDirectory::FindObjectAnyFile(const char*) const; const char*FindObjectClassName(const char* name) const; const char*FindObjectPathName(const TObject* obj) const; TObject*FindSpecialObject(const char* name, void*& where); TClass*FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; voidForceStyle(Bool_t force = kTRUE); Bool_tFromPopUp() const; virtual TObject*TDirectory::Get(const char* namecycle); TApplication*GetApplication() const; virtual Int_tTDirectory::GetBufferSize() const; Int_tGetBuiltDate() const; Int_tGetBuiltTime() const; TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TSeqCollection*GetClipboard() const; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TObject*GetGeometry(const char* name) const; TGlobal*GetGlobal(const char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:4996,load,load,4996,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,1,['load'],['load']
Performance,"arName = 0); RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const char* selExpr = 0, const char* wgtVarName = 0); RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t, const char* wgtVarName = 0); virtual~RooTreeDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); const RooArgSet&RooAbsDataStore::cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsDataStore::dirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawCla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooTreeDataStore.html:2284,cache,cacheOwner,2284,root/html534/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html,1,['cache'],['cacheOwner']
Performance,"arTransform=Norm"" );; ; // Boosted Decision Trees; if (Use[""BDT""]); factory->BookMethod( dataloader, TMVA::Types::kBDT, ""BDT"",; ""!H:!V:NTrees=100:MinNodeSize=1.0%:BoostType=AdaBoostR2:SeparationType=RegressionVariance:nCuts=20:PruneMethod=CostComplexity:PruneStrength=30"" );; ; if (Use[""BDTG""]); factory->BookMethod( dataloader, TMVA::Types::kBDT, ""BDTG"",; ""!H:!V:NTrees=2000::BoostType=Grad:Shrinkage=0.1:UseBaggedBoost:BaggedSampleFraction=0.5:nCuts=20:MaxDepth=3:MaxDepth=4"" );; // --------------------------------------------------------------------------------------------------; ; // Now you can tell the factory to train, test, and evaluate the MVAs; ; // Train MVAs using the set of training events; factory->TrainAllMethods();; ; // Evaluate all MVAs using the set of test events; factory->TestAllMethods();; ; // Evaluate and compare performance of all configured MVAs; factory->EvaluateAllMethods();; ; // --------------------------------------------------------------; ; // Save the output; outputFile->Close();; ; std::cout << ""==> Wrote root file: "" << outputFile->GetName() << std::endl;; std::cout << ""==> TMVARegression is done!"" << std::endl;; ; delete factory;; delete dataloader;; ; // Launch the GUI for the root macros; if (!gROOT->IsBatch()) TMVA::TMVARegGui( outfileName );; }; ; int main( int argc, char** argv ); {; // Select methods (don't look at this code - not of interest); TString methodList;; for (int i=1; i<argc; i++) {; TString regMethod(argv[i]);; if(regMethod==""-b"" || regMethod==""--batch"") continue;; if (!methodList.IsNull()) methodList += TString("","");; methodList += regMethod;; }; TMVARegression(methodList);; return 0;; }; DataLoader.h; mainint main()Definition Prototype.cxx:12; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Double_tdouble Double_tDefinition RtypesCore.h:59; TChain.h; TFile.h; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:145993,perform,performance,145993,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['perform'],['performance']
Performance,"ar_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsSelfCachedReal(); Destructor. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Fill cache with sampling of function as defined by the evaluate() implementation. RooArgSet* actualObservables(const RooArgSet& nset) const; Defines observables to be cached, given a set of user defined observables; Returns the subset of nset that are observables this p.d.f. RooArgSet* actualParameters(const RooArgSet& nset) const; Defines parameters on which cache contents depends. Returns; subset of variables of self that is not contained in the; supplied nset. const char* inputBaseName() const; Use own name as base name for caches. » Last changed: Tue Mar 10 17:14:13 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsSelfCachedReal.html:37414,cache,cache,37414,root/html534/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsSelfCachedReal.html,5,['cache'],"['cache', 'cached', 'caches']"
Performance,"aram); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tEnablePackage(const char* package, Bool_t notOnClient = kFALSE); Int_tEnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE); Int_tEnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tExec(const char* cmd, Bool_t plusMaster = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* dataset); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFeedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tFinalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tFinalize(const char* queryref, Bool_t force = kFALSE); TList*FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tGetBytesRead() const; Int_tGetClientProtocol() const; const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:5635,load,loadopts,5635,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,3,['load'],['loadopts']
Performance,"arameter. If you pass a tree, MyClass will use it rather than the tree from which it was created.; void Init(TTree *tree) - it is called by the constructor to initialize the tree for reading. It associates each branch with the corresponding leaf data member.; ~MyClass() -the destructor, nothing special.; Int_t GetEntry(Int_t entry) - it loads the class with the entry specified. Once you have executed GetEntry, the leaf data members in MyClass are set to the values of the entry. For example, GetEntry(12) loads the 13th event into the event data member of MyClass (note that the first entry is 0). GetEntry returns the number of bytes read from the file. In case the same entry is read twice, ROOT does not have to do any I/O. In this case GetEntry returns 1. It does not return 0, because many people assume a return of 0 means an error has occurred while reading.; Int_t LoadTree(Int_t entry) and void Notify() - these two methods are related to chains. LoadTree will load the tree containing the specified entry from a chain of trees. Notify is called by LoadTree to adjust the branch addresses.; void Loop() - it is the skeleton method that loops through each entry of the tree. This is interesting to us, because we will need to customize it for our analysis. 12.21.3 MyClass.C; MyClass::Loop consists of a for-loop calling GetEntry for each entry. In the template, the numbers of bytes are added up, but it does nothing else. If we were to execute it now, there would be no output.; void MyClass::Loop() {; if (fChain == 0) return;. Int_t nentries = Int_t(fChain->GetEntries());; Int_t nbytes = 0, nb = 0;; for (Int_t jentry=0; jentry<nentries;jentry++) {; Int_t ientry = LoadTree(jentry);; // in case of a TChain , ientry is the entry number in the; // current file; nb = fChain->GetEntry(jentry); nbytes += nb;; // if (Cut(ientry) < 0) continue;; }; }; At the beginning of the file are instructions about reading selected branches. They are not reprinted here, but please read them from y",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:640135,load,load,640135,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['load']
Performance,"aramsEffective parameters of this p.d.f.; RooRealProxy_pdf1First input p.d.f; RooRealProxy_pdf2Second input p.d.f; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Double_t_shift1; Double_t_shift2; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxy_xConvolution observable; RooRealProxy_xprimeInput function representing value of convolution observable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooFFTConvPdf(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:45702,cache,cache,45702,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,4,['cache'],['cache']
Performance,"aranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t , Bool_t = kTRUE); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE, Bool_t ownNewDataAnyway = kFALSE); cout << ""RAOTS::setDataSlave("" << this << "") START"" << endl ;; Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsOptTestStatistic(); Constructors, assignment etc. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function() const; { return *_funcClone ; }. const char* cacheUniqueSuffix() const; { return Form(""_%lx"", (ULong_t)_dataClone) ; }. Bool_t isDerived() const; Override this to be always true to force calculation of likelihood without parameters. { return kTRUE ; }. void seal(const char* notice = """"); { _sealed = kTRUE ; _sealNotice = notice ; }. Bool_t isSealed() const; { return _sealed ; }. const char* sealNotice() const; { return _sealNotice.Data() ; }. Bool_t allowFunctionCache(); { return kTRUE ; }. RooArgSet requiredExtraObservables() const; { return RooArgSet() ; }. » Last changed: Tue Jun 2 15:27:14 2015 » Last generated: 2015-06-02 15:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsOptTestStatistic.html:47970,cache,cacheUniqueSuffix,47970,root/html604/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html604/RooAbsOptTestStatistic.html,1,['cache'],['cacheUniqueSuffix']
Performance,"arch path). ; If no file name extension is provided it tries .DLL. ; Reimplemented from TSystem.; Definition at line 4113 of file TWinNTSystem.cxx. ◆ FindFile(). const char * TWinNTSystem::FindFile ; (; const char * ; search, . TString & ; infile, . EAccessMode ; mode = kFileExists . ). overridevirtual . Find location of file in a search path. ; User must delete returned string. Returns 0 in case file is not found. ; Reimplemented from TSystem.; Definition at line 3108 of file TWinNTSystem.cxx. ◆ FreeDirectory(). void TWinNTSystem::FreeDirectory ; (; void * ; dirp). overridevirtual . Close a WinNT file system directory. ; Reimplemented from TSystem.; Definition at line 1944 of file TWinNTSystem.cxx. ◆ GetCpuInfo(). Int_t TWinNTSystem::GetCpuInfo ; (; CpuInfo_t * ; info, . Int_t ; sampleTime = 1000 . ); const. overridevirtual . Returns cpu load average and load info into the CpuInfo_t structure. ; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the interval over which the CPU load will be measured, in ms (default 1000). ; Reimplemented from TSystem.; Definition at line 6133 of file TWinNTSystem.cxx. ◆ GetCPUTime(). Double_t TWinNTSystem::GetCPUTime ; (; ). Definition at line 4501 of file TWinNTSystem.cxx. ◆ GetCryptoRandom(). Int_t TWinNTSystem::GetCryptoRandom ; (; void * ; buf, . Int_t ; len . ). overridevirtual . Return cryptographic random number Fill provided buffer with random values Returns number of bytes written to buffer or -1 in case of error. ; Reimplemented from TSystem.; Definition at line 1273 of file TWinNTSystem.cxx. ◆ GetDirEntry(). const char * TWinNTSystem::GetDirEntry ; (; void * ; dirp). overridevirtual . Returns the next directory entry. ; Reimplemented from TSystem.; Definition at line 1960 of file TWinNTSystem.cxx. ◆ GetDirName(). TString TWinNTSystem::GetDirName ; (; const char * ; pathname). overridevirtual . Return the directory name in pathname. ; DirName of c:/user/root is /user. DirName of c:/user/root/ is /user/root. ; R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:48559,load,load,48559,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['load'],['load']
Performance,"arch. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TGenCollectionProxy::Value. class TGenCollectionProxy::Value. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Value(); voidDeleteItem(void* ptr); Bool_tIsValid(); TGenCollectionProxy::Value&operator=(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(const TGenCollectionProxy::Value& inside); TGenCollectionProxy::ValueValue(const string& info, Bool_t silent). Data Members; public:. UInt_tfCasetype of data of Value_type; void*fCtorMethod cache for containee constructor; void*fDeleteMethod cache for containee delete; void*fDtorMethod cache for containee destructor; EDataTypefKindkind of ROOT-fundamental type; UInt_tfPropertiesAdditional properties of the value type (kNeedDelete); size_tfSizefSize of the contained object; TClassReffTypeTClass reference of Value_type in collection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Value(const TGenCollectionProxy::Value& inside); Copy constructor. Value(const string& info, Bool_t silent); Initializing constructor. void DeleteItem(void* ptr); Delete individual item from STL container. Bool_t IsValid(). » Author: Markus Frank 28/10/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TGenCollectionProxy.h 41102 2011-10-03 21:42:02Z pcanal $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGenCollectionProxy__Value.html:1057,cache,cache,1057,root/html532/TGenCollectionProxy__Value.html,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy__Value.html,3,['cache'],['cache']
Performance,"arconvDefinition rf210_angularconv.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; ; [#1] INFO:Caching -- Changing internal binning of variable 'psi' in FFT 'Mf' from 100 to 930 to improve the precision of the numerical FFT. This can be done manually by setting an additional binning named 'cache'.; [#1] INFO:Eval -- RooRealVar::setRange(psi) new range named 'refrange_fft_Mf' created with bounds [0,3.14159]; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d599f000 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d59e3f60 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d59e3f60 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(Mf_over_Mf_Int[psi]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_Mf_over_Mf_Int[psi]_MfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x5569d5fcc4a0 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi] for nset () with code 1 from preexisting content.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf210__angularconv_8C.html:6989,cache,cache,6989,doc/master/rf210__angularconv_8C.html,https://root.cern,https://root.cern/doc/master/rf210__angularconv_8C.html,1,['cache'],['cache']
Performance,"ard; kVerbose; kTreeStructure; };. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsString::_lenLength of _value; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; char*RooAbsString::_value[_len] Value; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStringVar.html:17965,cache,caches,17965,root/html532/RooStringVar.html,https://root.cern,https://root.cern/root/html532/RooStringVar.html,2,['cache'],"['cache', 'caches']"
Performance,"are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return list containing all TDataTypes (typedefs) currently defined.; Since types can be added and removed during execution of the; program, we need to update the list of types every time we; execute this method. However, when calling this function in; a (tight) loop where no new types will be created; you can set load=kFALSE (default). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the given include file correspond to a class that has; been loaded through a compiled dictionnary. void InitSystem(); Initialize operating system interface. void InitThreads(); Load and initialize thread library. TClass * LoadClass(const char* name, Bool_t silent = kFALSE) const; Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). Int_t LoadClass(const char* classname, const char* libname, Bool_t check = kFALSE); Check if class ""classname"" is known to the interpreter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:25728,load,load,25728,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,1,['load'],['load']
Performance,"are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return list containing all TDataTypes (typedefs) currently defined.; Since types can be added and removed during execution of the; program, we need to update the list of types every time we; execute this method. However, when calling this function in; a (tight) loop where no new types will be created; you can set load=kFALSE (default). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the name of the given include file corresponds to a class that; is known to ROOT, e.g. ""TLorentzVector.h"" versus TLorentzVector. void InitSystem(); Initialize operating system interface. void InitThreads(); Load and initialize thread library. TClass * LoadClass(const char* name, Bool_t silent = kFALSE) const; Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). Int_t LoadClass(const char* classname, const char* libname, Bool_t check = kFALSE); Check if class ""classnam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TROOT.html:26264,load,load,26264,root/html530/TROOT.html,https://root.cern,https://root.cern/root/html530/TROOT.html,3,['load'],['load']
Performance,"are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect.; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 527 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 493 of file TROOT.cxx. ◆ FindEndSymbol(). static st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v626/namespaceROOT.html:24653,concurren,concurrent,24653,doc/v626/namespaceROOT.html,https://root.cern,https://root.cern/doc/v626/namespaceROOT.html,1,['concurren'],['concurrent']
Performance,"are large. In any case, whether the non-positive-definiteness is real or only numerical is largely irrelevant, since in both cases the error matrix will be unreliable and the minimum suspicious.; 5.9.4.4 An Ill-posed Problem; For questions of parameter dependence, see the discussion above on positive-definiteness. Possible other mathematical problems are the following:. Excessive numerical round off - be especially careful of exponential and factorial functions which get big very quickly and lose accuracy.; Starting too far from the solution - the function may have unphysical local minima, especially at infinity in some variables. 5.10 Minuit2 Package; Minuit2 is a new object-oriented implementation, written in C++, of the popular MINUIT minimization package. Compared with the TMinuit class, which is a direct conversion from FORTRAN to C++, Minuit2 is a complete redesign and re-implementation of the package. This new version provides all the functionality present in the old FORTRAN version, with almost equivalent numerical accuracy and computational performances. Furthermore, it contains some fixes and small improvements and this new functionality: * The possibility to set single side parameter limits * the FUMILI algorithm (see the next paragraph “FUMILI Minimization Package”), which is an optimized method for least square and log likelihood minimizations.; Minuit2 has been originally developed by M. Winkler and F. James in the SEAL project. More information can be found on the MINUIT Web Site and in particular at the following documentation page at http://www.cern.ch/minuit/doc/doc.html.; A detailed User Guide for Minuit2 exists, describing the API of the internal classes. ROOT uses Minuit2 for fitting via the Minuit2Minimizer class which implements the ROOT::Math::Minimizer interface.; Minuit2 is also distributed as an independent package of ROOT and can be built without any other dependency on the ROOT libraries.; Examples on how to use the Minuit2 and Fumili2 p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:225607,perform,performances,225607,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performances']
Performance,"ared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char* ). Bool_t GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes). DictFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. DictFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TRealData* GetRealData(const char* name) const; -- Return pointer to TRealData element with name ""name"". Name can be a data member in the class itself,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TFunctionTemplate * GetFunctionTemplate(const char* name). const char * GetSharedLibs(); Get the list of shared libraries",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:36301,load,loading,36301,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['load'],['loading']
Performance,"arent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time enviro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:131877,cache,cacheSize,131877,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,4,['cache'],"['cache', 'cacheSize']"
Performance,"arg, Bool_t calcInline = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealMPFE.html:24925,cache,cache,24925,root/html602/RooRealMPFE.html,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html,2,['cache'],['cache']
Performance,"argument; use format:; //; // mylinux~> root -l TMVAClassification.C\‍(\""myMethod1,myMethod2,myMethod3\""\‍); ; //---------------------------------------------------------------; // This loads the library; TMVA::Tools::Instance();; ; // Default MVA methods to be trained + tested; std::map<std::string,int> Use;; ; // Cut optimisation; Use[""Cuts""] = 1;; Use[""CutsD""] = 1;; Use[""CutsPCA""] = 0;; Use[""CutsGA""] = 0;; Use[""CutsSA""] = 0;; //; // 1-dimensional likelihood (""naive Bayes estimator""); Use[""Likelihood""] = 1;; Use[""LikelihoodD""] = 0; // the ""D"" extension indicates decorrelated input variables (see option strings); Use[""LikelihoodPCA""] = 1; // the ""PCA"" extension indicates PCA-transformed input variables (see option strings); Use[""LikelihoodKDE""] = 0;; Use[""LikelihoodMIX""] = 0;; //; // Mutidimensional likelihood and Nearest-Neighbour methods; Use[""PDERS""] = 1;; Use[""PDERSD""] = 0;; Use[""PDERSPCA""] = 0;; Use[""PDEFoam""] = 1;; Use[""PDEFoamBoost""] = 0; // uses generalised MVA method boosting; Use[""KNN""] = 1; // k-nearest neighbour method; //; // Linear Discriminant Analysis; Use[""LD""] = 1; // Linear Discriminant identical to Fisher; Use[""Fisher""] = 0;; Use[""FisherG""] = 0;; Use[""BoostedFisher""] = 0; // uses generalised MVA method boosting; Use[""HMatrix""] = 0;; //; // Function Discriminant analysis; Use[""FDA_GA""] = 1; // minimisation of user-defined function using Genetics Algorithm; Use[""FDA_SA""] = 0;; Use[""FDA_MC""] = 0;; Use[""FDA_MT""] = 0;; Use[""FDA_GAMT""] = 0;; Use[""FDA_MCMT""] = 0;; //; // Neural Networks (all are feed-forward Multilayer Perceptrons); Use[""MLP""] = 0; // Recommended ANN; Use[""MLPBFGS""] = 0; // Recommended ANN with optional training method; Use[""MLPBNN""] = 1; // Recommended ANN with BFGS training method and bayesian regulator; Use[""CFMlpANN""] = 0; // Depreciated ANN from ALEPH; Use[""TMlpANN""] = 0; // ROOT's own ANN; #ifdef R__HAS_TMVAGPU; Use[""DNN_GPU""] = 1; // CUDA-accelerated DNN training.; #else; Use[""DNN_GPU""] = 0;; #endif; ; #ifdef R__HAS_TMVACPU; Use[",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:81445,load,loads,81445,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['load'],['loads']
Performance,"ariable (override if minimizer supports them ) otherwise as default set an unlimited variable ;  ; virtual bool SetLowerLimitedVariable (unsigned int ivar, const std::string &name, double val, double step, double lower);  set a new lower limit variable (override if minimizer supports them ) ;  ; void SetMaxFunctionCalls (unsigned int maxfcn);  set maximum of function calls ;  ; void SetMaxIterations (unsigned int maxiter);  set maximum iterations (one iteration can have many function calls) ;  ; void SetOptions (const MinimizerOptions &opt);  set all options in one go ;  ; void SetPrecision (double prec);  set in the minimizer the objective function evaluation precision ( a value <=0 means the minimizer will choose its optimal value automatically, i.e. ;  ; void SetPrintLevel (int level);  set print level ;  ; void SetStrategy (int strategyLevel);  set the strategy ;  ; void SetTolerance (double tol);  set the tolerance ;  ; virtual bool SetUpperLimitedVariable (unsigned int ivar, const std::string &name, double val, double step, double upper);  set a new upper limit variable (override if minimizer supports them ) ;  ; void SetValidError (bool on);  flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit) ;  ; virtual bool SetVariable (unsigned int ivar, const std::string &name, double val, double step)=0;  set a new free variable ;  ; virtual bool SetVariableInitialRange (unsigned int, double, double);  set the initial range of an existing variable ;  ; virtual bool SetVariableLimits (unsigned int ivar, double lower, double upper);  set the limits of an already existing variable ;  ; virtual bool SetVariableLowerLimit (unsigned int ivar, double lower);  set the lower-limit of an already existing variable ;  ; template<class VariableIterator > ; int SetVariables (const VariableIterator &begin, const VariableIterator &end);  add variables . Return number of variables successfully added ;  ; virtual bool SetVariableStepSize (unsig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Minimizer.html:11490,perform,perform,11490,doc/master/classROOT_1_1Math_1_1Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Minimizer.html,1,['perform'],['perform']
Performance,"ariable (override if minimizer supports them ) otherwise as default set an unlimited variable ;  ; virtual bool SetLowerLimitedVariable (unsigned int ivar, const std::string &name, double val, double step, double lower);  set a new lower limit variable (override if minimizer supports them ) ;  ; void SetMaxFunctionCalls (unsigned int maxfcn);  set maximum of function calls ;  ; void SetMaxIterations (unsigned int maxiter);  set maximum iterations (one iteration can have many function calls) ;  ; void SetOptions (const MinimizerOptions &opt);  set all options in one go ;  ; void SetPrecision (double prec);  set in the minimizer the objective function evaluation precision ( a value <=0 means the minimizer will choose its optimal value automatically, i.e. ;  ; void SetPrintLevel (int level);  set print level ;  ; void SetStrategy (int strategyLevel);  set the strategy ;  ; void SetTolerance (double tol);  set the tolerance ;  ; virtual bool SetUpperLimitedVariable (unsigned int ivar, const std::string &name, double val, double step, double upper);  set a new upper limit variable (override if minimizer supports them ) ;  ; void SetValidError (bool on);  flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit) ;  ; virtual bool SetVariableInitialRange (unsigned int, double, double);  set the initial range of an existing variable ;  ; virtual bool SetVariableLimits (unsigned int ivar, double lower, double upper);  set the limits of an already existing variable ;  ; virtual bool SetVariableLowerLimit (unsigned int ivar, double lower);  set the lower-limit of an already existing variable ;  ; template<class VariableIterator > ; int SetVariables (const VariableIterator &begin, const VariableIterator &end);  add variables . Return number of variables successfully added ;  ; virtual bool SetVariableStepSize (unsigned int ivar, double value);  set the step size of an already existing variable ;  ; virtual bool SetVariableUpperLimit (unsigne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLinearMinimizer.html:8727,perform,perform,8727,doc/master/classTLinearMinimizer.html,https://root.cern,https://root.cern/doc/master/classTLinearMinimizer.html,1,['perform'],['perform']
Performance,"ariables ;  ; std::vector< std::vector< Double_t > > fGradVecLinTst;  gradient vector, linear terms - one per tau ;  ; std::vector< std::vector< Double_t > > fGradVecTst;  gradient vector - one per tau ;  ; Double_t fNEveEffPath;  sum of weights for Path events ;  ; Double_t fNEveEffPerf;  idem for Perf events ;  ; UInt_t fNLinear;  number of linear terms ;  ; UInt_t fNRules;  number of rules ;  ; Double_t * fNTCoeff;  GD path: rule coefficients. ;  ; Double_t fNTCoefRad;  GD path: 'radius' of all rulecoeffs. ;  ; Double_t fNTErrorRate;  GD path: error rate (or performance) ;  ; Double_t * fNTLinCoeff;  GD path: linear coefficients. ;  ; Double_t fNTNuval;  GD path: value of nu. ;  ; Double_t fNTOffset;  GD path: model offset. ;  ; Double_t fNTRisk;  GD path: risk. ;  ; UInt_t fPathIdx1;  first event index for path search ;  ; UInt_t fPathIdx2;  last event index for path search ;  ; UInt_t fPerfIdx1;  first event index for performance evaluation ;  ; UInt_t fPerfIdx2;  last event index for performance evaluation ;  ; RuleEnsemble * fRuleEnsemble;  rule ensemble ;  ; RuleFit * fRuleFit;  rule fit ;  ; Double_t fsigave;  Sigma of current signal score function F(sig) ;  ; Double_t fsigrms;  Rms of F(sig) ;  . Private Member Functions; MsgLogger & Log () const;  . Private Attributes; MsgLogger * fLogger;  ! message logger ;  . #include <TMVA/RuleFitParams.h>; Member Typedef Documentation. ◆ EventItr. typedef std::vector<constTMVA::Event*>::const_iterator TMVA::RuleFitParams::EventItr. protected . Definition at line 130 of file RuleFitParams.h. Constructor & Destructor Documentation. ◆ RuleFitParams(). TMVA::RuleFitParams::RuleFitParams ; (; ). constructor ; Definition at line 64 of file RuleFitParams.cxx. ◆ ~RuleFitParams(). TMVA::RuleFitParams::~RuleFitParams ; (; ). virtual . destructor ; Definition at line 104 of file RuleFitParams.cxx. Member Function Documentation. ◆ CalcAverageResponse(). Double_t TMVA::RuleFitParams::CalcAverageResponse ; (; ). protected . calcul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:7653,perform,performance,7653,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,2,['perform'],['performance']
Performance,"ariables, making this PDF directly dependent on the dataset. Int_t Compare(const TObject* other) const; Utility function used by TCollection::Sort to compare contained TObjects; We implement comparison by name, resulting in alphabetical sorting by object name. void printDirty(Bool_t depth = kTRUE) const; Print information about current value dirty state information.; If depth flag is true, information is recursively printed for; all nodes in this arg tree. void optimizeCacheMode(const RooArgSet& observables); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Interface function signaling a re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:29649,optimiz,optimizeCacheMode,29649,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,9,"['cache', 'optimiz']","['cache', 'optimization', 'optimizeCacheMode']"
Performance,"ariables, making this PDF directly dependent on the dataset. Int_t Compare(const TObject* other) const; Utility function used by TCollection::Sort to compare contained TObjects; We implement comparison by name, resulting in alphabetical sorting by object name. void printDirty(Bool_t depth = kTRUE) const; Print information about current value dirty state information.; If depth flag is true, information is recursively printed for; all nodes in this arg tree. void optimizeCacheMode(const RooArgSet& observables); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Activate cache mode optimization with given definition of observables.; The cache operation mode of all objects in the expression tree will; modified such that all nodes that depend directly or indirectly on; any of the listed observables will be set to ADirty, as they are; expected to change every time. This save change tracking overhead for; nodes that are a priori known to change every time. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); Find branch nodes with all-constant parameters, and add them to the list of; nodes that can be cached with a dataset in a test statistic calculation. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsArg.html:30109,optimiz,optimizeCacheMode,30109,root/html532/RooAbsArg.html,https://root.cern,https://root.cern/root/html532/RooAbsArg.html,12,"['cache', 'optimiz']","['cache', 'optimization', 'optimizeCacheMode']"
Performance,"ariablesvector of variable settings and tranformation function; vector<double>fXinternal cached of external values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MinimTransformFunction(const ROOT::Math::IMultiGradFunction* f, const vector<ROOT::Math::EMinimVariableType>& types, const vector<double>& values, const map<unsigned int,pair<double,double> >& bounds). Constructor from a IMultiGradFunction interface (which is managed by the class); vector specifying the variable types (free, bounded or fixed, defined in enum EMinimVariableTypes ); variable values (used for the fixed ones) and a map with the bounds (for the bounded variables). unsigned int NDim() const; method inherited from IFunction interface. { return fIndex.size(); }. unsigned int NTot() const; { return fFunc->NDim(); }. IMultiGenFunction * Clone() const; clone: not supported (since auto_ptr used in the fVariables). const double * Transformation(const double* x) const; transform from internal to external; result is cached also inside the class. Transformation(x, &fX[0]). void InvTransformation(const double* xext, double* xint) const; inverse transformation (external -> internal). void InvStepTransformation(const double* x, const double* sext, double* sint) const; inverse transformation for steps (external -> internal) at external point x. void GradientTransformation(const double* x, const double* gExt, double* gInt) const; transform gradient vector (external -> internal) at internal point x. void MatrixTransformation(const double* x, const double* covInt, double* covExt) const; transform covariance matrix (internal -> external) at internal point x; use row storages for matrices m(i,j) = rep[ i * dim + j]. const IMultiGradFunction * OriginalFunction() const; return original function. { return fFunc; }. double DoEval(const double* x) const; function evaluation. double DoDerivative(const double* x, unsigned int icoord) const; calculate derivatives. MinimTransformF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__MinimTransformFunction.html:3896,cache,cached,3896,root/html602/ROOT__Math__MinimTransformFunction.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__MinimTransformFunction.html,2,['cache'],['cached']
Performance,"ariance matrix calculation will re-implement the method. { return 0; }. double Correlation(unsigned int i, unsigned int j) const. return correlation coefficient between variable i and j.; If the variable is fixed or const the return value is zero. double GlobalCC(unsigned int ) const. return global correlation coefficient for variable i; This is a number between zero and one which gives; the correlation between the i-th parameter and that linear combination of all; other parameters which is most strongly correlated with i.; Minimizer must overload method if implemented. { return -1; }. bool GetMinosError(unsigned int , double& errLow, double& errUp, int = 0). minos error for variable i, return false if Minos failed or not supported; and the lower and upper errors are returned in errLow and errUp; An extra flag specifies if only the lower (runopt=-1) or the upper (runopt=+1) error calculation is run; (This feature isnot yet implemented). bool Hesse(). perform a full calculation of the Hessian matrix for error calculation. { return false; }. bool Scan(unsigned int , unsigned int& , double* , double* , double = 0, double = 0). scan function minimum for variable i. Variable and function must be set before using Scan; Return false if an error or if minimizer does not support this functionality. bool Contour(unsigned int , unsigned int , unsigned int& , double* , double* ). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const = 0;; print the result according to set level (implemented for TMinuit for mantaining Minuit-style printing). {}. std::string VariableName(unsigned int ) const; get name of variables (override if minimizer support storing of variable names); return an empty string if variable is not found. { return std::string();}. int Vari",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__Minimizer.html:7713,perform,perform,7713,root/html526/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__Minimizer.html,4,['perform'],['perform']
Performance,"ariations for an existing column. Varied results are then extracted via VariationsFor(). |; 110 ; 111 ; 112### Actions; 113Actions aggregate data into a result. Each one is described in more detail in the reference guide.; 114 ; 115In the following, whenever we say an action ""returns"" something, we always mean it returns a smart pointer to it. Actions only act on events that pass all preceding filters.; 116 ; 117Lazy actions only trigger the event loop when one of the results is accessed for the first time, making it easy to; 118produce many different results in one event loop. Instant actions trigger the event loop instantly.; 119 ; 120 ; 121| **Lazy action** | **Description** |; 122|------------------|-----------------|; 123| Aggregate() | Execute a user-defined accumulation operation on the processed column values. |; 124| Book() | Book execution of a custom action using a user-defined helper object. |; 125| Cache() | Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). |; 126| Count() | Return the number of events processed. Useful e.g. to get a quick count of the number of events passing a Filter. |; 127| Display() | Provides a printable representation of the dataset contents. The method returns a ROOT::RDF::RDisplay() instance which can print a tabular representation of the data or return it as a string. |; 128| Fill() | Fill a user-defined object with the values of the specified columns, as if by calling `Obj.Fill(col1, col2, ...)`. |; 129| Graph() | Fills a TGraph with the two columns provided. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; 130| GraphAsymmErrors() | Fills a TGraphAsymmErrors. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; 131| Histo1D(), Histo2D(), Histo3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:7473,cache,cached,7473,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,2,['cache'],['cached']
Performance,"ariations for an existing column. Varied results are then extracted via VariationsFor(). |; 114 ; 115 ; 116### Actions; 117Actions aggregate data into a result. Each one is described in more detail in the reference guide.; 118 ; 119In the following, whenever we say an action ""returns"" something, we always mean it returns a smart pointer to it. Actions only act on events that pass all preceding filters.; 120 ; 121Lazy actions only trigger the event loop when one of the results is accessed for the first time, making it easy to; 122produce many different results in one event loop. Instant actions trigger the event loop instantly.; 123 ; 124 ; 125| **Lazy action** | **Description** |; 126|------------------|-----------------|; 127| Aggregate() | Execute a user-defined accumulation operation on the processed column values. |; 128| Book() | Book execution of a custom action using a user-defined helper object. |; 129| Cache() | Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). |; 130| Count() | Return the number of events processed. Useful e.g. to get a quick count of the number of events passing a Filter. |; 131| Display() | Provides a printable representation of the dataset contents. The method returns a ROOT::RDF::RDisplay() instance which can print a tabular representation of the data or return it as a string. |; 132| Fill() | Fill a user-defined object with the values of the specified columns, as if by calling `Obj.Fill(col1, col2, ...)`. |; 133| Graph() | Fills a TGraph with the two columns provided. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; 134| GraphAsymmErrors() | Fills a TGraphAsymmErrors. If multi-threading is enabled, the order of the points may not be the one expected, it is therefore suggested to sort if before drawing. |; 135| Histo1D(), Histo2D(), Histo3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:7915,cache,cached,7915,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,2,['cache'],['cached']
Performance,"arker) ;  ; static Style_t GetMarkerStyleBase (Style_t style);  Internal helper function that returns the corresponding marker style with line width 1 for the given style. ;  . Protected Member Functions; virtual Double_t ** Allocate (Int_t newsize);  Allocate internal data structures for newsize points. ;  ; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; virtual void CopyAndRelease (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin);  Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin != iend. ;  ; virtual Bool_t CopyPoints (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin);  Copy points from fX and fY to arrays[0] and arrays[1] or to fX and fY if arrays == 0 and ibegin != iend. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; virtual Bool_t DoMerge (const TGraph *g);  protected function to perform the merge operation of a graph ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; virtual void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE);  Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHistogramAndFunctions (std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option);  Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes. ;  ; Double_t ** ShrinkAndCopy (Int_t size, Int_t iend);  if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend). ;  ; virtual void SwapPoints (Int_t pos1, Int_t pos2);  Swap points. ;  ; virtual void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low);  Upda",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph.html:28802,perform,perform,28802,doc/master/classTGraph.html,https://root.cern,https://root.cern/doc/master/classTGraph.html,1,['perform'],['perform']
Performance,"arlowBeeston.py;   Implementing the Barlow-Beeston method for taking into account the statistical uncertainty of a Monte-Carlo fit template. ;  ; file  rf710_roopoly.C;   Taylor expansion of RooFit functions using the taylorExpand function with RooPolyFunc ;  ; file  rf710_roopoly.py;   Taylor expansion of RooFit functions using the taylorExpand function ;  ; file  rf711_lagrangianmorph.C;   Morphing effective field theory distributions with RooLagrangianMorphFunc A morphing function as a function of one coefficient is setup and can be used to obtain the distribution for any value of the coefficient. ;  ; file  rf711_lagrangianmorph.py;   Morphing effective field theory distributions with RooLagrangianMorphFunc. ;  ; file  rf712_lagrangianmorphfit.C;   Performing a simple fit with RooLagrangianMorphFunc. ;  ; file  rf712_lagrangianmorphfit.py;   Performing a simple fit with RooLagrangianMorphFunc ;  ; file  rf801_mcstudy.C;   Validation and MC studies: toy Monte Carlo study that perform cycles of event generation and fitting ;  ; file  rf801_mcstudy.py;   Validation and MC studies: toy Monte Carlo study that perform cycles of event generation and fitting ;  ; file  rf802_mcstudy_addons.C;   Validation and MC studies: RooMCStudy - using separate fit and generator models, using the chi^2 calculator model Running a biased fit model against an optimal fit. ;  ; file  rf803_mcstudy_addons2.C;   Validation and MC studies: RooMCStudy - Using the randomizer and profile likelihood add-on models ;  ; file  rf804_mcstudy_constr.C;   Validation and MC studies: using RooMCStudy on models with constrains ;  ; file  rf901_numintconfig.C;   Numeric algorithm tuning: configuration and customization of how numeric (partial) integrals are executed ;  ; file  rf901_numintconfig.py;   Numeric algorithm tuning: configuration and customization of how numeric (partial) integrals are executed ;  ; file  rf902_numgenconfig.C;   Numeric algorithm tuning: configuration and customization of how ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__roofit.html:22891,perform,perform,22891,doc/master/group__tutorial__roofit.html,https://root.cern,https://root.cern/doc/master/group__tutorial__roofit.html,1,['perform'],['perform']
Performance,"arr3[2]"");; 4249/// ~~~; 4250/// will draw the sum arr3 for the index 0 to 2 only if the; 4251/// actual_size_of_arr3 is greater or equal to 3.; 4252/// Note that the array in 'primary' is flattened/linearized thus using; 4253/// `Alt$` with multi-dimensional arrays of different dimensions in unlikely; 4254/// to yield the expected results. To visualize a bit more what elements; 4255/// would be matched by TTree::Draw, TTree::Scan can be used:; 4256/// ~~~ {.cpp}; 4257/// tree->Scan(""arr1:Alt$(arr2,0)"");; 4258/// ~~~; 4259/// will print on one line the value of arr1 and (arr2,0) that will be; 4260/// matched by; 4261/// ~~~ {.cpp}; 4262/// tree->Draw(""arr1-Alt$(arr2,0)"");; 4263/// ~~~; 4264/// The ternary operator is not directly supported in TTree::Draw however, to plot the; 4265/// equivalent of `var2<20 ? -99 : var1`, you can use:; 4266/// ~~~ {.cpp}; 4267/// tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");; 4268/// ~~~; 4269///; 4270/// ### Drawing a user function accessing the TTree data directly; 4271///; 4272/// If the formula contains a file name, TTree::MakeProxy will be used; 4273/// to load and execute this file. In particular it will draw the; 4274/// result of a function with the same name as the file. The function; 4275/// will be executed in a context where the name of the branches can; 4276/// be used as a C++ variable.; 4277///; 4278/// For example draw px using the file hsimple.root (generated by the; 4279/// hsimple.C tutorial), we need a file named hsimple.cxx:; 4280/// ~~~ {.cpp}; 4281/// double hsimple() {; 4282/// return px;; 4283/// }; 4284/// ~~~; 4285/// MakeProxy can then be used indirectly via the TTree::Draw interface; 4286/// as follow:; 4287/// ~~~ {.cpp}; 4288/// new TFile(""hsimple.root""); 4289/// ntuple->Draw(""hsimple.cxx"");; 4290/// ~~~; 4291/// A more complete example is available in the tutorials directory:; 4292/// `h1analysisProxy.cxx`, `h1analysProxy.h` and `h1analysisProxyCut.C`; 4293/// which reimplement the selector found in `",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:171911,load,load,171911,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['load'],['load']
Performance,"arrived ; Definition at line 158 of file RWebWindow.hxx. ◆ fDefaultPage. std::string ROOT::RWebWindow::fDefaultPage. private . ! HTML page (or file name) returned when window URL is opened ; Definition at line 139 of file RWebWindow.hxx. ◆ fDisconnCallback. WebWindowConnectCallback_t ROOT::RWebWindow::fDisconnCallback. private . ! callback for disconnect event ; Definition at line 159 of file RWebWindow.hxx. ◆ fHasWindowThrd. bool ROOT::RWebWindow::fHasWindowThrd {false}. private . ! indicate if special window thread was started ; Definition at line 162 of file RWebWindow.hxx. ◆ fHeight. unsigned ROOT::RWebWindow::fHeight {0}. private . ! initial window width and height when displayed, zeros are ignored ; Definition at line 166 of file RWebWindow.hxx. ◆ fId. unsigned ROOT::RWebWindow::fId {0}. private . ! unique identifier ; Definition at line 141 of file RWebWindow.hxx. ◆ fInputQueue. std::queue<QueueEntry> ROOT::RWebWindow::fInputQueue. private . ! input queue for all callbacks ; Definition at line 164 of file RWebWindow.hxx. ◆ fInputQueueMutex. std::mutex ROOT::RWebWindow::fInputQueueMutex. private . ! mutex to protect input queue ; Definition at line 165 of file RWebWindow.hxx. ◆ fMaster. std::shared_ptr<RWebWindow> ROOT::RWebWindow::fMaster. private . ! master window where this window is embedded ; Definition at line 137 of file RWebWindow.hxx. ◆ fMasterConns. std::vector<MasterConn> ROOT::RWebWindow::fMasterConns. private . ! master connections ; Definition at line 138 of file RWebWindow.hxx. ◆ fMaxQueueLength. unsigned ROOT::RWebWindow::fMaxQueueLength {10}. private . ! maximal number of queue entries ; Definition at line 156 of file RWebWindow.hxx. ◆ fMgr. std::shared_ptr<RWebWindowsManager> ROOT::RWebWindow::fMgr. private . ! display manager ; Definition at line 136 of file RWebWindow.hxx. ◆ fNativeOnlyConn. bool ROOT::RWebWindow::fNativeOnlyConn {false}. private . ! only native connection are allowed, created by Show() method ; Definition at line 154 of fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:56055,queue,queue,56055,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['queue'],['queue']
Performance,"arrived ; Definition at line 161 of file RWebWindow.hxx. ◆ fDefaultPage. std::string ROOT::RWebWindow::fDefaultPage. private . ! HTML page (or file name) returned when window URL is opened ; Definition at line 142 of file RWebWindow.hxx. ◆ fDisconnCallback. WebWindowConnectCallback_t ROOT::RWebWindow::fDisconnCallback. private . ! callback for disconnect event ; Definition at line 162 of file RWebWindow.hxx. ◆ fHasWindowThrd. bool ROOT::RWebWindow::fHasWindowThrd {false}. private . ! indicate if special window thread was started ; Definition at line 165 of file RWebWindow.hxx. ◆ fHeight. unsigned ROOT::RWebWindow::fHeight {0}. private . ! initial window width and height when displayed, zeros are ignored ; Definition at line 169 of file RWebWindow.hxx. ◆ fId. unsigned ROOT::RWebWindow::fId {0}. private . ! unique identifier ; Definition at line 144 of file RWebWindow.hxx. ◆ fInputQueue. std::queue<QueueEntry> ROOT::RWebWindow::fInputQueue. private . ! input queue for all callbacks ; Definition at line 167 of file RWebWindow.hxx. ◆ fInputQueueMutex. std::mutex ROOT::RWebWindow::fInputQueueMutex. private . ! mutex to protect input queue ; Definition at line 168 of file RWebWindow.hxx. ◆ fMaster. std::shared_ptr<RWebWindow> ROOT::RWebWindow::fMaster. private . ! master window where this window is embedded ; Definition at line 140 of file RWebWindow.hxx. ◆ fMasterConns. std::vector<MasterConn> ROOT::RWebWindow::fMasterConns. private . ! master connections ; Definition at line 141 of file RWebWindow.hxx. ◆ fMaxQueueLength. unsigned ROOT::RWebWindow::fMaxQueueLength {10}. private . ! maximal number of queue entries ; Definition at line 159 of file RWebWindow.hxx. ◆ fMgr. std::shared_ptr<RWebWindowsManager> ROOT::RWebWindow::fMgr. private . ! display manager ; Definition at line 139 of file RWebWindow.hxx. ◆ fNativeOnlyConn. bool ROOT::RWebWindow::fNativeOnlyConn {false}. private . ! only native connection are allowed, created by Show() method ; Definition at line 157 of fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:54939,queue,queue,54939,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['queue'],['queue']
Performance,"ars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor; cout << ""deleting dataset "" << this << endl ;. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsData.html:14852,cache,cached,14852,root/html530/RooAbsData.html,https://root.cern,https://root.cern/root/html530/RooAbsData.html,1,['cache'],['cached']
Performance,"ars' control the dimensionality of the; function. Any additional dimensions present in 'dhist' will be projected out. RooDataHist dimensions; can be either real or discrete. See RooDataHist::RooDataHist for details on the binning.; RooHistFunc neither owns or clone 'dhist' and the user must ensure the input histogram exists; for the entire life span of this function. RooHistFunc(const RooHistFunc& other, const char* name = 0); Copy constructor. Double_t evaluate() const; Return the current value: The value of the bin enclosing the current coordinates; of the dependents, normalized by the histograms contents. Interpolation; is applied if the RooHistFunc is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooDataHist. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistFunc can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used, only the integral; over all RooHistPdf observables is implemented. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. TObject* clone(const char* newname) const; { return new RooHistFunc(*this,newname); }. virtual ~RooHistFunc(); { }. RooDataHist& dataHist(); Return RooDataHist that is represented. const RooDataHist& dataHist() const; Return RooDataHist that is represented. void setInterpo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHistFunc.html:34509,perform,perform,34509,root/html528/RooHistFunc.html,https://root.cern,https://root.cern/root/html528/RooHistFunc.html,1,['perform'],['perform']
Performance,"ars' control the dimensionality of the; function. Any additional dimensions present in 'dhist' will be projected out. RooDataHist dimensions; can be either real or discrete. See RooDataHist::RooDataHist for details on the binning.; RooHistFunc neither owns or clone 'dhist' and the user must ensure the input histogram exists; for the entire life span of this function. RooHistFunc(const RooHistFunc& other, const char* name = 0); Copy constructor. Double_t evaluate() const; Return the current value: The value of the bin enclosing the current coordinates; of the dependents, normalized by the histograms contents. Interpolation; is applied if the RooHistFunc is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooDataHist. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistFunc can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used, only the integral; over all RooHistPdf observables is implemented. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. TObject* clone(const char* newname) const; { return new RooHistFunc(*this,newname); }. virtual ~RooHistFunc(); { }. RooDataHist& dataHist(); Return RooDataHist that is represented. const RooDataHist& dataHist(); Return RooDataHist that is represented. void setInterpolation",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHistFunc.html:34268,perform,perform,34268,root/html526/RooHistFunc.html,https://root.cern,https://root.cern/root/html526/RooHistFunc.html,1,['perform'],['perform']
Performance,"ars' control the dimensionality of the; function. Any additional dimensions present in 'dhist' will be projected out. RooDataHist dimensions; can be either real or discrete. See RooDataHist::RooDataHist for details on the binning.; RooHistFunc neither owns or clone 'dhist' and the user must ensure the input histogram exists; for the entire life span of this function. RooHistFunc(const RooHistFunc& other, const char* name = 0); Copy constructor. Double_t evaluate() const; Return the current value: The value of the bin enclosing the current coordinates; of the dependents, normalized by the histograms contents. Interpolation; is applied if the RooHistFunc is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooDataHist. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistFunc can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used, only the integral; over all RooHistPdf observables is implemented. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHistFunc.html:35705,perform,perform,35705,root/html532/RooHistFunc.html,https://root.cern,https://root.cern/root/html532/RooHistFunc.html,1,['perform'],['perform']
Performance,"ars' control the dimensionality of the; function. Any additional dimensions present in 'dhist' will be projected out. RooDataHist dimensions; can be either real or discrete. See RooDataHist::RooDataHist for details on the binning.; RooHistFunc neither owns or clone 'dhist' and the user must ensure the input histogram exists; for the entire life span of this function. RooHistFunc(const RooHistFunc& other, const char* name = 0); Copy constructor. Double_t evaluate() const; Return the current value: The value of the bin enclosing the current coordinates; of the dependents, normalized by the histograms contents. Interpolation; is applied if the RooHistFunc is configured to do that. Double_t totVolume() const; Return the total volume spanned by the observables of the RooDataHist. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Determine integration scenario. If no interpolation is used,; RooHistFunc can perform all integrals over its dependents; analytically via partial or complete summation of the input; histogram. If interpolation is used, only the integral; over all RooHistPdf observables is implemented. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Return integral identified by 'code'. The actual integration; is deferred to RooDataHist::sum() which implements partial; or complete summation over the histograms contents. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. void Streamer(TBuffer& b); Stream an object of class RooHistFunc. TObject* clone(const char* newname) const; { return new RooHistFunc(*this,newname); }. virtual ~RooHistFunc(); { }. RooDataHist& dataHist(); Return RooDataHist that is represented. const RooDataHist& dataHis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooHistFunc.html:35026,perform,perform,35026,root/html530/RooHistFunc.html,https://root.cern,https://root.cern/root/html530/RooHistFunc.html,1,['perform'],['perform']
Performance,"ars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; Int_tRooAbsTestStatistic::numSets() const; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::operMode() const; virtual voidRooAbsArg::operModeHook(); voidRooAbsOptTestStatistic::optimizeCaching(); voidRooAbsOptTestStatistic::optimizeConstantTerms(Bool_t); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; virtual voidRooAbsOptTestStatistic::printCompactTreeHook(ostream& os, const char* indent = """"); virtual Bool_tRooAbsOptTestStatistic::redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChi2Var.html:29423,optimiz,optimizeConstantTerms,29423,root/html526/RooChi2Var.html,https://root.cern,https://root.cern/root/html526/RooChi2Var.html,12,['optimiz'],['optimizeConstantTerms']
Performance,"ars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; Int_tRooAbsTestStatistic::numSets() const; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::operMode() const; virtual voidRooAbsArg::operModeHook(); voidRooAbsOptTestStatistic::optimizeCaching(); voidRooAbsOptTestStatistic::optimizeConstantTerms(Bool_t); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; virtual voidRooAbsOptTestStatistic::printCompactTreeHook(ostream& os, const char* indent = """"); virtual Bool_tprocessEmptyDataSets() const; virtual Bool_tRooAbsOptTestStatistic::redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNLLVar.html:28824,optimiz,optimizeConstantTerms,28824,root/html526/RooNLLVar.html,https://root.cern,https://root.cern/root/html526/RooNLLVar.html,3,['optimiz'],['optimizeConstantTerms']
Performance,"ars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; Int_tRooAbsTestStatistic::numSets() const; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::operMode() const; virtual voidRooAbsArg::operModeHook(); voidRooAbsOptTestStatistic::optimizeCaching(); voidRooAbsOptTestStatistic::optimizeConstantTerms(Bool_t, Bool_t = kTRUE); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; virtual voidRooAbsOptTestStatistic::printCompactTreeHook(ostream& os, const char* indent = """"); virtual Bool_tRooAbsTestStatistic::processEmptyDataSets() const; virtual Bool_tRooAbsOptTestStatistic::redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); voidRooAbsArg::registerProxy(RooArgProxy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChi2Var.html:32753,optimiz,optimizeConstantTerms,32753,root/html534/RooChi2Var.html,https://root.cern,https://root.cern/root/html534/RooChi2Var.html,9,['optimiz'],['optimizeConstantTerms']
Performance,"ars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; Int_tRooAbsTestStatistic::numSets() const; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::operMode() const; virtual voidRooAbsArg::operModeHook(); voidRooAbsOptTestStatistic::optimizeCaching(); voidRooAbsOptTestStatistic::optimizeConstantTerms(Bool_t, Bool_t = kTRUE); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; virtual voidRooAbsOptTestStatistic::printCompactTreeHook(ostream& os, const char* indent = """"); virtual Bool_tprocessEmptyDataSets() const; virtual Bool_tRooAbsOptTestStatistic::redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNLLVar.html:32223,optimiz,optimizeConstantTerms,32223,root/html534/RooNLLVar.html,https://root.cern,https://root.cern/root/html534/RooNLLVar.html,3,['optimiz'],['optimizeConstantTerms']
Performance,"ars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; Int_tRooAbsTestStatistic::numSets() const; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::operMode() const; virtual voidRooAbsArg::operModeHook(); voidRooAbsOptTestStatistic::optimizeCaching(); voidRooAbsOptTestStatistic::optimizeConstantTerms(Bool_t, Bool_t = kTRUE); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; virtual voidRooAbsOptTestStatistic::printCompactTreeHook(ostream& os, const char* indent = """"); virtual Bool_tprocessEmptyDataSets() const; virtual Bool_tRooAbsOptTestStatistic::redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); voidRooAbsArg::registerProxy(RooArgProxy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNLLVar.html:30317,optimiz,optimizeConstantTerms,30317,root/html532/RooNLLVar.html,https://root.cern,https://root.cern/root/html532/RooNLLVar.html,1,['optimiz'],['optimizeConstantTerms']
Performance,"ars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& ); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooTreeDataStore.html:17730,cache,cached,17730,root/html534/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html,6,['cache'],['cached']
Performance,"arse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0.0, Double_t oneOverZeroError = 0.0, const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldSys.html:16940,perform,performs,16940,root/html534/TUnfoldSys.html,https://root.cern,https://root.cern/root/html534/TUnfoldSys.html,1,['perform'],['performs']
Performance,"arts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAttAxis(); Constructor. ~TAttAxis(); Destructor. void Copy(TAttAxis& attaxis) const; Copy of the object. void ResetAttAxis(Option_t* option = """"); Reset axis attributes. void SaveAttributes(ostream& out, const char* name, const char* subname); Save axis attributes as C++ statement(s) on output stream out. void SetAxisColor(Color_t color = 1); Set color of the line axis and tick marks. void SetLabelColor(Color_t color = 1); Set color of labels. void SetLabelFont(Style_t font = 62); Set labels' font. void SetLabelOffset(Float_t offset = 0.005); Set distance between the axis and the labels; The distance is expressed in per cent of the pad width. void SetLabelSize(Float_t size = 0.04); Set size of axis labels; The size is expressed in per cent of the pad width. void SetNdivisions(Int_t n = 510, Bool_t optim = kTRUE); Set the number of divisions for this axis. if optim = kTRUE (default), the number of divisions will be; optimized around the specified value.; if optim = kFALSE, or n < 0, the axis will be forced to use; exactly n divisions. n = n1 + 100*n2 + 10000*n3. Where n1 is the number of primary divisions,; n2 is the number of second order divisions and; n3 is the number of third order divisions. e.g. 512 means 12 primary and 5 secondary divisions. If the number of divisions is ""optimized"" (see above) n1, n2, n3 are; maximum values. void SetNdivisions(Int_t n1, Int_t n2, Int_t n3, Bool_t optim = kTRUE); see function above. void SetTickLength(Float_t length = 0.03); Set tick mark length; The length is expressed in per cent of the pad width. void SetTitleOffset(Float_t offset = 1); Set distance between the axis and the axis title; Offset is a correction factor with respect to the ""standard"" value.; offset = 1 uses the default position that is computed in function; of the label offset and size.; offset = 1.2 will add 20 per cent more to the default offset. void SetTitleSize(Float_t size =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAttAxis.html:3349,optimiz,optimized,3349,root/html526/TAttAxis.html,https://root.cern,https://root.cern/root/html526/TAttAxis.html,4,['optimiz'],['optimized']
Performance,"arts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsString(); Destructor. const char* getVal() const; Return value of object. Calculated if dirty, otherwise cached value is returned. Bool_t operator==(const char* value); Equality operator comparing with a TString. Bool_t operator==(const RooAbsArg& other); Equality operator comparing to another RooAbsArg. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) const; Print value. Bool_t isValid() const; Check if current value is valid. Bool_t isValidString(const char* , Bool_t printError = kFALSE) const; Check if given string value is valid. Bool_t traceEvalHook(const char* value) const; Hook function for trace evaluation. const char* traceEval() const; Calculate current value of object, with error tracing wrapper. void syncCache(const RooArgSet* nset = 0); Forcibly bring internal cache up-to-date. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy cache of another RooAbsArg to our cache. Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. void fillTreeBranch(TTree& t); Fill tree branch associated with this object. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooStringVar fundamental object with our properties. TString evaluate() const; { return """" ; }. » Last changed: Mon Dec 7 13:45:50 2009 » Last generated: 2009-12-07 13:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsString.html:19967,cache,cache,19967,root/html526/RooAbsString.html,https://root.cern,https://root.cern/root/html526/RooAbsString.html,5,['cache'],"['cache', 'cached']"
Performance,"ary dependencies have different consequences; depending on whether you try to build a binary, or you just try to access a class that is defined in a library.; 1.6.2.2 Linktime Library Dependencies; When building your own executable you will have to link against the libraries that contain the classes you use. The ROOT reference guide states the library a class is reference guide defined in. Almost all relevant classes can be found in libraries returned by root-config -glibs; the graphics libraries are retuned by root-config --libs. These commands are commonly used in Makefiles. Using root-config instead of enumerating the libraries by hand allows you to link them in a platform independent way. Also, if ROOT library names change you will not need to change your Makefile.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, only needs to link the core libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:22337,load,loads,22337,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loads']
Performance,"ary part of the output; ""MAG""- returns a histogram of the magnitude of the output; ""PH"" - returns a histogram of the phase of the output. - option of transform type; ""R2C"" - real to complex transforms - default; ""R2HC"" - real to halfcomplex (special format of storing output data,; results the same as for R2C); ""DHT"" - discrete Hartley transform; real to real transforms (sine and cosine):; ""R2R_0"", ""R2R_1"", ""R2R_2"", ""R2R_3"" - discrete cosine transforms of types I-IV; ""R2R_4"", ""R2R_5"", ""R2R_6"", ""R2R_7"" - discrete sine transforms of types I-IV; To specify the type of each dimension of a 2-dimensional real to real; transform, use options of form ""R2R_XX"", for example, ""R2R_02"" for a transform,; which is of type ""R2R_0"" in 1st dimension and ""R2R_2"" in the 2nd. - option of transform flag; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performance; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type. Default is ""ES"".; Examples of valid options: ""Mag R2C M"" ""Re R2R_11"" ""Im R2C ES"" ""PH R2HC EX"". Int_t Fill(Double_t x); -*-*-*-*-*-*-*-*Increment bin with abscissa X by 1*-*-*-*-*-*-*-*-*-*-*. if x is less than the low-edge of the first bin, the Underflow bin is incremented; if x is greater than the upper edge of last bin, the Overflow bin is incremented. If the storage of the sum of squares of weights has been triggered,; via the function Sumw2, then the sum of the squares of weights is incremented; by 1 in the bin corresponding to x. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. Int_t Fill(Double_t x, Double_t w); -*-*-*-*-*-*Increment bin with abscis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:65002,perform,performance,65002,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,4,['perform'],['performance']
Performance,"ary part of the output; ""MAG""- returns a histogram of the magnitude of the output; ""PH"" - returns a histogram of the phase of the output. - option of transform type; ""R2C"" - real to complex transforms - default; ""R2HC"" - real to halfcomplex (special format of storing output data,; results the same as for R2C); ""DHT"" - discrete Hartley transform; real to real transforms (sine and cosine):; ""R2R_0"", ""R2R_1"", ""R2R_2"", ""R2R_3"" - discrete cosine transforms of types I-IV; ""R2R_4"", ""R2R_5"", ""R2R_6"", ""R2R_7"" - discrete sine transforms of types I-IV; To specify the type of each dimension of a 2-dimensional real to real; transform, use options of form ""R2R_XX"", for example, ""R2R_02"" for a transform,; which is of type ""R2R_0"" in 1st dimension and ""R2R_2"" in the 2nd. - option of transform flag; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performance; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type. Default is ""ES"".; Examples of valid options: ""Mag R2C M"" ""Re R2R_11"" ""Im R2C ES"" ""PH R2HC EX"". Int_t Fill(Double_t x); Increment bin with abscissa X by 1. if x is less than the low-edge of the first bin, the Underflow bin is incremented; if x is greater than the upper edge of last bin, the Overflow bin is incremented. If the storage of the sum of squares of weights has been triggered,; via the function Sumw2, then the sum of the squares of weights is incremented; by 1 in the bin corresponding to x. The function returns the corresponding bin number which has its content incremented by 1. Int_t Fill(Double_t x, Double_t w); Increment bin with abscissa X with a weight w. if x is les",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:70836,perform,performance,70836,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,2,['perform'],['performance']
Performance,"ary. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); Open a connection to another host. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service. int AnnounceUdpService(int port, int backlog); Announce UDP service. i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSystem.html:35171,load,loaded,35171,root/html534/TSystem.html,https://root.cern,https://root.cern/root/html534/TSystem.html,3,['load'],['loaded']
Performance,"ary::ESTLTypeTDictionary::kUnorderedSet; static TDictionary::ESTLTypeTDictionary::kVector; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TClass*fClass!owning class; THashListfConstantListlist of constants the enum type; void*fInfo!interpreter implementation provided declaration; stringfQualNamefully qualified type name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEnum(const char* name, void* info, TClass* cls); Constructor for TEnum class.; It take the name of the TEnum type, specification if it is global; and interpreter info.; Constant List is owner if enum not on global scope (thus constants not; in TROOT::GetListOfGlobals). ~TEnum(); Destructor. void AddConstant(TEnumConstant* constant); Add a EnumConstant to the list of constants of the Enum Type. Bool_t IsValid(); Return true if this enum object is pointing to a currently; loaded enum. If a enum is unloaded after the TEnum; is created, the TEnum will be set to be invalid. Long_t Property() const; Get property description word. For meaning of bits see EProperty. void Update(TDictionary::DeclId_t id). TEnum * GetEnum(const std::type_info &ti, ESearchAction sa). TEnum * GetEnum(const char* enumName, TEnum::ESearchAction sa = kALoadAndInterpLookup); Static function to retrieve enumerator from the ROOT's typesystem.; It has no side effect, except when the load flag is true. In this case,; the load of the library containing the scope of the enumerator is attempted.; There are two top level code paths: the enumerator is scoped or isn't.; If it is not, a lookup in the list of global enums is performed.; If it is, two lookups are carried out for its scope: one in the list of; classes and one in the list of protoclasses. If a scope with the desired name; is found, the enum is searched. If the scope is not found, and the load flag i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEnum.html:8417,load,loaded,8417,root/html604/TEnum.html,https://root.cern,https://root.cern/root/html604/TEnum.html,1,['load'],['loaded']
Performance,"as $XDG_RUNTIME_DIR is defined to be user-specific as opposed to a system-wide directory.).; Otherwise, take the token from /tmp/bt_u$ID. Xrootd client support; ROOT can now be built with Xrootd 5 client libraries.; GUI Libraries; RBrowser improvements. central factory methods to handle browsing, editing and drawing of different classes; simple possibility to extend RBrowser on user-defined classes; support of web-based geometry viewer; better support of TTree drawing; server-side handling of code editor and image viewer widgets; rbrowser content is fully recovered when web-browser is reloaded; load of widgets code only when really required (shorter startup time for RBrowser). JavaScript ROOT; Major JSROOT update to version 6. update all used libraries d3.js, three.js, MathJax.js, openui5; change to Promise based interface for all async methods, remove call-back arguments; change scripts names, core scripts name now JSRoot.core.js; unify function/methods naming conventions, many changes in method names; provide central code loader via JSROOT.require, supporting 4 different loading engines; many nice features and many bug fixes; see JSROOT v6 release notes. Class Reference Guide; One can now select a class’s documentation for a specific version. If a class does not exist in a given version, that version is grayed out, see for instance the documentation for ROOT::Experimental::RNTupleReader.; Build, Configuration and Testing Infrastructure. a new cmake variable, CMAKE_INSTALL_PYTHONDIR, has been added: it allows customization of the installation directory of ROOT’s python modules; the developer build option asserts is introduced to enable/disable asserts via the NDEBUG C/CXX flag. Asserts are always enabled for CMAKE_BUILD_TYPE=Debug and dev=ON. The previous behavior of the builds set via the CMAKE_BUILD_TYPE variable has not changed.; CMAKE_CXX_STANDARD, i.e. the C++ standard ROOT is built with, now defaults to the compiler default (or C++11 if the compiler default i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:28926,load,loader,28926,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['load'],['loader']
Performance,"as been removed in favour of the faster evaluateSpan(). See section “RooFit Libraries” for instructions on how to use RooAbsReal::evaluateSpan().; TTreeProcessorMT::SetMaxTasksPerFilePerWorker has been deprecated in favour of TTreeProcessorMT::SetTasksPerWorkerHint. Header Dependency Reduction; As always, ROOT tries to reduce the amount of code exposed through its headers. To that end, #includes were replaced by forward declarations in several headers. This might cause compilation errors (“missing definition of type…”) in your code, if that code was relying on indirect includes, instead of including the required headers itself. Please correct that simply by including the required header directly.; Core Libraries; Due to internal changes required to comply with the deprecation of Intel TBB’s task_scheduler_init and related interfaces in recent TBB versions, as of v6.24 ROOT will not honor a maximum concurrency level set with tbb::task_scheduler_init but will require instead the usage of tbb::global_control:; //tbb::task_scheduler_init init(2); // does not affect the number of threads ROOT will use anymore. tbb::global_control c(tbb::global_control::max_allowed_parallelism, 2);; ROOT::TThreadExecutor p1; // will use 2 threads; ROOT::TThreadExecutor p2(/*nThreads=*/8); // will still use 2 threads; Note that the preferred way to steer ROOT’s concurrency level is still through ROOT::EnableImplicitMT or by passing the appropriate parameter to executors’ constructors, as in TThreadExecutor::TThreadExecutor.; See the discussion at ROOT-11014 for more context.; Dynamic Path: ROOT_LIBRARY_PATH; A new way to set ROOT’s “Dynamic Path” was added: the environment variable ROOT_LIBRARY_PATH. On Unix it should contain a colon separated list of paths, on Windows a semicolon separated list. It is intended to be cross platform and to be specific to ROOT (and thus not interfere with the system’s shared linker). The final “Dynamic Path” is now composed of these sources in order:. ROOT_L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:3527,concurren,concurrency,3527,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['concurren'],['concurrency']
Performance,"as been requested and is; possible (only 1 entry in this basket). Int_t ReadBasketBuffersUnzip(char* , Int_t , Bool_t , TFile* ); We always create the TBuffer for the basket but it hold the buffer from the cache. void inline InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of success, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get the unzipped file from the cache; receiving only a pointer to that buffer (so we shall not; delete that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory and cleanup. Read first bytes of a logical record starting at position pos; return record length (first 4 bytes of record). void Reset(); Reset the basket to the starting state. i.e. as it was after calling; the constructor (and potentially attaching a TBuffer.); Reduce memory used by fEntryOffset and the TBuffer if needed .. void SetReadMode(); Set read mode of basket. void SetWriteMode(); Set write mode of basket. void Streamer(TBuffer& ); Stream a class object. void Update(Int_t newlast, Int_t skipped); Update basket header and EntryOffset table. Int_t WriteBuffer(); Write buffer of this basket on the current file. The function returns the number of bytes committed to the memory.; If a write error occurs, the number of bytes returned is -1.; If no data are written, the number of bytes returned is 0. TBasket(const TBasket& ). TBasket& operator=(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBasket.html:11522,cache,cache,11522,root/html534/TBasket.html,https://root.cern,https://root.cern/root/html534/TBasket.html,3,['cache'],['cache']
Performance,"as been requested and is; possible (only 1 entry in this basket). Int_t ReadBasketBuffersUnzip(char* , Int_t , Bool_t , TFile* ); We always create the TBuffer for the basket but it hold the buffer from the cache. void inline InitializeCompressedBuffer(Int_t len, TFile* file); Initialize the compressed buffer; either from the TTree or create a local one. Int_t ReadBasketBuffers(Long64_t pos, Int_t len, TFile* file); Read basket buffers in memory and cleanup. Read a basket buffer. Check if buffers of previous ReadBasket; should not be dropped. Remember, we keep buffers in memory up to; fMaxVirtualSize.; The function returns 0 in case of success, 1 in case of error; This function was modified with the addition of the parallel; unzipping, it will try to get the unzipped file from the cache; receiving only a pointer to that buffer (so we shall not; delete that pointer), although we get a new buffer in case; it's not found in the cache.; There is a lot of code duplication but it was necesary to assure; the expected behavior when there is no cache. Int_t ReadBasketBytes(Long64_t pos, TFile* file); Read basket buffers in memory and cleanup. Read first bytes of a logical record starting at position pos; return record length (first 4 bytes of record). void Reset(); Reset the basket to the starting state. i.e. as it was after calling; the constructor (and potentially attaching a TBuffer.); Reduce memory used by fEntryOffset and the TBuffer if needed .. void SetReadMode(); Set read mode of basket. void SetWriteMode(); Set write mode of basket. void Streamer(TBuffer& b); Stream a class object. void Update(Int_t newlast, Int_t skipped); Update basket header and EntryOffset table. Int_t WriteBuffer(); Write buffer of this basket on the current file. The function returns the number of bytes committed to the memory.; If a write error occurs, the number of bytes returned is -1.; If no data are written, the number of bytes returned is 0. TBasket(const TBasket& ). TBasket& operator=(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBasket.html:11469,cache,cache,11469,root/html532/TBasket.html,https://root.cern,https://root.cern/root/html532/TBasket.html,1,['cache'],['cache']
Performance,"as graduated from the Nuclear Physics Department of Belorussian State University, where he also received his Ph.D. in Physics and Mathematics in 1999. Since 2002 Sergey working in GSI - heavy-ion research center in Darmstadt, Germany, developing software for data acquisition and online analysis for different experiments. From 2004 starts contributing to different ROOT components like I/O with XML, SQL, JSON, THttpServer, JavaScript ROOT. Currently is responsible for the development of new web-based GUIs in ROOT like RCanvas, REve, RFitPanel and many others.; ; . Stephan Hageboeck ; ; Stephan is a particle physicist, and obtained his Ph.D. at the university of Bonn in Germany. He worked in ATLAS to improve the sensitivity in the search for Higgs --> bb decays. His main focus was on analysis frameworks, machine learning, systematic uncertainties and statistical models.; He joined the ROOT team in 2018 to support and improve RooFit. He further looks into math and statistics, as well as into questions regarding performance and programming model.; ; . Vassil Vassilev ; ; Vassil graduated from the University of Plovdiv ""Paisii Hilendarski"", Bulgaria. He received a MSc in Software Technologies and a PhD in Computer Science with specialization in programming languages and visual programming. He joined the ROOT team in 2010, authoring Cling - the interactive, LLVM-based C++ interpreter. He was one of the core engineers involved in ROOT6.; Vassil is responsible for the implementation and adoption of clang's C++ modules (PCMs) in ROOT. He also helps with interpreter and reflection related activities in the ROOT project. He works on the CMS interests in the ROOT collaboration including development, trouble shooting, and any other activities as may be required.   ; From January, 2017, Vassil is employed by Princeton University and part of the Princeton Intel Parallel Computing Center (IPCC) project, which focuses on code modernization in ROOT.;  ; ; . Sitemap. DownloadDownload R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/team.html:10337,perform,performance,10337,d/team.html,https://root.cern,https://root.cern/d/team.html,1,['perform'],['performance']
Performance,"as(const char* aliasName, const char* aliasFormula); virtual voidSetAutoDelete(Bool_t autodel = kTRUE); virtual voidTTree::SetAutoFlush(Long64_t autof = -30000000); virtual voidTTree::SetAutoSave(Long64_t autos = 300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tSetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidSetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidSetCacheSize(Long64_t cacheSize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidSetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* elist, Option_t* opt = """"); virtual voidSetEntryListFile(const char* filename = """", Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidSetEventList(TEventList* evlist); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TChain.html:16523,cache,cacheSize,16523,root/html602/TChain.html,https://root.cern,https://root.cern/root/html602/TChain.html,1,['cache'],['cacheSize']
Performance,"as.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TH1.h""; using namespace RooFit;; ; void rf705_linearmorph(); {; // C r e a t e e n d p o i n t p d f s h a p e s; // ------------------------------------------------------; ; // Observable; RooRealVar x(""x"", ""x"", -20, 20);; ; // Lower end point shape: a Gaussian; RooRealVar g1mean(""g1mean"", ""g1mean"", -10);; RooGaussian g1(""g1"", ""g1"", x, g1mean, 2.0);; ; // Upper end point shape: a Polynomial; RooPolynomial g2(""g2"", ""g2"", x, RooArgSet(-0.03, -0.001));; ; // C r e a t e i n t e r p o l a t i n g p d f; // -----------------------------------------------; ; // Create interpolation variable; RooRealVar alpha(""alpha"", ""alpha"", 0, 1.0);; ; // Specify sampling density on observable and interpolation variable; x.setBins(1000, ""cache"");; alpha.setBins(50, ""cache"");; ; // Construct interpolating pdf in (x,a) represent g1(x) at a=a_min; // and g2(x) at a=a_max; RooIntegralMorph lmorph(""lmorph"", ""lmorph"", g1, g2, x, alpha);; ; // P l o t i n t e r p o l a t i n g p d f a t v a r i o u s a l p h a; // -----------------------------------------------------------------------------; ; // Show end points as blue curves; RooPlot *frame1 = x.frame();; g1.plotOn(frame1);; g2.plotOn(frame1);; ; // Show interpolated shapes in red; alpha.setVal(0.125);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.25);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.375);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.50);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.625);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.75);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.875);; lmorph.plotOn(frame1, LineColor(kRed));; alpha.setVal(0.95);; lmorph.plotOn(frame1, LineColor(kRed));; ; // S h o w 2 D d i s t r i b u t i o n o f p d f ( x , a l p h a ); // -----------------------------------------------------------------------; ; // Create 2D histogram; TH1 *hh = lmorph.createHistogram(""hh"", x, B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf705__linearmorph_8C.html:1285,cache,cache,1285,doc/master/rf705__linearmorph_8C.html,https://root.cern,https://root.cern/doc/master/rf705__linearmorph_8C.html,1,['cache'],['cache']
Performance,"as::ProcessedEvent ; (; Int_t ; event, . Int_t ; x, . Int_t ; y, . TObject * ; selected . ). virtual . Emit ProcessedEvent() signal. ; Definition at line 1651 of file TCanvas.cxx. ◆ RaiseWindow(). void TCanvas::RaiseWindow ; (; ). Raise canvas window. ; Definition at line 1742 of file TCanvas.cxx. ◆ ResetDrawn(). void TCanvas::ResetDrawn ; (; ). inline . Definition at line 192 of file TCanvas.h. ◆ ResetUpdated(). void TCanvas::ResetUpdated ; (; ). inline . Definition at line 193 of file TCanvas.h. ◆ Resize(). void TCanvas::Resize ; (; Option_t * ; option = """"). virtual . Recompute canvas parameters following a X11 Resize. ; Definition at line 1666 of file TCanvas.cxx. ◆ ResizeOpaque(). void TCanvas::ResizeOpaque ; (; Int_t ; set = 1). Set option to resize objects/pads in a canvas. . set = 1 (default) graphics objects are resized in opaque mode; set = 0 only the outline of objects is drawn when resizing them. The option opaque produces the best effect. It requires however a a reasonably fast workstation or response time. ; Definition at line 1757 of file TCanvas.cxx. ◆ RunAutoExec(). void TCanvas::RunAutoExec ; (; ). private . Execute the list of TExecs in the current pad. ; Definition at line 1765 of file TCanvas.cxx. ◆ SaveAll(). Bool_t TCanvas::SaveAll ; (; const std::vector< TPad * > & ; pads = {}, . const char * ; filename = """", . Option_t * ; option = """" . ). static . Save provided pads/canvases into the image file(s) Filename can include printf argument for image number - like ""image%03d.png"". ; In this case images: ""image000.png"", ""image001.png"", ""image002.png"" will be created. If pattern is not provided - it will be automatically inserted before extension except PDF and ROOT files. In last case PDF or ROOT file will contain all pads. Parameter option only used when output into PDF/PS files If TCanvas::SaveAll() called without arguments - all existing canvases will be stored in allcanvases.pdf file. ; Definition at line 2641 of file TCanvas.cxx. ◆ SavePrimiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCanvas.html:83760,response time,response time,83760,doc/v632/classTCanvas.html,https://root.cern,https://root.cern/doc/v632/classTCanvas.html,1,['response time'],['response time']
Performance,"as::ProcessedEvent ; (; Int_t ; event, . Int_t ; x, . Int_t ; y, . TObject * ; selected . ). virtual . Emit ProcessedEvent() signal. ; Definition at line 1653 of file TCanvas.cxx. ◆ RaiseWindow(). void TCanvas::RaiseWindow ; (; ). Raise canvas window. ; Definition at line 1744 of file TCanvas.cxx. ◆ ResetDrawn(). void TCanvas::ResetDrawn ; (; ). inline . Definition at line 192 of file TCanvas.h. ◆ ResetUpdated(). void TCanvas::ResetUpdated ; (; ). inline . Definition at line 193 of file TCanvas.h. ◆ Resize(). void TCanvas::Resize ; (; Option_t * ; option = """"). virtual . Recompute canvas parameters following a X11 Resize. ; Definition at line 1668 of file TCanvas.cxx. ◆ ResizeOpaque(). void TCanvas::ResizeOpaque ; (; Int_t ; set = 1). Set option to resize objects/pads in a canvas. . set = 1 (default) graphics objects are resized in opaque mode; set = 0 only the outline of objects is drawn when resizing them. The option opaque produces the best effect. It requires however a a reasonably fast workstation or response time. ; Definition at line 1759 of file TCanvas.cxx. ◆ RunAutoExec(). void TCanvas::RunAutoExec ; (; ). private . Execute the list of TExecs in the current pad. ; Definition at line 1767 of file TCanvas.cxx. ◆ SaveAll(). Bool_t TCanvas::SaveAll ; (; const std::vector< TPad * > & ; pads = {}, . const char * ; filename = """", . Option_t * ; option = """" . ). static . Save provided pads/canvases into the image file(s) Filename can include printf argument for image number - like ""image%03d.png"". ; In this case images: ""image000.png"", ""image001.png"", ""image002.png"" will be created. If pattern is not provided - it will be automatically inserted before extension except PDF and ROOT files. In last case PDF or ROOT file will contain all pads. Parameter option only used when output into PDF/PS files If TCanvas::SaveAll() called without arguments - all existing canvases will be stored in allcanvases.pdf file. ; Definition at line 2654 of file TCanvas.cxx. ◆ SavePrimiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCanvas.html:84136,response time,response time,84136,doc/master/classTCanvas.html,https://root.cern,https://root.cern/doc/master/classTCanvas.html,1,['response time'],['response time']
Performance,"as; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum TXMLSetup::EXMLLayout { kSpecialized; kGeneralized; };. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfCanUseCompact! flag indicate that basic type (like Int_t) can be placed in the same tag; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tfCompressLevel! compression level and algorithm; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; Int_tfErrorFlag!; TClass*fExpectedBaseClass! pointer to class, which should be stored as parent of current; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; Int_tfIOVersion! indicates format of ROOT xml file; TObjArray*fIdArray!; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TExMap*fObjMap!; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTXMLSetup::fRefCounter! counter , used to build id of xml references; TObjArrayfStack!; Bool_tTXMLSetup::fStoreStreamerInfos; TStringTXMLSetup::fStrBuf! buffer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferXML.html:23460,cache,cache,23460,root/html534/TBufferXML.html,https://root.cern,https://root.cern/root/html534/TBufferXML.html,1,['cache'],['cache']
Performance,"asColor() constDefinition TStyle.h:188; TStyle::GetPadBottomMarginFloat_t GetPadBottomMargin() constDefinition TStyle.h:211; TStyle::GetCanvasDefWInt_t GetCanvasDefW() constDefinition TStyle.h:192; TStyle::GetOptLogxInt_t GetOptLogx() constDefinition TStyle.h:247; TStyle::GetCanvasBorderModeInt_t GetCanvasBorderMode() constDefinition TStyle.h:190; TStyle::GetCanvasBorderSizeWidth_t GetCanvasBorderSize() constDefinition TStyle.h:189; TStyle::GetOptFitInt_t GetOptFit() constDefinition TStyle.h:244; TStyle::GetOptLogzInt_t GetOptLogz() constDefinition TStyle.h:249; TStyle::GetPadTopMarginFloat_t GetPadTopMargin() constDefinition TStyle.h:212; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TView::Classstatic TClass * Class(); TVirtualPSTVirtualPS is an abstract interface to Postscript, PDF, SVG.Definition TVirtualPS.h:30; TVirtualPadEditor::GetPadEditorstatic TVirtualPadEditor * GetPadEditor(Bool_t load=kTRUE)Returns the pad editor dialog. Static method.Definition TVirtualPadEditor.cxx:74; TVirtualPadPainterTo make it possible to use GL for 2D graphic in a TPad/TCanvas.Definition TVirtualPadPainter.h:19; TVirtualPadPainter::LockPaintervirtual void LockPainter()Empty definition.Definition TVirtualPadPainter.cxx:51; TVirtualPadPainter::PadPainterstatic TVirtualPadPainter * PadPainter(Option_t *opt="""")Create a pad painter of specified type.Definition TVirtualPadPainter.cxx:58; TVirtualPadPainter::SelectDrawablevirtual void SelectDrawable(Int_t device)=0; TVirtualPadPainter::InitPaintervirtual void InitPainter()Empty definition.Definition TVirtualPadPainter.cxx:37; TVirtualPad::TContextsmall helper class to store/restore gPad context in TPad methodsDefinition TVirtualPad.h:61; TVirtualPad::TContext::GetSavedauto GetSaved() constDefinition TVirtualPad.h:69; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:132951,load,load,132951,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['load'],['load']
Performance,"asMethod( const TString& datasetname, const TString& title ) const;; 133 ; 134 Bool_t Verbose( void ) const { return fVerbose; }; 135 void SetVerbose( Bool_t v=kTRUE );; 136 ; 137 // make ROOT-independent C++ class for classifier response; 138 // (classifier-specific implementation); 139 // If no classifier name is given, help messages for all booked; 140 // classifiers are printed; 141 virtual void MakeClass(const TString& datasetname , const TString& methodTitle = """" ) const;; 142 ; 143 // prints classifier-specific help messages, dedicated to; 144 // help with the optimisation and configuration options tuning.; 145 // If no classifier name is given, help messages for all booked; 146 // classifiers are printed; 147 void PrintHelpMessage(const TString& datasetname , const TString& methodTitle = """" ) const;; 148 ; 149 TDirectory* RootBaseDir() { return (TDirectory*)fgTargetFile; }; 150 ; 151 Bool_t IsSilentFile() const { return fSilentFile;}; 152 Bool_t IsModelPersistence() const { return fModelPersistence; }; 153 ; 154 Double_t GetROCIntegral(DataLoader *loader, TString theMethodName, UInt_t iClass = 0,; 155 Types::ETreeType type = Types::kTesting);; 156 Double_t GetROCIntegral(TString datasetname, TString theMethodName, UInt_t iClass = 0,; 157 Types::ETreeType type = Types::kTesting);; 158 ; 159 // Methods to get a TGraph for an indicated method in dataset.; 160 // Optional title and axis added with fLegend=kTRUE.; 161 // Argument iClass used in multiclass settings, otherwise ignored.; 162 TGraph *GetROCCurve(DataLoader *loader, TString theMethodName, Bool_t setTitles = kTRUE, UInt_t iClass = 0,; 163 Types::ETreeType type = Types::kTesting);; 164 TGraph *GetROCCurve(TString datasetname, TString theMethodName, Bool_t setTitles = kTRUE, UInt_t iClass = 0,; 165 Types::ETreeType type = Types::kTesting);; 166 ; 167 // Methods to get a TMultiGraph for a given class and all methods in dataset.; 168 TMultiGraph *GetROCCurveAsMultiGraph(DataLoader *loader, UInt_t iClass, Ty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html:6372,load,loader,6372,doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,1,['load'],['loader']
Performance,"asUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCurrentIDunique ID of current node; Int_tfGeoCacheMaxLevelsmaximum supported number of levels; Int_tfGeoCacheStackSizemaximum size of the stack; Int_tfGeoInfoStackSizemaximum size of the stack of info states; Int_tfIdBranch[100]current branch of indices; Int_tfIndexindex in array of ID's; TGeoStateInfo**fInfoBranchcurrent branch of nodes; Int_tfInfoLevelcurrent level in the stack; Int_tfLevellevel in the current branch; TGeoHMatrix**fMPBpre-built matrices; TGeoHMatrix*fMatrix! current matrix; TGeoHMatrix**fMatrixBranchcurrent branch of global matrices; TGeoNode*fNode! current node; TGeoNode**fNodeBranchcurrent branch of nodes; Int_t*fNodeIdArray! array of node id's; TGeoStateInfo*fPWInfo! State info for the parallel world; TStringfPathpath for current branch; TObjArray*fStackstack of cache states; Int_tfStackLevelcurrent level in the stack; TGeoNode*fToptop node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNodeCache(); Dummy constructor. TGeoNodeCache(TGeoNode* top, Bool_t nodeid = kFALSE, Int_t capacity = 30); Default constructor. ~TGeoNodeCache(); Destructor. void BuildIdArray(); Builds node id array. void BuildInfoBranch(); Bulds info branch. Navigation is possible only after this step. TGeoStateInfo * GetMakePWInfo(Int_t nd); Get the PW info, if none create one. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoNodeCache.html:8118,cache,cache,8118,root/html604/TGeoNodeCache.html,https://root.cern,https://root.cern/root/html604/TGeoNodeCache.html,1,['cache'],['cache']
Performance,"ase *smethod = dynamic_cast<TMVA::MethodBase *>(fMethodsMap[xbitset.to_string().c_str()][0][0]);; 2526 TMVA::ResultsClassification *sresults = (TMVA::ResultsClassification *)smethod->Data()->GetResults(; 2527 smethod->GetMethodName(), Types::kTesting, Types::kClassification);; 2528 delete sresults;; 2529 delete seedloader;; 2530 this->DeleteAllMethods();; 2531 fMethodsMap.clear();; 2532 ; 2533 // removing global result because it is requiring a lot of RAM for all seeds; 2534 ; 2535 for (uint32_t i = 0; i < 32; ++i) {; 2536 if (x & (uint64_t(1) << i)) {; 2537 y = x & ~(1 << i);; 2538 std::bitset<32> ybitset(y);; 2539 // need at least one variable; 2540 // NOTE: if sub-seed is zero then is the special case; 2541 // that count in xbitset is 1; 2542 Double_t ny = log(x - y) / 0.693147;; 2543 if (y == 0) {; 2544 importances[ny] = SROC - 0.5;; 2545 // std::cout << ""SubSeed: "" << y << "" y:"" << ybitset << ""ROC "" << 0.5 << std::endl;; 2546 continue;; 2547 }; 2548 ; 2549 // creating loader for sub-seed; 2550 TMVA::DataLoader *subseedloader = new TMVA::DataLoader(ybitset.to_string());; 2551 // adding variables from sub-seed; 2552 for (int index = 0; index < nbits; index++) {; 2553 if (ybitset[index]); 2554 subseedloader->AddVariable(varNames[index], 'F');; 2555 }; 2556 ; 2557 // Loading Dataset; 2558 DataLoaderCopy(subseedloader, loader);; 2559 ; 2560 // Booking SubSeed; 2561 BookMethod(subseedloader, theMethod, methodTitle, theOption);; 2562 ; 2563 // Train/Test/Evaluation; 2564 TrainAllMethods();; 2565 TestAllMethods();; 2566 EvaluateAllMethods();; 2567 ; 2568 // getting ROC; 2569 SSROC = GetROCIntegral(ybitset.to_string(), methodTitle);; 2570 importances[ny] += SROC - SSROC;; 2571 // std::cout << ""SubSeed: "" << y << "" y:"" << ybitset << "" x-y "" << x - y << "" "" << std::bitset<32>(x - y) <<; 2572 // "" ny "" << ny << "" SROC "" << SROC << "" SSROC "" << SSROC << "" Importance = "" << importances[ny] <<; 2573 // std::endl; cleaning information; 2574 TMVA::MethodBase *ssmethod =; 2575 d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:105553,load,loader,105553,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance,"ase of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called everytime a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function; accepting a TSelector* as argument.eg; MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);. NOTE2; One should not call this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; }; or use ACLIC to compile the selector; workaround 2. void stubs2() {; TFile *f1 = new TFile(""st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:108032,load,loaded,108032,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,3,['load'],['loaded']
Performance,"ase of error. Int_t UploadPackageOnClient(const char* package, TProof::EUploadPackageOpt opt, TMD5* md5); Upload a package on the client in ~/.proof/packages.; The 'opt' allows to specify whether the .PAR should be just unpacked; in the existing dir (opt = kUntar, default) or a remove of the existing; directory should be executed (opt = kRemoveOld), thereby triggering a full; re-build. This option if effective only for PROOF protocol > 8.; Returns 0 in case of success and -1 in case of error. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Load the specified macro on master, workers and, if notOnClient is; kFALSE, on the client. The macro file is uploaded if new or updated.; If existing, the corresponding header basename(macro).h or .hh, is also; uploaded. The default is to load the macro also on the client.; On masters, if uniqueWorkers is kTRUE, the macro is loaded on unique workers; only, and collection is not done; if uniqueWorkers is kFALSE, collection; from the previous request is done, and broadcasting + collection from the; other workers is done.; The wrks arg can be used on the master to limit the set of workers.; Returns 0 in case of success and -1 in case of error. Int_t AddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0); Add 'libpath' to the lib path search.; Multiple paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. Int_t AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0); Add 'incpath' to the inc path search.; Multiple paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. Int_t RemoveDynamicPath(const char* libpath, Bool_t onClient = kFALSE); Remove 'libpath' from the lib path search.; Multiple paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. Int_t RemoveIncludePath(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:68080,load,loaded,68080,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,1,['load'],['loaded']
Performance,"ase of failure.; Note: This is the overloading made in TXNetFile, If ReadBuffers; is supported by xrootd it will try to gt the whole list from one single; call avoiding the latency of multiple calls. Bool_t WriteBuffer(const char* buffer, Int_t BufferLength); Override TNetFile::WriteBuffer to deal with the xrootd server.; Returns kTRUE in case of errors. void Init(Bool_t create); Initialize the file. Makes sure that the file is really open before; calling TFile::Init. It may block. Bool_t IsOpen() const; Return kTRUE if the file is open, kFALSE otherwise. TFile::EAsyncOpenStatus GetAsyncOpenStatus(); Return status of asynchronous request. Int_t ReOpen(Option_t* mode); Re-open the file (see TNetFile::ReOpen() or TFile::ReOpen(); for more details). void Close(Option_t* opt = """"); Close the file (see TNetFile::Close() or TFile::Close(); for more details). void Flush(); Flushes un-written data. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Override TNetFile::SysStat (see parent's method for more details). Int_t SysClose(Int_t fd); Override TNetFile::SysClose (see parent's method for more details). Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Override TNetFile::SysOpen (see parent's method for more details). void SetEnv(); Set the relevant environment variables. void SynchronizeCacheSize(); Synchronize the cache size; Alternative purging policy. void ResetCache(); Reset the cache. Int_t GetBytesToPrefetch() const; Max number of bytes to prefetch. void Print(Option_t* option = """") const; Print the local statistics. TXNetFile(const TXNetFile& ); attempts to Init() for this object only; Methods. TXNetFile& operator=(const TXNetFile& ). TXNetFile(); {}. » Last changed: root/netx:$Id: TXNetFile.h 34444 2010-07-16 02:17:39Z pcanal $ » Last generated: 2010-11-29 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetFile.html:28719,cache,cache,28719,root/html528/TXNetFile.html,https://root.cern,https://root.cern/root/html528/TXNetFile.html,2,['cache'],['cache']
Performance,"ase of failure.; Note: This is the overloading made in TXNetFile, If ReadBuffers; is supported by xrootd it will try to gt the whole list from one single; call avoiding the latency of multiple calls. Bool_t WriteBuffer(const char* buffer, Int_t BufferLength); Override TNetFile::WriteBuffer to deal with the xrootd server.; Returns kTRUE in case of errors. void Init(Bool_t create); Initialize the file. Makes sure that the file is really open before; calling TFile::Init. It may block. Bool_t IsOpen() const; Return kTRUE if the file is open, kFALSE otherwise. TFile::EAsyncOpenStatus GetAsyncOpenStatus(); Return status of asynchronous request. Int_t ReOpen(Option_t* mode); Re-open the file (see TNetFile::ReOpen() or TFile::ReOpen(); for more details). void Close(Option_t* opt = """"); Close the file (see TNetFile::Close() or TFile::Close(); for more details). void Flush(); Flushes un-written data. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Override TNetFile::SysStat (see parent's method for more details). Int_t SysClose(Int_t fd); Override TNetFile::SysClose (see parent's method for more details). Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Override TNetFile::SysOpen (see parent's method for more details). void SetEnv(); Set the relevant environment variables. void SynchronizeCacheSize(); Synchronize the cache size; Alternative purging policy. void ResetCache(); Reset the cache. Int_t GetBytesToPrefetch() const; Max number of bytes to prefetch. void Print(Option_t* option = """") const; Print the local statistics. TXNetFile(const TXNetFile& ); attempts to Init() for this object only; Methods. TXNetFile& operator=(const TXNetFile& ). TXNetFile(); {}. » Last changed: root/netx:$Id: TXNetFile.h 34444 2010-07-16 02:17:39Z pcanal $ » Last generated: 2011-07-04 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXNetFile.html:28973,cache,cache,28973,root/html530/TXNetFile.html,https://root.cern,https://root.cern/root/html530/TXNetFile.html,2,['cache'],['cache']
Performance,"ase of missing TTreeIndex, the resulting TTree index has gaps.; 3532/// - BuildIndexOnError : If any of the underlying TTree objects do not have a TTreeIndex,; 3533/// all TTreeIndex are 'ignored' and the missing piece are rebuilt.; 3534 ; 3535Long64_t TTree::CopyEntries(TTree* tree, Long64_t nentries /* = -1 */, Option_t* option /* = """" */, bool needCopyAddresses /* = false */); 3536{; 3537 if (!tree) {; 3538 return 0;; 3539 }; 3540 // Options; 3541 TString opt = option;; 3542 opt.ToLower();; 3543 bool fastClone = opt.Contains(""fast"");; 3544 bool withIndex = !opt.Contains(""noindex"");; 3545 EOnIndexError onIndexError;; 3546 if (opt.Contains(""asisindex"")) {; 3547 onIndexError = kKeep;; 3548 } else if (opt.Contains(""buildindex"")) {; 3549 onIndexError = kBuild;; 3550 } else if (opt.Contains(""dropindex"")) {; 3551 onIndexError = kDrop;; 3552 } else {; 3553 onIndexError = kBuild;; 3554 }; 3555 Ssiz_t cacheSizeLoc = opt.Index(""cachesize="");; 3556 Long64_t cacheSize = -1;; 3557 if (cacheSizeLoc != TString::kNPOS) {; 3558 // If the parse faile, cacheSize stays at -1.; 3559 Ssiz_t cacheSizeEnd = opt.Index("" "",cacheSizeLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:140595,cache,cachesize,140595,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,4,['cache'],"['cacheSize', 'cacheSizeLoc', 'cachesize']"
Performance,"ase of success and -1 in case of error.; Provided for backward compatibility. Int_t EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; It is is possible to specify options for the loading step via 'loadopts';; the string will be passed passed as argument to SETUP.; Returns 0 in case of success and -1 in case of error. Int_t EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; It is is possible to specify a list of objects to be passed to the SETUP; functions via 'loadopts'; the objects must be streamable.; Returns 0 in case of success and -1 in case of error. Int_t DownloadPackage(const char* par, const char* dstdir = 0); Download a PROOF archive (PAR file) from the master package repository.; The PAR file is downloaded in the current directory or in the directory; specified by 'dstdir'. If a package with the same name already exists; at destination, a check on the MD5 sum is done and the user warned or; prompted for action, depending is the file is equal or different.; Returns 0 in case of success and -1 in case of error. Int_t UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar); Upload a PROOF archive (PAR file). A PAR file is a compressed; tar file with one special additional directory, PROOF-INF; (blatantly copied from Java's jar format). It must have the extension; .par. A PAR file can be directly a binary or a source with a build; procedure. In the PROOF-INF directory there can be a build script:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:65341,load,loadopts,65341,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,3,['load'],['loadopts']
Performance,"ase, 1 when this a split clases inside a TClonesArray, 2 when this is a split classes inside an STL container. More...;  . Functions; tbb::isolated_task_group * CastToTG (void *p);  ; bool ContaineeInheritsFrom (TClass *cl, TClass *base);  Return true if 'cl' inherits from 'base'. ;  ; void DefaultStreamer (TBuffer &R__b, const TClass *cl, void *objpointer);  Default streamer implementation used by ClassDefInline to avoid requirement to include TBuffer.h. ;  ; const TQObjectInitBehavior * DefineBehavior (TQObject *, TQObject *);  ; const TInitBehavior * DefineBehavior (void *, void *);  ; bool DeleteChangesMemory ();  ; bool DeleteChangesMemoryImpl ();  ; void DisableParBranchProcessing ();  Globally disables the IMT use case of parallel branch processing, deactivating the corresponding locks. ;  ; const TCollection & EmptyCollection ();  Return an empty collection for use with nullptr TRangeCast. ;  ; void EnableParBranchProcessing ();  Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in ROOT, activating the required locks. ;  ; void EvalParMultiDim (TF1 *func, Double_t *out, const Double_t *x, std::size_t size, std::size_t rows, Double_t *params);  ; void GenericShowMembers (const char *topClassName, void *obj, TMemberInspector &R__insp, bool transientMember);  ; TString GetArrayType (TStreamerElement *element, const char *subtype, TTreeProxyGenerator::EContainer container);  ; template<typename T > ; TClass * GetClassHelper (Bool_t load, Bool_t silent, std::false_type);  ; template<typename T > ; TClass * GetClassHelper (Bool_t, Bool_t, std::true_type);  ; std::string GetDemangledTypeName (const std::type_info &t);  ; ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler ();  ; std::shared_ptr< ROOT::Internal::RTaskArenaWrapper > GetGlobalTaskArena (unsigned maxConcurrency=0);  Factory function returning a shared pointer to the instance of the global RTaskArenaWrapper. ;  ; TROOT * GetROOT1 ();  ; TROOT * GetROOT2 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal.html:13475,multi-thread,multi-threading,13475,doc/master/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal.html,1,['multi-thread'],['multi-threading']
Performance,"ase, 1 when this a split clases inside a TClonesArray, 2 when this is a split classes inside an STL container. More...;  . Functions; tbb::isolated_task_group * CastToTG (void *p);  ; bool ContaineeInheritsFrom (TClass *cl, TClass *base);  Return true if 'cl' inherits from 'base'. ;  ; void DefaultStreamer (TBuffer &R__b, const TClass *cl, void *objpointer);  Default streamer implementation used by ClassDefInline to avoid requirement to include TBuffer.h. ;  ; const TQObjectInitBehavior * DefineBehavior (TQObject *, TQObject *);  ; const TInitBehavior * DefineBehavior (void *, void *);  ; bool DeleteChangesMemory ();  ; bool DeleteChangesMemoryImpl ();  ; void DisableParBranchProcessing ();  Globally disables the IMT use case of parallel branch processing, deactivating the corresponding locks. ;  ; const TCollection & EmptyCollection ();  Return an empty collection for use with nullptr TRangeCast. ;  ; void EnableParBranchProcessing ();  Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in ROOT, activating the required locks. ;  ; void GenericShowMembers (const char *topClassName, void *obj, TMemberInspector &R__insp, bool transientMember);  ; TString GetArrayType (TStreamerElement *element, const char *subtype, TTreeProxyGenerator::EContainer container);  ; template<typename T > ; TClass * GetClassHelper (Bool_t load, Bool_t silent, std::false_type);  ; template<typename T > ; TClass * GetClassHelper (Bool_t, Bool_t, std::true_type);  ; std::string GetDemangledTypeName (const std::type_info &t);  ; ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler ();  ; std::shared_ptr< ROOT::Internal::RTaskArenaWrapper > GetGlobalTaskArena (unsigned maxConcurrency=0);  Factory function returning a shared pointer to the instance of the global RTaskArenaWrapper. ;  ; TROOT * GetROOT1 ();  ; TROOT * GetROOT2 ();  ; static Func_t GetSymInLibImt (const char *funcname);  ; template<typename T , typename F > ; auto GetTheRightOp (T(F::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html:13337,multi-thread,multi-threading,13337,doc/v632/namespaceROOT_1_1Internal.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Internal.html,1,['multi-thread'],['multi-threading']
Performance,"ase::fObjectvoid * fObjectDefinition TCollectionProxyInfo.h:234; ROOT::Detail::TCollectionProxyInfo::EnvironSmall helper to save proxy environment in the event of recursive calls.Definition TCollectionProxyInfo.h:244; TGenCollectionProxy::ValueSmall helper to describe the Value_type or the key_type of an STL container.Definition TGenCollectionProxy.h:60; TGenCollectionProxy::Value::DeleteItemvoid DeleteItem(void *ptr)Definition TGenCollectionProxy.cxx:518; TGenCollectionProxy::Value::fCaseUInt_t fCasetype of data of Value_typeDefinition TGenCollectionProxy.h:64; TGenCollectionProxy::Value::fTypeTClassRef fTypeTClass reference of Value_type in collection.Definition TGenCollectionProxy.h:66; TGenCollectionProxy::Value::fPropertiesUInt_t fPropertiesAdditional properties of the value type (kNeedDelete)Definition TGenCollectionProxy.h:65; TGenCollectionProxy::Value::fSizesize_t fSizefSize of the contained objectDefinition TGenCollectionProxy.h:68; TGenCollectionProxy::Value::fDeleteROOT::DelFunc_t fDeleteMethod cache for containee delete.Definition TGenCollectionProxy.h:63; TGenCollectionProxy::Value::fDtorROOT::DesFunc_t fDtorMethod cache for containee destructor.Definition TGenCollectionProxy.h:62; TGenCollectionProxy::Value::fCtorROOT::NewFunc_t fCtorMethod cache for containee constructor.Definition TGenCollectionProxy.h:61; TGenCollectionProxy::Value::ValueValue(const std::string &info, Bool_t silent, size_t hint_pair_offset=0, size_t hint_pair_size=0)Constructor.Definition TGenCollectionProxy.cxx:316; TGenCollectionProxy::Value::fKindEDataType fKindkind of ROOT-fundamental typeDefinition TGenCollectionProxy.h:67; TGenCollectionProxy::Value::IsValidBool_t IsValid()Return true if the Value has been properly initialized.Definition TGenCollectionProxy.cxx:511; TGenCollectionProxy__SlowIteratorDefinition TGenCollectionProxy.cxx:1454; TGenCollectionProxy__SlowIterator::fProxyTVirtualCollectionProxy * fProxyDefinition TGenCollectionProxy.cxx:1455; TGenCollectionProxy__Slow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:98018,cache,cache,98018,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['cache'],['cache']
Performance,"aseFunc;  ; typedef IGradientFunctionOneDim BaseGrad;  . Public Member Functions;  WrappedTF1 (const WrappedTF1 &rhs);  Copy constructor. ;  ;  WrappedTF1 (TF1 &f);  constructor from a TF1 function pointer. ;  ;  ~WrappedTF1 () override;  Destructor (no operations). ;  ; WrappedTF1 & operator= (const WrappedTF1 &rhs);  Assignment operator. ;  ; interface inherited from IFunction; ROOT::Math::IGenFunction * Clone () const override;  Clone the wrapper but not the original function. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricGradFunctionOneDim;  ~IParametricGradFunctionOneDim () override;  Virtual Destructor (no operations) ;  ; double ParameterDerivative (const double *x, const double *p, unsigned int ipar=0) const;  Partial derivative with respect a parameter Compatibility interface with multi-dimensional functions. ;  ; double ParameterDerivative (const double *x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values (multi-dim like interface) ;  ; double ParameterDerivative (double x, const double *p, unsigned int ipar=0) const;  Partial derivative with respect a parameter. ;  ; double ParameterDerivative (double x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values. ;  ; void ParameterGradient (const double *x, const double *p, double *grad) const;  Compatibility interface with multi-dimensional functions. ;  ; void ParameterGradient (const double *x, double *grad) const;  Evaluate all derivatives using cached parameter values (multi-dim like interface) ;  ; void ParameterGradient (double x, double *grad) const;  Evaluate all derivatives using cached parameter values. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricFunctionOneDim; double operator() (const double *x, const double *p) const;  multidim-like interface ;  ; double operator() (double x, const double *p) const;  Evaluate function at a point x and for given parameters p. ;  ;  Public Member Fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedTF1.html:2424,cache,cached,2424,doc/master/classROOT_1_1Math_1_1WrappedTF1.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedTF1.html,1,['cache'],['cached']
Performance,"aseFunc BaseFunc;  ; typedef IGradientFunctionOneDim BaseGradFunc;  ; typedef IParametricFunctionOneDim BaseParamFunc;  ;  Public Types inherited from ROOT::Math::IParametricFunctionOneDim; typedef IBaseFunctionOneDim BaseFunc;  ;  Public Types inherited from ROOT::Math::IBaseFunctionOneDim; typedef IBaseFunctionOneDim BaseFunc;  . Public Member Functions;  ~IParametricGradFunctionOneDim () override;  Virtual Destructor (no operations) ;  ; double ParameterDerivative (const double *x, const double *p, unsigned int ipar=0) const;  Partial derivative with respect a parameter Compatibility interface with multi-dimensional functions. ;  ; double ParameterDerivative (const double *x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values (multi-dim like interface) ;  ; double ParameterDerivative (double x, const double *p, unsigned int ipar=0) const;  Partial derivative with respect a parameter. ;  ; double ParameterDerivative (double x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values. ;  ; void ParameterGradient (const double *x, const double *p, double *grad) const;  Compatibility interface with multi-dimensional functions. ;  ; void ParameterGradient (const double *x, double *grad) const;  Evaluate all derivatives using cached parameter values (multi-dim like interface) ;  ; virtual void ParameterGradient (double x, const double *p, double *grad) const;  Evaluate the derivatives of the function with respect to the parameters at a point x. ;  ; void ParameterGradient (double x, double *grad) const;  Evaluate all derivatives using cached parameter values. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricFunctionOneDim; double operator() (const double *x, const double *p) const;  multidim-like interface ;  ; double operator() (double x, const double *p) const;  Evaluate function at a point x and for given parameters p. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricGradFunctionOneDim.html:2029,cache,cached,2029,doc/master/classROOT_1_1Math_1_1IParametricGradFunctionOneDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricGradFunctionOneDim.html,1,['cache'],['cached']
Performance,aset[dataset] : Create results for testing; : Dataset[dataset] : Multiclass evaluation of MLP on testing sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 0.0114 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; Factory : Test method: PDEFoam for Multiclass classification performance; : ; : Dataset[dataset] : Create results for testing; : Dataset[dataset] : Multiclass evaluation of PDEFoam on testing sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 0.122 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; Factory : Test method: DL_CPU for Multiclass classification performance; : ; : Dataset[dataset] : Create results for testing; : Dataset[dataset] : Multiclass evaluation of DL_CPU on testing sample; : Dataset[dataset] : Elapsed time for evaluation of 4000 events: 0.105 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; Factory : ␛[1mEvaluate all methods␛[0m; : Evaluate multiclass classification method: BDTG; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; TFHandler_BDTG : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.070153 1.0224 [ -4.0592 3.5808 ]; : var2: 0.30372 1.0460 [ -3.6952 3.7877 ]; : var3: 0.12152 1.1222 [ -3.6800 3.9200 ]; : var4: -0.072602 1.2766 [ -4.8486 4.2221 ]; : -----------------------------------------------------------; : Evaluate multiclass classification method: MLP; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; TFHandler_MLP : Variable Mean RMS [ Min Max ]; : ------------------------------------------------------,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:20785,perform,performance,20785,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['perform'],['performance']
Performance,"ash->GetListForObject (resolvedThis));; 1668 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1669 if (resolvedThis == htmp->String() && htmp->fOrigName == GetName()) {; 1670 fgClassTypedefHash->Remove (htmp);; 1671 delete htmp;; 1672 break;; 1673 }; 1674 }; 1675 }; 1676 ; 1677 // Not owning lists, don't call Delete(); 1678 // But this still need to be done first because the TList destructor; 1679 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1680 delete fStreamer; fStreamer =nullptr;; 1681 delete fAllPubData; fAllPubData =nullptr;; 1682 delete fAllPubMethod; fAllPubMethod=nullptr;; 1683 ; 1684 delete fPersistentRef.load();; 1685 ; 1686 if (fBase.load()); 1687 (*fBase).Delete();; 1688 delete fBase.load(); fBase = nullptr;; 1689 ; 1690 if (fData.load()); 1691 (*fData).Delete();; 1692 delete fData.load(); fData = nullptr;; 1693 ; 1694 if (fUsingData.load()); 1695 (*fUsingData).Delete();; 1696 delete fUsingData.load(); fUsingData = nullptr;; 1697 ; 1698 if (fEnums.load()); 1699 (*fEnums).Delete();; 1700 delete fEnums.load(); fEnums = nullptr;; 1701 ; 1702 if (fFuncTemplate); 1703 fFuncTemplate->Delete();; 1704 delete fFuncTemplate; fFuncTemplate = nullptr;; 1705 ; 1706 if (fMethod.load()); 1707 (*fMethod).Delete();; 1708 delete fMethod.load(); fMethod=nullptr;; 1709 ; 1710 if (fRealData); 1711 fRealData->Delete();; 1712 delete fRealData; fRealData=nullptr;; 1713 ; 1714 if (fStreamerInfo); 1715 fStreamerInfo->Delete();; 1716 delete fStreamerInfo; fStreamerInfo = nullptr;; 1717 ; 1718 if (fDeclFileLine >= -1); 1719 TClass::RemoveClass(this);; 1720 ; 1721 gCling->ClassInfo_Delete(fClassInfo);; 1722 fClassInfo=nullptr;; 1723 ; 1724 if (fClassMenuList); 1725 fClassMenuList->Delete();; 1726 delete fClassMenuList; fClassMenuList=nullptr;; 1727 ; 1728 fIsOffsetStreamerSet=kFALSE;; 1729 ; 1730 if ( fIsA ) delete fIsA;; 1731 ; 1732 if ( fRefProxy ) fRefProxy->Release();; 1733 fRefProxy = nullptr;; 1734 ; 1735 delete fStreamer;; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:65264,load,load,65264,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"ash->GetListForObject (resolvedThis));; 1735 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1736 if (resolvedThis == htmp->String() && htmp->fOrigName == GetName()) {; 1737 fgClassTypedefHash->Remove (htmp);; 1738 delete htmp;; 1739 break;; 1740 }; 1741 }; 1742 }; 1743 ; 1744 // Not owning lists, don't call Delete(); 1745 // But this still need to be done first because the TList destructor; 1746 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1747 delete fStreamer; fStreamer =nullptr;; 1748 delete fAllPubData; fAllPubData =nullptr;; 1749 delete fAllPubMethod; fAllPubMethod=nullptr;; 1750 ; 1751 delete fPersistentRef.load();; 1752 ; 1753 if (fBase.load()); 1754 (*fBase).Delete();; 1755 delete fBase.load(); fBase = nullptr;; 1756 ; 1757 if (fData.load()); 1758 (*fData).Delete();; 1759 delete fData.load(); fData = nullptr;; 1760 ; 1761 if (fUsingData.load()); 1762 (*fUsingData).Delete();; 1763 delete fUsingData.load(); fUsingData = nullptr;; 1764 ; 1765 if (fEnums.load()); 1766 (*fEnums).Delete();; 1767 delete fEnums.load(); fEnums = nullptr;; 1768 ; 1769 if (fFuncTemplate); 1770 fFuncTemplate->Delete();; 1771 delete fFuncTemplate; fFuncTemplate = nullptr;; 1772 ; 1773 if (fMethod.load()); 1774 (*fMethod).Delete();; 1775 delete fMethod.load(); fMethod=nullptr;; 1776 ; 1777 if (fRealData); 1778 fRealData->Delete();; 1779 delete fRealData; fRealData=nullptr;; 1780 ; 1781 if (fStreamerInfo); 1782 fStreamerInfo->Delete();; 1783 delete fStreamerInfo; fStreamerInfo = nullptr;; 1784 ; 1785 if (fDeclFileLine >= -1); 1786 TClass::RemoveClass(this);; 1787 ; 1788 gCling->ClassInfo_Delete(fClassInfo);; 1789 fClassInfo=nullptr;; 1790 ; 1791 if (fClassMenuList); 1792 fClassMenuList->Delete();; 1793 delete fClassMenuList; fClassMenuList=nullptr;; 1794 ; 1795 fIsOffsetStreamerSet=kFALSE;; 1796 ; 1797 if ( fIsA ) delete fIsA;; 1798 ; 1799 if ( fRefProxy ) fRefProxy->Release();; 1800 fRefProxy = nullptr;; 1801 ; 1802 delete fStreamer;; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:68015,load,load,68015,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"ashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 548 of file RooAddPdf.cxx. ◆ updateCoefficients(). void RooAddPdf::updateCoefficients ; (; AddCacheElem & ; cache, . const RooArgSet * ; nset, . bool ; syncCoefValues = true . ); const. protected . Update the coefficient values in the given cache element: calculate new remainder fraction, normalize fractions obtained from extended ML terms to unity, and multiply the various range and dimensional corrections needed in the current use context. ; param[in] cache The cache element for the given normalization set that stores the supplementary normalization values and projection-related objects. param[in] nset The set of variables to normalize over. param[in] syncCoefValues If the initial values of the coefficients still need to be copied from the _coefList elements to the _coefCache. True by default. ; Definition at line 442 of file RooAddPdf.cxx. Friends And Related Symbol Documentation. ◆ RooAddGenContext. friend class RooAddGenContext. friend . Definition at line 115 of file RooAddPdf.h. ◆ RooAddModel. friend class RooAddModel. friend . Definition at line 116 of file RooAddPdf.h. Member Data Documentation. ◆ _allExtendable. bool RooAddPdf::_allExtendable = false. protected . Flag indicating if all PDF components are extendable. ; Definition at line 136 of file RooAddPdf.h. ◆ _codeReg. RooAICRegistry Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:95476,cache,cache,95476,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,2,['cache'],['cache']
Performance,"ashes are mandatory); 16/// If no method given, a default set is used.; 17///; 18/// The output file ""TMVAReg.root"" can be analysed with the use of dedicated; 19/// macros (simply say: root -l <macro.C>), which can be conveniently; 20/// invoked through a GUI that will appear at the end of the run of this macro.; 21/// - Project : TMVA - a Root-integrated toolkit for multivariate data analysis; 22/// - Package : TMVA; 23/// - Root Macro: TMVARegression; 24///; 25/// \macro_output; 26/// \macro_code; 27/// \author Andreas Hoecker; 28 ; 29#include <cstdlib>; 30#include <iostream>; 31#include <map>; 32#include <string>; 33 ; 34#include ""TChain.h""; 35#include ""TFile.h""; 36#include ""TTree.h""; 37#include ""TString.h""; 38#include ""TObjString.h""; 39#include ""TSystem.h""; 40#include ""TROOT.h""; 41 ; 42#include ""TMVA/Tools.h""; 43#include ""TMVA/Factory.h""; 44#include ""TMVA/DataLoader.h""; 45#include ""TMVA/TMVARegGui.h""; 46 ; 47 ; 48using namespace TMVA;; 49 ; 50void TMVARegression( TString myMethodList = """" ); 51{; 52 // The explicit loading of the shared libTMVA is done in TMVAlogon.C, defined in .rootrc; 53 // if you use your private .rootrc, or run from a different directory, please copy the; 54 // corresponding lines from .rootrc; 55 ; 56 // methods to be processed can be given as an argument; use format:; 57 //; 58 // mylinux~> root -l TMVARegression.C\‍(\""myMethod1,myMethod2,myMethod3\""\‍); 59 //; 60 ; 61 //---------------------------------------------------------------; 62 // This loads the library; 63 TMVA::Tools::Instance();; 64 ; 65 ; 66 ; 67 // Default MVA methods to be trained + tested; 68 std::map<std::string,int> Use;; 69 ; 70 // Mutidimensional likelihood and Nearest-Neighbour methods; 71 Use[""PDERS""] = 0;; 72 Use[""PDEFoam""] = 1;; 73 Use[""KNN""] = 1;; 74 //; 75 // Linear Discriminant Analysis; 76 Use[""LD""] = 1;; 77 //; 78 // Function Discriminant analysis; 79 Use[""FDA_GA""] = 0;; 80 Use[""FDA_MC""] = 0;; 81 Use[""FDA_MT""] = 0;; 82 Use[""FDA_GAMT""] = 0;; 83 //; 84 // Neural",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C_source.html:1743,load,loading,1743,doc/master/TMVARegression_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C_source.html,1,['load'],['loading']
Performance,"asic3d.C Show 3-D polylines and markers ;  canvas.C Example of primitives in a canvas ;  canvas2.C Example of canvas partitioning ;  compile.C This macro produces the flowchart of TFormula::Compile ;  crown.C Draw crowns ;  diamond.C Draw a diamond ;  earth.C This tutorial illustrates the special contour options ;  ellipse.C Draw ellipses ;  eval.C This macro produces the flowchart of TFormula::Eval ;  event.C Illustrate some basic primitives ;  feynman.C Draw Feynman diagrams ;  first.C Show some basic primitives ;  formula1.C Display interpreted functions ;  framework.C An example with basic graphics illustrating the Object Oriented User Interface of ROOT ;  gaxis.C Simple example illustrating how to draw TGaxis objects in various formats ;  gaxis2.C Example illustrating how to draw TGaxis with labels defined by a function ;  gaxis3.C Example illustrating how to modify individual labels of a TGaxis ;  graph_edit_playback.CThis macro plays a recorded ROOT session showing how to perform various interactive graphical editing operations ;  greyscale.C Create grey scale of 200 x 200 boxes ;  gtime.CExample of a graph of data moving in time ;  latex.C This macro draws 5 Latex-style formula in a canvas and prints the canvas as a Postscript file ;  latex2.C This macro draws 4 Latex-style formula in a canvas and prints the canvas as a Postscript file ;  latex3.C Example illustrating a TPaveText with Latex inside ;  latex4.C Draw the Greek letters as a table and save the result as GIF, PS, PDF and SVG files ;  latex5.C This draws the Mathematical Symbols letters as a table and save the result as GIF, PS, PDF and SVG files ;  mandelbrot.C Using TExec to handle keyboard events and TComplex to draw the Mandelbrot set ;  manyaxis.C Show several TGaxis formats ;  markerwarning.C This script illustrates the danger of using asymmetric symbols ;  mass_spectrum.C This macro makes use of some basic graphics primitives such as line, arrow and text ;  palettes.C This macro draws all the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:112358,perform,perform,112358,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,3,['perform'],['perform']
Performance,"asketinfo"");; 587 ; 588 TFile *file = fTree->GetCurrentFile();; 589 if (!file); 590 return;; 591 ; 592 TTreeCache *cache = dynamic_cast<TTreeCache *>(file->GetCacheRead(fTree));; 593 if (!cache); 594 return;; 595 ; 596 auto branches = cache->GetCachedBranches();; 597 for (size_t i = 0; i < fBasketsInfo.size(); ++i) {; 598 const char *branchname = branches->At(i)->GetName();; 599 ; 600 printf("" br=%zu %s read not cached: "", i, branchname);; 601 if (fBasketsInfo[i].empty()) {; 602 printf(""none"");; 603 } else; 604 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 605 if (fBasketsInfo[i][j].fMissed); 606 printf(""%zu "", j);; 607 }; 608 printf(""\n"");; 609 ; 610 printf("" br=%zu %s cached more than once: "", i, branchname);; 611 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 612 auto &info(fBasketsInfo[i][j]);; 613 if ((info.fLoaded + info.fLoadedMiss) > 1); 614 printf(""%zu[%d,%d] "", j, info.fLoaded, info.fLoadedMiss);; 615 }; 616 printf(""\n"");; 617 ; 618 printf("" br=%zu %s cached but not used: "", i, branchname);; 619 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 620 auto &info(fBasketsInfo[i][j]);; 621 if ((info.fLoaded + info.fLoadedMiss) && !info.fUsed) {; 622 if (info.fLoadedMiss); 623 printf(""%zu[%d,%d] "", j, info.fLoaded, info.fLoadedMiss);; 624 else; 625 printf(""%zu "", j);; 626 }; 627 }; 628 printf(""\n"");; 629 ; 630 if (all) {; 631 printf("" br=%zu %s: "", i, branchname);; 632 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 633 auto &info(fBasketsInfo[i][j]);; 634 printf(""%zu[%d,%d,%d,%d] "", j, info.fUsed, info.fLoaded, info.fLoadedMiss, info.fMissed);; 635 }; 636 printf(""\n"");; 637 }; 638 }; 639 for (Int_t i = fBasketsInfo.size(); i < branches->GetEntries(); ++i) {; 640 printf("" br=%d %s: no basket information\n"", i, branches->At(i)->GetName());; 641 }; 642}; 643 ; 644////////////////////////////////////////////////////////////////////////////////; 645/// Save this object to filename; 646 ; 647void TTreePerfStats::SaveAs(const char *filenam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:21856,cache,cached,21856,doc/master/TTreePerfStats_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html,1,['cache'],['cached']
Performance,"askets; ///< -> List of baskets of this branch; 141 Int_t *fBasketBytes; ///<[fMaxBaskets] Length of baskets on file; 142 Long64_t *fBasketEntry; ///<[fMaxBaskets] Table of first entry in each basket; 143 Long64_t *fBasketSeek; ///<[fMaxBaskets] Addresses of baskets on file; 144 TTree *fTree; ///<! Pointer to Tree header; 145 TBranch *fMother; ///<! Pointer to top-level parent branch in the tree.; 146 TBranch *fParent; ///<! Pointer to parent branch.; 147 char *fAddress; ///<! Address of 1st leaf (variable or object); 148 TDirectory *fDirectory; ///<! Pointer to directory where this branch buffers are stored; 149 TString fFileName; ///< Name of file where buffers are stored ("""" if in same file as Tree header); 150 TBuffer *fEntryBuffer; ///<! Buffer used to directly pass the content without streaming; 151 TBuffer *fTransientBuffer; ///<! Pointer to the current transient buffer.; 152 TList *fBrowsables; ///<! List of TVirtualBranchBrowsables used for Browse(); 153 BulkObj fBulk; ///<! Helper for performing bulk IO; 154 ; 155 bool fSkipZip; ///<! After being read, the buffer will not be unzipped.; 156 ; 157 using CacheInfo_t = ROOT::Internal::TBranchCacheInfo;; 158 CacheInfo_t fCacheInfo; ///<! Hold info about which basket are in the cache and if they have been retrieved from the cache.; 159 ; 160 typedef void (TBranch::*ReadLeaves_t)(TBuffer &b);; 161 ReadLeaves_t fReadLeaves; ///<! Pointer to the ReadLeaves implementation to use.; 162 typedef void (TBranch::*FillLeaves_t)(TBuffer &b);; 163 FillLeaves_t fFillLeaves; ///<! Pointer to the FillLeaves implementation to use.; 164 void ReadLeavesImpl(TBuffer &b);; 165 void ReadLeaves0Impl(TBuffer &b);; 166 void ReadLeaves1Impl(TBuffer &b);; 167 void ReadLeaves2Impl(TBuffer &b);; 168 void FillLeavesImpl(TBuffer &b);; 169 ; 170 void SetSkipZip(bool skip = true) { fSkipZip = skip; }; 171 void Init(const char *name, const char *leaflist, Int_t compress);; 172 ; 173 TBasket *GetFreshBasket(Int_t basketnumber, TBuffer *user_buffe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8h_source.html:6574,perform,performing,6574,doc/master/TBranch_8h_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8h_source.html,1,['perform'],['performing']
Performance,"ass %s read from %s%s\n""; 2945 "" has the same version (=%d) as the active class but a different checksum.\n""; 2946 "" You should update the version to ClassDef(%s,%d).\n""; 2947 "" The objects on this file might not be readable because:\n""; 2948 "" The in-memory layout version %d for class '%s' has a base class (%s) with version %d but the on-file layout version %d recorded the version number %d for this base class (%s)."",; 2949 GetName(), file ? ""file "" : """", file ? file->GetName() : """", fClassVersion, GetName(), fClassVersion + 1,; 2950 GetClassVersion(), GetName(), otherClass.Data(), otherBaseClass->GetClassVersion(),; 2951 GetClassVersion(), localBase->GetBaseVersion(), localClass.Data());; 2952 TStreamerBase *otherBase = (TStreamerBase*)cl->GetStreamerInfo()->GetElements()->FindObject(otherClass);; 2953 otherBase->SetErrorMessage(msg);; 2954 ; 2955 } else if (!otherBaseClass->IsVersioned() && localBase->GetBaseCheckSum() != otherBaseClass->GetCheckSum()) {; 2956 TVirtualStreamerInfo *localBaseInfo = otherBaseClass->FindStreamerInfo(localBase->GetBaseCheckSum());; 2957 if (!localBaseInfo) {; 2958 // We are likely in the situation where the base class comes after the derived; 2959 // class in the TFile's list of StreamerInfo, so it has not yet been loaded,; 2960 // let's see if it is there.; 2961 const TList *list = file->GetStreamerInfoCache();; 2962 localBaseInfo = list ? (TStreamerInfo*)list->FindObject(localBase->GetName()) : 0;; 2963 }; 2964 if (!localBaseInfo) {; 2965 TString msg;; 2966 msg.Form("" The StreamerInfo of the base class %s (of class %s) read from %s%s\n""; 2967 "" refers to a checksum (%x) that can not be found neither in memory nor in the file.\n"",; 2968 otherBaseClass->GetName(), localClass.Data(),; 2969 file ? ""file "" : """", file ? file->GetName() : """",; 2970 localBase->GetBaseCheckSum(); 2971 );; 2972 TStreamerBase *otherBase = (TStreamerBase*)cl->GetStreamerInfo()->GetElements()->FindObject(otherClass);; 2973 otherBase->SetErrorMessage(msg);; 2974",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:117964,load,loaded,117964,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['load'],['loaded']
Performance,"ass * RooObjCacheManager::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooObjCacheManager::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooObjCacheManager::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 62 of file RooObjCacheManager.h. ◆ clearObsList(). static bool RooObjCacheManager::clearObsList ; (; ). inlinestatic . Definition at line 48 of file RooObjCacheManager.h. ◆ DeclFileName(). static const char * RooObjCacheManager::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 62 of file RooObjCacheManager.h. ◆ doClearObsList(). static void RooObjCacheManager::doClearObsList ; (; bool ; flag). inlinestatic . Definition at line 47 of file RooObjCacheManager.h. ◆ findConstantNodes(). void RooObjCacheManager::findConstantNodes ; (; const RooArgSet & ; obs, . RooArgSet & ; cacheList, . RooLinkedList & ; processedNodes . ). overridevirtual . If clearOnRedirect is false, forward constant term optimization calls to cache elements. ; Reimplemented from RooAbsCache.; Definition at line 209 of file RooObjCacheManager.cxx. ◆ insertObjectHook(). void RooObjCacheManager::insertObjectHook ; (; RooAbsCacheElement & ; obj). overridevirtual . Set owner link on all object inserted into cache. ; Also if cache mode optimization was requested, apply it now to cache element being inserted ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 175 of file RooObjCacheManager.cxx. ◆ IsA(). TClass * RooObjCacheManager::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooCacheManager< RooAbsCacheElement >.; Definition at line 62 of file RooObjCacheManager.h. ◆ operModeHook(). void RooObjCacheManager::operModeHook ; (; ). overridevirtual . Intercept changes to cache operation mode and forward to ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:9003,cache,cacheList,9003,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['cache'],['cacheList']
Performance,"ass * fClassNot Owned.Definition TStreamerInfo.h:53; TStreamerInfo::TCompInfo::fStreamerTMemberStreamer * fStreamerNot Owned.Definition TStreamerInfo.h:56; TStreamerInfo::TCompInfo::fOffsetInt_t fOffsetDefinition TStreamerInfo.h:49; TStreamerInfo::TCompInfo::fMethodULongptr_t fMethodDefinition TStreamerInfo.h:52; TStreamerInfo::TCompInfo::fLengthInt_t fLengthDefinition TStreamerInfo.h:50; TStreamerInfo::TPointerCollectionAdapterDefinition TStreamerInfo.h:73; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStreamerInfo::fNfulldataInt_t fNfulldata!number of elementsDefinition TStreamerInfo.h:94; TStreamerInfo::WriteBufferSTLInt_t WriteBufferSTL(TBuffer &b, TVirtualCollectionProxy *cont, Int_t nc)Write for STL container. ('first' is an id between -1 and fNfulldata).Definition TStreamerInfoWriteBuffer.cxx:836; TStreamerInfo::fCompFullTCompInfo ** fCompFull![fElements->GetEntries()]Definition TStreamerInfo.h:98; TStreamerInfo::fNdataInt_t fNdata!number of optimized elementsDefinition TStreamerInfo.h:93; TStreamerInfo::IsATClass * IsA() const overrideDefinition TStreamerInfo.h:254; TStreamerInfo::fClassTClass * fClass!pointer to classDefinition TStreamerInfo.h:99; TStreamerInfo::fCompOptTCompInfo ** fCompOpt![fNdata]Definition TStreamerInfo.h:97; TStreamerInfo::Streamervoid Streamer(TBuffer &) overrideStream an object of class TStreamerInfo.Definition TStreamerInfo.cxx:5266; TStreamerInfo::WriteBufferInt_t WriteBuffer(TBuffer &b, char *pointer, Int_t first)General Write.Definition TStreamerInfoWriteBuffer.cxx:863; TStreamerInfo::WriteBufferClonesInt_t WriteBufferClones(TBuffer &b, TClonesArray *clones, Int_t nc, Int_t first, Int_t eoffset)Write for ClonesArray ('first' is an id between -1 and fNfulldata).Definition TStreamerInfoWriteBuffer.cxx:872; TStreamerInfo::WriteBufferAuxInt_t WriteBufferAux(TBuffer &b, const T &arr, TCompInfo *const *const compinfo, Int_t first, Int_t last, Int_t narr, Int_t eoffset, Int_t mode)The object at po",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoWriteBuffer_8cxx_source.html:44812,optimiz,optimized,44812,doc/master/TStreamerInfoWriteBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoWriteBuffer_8cxx_source.html,1,['optimiz'],['optimized']
Performance,"ass *cl, const void *obj, TMemberInspector &);  Indirect call to the implementation of ShowMember allowing [forward] declaration with out a full definition of the TClass class. More...;  ; static UInt_t ClassTableHash (const char *name, UInt_t size);  ; int CompressionSettings (RCompressionSetting::EAlgorithm algorithm, int compressionLevel);  ; int CompressionSettings (ROOT::ECompressionAlgorithm algorithm, int compressionLevel);  Deprecated name, do not use: More...;  ; TClass * CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). More...;  ; TClass * CreateClass (const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). More...;  ; void DisableImplicitMT ();  Disables the implicit multi-threading in ROOT (see EnableImplicitMT). More...;  ; void EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. More...;  ; void EnableThreadSafety ();  Enables the global mutex to make ROOT thread safe/aware. More...;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (ROOT::Internal::TStringView str, T &value);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. More...;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:7150,multi-thread,multi-threading,7150,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,3,['multi-thread'],['multi-threading']
Performance,"ass Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TVirtualMCApplication(). Destructor. TVirtualMCApplication* Instance(). Static access method. void Field(const Double_t* x, Double_t* b) const; No magnetic field. void ConstructGeometry(). methods. Construct user geometry. Bool_t MisalignGeometry(); Misalign user geometry (optional). {return kFALSE;}. void ConstructOpGeometry(); Define parameters for optical processes (optional). {}. void InitGeometry(); Initialize geometry; (Usually used to define sensitive volumes IDs). void AddParticles(); Add user defined particles (optional). {}. void AddIons(); Add user defined ions (optional). {}. void GeneratePrimaries(); Generate primary particles. void BeginEvent(); Define actions at the beginning of the event. void BeginPrimary(); Define actions at the beginning of the primary track. void PreTrack(); Define actions at the beginning of each track. void Stepping(); Define action at each step. void PostTrack(); Define actions at the end of each track. void FinishPrimary(); Define actions at the end of the primary track. void FinishEvent(); Define actions at the end of the event. Double_t TrackingRmax() const; Define maximum radius for tracking (optional). { return DBL_MAX; }. Double_t TrackingZmax() const; Define maximum z for tracking (optional). { return DBL_MAX; }. void GeaneStepping(); Define action at each step for Geane. {;}. TVirtualMCApplication* CloneForWorker() const; New functions for multi-threading applications. { return 0;}. void InitForWorker() const; {}. void BeginWorkerRun() const; {}. void FinishWorkerRun() const; {}. void Merge(TVirtualMCApplication* ); {}. » Author: Ivana Hrivnacova, 23/03/2002 » Copyright (C) 2006, Rene Brun and Fons Rademakers. *; » Last changed: root/vmc:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualMCApplication.html:7997,multi-thread,multi-threading,7997,root/html534/TVirtualMCApplication.html,https://root.cern,https://root.cern/root/html534/TVirtualMCApplication.html,1,['multi-thread'],['multi-threading']
Performance,"ass RooSimWSTool::ObjSplitRule. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'maste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimWSTool__ObjSplitRule.html:1285,perform,performed,1285,root/html526/RooSimWSTool__ObjSplitRule.html,https://root.cern,https://root.cern/root/html526/RooSimWSTool__ObjSplitRule.html,4,['perform'],['performed']
Performance,"ass TROOT;; 55class TListOfDataMembers;; 56class TListOfEnums;; 57class TListOfFunctions;; 58class TListOfFunctionTemplates;; 59class TSeqCollection;; 60class TFunctionTemplate;; 61class TGlobalMappedFunction;; 62 ; 63R__EXTERN TVirtualMutex *gROOTMutex;; 64 ; 65namespace ROOT {; 66namespace Internal {; 67 class TROOTAllocator;; 68 ; 69 TROOT *GetROOT2();; 70 ; 71 // Manage parallel branch processing; 72 void EnableParBranchProcessing();; 73 void DisableParBranchProcessing();; 74 Bool_t IsParBranchProcessingEnabled();; 75 class TParBranchProcessingRAII {; 76 public:; 77 TParBranchProcessingRAII() { EnableParBranchProcessing(); }; 78 ~TParBranchProcessingRAII() { DisableParBranchProcessing(); }; 79 };; 80} } // End ROOT::Internal; 81 ; 82namespace ROOT {; 83 /// \brief Enable support for multi-threading within the ROOT code; 84 /// in particular, enables the global mutex to make ROOT thread safe/aware.; 85 void EnableThreadSafety();; 86 /// \brief Enable ROOT's implicit multi-threading for all objects and methods that provide an internal; 87 /// parallelisation mechanism.; 88 void EnableImplicitMT(UInt_t numthreads = 0);; 89 void DisableImplicitMT();; 90 Bool_t IsImplicitMTEnabled();; 91 UInt_t GetThreadPoolSize();; 92}; 93 ; 94class TROOT : public TDirectory {; 95 ; 96friend class TCling;; 97friend TROOT *ROOT::Internal::GetROOT2();; 98 ; 99private:; 100 Int_t fLineIsProcessing; ///< To synchronize multi-threads; 101 ; 102 static Int_t fgDirLevel; ///< Indentation level for ls(); 103 static Bool_t fgRootInit; ///< Singleton initialization flag; 104 ; 105 TROOT(const TROOT&) = delete;; 106 TROOT& operator=(const TROOT&) = delete;; 107 ; 108protected:; 109 typedef std::atomic<TListOfEnums*> AListOfEnums_t;; 110 ; 111 TString fConfigOptions; ///< ROOT ./configure set build options; 112 TString fConfigFeatures; ///< ROOT ./configure detected build features; 113 TString fVersion; ///< ROOT version (from CMZ VERSQQ) ex 0.05/01; 114 Int_t fVersionInt; ///< ROOT version in i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:2784,multi-thread,multi-threading,2784,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,2,['multi-thread'],['multi-threading']
Performance,"ass described by this TClass has a default constructor (public or not), use cl->GetProperty() & kClassHasDefaultCtor; kClassHasDefaultCtor@ kClassHasDefaultCtorDefinition TDictionary.h:140; To know if the class described by this TClass has a public default constructor use: gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; gInterpreter#define gInterpreterDefinition TInterpreter.h:573. Definition at line 7393 of file TClass.cxx. ◆ HasDictionary(). Bool_t TClass::HasDictionary ; (; ); const. Check whether a class has a dictionary or not. ; This is equivalent to ask if a class is coming from a bootstrapping procedure initiated during the loading of a library. ; Definition at line 3906 of file TClass.cxx. ◆ HasDictionarySelection(). Bool_t TClass::HasDictionarySelection ; (; const char * ; clname). static . Check whether a class has a dictionary or ROOT can load one. ; This is equivalent to ask HasDictionary() or whether a library is known where it can be loaded from, or whether a Dictionary function is available because the class's dictionary library was already loaded. ; Definition at line 3917 of file TClass.cxx. ◆ HasInterpreterInfo(). Bool_t TClass::HasInterpreterInfo ; (; ); const. inline . Definition at line 410 of file TClass.h. ◆ HasInterpreterInfoInMemory(). Bool_t TClass::HasInterpreterInfoInMemory ; (; ); const. inline . Definition at line 409 of file TClass.h. ◆ HasLocalHashMember(). Bool_t TClass::HasLocalHashMember ; (; ); const. Returns true if this class has an definition and/or overload of the member function Hash. ; For example to test if the class overload TObject::Hash use if (cl->IsTObject() && cl->HasLocalHashMember()). Definition at line 7421 of file TClass.cxx. ◆ HasNoInfoOrEmuOrFwdDeclaredDecl(). Bool_t TClass::HasNoInfoOrEmuOrFwdDeclaredDecl ; (; const char * ; name). staticprivate . Definition at line 3398 of file TClass.cxx. ◆ IgnoreTObjectStreamer(). void TClass::IgnoreTObjectStreamer ; (; Bool_t ; doIgnore = kTRUE). Wh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:95377,load,loaded,95377,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,2,['load'],['loaded']
Performance,"ass described by this TClass has a default constructor (public or not), use cl->GetProperty() & kClassHasDefaultCtor; kClassHasDefaultCtor@ kClassHasDefaultCtorDefinition TDictionary.h:140; To know if the class described by this TClass has a public default constructor use: gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; gInterpreter#define gInterpreterDefinition TInterpreter.h:573. Definition at line 7460 of file TClass.cxx. ◆ HasDictionary(). Bool_t TClass::HasDictionary ; (; ); const. Check whether a class has a dictionary or not. ; This is equivalent to ask if a class is coming from a bootstrapping procedure initiated during the loading of a library. ; Definition at line 3973 of file TClass.cxx. ◆ HasDictionarySelection(). Bool_t TClass::HasDictionarySelection ; (; const char * ; clname). static . Check whether a class has a dictionary or ROOT can load one. ; This is equivalent to ask HasDictionary() or whether a library is known where it can be loaded from, or whether a Dictionary function is available because the class's dictionary library was already loaded. ; Definition at line 3984 of file TClass.cxx. ◆ HasInterpreterInfo(). Bool_t TClass::HasInterpreterInfo ; (; ); const. inline . Definition at line 410 of file TClass.h. ◆ HasInterpreterInfoInMemory(). Bool_t TClass::HasInterpreterInfoInMemory ; (; ); const. inline . Definition at line 409 of file TClass.h. ◆ HasLocalHashMember(). Bool_t TClass::HasLocalHashMember ; (; ); const. Returns true if this class has an definition and/or overload of the member function Hash. ; For example to test if the class overload TObject::Hash use if (cl->IsTObject() && cl->HasLocalHashMember()). Definition at line 7488 of file TClass.cxx. ◆ HasNoInfoOrEmuOrFwdDeclaredDecl(). Bool_t TClass::HasNoInfoOrEmuOrFwdDeclaredDecl ; (; const char * ; name). staticprivate . Definition at line 3465 of file TClass.cxx. ◆ IgnoreTObjectStreamer(). void TClass::IgnoreTObjectStreamer ; (; Bool_t ; doIgnore = kTRUE). Wh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:95378,load,loaded,95378,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,2,['load'],['loaded']
Performance,"ass for implementing GSL multi-root finders not using derivatives. ; Definition at line 155 of file GSLMultiRootSolver.h. Public Member Functions;  GSLMultiRootSolver (const gsl_multiroot_fsolver_type *type, int n);  Constructor from type and simension of system (number of functions) ;  ;  GSLMultiRootSolver (const GSLMultiRootSolver &)=delete;  ;  GSLMultiRootSolver (GSLMultiRootSolver &&)=delete;  ;  ~GSLMultiRootSolver () override;  Destructor (no operations) ;  ; void CreateSolver (const gsl_multiroot_fsolver_type *type, unsigned int n);  ; gsl_vector * GetDx () const override;  return function steps ;  ; gsl_vector * GetF () const override;  return function values ;  ; gsl_vector * GetRoot () const override;  solution values at the current iteration ;  ; int Iterate () override;  perform an iteration ;  ; const std::string & Name () const override;  return name ;  ; GSLMultiRootSolver & operator= (const GSLMultiRootSolver &rhs)=delete;  ; GSLMultiRootSolver & operator= (GSLMultiRootSolver &&rhs)=delete;  ; int SetSolver (const std::vector< ROOT::Math::IMultiGenFunction * > &funcVec, const double *x) override;  set the solver parameters ;  ;  Public Member Functions inherited from ROOT::Math::GSLMultiRootBaseSolver; virtual ~GSLMultiRootBaseSolver ();  virtual Destructor ;  ; const double * Dx () const;  return function steps ;  ; const double * FVal () const;  return function values ;  ; bool InitSolver (const std::vector< ROOT::Math::IMultiGenFunction * > &funcVec, const double *x);  init the solver with function list and initial values ;  ; int TestDelta (double absTol, double relTol) const;  test using abs and relative tolerance |dx| < absTol + relTol*|x| for every component ;  ; int TestResidual (double absTol) const;  test using abs tolerance Sum |f|_i < absTol ;  ; const double * X () const;  solution values at the current iteration ;  . Private Attributes; GSLMultiRootFunctionWrapper fFunctions;  ; std::string fName;  ; gsl_multiroot_fsolver * fSolver;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMultiRootSolver.html:1196,perform,perform,1196,doc/master/classROOT_1_1Math_1_1GSLMultiRootSolver.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMultiRootSolver.html,1,['perform'],['perform']
Performance,"ass implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.95, bool norm = true) const. get confidence intervals for an array of n points x.; stride1 indicates the stride in the coordinate space while stride2 the stride in dimension space.; For 1-dim points : stride1=1, stride2=1; for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidedence interval value; norm is a flag to control if the intervals need to be normalized to the chi2/ndf value; By default the intervals are corrected using the chi2/ndf value of the fit if a chi2 fit is performed. void GetConfidenceIntervals(const ROOT::Fit::BinData& data, double* ci, double cl = 0.95, bool norm = true) const. evaluate confidence interval for the point specified in the passed data sets; the confidence interval are returned in the array ci; cl is the desired confidence interval value. int Index(const string& name) const; get index for parameter name (return -1 if not found). void NormalizeErrors(); normalize errors using chi2/ndf for chi2 fits. bool NormalizedErrors() const; flag to chek if errors are normalized. { return fNormalized; }. void Print(ostream& os, bool covmat = false) const; print the result and optionaly covariance matrix and correlations. void PrintCovMatrix(ostream& os) const; print error matrix and correlations. bool IsParameterBound(unsigned int ipar) const; query if a parameter is bound. bool IsParameterFixed(unsign",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Fit__FitResult.html:10182,perform,performed,10182,root/html530/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html530/ROOT__Fit__FitResult.html,3,['perform'],['performed']
Performance,"ass implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.95, bool norm = true) const. get confidence intervals for an array of n points x.; stride1 indicates the stride in the coordinate space while stride2 the stride in dimension space.; For 1-dim points : stride1=1, stride2=1; for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidedence interval value; norm is a flag to control if the intervals need to be normalized to the chi2/ndf value; By default the intervals are corrected using the chi2/ndf value of the fit if a chi2 fit is performed. void GetConfidenceIntervals(const ROOT::Fit::BinData& data, double* ci, double cl = 0.95, bool norm = true) const. evaluate confidence interval for the point specified in the passed data sets; the confidence interval are returned in the array ci; cl is the desired confidence interval value. int Index(const string& name) const; get index for parameter name (return -1 if not found). void NormalizeErrors(); normalize errors using chi2/ndf for chi2 fits. bool NormalizedErrors(); flag to chek if errors are normalized. { return fNormalized; }. void Print(ostream& os, bool covmat = false) const; print the result and optionaly covariance matrix and correlations. void PrintCovMatrix(ostream& os) const; print error matrix and correlations. bool IsParameterBound(unsigned int ipar) const; query if a parameter is bound. bool IsParameterFixed(unsigned int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__FitResult.html:9862,perform,performed,9862,root/html528/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__FitResult.html,1,['perform'],['performed']
Performance,"ass name.Definition TClass.cxx:3035; TCollectionCollection abstract base class.Definition TCollection.h:65; TCutA specialized string object used for TTree selections.Definition TCut.h:25; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TDirectory::TContextTDirectory::TContext keeps track and restore the current directory.Definition TDirectory.h:89; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::GetListvirtual TList * GetList() constDefinition TDirectory.h:222; TDirectory::Appendvirtual void Append(TObject *obj, Bool_t replace=kFALSE)Append object to this directory.Definition TDirectory.cxx:199; TDirectory::GetFilevirtual TFile * GetFile() constDefinition TDirectory.h:220; TDirectory::Removevirtual TObject * Remove(TObject *)Remove an object from the in-memory list.Definition TDirectory.cxx:1212; TEntryListFromFileManages entry lists from different files, when they are not loaded in memory at the same time.Definition TEntryListFromFile.h:41; TEntryListA List of entry numbers in a TTree or TChain.Definition TEntryList.h:26; TEntryList::Entervirtual bool Enter(Long64_t entry, TTree *tree=nullptr)Add entry #entry to the list.Definition TEntryList.cxx:631; TEntryList::GetEntryListvirtual TEntryList * GetEntryList(const char *treename, const char *filename, Option_t *opt="""")Return the entry list, corresponding to treename and filename By default, the filename is first tried...Definition TEntryList.cxx:889; TEntryList::GetTreeNumbervirtual Int_t GetTreeNumber() constDefinition TEntryList.h:81; TEntryList::GetListsvirtual TList * GetLists() constDefinition TEntryList.h:76; TEntryList::SetTreevirtual void SetTree(const TTree *tree)If a list for a tree with such name and filename exists, sets it as the current sublist If not,...Definition TEntryList.cxx:1296; TEntryList::SetShiftvirtual void SetShift(bool shift)Definition TEntryList.h:1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:132762,load,loaded,132762,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['load'],['loaded']
Performance,"ass that can be used to execute a C++ command when some event happens in a pad ;  ►CTExMapThis class stores a (key,value) pair using an external hash ;  CAssoc_t;  CTExMapIter;  ►CTF11-Dim function class ;  CTF1FunctorPointer;  CTF1FunctorPointerImpl;  CTF12A projection of a TF2 along X or Y ;  CTF1AbsComposition;  CTF1ConvolutionClass wrapping convolution of two functions ;  CTF1Editor;  CTF1NormSumClass adding two functions: c1*f1+c2*f2 ;  CTF1ParametersTF1 Parameters class ;  CTF2A 2-Dim function with parameters ;  CTF2GLGL renderer for TF2 ;  CTF3A 3-Dim function with parameters ;  CTFastCgi;  CTFeldmanCousinsClass to calculate the CL upper limit using the Feldman-Cousins method as described in PRD V57 #7, p3873-3889 ;  CTFFTComplex;  CTFFTComplexReal;  CTFFTReal;  CTFFTRealComplex;  ►CTFileA ROOT file is a suite of consecutive data records (TKey instances) with a well defined format ;  CInfoListRetSimple struct of the return value of GetStreamerInfoListImpl ;  CTFileCacheReadA cache when reading files over the network ;  CTFileCacheWriteA cache when writing files over the network ;  CTFileCollectionClass that contains a list of TFileInfo's and accumulated meta data information about its entries ;  CTFileDrawMapThis class is automatically called by TFile::DrawMap ;  CTFileHandler;  CTFileInfoClass describing a generic file including meta information ;  CTFileInfoMeta;  CTFileIter;  CTFileMergeInfo;  CTFileMergerThis class provides file copy and merging services ;  CTFileOpenHandleClass holding info about the file being opened ;  CTFilePrefetchThe prefetching mechanism uses two classes (TFilePrefetch and TFPBlock) to prefetch in advance a block of tree entries ;  CTFileSet;  CTFileStager;  ►CTFitEditor;  CFuncParamData_tTF1Convolution object ;  CTFitParametersDialog;  CTFitResultExtends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O ;  CTFitResultPtrProvides an indirection to the TFitResult class and with a semantics iden",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:154452,cache,cache,154452,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,2,['cache'],['cache']
Performance,"ass  BasicMinimizer;  Base Minimizer class, which defines the basic functionality of various minimizer implementations (apart from Minuit and Minuit2) It provides support for storing parameter values, step size, parameter transformation etc. More...;  ; class  BinaryOp;  BinaryOperation class A class representing binary operators in the parse tree. More...;  ; class  BinaryOpCopyL;  Binary Operation class with value storage for the left argument. More...;  ; class  BinaryOpCopyR;  Binary Operation class with value storage for the right argument. More...;  ; class  Boost;  Lorentz boost class with the (4D) transformation represented internally by a 4x4 orthosymplectic matrix. More...;  ; class  BoostX;  Class representing a Lorentz Boost along the X axis, by beta. More...;  ; class  BoostY;  Class representing a Lorentz Boost along the Y axis, by beta. More...;  ; class  BoostZ;  Class representing a Lorentz Boost along the Z axis, by beta. More...;  ; class  BrentMinimizer1D;  User class for performing function minimization. More...;  ; class  BrentRootFinder;  Class for finding the root of a one dimensional function using the Brent algorithm. More...;  ; class  Cartesian2D;  Class describing a 2D cartesian coordinate system (x, y coordinates) More...;  ; class  Cartesian3D;  Class describing a 3D cartesian coordinate system (x, y, z coordinates) More...;  ; struct  CDFWrapper;  ; class  ChebyshevApprox;  Class describing a Chebyshev series which can be used to approximate a function in a defined range [a,b] using Chebyshev polynomials. More...;  ; class  ChebyshevPol;  ; class  CholeskyDecomp;  class to compute the Cholesky decomposition of a matrix More...;  ; class  CholeskyDecompGenDim;  class to compute the Cholesky decomposition of a matrix More...;  ; class  CholInverter;  ; struct  CompileTimeChecker;  ; struct  CompileTimeChecker< false >;  ; class  Constant;  Constant expression class A class representing constant expressions (literals) in the parse tree. M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:4215,perform,performing,4215,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['perform'],['performing']
Performance,"ass();; 4305 }; 4306 // Build the signature of the method; 4307 TString sig;; 4308 TList* margsList = method->GetListOfMethodArgs();; 4309 TIter nextarg(margsList);; 4310 while ((methodArg = (TMethodArg*)nextarg())) {; 4311 sig = sig+"",""+methodArg->GetFullTypeName();; 4312 }; 4313 if (sig.Length()!=0) sig.Remove(0,1); // remove first comma; 4314 menuItem = new TClassMenuItem(TClassMenuItem::kPopupUserFunction, this,; 4315 method->GetName(), method->GetName(),nullptr,; 4316 sig.Data(),-1,TClassMenuItem::kIsSelf);; 4317 if (method->IsMenuItem() == kMenuToggle) menuItem->SetToggle();; 4318 fClassMenuList->Add(menuItem);; 4319 }; 4320 delete methodList;; 4321}; 4322 ; 4323////////////////////////////////////////////////////////////////////////////////; 4324/// Register the fact that an object was moved from the memory location; 4325/// 'arenaFrom' to the memory location 'arenaTo'.; 4326 ; 4327void TClass::Move(void *arenaFrom, void *arenaTo) const; 4328{; 4329 // If/when we have access to a copy constructor (or better to a move; 4330 // constructor), this function should also perform the data move.; 4331 // For now we just information the repository.; 4332 ; 4333 if ((GetState() <= kEmulated) && !fCollectionProxy) {; 4334 MoveAddressInRepository(""TClass::Move"",arenaFrom,arenaTo,this);; 4335 }; 4336}; 4337 ; 4338////////////////////////////////////////////////////////////////////////////////; 4339/// Return the list of menu items associated with the class.; 4340 ; 4341TList *TClass::GetMenuList() const {; 4342 if (!fClassMenuList) {; 4343 fClassMenuList = new TList();; 4344 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, const_cast<TClass*>(this)));; 4345 }; 4346 return fClassMenuList;; 4347}; 4348 ; 4349////////////////////////////////////////////////////////////////////////////////; 4350/// Return (create an empty one if needed) the list of functions.; 4351/// The major difference with GetListOfMethod is that this returns; 4352/// the interna",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:163742,perform,perform,163742,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['perform'],['perform']
Performance,"ass();; 4372 }; 4373 // Build the signature of the method; 4374 TString sig;; 4375 TList* margsList = method->GetListOfMethodArgs();; 4376 TIter nextarg(margsList);; 4377 while ((methodArg = (TMethodArg*)nextarg())) {; 4378 sig = sig+"",""+methodArg->GetFullTypeName();; 4379 }; 4380 if (sig.Length()!=0) sig.Remove(0,1); // remove first comma; 4381 menuItem = new TClassMenuItem(TClassMenuItem::kPopupUserFunction, this,; 4382 method->GetName(), method->GetName(),nullptr,; 4383 sig.Data(),-1,TClassMenuItem::kIsSelf);; 4384 if (method->IsMenuItem() == kMenuToggle) menuItem->SetToggle();; 4385 fClassMenuList->Add(menuItem);; 4386 }; 4387 delete methodList;; 4388}; 4389 ; 4390////////////////////////////////////////////////////////////////////////////////; 4391/// Register the fact that an object was moved from the memory location; 4392/// 'arenaFrom' to the memory location 'arenaTo'.; 4393 ; 4394void TClass::Move(void *arenaFrom, void *arenaTo) const; 4395{; 4396 // If/when we have access to a copy constructor (or better to a move; 4397 // constructor), this function should also perform the data move.; 4398 // For now we just information the repository.; 4399 ; 4400 if ((GetState() <= kEmulated) && !fCollectionProxy) {; 4401 MoveAddressInRepository(""TClass::Move"",arenaFrom,arenaTo,this);; 4402 }; 4403}; 4404 ; 4405////////////////////////////////////////////////////////////////////////////////; 4406/// Return the list of menu items associated with the class.; 4407 ; 4408TList *TClass::GetMenuList() const {; 4409 if (!fClassMenuList) {; 4410 fClassMenuList = new TList();; 4411 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, const_cast<TClass*>(this)));; 4412 }; 4413 return fClassMenuList;; 4414}; 4415 ; 4416////////////////////////////////////////////////////////////////////////////////; 4417/// Return (create an empty one if needed) the list of functions.; 4418/// The major difference with GetListOfMethod is that this returns; 4419/// the interna",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:166493,perform,perform,166493,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['perform'],['perform']
Performance,"ass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidDLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveJetConeGL.html:1870,cache,cached,1870,root/html534/TEveJetConeGL.html,https://root.cern,https://root.cern/root/html534/TEveJetConeGL.html,1,['cache'],['cached']
Performance,"ass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveBoxGL.html:1846,cache,cached,1846,root/html534/TEveBoxGL.html,https://root.cern,https://root.cern/root/html534/TEveBoxGL.html,3,['cache'],['cached']
Performance,"ass::GetMethodWithPrototype to also search the base classes. Int_t GetNdata(); Return the number of data members of this class; Note that in case the list of data members is not yet created, it will be done; by GetListOfDataMembers(). Int_t GetNmethods(); Return the number of methods of this class; Note that in case the list of methods is not yet created, it will be done; by GetListOfMethods().; This will also load/populate the list of methods, to get 'just' the; number of currently loaded methods use:; cl->GetListOfMethods(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:45447,optimiz,optimizes,45447,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['optimiz'],['optimizes']
Performance,"ass::~TClass(); 1661{; 1662 R__LOCKGUARD(gInterpreterMutex);; 1663 ; 1664 // Remove from the typedef hashtables.; 1665 if (fgClassTypedefHash && TestBit (kHasNameMapNode)) {; 1666 TString resolvedThis = TClassEdit::ResolveTypedef (GetName(), kTRUE);; 1667 TIter next (fgClassTypedefHash->GetListForObject (resolvedThis));; 1668 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1669 if (resolvedThis == htmp->String() && htmp->fOrigName == GetName()) {; 1670 fgClassTypedefHash->Remove (htmp);; 1671 delete htmp;; 1672 break;; 1673 }; 1674 }; 1675 }; 1676 ; 1677 // Not owning lists, don't call Delete(); 1678 // But this still need to be done first because the TList destructor; 1679 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1680 delete fStreamer; fStreamer =nullptr;; 1681 delete fAllPubData; fAllPubData =nullptr;; 1682 delete fAllPubMethod; fAllPubMethod=nullptr;; 1683 ; 1684 delete fPersistentRef.load();; 1685 ; 1686 if (fBase.load()); 1687 (*fBase).Delete();; 1688 delete fBase.load(); fBase = nullptr;; 1689 ; 1690 if (fData.load()); 1691 (*fData).Delete();; 1692 delete fData.load(); fData = nullptr;; 1693 ; 1694 if (fUsingData.load()); 1695 (*fUsingData).Delete();; 1696 delete fUsingData.load(); fUsingData = nullptr;; 1697 ; 1698 if (fEnums.load()); 1699 (*fEnums).Delete();; 1700 delete fEnums.load(); fEnums = nullptr;; 1701 ; 1702 if (fFuncTemplate); 1703 fFuncTemplate->Delete();; 1704 delete fFuncTemplate; fFuncTemplate = nullptr;; 1705 ; 1706 if (fMethod.load()); 1707 (*fMethod).Delete();; 1708 delete fMethod.load(); fMethod=nullptr;; 1709 ; 1710 if (fRealData); 1711 fRealData->Delete();; 1712 delete fRealData; fRealData=nullptr;; 1713 ; 1714 if (fStreamerInfo); 1715 fStreamerInfo->Delete();; 1716 delete fStreamerInfo; fStreamerInfo = nullptr;; 1717 ; 1718 if (fDeclFileLine >= -1); 1719 TClass::RemoveClass(this);; 1720 ; 1721 gCling->ClassInfo_Delete(fClassInfo);; 1722 fClassInfo=nullptr;; 1723 ; 1724 if (fClassMenu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:64997,load,load,64997,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"ass::~TClass(); 1728{; 1729 R__LOCKGUARD(gInterpreterMutex);; 1730 ; 1731 // Remove from the typedef hashtables.; 1732 if (fgClassTypedefHash && TestBit (kHasNameMapNode)) {; 1733 TString resolvedThis = TClassEdit::ResolveTypedef (GetName(), kTRUE);; 1734 TIter next (fgClassTypedefHash->GetListForObject (resolvedThis));; 1735 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1736 if (resolvedThis == htmp->String() && htmp->fOrigName == GetName()) {; 1737 fgClassTypedefHash->Remove (htmp);; 1738 delete htmp;; 1739 break;; 1740 }; 1741 }; 1742 }; 1743 ; 1744 // Not owning lists, don't call Delete(); 1745 // But this still need to be done first because the TList destructor; 1746 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1747 delete fStreamer; fStreamer =nullptr;; 1748 delete fAllPubData; fAllPubData =nullptr;; 1749 delete fAllPubMethod; fAllPubMethod=nullptr;; 1750 ; 1751 delete fPersistentRef.load();; 1752 ; 1753 if (fBase.load()); 1754 (*fBase).Delete();; 1755 delete fBase.load(); fBase = nullptr;; 1756 ; 1757 if (fData.load()); 1758 (*fData).Delete();; 1759 delete fData.load(); fData = nullptr;; 1760 ; 1761 if (fUsingData.load()); 1762 (*fUsingData).Delete();; 1763 delete fUsingData.load(); fUsingData = nullptr;; 1764 ; 1765 if (fEnums.load()); 1766 (*fEnums).Delete();; 1767 delete fEnums.load(); fEnums = nullptr;; 1768 ; 1769 if (fFuncTemplate); 1770 fFuncTemplate->Delete();; 1771 delete fFuncTemplate; fFuncTemplate = nullptr;; 1772 ; 1773 if (fMethod.load()); 1774 (*fMethod).Delete();; 1775 delete fMethod.load(); fMethod=nullptr;; 1776 ; 1777 if (fRealData); 1778 fRealData->Delete();; 1779 delete fRealData; fRealData=nullptr;; 1780 ; 1781 if (fStreamerInfo); 1782 fStreamerInfo->Delete();; 1783 delete fStreamerInfo; fStreamerInfo = nullptr;; 1784 ; 1785 if (fDeclFileLine >= -1); 1786 TClass::RemoveClass(this);; 1787 ; 1788 gCling->ClassInfo_Delete(fClassInfo);; 1789 fClassInfo=nullptr;; 1790 ; 1791 if (fClassMenu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:67748,load,load,67748,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"assImpQ(TPad); 71 ; 72/** \class TPad; 73\ingroup gpad; 74 ; 75The most important graphics class in the ROOT system.; 76 ; 77A Pad is contained in a Canvas.; 78 ; 79A Pad may contain other pads (unlimited pad hierarchy).; 80 ; 81A pad is a linked list of primitives of any type (graphics objects,; 82histograms, detectors, tracks, etc.).; 83 ; 84Adding a new element into a pad is in general performed by the Draw; 85member function of the object classes.; 86 ; 87It is important to realize that the pad is a linked list of references; 88to the original object.; 89For example, in case of a histogram, the histogram.Draw() operation; 90only stores a reference to the histogram object and not a graphical; 91representation of this histogram.; 92When the mouse is used to change (say the bin content), the bin content; 93of the original histogram is changed.; 94 ; 95The convention used in ROOT is that a Draw operation only adds; 96a reference to the object. The effective drawing is performed; 97when the canvas receives a signal to be painted.; 98 ; 99\image html gpad_pad1.png; 100 ; 101This signal is generally sent when typing carriage return in the; 102command input or when a graphical operation has been performed on one; 103of the pads of this canvas.; 104When a Canvas/Pad is repainted, the member function Paint for all; 105objects in the Pad linked list is invoked.; 106 ; 107\image html gpad_pad2.png; 108 ; 109When the mouse is moved on the Pad, The member function DistancetoPrimitive; 110is called for all the elements in the pad. DistancetoPrimitive returns; 111the distance in pixels to this object.; 112 ; 113When the object is within the distance window, the member function; 114ExecuteEvent is called for this object.; 115 ; 116In ExecuteEvent, move, changes can be performed on the object.; 117 ; 118For examples of DistancetoPrimitive and ExecuteEvent functions,; 119see classes; 120~~~ {.cpp}; 121 TLine::DistancetoPrimitive, TLine::ExecuteEvent; 122 TBox::DistancetoPrimitive, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:2958,perform,performed,2958,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['perform'],['performed']
Performance,"assInit, // The class has a TClass proper bootstrap coming from a run; 128 // through rootcling/genreflex/TMetaUtils and the library; 129 // containing this dictionary has been loaded in memory.; 130 kLoaded = kHasTClassInit,; 131 kNamespaceForMeta // Very transient state necessary to bootstrap namespace entries; 132 // in ROOT Meta w/o interpreter information; 133 };; 134 ; 135 // ""Typed"" pointer that recalls how TClass::New allocated the object.; 136 // It is returned by TClass:NewObject and should be passed to TClass::DeleteArray or TClass::Destructor; 137 // to delete the object.; 138 // It is also used in TVirtualCollectionProxy for the same reasons.; 139 struct ObjectPtr; 140 {; 141 void *fPtr = nullptr;; 142 ; 143 TVirtualStreamerInfo *fAllocator = nullptr;; 144 ; 145 ObjectPtr(void *ptr = nullptr, TVirtualStreamerInfo *allocator = nullptr) : fPtr(ptr), fAllocator(allocator) {}; 146 ; 147 void *GetPtr() const { return fPtr; }; 148 ; 149 TVirtualStreamerInfo *GetAllocator() const { return fAllocator; }; 150 ; 151 operator bool() const { return fPtr != nullptr; }; 152 };; 153 ; 154private:; 155 ; 156 ; 157 ; 158 class TDeclNameRegistry {; 159 // A class which is used to collect decl names starting from normalised; 160 // names (typedef resolution is excluded here, just string manipulation; 161 // is performed). At the heart of the implementation, an unordered set.; 162 public:; 163 TDeclNameRegistry(Int_t verbLevel=0);; 164 void AddQualifiedName(const char *name);; 165 Bool_t HasDeclName(const char *name) const;; 166 ~TDeclNameRegistry();; 167 private:; 168 Int_t fVerbLevel=0;; 169 std::unordered_set<std::string> fClassNamesSet;; 170 mutable std::atomic_flag fSpinLock; // MSVC doesn't support = ATOMIC_FLAG_INIT;; 171 };; 172 ; 173 class InsertTClassInRegistryRAII {; 174 // Trivial RAII used to insert names in the registry; 175 TClass::EState& fState;; 176 const char* fName;; 177 TDeclNameRegistry& fNoInfoOrEmuOrFwdDeclNameRegistry;; 178 public:; 179 InsertTClas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:5580,perform,performed,5580,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,2,['perform'],['performed']
Performance,"assName(const char* name) const; Returns class name of a ROOT object including CINT globals. const char * FindObjectPathName(const TObject* obj) const; Return path name of obj somewhere in the //root/... path.; The function returns the first occurence of the object in the list; of folders. The returned string points to a static char array in TROOT.; If this function is called in a loop or recursively, it is the; user's responsability to copy this string in their area. TClass * FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; return a TClass object corresponding to 'name' assuming it is an STL container.; In particular we looking for possible alternative name (default template; parameter, typedefs template arguments, typedefed name). TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class with name. Obsolete, use TClass::GetClass directly. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TFunctionTemplate * GetFunctionTemplate(const char* name). TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; Return pointer to global variable with address addr. TListOfF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:26034,load,load,26034,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,2,['load'],['load']
Performance,"assName, Int_t *argc, char **argv, void *options, Int_t numOptions, Bool_t noLogo,; 172 Bool_t exitOnUnknownArgs); 173 : TApplication(appClassName, argc, argv, options, numOptions + SetExtraClingArgsBeforeTAppCtor(argc, argv)),; 174 fCaughtSignal(-1); 175{; 176 ; 177 if (exitOnUnknownArgs && argc != nullptr && *argc > 1) {; 178 // Early exit if there are remaining unrecognized options; 179 // This branch supposes that TRint is created as a result of using the `root` command; 180 for (auto n = 1; n < *argc; n++) {; 181 std::cerr << ""root: unrecognized option '"" << argv[n] << ""'\n"";; 182 }; 183 std::cerr << ""Try 'root --help' for more information.\n"";; 184 TApplication::Terminate(0);; 185 }; 186 ; 187 fNcmd = 0;; 188 fDefaultPrompt = ""root [%d] "";; 189 fInterrupt = kFALSE;; 190 ; 191 gBenchmark = new TBenchmark();; 192 ; 193 if (!noLogo && !NoLogoOpt()) {; 194 Bool_t lite = (Bool_t) gEnv->GetValue(""Rint.WelcomeLite"", 0);; 195 PrintLogo(lite);; 196 }; 197 ; 198 // Explicitly load libMathCore it cannot be auto-loaded it when using one; 199 // of its freestanding functions. Once functions can trigger autoloading we; 200 // can get rid of this.; 201 if (!gClassTable->GetDict(""TRandom"")); 202 gSystem->Load(""libMathCore"");; 203 ; 204 if (!gInterpreter->HasPCMForLibrary(""std"")) {; 205 // Load some frequently used includes; 206 Int_t includes = gEnv->GetValue(""Rint.Includes"", 1);; 207 // When the interactive ROOT starts, it can automatically load some frequently; 208 // used includes. However, this introduces several overheads; 209 // -The initialisation takes more time; 210 // -Memory overhead when including <vector>; 211 // In $ROOTSYS/etc/system.rootrc, you can set the variable Rint.Includes to 0; 212 // to disable the loading of these includes at startup.; 213 // You can set the variable to 1 (default) to load only <iostream>, <string> and <DllImport.h>; 214 // You can set it to 2 to load in addition <vector> and <utility>; 215 // We strongly recommend setting the variabl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:6220,load,load,6220,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,2,['load'],"['load', 'loaded']"
Performance,"assTable::AddAlternatestatic ROOT::TClassAlt * AddAlternate(const char *normname, const char *alternate)Definition TClassTable.cxx:507; TClassTable::fgCursorstatic UInt_t fgCursorDefinition TClassTable.h:53; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::fClassVersionVersion_t fClassVersionDefinition TClass.h:221; TClass::SetUnloadedvoid SetUnloaded()Call this method to indicate that the shared library containing this class's code has been removed (u...Definition TClass.cxx:6309; TClass::SetClassVersionvoid SetClassVersion(Version_t version)Private function.Definition TClass.cxx:5675; TClass::fVersionUsedstd::atomic< Bool_t > fVersionUsedsaved remember if fOffsetStreamer has been set.Definition TClass.h:262; TClass::kHasTClassInit@ kHasTClassInitDefinition TClass.h:127; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:2968; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TInterpreter::RegisterTClassUpdatevirtual void RegisterTClassUpdate(TClass *oldcl, DictFuncPtr_t dict)=0; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TNamedThe TNamed class is t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClassTable_8cxx_source.html:45946,load,load,45946,doc/v632/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClassTable_8cxx_source.html,1,['load'],['load']
Performance,"assTable::AddAlternatestatic ROOT::TClassAlt * AddAlternate(const char *normname, const char *alternate)Definition TClassTable.cxx:507; TClassTable::fgCursorstatic UInt_t fgCursorDefinition TClassTable.h:53; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::fClassVersionVersion_t fClassVersionDefinition TClass.h:221; TClass::SetUnloadedvoid SetUnloaded()Call this method to indicate that the shared library containing this class's code has been removed (u...Definition TClass.cxx:6376; TClass::SetClassVersionvoid SetClassVersion(Version_t version)Private function.Definition TClass.cxx:5742; TClass::fVersionUsedstd::atomic< Bool_t > fVersionUsedsaved remember if fOffsetStreamer has been set.Definition TClass.h:262; TClass::kHasTClassInit@ kHasTClassInitDefinition TClass.h:127; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TInterpreter::RegisterTClassUpdatevirtual void RegisterTClassUpdate(TClass *oldcl, DictFuncPtr_t dict)=0; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TNamedThe TNamed class is t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClassTable_8cxx_source.html:45946,load,load,45946,doc/master/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html,1,['load'],['load']
Performance,"ass_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Types; enum  EStatusBits { kIsOwnerValue = (1ULL << ( 15 )); };  ;  Protected Types inherited from TCollection; enum  EStatusBits { kIsOwner = (1ULL << ( 14 )); , kUseRWLock = (1ULL << ( 16 )); };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const override;  Print the collection entry. ;  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions;  TMap (const TMap &map)=delete;  ; TMap & operator= (const TMap &map)=delete;  . Private Attributes; THashTable * fTable;  . Friends; class TMapIter;  . Additional Inherited Members;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . #include <TMap.h>. Inheritance diagram for TMap:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ Iterator_t. typedef TMapIter TMap::Iterator_t. Definition at line 56 of f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMap.html:15903,perform,perform,15903,doc/master/classTMap.html,https://root.cern,https://root.cern/doc/master/classTMap.html,1,['perform'],['perform']
Performance,"ass_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions;  TPluginManager (const TPluginManager &)=delete;  true if we are running LoadHandlersFromPluginDirs ;  ; void LoadHandlerMacros (const char *path);  Load all plugin macros from the specified path/base directory. ;  ; TPluginManager & operator= (const TPluginManager &)=delete;  . Private Attributes; THashTable * fBasesLoaded;  ; TList * fHandlers;  ; Bool_t fReadingDirs;  table of base classes already checked or loaded ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPluginManager.html:14187,load,loaded,14187,doc/master/classTPluginManager.html,https://root.cern,https://root.cern/doc/master/classTPluginManager.html,1,['load'],['loaded']
Performance,"ass_ShowMembers (TClass *cl, const void *obj, TMemberInspector &);  Indirect call to the implementation of ShowMember allowing [forward] declaration with out a full definition of the TClass class. ;  ; static UInt_t ClassTableHash (const char *name, UInt_t size);  ; int CompressionSettings (RCompressionSetting::EAlgorithm::EValues algorithm, int compressionLevel);  ; int CompressionSettings (ROOT::ECompressionAlgorithm algorithm, int compressionLevel);  Deprecated name, do not use: ;  ; TClass * CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; TClass * CreateClass (const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; void DisableImplicitMT ();  Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ;  ; void EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ;  ; void EnableThreadSafety ();  Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (ROOT::Internal::TStringView str, T &value);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:8994,multi-thread,multi-threading,8994,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,2,['multi-thread'],['multi-threading']
Performance,"ass_ShowMembers (TClass *cl, const void *obj, TMemberInspector &);  Indirect call to the implementation of ShowMember allowing [forward] declaration with out a full definition of the TClass class. ;  ; static UInt_t ClassTableHash (const char *name, UInt_t size);  ; int CompressionSettings (RCompressionSetting::EAlgorithm::EValues algorithm, int compressionLevel);  ; int CompressionSettings (ROOT::ECompressionAlgorithm algorithm, int compressionLevel);  Deprecated name, do not use: ;  ; TClass * CreateClass (const char *cname, Version_t id, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; TClass * CreateClass (const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il);  Global function called by a class' static Dictionary() method (see the ClassDef macro). ;  ; void DisableImplicitMT ();  Disables the implicit multi-threading in ROOT (see EnableImplicitMT). ;  ; void EnableImplicitMT (UInt_t numthreads=0);  Enable ROOT's implicit multi-threading for all objects and methods that provide an internal parallelisation mechanism. ;  ; void EnableThreadSafety ();  Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ;  ; static std::string::size_type FindEndSymbol (std::string &command);  ; template<typename T > ; EFromHumanReadableSize FromHumanReadableSize (std::string_view str, T &value);  Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB, 3.7GiB, 5MiB with some amount of forgiveness baked into the parsing. ;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT.html:13648,multi-thread,multi-threading,13648,doc/v632/namespaceROOT.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"ass_Version(). static constexpr Version_t TGeoNavigator::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 282 of file TGeoNavigator.h. ◆ CrossBoundaryAndLocate(). TGeoNode * TGeoNavigator::CrossBoundaryAndLocate ; (; Bool_t ; downwards, . TGeoNode * ; skipnode . ). Cross next boundary and locate within current node The current point must be on the boundary of fCurrentNode. ; Definition at line 523 of file TGeoNavigator.cxx. ◆ CrossDivisionCell(). TGeoNode * TGeoNavigator::CrossDivisionCell ; (; ). protected . Cross a division cell. ; Distance to exit contained in fStep, current node points to the cell node. ; Definition at line 461 of file TGeoNavigator.cxx. ◆ DeclFileName(). static const char * TGeoNavigator::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 282 of file TGeoNavigator.h. ◆ DoBackupState(). void TGeoNavigator::DoBackupState ; (; ). Backup the current state without affecting the cache stack. ; Definition at line 2648 of file TGeoNavigator.cxx. ◆ DoRestoreState(). void TGeoNavigator::DoRestoreState ; (; ). Restore a backed-up state without affecting the cache stack. ; Definition at line 2657 of file TGeoNavigator.cxx. ◆ FindInCluster(). TGeoNode * TGeoNavigator::FindInCluster ; (; Int_t * ; cluster, . Int_t ; nc . ). protected . Find a node inside a cluster of overlapping nodes. ; Current node must be on top of all the nodes in cluster. Always nc>1. ; Definition at line 2159 of file TGeoNavigator.cxx. ◆ FindNextBoundary(). TGeoNode * TGeoNavigator::FindNextBoundary ; (; Double_t ; stepmax = TGeoShape::Big(), . const char * ; path = """", . Bool_t ; frombdr = kFALSE . ). Find distance to next boundary and store it in fStep. ; Returns node to which this boundary belongs. If PATH is specified, compute only distance to the node to which PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller than this value. STEPMAX re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:26262,cache,cache,26262,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['cache'],['cache']
Performance,"assed to RooAbsPdf::fitTo() (see the documentation of said function to learn more about the interpretation of fits with squared weights). ; [in]doOffsetSee RooAbsPdf::extendedTerm(double, RooArgSet const*, double, bool) const. . Definition at line 793 of file RooAbsPdf.cxx. ◆ extendMode(). virtual ExtendMode RooAbsPdf::extendMode ; (; ); const. inlinevirtual . Returns ability of PDF to provide extended likelihood terms. ; Possible answers are in the enumerator RooAbsPdf::ExtendMode. This default implementation always returns CanNotBeExtended. ; Reimplemented in RooAddModel, RooAddPdf, RooBinSamplingPdf, RooExtendedTerm, RooExtendPdf, RooProdPdf, RooProjectedPdf, RooRealSumPdf, RooSimultaneous, RooNormalizedPdf, RooFixedProdPdf, and xRooProjectedPdf.; Definition at line 216 of file RooAbsPdf.h. ◆ fitTo(). template<typename... CmdArgs_t> . RooAbsPdf::fitTo ; (; RooAbsData & ; data, . CmdArgs_t const &... ; cmdArgs . ). inline . Fit PDF to given dataset. ; If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT commands MIGRAD, HESSE in succession.; Parameters. dataReference to a RooAbsData object representing the dataset. ; cmdArgsVariadic template arguments representing optional command arguments. You can pass either an arbitrary number of RooCmdArg instances or a single RooLinkedList that points to the RooCmdArg objects. . ReturnsAn owning pointer to the created RooAbsReal NLL object. . RooFitResult with fit status and parameters if option Save() is used, nullptr otherwise. The user takes ownership of the fit result.; Template Parameters. CmdArgs_tTemplate types for optional command arguments. Can either be an arbitrary number of RooCmdArg or a single RooLinkedList. NoteThis front-end function should not be re-implemented in derived PDF types. If you mean to customize the likelihood fitting routine, you need to override the virtual RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:104059,perform,performed,104059,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['perform'],['performed']
Performance,"asses and related header files; 282 const TROOT::FwdDeclArgsToKeepCollection_t fFwdNargsToKeepColl; // Collection of; 283 // pairs of template fwd decls and number of; 284 bool fHasCxxModule; // Whether this module has a C++ module alongside it.; 285 };; 286 ; 287 std::vector<ModuleHeaderInfo_t>& GetModuleHeaderInfoBuffer() {; 288 static std::vector<ModuleHeaderInfo_t> moduleHeaderInfoBuffer;; 289 return moduleHeaderInfoBuffer;; 290 }; 291}; 292 ; 293Int_t TROOT::fgDirLevel = 0;; 294Bool_t TROOT::fgRootInit = kFALSE;; 295 ; 296static void at_exit_of_TROOT() {; 297 if (ROOT::Internal::gROOTLocal); 298 ROOT::Internal::gROOTLocal->~TROOT();; 299}; 300 ; 301// This local static object initializes the ROOT system; 302namespace ROOT {; 303namespace Internal {; 304 class TROOTAllocator {; 305 // Simple wrapper to separate, time-wise, the call to the; 306 // TROOT destructor and the actual free-ing of the memory.; 307 //; 308 // Since the interpreter implementation (currently TCling) is; 309 // loaded via dlopen by libCore, the destruction of its global; 310 // variable (i.e. in particular clang's) is scheduled before; 311 // those in libCore so we need to schedule the call to the TROOT; 312 // destructor before that *but* we want to make sure the memory; 313 // stay around until libCore itself is unloaded so that code; 314 // using gROOT can 'properly' check for validity.; 315 //; 316 // The order of loading for is:; 317 // libCore.so; 318 // libRint.so; 319 // ... anything other library hard linked to the executable ...; 320 // ... for example libEvent; 321 // libCling.so; 322 // ... other libraries like libTree for example ....; 323 // and the destruction order is (of course) the reverse.; 324 // By default the unloading of the dictionary, does use; 325 // the service of the interpreter ... which of course; 326 // fails if libCling is already unloaded by that information; 327 // has not been registered per se.; 328 //; 329 // To solve this problem, we now schedule the de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:10275,load,loaded,10275,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['loaded']
Performance,"assification Class Reference. . Definition at line 162 of file Classification.h. Public Member Functions;  Classification (DataLoader *loader, TFile *file, TString options);  Contructor to create a two class classifier. ;  ;  Classification (DataLoader *loader, TString options);  Contructor to create a two class classifier without output file. ;  ;  ~Classification ();  ; virtual void Evaluate ();  Method to perform Train/Test over all ml method booked. ;  ; MethodBase * GetMethod (TString methodname, TString methodtitle);  Return a TMVA::MethodBase object. ;  ; std::vector< ClassificationResult > & GetResults ();  Return the vector of TMVA::Experimental::ClassificationResult objects. ;  ; virtual TClass * IsA () const;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Test ();  Perform test evaluation in all booked methods. ;  ; virtual void TestMethod (TString methodname, TString methodtitle);  Lets perform test an specific ml method. ;  ; virtual void TestMethod (Types::EMVA method, TString methodtitle);  Lets perform test an specific ml method given the method type in enum TMVA::Types::EMVA. ;  ; virtual void Train ();  Method to train all booked ml methods. ;  ; virtual void TrainMethod (TString methodname, TString methodtitle);  Lets train an specific ml method. ;  ; virtual void TrainMethod (Types::EMVA method, TString methodtitle);  Lets train an specific ml method given the method type in enum TMVA::Types::EMVA. ;  ;  Public Member Functions inherited from TMVA::Envelope;  ~Envelope ();  Default destructor. ;  ; virtual void BookMethod (TString methodname, TString methodtitle, TString options="""");  Method to book the machine learning method to perform the algorithm. ;  ; virtual void BookMethod (Types::EMVA method, TString methodtitle, TString options="""");  Method to book the machine learning method to perform the algorithm. ;  ; DataLoader * GetDataLo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Experimental_1_1Classification.html:1343,perform,perform,1343,doc/master/classTMVA_1_1Experimental_1_1Classification.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Experimental_1_1Classification.html,1,['perform'],['perform']
Performance,"assigned keyboard mnemonic for its choice. A button that prompts more information for users has the label generally followed by ellipsis (…). As we saw the hot strings “&Draw” and “&Exit” define the text labels “Draw” and “Exit” and keyboard mnemonics Alt+D, Alt+E for their selection. The letter D and E appear underlined on the screen. All text buttons should have a unique shortcut key with the exception of OK and Cancel.; These buttons are usually placed within a window to provide fast access to frequently used or critical commands. They help in situations where a command is not available through the menu bar. You already know that a command string can be passed in the text button via the constructor:; TGTextButton(const TGWindow *p, const char *s, const char *cmd,; Int_t id, GContext_t norm, FontStruct_t font,; UInt_t options);; A button label can be changed by SetText(new_label). There are important guidelines to be followed about a button label. The text has to provide a meaningful description of the performed action. The single-word label should be used whenever possible, only two-three words for clarity, if necessary. Do not number labels. Always follow all platform presentation and usage guidelines for standard button functions. Let’s remember a few standard names and definitions of well known buttons:; OK - any changed information in a window is accepted and the window is closed;; Cancel - closes window without implementing submitted changes;; Reset- resets defaults and cancels any changed information that has not be submitted;; Apply - any changed information is accepted and again displayed in the window that remains open;; Close - closes the window;; Help - opens online Help.; Below are examples of text buttons. Note the two placement methods. The first example should be used when there are one to three command buttons; the second one when there are more than three buttons. Picture buttons are usually rectangular in shape with an icon or graphics label. Th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1178206,perform,performed,1178206,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performed']
Performance,"assstatic; GetDictionary(const char *name)TDictionarystatic; GetDictionary(const std::type_info &typeinfo)TDictionarystatic; GetDirectoryAutoAdd() constTClass; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetFunctionTemplate(const char *name)TClass; GetHeapInstanceCount() constTClassinline; GetIconName() constTObjectvirtual; GetIdMap()TClassprivatestatic; GetImplFileLine() constTClassinline; GetImplFileName() constTClassinline; GetInstanceCount() constTClassinline; GetIsAProxy() constTClass; GetLastReadInfo() constTClassinline; GetListOfAllPublicDataMembers(Bool_t load=kTRUE)TClass; GetListOfAllPublicMethods(Bool_t load=kTRUE)TClass; GetListOfBases()TClass; GetListOfDataMembers(Bool_t load=kTRUE)TClass; GetListOfEnums(Bool_t load=kTRUE)TClass; GetListOfFunctionTemplates(Bool_t load=kTRUE)TClass; GetListOfMethodOverloads(const char *name) constTClass; GetListOfMethods(Bool_t load=kTRUE)TClass; GetListOfRealData() constTClassinline; GetListOfUsingDataMembers(Bool_t load=kTRUE)TClass; GetMenuItems(TList *listitems)TClass; GetMenuList() constTClass; GetMerge() constTClass; GetMethod(const char *method, const char *params, Bool_t objectIsConst=kFALSE)TClass; GetMethodAllAny(const char *method)TClass; GetMethodAny(const char *method)TClass; GetMethodList()TClassprivate; GetMethodWithPrototype(const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)TClass; GetMissingDictionaries(THashTable &result, bool recurse=false)TClass; GetMissingDictionariesForBaseClasses(TCollection &result, TCollection &visited, bool recurse)TClassprotected; GetMissingDictionariesForMembers(TCollection &result, TCollection &visited, bool recurse)TClassprotected; GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)TClassprotected; GetMissingDictionariesWithRecursionCheck(TCollection &result, TCollection &visited, bool recurse)TClassprotected; GetName() const overrideTNamedinl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass-members.html:9713,load,load,9713,doc/master/classTClass-members.html,https://root.cern,https://root.cern/doc/master/classTClass-members.html,1,['load'],['load']
Performance,"ast TProcessID in the file. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from file.; If the object is not already entered in the gROOT list, it is added. UInt_t GetTRefExecId(); Return the exec id stored in the current TStreamerInfo element.; The execid has been saved in the unique id of the TStreamerElement; being read by TStreamerElement::Streamer.; The current element (fgElement) is set as a static global; by TStreamerInfo::ReadBuffer (Clones) when reading this TRef. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pid is already in the file.; If not, add it and return the index number in the local file list. void ForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); force writing the TStreamerInfo to the file. void ForceWriteInfoClones(TClonesArray* a); Make sure TStreamerInfo is not optimized, otherwise it will not be; possible to support schema evolution in read mode.; In case the StreamerInfo has already been computed and optimized,; one must disable the option BypassStreamer. Int_t ReadClones(TClonesArray* a, Int_t nobjects, Version_t objvers); Interface to TStreamerInfo::ReadBufferClones. Int_t WriteClones(TClonesArray* a, Int_t nobjects); Interface to TStreamerInfo::WriteBufferClones. Int_t ReadClassEmulated(const TClass* cl, void* object, const TClass* onfile_class); Read emulated class. Int_t ReadClassBuffer(const TClass* cl, void* pointer, Int_t version, UInt_t start, UInt_t count, const TClass* onfile_class); Deserialize information from a buffer into an object. Note: This function is called by the xxx::Streamer(); functions in rootcint-generated dictionaries.; // This function assumes that the class version and the byte count; information have been read. version is the version number of the class; start is the starting position in the buffer b; count is the number of bytes for this object in the buffer. Int_t ReadClassBuffer(const TClass* cl, void* pointer, const TClass* onfile_class); Deserial",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferFile.html:42432,optimiz,optimized,42432,root/html526/TBufferFile.html,https://root.cern,https://root.cern/root/html526/TBufferFile.html,7,['optimiz'],['optimized']
Performance,"ast send packetDefinition RWebWindow.hxx:88; ROOT::RWebWindow::WebConn::fKeyUsedint fKeyUsed! key value used to verify connectionDefinition RWebWindow.hxx:73; ROOT::RWebWindow::WebConn::~WebConn~WebConn()Destructor for WebConn Notify special HTTP request which blocks headless browser from exit.Definition RWebWindow.cxx:42; ROOT::RWebWindow::WebConn::fMutexstd::mutex fMutex! mutex must be used to protect all following dataDefinition RWebWindow.hxx:81; ROOT::RWebWindow::WebConn::fDoingSendbool fDoingSend! true when performing send operationDefinition RWebWindow.hxx:86; ROOT::RWebWindow::WebConn::fSendCreditsint fSendCredits! how many send operation can be performed without confirmation from other sideDefinition RWebWindow.hxx:84; ROOT::RWebWindow::WebConn::WebConnWebConn(unsigned connid, unsigned wsid)Definition RWebWindow.hxx:93; ROOT::RWebWindow::WebConn::fNewKeystd::string fNewKey! new key if connection request reloadDefinition RWebWindow.hxx:74; ROOT::RWebWindow::WebConn::fWSIdunsigned fWSId! websocket idDefinition RWebWindow.hxx:79; ROOT::RWebWindow::WebConn::fSendStamptimestamp_t fSendStamp! last server operation, always used from window threadDefinition RWebWindow.hxx:77; ROOT::RWebWindow::WebConn::fRecvStamptimestamp_t fRecvStamp! last receive operation, protected with connection mutexDefinition RWebWindow.hxx:82; ROOT::RWebWindow::WebConn::fRecvCountint fRecvCount! number of received packets, should return back with next sendingDefinition RWebWindow.hxx:83; ROOT::RWebWindow::WebConn::ResetStampsvoid ResetStamps()Definition RWebWindow.hxx:101; ROOT::RWebWindow::WebConn::fQueuestd::queue< QueueItem > fQueue! output queueDefinition RWebWindow.hxx:89; ROOT::RWebWindow::WebConn::fDisplayHandlestd::unique_ptr< RWebDisplayHandle > fDisplayHandle! handle assigned with started web display (when exists)Definition RWebWindow.hxx:75. guiwebdisplayincROOTRWebWindow.hxx. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:08:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:50851,queue,queue,50851,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,2,['queue'],"['queue', 'queueDefinition']"
Performance,"at ComputeTopMass(float lep_pt, float lep_eta, float lep_phi, float lep_e, float jet_pt, float jet_eta, float jet_phi, float jet_e, float met_et, float met_phi); {; const ROOT::Math::PtEtaPhiEVector lep(lep_pt / 1000.0, lep_eta, lep_phi, lep_e / 1000.0);; const ROOT::Math::PtEtaPhiEVector met(met_et / 1000.0, 0, met_phi, met_et / 1000.0);; const ROOT::Math::PtEtaPhiEVector bjet(jet_pt / 1000.0, jet_eta, jet_phi, jet_e / 1000.0);; // Please note that we treat here the missing transverse energy as the neutrino, even though the z component is missing!; return (lep + met + bjet).M();; }; """"""); ; histos = {}; for s in samples:; df[s] = df[s].Define(""top_mass"", ""ComputeTopMass(lep_pt[idx_lep], lep_eta[idx_lep], lep_phi[idx_lep], lep_E[idx_lep], jet_pt[idx_tagged], jet_eta[idx_tagged], jet_phi[idx_tagged], jet_E[idx_tagged], met_et, met_phi)""); histos[s] = df[s].Histo1D(ROOT.RDF.TH1DModel(""top_mass"", """", 10, 100, 400), ""top_mass"", ""weight""); ; # Run the event loop and merge histograms of the respective processes; ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([histos[s] for s in samples]); ; def merge_histos(label):; h = None; for i, d in enumerate(files[label]):; t = histos[d[1]].GetValue(); if i == 0: h = t.Clone(); else: h.Add(t); h.SetNameTitle(label, label); return h; ; data = merge_histos(""data""); twtb = merge_histos(""twtb""); singletop = merge_histos(""singletop""); wjets = merge_histos(""wjets""); ; # Create the plot; ; # Set styles; ROOT.gROOT.SetStyle(""ATLAS""); ; # Create canvas with pad; c = ROOT.TCanvas(""c"", """", 600, 600); pad = ROOT.TPad(""upper_pad"", """", 0, 0, 1, 1); pad.SetTickx(False); pad.SetTicky(False); pad.Draw(); pad.cd(); ; # Draw stack with MC contributions; stack = ROOT.THStack(); wjets.Scale(1.1) # Corrected nor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:8348,concurren,concurrently,8348,doc/master/df107__SingleTopAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html,1,['concurren'],['concurrently']
Performance,"at cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooCachedReal.h>. Inheritance diagram for RooCachedReal:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooCachedReal() [1/4]. RooCachedReal::RooCachedReal ; (; ). inline . Definition at line 22 of file RooCachedReal.h. ◆ RooCachedReal() [2/4]. RooCachedReal::RooCachedReal ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _func, . const RooArgSet & ; cacheObs . ). Constructor taking name, title and function to be cached and fixed choice of variable to cache. ; To control granularity of the binning of the cache histogram set the desired properties in the binning named ""cache"" in the observables of the function. If the fixed set of cache observables does not match the observables defined in the use context of the p.d.f the cache is still filled completely. Ee.g. when it is specified to cache x and p and only x is a observable in the given use context the cache histogram will store sampled values for all values of observable x and parameter p. In such a mode of operation the cache will also not be recalculated if the observable p changes ; Definition at line 68 of file RooCachedReal.cxx. ◆ RooCachedReal() [3/4]. RooCachedReal::RooCachedReal ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _func . ). Constructor taking name, title and function to be cached. ; To control granularity of the binning of the cache histogram set the desired properties in the binning named ""cache"" in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:63609,cache,cached,63609,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,2,['cache'],"['cache', 'cached']"
Performance,"at has to be done.; This machine independent version of the data is copied into a basket (each branch has its own basket). When a basket is full (32k worth of data by default), it is then optionally compressed and written to disk (this operation is also called committing or 'flushing' the basket). The committed baskets are then immediately removed from memory.; The function returns the number of bytes committed to the individual branches.; If a write error occurs, the number of bytes returned is -1.; If no data are written, because, e.g., the branch is disabled, the number of bytes returned is 0.; The baskets are flushed and the Tree header saved at regular intervals; At regular intervals, when the amount of data written so far is greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk. This makes future reading faster as it guarantees that baskets belonging to nearby entries will be on the same disk region. When the first call to flush the baskets happen, we also take this opportunity to optimize the baskets buffers. We also check if the amount of data written is greater than fAutoSave (see SetAutoSave). In this case we also write the Tree header. This makes the Tree recoverable up to this point in case the program writing the Tree crashes. The decisions to FlushBaskets and Auto Save can be made based either on the number of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries written (fAutoFlush and fAutoSave positive). Note that the user can decide to call FlushBaskets and AutoSave in her event loop base on the number of events written instead of the number of bytes written.; NoteCalling TTree::FlushBaskets too often increases the IO time. Calling TTree::AutoSave too often increases the IO time and also the file size. This method calls TTree::ChangeFile when the tree reaches a size greater than TTree::fgMaxTreeSize. This doesn't happen if the tree is attached to a TMemFile or derivate. ; Reimplemented from TTree.; D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:70692,optimiz,optimize,70692,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,2,['optimiz'],['optimize']
Performance,"at has to be done.; This machine independent version of the data is copied into a basket (each branch has its own basket). When a basket is full (32k worth of data by default), it is then optionally compressed and written to disk (this operation is also called committing or 'flushing' the basket). The committed baskets are then immediately removed from memory.; The function returns the number of bytes committed to the individual branches.; If a write error occurs, the number of bytes returned is -1.; If no data are written, because, e.g., the branch is disabled, the number of bytes returned is 0.; The baskets are flushed and the Tree header saved at regular intervals; At regular intervals, when the amount of data written so far is greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk. This makes future reading faster as it guarantees that baskets belonging to nearby entries will be on the same disk region. When the first call to flush the baskets happen, we also take this opportunity to optimize the baskets buffers. We also check if the amount of data written is greater than fAutoSave (see SetAutoSave). In this case we also write the Tree header. This makes the Tree recoverable up to this point in case the program writing the Tree crashes. The decisions to FlushBaskets and Auto Save can be made based either on the number of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries written (fAutoFlush and fAutoSave positive). Note that the user can decide to call FlushBaskets and AutoSave in her event loop base on the number of events written instead of the number of bytes written.; NoteCalling TTree::FlushBaskets too often increases the IO time. Calling TTree::AutoSave too often increases the IO time and also the file size. This method calls TTree::ChangeFile when the tree reaches a size greater than TTree::fgMaxTreeSize. This doesn't happen if the tree is attached to a TMemFile or derivate. ; Reimplemented in TChain, TNt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:139921,optimiz,optimize,139921,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['optimiz'],['optimize']
Performance,at line 126 of file TLinearMinimizer.h. ◆ Edm(). double TLinearMinimizer::Edm ; (; ); const. inlineoverridevirtual . return expected distance reached from the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 66 of file TLinearMinimizer.h. ◆ Errors(). const double * TLinearMinimizer::Errors ; (; ); const. inlineoverridevirtual . return errors at the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 89 of file TLinearMinimizer.h. ◆ IsA(). virtual TClass * TLinearMinimizer::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Definition at line 126 of file TLinearMinimizer.h. ◆ MinGradient(). const double * TLinearMinimizer::MinGradient ; (; ); const. inlineoverridevirtual . return pointer to gradient values at the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 72 of file TLinearMinimizer.h. ◆ Minimize(). bool TLinearMinimizer::Minimize ; (; ). overridevirtual . method to perform the minimization ; Implements ROOT::Math::Minimizer.; Definition at line 197 of file TLinearMinimizer.cxx. ◆ MinValue(). double TLinearMinimizer::MinValue ; (; ); const. inlineoverridevirtual . return minimum function value ; Implements ROOT::Math::Minimizer.; Definition at line 63 of file TLinearMinimizer.h. ◆ NCalls(). unsigned int TLinearMinimizer::NCalls ; (; ); const. inlineoverridevirtual . number of function calls to reach the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 75 of file TLinearMinimizer.h. ◆ NDim(). unsigned int TLinearMinimizer::NDim ; (; ); const. inlineoverridevirtual . this is <= Function().NDim() which is the total number of variables (free+ constrained ones) ; Implements ROOT::Math::Minimizer.; Definition at line 79 of file TLinearMinimizer.h. ◆ NFree(). unsigned int TLinearMinimizer::NFree ; (; ); const. inlineoverridevirtual . number of free variables (real dimension of the problem) this is <= Function().NDim() which is the total ; Reimplemented fro,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLinearMinimizer.html:14129,perform,perform,14129,doc/master/classTLinearMinimizer.html,https://root.cern,https://root.cern/doc/master/classTLinearMinimizer.html,1,['perform'],['perform']
Performance,"at line 138 of file TTreeCache.h. ◆ GetTree(). TTree * TTreeCache::GetTree ; (; ); const. inline . Definition at line 149 of file TTreeCache.h. ◆ IsA(). TClass * TTreeCache::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 175 of file TTreeCache.h. ◆ IsAutoCreated(). bool TTreeCache::IsAutoCreated ; (; ); const. inline . Definition at line 150 of file TTreeCache.h. ◆ IsEnabled(). virtual bool TTreeCache::IsEnabled ; (; ); const. inlinevirtual . Definition at line 151 of file TTreeCache.h. ◆ IsLearning(). bool TTreeCache::IsLearning ; (; ); const. inlineoverridevirtual . Reimplemented from TFileCacheRead.; Definition at line 152 of file TTreeCache.h. ◆ LearnBranch(). Int_t TTreeCache::LearnBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ; Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Definition at line 350 of file TTreeCache.cxx. ◆ LearnPrefill(). void TTreeCache::LearnPrefill ; (; ). virtual . Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ; Definition at line 2250 of file TTreeCache.cxx. ◆ operator=(). TTreeCache & TTreeCache::operator= ; (; const TTreeCache & ; ). privatedelete . ◆ Print(). void TTreeCache::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; Like:; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Read",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:43267,cache,cache,43267,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['cache'],['cache']
Performance,"at line 138 of file TTreeCache.h. ◆ GetTree(). TTree * TTreeCache::GetTree ; (; ); const. inline . Definition at line 149 of file TTreeCache.h. ◆ IsA(). TClass * TTreeCache::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 175 of file TTreeCache.h. ◆ IsAutoCreated(). bool TTreeCache::IsAutoCreated ; (; ); const. inline . Definition at line 150 of file TTreeCache.h. ◆ IsEnabled(). virtual bool TTreeCache::IsEnabled ; (; ); const. inlinevirtual . Definition at line 151 of file TTreeCache.h. ◆ IsLearning(). bool TTreeCache::IsLearning ; (; ); const. inlineoverridevirtual . Reimplemented from TFileCacheRead.; Definition at line 152 of file TTreeCache.h. ◆ LearnBranch(). Int_t TTreeCache::LearnBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch discovered by actual usage to the list of branches to be stored in the cache this function is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ; Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Definition at line 350 of file TTreeCache.cxx. ◆ LearnPrefill(). void TTreeCache::LearnPrefill ; (; ). virtual . Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ; Definition at line 2251 of file TTreeCache.cxx. ◆ operator=(). TTreeCache & TTreeCache::operator= ; (; const TTreeCache & ; ). privatedelete . ◆ Print(). void TTreeCache::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; Like:; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Read",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:43271,cache,cache,43271,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['cache'],['cache']
Performance,"at line 1806 of file TSystem.cxx. ◆ Setenv(). void TSystem::Setenv ; (; const char * ; name, . const char * ; value . ). virtual . Set environment variable. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1649 of file TSystem.cxx. ◆ SetErrorStr(). void TSystem::SetErrorStr ; (; const char * ; errstr). Set the system error string. ; This string will be used by GetError(). To be used in case one does not want or can use the system error string (e.g. because error is generated by a third party POSIX like library that does not use standard errno). ; Definition at line 245 of file TSystem.cxx. ◆ SetFlagsDebug(). void TSystem::SetFlagsDebug ; (; const char * ; flags). virtual . FlagsDebug should contain the options to pass to the C++ compiler in order to compile the library in debug mode. ; Definition at line 4056 of file TSystem.cxx. ◆ SetFlagsOpt(). void TSystem::SetFlagsOpt ; (; const char * ; flags). virtual . FlagsOpt should contain the options to pass to the C++ compiler in order to compile the library in optimized mode. ; Definition at line 4065 of file TSystem.cxx. ◆ SetFPEMask(). Int_t TSystem::SetFPEMask ; (; Int_t ; mask = kDefaultMask). virtual . Set which conditions trigger a floating point exception. ; Return the previous set of conditions. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 642 of file TSystem.cxx. ◆ SetIncludePath(). void TSystem::SetIncludePath ; (; const char * ; includePath). virtual . IncludePath should contain the list of compiler flags to indicate where to find user defined header files. ; It is used to expand $IncludePath in the directives given to SetMakeSharedLib() and SetMakeExe(), e.g.: gSystem->SetInclude(""-I$ROOTSYS/include -Imydirectory/include"");; the default value of IncludePath on Unix is: ""-I$ROOTSYS/include ""; and on Windows: ""/I%ROOTSYS%/include "". Definition at line 4194 of file TSystem.cxx. ◆ SetLinkdefSuffix(). void TSystem::SetLinkdefSuffix ; (; const char * ; suffix). virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:85423,optimiz,optimized,85423,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['optimiz'],['optimized']
Performance,"at line 310 of file TBasket.cxx. ◆ operator=(). TBasket & TBasket::operator= ; (; const TBasket & ; ). private . TBasket objects are not copiable. . ◆ PrepareBasket(). virtual void TBasket::PrepareBasket ; (; Long64_t ; ). inlinevirtual . Reimplemented in TBasketSQL.; Definition at line 133 of file TBasket.h. ◆ ReadBasketBuffers(). Int_t TBasket::ReadBasketBuffers ; (; Long64_t ; pos, . Int_t ; len, . TFile * ; file . ). Read basket buffers in memory and cleanup. ; Read a basket buffer. Check if buffers of previous ReadBasket should not be dropped. Remember, we keep buffers in memory up to fMaxVirtualSize. The function returns 0 in case of success, 1 in case of error This function was modified with the addition of the parallel unzipping, it will try to get the unzipped file from the cache receiving only a pointer to that buffer (so we shall not delete that pointer), although we get a new buffer in case it's not found in the cache. There is a lot of code duplication but it was necessary to assure the expected behavior when there is no cache. ; Definition at line 464 of file TBasket.cxx. ◆ ReadBasketBuffersUncompressedCase(). Int_t TBasket::ReadBasketBuffersUncompressedCase ; (; ). private . By-passing buffer unzipping has been requested and is possible (only 1 entry in this basket). ; Definition at line 358 of file TBasket.cxx. ◆ ReadBasketBuffersUnzip(). Int_t TBasket::ReadBasketBuffersUnzip ; (; char * ; buffer, . Int_t ; size, . bool ; mustFree, . TFile * ; file . ). private . We always create the TBuffer for the basket but it hold the buffer from the cache. ; Definition at line 380 of file TBasket.cxx. ◆ ReadBasketBytes(). Int_t TBasket::ReadBasketBytes ; (; Long64_t ; pos, . TFile * ; file . ). Read basket buffers in memory and cleanup. ; Read first bytes of a logical record starting at position pos return record length (first 4 bytes of record). ; Definition at line 698 of file TBasket.cxx. ◆ ReadResetBuffer(). void TBasket::ReadResetBuffer ; (; Int_t ; basketn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBasket.html:27387,cache,cache,27387,doc/master/classTBasket.html,https://root.cern,https://root.cern/doc/master/classTBasket.html,1,['cache'],['cache']
Performance,"at line 456 of file Integrator.h. ◆ Result(). double ROOT::Math::IntegratorOneDim::Result ; (; ); const. inline . return the Result of the last Integral calculation ; Definition at line 411 of file Integrator.h. ◆ SetAbsTolerance(). void ROOT::Math::IntegratorOneDim::SetAbsTolerance ; (; double ; absTolerance). inline . set the desired absolute Error ; Definition at line 441 of file Integrator.h. ◆ SetFunction() [1/3]. void ROOT::Math::IntegratorOneDim::SetFunction ; (; const IGenFunction & ; f, . bool ; copy = false . ). inline . set one dimensional function for 1D integration ; Definition at line 202 of file Integrator.h. ◆ SetFunction() [2/3]. void ROOT::Math::IntegratorOneDim::SetFunction ; (; const IMultiGenFunction & ; f, . unsigned int ; icoord, . const double * ; x . ). Set integration function from a multi-dim function type. ; Can be used in case of having 1D function implementing the generic interface Parameters. fintegration function ; icoordindex of coordinate on which the integration is performed ; xarray of the passed variables values. In case of dim=1 a 0 can be passed . Definition at line 100 of file Integrator.cxx. ◆ SetFunction() [3/3]. template<class Function > . void ROOT::Math::IntegratorOneDim::SetFunction ; (; Function & ; f). inline . method to set the a generic integration function ; Parameters. fintegration function. The function type must implement the assignment operator, double operator() ( double x ) . Definition at line 492 of file Integrator.h. ◆ SetOptions(). void ROOT::Math::IntegratorOneDim::SetOptions ; (; const ROOT::Math::IntegratorOneDimOptions & ; opt). inline . set the options ; Definition at line 451 of file Integrator.h. ◆ SetRelTolerance(). void ROOT::Math::IntegratorOneDim::SetRelTolerance ; (; double ; relTolerance). inline . set the desired relative Error ; Definition at line 435 of file Integrator.h. ◆ Status(). int ROOT::Math::IntegratorOneDim::Status ; (; ); const. inline . return the Error Status of the last Integral",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html:20679,perform,performed,20679,doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html,1,['perform'],['performed']
Performance,"at line 69 of file TTreePerfStats.h. ◆ fGraphTime. TGraphErrors* TTreePerfStats::fGraphTime. protected . Pointer to the graph with timestamp info. ; Definition at line 70 of file TTreePerfStats.h. ◆ fHostInfo. TString TTreePerfStats::fHostInfo. protected . Name of the host system, ROOT version and date. ; Definition at line 66 of file TTreePerfStats.h. ◆ fHostInfoText. TText* TTreePerfStats::fHostInfoText. protected . Graphics Text object with the fHostInfo data. ; Definition at line 74 of file TTreePerfStats.h. ◆ fName. TString TTreePerfStats::fName. protected . Name of this TTreePerfStats. ; Definition at line 65 of file TTreePerfStats.h. ◆ fNleaves. Int_t TTreePerfStats::fNleaves. protected . Number of leaves in the tree. ; Definition at line 52 of file TTreePerfStats.h. ◆ fPave. TPaveText* TTreePerfStats::fPave. protected . Pointer to annotation pavetext. ; Definition at line 71 of file TTreePerfStats.h. ◆ fReadaheadSize. Int_t TTreePerfStats::fReadaheadSize. protected . Read-ahead cache size. ; Definition at line 54 of file TTreePerfStats.h. ◆ fReadCalls. Int_t TTreePerfStats::fReadCalls. protected . Number of read calls. ; Definition at line 53 of file TTreePerfStats.h. ◆ fRealNorm. Double_t TTreePerfStats::fRealNorm. protected . Real time scale factor for fGraphTime. ; Definition at line 57 of file TTreePerfStats.h. ◆ fRealTime. Double_t TTreePerfStats::fRealTime. protected . Real time. ; Definition at line 58 of file TTreePerfStats.h. ◆ fRealTimeAxis. TGaxis* TTreePerfStats::fRealTimeAxis. protected . Pointer to TGaxis object showing real-time. ; Definition at line 73 of file TTreePerfStats.h. ◆ fTree. TTree* TTreePerfStats::fTree. protected . ! Pointer to the Tree being monitored ; Definition at line 68 of file TTreePerfStats.h. ◆ fTreeCacheSize. Int_t TTreePerfStats::fTreeCacheSize. protected . TTreeCache buffer size. ; Definition at line 51 of file TTreePerfStats.h. ◆ fUnzipInputSize. Long64_t TTreePerfStats::fUnzipInputSize. protected . Compressed bytes s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePerfStats.html:36015,cache,cache,36015,doc/master/classTTreePerfStats.html,https://root.cern,https://root.cern/doc/master/classTTreePerfStats.html,1,['cache'],['cache']
Performance,"at line 73 of file TSelector.h. ◆ GetEntry(). virtual Int_t TSelector::GetEntry ; (; Long64_t ; , . Int_t ; = 0 . ). inlinevirtual . Reimplemented in RooProofDriverSelector, and TSelectorEntries.; Definition at line 59 of file TSelector.h. ◆ GetInputList(). virtual TList * TSelector::GetInputList ; (; ); const. inlinevirtual . Definition at line 68 of file TSelector.h. ◆ GetOption(). const char * TSelector::GetOption ; (; ); const. inlineoverridevirtual . Reimplemented from TObject.; Definition at line 57 of file TSelector.h. ◆ GetOutputList(). virtual TList * TSelector::GetOutputList ; (; ); const. inlinevirtual . Reimplemented in TSelEvent, TSelVerifyDataSet, TSelEventGen, TSelHandleDataSet, TSelHist, RooProofDriverSelector, TSelectorEntries, h1analysis, and h1analysisTreeReader.; Definition at line 69 of file TSelector.h. ◆ GetSelector(). TSelector * TSelector::GetSelector ; (; const char * ; filename). static . The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid class implementation derived from TSelector. ; If filename is of the form file.C, the file will be interpreted. If filename is of the form file.C++, the file file.C will be compiled and dynamically loaded. The corresponding binary file and shared library will be deleted at the end of the function. If filename is of the form file.C+, the file file.C will be compiled and dynamically loaded. At next call, if file.C is older than file.o and file.so, the file.C is not compiled, only file.so is loaded.; The static function returns a pointer to a TSelector object ; Definition at line 142 of file TSelector.cxx. ◆ GetStatus(). virtual Long64_t TSelector::GetStatus ; (; ); const. inlinevirtual . Definition at line 58 of file TSelector.h. ◆ ImportOutput(). void TSelector::ImportOutput ; (; TList * ; output). virtual . Imports the content of 'output' in the internal output list. ; Existing content in the output list is discarded (unless found also in 'output'). In parti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelector.html:17906,load,loaded,17906,doc/master/classTSelector.html,https://root.cern,https://root.cern/doc/master/classTSelector.html,1,['load'],['loaded']
Performance,"at line 783 of file RooDataSet.cxx. ◆ initialize(). void RooDataSet::initialize ; (; const char * ; wgtVarName). protected . Initialize the dataset. ; If wgtVarName is not null, interpret the observable with that name as event weight ; Definition at line 657 of file RooDataSet.cxx. ◆ IsA(). TClass * RooDataSet::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsData.; Definition at line 143 of file RooDataSet.h. ◆ isNonPoissonWeighted(). bool RooDataSet::isNonPoissonWeighted ; (; ); const. overridevirtual . Returns true if histogram contains bins with entries with a non-integer weight. ; Reimplemented from RooAbsData.; Definition at line 895 of file RooDataSet.cxx. ◆ isWeighted(). bool RooDataSet::isWeighted ; (; ); const. overridevirtual . Return true if dataset contains weighted events. ; Reimplemented from RooAbsData.; Definition at line 885 of file RooDataSet.cxx. ◆ loadValuesFromSlices(). void RooDataSet::loadValuesFromSlices ; (; RooCategory & ; indexCat, . std::map< std::string, RooAbsData * > const & ; slices, . const char * ; rangeName, . RooFormulaVar const * ; cutVar, . const char * ; cutSpec . ). private . Definition at line 1752 of file RooDataSet.cxx. ◆ merge() [1/2]. bool RooDataSet::merge ; (; RooDataSet * ; data1, . RooDataSet * ; data2 = nullptr, . RooDataSet * ; data3 = nullptr, . RooDataSet * ; data4 = nullptr, . RooDataSet * ; data5 = nullptr, . RooDataSet * ; data6 = nullptr . ). Definition at line 1079 of file RooDataSet.cxx. ◆ merge() [2/2]. bool RooDataSet::merge ; (; std::list< RooDataSet * > ; dsetList). Merge columns of supplied data set(s) with this data set. ; All data sets must have equal number of entries. In case of duplicate columns the column of the last dataset in the list prevails ; Definition at line 1101 of file RooDataSet.cxx. ◆ plotOnXY(). RooDataSet::plotOnXY ; (; RooPlot * ; frame, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataSet.html:50004,load,loadValuesFromSlices,50004,doc/master/classRooDataSet.html,https://root.cern,https://root.cern/doc/master/classRooDataSet.html,1,['load'],['loadValuesFromSlices']
Performance,"at line 858 of file TTreeReader.cxx. ◆ Restart(). void TTreeReader::Restart ; (; ). Restart a Next() loop from entry 0 (of TEntryList index 0 of fEntryList is set). ; Definition at line 571 of file TTreeReader.cxx. ◆ SetEntriesRange(). TTreeReader::EEntryStatus TTreeReader::SetEntriesRange ; (; Long64_t ; beginEntry, . Long64_t ; endEntry . ). Set the range of entries to be loaded by Next(); end will not be loaded. ; If end <= begin, end is ignored (set to -1, i.e. will run on all entries from begin onwards).; Example:; reader.SetEntriesRange(3, 5);; while (reader.Next()) {; // Will load entries 3 and 4.; }; Note that if a TEntryList is present, beginEntry and endEntry refer to the beginEntry-th/endEntry-th entries of the TEntryList (or the main TEntryList in case it has sub-entrylists). In other words, SetEntriesRange can be used to only loop over part of the TEntryList, but not to further restrict the actual TTree/TChain entry numbers considered.; Parameters. beginEntryThe first entry to be loaded by Next(). ; endEntryThe entry where Next() will return false, not loading it. . Definition at line 533 of file TTreeReader.cxx. ◆ SetEntry(). EEntryStatus TTreeReader::SetEntry ; (; Long64_t ; entry). inline . Set the next entry (or index of the TEntryList if that is set). ; Parameters. entryIf not TEntryList is set, the entry is a global entry (i.e. not the entry number local to the chain's current tree). . Returnsthe entry's read status, i.e. whether the entry is available. ; Definition at line 225 of file TTreeReader.h. ◆ SetEntryBase(). TTreeReader::EEntryStatus TTreeReader::SetEntryBase ; (; Long64_t ; entry, . bool ; local . ). protected . Load an entry into the tree, return the status of the read. ; For chains, entry is the global (i.e. not tree-local) entry number, unless local is true, in which case entry specifies the entry number within the current tree. This is needed for instance for TSelector::Process(). ; Definition at line 630 of file TTreeReader.cxx. ◆ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReader.html:32039,load,loaded,32039,doc/master/classTTreeReader.html,https://root.cern,https://root.cern/doc/master/classTTreeReader.html,1,['load'],['loaded']
Performance,at line 96 of file TTree.h. ◆ fMaxEntries. Long64_t TTree::fMaxEntries. protected . Maximum number of entries in case of circular buffers. ; Definition at line 97 of file TTree.h. ◆ fMaxEntryLoop. Long64_t TTree::fMaxEntryLoop. protected . Maximum number of entries to process. ; Definition at line 98 of file TTree.h. ◆ fMaxVirtualSize. Long64_t TTree::fMaxVirtualSize. protected . Maximum total size of buffers kept in memory. ; Definition at line 99 of file TTree.h. ◆ fNClusterRange. Int_t TTree::fNClusterRange. protected . Number of Cluster range in addition to the one defined by 'AutoFlush'. ; Definition at line 95 of file TTree.h. ◆ fNEntriesSinceSorting. UInt_t TTree::fNEntriesSinceSorting. protected . ! Number of entries processed since the last re-sorting of branches ; Definition at line 143 of file TTree.h. ◆ fNfill. Int_t TTree::fNfill. protected . ! Local for EntryLoop ; Definition at line 110 of file TTree.h. ◆ fNotify. TObject* TTree::fNotify. protected . Object to be notified when loading a Tree. ; TTree::LoadTree() and TChain::LoadTree() will call fNotify->Notify(). Usually points to a TNotifyLink if this is a TChain. ; Definition at line 120 of file TTree.h. ◆ fPacketSize. Int_t TTree::fPacketSize. protected . ! Number of entries in one packet for parallel root ; Definition at line 109 of file TTree.h. ◆ fPerfStats. TVirtualPerfStats* TTree::fPerfStats. protected . ! pointer to the current perf stats object ; Definition at line 132 of file TTree.h. ◆ fPlayer. TVirtualTreePlayer* TTree::fPlayer. protected . ! Pointer to current Tree player ; Definition at line 134 of file TTree.h. ◆ fReadEntry. Long64_t TTree::fReadEntry. protected . ! Number of the entry being processed ; Definition at line 107 of file TTree.h. ◆ fSavedBytes. Long64_t TTree::fSavedBytes. protected . Number of autosaved bytes. ; Definition at line 88 of file TTree.h. ◆ fScanField. Int_t TTree::fScanField. protected . Number of runs before prompting in Scan. ; Definition at line 92 of file,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:230630,load,loading,230630,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['load'],['loading']
Performance,"at the end points of the interpolation parameter alpha If doCacheAlpha is true, a two-dimensional cache is constructed in both alpha and x. ; Definition at line 101 of file RooIntegralMorph.cxx. ◆ RooIntegralMorph() [3/3]. RooIntegralMorph::RooIntegralMorph ; (; const RooIntegralMorph & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 119 of file RooIntegralMorph.cxx. Member Function Documentation. ◆ actualObservables(). RooFit::OwningPtr< RooArgSet > RooIntegralMorph::actualObservables ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . Observable to be cached for given choice of normalization. ; Returns the 'x' observable unless doCacheAlpha is set in which case a set with both x and alpha ; Implements RooAbsCachedPdf.; Definition at line 134 of file RooIntegralMorph.cxx. ◆ actualParameters(). RooFit::OwningPtr< RooArgSet > RooIntegralMorph::actualParameters ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . Parameters of the cache. ; Returns parameters of both pdf1 and pdf2 and parameter cache, in case doCacheAlpha is not set. ; Implements RooAbsCachedPdf.; Definition at line 148 of file RooIntegralMorph.cxx. ◆ cacheAlpha(). bool RooIntegralMorph::cacheAlpha ; (; ); const. inline . Definition at line 45 of file RooIntegralMorph.h. ◆ Class(). static TClass * RooIntegralMorph::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooIntegralMorph::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooIntegralMorph::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 110 of file RooIntegralMorph.h. ◆ clone(). TObject * RooIntegralMorph::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 35 of file RooIntegralMorph.h. ◆ createCache(). RooAbsCachedPdf::PdfCacheElem * RooIntegralMorph::createCache ; (; const RooAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooIntegralMorph.html:82371,cache,cache,82371,doc/master/classRooIntegralMorph.html,https://root.cern,https://root.cern/doc/master/classRooIntegralMorph.html,1,['cache'],['cache']
Performance,"at the numeric labels, their; size is by default equal to 0.66666 * the_numeric_labels_size.; Number of divisions optimisation; By default the number of divisions on axis is optimised to show a coherent; labelling of the main tick marks. The number of division (ndiv) is a; composite integer given by:. ndiv = N1 + 100*N2 + 10000*N3. N1 = number of 1st divisions.; N2 = number of 2nd divisions.; N3 = number of 3rd divisions. by default the value of N1, N2 and N3 are maximum; values. After optimisation the real number of divisions will be smaller or; equal to these value. If one wants to bypass the optimisation, the option ""N""; should be given when the TGaxis is created. The option ""I""; also act on the number of division as it will force an integer labelling of; the axis. On an histogram pointer h the number of divisions can be set in different; ways:. Directly on the histogram. The following will set the number of division; to 510 on the X axis of h. To avoid optimization the number of divisions; should be negative (ie: -510);. h->SetNdivisions(510, ""X"");. On the axis itself:. h->GetXaxis()->SetNdivisions(510, kTRUE);. The first parameter is the number of division. If it is negative of if the; second parameter is kFALSE then the number of divisions is not optimised.; And other signature is also allowed:. h->GetXaxis()->SetNdivisions(10, 5, 0, kTRUE);. Maximum Number of Digits for the axis labels; The static function TGaxis::SetMaxDigits sets the maximum number of; digits permitted for the axis labels above which the notation with 10^N is used.; For example, to accept 6 digits number like 900000 on an axis call; TGaxis::SetMaxDigits(6). The default value is 5.; fgMaxDigits must be greater than 0.; Optional grid; The option ""W"" allows to draw a grid on the primary tick marks. In case; of a log axis, the grid is only drawn for the primary tick marks if the number; of secondary and tertiary divisions is 0. SetGridLength() allows to define; the length of the grid. When plott",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGaxis.html:11111,optimiz,optimization,11111,root/html604/TGaxis.html,https://root.cern,https://root.cern/root/html604/TGaxis.html,1,['optimiz'],['optimization']
Performance,"at to indicate of Method Transformations have been optained yet or not (normally done in MethodBase::TrainMethod); TStringfOptimizationFitTypewhich type of optimisation procedure to be used; map<TString,TMVA::Interval*>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase*const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). std::vector< int > GetScanIndices(int val, vector<int> base); helper function to scan through the all the combinations in the; parameter space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__OptimizeConfigParameters.html:3416,optimiz,optimizeScan,3416,root/html602/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html602/TMVA__OptimizeConfigParameters.html,4,['optimiz'],"['optimization', 'optimizeScan']"
Performance,"at16(Float_t* f, TStreamerElement* ele = 0); read a Float16_t from the buffer. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); read a Double32_t from the buffer. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have; been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified; (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferJSON does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have; been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified; (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStreamerElement* ele = 0); write a Double32_t to the buffer. Int_t ReadArray(Bool_t*& b); Read array of Bool_t from buffer. Int_t ReadArray(Char_t*& c); Read array of Char_t from buffer. Int_t ReadArray(UChar_t*& c); Read array of UChar_t from buffer. Int_t ReadArray(Short_t*& h); Read array of Short_t from buffer. Int_t ReadArray(UShort_t*& h); Read array of UShort_t from buffer. Int_t ReadArray(Int_t*& i); Read array of Int_t from buffer. Int_t ReadArray(UInt_t*& i); Read array of UInt_t from buffer. Int_t ReadArray(Long_t*& l); Read array of Long_t from buffer. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferJSON.html:28060,optimiz,optimize,28060,root/html534/TBufferJSON.html,https://root.cern,https://root.cern/root/html534/TBufferJSON.html,3,['optimiz'],['optimize']
Performance,"atList, Bool_t ignoreNonVisible); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiBinomial.html:24705,cache,cache,24705,root/html602/RooMultiBinomial.html,https://root.cern,https://root.cern/root/html602/RooMultiBinomial.html,2,['cache'],['cache']
Performance,"atType*RooAbsCategory::defineType(const char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; TStringevalUserFunc(RooArgSet* vars); virtual voidRooAbsCategory::fillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); voidinitialize(); virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(RooCatType value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy); voidupdateIndexList().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGenCategory.html:17474,optimiz,optimizeDirtyHook,17474,root/html526/RooGenCategory.html,https://root.cern,https://root.cern/root/html526/RooGenCategory.html,2,['optimiz'],['optimizeDirtyHook']
Performance,atValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigN,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBCPEffDecay.html:39664,cache,cache,39664,root/html526/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html526/RooBCPEffDecay.html,1,['cache'],['cache']
Performance,atValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC genera,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBCPEffDecay.html:40238,cache,cache,40238,root/html528/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html528/RooBCPEffDecay.html,1,['cache'],['cache']
Performance,atValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculatin,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooBCPEffDecay.html:40515,cache,cache,40515,root/html530/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html530/RooBCPEffDecay.html,1,['cache'],['cache']
Performance,atValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalcul,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBCPEffDecay.html:40918,cache,cache,40918,root/html532/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html532/RooBCPEffDecay.html,1,['cache'],['cache']
Performance,"atVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/Roo2DKeysPdf.html:34065,optimiz,optimizeDirtyHook,34065,root/html532/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html532/Roo2DKeysPdf.html,47,['optimiz'],['optimizeDirtyHook']
Performance,"at_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMVA::IMethod* GetMethod(const TString& title) const; returns pointer to MVA that corresponds to given method title. TMVA::IMethod* GetMethod(const Int_t index) const; returns pointer to MVA that corresponds to given method index. void AddWeightsXMLTo(void* parent) const. ~MethodCompositeBase( void ); delete methods. void ReadWeightsFromXML(void* wghtnode); XML streamer. void ReadWeightsFromStream(istream& istr); text streamer. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); return composite MVA response. void Train(); performs classifier training. const Ranking* CreateRanking(); create ranking. UInt_t GetMethodIndex(); { return fMethodIndex; }. IMethod* GetLastMethod(); { return fMethods.back(); }. IMethod* GetPreviousMethod(); { return (fMethodIndex>0)?fMethods[fMethodIndex-1]:0; }. IMethod* GetCurrentMethod(); { return (fMethodIndex>0)?fMethods[fMethodIndex]:0; }. void DeclareOptions(). void ProcessOptions(). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Or Cohen » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodCompositeBase.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodCompositeBase.html:17047,perform,performs,17047,root/html530/TMVA__MethodCompositeBase.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodCompositeBase.html,1,['perform'],['performs']
Performance,at_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigN,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBDecay.html:39512,cache,cache,39512,root/html526/RooBDecay.html,https://root.cern,https://root.cern/root/html526/RooBDecay.html,2,['cache'],['cache']
Performance,at_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC genera,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBDecay.html:39894,cache,cache,39894,root/html528/RooBDecay.html,https://root.cern,https://root.cern/root/html528/RooBDecay.html,2,['cache'],['cache']
Performance,at_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculatin,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooBDecay.html:40363,cache,cache,40363,root/html530/RooBDecay.html,https://root.cern,https://root.cern/root/html530/RooBDecay.html,2,['cache'],['cache']
Performance,at_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalcul,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBDecay.html:40766,cache,cache,40766,root/html532/RooBDecay.html,https://root.cern,https://root.cern/root/html532/RooBDecay.html,2,['cache'],['cache']
Performance,"ata Members; private:. TF1*fFuncpointer to ROOT function; boolfLinearflag for linear functions ; vector<double>fParamscached vector with parameter values; boolfPolynomialflag for polynomial functions ; doublefX[1]! cached vector for x value (needed for TF1::EvalPar signature) ; static doublefgEpsepsilon used in derivative calculation h ~ eps |x|. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; WrappedTF1(TF1& f). constructor from a TF1 function pointer. virtual ~WrappedTF1(). Destructor (no operations). TF1 Function pointer is not owned. {}. WrappedTF1(TF1& f). Copy constructor. ROOT::Math::IGenFunction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cachen inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter name (this is stored in TF1). void ParameterGradient(double x, const double* par, double* grad) const; evaluate the derivative of the function with respect to the parameters. void FdF(double x, double& f, double& deriv) const; calculate function and derivative at same time (required by IGradient interface). void SetDerivPrecision(double eps); precision value used for calculating the derivative step-size; h = eps * |x|. The default is 0.001, give a smaller in case function changes rapidly. double GetDerivPrecision(); get precision value used for calculating the derivative step-size. double DoEvalPar(double x, const double* p) const; evaluate function passing coordinates x and vector of parameters. double DoEval(double x) const; evaluate function using the cached parameter values of this class (not of TF1)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__WrappedTF1.html:3171,cache,cached,3171,root/html528/ROOT__Math__WrappedTF1.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__WrappedTF1.html,4,['cache'],['cached']
Performance,"ata Members; protected:. Int_t_lastIndex! Last slot accessed; Int_t_maxSize! Maximum size; vector<RooNormSetCache>_nsetCache! Normalization/Integration set manager; vector<vector<double>*>_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_size! Actual use; Bool_t_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. return getObj(nset,0,sterileIndex,isetRangeName). Int_t setObj(const RooArgSet* nset, vector<double>* obj, const TNamed* isetRangeName = 0); Setter function without integration set. return setObj(const RooArgSet* nset, const RooArgSet* iset, vector<double>* obj, const TNamed* isetRangeName = 0). T* getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx, const char* isetRangeName). void reset(). void sterilize(). Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface function to intercept server redirects. void operModeHook(); Interface function to intercept cache operation mode changes. void printCompactTreeHook(ostream& , const char* ); Interface function to cache add contents to output in tree printing mode. T* getObjByIndex(Int_t index) const. const RooNameSet* nameSet1ByIndex(Int_t index) const. const RooNameSet* nameSet2ByIndex(Int_t index) const. void insertObjectHook(vector<double>& ); Interface function to perform post-insert operations on cached object. void wireCache(). » Last changed: Fri Jun 19 21:36:04 2015 » Last generated: 2015-06-19 21:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCacheManager_vector_double___.html:4079,cache,cacheSize,4079,root/html602/RooCacheManager_vector_double___.html,https://root.cern,https://root.cern/root/html602/RooCacheManager_vector_double___.html,6,"['cache', 'perform']","['cache', 'cacheSize', 'cached', 'perform']"
Performance,"ata Members; protected:. Int_t_lastIndex! Last slot accessed; Int_t_maxSize! Maximum size; vector<RooNormSetCache>_nsetCache! Normalization/Integration set manager; vector<vector<double>*>_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_size! Actual use; Bool_t_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. return getObj(nset,0,sterileIndex,isetRangeName). Int_t setObj(const RooArgSet* nset, vector<double>* obj, const TNamed* isetRangeName = 0); Setter function without integration set. return setObj(const RooArgSet* nset, const RooArgSet* iset, vector<double>* obj, const TNamed* isetRangeName = 0). T* getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx, const char* isetRangeName). void reset(). void sterilize(). Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface function to intercept server redirects. void operModeHook(); Interface function to intercept cache operation mode changes. void printCompactTreeHook(ostream& , const char* ); Interface function to cache add contents to output in tree printing mode. T* getObjByIndex(Int_t index) const. const RooNameSet* nameSet1ByIndex(Int_t index) const. const RooNameSet* nameSet2ByIndex(Int_t index) const. void insertObjectHook(vector<double>& ); Interface function to perform post-insert operations on cached object. void wireCache(). » Last changed: Sat Jun 20 17:30:06 2015 » Last generated: 2015-06-20 17:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooCacheManager_vector_double___.html:4079,cache,cacheSize,4079,root/html604/RooCacheManager_vector_double___.html,https://root.cern,https://root.cern/root/html604/RooCacheManager_vector_double___.html,6,"['cache', 'perform']","['cache', 'cacheSize', 'cached', 'perform']"
Performance,"ata analysis.; ; using namespace ROOT;; ; int df016_vecOps(); {; // We re-create a set of points in a square.; // This is a technical detail, just to create a dataset to play with!; auto unifGen = [](double) { return gRandom->Uniform(-1.0, 1.0); };; auto vGen = [&](int len) {; RVecD v(len);; std::transform(v.begin(), v.end(), v.begin(), unifGen);; return v;; };; RDataFrame d(1024);; auto d0 = d.Define(""len"", []() { return (int)gRandom->Uniform(0, 16); }); .Define(""x"", vGen, {""len""}); .Define(""y"", vGen, {""len""});; ; // Now we have in our hands d, a RDataFrame with two columns, x and y, which; // hold collections of coordinates. The sizes of these collections vary.; // Let's now define radii from the x and y coordinates. We'll do it treating ; // the collections stored in the columns without looping on the individual elements.; auto d1 = d0.Define(""r"", ""sqrt(x*x + y*y)"");; ; // Now we want to plot 2 quarters of a ring with radii .5 and 1.; // Note how the cuts are performed on RVecs, comparing them with integers and; // among themselves.; auto ring_h = d1.Define(""rInFig"", ""r > .5 && r < 1 && x*y < 0""); .Define(""yFig"", ""y[rInFig]""); .Define(""xFig"", ""x[rInFig]""); .Histo2D({""fig"", ""Two quarters of a ring"", 64, -1.1, 1.1, 64, -1.1, 1.1}, ""xFig"", ""yFig"");; ; auto cring = new TCanvas();; ring_h->DrawCopy(""Colz"");; ; return 0;; }; d#define d(i)Definition RSha256.hxx:102; lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df016__vecOps_8C.html:1394,perform,performed,1394,doc/master/df016__vecOps_8C.html,https://root.cern,https://root.cern/doc/master/df016__vecOps_8C.html,1,['perform'],['performed']
Performance,"ata set, using addColumn(), you may alter the outcome of the fit.; Only in cases where such a modification of fit behaviour is intentional, this function should be used. ; Implements RooAbsDataStore.; Definition at line 782 of file RooTreeDataStore.cxx. ◆ append(). void RooTreeDataStore::append ; (; RooAbsDataStore & ; other). overridevirtual . Implements RooAbsDataStore.; Definition at line 867 of file RooTreeDataStore.cxx. ◆ attachBuffers(). void RooTreeDataStore::attachBuffers ; (; const RooArgSet & ; extObs). overridevirtual . Implements RooAbsDataStore.; Definition at line 1036 of file RooTreeDataStore.cxx. ◆ attachCache(). void RooTreeDataStore::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). overrideprivatevirtual . Initialize cache of dataset: attach variables of cache ArgSet to the corresponding TTree branches. ; Implements RooAbsDataStore.; Definition at line 229 of file RooTreeDataStore.cxx. ◆ cacheArgs(). void RooTreeDataStore::cacheArgs ; (; const RooAbsArg * ; owner, . RooArgSet & ; newVarSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = false . ). overridevirtual . Cache given RooAbsArgs with this tree: The tree is given direct write access of the args internal cache the args values is pre-calculated for all data points in this data collection. ; Upon a get() call, the internal cache of 'newVar' will be loaded with the precalculated value and it's dirty flag will be cleared. ; Implements RooAbsDataStore.; Definition at line 950 of file RooTreeDataStore.cxx. ◆ cacheOwner(). const RooAbsArg * RooTreeDataStore::cacheOwner ; (; ). inlineoverridevirtual . Implements RooAbsDataStore.; Definition at line 121 of file RooTreeDataStore.h. ◆ changeObservableName(). bool RooTreeDataStore::changeObservableName ; (; const char * ; from, . const char * ; to . ). overridevirtual . Change name of internal observable named 'from' into 'to'. ; Implements RooAbsDataStore.; Definition at line 712 of file RooTreeDataS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:27887,cache,cacheArgs,27887,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,1,['cache'],['cacheArgs']
Performance,"ata& data, const RooStats::ModelConfig& altModel, const RooStats::ModelConfig& nullModel, bool nominalAsimov = false); constructor for asymptotic calculator from Data set and ModelConfig. bool Initialize() const; Initialize the calculator; The initialization will perform a global fit of the model to the data; and build an Asimov data set.; It will then also fit the model to the Asimov data set to find the likelihood value; of the Asimov data set; nominalAsimov is an option for using Asimov data set obtained using nominal nuisance parameter values; By default the nuisance parameters are fitted to the data; NOTE: If a fit has been done before, one for speeding up could set all the initial prameters; to the fit value and in addition set the null snapshot to the best fit. Double_t EvaluateNLL(RooAbsPdf& pdf, RooAbsData& data, const RooArgSet* condObs, const RooArgSet* poiSet = 0). HypoTestResult* GetHypoTest() const; It performs an hypothesis tests using the likelihood function; and computes the p values for the null and the alternate using the asymptotic; formulae for the profile likelihood ratio.; See G. Cowan, K. Cranmer, E. Gross and O. Vitells.; Asymptotic formulae for likelihood- based tests of new physics. Eur. Phys. J., C71:1–19, 2011.; The formulae are valid only for one POI. If more than one POI exists consider as POI only the; first one. double GetExpectedPValues(double pnull, double palt, double nsigma, bool usecls, bool oneSided = true); function given the null and the alt p value - return the expected one given the N - sigma value. void FillBins(const RooAbsPdf& pdf, const RooArgList& obs, RooAbsData& data, int& index, double& binVolume, int& ibin); fill bins by looping recursivly on observables. bool SetObsToExpected(RooProdPdf& prod, const RooArgSet& obs); iterate a Prod pdf to find all the Poisson or Gaussian part to set the observed value to expected one. bool SetObsToExpected(RooAbsPdf& pdf, const RooArgSet& obs); set observed value to the expected on",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooStats__AsymptoticCalculator.html:6695,perform,performs,6695,root/html604/RooStats__AsymptoticCalculator.html,https://root.cern,https://root.cern/root/html604/RooStats__AsymptoticCalculator.html,1,['perform'],['performs']
Performance,"ata());; 1870 return;; 1871 }; 1872 TFile pcmFile(pcmFileName + ""?filetype=pcm"", ""READ"");; 1873 LoadPCMImpl(pcmFile);; 1874}; 1875 ; 1876//______________________________________________________________________________; 1877 ; 1878namespace {; 1879 using namespace clang;; 1880 ; 1881 class ExtLexicalStorageAdder: public RecursiveASTVisitor<ExtLexicalStorageAdder>{; 1882 // This class is to be considered an helper for autoparsing.; 1883 // It visits the AST and marks all classes (in all of their redeclarations); 1884 // with the setHasExternalLexicalStorage method.; 1885 public:; 1886 bool VisitRecordDecl(clang::RecordDecl* rcd){; 1887 if (gDebug > 2); 1888 Info(""ExtLexicalStorageAdder"",; 1889 ""Adding external lexical storage to class %s"",; 1890 rcd->getNameAsString().c_str());; 1891 auto reDeclPtr = rcd->getMostRecentDecl();; 1892 do {; 1893 reDeclPtr->setHasExternalLexicalStorage();; 1894 } while ((reDeclPtr = reDeclPtr->getPreviousDecl()));; 1895 ; 1896 return false;; 1897 }; 1898 };; 1899 ; 1900 ; 1901}; 1902 ; 1903////////////////////////////////////////////////////////////////////////////////; 1904///\returns true if the module map was loaded, false on error or if the map was; 1905/// already loaded.; 1906bool TCling::RegisterPrebuiltModulePath(const std::string &FullPath,; 1907 const std::string &ModuleMapName /*= ""module.modulemap""*/) const; 1908{; 1909 assert(llvm::sys::path::is_absolute(FullPath));; 1910 Preprocessor &PP = fInterpreter->getCI()->getPreprocessor();; 1911 FileManager &FM = PP.getFileManager();; 1912 // FIXME: In a ROOT session we can add an include path (through .I /inc/path); 1913 // We should look for modulemap files there too.; 1914 if (auto DE = FM.getOptionalDirectoryRef(FullPath)) {; 1915 HeaderSearch &HS = PP.getHeaderSearchInfo();; 1916 HeaderSearchOptions &HSOpts = HS.getHeaderSearchOpts();; 1917 const auto &ModPaths = HSOpts.PrebuiltModulePaths;; 1918 bool pathExists = std::find(ModPaths.begin(), ModPaths.end(), FullPath) != ModPaths",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:71697,load,loaded,71697,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,['load'],['loaded']
Performance,"ata* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCategory.html:10472,optimiz,optimizeCacheMode,10472,root/html530/RooAbsCategory.html,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html,3,['optimiz'],['optimizeCacheMode']
Performance,"ata::SliceInfo_t> >TEveCaloData::fSliceInfos; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; Bool_tTEveCaloData::fWrapTwoPi. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveCaloDataHist(); Constructor. ~TEveCaloDataHist(); Destructor. void DataChanged(); Update limits and notify data users. void GetCellList(Float_t etaMin, Float_t etaMax, Float_t phi, Float_t phiRng, TEveCaloData::vCellId_t& out) const; Get list of cell IDs in given eta and phi range. void Rebin(TAxis* ax, TAxis* ay, TEveCaloData::vCellId_t& in, Bool_t et, TEveCaloData::RebinData_t& out) const. void GetCellData(const TEveCaloData::CellId_t& id, TEveCaloData::CellData_t& data) const; Get cell geometry and value from cell ID. Int_t AddHistogram(TH2F* hist); Add new slice to calo tower. Updates cached variables fMaxValE; and fMaxValEt; Return last index in the vector of slice infos. TH2F* GetHist(Int_t slice) const; Get histogram in given slice. void GetEtaLimits(Double_t& min, Double_t& max) const; Get eta limits. void GetPhiLimits(Double_t& min, Double_t& max) const; Get phi limits. TEveCaloData& operator=(const TEveCaloDataHist& ). TEveCaloDataHist(const TEveCaloDataHist& ). THStack* GetStack(); { return fHStack; }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id: TEveCaloData.h 33955 2010-06-17 11:33:13Z matevz $ » Last generated: 2010-11-21 09:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveCaloDataHist.html:21300,cache,cached,21300,root/html528/TEveCaloDataHist.html,https://root.cern,https://root.cern/root/html528/TEveCaloDataHist.html,1,['cache'],['cached']
Performance,"ata::SliceInfo_t> >TEveCaloData::fSliceInfos; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; Bool_tTEveCaloData::fWrapTwoPi. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveCaloDataHist(); Constructor. ~TEveCaloDataHist(); Destructor. void DataChanged(); Update limits and notify data users. void GetCellList(Float_t etaMin, Float_t etaMax, Float_t phi, Float_t phiRng, TEveCaloData::vCellId_t& out) const; Get list of cell IDs in given eta and phi range. void Rebin(TAxis* ax, TAxis* ay, TEveCaloData::vCellId_t& in, Bool_t et, TEveCaloData::RebinData_t& out) const. void GetCellData(const TEveCaloData::CellId_t& id, TEveCaloData::CellData_t& data) const; Get cell geometry and value from cell ID. Int_t AddHistogram(TH2F* hist); Add new slice to calo tower. Updates cached variables fMaxValE; and fMaxValEt; Return last index in the vector of slice infos. TH2F* GetHist(Int_t slice) const; Get histogram in given slice. void GetEtaLimits(Double_t& min, Double_t& max) const; Get eta limits. void GetPhiLimits(Double_t& min, Double_t& max) const; Get phi limits. TEveCaloData& operator=(const TEveCaloDataHist& ). TEveCaloDataHist(const TEveCaloDataHist& ). THStack* GetStack(); { return fHStack; }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id: TEveCaloData.h 33955 2010-06-17 11:33:13Z matevz $ » Last generated: 2011-07-04 15:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveCaloDataHist.html:21369,cache,cached,21369,root/html530/TEveCaloDataHist.html,https://root.cern,https://root.cern/root/html530/TEveCaloDataHist.html,1,['cache'],['cached']
Performance,"ata::SliceInfo_t> >TEveCaloData::fSliceInfos; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; Bool_tTEveCaloData::fWrapTwoPi. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveCaloDataHist(); Constructor. ~TEveCaloDataHist(); Destructor. void DataChanged(); Update limits and notify data users. void GetCellList(Float_t etaMin, Float_t etaMax, Float_t phi, Float_t phiRng, TEveCaloData::vCellId_t& out) const; Get list of cell IDs in given eta and phi range. void Rebin(TAxis* ax, TAxis* ay, TEveCaloData::vCellId_t& in, Bool_t et, TEveCaloData::RebinData_t& out) const. void GetCellData(const TEveCaloData::CellId_t& id, TEveCaloData::CellData_t& data) const; Get cell geometry and value from cell ID. Int_t AddHistogram(TH2F* hist); Add new slice to calo tower. Updates cached variables fMaxValE; and fMaxValEt; Return last index in the vector of slice infos. TH2F* GetHist(Int_t slice) const; Get histogram in given slice. void GetEtaLimits(Double_t& min, Double_t& max) const; Get eta limits. void GetPhiLimits(Double_t& min, Double_t& max) const; Get phi limits. TEveCaloData& operator=(const TEveCaloDataHist& ). TEveCaloDataHist(const TEveCaloDataHist& ). THStack* GetStack(); { return fHStack; }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id: TEveCaloData.h 33955 2010-06-17 11:33:13Z matevz $ » Last generated: 2011-11-03 20:11; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveCaloDataHist.html:21369,cache,cached,21369,root/html532/TEveCaloDataHist.html,https://root.cern,https://root.cern/root/html532/TEveCaloDataHist.html,1,['cache'],['cached']
Performance,"ataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 35 out-of-range events; RooDataSet::ds[x,y] = 65 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #8 because z cannot accommodate the value 10; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds2) Ignored 36 out-of-range events; RooDataSet::ds2[x,z,y] = 26 entries; [#1] INFO:DataHandling -- RooAbsReal::attachToTree(i) TTree Int_t branch i will be converted to double precision.; RooDataSet::ds3[x,i] = 100 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #2 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #5 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #8 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #11 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping ...; [#0] WARNING:DataH",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf401__importttreethx_8py.html:5002,load,loadValues,5002,doc/master/rf401__importttreethx_8py.html,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8py.html,1,['load'],['loadValues']
Performance,"ataHist.h. ◆ calcTreeIndex() [1/2]. Int_t RooDataHist::calcTreeIndex ; (; ); const. inlineprotected . Legacy overload to calculate the tree index from the current value of _vars. ; Deprecated:Use calcTreeIndex(const RooArgSet&,bool) const. ; Definition at line 232 of file RooDataHist.h. ◆ calcTreeIndex() [2/2]. std::size_t RooDataHist::calcTreeIndex ; (; const RooAbsCollection & ; coords, . bool ; fast . ); const. protected . Calculate the bin index corresponding to the coordinates passed as argument. ; Parameters. [in]coordsCoordinates. If fast == false, these can be partial. ; [in]fastPromise that the coordinates in coords have the same order as the internal coordinates. In this case, values are looked up only by index. . Definition at line 1054 of file RooDataHist.cxx. ◆ calculatePartialBinVolume(). const std::vector< double > & RooDataHist::calculatePartialBinVolume ; (; const RooArgSet & ; dimSet); const. protected . Fill the transient cache with partial bin volumes with up-to-date values for the partial volume specified by observables 'dimSet'. ; Definition at line 2065 of file RooDataHist.cxx. ◆ calculateTreeIndexForCodeSquash(). std::string RooDataHist::calculateTreeIndexForCodeSquash ; (; RooAbsArg const * ; klass, . RooFit::Detail::CodeSquashContext & ; ctx, . const RooAbsCollection & ; coords, . bool ; reverse = false . ); const. Definition at line 1011 of file RooDataHist.cxx. ◆ checkBinBounds(). void RooDataHist::checkBinBounds ; (; ); const. protected . Definition at line 867 of file RooDataHist.cxx. ◆ Class(). static TClass * RooDataHist::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooDataHist::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooDataHist::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 282 of file RooDataHist.h. ◆ Clone(). TObject * RooDataHist::Clone ; (; const char * ; newname = """")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:55247,cache,cache,55247,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['cache'],['cache']
Performance,"ataSB.Size(), True); 114result = fitter.Result(); 115result.Print(ROOT.std.cout); 116 ; 117c1 = ROOT.TCanvas(""Simfit"", ""Simultaneous fit of two histograms"", 10, 10, 700, 700); 118c1.Divide(1, 2); 119c1.cd(1); 120ROOT.gStyle.SetOptFit(1111); 121 ; 122fB.SetFitResult(result, iparB); 123fB.SetRange(rangeB().first, rangeB().second); 124fB.SetLineColor(ROOT.kBlue); 125hB.GetListOfFunctions().Add(fB); 126hB.Draw(); 127 ; 128c1.cd(2); 129fSB.SetFitResult(result, iparSB); 130fSB.SetRange(rangeSB().first, rangeSB().second); 131fSB.SetLineColor(ROOT.kRed); 132hSB.GetListOfFunctions().Add(fSB); 133hSB.Draw(); 134 ; 135c1.SaveAs(""combinedFit.png""); ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::Chi2FCNChi2FCN class for binned fits using the least square methods.Definition Chi2FCN.h:46; ROOT::Fit::DataRangeclass describing the range in the coordinates it supports multiple range in a coordinate.Definition DataRange.h:35; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Math::FunctorDocumentation for class Functor class.Definition Functor.h:47; ROOT::Math::WrappedMultiTF1TemplClass to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions...Definition WrappedMultiTF1.h:48; object; ROOT::Fit::FillDatavoid FillData(BinData &dv, const TH1 *hist, TF1 *func=nullptr)fill the data vector from a TH1.Definition HFitInterface.cxx:107; TMatrixTAutoloadOps::AddTMatrixT< Element > & Add(TMatrixT< Element > &target, Element scalar, const TMatrixT< Element > &source)Modify addition: target += scalar * source.Definition TMatrixT.cxx:2936; ROOT::Fit::DataOptionsDataOptions : simple structure holding the options on how the data are filled.Definition DataOptions.h:28. tutorialsfitcombinedFit.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:07 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/combinedFit_8py_source.html:4478,perform,performing,4478,doc/master/combinedFit_8py_source.html,https://root.cern,https://root.cern/doc/master/combinedFit_8py_source.html,1,['perform'],['performing']
Performance,"ataloader, TMVA::Types::kBDT, ""BDT"",; 305 ""!H:!V:NTrees=100:MinNodeSize=1.0%:BoostType=AdaBoostR2:SeparationType=RegressionVariance:nCuts=20:PruneMethod=CostComplexity:PruneStrength=30"" );; 306 ; 307 if (Use[""BDTG""]); 308 factory->BookMethod( dataloader, TMVA::Types::kBDT, ""BDTG"",; 309 ""!H:!V:NTrees=2000::BoostType=Grad:Shrinkage=0.1:UseBaggedBoost:BaggedSampleFraction=0.5:nCuts=20:MaxDepth=3:MaxDepth=4"" );; 310 // --------------------------------------------------------------------------------------------------; 311 ; 312 // Now you can tell the factory to train, test, and evaluate the MVAs; 313 ; 314 // Train MVAs using the set of training events; 315 factory->TrainAllMethods();; 316 ; 317 // Evaluate all MVAs using the set of test events; 318 factory->TestAllMethods();; 319 ; 320 // Evaluate and compare performance of all configured MVAs; 321 factory->EvaluateAllMethods();; 322 ; 323 // --------------------------------------------------------------; 324 ; 325 // Save the output; 326 outputFile->Close();; 327 ; 328 std::cout << ""==> Wrote root file: "" << outputFile->GetName() << std::endl;; 329 std::cout << ""==> TMVARegression is done!"" << std::endl;; 330 ; 331 delete factory;; 332 delete dataloader;; 333 ; 334 // Launch the GUI for the root macros; 335 if (!gROOT->IsBatch()) TMVA::TMVARegGui( outfileName );; 336}; 337 ; 338int main( int argc, char** argv ); 339{; 340 // Select methods (don't look at this code - not of interest); 341 TString methodList;; 342 for (int i=1; i<argc; i++) {; 343 TString regMethod(argv[i]);; 344 if(regMethod==""-b"" || regMethod==""--batch"") continue;; 345 if (!methodList.IsNull()) methodList += TString("","");; 346 methodList += regMethod;; 347 }; 348 TMVARegression(methodList);; 349 return 0;; 350}; DataLoader.h; mainint main()Definition Prototype.cxx:12; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Double_tdouble Double_tDefinition RtypesCore.h:59; TChain.h; TFile.h; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C_source.html:13880,perform,performance,13880,doc/master/TMVARegression_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C_source.html,1,['perform'],['performance']
Performance,"atamember) const; Long_tGetDataMemberOffset(const char* membername) const; Short_tGetDeclFileLine() const; const char*GetDeclFileName() const; ROOT::DelFunc_tGetDelete() const; ROOT::DelArrFunc_tGetDeleteArray() const; ROOT::DesFunc_tGetDestructor() const; static DictFuncPtr_tGetDict(const char* cname); static DictFuncPtr_tGetDict(const type_info& info); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); ROOT::DirAutoAdd_tGetDirectoryAutoAdd() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFunctionTemplate*GetFunctionTemplate(const char* name); UInt_tGetHeapInstanceCount() const; virtual const char*TObject::GetIconName() const; Short_tGetImplFileLine() const; const char*GetImplFileName() const; UInt_tGetInstanceCount() const; TVirtualIsAProxy*GetIsAProxy() const; TVirtualStreamerInfo*GetLastReadInfo() const; TList*GetListOfAllPublicDataMembers(Bool_t load = kTRUE); const TList*GetListOfAllPublicMethods(Bool_t load = kTRUE); TList*GetListOfBases(); TList*GetListOfDataMembers(Bool_t load = kTRUE); TList*GetListOfEnums(Bool_t load = kTRUE); TList*GetListOfFunctionTemplates(Bool_t load = kTRUE); TCollection*GetListOfMethodOverloads(const char* name) const; TList*GetListOfMethods(Bool_t load = kTRUE); TList*GetListOfRealData() const; voidGetMenuItems(TList* listitems); TList*GetMenuList() const; ROOT::MergeFunc_tGetMerge() const; TMethod*GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetMethodAllAny(const char* method); TMethod*GetMethodAny(const char* method); TMethod*GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); voidGetMissingDictionaries(THashTable& result, bool recurse = false); virtual const char*TNamed::GetName() const; Int_tGetNdata(); ROOT::NewFunc_tGetNew() const; ROOT::NewArrFunc_tGetN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:6439,load,load,6439,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['load'],['load']
Performance,"ataset(s); ; # Define now input data file and signal and background trees; ; inputFileName = ""Higgs_data.root""; inputFileLink = ""http://root.cern.ch/files/"" + inputFileName; ; ; if ROOT.gSystem.AccessPathName(inputFileName):; ROOT.Info(""TMVA_Higgs_Classification"", ""Download Higgs_data.root file""); TFile.SetCacheFileDir("".""); inputFile = TFile.Open(inputFileLink, ""CACHEREAD""); if inputFile is None:; raise FileNotFoundError(""Input file cannot be downloaded - exit""); else:; # file exists; inputFile = TFile.Open(inputFileName); ; ; # --- Register the training and test trees; signalTree = inputFile.Get(""sig_tree""); backgroundTree = inputFile.Get(""bkg_tree""); signalTree.Print(); ; ## Declare DataLoader(s); ; # The next step is to declare the DataLoader class that deals with input variables; # Define the input variables that shall be used for the MVA training; # note that you may also use variable expressions, which can be parsed by TTree::Draw( ""expression"" )]; loader = TMVA.DataLoader(""dataset""); ; loader.AddVariable(""m_jj""); loader.AddVariable(""m_jjj""); loader.AddVariable(""m_lv""); loader.AddVariable(""m_jlv""); loader.AddVariable(""m_bb""); loader.AddVariable(""m_wbb""); loader.AddVariable(""m_wwbb""); ; # We set now the input data trees in the TMVA DataLoader class; # global event weights per tree (see below for setting event-wise weights); signalWeight = 1.0; backgroundWeight = 1.0; # You can add an arbitrary number of signal or background trees; loader.AddSignalTree(signalTree, signalWeight); loader.AddBackgroundTree(backgroundTree, backgroundWeight); ; # Set individual event weights (the variables must exist in the original TTree); # for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; # for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; # loader->SetBackgroundWeightExpression( ""weight"" );; ; ; # Apply additional cuts on the signal and background samples (can be different); mycuts = ROOT.TCut("""") # for example: TCut mycuts = ""abs(va",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:59340,load,loader,59340,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['load'],['loader']
Performance,"ataset] : Evaluation of TMVA_DNN_CPU on testing sample (400 events); : Elapsed time for evaluation of 400 events: 0.023 sec ; Factory : Test method: TMVA_CNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 400; : ; TMVA_CNN_CPU : [dataset] : Evaluation of TMVA_CNN_CPU on testing sample (400 events); : Elapsed time for evaluation of 400 events: 0.149 sec ; Factory : Test method: PyKeras for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_cnn.h5; PyKeras : [dataset] : Evaluation of PyKeras on testing sample (400 events); : Elapsed time for evaluation of 400 events: 0.175 sec ; Factory : Test method: PyTorch for Classification performance; : ; : Setup PyTorch Model for training; : Executing user initialization code from /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials/tmva/PyTorch_Generate_CNN_Model.py; RecursiveScriptModule(; original_name=Sequential; (0): RecursiveScriptModule(original_name=Reshape); (1): RecursiveScriptModule(original_name=Conv2d); (2): RecursiveScriptModule(original_name=ReLU); (3): RecursiveScriptModule(original_name=BatchNorm2d); (4): RecursiveScriptModule(original_name=Conv2d); (5): RecursiveScriptModule(original_name=ReLU); (6): RecursiveScriptModule(original_name=MaxPool2d); (7): RecursiveScriptModule(original_name=Flatten); (8): RecursiveScriptModule(original_name=Linear); (9): RecursiveScriptModule(original_name=ReLU); (10): RecursiveScriptModule(original_name=Linear); (11): RecursiveScriptModule(original_name=Sigmoid); ); [1, 4] train loss: 1.164; [1, 8] train loss: 0.756; [1, 12] train loss: 0.696; [1] val loss: 0.693; [2, 4] train loss: 0.692; [2, 8] train loss: 0.690; [2, 12] train loss: 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:39132,perform,performance,39132,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['perform'],['performance']
Performance,"atasets/2020-01-22""; else: dataset_path = ""root://eospublic.cern.ch//eos/root-eos/reduced_atlas_opendata/w""; ; # Create a ROOT dataframe for each dataset; # Note that we load the filenames from the external json file placed in the same folder than this script.; files = json.load(open(os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe/df105_WBosonAnalysis.json""))); processes = files.keys(); df = {}; xsecs = {}; sumws = {}; samples = []; for p in processes:; for d in files[p]:; # Construct the dataframes; folder = d[0] # Folder name; sample = d[1] # Sample name; xsecs[sample] = d[2] # Cross-section; sumws[sample] = d[3] # Sum of weights; num_events = d[4] # Number of events; samples.append(sample); df[sample] = ROOT.RDataFrame(""mini"", ""{}/1lep/{}/{}.1lep.root"".format(dataset_path, folder, sample)); ; # Scale down the datasets if requested; if args.full_dataset and lumi_scale < 1.0:; df[sample] = df[sample].Range(int(num_events * lumi_scale)); ; # Select events for the analysis; ; # Just-in-time compile custom helper function performing complex computations; ROOT.gInterpreter.Declare(""""""; bool GoodElectronOrMuon(int type, float pt, float eta, float phi, float e, float trackd0pv, float tracksigd0pv, float z0); {; ROOT::Math::PtEtaPhiEVector p(pt / 1000.0, eta, phi, e / 1000.0);; if (abs(z0 * sin(p.theta())) > 0.5) return false;; if (type == 11 && abs(eta) < 2.46 && (abs(eta) < 1.37 || abs(eta) > 1.52)) {; if (abs(trackd0pv / tracksigd0pv) > 5) return false;; return true;; }; if (type == 13 && abs(eta) < 2.5) {; if (abs(trackd0pv / tracksigd0pv) > 3) return false;; return true;; }; return false;; }; """"""); ; for s in samples:; # Select events with a muon or electron trigger and with a missing transverse energy larger than 30 GeV; df[s] = df[s].Filter(""trigE || trigM"")\; .Filter(""met_et > 30000""); ; # Find events with exactly one good lepton; df[s] = df[s].Define(""good_lep"", ""lep_isTightID && lep_pt > 35000 && lep_ptcone30 / lep_pt < 0.1 && lep_etcone20 / lep_pt < 0.1"")\",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:3419,perform,performing,3419,doc/master/df105__WBosonAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html,1,['perform'],['performing']
Performance,"atastore associated with current event; map<std::string,RooAbsDataStore*>_dataMap; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; RooCategory*_indexCat; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSetRooAbsDataStore::_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCompositeDataStore(). RooCompositeDataStore(const char* name, const char* title, const RooArgSet& vars, RooCategory& indexCat, map<std::string,RooAbsDataStore*> inputData). RooCompositeDataStore(const RooCompositeDataStore& other, const char* newname = 0). RooCompositeDataStore(const RooCompositeDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooCompositeDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Forward fill request to appropriate subset. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight() const. Double_t weight(Int_t index) const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); WVE ownership issue here!! Caller (a RooAbsData) should take ownership of all; arguments, but only does for the first one here... RooArgSet* addColumns(const RooArgList& varList); WVE ownership issue here!! Caller (a RooAbsData) should take ownership",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCompositeDataStore.html:9626,load,loaded,9626,root/html528/RooCompositeDataStore.html,https://root.cern,https://root.cern/root/html528/RooCompositeDataStore.html,2,['load'],['loaded']
Performance,"ate . Definition at line 287 of file RCsvDS.cxx. ◆ SetEntry(). bool ROOT::RDF::RCsvDS::SetEntry ; (; unsigned int ; slot, . ULong64_t ; entry . ). finalvirtual . Advance the ""cursors"" returned by GetColumnReaders to the selected entry for a particular slot. ; Parameters. [in]slotThe data processing slot that needs to be considered ; [in]entryThe entry which needs to be pointed to by the reader pointers Slots are adopted to accommodate parallel data processing. Different workers will loop over different ranges and will be labelled by different ""slot"" values. Returns true if the entry has to be processed, false otherwise. . Implements ROOT::RDF::RDataSource.; Definition at line 505 of file RCsvDS.cxx. ◆ SetNSlots(). void ROOT::RDF::RCsvDS::SetNSlots ; (; unsigned int ; nSlots). finalvirtual . Inform RDataSource of the number of processing slots (i.e. ; worker threads) used by the associated RDataFrame. Slots numbers are used to simplify parallel execution: RDataFrame guarantees that different threads will always pass different slot values when calling methods concurrently. ; Implements ROOT::RDF::RDataSource.; Definition at line 536 of file RCsvDS.cxx. ◆ ValidateColTypes(). void ROOT::RDF::RCsvDS::ValidateColTypes ; (; std::vector< std::string > & ; columns); const. private . Definition at line 203 of file RCsvDS.cxx. Member Data Documentation. ◆ fBoolEvtValues. std::vector<std::deque<bool> > ROOT::RDF::RCsvDS::fBoolEvtValues. private . Definition at line 64 of file RCsvDS.hxx. ◆ fColAddresses. std::vector<std::vector<void *> > ROOT::RDF::RCsvDS::fColAddresses. private . Definition at line 57 of file RCsvDS.hxx. ◆ fColContainingEmpty. std::set<std::string> ROOT::RDF::RCsvDS::fColContainingEmpty. private . Definition at line 55 of file RCsvDS.hxx. ◆ fColTypes. std::unordered_map<std::string, ColType_t> ROOT::RDF::RCsvDS::fColTypes. private . Definition at line 54 of file RCsvDS.hxx. ◆ fColTypesList. std::list<ColType_t> ROOT::RDF::RCsvDS::fColTypesList. private . Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RCsvDS.html:14074,concurren,concurrently,14074,doc/master/classROOT_1_1RDF_1_1RCsvDS.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RCsvDS.html,1,['concurren'],['concurrently']
Performance,"ate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setData(RooAbsData& data, Bool_t cloneData = kTRUE); Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function() const; { return *_funcClone ; }. const char* cacheUniqueSuffix() const; { return Form(""_%lx"", (ULong_t)_dataClone) ; }. Bool_t isDerived() const; Override t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsOptTestStatistic.html:37826,optimiz,optimizeConstantTerms,37826,root/html528/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html528/RooAbsOptTestStatistic.html,2,['optimiz'],"['optimization', 'optimizeConstantTerms']"
Performance,"ate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setData(RooAbsData& data, Bool_t cloneData = kTRUE); Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function(); { return *_funcClone ; }. RooAbsData& data(); { return *_dataClone ; }. const RooAbsData& data(); { return *_dataClone ; }. Bool_t allowFunctionCache(); { return kTRUE ; }. RooArgSet requiredExtraObservables",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsOptTestStatistic.html:36981,optimiz,optimizeConstantTerms,36981,root/html526/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsOptTestStatistic.html,2,['optimiz'],"['optimization', 'optimizeConstantTerms']"
Performance,"ate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE); Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function() const; { return *_funcClone ; }. const char* cacheUniqueSuffix() const; { return Form(""_%lx"", (ULong_t)_dataClone) ; }. Bool_t isDerived() const; Overr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsOptTestStatistic.html:38053,optimiz,optimizeConstantTerms,38053,root/html530/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html,2,['optimiz'],"['optimization', 'optimizeConstantTerms']"
Performance,"ate generator context for this convolution. ;  ; TString histNameSuffix () const override;  Suffix for cache histogram (added in addition to suffix for cache name) ;  ; const char * inputBaseName () const override;  Return base name component for cache components in this case 'PDF1_CONV_PDF2'. ;  ; RooAbsArg & pdfObservable (RooAbsArg &histObservable) const override;  Return p.d.f. ;  ; std::vector< double > scanPdf (RooRealVar &obs, RooAbsPdf &pdf, const RooDataHist &hist, const RooArgSet &slicePos, Int_t &N, Int_t &N2, Int_t &zeroBin, double shift) const;  Scan the values of 'pdf' in observable 'obs' using the bin values stored in 'hist' at slice position 'slicePos' N is filled with the number of bins defined in hist, N2 is filled with N plus the number of buffer bins The return value is an array of doubles of length N2 with the sampled values. ;  ;  Protected Member Functions inherited from RooAbsCachedPdf; virtual const char * binningName () const;  ; std::string cacheNameSuffix (const RooArgSet &nset) const;  Construct string with unique suffix for cache objects based on observable names that define cache configuration. ;  ; void disableCache (bool flag);  ; void doEval (RooFit::EvalContext &) const override;  Base function for computing multiple values of a RooAbsReal. ;  ; PdfCacheElem * getCache (const RooArgSet *nset, bool recalculate=true) const;  Retrieve cache object associated with given choice of observables. ;  ; virtual const char * payloadUniqueSuffix () const;  ;  Protected Member Functions inherited from RooAbsPdf;  RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr);  Copy constructor. ;  ; virtual std::unique_ptr< RooAbsReal > createNLLImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the NLL creation routine. ;  ; virtual std::unique_ptr< RooFitResult > fitToImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the likelihood fitting routine. ;  ; bool isActiveNormSet (Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:70209,cache,cacheNameSuffix,70209,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,3,['cache'],"['cache', 'cacheNameSuffix']"
Performance,"ate object for a; RooAbsPdf implementation with class name 'name', taking all; elements of 'vars' as constructor arguments. The initial value; expression is taken to be 'expression' which can be any one-line; C++ expression in terms of variables that occur in 'vars'. The returned object is an instance of the object you just defined; connected to the variables listed in 'vars'. The name of the; object is 'name', its class name Roo<name>Class. This function is an effective compiled replacement of RooGenericPdf. You can add optional expressions for analytical integrals to be; advertised by your class in the syntax; ""<intObsName>:<CPPAnaIntExpression>;<intObsName,intObsName>:<CPPAnaIntExpression>""; where <intObsName> a name of the observable integrated over and; <CPPAnaIntExpression> is the C++ expression that calculates that; integral. RooAbsPdf* makePdfInstance(const char* className, const char* name, const char* expression, const RooArgList& vars, const char* intExpression = 0); Write, compile and load code and instantiate object for a; RooAbsPdf implementation with class name 'name', taking all; elements of 'vars' as constructor arguments. The initial value; expression is taken to be 'expression' which can be any one-line; C++ expression in terms of variables that occur in 'vars'. The returned object is an instance of the object you just defined; connected to the variables listed in 'vars'. The name of the; object is 'name', its class name Roo<name>Class. This function is an effective compiled replacement of RooGenericPdf. You can add optional expressions for analytical integrals to be; advertised by your class in the syntax; ""<intObsName>:<CPPAnaIntExpression>;<intObsName,intObsName>:<CPPAnaIntExpression>""; where <intObsName> a name of the observable integrated over and; <CPPAnaIntExpression> is the C++ expression that calculates that; integral. Bool_t makePdf(const char* name, const char* realArgNames = 0, const char* catArgNames = 0, const char* expression = ""1.0""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooClassFactory.html:12725,load,load,12725,root/html526/RooClassFactory.html,https://root.cern,https://root.cern/root/html526/RooClassFactory.html,7,['load'],['load']
Performance,"ate pointer to current Tree and recompute pointers to the branches in the cache ;  ;  Public Member Functions inherited from TTreeCache;  TTreeCache ();  Default Constructor. ;  ;  TTreeCache (TTree *tree, Int_t buffersize=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ;  ; bool GetOptimizeMisses () const;  ; TTree * GetTree () const;  ; bool IsAutoCreated () const;  ; virtual bool IsEnabled () const;  ; bool IsLearning () const override;  ; Int_t LearnBranch (TBranch *b, bool subgbranches=false) override;  Add a branch discovered by actual u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:5260,cache,cache,5260,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,2,['cache'],['cache']
Performance,"ate propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooObjCacheManager_partIntMgrComponent normalization manager; TList_pdfProxyListList of PDF proxies (named after applicable category state); Int_tRooAbsReal::_plotBinsNumber of plot bins; const TNamed*_plotCoefNormRange; RooSetProxy_plotCoefNormSet; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooSimultaneous.html:41032,cache,cache,41032,root/html530/RooSimultaneous.html,https://root.cern,https://root.cern/root/html530/RooSimultaneous.html,2,['cache'],['cache']
Performance,"ate some events; data_cpsi = Mcpsi.generate({cpsi}, 10000); ; # set psi constant to exclude to be a parameter of the fit; psi.setConstant(True); ; # Fit convoluted model as function of cos(psi); Mcpsi.fitTo(data_cpsi, PrintLevel=-1); ; # Plot cos(psi) frame with Mf(cpsi); frame2 = cpsi.frame(Title=""Same convolution in psi, in cos(psi)""); data_cpsi.plotOn(frame2); Mcpsi.plotOn(frame2); ; # Overlay comparison to unsmeared physics p.d.f ROOT.Tf(cpsi); Tcpsi.plotOn(frame2, LineColor=""r""); ; # Draw frame on canvas; c = ROOT.TCanvas(""rf210_angularconv"", ""rf210_angularconv"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.4); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf210_angularconv.png""); [#1] INFO:Caching -- Changing internal binning of variable 'psi' in FFT 'Mf' from 100 to 930 to improve the precision of the numerical FFT. This can be done manually by setting an additional binning named 'cache'.; [#1] INFO:Eval -- RooRealVar::setRange(psi) new range named 'refrange_fft_Mf' created with bounds [0,3.14159]; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x77ddb60 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7953590 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7b5fca0 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(Mf_over_Mf_Int[psi]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf210__angularconv_8py.html:3969,cache,cache,3969,doc/master/rf210__angularconv_8py.html,https://root.cern,https://root.cern/doc/master/rf210__angularconv_8py.html,1,['cache'],['cache']
Performance,ate the interfaces like ROOT::Math::Minimizer via the Plugin Manager. More...;  ; class  FastInverter;  Fast Matrix Inverter class Class to specialize calls to Dinv. More...;  ; class  FastInverter< 3 >;  3x3 direct matrix inversion using Cramer Rule use only for FastInverter More...;  ; class  FastInverter< 4 >;  4x4 matrix inversion using Cramers rule. More...;  ; class  FastInverter< 5 >;  5x5 Matrix inversion using Cramers rule. More...;  ; class  FitTransformFunction;  Internal class used by GSLNLSMinimizer to implement the transformation of the chi2 function used by GSL Non-linear Least-square fitting The class is template on the FitMethodFunction type to support both gradient and non gradient functions. More...;  ; class  Functor;  Documentation for class Functor class. More...;  ; class  Functor1D;  Functor1D class for one-dimensional functions. More...;  ; class  GaussIntegrator;  User class for performing function integration. More...;  ; class  GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  GenAlgoOptions;  class implementing generic options for a numerical algorithm Just store the options in a map of string-value pairs More...;  ; struct  GeneralHessianCalc;  ; struct  GeneralHessianCalc< double >;  ; struct  GeneralLinearFunctionDerivation;  Auxiliar class to bypass the (provisional) lack of vectorization in TFormula::EvalPar. More...;  ; struct  GeneralLinearFunctionDerivation< double >;  ; class  GeneticMinimizer;  GeneticMinimizer. More...;  ; struct  GeneticMinimizerParameters;  ; class  GenVector_exception;  ; class  GlobalCoordinateSystemTag;  Tag for identifying vectors based on a global coordinate system. More...;  ; class  GoFTest;  GoFTest class implementing the 1 sample and 2 sample goodness of fit tests for uni-variate distributions and data. More...;  ; class  GradFunctor;  GradFunctor class for Multidimensional gradient functions. More...;  ; class  GradFunctor1D;  GradFunctor1D class for one-di,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:7733,perform,performing,7733,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['perform'],['performing']
Performance,"ate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; WARNING: Currently only ONE TTree object can be 'cached' per TFile object.; This call disable the cache for the other TTree objects read from the same; TFile object as this TTree (The SetCacheSize called __last__ wins).; To cache multiple TTree objects in the same ROOT file, you must create; one TFile object per TTree object. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:119905,cache,cached,119905,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,3,['cache'],['cached']
Performance,"ate() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooConvCoefVar.html:11267,cache,cacheList,11267,root/html534/RooConvCoefVar.html,https://root.cern,https://root.cern/root/html534/RooConvCoefVar.html,9,['cache'],['cacheList']
Performance,"ate() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRoo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvolution.html:12701,cache,cacheList,12701,root/html526/RooNumConvolution.html,https://root.cern,https://root.cern/root/html526/RooNumConvolution.html,4,['cache'],['cacheList']
Performance,"ate() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tget",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooConvCoefVar.html:10651,cache,cacheList,10651,root/html526/RooConvCoefVar.html,https://root.cern,https://root.cern/root/html526/RooConvCoefVar.html,4,['cache'],['cacheList']
Performance,"ate() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooPlot*RooAbsRealLValue::frame() const; RooPlot*RooAbsRealLValue::frame(const RooLinkedList& cmdList) const; RooPlot*RooAbsRealLValue::frame(Int_t nbins",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooErrorVar.html:11802,cache,cacheList,11802,root/html526/RooErrorVar.html,https://root.cern,https://root.cern/root/html526/RooErrorVar.html,4,['cache'],['cacheList']
Performance,"ateAllMethods(void)Iterates over all MVAs that have been booked, and calls their evaluation methods.Definition Factory.cxx:1376; TMVA::Factory::EvaluateImportanceRandomTH1F * EvaluateImportanceRandom(DataLoader *loader, UInt_t nseeds, Types::EMVA theMethod, TString methodTitle, const char *theOption="""")Definition Factory.cxx:2473; TMVA::Factory::GetImportanceTH1F * GetImportance(const int nbits, std::vector< Double_t > importances, std::vector< TString > varNames)Definition Factory.cxx:2591; TMVA::Factory::fROCBool_t fROC! enable to calculate ROC valuesDefinition Factory.h:216; TMVA::Factory::EvaluateAllVariablesvoid EvaluateAllVariables(DataLoader *loader, TString options="""")Iterates over all MVA input variables and evaluates them.Definition Factory.cxx:1360; TMVA::Factory::fVerboseLevelTString fVerboseLevel! verbosity level, controls granularity of loggingDefinition Factory.h:214; TMVA::Factory::GetROCCurveAsMultiGraphTMultiGraph * GetROCCurveAsMultiGraph(DataLoader *loader, UInt_t iClass, Types::ETreeType type=Types::kTesting)Generate a collection of graphs, for all methods for a given class.Definition Factory.cxx:988; TMVA::Factory::EvaluateImportanceTH1F * EvaluateImportance(DataLoader *loader, VIType vitype, Types::EMVA theMethod, TString methodTitle, const char *theOption="""")Evaluate Variable Importance.Definition Factory.cxx:2217; TMVA::Factory::GetROCIntegralDouble_t GetROCIntegral(DataLoader *loader, TString theMethodName, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)Calculate the integral of the ROC curve, also known as the area under curve (AUC),...Definition Factory.cxx:849; TMVA::Factory::~Factoryvirtual ~Factory()Destructor.Definition Factory.cxx:306; TMVA::Factory::MakeClassvirtual void MakeClass(const TString &datasetname, const TString &methodTitle="""") constDefinition Factory.cxx:1305; TMVA::Factory::BookMethodWeightfileMethodBase * BookMethodWeightfile(DataLoader *dataloader, TMVA::Types::EMVA methodType, const TString &weightfile)Adds an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:122377,load,loader,122377,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance,"ateCache ; (; const RooArgSet * ; nset); const. overrideprotectedvirtual . Return specialized cache subclass for FFT calculations. ; Reimplemented from RooAbsCachedPdf.; Definition at line 342 of file RooFFTConvPdf.cxx. ◆ DeclFileName(). static const char * RooFFTConvPdf::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 124 of file RooFFTConvPdf.h. ◆ evaluate(). double RooFFTConvPdf::evaluate ; (; ); const. inlineoverrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 96 of file RooFFTConvPdf.h. ◆ fillCacheObject(). void RooFFTConvPdf::fillCacheObject ; (; RooAbsCachedPdf::PdfCacheElem & ; cache); const. overrideprotectedvirtual . Fill the contents of the cache the FFT convolution output. ; Implements RooAbsCachedPdf.; Definition at line 479 of file RooFFTConvPdf.cxx. ◆ fillCacheSlice(). void RooFFTConvPdf::fillCacheSlice ; (; FFTCacheElem & ; cache, . const RooArgSet & ; slicePosition . ); const. protected . Fill a slice of cachePdf with the output of the FFT convolution calculation. ; Definition at line 559 of file RooFFTConvPdf.cxx. ◆ genContext(). RooAbsGenContext * RooFFTConvPdf::genContext ; (; const RooArgSet & ; vars, . const RooDataSet * ; prototype = nullptr, . const RooArgSet * ; auxProto = nullptr, . bool ; verbose = false . ); const. overrideprotectedvirtual . Create appropriate generator context for this convolution. ; If both input p.d.f.s support internal generation, if it is safe to use them and if no observables other than the convolution observable are requested for generation, use the specialized convolution generator context which implements a smearing strategy in the convolution observable. If not return the regular accept/reject generator context ; Reimplemented from RooAbsPdf.; Definition at line 864 of file RooFFTConvPdf.cxx. ◆ getMaxVal(). Int_t RooFFTConvPdf::getMaxVal ; (;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:90695,cache,cache,90695,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cache']
Performance,"ateColorTableFromFile(""filename.txt"") or gStyle->SetPalette(""filename.txt""). The input file contains one color per line in “r g b” float format. This function is useful to profit from a full set of colour-vision deficiency friendly and perceptually uniform colour maps that are available to download; 9.7 The Graphics Editor; A new graphics editor took place in ROOT v4.0. The editor can be activated by selecting the Editor menu entry in the canvas View menu or one of the context menu entries for setting line, fill, marker or text attributes. The following object editors are available for the current ROOT version.; 9.7.1 TAxisEditor. This user interface gives the possibility for changing the following axis attributes:. color of the selected axis, the axis’ title and labels;; the length of thick parameters and the possibility to set them on both axis sides (if +- is selected);; to set logarithmic or linear scale along the selected axis with a choice for optimized or more logarithmic labels;; primary, secondary and tertiary axis divisions can be set via the three number fields;; the axis title can be added or edited and the title’s color, position, offset, size and font can be set interactively;; the color, size, and offset of axis labels can be set similarly. In addition, there is a check box for no exponent choice, and another one for setting the same decimal part for all labels. 9.7.2 TPadEditor. It provides the following user interface:; Fixed aspect ratio - can be set for pad resizing.; Edit - sets pad or canvas as editable.; Cross-hair - sets a cross hair on the pad.; TickX - set ticks along the X axis.; TickY - set ticks along the Y axis.; GridX - set a grid along the X axis.; GridY - set a grid along the Y axis.; The pad or canvas border size can be set if a sunken or a raised border mode is; selected; no border mode can be set too. 9.8 Copy and Paste; You can make a copy of a canvas using TCanvas::DrawClonePad. This method is unique to TCanvas. It clones the ent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:366196,optimiz,optimized,366196,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['optimiz'],['optimized']
Performance,"ateIntegral(iset,nset,cfg,rangeName) ;; 536}; 537 ; 538 ; 539 ; 540 ; 541 ; 542////////////////////////////////////////////////////////////////////////////////; 543/// Create an object that represents the integral of the function over one or more observables listed in iset.; 544/// The actual integration calculation is only performed when the return object is evaluated. The name; 545/// of the integral object is automatically constructed from the name of the input function, the variables; 546/// it integrates and the range integrates over. If nset is specified the integrand is request; 547/// to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; 548/// the integral is performed over the named range, otherwise it is performed over the domain of each; 549/// integrated observable. If cfg is specified it will be used to configure any numeric integration; 550/// aspect of the integral. It will not force the integral to be performed numerically, which is; 551/// decided automatically by RooRealIntegral.; 552 ; 553RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset,; 554 const RooNumIntConfig* cfg, const char* rangeName) const; 555{; 556 if (!rangeName || strchr(rangeName,',')==nullptr) {; 557 // Simple case: integral over full range or single limited range; 558 return createIntObj(iset,nset,cfg,rangeName);; 559 }; 560 ; 561 // Integral over multiple ranges; 562 std::vector<std::string> tokens = ROOT::Split(rangeName, "","");; 563 ; 564 if(RooHelpers::checkIfRangesOverlap(iset, tokens)) {; 565 std::stringstream errMsg;; 566 errMsg << GetName() << "" : integrating with respect to the variables "" << iset << "" on the ranges \"""" << rangeName; 567 << ""\"" is not possible because the ranges are overlapping"";; 568 const std::string errMsgString = errMsg.str();; 569 coutE(Integration) << errMsgString << std::endl;; 570 throw std::invalid_argument(errMsgString);; 571 }; 572 ; 573 RooArgSet ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:20442,perform,performed,20442,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['perform'],['performed']
Performance,"ateNavigator(); ; Definition at line 22 of file TGeoBranchArray.h. Public Types; enum  EGeoBATypes { kBASelfAlloc = (1ULL << ( 14 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TGeoBranchArray (TRootIOCtor *);  ;  ~TGeoBranchArray () override;  ; void AddLevel (Int_t dindex);  Add and extra daughter to the current path array. No validity check performed ! ;  ; void CleanMatrix ();  Garbage collect the stored matrix. ;  ; Int_t Compare (const TObject *obj) const override;  Compare with other object of same type. ;  ; void CopyTo (TGeoBranchArray *dest);  Raw memcpy of the branch array content to an existing destination. ;  ; size_t DataSize () const;  ; void * DataStart () const;  ; TGeoNode ** GetArray () const;  ; TGeoNode * GetCurrentNode () const;  ; size_t GetLevel () const;  ; const TGeoHMatrix * GetMatrix () const;  ; size_t GetMaxLevel () const;  ; TGeoNode * GetNode (Int_t level) const;  ; void GetPath (TString &path) const;  Fill path pointed by the array. ;  ; void Init (TGeoNode **branch, TGeoMatrix *global, Int_t level);  Init the branch array from an array of nodes, the global matrix for the path and the level. ;  ; void InitFromNavigator (TGeoNavigator *nav);  Init the branch array from current navigator state. ;  ; TClass * IsA () const override;  ; Bool_t IsOutside () const;  ; Bool_t IsSortable () const override;  ; Bool_t operator!= ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBranchArray.html:1984,perform,performed,1984,doc/master/classTGeoBranchArray.html,https://root.cern,https://root.cern/doc/master/classTGeoBranchArray.html,1,['perform'],['performed']
Performance,"ated dimensions to activate normalization value caching; RooRealProxy_nNumber of expected events; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooExtendedTerm.html:39384,cache,cache,39384,root/html532/RooExtendedTerm.html,https://root.cern,https://root.cern/root/html532/RooExtendedTerm.html,1,['cache'],['cache']
Performance,"atedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TGraphErrors; Double_t ** Allocate (Int_t size) override;  Allocate internal data structures for newsize points. ;  ; void CopyAndRelease (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy and release. ;  ; Bool_t CopyPoints (Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin != iend. ;  ; Bool_t CtorAllocate ();  Constructor allocate. ;  ; Bool_t DoMerge (const TGraph *g) override;  Protected function to perform the merge operation of a graph with errors. ;  ; void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) override;  Set zero values for point arrays in the range [begin, end]. ;  ; void SwapPoints (Int_t pos1, Int_t pos2) override;  Swap points. ;  ; void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) override;  Update the fX, fY, fEX, and fEY arrays with the sorted values. ;  ;  Protected Member Functions inherited from TGraph; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHistogramAndFunctions (std",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphPolar.html:34220,perform,perform,34220,doc/master/classTGraphPolar.html,https://root.cern,https://root.cern/doc/master/classTGraphPolar.html,1,['perform'],['perform']
Performance,"ategory(); RooBinningCategory(const RooBinningCategory& other, const char* name = 0); RooBinningCategory(const char* name, const char* title, RooAbsRealLValue& inputVar, const char* binningName = 0, const char* catTypeName = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBinningCategory.html:14929,cache,cache,14929,root/html602/RooBinningCategory.html,https://root.cern,https://root.cern/root/html602/RooBinningCategory.html,2,['cache'],['cache']
Performance,"ategoryLValue(const char* name, const char* title); RooAbsCategoryLValue(const RooAbsCategoryLValue& other, const char* name = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); voidsetConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual Bool_tsetIndex(Int_t index, Bool_t printError = kTRUE); virtual Bool_tsetLabel(const char* label, Bool_t printError = kTRUE); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategoryLValue.html:15891,cache,cache,15891,root/html602/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html,2,['cache'],['cache']
Performance,"ates that this class and any derived class should not be split. This included a rework the mechanism checking the base classes. Instead of using InheritsFrom, which lead in some cases, including the case where the class derived from an STL collection, to spurrious autoparsing (to look at the base class of the collection!), we use a custom walk through the tree of base classes that checks their value of fCanSplit. This also has the side-effect of allowing the extension of the concept ‘base class that prevent its derived class from being split’ to any user class. This fixes ROOT-7972.; TTree. Do not automatically setup read cache during TTree::Fill(). This fixes ROOT-8031.; Fast Cloning We added a cache specifically for the fast option of the TTreeCloner to significantly reduce the run-time when fast-cloning remote files to address ROOT-5078. It can be controlled from the TTreeCloner, TTree::CopyEntries or hadd interfaces. The new cache is enabled by default, to update the size of the cache or disable it from TTreeCloner use: TTreeCloner::SetCacheSize. To do the same from TTree::CopyEntries add to the option string “cachesize=SIZE”. To update the size of the cache or disable it from hadd, use the command line option -cachesize SIZE. SIZE shouyld be given in number bytes and can be expressed in ‘human readable form’ (number followed by size unit like MB, MiB, GB or GiB, etc. or SIZE can be set zero to disable the cache. Histogram Libraries. Protect access to TROOT::GetListOfGlobalFunctions in TFormula. Math. Update MixMax random number generator for 32 bit architectures. TColor. Import TColor from master to make sure the high quality palettes are defined only ones. This was requested here. PyROOT. Fix case where c++ exception in a constructor were not propagated to python ROOT-7864; Fix case where PyROOT was unable to call copy constructor ROOT-7783; Fix handling of vector<enums> ROOT-7916; Fix the wrong return value when calling a c++ function returning short, or when",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:25774,cache,cache,25774,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,2,['cache'],['cache']
Performance,"atform dependent implementation is in the TThreadImp class and its descendant classes (e.g. TPosixThread ).; TMutex class implements mutex locks. A mutex is a mutually exclusive lock. The platform dependent implementation is in the TMutexImp class and its descendant classes (e.g. TPosixMutex); TCondition class implements a condition variable. Use a condition variable to signal threads. The platform dependent implementation is in the TConditionImp and TPosixCondition classes .; TSemaphore class implements a counting semaphore. Use a semaphore to synchronize threads. The platform dependent implementation is in the TMutexImp and TConditionImp classes.; 23.2.3 TThread for Pedestrians; To run a thread in ROOT, follow these steps:. Initialization. Add these lines to your rootlogon.C:; {; ...; // The next line may be unnecessary on some platforms; gSystem->Load(""/usr/lib/libpthread.so"");; gSystem->Load(""$ROOTSYS/lib/libThread.so"");; ...; }; This loads the library with the TThread class and the pthread specific implementation file for Posix threads. Coding. Define a function (e.g. void* UserFun(void* UserArgs)) that should run as a thread. The code for the examples is at the web site of the authors (Jörn Adamczewski, Marc Hemberger). After downloading the code from this site, you can follow the example below:; http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html. Loading. Start an interactive ROOT session. Load the shared library:; root[] gSystem->Load(""mhs3.so""); // or; root[] gSystem->Load(""CalcPiThread.so"");. Creating. Create a thread instance (see also example RunMhs3.CorRunPi.C) with:; root[] TThread *th = new TThread(UserFun,UserArgs);; When called from the interpreter, this gives the name “UserFun” to the thread. This name can be used to retrieve the thread later. However, when called from compiled code, this method does not give any name to the thread. So give a name to the thread in compiled use:; root[] TThread *th = new TThread(""MyThread"", UserFun, Use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1105421,load,loads,1105421,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loads']
Performance,"ath to; 1262 /// the TTree as part of the TTree name, e.g. `df.Snapshot(""subdir/t"", ""f.root"")` write TTree `t` in the; 1263 /// sub-directory `subdir` of file `f.root` (creating file and sub-directory as needed).; 1264 ///; 1265 /// \attention In multi-thread runs (i.e. when EnableImplicitMT() has been called) threads will loop over clusters of; 1266 /// entries in an undefined order, so Snapshot will produce outputs in which (clusters of) entries will be shuffled with; 1267 /// respect to the input TTree. Using such ""shuffled"" TTrees as friends of the original trees would result in wrong; 1268 /// associations between entries in the main TTree and entries in the ""shuffled"" friend. Since v6.22, ROOT will; 1269 /// error out if such a ""shuffled"" TTree is used in a friendship.; 1270 ///; 1271 /// \note In case no events are written out (e.g. because no event passes all filters) the behavior of Snapshot in; 1272 /// single-thread and multi-thread runs is different: in single-thread runs, Snapshot will write out a TTree with; 1273 /// the specified name and zero entries; in multi-thread runs, no TTree object will be written out to disk.; 1274 ///; 1275 /// \note Snapshot will refuse to process columns with names of the form `#columnname`. These are special columns; 1276 /// made available by some data sources (e.g. RNTupleDS) that represent the size of column `columnname`, and are; 1277 /// not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an; 1278 /// Alias(): `df.Alias(""nbar"", ""#bar"").Snapshot(..., {""nbar""})`.; 1279 ///; 1280 /// ### Example invocations:; 1281 ///; 1282 /// ~~~{.cpp}; 1283 /// // without specifying template parameters (column types automatically deduced); 1284 /// df.Snapshot(""outputTree"", ""outputFile.root"", {""x"", ""y""});; 1285 ///; 1286 /// // specifying template parameters (""x"" is `int`, ""y"" is `float`); 1287 /// df.Snapshot<int, float>(""outputTree"", ""outputFile.root"", {""x"", ""y""});; 1288 /// ~~~; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:70285,multi-thread,multi-thread,70285,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,2,['multi-thread'],['multi-thread']
Performance,"ath() function. ;  ; std::atomic< size_t > fContextPeg {0};  thread local gDirectory pointing to this object. ;  ; std::vector< SharedGDirectory_t > fGDirectories;  ; TList * fList {nullptr};  ; TObject * fMother {nullptr};  ; TString fPathBuffer;  ; std::atomic_flag fSpinLock;  Counter delaying the TDirectory destructor from finishing. ;  ; TUUID fUUID;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from TMemFile; static constexpr Long64_t fgDefaultBlockSize = 2 * 1024 * 1024;  ;  Static Protected Attributes inherited from TFile; static TList * fgAsyncOpenRequests = nullptr;  ; static std::atomic< Long64_t > fgBytesRead {0};  Number of bytes read by all TFile objects. ;  ; static std::atomic< Long64_t > fgBytesWrite {0};  Number of bytes written by all TFile objects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TBufferMergerFile.html:43647,cache,cache,43647,doc/v632/classROOT_1_1TBufferMergerFile.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TBufferMergerFile.html,6,['cache'],"['cache', 'cached']"
Performance,"ath)Change directory.Definition TSystem.cxx:862; TSystem::Renamevirtual int Rename(const char *from, const char *to)Rename a file.Definition TSystem.cxx:1350; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; TSystem::GetFlagsDebugvirtual const char * GetFlagsDebug() constReturn the debug flags.Definition TSystem.cxx:3927; TSystem::IsAbsoluteFileNamevirtual Bool_t IsAbsoluteFileName(const char *dir)Return true if dir is an absolute pathname.Definition TSystem.cxx:951; TSystem::GetObjExtvirtual const char * GetObjExt() constGet the object file extension.Definition TSystem.cxx:4021; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::GetLibrariesvirtual const char * GetLibraries(const char *regexp="""", const char *option="""", Bool_t isRegexp=kTRUE)Return a space separated list of loaded shared libraries.Definition TSystem.cxx:2136; TSystem::HomeDirectoryvirtual const char * HomeDirectory(const char *userName=nullptr)Return the user's home directory.Definition TSystem.cxx:887; TSystem::ProcessEventsvirtual Bool_t ProcessEvents()Process pending events (GUI, timers, sockets).Definition TSystem.cxx:416; TSystem::GetSoExtvirtual const char * GetSoExt() constGet the shared library extension.Definition TSystem.cxx:4013; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; TSystem::GetFlagsOptvirtual const char * GetFlagsOpt() constReturn the optimization flags.Definition TSystem.cxx:3935; TTimeStampThe TTimeStamp encapsulates seconds and ns since EPOCH.Definition TTimeStamp.h:45; TUUIDThis class defines a UUID (Universally Unique",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:250434,load,loaded,250434,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['load'],['loaded']
Performance,"ath::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(double x, const double* p) const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionOneDim&operator=(const ROOT::Math::IParametricFunctionOneDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the function (internal parameter values).; If for some reason one prefers caching the parameter values, SetParameters(p) and then operator()(x) should be; called.; Use the pure virtual function DoEvalPar to implement it. return DoEvalPar(x, p). double DoEval(double x) const. Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values. double operator()(double x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the function (internal parameter values).; If for some reason one prefers caching the parameter values, SetParameters(p) and then operator()(x) should be; called.; Use the pure virtual function DoEvalPar to implement it. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__IParametricFunctionOneDim.html:2407,cache,cached,2407,root/html534/ROOT__Math__IParametricFunctionOneDim.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__IParametricFunctionOneDim.html,1,['cache'],['cached']
Performance,"ath::IParametricGradFunctionMultiDim&); doubleParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; voidParameterGradient(const double* x, double* grad) const; virtual voidParameterGradient(const double* x, const double* p, double* grad) const; virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoParameterDerivative(const double* x, const double* p, unsigned int ipar) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IParametricGradFunctionMultiDim(). Virtual Destructor (no operations). {}. void ParameterGradient(const double* x, const double* p, double* grad) const. Evaluate the all the derivatives (gradient vector) of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency. double ParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const. Evaluate the partial derivative w.r.t a parameter ipar from values and parameters. return DoParameterDerivative(const double* x, const double* p, unsigned int ipar) const. void ParameterGradient(const double* x, double* grad) const. Evaluate all derivatives using cached parameter values. double ParameterDerivative(const double* x, unsigned int ipar = 0) const. Evaluate partial derivative using cached parameter values. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 27272 2009-01-28 09:03:03Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IParametricGradFunctionMultiDim.html:2978,cache,cached,2978,root/html526/ROOT__Math__IParametricGradFunctionMultiDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IParametricGradFunctionMultiDim.html,2,['cache'],['cached']
Performance,"ath::Minimizer>fMinimizer! pointer to used minimizer; auto_ptr<ROOT::Math::IMultiGenFunction>fObjFunction! pointer to used objective function; auto_ptr<ROOT::Fit::FitResult>fResult! pointer to the object containing the result of the fit; boolfUseGradientflag to indicate if using gradient or not. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fitter(). Default constructor. ~Fitter(). Destructor. Fitter(const ROOT::Fit::Fitter& ). Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned default is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Fit__Fitter.html:6437,perform,performed,6437,root/html534/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html,1,['perform'],['performed']
Performance,"ath::Minimizer>fMinimizer! pointer to used minimizer; auto_ptr<ROOT::Math::IMultiGenFunction>fObjFunction! pointer to used objective function; auto_ptr<ROOT::Fit::FitResult>fResult! pointer to the object containing the result of the fit; boolfUseGradientflag to indicate if using gradient or not. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fitter(). Default constructor. ~Fitter(). Destructor. Fitter(const ROOT::Fit::Fitter& ). Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned defult is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Fit__Fitter.html:6437,perform,performed,6437,root/html532/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html,1,['perform'],['performed']
Performance,"atic . Add font to static list of fonts supported by the canvas Name specifies name of the font, second is font file with .ttf or .woff2 extension Only True Type Fonts (ttf) are supported by PDF Returns font index which can be used in auto font_indx = TWebCanvas::AddFont(""test"", ""test.ttf"", 2); gStyle->SetStatFont(font_indx);. ; Definition at line 228 of file TWebCanvas.cxx. ◆ AddSendQueue(). void TWebCanvas::AddSendQueue ; (; unsigned ; connid, . const std::string & ; msg . ). protected . Add message to send queue for specified connection If connid == 0, message will be add to all connections. ; Definition at line 1187 of file TWebCanvas.cxx. ◆ AssignStatusBits(). void TWebCanvas::AssignStatusBits ; (; UInt_t ; bits). protected . Assign clients bits. ; Definition at line 1472 of file TWebCanvas.cxx. ◆ BatchImageMode(). void TWebCanvas::BatchImageMode ; (; UInt_t ; n = 100). static . Configure batch image mode for web graphics. ; Allows to process many images with single headless browser invocation and increase performance of image production. When many canvases are stored as image in difference places, they first collected in batch and then processed when at least n images are prepared. Only then headless browser invoked and create all these images at once. This allows to significantly increase performance of image production in web mode ; Definition at line 156 of file TWebCanvas.cxx. ◆ CalculateColorsHash(). UInt_t TWebCanvas::CalculateColorsHash ; (; ). protected . Calculate hash function for all colors and palette. ; Definition at line 559 of file TWebCanvas.cxx. ◆ CanCreateObject(). virtual Bool_t TWebCanvas::CanCreateObject ; (; const std::string & ; ). inlineprotectedvirtual . Definition at line 170 of file TWebCanvas.h. ◆ CheckCanvasModified(). Bool_t TWebCanvas::CheckCanvasModified ; (; bool ; force_modified = false). protected . Check if any pad on the canvas was modified If yes, increment version of correspondent pad Returns true when canvas really modif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebCanvas.html:21097,perform,performance,21097,doc/master/classTWebCanvas.html,https://root.cern,https://root.cern/doc/master/classTWebCanvas.html,1,['perform'],['performance']
Performance,atic Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. Bool_tfAutoFitwhen true canvas container keeps same size as canvas; Int_tfButtoncurrently pressed button; TRootContainer*fCanvasContainercontainer in canvas widget; Int_tfCanvasIDindex in fWindows array of TGX11; TGLayoutHints*fCanvasLayoutlayout for canvas widget; TGCanvas*fCanvasWindowcanvas widget; TGLayoutHints*fDockLayoutlayout hints for dockable frame widget; TGPopupMenu*fEditClearMenuclear cascade submenu; TGPopupMenu*fEditMenuedit menu; TVirtualPadEditor*fEditorpointer to currently loaded pad editor; TGCompositeFrame*fEditorFrameside frame for current pad editor; TGLayoutHints*fEditorLayoutlayout for editor frame; Bool_tfEmbeddedtrue if embedded in any other frame (e.g. in the browser); TGPopupMenu*fFileMenufile menu; TGPopupMenu*fFileSaveMenusave cascade submenu; TGPopupMenu*fHelpMenuhelp menu; TGHorizontal3DLine*fHorizontal1toolbar sepatator; TGLayoutHints*fHorizontal1Layoutlayout hints for separator; const TGPicture*fIconPicicon picture; TGCompositeFrame*fMainFramemain frame containing canvas and side frame; TGLayoutHints*fMainFrameLayoutlayout for main frame; TGMenuBar*fMenuBarmenubar; TGLayoutHints*fMenuBarHelpLayoutlayout hint for help menu in menubar; TGLayoutHints*fMenuBarItemLayoutlayout hints for menu in menubar; TGLayoutHints*fMenuBarLayoutmenubar layout hints; TGPopupMenu*fOptionMenuoption menu; TGSta,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRootCanvas.html:24687,load,loaded,24687,root/html602/TRootCanvas.html,https://root.cern,https://root.cern/root/html602/TRootCanvas.html,2,['load'],['loaded']
Performance,"atic TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,int,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCFunction2PdfBinding_double_int_int_.html:39323,cache,cache,39323,root/html528/RooCFunction2PdfBinding_double_int_int_.html,https://root.cern,https://root.cern/root/html528/RooCFunction2PdfBinding_double_int_int_.html,2,['cache'],['cache']
Performance,"atic constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Member Functions; void initialize (const char *wgtVarName);  Initialize the dataset. ;  ; std::unique_ptr< RooAbsData > reduceEng (const RooArgSet &varSubset, const RooFormulaVar *cutVar, const char *cutRange=nullptr, std::size_t nStart=0, std::size_t nStop=std::numeric_limits< std::size_t >::max()) const override;  Implementation of RooAbsData virtual method that drives the RooAbsData::reduce() methods. ;  ;  Protected Member Functions inherited from RooAbsData; bool allClientsCached (RooAbsArg *, const RooArgSet &);  Utility function that determines if all clients of object 'var' appear in given list of cached nodes. ;  ; virtual void attachCache (const RooAbsArg *newOwner, const RooArgSet &cachedVars);  Internal method – Attach dataset copied with cache contents to copied instances of functions. ;  ; virtual void cacheArgs (const RooAbsArg *owner, RooArgSet &varSet, const RooArgSet *nset=nullptr, bool skipZeroWeights=false);  Internal method – Cache given set of functions with data. ;  ; double corrcov (const RooRealVar &x, const RooRealVar &y, const char *cutSpec, const char *cutRange, bool corr) const;  Internal method to calculate single correlation and covariance elements. ;  ; RooFit::OwningPtr< TMatrixDSym > corrcovMatrix (const RooArgList &vars, const char *cutSpec, const char *cutRange, bool corr) const;  Return covariance matrix from data for given list of observables. ;  ; RooRealVar * dataRealVar (const char *methodname, const RooRealVar &extVar) const;  Internal method to check if given RooRealVar maps to a RooRealVar in this dataset. ;  ; void initializeVars (RooArgSet const &vars);  ; virtual void optimizeReadingWithCaching (RooAbsArg &arg, const RooArgSet &cacheList, const RooArgSet &keepObsList);  Prepare dataset for use with cached constant terms listed in 'cacheList' of expression 'arg'. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataSet.html:31195,cache,cacheArgs,31195,doc/master/classRooDataSet.html,https://root.cern,https://root.cern/doc/master/classRooDataSet.html,1,['cache'],['cacheArgs']
Performance,"atic void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; double evaluate () const override;  Calculate and return current value of self. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddition.html:48457,cache,cached,48457,doc/master/classRooAddition.html,https://root.cern,https://root.cern/doc/master/classRooAddition.html,2,['cache'],"['cache', 'cached']"
Performance,"atic_cast<TH1 *>(data->Clone());; h_data->SetLineWidth(1);; h_data->SetMarkerStyle(20);; h_data->SetMarkerSize(1.0);; h_data->SetMarkerColor(kBlack);; h_data->SetLineColor(kBlack);; ; // Draw histograms; h_cmb->Draw(""HIST"");; h_bkg->Draw(""HIST SAME"");; h_data->Draw(""PE1 SAME"");; ; // Add legend; auto legend = new TLegend(0.62, 0.70, 0.82, 0.88);; legend->SetFillColor(0);; legend->SetBorderSize(0);; legend->SetTextSize(0.03);; legend->AddEntry(h_data, ""Data"", ""pe"");; legend->AddEntry(h_bkg, ""ZZ"", ""f"");; legend->AddEntry(h_cmb, ""m_{H} = 125 GeV"", ""f"");; legend->Draw();; ; // Add header; TLatex cms_label;; cms_label.SetTextSize(0.04);; cms_label.DrawLatexNDC(0.16, 0.92, ""#bf{CMS Open Data}"");; TLatex header;; header.SetTextSize(0.03);; header.DrawLatexNDC(0.63, 0.92, ""#sqrt{s} = 8 TeV, L_{int} = 11.6 fb^{-1}"");; ; // Save plot; c->SaveAs(filename.c_str());; }; ; void df103_NanoAODHiggsAnalysis(const bool run_fast = true); {; // Enable multi-threading; ROOT::EnableImplicitMT();; ; // In fast mode, take samples from */cms_opendata_2012_nanoaod_skimmed/*, which has; // the preselections from the selection_* functions already applied.; std::string path = ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/"";; if (run_fast) path = ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod_skimmed/"";; ; // Create dataframes for signal, background and data samples; ; // Signal: Higgs -> 4 leptons; ROOT::RDataFrame df_sig_4l(""Events"", path + ""SMHiggsToZZTo4L.root"");; ; // Background: ZZ -> 4 leptons; // Note that additional background processes from the original paper with minor contribution were left out for this; // tutorial.; ROOT::RDataFrame df_bkg_4mu(""Events"", path + ""ZZTo4mu.root"");; ROOT::RDataFrame df_bkg_4el(""Events"", path + ""ZZTo4e.root"");; ROOT::RDataFrame df_bkg_2el2mu(""Events"", path + ""ZZTo2e2mu.root"");; ; // CMS data taken in 2012 (11.6 fb^-1 integrated luminosity); ROOT::RDataFrame df_data_doublemu(; ""Events"", {path + ""Run2012B_DoubleMuParke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html:15609,multi-thread,multi-threading,15609,doc/master/df103__NanoAODHiggsAnalysis_8C.html,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html,1,['multi-thread'],['multi-threading']
Performance,"atically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is automatically used by TTree::Draw. The method knows which branches are used in the query and it puts automatically these branches in the cache. The entry range is also inferred automatically. TTree::Process and TSelectors Examples; The user must enable the cache and tell the system which branches to cache and also specify the entry range. It is important to specify the entry range in case only a subset of the events is processed to avoid wasteful caching.; Reading all branches; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"", true); //<<< add all branches to the cache; T->Process(""myselector.C+"");; // In the TSelector::Process function we read all branches; T->GetEntry(i);; // ... Here the entry is processed; f#define f(i)Definition RSha256.hxx:104; nentriesint nentriesDefinition THbookFile.cxx:91; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Reading a subset of all branches; In the Process function we read a subset of the branches. Only the branches used in the first entry will be put in the cache TTree *T;; f->GetObject(T, ""mytree"");; // We want to process only the 200 first entries; auto nentries=200UL;; auto efirst = 0;; auto elast = efirst+nentries;; auto cachesize = 10000000U; // 10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process(""myselector.C+"","""",nentries,efirst);; // In the TSelector::Pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:7017,cache,cachesize,7017,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,6,['cache'],"['cache', 'cachesize']"
Performance,"ating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_lowestOrder; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooPolyVar.html:33125,cache,cache,33125,root/html532/RooPolyVar.html,https://root.cern,https://root.cern/root/html532/RooPolyVar.html,1,['cache'],['cache']
Performance,"ating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,int,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction2Binding_double_int_int_.html:32445,cache,cache,32445,root/html526/RooCFunction2Binding_double_int_int_.html,https://root.cern,https://root.cern/root/html526/RooCFunction2Binding_double_int_int_.html,2,['cache'],['cache']
Performance,"ating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; TString_rangeName; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRangeBoolean.html:32840,cache,cache,32840,root/html532/RooRangeBoolean.html,https://root.cern,https://root.cern/root/html532/RooRangeBoolean.html,1,['cache'],['cache']
Performance,"ation ; Definition at line 361 of file h1analysis.h. ◆ GetOutputList(). TList * h1analysis::GetOutputList ; (; ); const. inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 357 of file h1analysis.h. ◆ Init(). void h1analysis::Init ; (; TTree * ; tree). overridevirtual . Reimplemented from TSelector.; Definition at line 390 of file h1analysis.h. ◆ IsA(). TClass * h1analysis::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 361 of file h1analysis.h. ◆ Notify(). Bool_t h1analysis::Notify ; (; ). overridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject.; Definition at line 554 of file h1analysis.h. ◆ Process(). Bool_t h1analysis::Process ; (; Long64_t ; ). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return valu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classh1analysis.html:21296,load,load,21296,doc/master/classh1analysis.html,https://root.cern,https://root.cern/doc/master/classh1analysis.html,2,['load'],['load']
Performance,"ation algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Various types of adaptive and non-adaptive integration are supported. These include integration over infinite and semi-infinite ranges and singular integrals.; The integration type is selected using the Integration::type enumeration in the class constructor. The default type is adaptive integration with singularity (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule. In the case of ADAPTIVE type, the integration rule can also be specified via the Integration::GKRule. The default rule is 31 points.; In the case of integration over infinite and semi-infinite ranges, the type used is always ADAPTIVESINGULAR applying a transformation from the original interval into (0,1).; The ADAPTIVESINGULAR type is the most sophicticated type. When performances are important, it is then recommended to use the NONADAPTIVE type in case of smooth functions or ADAPTIVE with a lower Gauss-Kronrod rule.; For detailed description on GSL integration algorithms see the GSL Manual. ; Definition at line 90 of file GSLIntegrator.h. Public Member Functions;  GSLIntegrator (const char *type, int rule, double absTol, double relTol, size_t size);  constructor of GSL Integrator. ;  ;  GSLIntegrator (const Integration::Type type, const Integration::GKRule rule, double absTol=1.E-9, double relTol=1E-6, size_t size=1000);  generic constructor for GSL Integrator ;  ;  GSLIntegrator (const Integration::Type type, double absTol=1.E-9, double relTol=1E-6, size_t size=1000);  constructor of GSL Integrator. ;  ;  GSLIntegrator (double absTol=1.E-9, double relTol=1E-6, size_t size=1000);  Default constructor of GSL Integrator for Adaptive Singular integration. ;  ;  ~GSLIntegrator () override;  ; double Error () const override;  return the estimate of the absolute Error of the last Integral calculation ;  ; IntegrationOneDim::T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLIntegrator.html:1442,perform,performances,1442,doc/master/classROOT_1_1Math_1_1GSLIntegrator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLIntegrator.html,1,['perform'],['performances']
Performance,ation code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; TIterator*_histObsIter! ; RooArgSet_histObsListList of observables defining dimensions of histogram; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intOrderInterpolation order; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfObsIter! ; RooSetProxy_pdfObsListList of observables mapped onto histogram observables; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHistPdf.html:37775,cache,cache,37775,root/html526/RooHistPdf.html,https://root.cern,https://root.cern/root/html526/RooHistPdf.html,1,['cache'],['cache']
Performance,ation code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; TIterator*_histObsIter! ; RooArgSet_histObsListList of observables defining dimensions of histogram; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intOrderInterpolation order; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfObsIter! ; RooSetProxy_pdfObsListList of observables mapped onto histogram observables; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHistPdf.html:38402,cache,cache,38402,root/html528/RooHistPdf.html,https://root.cern,https://root.cern/root/html528/RooHistPdf.html,2,['cache'],['cache']
Performance,"ation for the ML writer ;  CTProofMonSenderSQLTProofMonSender implementation for the SQL writers ;  CTProofNodeInfoThe purpose of this class is to provide a complete node description for masters, submasters and workers ;  CTProofNodesPROOF worker node information .  CTProofOutputFileClass to steer the merging of files produced on the workers ;  CTProofOutputListDerivation of TList with an overload of ls() and Print() allowing to filter out some of the variables ;  CTProofPerfAnalysisSet of tools to analyse the performance tree ;  ►CTProofPlayerInternal class steering processing in PROOF ;  CTCleanup;  CTProofPlayerLiteVersion of TProofPlayerRemote merges the functionality needed by clients and masters ;  CTProofPlayerLocal;  CTProofPlayerRemote;  CTProofPlayerSlave;  CTProofPlayerSuperMaster;  CTProofProgressDialog;  CTProofProgressInfo;  CTProofProgressLog;  CTProofProgressMemoryPlot;  CTProofProgressStatusContainer class for processing statistics ;  CTProofQueryResultTQueryResult version adapted to PROOF neeeds ;  CTProofResources;  CTProofResourcesStaticThe purpose of this class is to provide a standard interface to static config files ;  CTProofServClass providing the PROOF server ;  CTProofServLiteVersion of the PROOF worker server for local running ;  CTProofServLogHandler;  CTProofServLogHandlerGuard;  CTProofSuperMasterImplementation of TProof controlling PROOF federated clusters ;  CTProofVectorContainer;  ►CTProtoClassPersistent version of a TClass ;  CTProtoRealData;  CTPServerSocket;  CTPSocket;  CTPwdCtx;  CTPyArg;  CTPyClassGenerator;  CTPyDispatcher;  CTPyMultiGenFunction;  CTPyMultiGradFunction;  CTPyReturn;  CTPySelector;  ►CTPythia6TPythia is an interface class to F77 version of Pythia 6.2 .  CTPythia6CleanerUtility class to manage the TPythia6 instance ;  CTPythia6DecayerThis class implements the TVirtualMCDecayer interface ;  CTPythia8TPythia8 is an interface class to C++ version of Pythia 8.1 ; event generators, written by T.Sjostrand ;  CTPythi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:204596,perform,performance,204596,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['perform'],['performance']
Performance,ation if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_nNumber of expected events; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooRealProxy_pdfInput p.d.f; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; const TNamed*_rangeNameName of subset range; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeD,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExtendPdf.html:43310,cache,cache,43310,root/html602/RooExtendPdf.html,https://root.cern,https://root.cern/root/html602/RooExtendPdf.html,2,['cache'],['cache']
Performance,"ation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxymsf; RooRealProxysigma; RooRealProxyssf; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGaussModel.html:42423,cache,cache,42423,root/html532/RooGaussModel.html,https://root.cern,https://root.cern/root/html532/RooGaussModel.html,2,['cache'],['cache']
Performance,"ation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,int>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCFunction4PdfBinding_double_double_double_double_int_.html:40091,cache,cache,40091,root/html530/RooCFunction4PdfBinding_double_double_double_double_int_.html,https://root.cern,https://root.cern/root/html530/RooCFunction4PdfBinding_double_double_double_double_int_.html,2,['cache'],['cache']
Performance,"ation of module base class. Bool_t initializeRun(Int_t ); Method called at the beginning of each RooMCStudy run. RooDataSet* finalizeRun(); Method called at the end of each RooMCStudy run. If a RooDataSet is returned, it must have a length equal to; the number of toy experiments performed and will merged with the fitpar dataset of RooMCStudy. Bool_t processBeforeGen(Int_t ); Method called after resetting of generator parameters to initial values and before call to generator context; Any modifications to generator parameters will affect next generation operation (only). Bool_t processBetweenGenAndFit(Int_t ); Method called after generation of toy data sample and resetting of fit parameters to initial values and before; actual fit is performed. Any modifications to fit parameters will apply to next fit operation. Note that setConstant; flag of fit parameters are not explicitly reset by RooMCStudy, so any changes made to these flags here will persist. Bool_t processAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsMCStudyModule.html:8449,perform,performed,8449,root/html526/RooAbsMCStudyModule.html,https://root.cern,https://root.cern/root/html526/RooAbsMCStudyModule.html,7,['perform'],['performed']
Performance,"ation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset); Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset); Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedPdf.html:41710,cache,cache,41710,root/html526/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedPdf.html,1,['cache'],['cache']
Performance,"ation set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_dh) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #0 because y cannot accommodate the value 14.424; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #3 because y cannot accommodate the value -12.0022; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #5 because y cannot accommodate the value 13.8261; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #6 because y cannot accommodate the value -14.9925; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 36 out-of-range events; ; -----------------------; Reading data from ASCII; [#1] INFO:DataHandling -- RooDataSet::read: reading file rf102_testData.txt; [#1] INFO:DataHandling -- RooDataSet::read: read 64 events (ignored 0 out of range events); DataStore dataset (rf102_testData.txt); Contains 64 entries; Observables: ; 1) x = 0.0174204 L(-10 - 10) ""x""; 2) y = 9.46654 L(-10 - 10) ""y""; 3) blindState = Normal(idx = 0); ""Blinding State""; ; Original data, line 20:; 1) RooRealVar:: x = -0.79919; 2) RooRealVar:: y = 0.0106407; ; Read-back data, line 20:; 1) RooRealVar:: x = -0.79919; 2) RooRealVar:: y = 0.0106407; 3) RooCategory:: blindState = Normal(idx = 0); ; RooDataSet::ds[x,y] = 64 entries; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf102_dataimport.C. tutorialsroofitrf102_dataimport.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf102__dataimport_8C.html:11283,load,loadValues,11283,doc/master/rf102__dataimport_8C.html,https://root.cern,https://root.cern/doc/master/rf102__dataimport_8C.html,1,['load'],['loadValues']
Performance,"ation set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_dh) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #0 because y cannot accommodate the value 14.424; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #3 because y cannot accommodate the value -12.0022; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #5 because y cannot accommodate the value 13.8261; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #6 because y cannot accommodate the value -14.9925; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 36 out-of-range events; [#1] INFO:DataHandling -- RooDataSet::read: reading file rf102_testData.txt; [#1] INFO:DataHandling -- RooDataSet::read: read 64 events (ignored 0 out of range events); DataStore dataset (rf102_testData.txt); Contains 64 entries; Observables: ; 1) x = 9.46654 L(-10 - 10) ""x""; 2) y = 0.0174204 L(-10 - 10) ""y""; 3) blindState = Normal(idx = 0); ""Blinding State""; 1) RooRealVar:: y = 0.0106407; 2) RooRealVar:: x = -0.79919; 1) RooRealVar:: x = 0.0106407; 2) RooRealVar:: y = -0.79919; 3) RooCategory:: blindState = Normal(idx = 0); ; RooDataSet::ds[y,x] = 64 entries; ; -----------------------; Reading data from ASCII; ; Original data, line 20:; ; Read-back data, line 20:; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf102_dataimport.py. tutorialsroofitrf102_dataimport.py. ROOT master - Reference Guide Generated on ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf102__dataimport_8py.html:7070,load,loadValues,7070,doc/master/rf102__dataimport_8py.html,https://root.cern,https://root.cern/doc/master/rf102__dataimport_8py.html,1,['load'],['loadValues']
Performance,"ation set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,double>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4PdfBinding_double_double_double_double_double_.html:45139,cache,cache,45139,root/html602/RooCFunction4PdfBinding_double_double_double_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4PdfBinding_double_double_double_double_double_.html,2,['cache'],['cache']
Performance,"ation set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; const ROOT::Math::IBaseFunctionMultiDim*funcFunctor; RooListProxyvarsArgument reference; Double_t*xArgument value array.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooFunctorPdfBinding.html:40186,cache,cache,40186,root/html530/RooFunctorPdfBinding.html,https://root.cern,https://root.cern/root/html530/RooFunctorPdfBinding.html,2,['cache'],['cache']
Performance,"ation specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdfProxy to p.d.f being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. The dimensions; of the cache are automatically matched to the number of observables used; in each use context. Multiple cache in different observable may exists; simultanously if the cached p.d.f is used with multiple observable; configurations simultaneously. RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedPdf.html:41170,cache,cached,41170,root/html526/RooCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooCachedPdf.html,4,['cache'],['cached']
Performance,"ation; RooProduct(); Default constructor. ~RooProduct(); Destructor. RooProduct(const char* name, const char* title, const RooArgSet& _prodSet); Construct function representing the product of functions in prodSet. RooProduct(const RooProduct& other, const char* name = 0); Copy constructor. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force internal handling of integration of given observable if any; of the product terms depend on it. Int_t getPartIntList(const RooArgSet* iset, const char* rangeName = 0) const; Return list of (partial) integrals whose product defines the integral of this; RooProduct over the observables in iset in range isetRange. If no such list; exists, create it now and store it in the cache for future use. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Declare that we handle all integrations internally. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Calculate integral internally from appropriate partial integral cache. Double_t calculate(const RooArgList& partIntList) const; Calculate and return product of partial terms in partIntList. const char* makeFPName(const char* pfx, const RooArgSet& terms) const; Construct automatic name for internal product terms. Double_t evaluate() const; Evaluate product of input functions. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProduct to more intuitively reflect the contents of the; product operator constr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProduct.html:35155,cache,cache,35155,root/html532/RooProduct.html,https://root.cern,https://root.cern/root/html532/RooProduct.html,1,['cache'],['cache']
Performance,"ation; RooProduct(); Default constructor. ~RooProduct(); Destructor. RooProduct(const char* name, const char* title, const RooArgSet& _prodSet); Construct function representing the product of functions in prodSet. RooProduct(const RooProduct& other, const char* name = 0); Copy constructor. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force internal handling of integration of given observable if any; of the product terms depend on it. Int_t getPartIntList(const RooArgSet* iset, const char* rangeName = 0) const; Return list of (partial) integrals whose product defines the integral of this; RooProduct over the observables in iset in range isetRange. If no such list; exists, create it now and store it in the cache for future use. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Declare that we handle all integrations internally. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Calculate integral internally from appropriate partial integral cache. Double_t calculate(const RooArgList& partIntList) const; Calculate and return product of partial terms in partIntList. const char* makeFPName(const char* pfx, const RooArgSet& terms) const; Construct automatic name for internal product terms. Double_t evaluate() const; Evaluate product of input functions. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProduct to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooProduct(*this, newname); }. RooArgSet components(); { RooArgSet tmp(_compRSet) ; tmp.add(_compCSet) ; return tmp ; }. ProdMap* groupProductTerms(const RooArgSet& ) const. » Last changed: Mon Jul 4 15:23:44 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooProduct.html:34484,cache,cache,34484,root/html530/RooProduct.html,https://root.cern,https://root.cern/root/html530/RooProduct.html,1,['cache'],['cache']
Performance,"ation; RooProduct(); Default constructor. ~RooProduct(); Destructor. RooProduct(const char* name, const char* title, const RooArgSet& _prodSet); Construct function representing the product of functions in prodSet. RooProduct(const RooProduct& other, const char* name = 0); Copy constructor. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force internal handling of integration of given observable if any; of the product terms depend on it. Int_t getPartIntList(const RooArgSet* iset, const char* rangeName = 0) const; Return list of (partial) integrals whose product defines the integral of this; RooProduct over the observables in iset in range isetRange. If no such list; exists, create it now and store it in the cache for future use. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Declare that we handle all integrations internally. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Calculate integral internally from appropriate partial integral cache. Double_t calculate(const RooArgList& partIntList) const; Calculate and return product of partial terms in partIntList. const char* makeFPName(const char* pfx, const RooArgSet& terms) const; Construct automatic name for internal product terms. Double_t evaluate() const; Evaluate product of input functions. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProduct to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooProduct(*this, newname); }. RooArgSet components(); { RooArgSet tmp(_compRSet) ; tmp.add(_compCSet) ; return tmp ; }. ProdMap* groupProductTerms(const RooArgSet& ) const. » Last changed: Sat Oct 9 20:48:34 2010 » Last generated: 2010-10-09 20:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProduct.html:33967,cache,cache,33967,root/html528/RooProduct.html,https://root.cern,https://root.cern/root/html528/RooProduct.html,1,['cache'],['cache']
Performance,"ationCount. std::atomic<UInt_t> TTree::fAllocationCount {0}. mutableprotected . indicates basket should be resized to exact memory usage, but causes significant ; memory churn. ! Number of reallocations basket memory buffers. ; Definition at line 152 of file TTree.h. ◆ fAutoFlush. Long64_t TTree::fAutoFlush. protected . Auto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced. ; Definition at line 101 of file TTree.h. ◆ fAutoSave. Long64_t TTree::fAutoSave. protected . Autosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced. ; Definition at line 100 of file TTree.h. ◆ fBranches. TObjArray TTree::fBranches. protected . List of Branches. ; Definition at line 122 of file TTree.h. ◆ fBranchRef. TBranchRef* TTree::fBranchRef. protected . Branch supporting the TRefTable (if any) ; Definition at line 136 of file TTree.h. ◆ fCacheDoAutoInit. bool TTree::fCacheDoAutoInit. protected . ! true if cache auto creation or resize check is needed ; Definition at line 139 of file TTree.h. ◆ fCacheDoClusterPrefetch. bool TTree::fCacheDoClusterPrefetch. protected . ! true if cache is prefetching whole clusters ; Definition at line 140 of file TTree.h. ◆ fCacheSize. Long64_t TTree::fCacheSize. protected . ! Maximum size of file buffers ; Definition at line 105 of file TTree.h. ◆ fCacheUserSet. bool TTree::fCacheUserSet. protected . ! true if the cache setting was explicitly given by user ; Definition at line 141 of file TTree.h. ◆ fChainOffset. Long64_t TTree::fChainOffset. protected . ! Offset of 1st entry of this Tree in a TChain ; Definition at line 106 of file TTree.h. ◆ fClones. TList* TTree::fClones. protected . ! List of cloned trees which share our addresses ; Definition at line 135 of file TTree.h. ◆ fClusterRangeEnd. Long64_t* TTree::fClusterRangeEnd. protected . [fNClusterRange] Last entry of a cluster range. ; Definition at line 103 of file TTree.h. ◆ fClusterSize. Long64_t* TTree::fClusterSize. protected . [fN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:224804,cache,cache,224804,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['cache'],['cache']
Performance,"ationDate ; (; ); const. inline . Definition at line 95 of file TDirectoryFile.h. ◆ GetNbytesKeys(). Int_t TDirectoryFile::GetNbytesKeys ; (; ); const. inlineoverridevirtual . Reimplemented from TDirectory.; Definition at line 96 of file TDirectoryFile.h. ◆ GetNkeys(). Int_t TDirectoryFile::GetNkeys ; (; ); const. inlineoverridevirtual . Reimplemented from TDirectory.; Definition at line 97 of file TDirectoryFile.h. ◆ GetObjectChecked() [1/2]. void * TDirectoryFile::GetObjectChecked ; (; const char * ; namecycle, . const char * ; classname . ). overridevirtual . See documentation of TDirectoryFile::GetObjectCheck(const char *namecycle, const TClass *cl) ; Reimplemented from TDirectory.; Definition at line 1018 of file TDirectoryFile.cxx. ◆ GetObjectChecked() [2/2]. void * TDirectoryFile::GetObjectChecked ; (; const char * ; namecycle, . const TClass * ; expectedClass . ). overridevirtual . Return pointer to object identified by namecycle if and only if the actual object is a type suitable to be stored as a pointer to a ""expectedClass"" If expectedClass is null, no check is performed. . namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. Very important note; The calling application must cast the returned pointer to the type described by the 2 arguments (i.e. cl):; auto objPtr = (MyClass*)directory->GetObjectChecked(""some object of MyClass"",""MyClass""));; Note: We recommend using the method TDirectoryFile::Get<T>: auto objPtr = directory->Get<MyClass>(""some object inheriting from MyClass"");; if (objPtr) { ... we found what we are looking for ... }; whatstatic const char * whatDefinition stlLoader.cc:5. Reimplemented from TDirectory.; Definition at line 1045 of file TDirectoryFile.cxx. ◆ GetObjectUnchecked(). void * TDirectoryFile::GetObjectUnchecked ; (; const char * ; namecycle). overridevirtual . Return pointer to object identified by namecycle. ; The returned object may or may not der",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDirectoryFile.html:38052,perform,performed,38052,doc/master/classTDirectoryFile.html,https://root.cern,https://root.cern/doc/master/classTDirectoryFile.html,1,['perform'],['performed']
Performance,atistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; Double_t_offsetCarrySaveW2!; Double_t_offsetSaveW2!; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::_optimized!; RooAbsData*RooAbsOptTestStatistic::_origDataOriginal data; RooAbsReal*RooAbsOptTestStatistic::_origFuncOriginal function; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server o,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNLLVar.html:42855,cache,cache,42855,root/html602/RooNLLVar.html,https://root.cern,https://root.cern/root/html602/RooNLLVar.html,2,['cache'],['cache']
Performance,"ative of this function. RooDerivative* derivative(RooRealVar& obs, const RooArgSet& normSet, Int_t order, Double_t eps = 0.001); Return function representing first, second or third order derivative of this function. RooMoment* moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); Return function representing moment of function of given order. If central is; true, the central moment is given <(x-<x>)^2>. RooMoment* moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Return function representing moment of p.d.f (normalized w.r.t given observables) of given order. If central is; true, the central moment is given <(x-<x>)^2>. If intNormObs is true, the moment of the function integrated over; all normalization observables is returned. Double_t findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval). Return value of x (in range xmin,xmax) at which function equals yval.; (Calculation is performed with Brent root finding algorithm). RooGenFunction* iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()). RooMultiGenFunction* iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()). RooFitResult* chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Perform a chi^2 fit to given histogram By default the fit is executed through the MINUIT; commands MIGRAD, HESSE in succession. The following named arguments are supported. Options to control construction of -log(L). Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsReal.html:70431,perform,performed,70431,root/html528/RooAbsReal.html,https://root.cern,https://root.cern/root/html528/RooAbsReal.html,3,['perform'],['performed']
Performance,"ative of this function. RooDerivative* derivative(RooRealVar& obs, const RooArgSet& normSet, Int_t order, Double_t eps = 0.001); Return function representing first, second or third order derivative of this function. RooMoment* moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); Return function representing moment of function of given order. If central is; true, the central moment is given <(x-<x>)^2>. RooMoment* moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Return function representing moment of p.d.f (normalized w.r.t given observables) of given order. If central is; true, the central moment is given <(x-<x>)^2>. If intNormObs is true, the moment of the function integrated over; all normalization observables is returned. Double_t findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval). Return value of x (in range xmin,xmax) at which function equals yval.; (Calculation is performed with Brent root finding algorithm). RooGenFunction* iGenFunction(RooRealVar& x, const RooArgSet& nset). RooMultiGenFunction* iGenFunction(const RooArgSet& observables, const RooArgSet& nset). RooFitResult* chi2FitTo(RooDataHist& data, RooCmdArg arg1, RooCmdArg arg2, 				 RooCmdArg arg3, RooCmdArg arg4, RooCmdArg arg5, 				 RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8); Perform a chi^2 fit to given histogram By default the fit is executed through the MINUIT; commands MIGRAD, HESSE in succession. The following named arguments are supported. Options to control construction of -log(L). Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; NumCPU(int num) -- Parallelize NLL calculation on num CPUs; Optimize(Bool_t flag) -- Activate constant term optimization (on by default). Options to contr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:69699,perform,performed,69699,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,1,['perform'],['performed']
Performance,"ative use. const RooArgSet* get(const RooArgSet& coord) const; Return a RooArgSet with center coordinates of the bin; enclosing the point 'coord'. Double_t binVolume(const RooArgSet& bin); Return the volume of the bin enclosing coordinates 'coord'. void setAllWeights(Double_t value); Set all the event weight of all bins to the specified value. TIterator* sliceIterator(RooAbsArg& sliceArg, const RooArgSet& otherArgs); Create an iterator over all bins in a slice defined by the subset of observables; listed in sliceArg. The position of the slice is given by otherArgs. void SetName(const char* name); Change the name of the RooDataHist. void SetNameTitle(const char* name, const char* title); Change the title of this RooDataHist. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. void cacheValidEntries(); Cache the datahist entries with bin centers that are inside/outside the; current observable definitio. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Bool_t isNonPoissonWeighted() const; Returns true if datasets contains entries with a non-integer weight. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print the details on the dataset contents. void Streamer(TBuffer& ); Stream an object of class RooDataHist. TObject* Clone(const char* newname = 0) const; { return new RooDataHist(*this,newname?newname:GetName()) ; }. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* = 0) const; Return empty clone of this RooDataHist. void add(const RooArgSet& row, Double_t wgt = 1.); Add one ore more rows of data. const RooArgSet* get() const; Return set with coordinates of center of current bin. Bool_t isWeighted() const; Return tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataHist.html:35693,cache,cacheValidEntries,35693,root/html602/RooDataHist.html,https://root.cern,https://root.cern/root/html602/RooDataHist.html,2,['cache'],['cacheValidEntries']
Performance,"ative use. const RooArgSet* get(const RooArgSet& coord) const; Return a RooArgSet with center coordinates of the bin; enclosing the point 'coord'. Double_t binVolume(const RooArgSet& bin); Return the volume of the bin enclosing coordinates 'coord'. void setAllWeights(Double_t value); Set all the event weight of all bins to the specified value. TIterator* sliceIterator(RooAbsArg& sliceArg, const RooArgSet& otherArgs); Create an iterator over all bins in a slice defined by the subset of observables; listed in sliceArg. The position of the slice is given by otherArgs. void SetName(const char* name); Change the name of the RooDataHist. void SetNameTitle(const char* name, const char* title); Change the title of this RooDataHist. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. void cacheValidEntries(); Cache the datahist entries with bin centers that are inside/outside the; current observable definitio. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Bool_t isNonPoissonWeighted() const; Returns true if datasets contains entries with a non-integer weight. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print the details on the dataset contents. void Streamer(TBuffer& ); Stream an object of class RooDataHist. TObject* Clone(const char* newname = 0) const; { return new RooDataHist(*this,newname?newname:GetName()) ; }. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* = 0) const; Return empty clone of this RooDataHist. void add(const RooArgSet& row, Double_t wgt = 1.0); Add one ore more rows of data. const RooArgSet* get() const; Return set with coordinates of center of current bin. Bool_t isWeighted() const; Return t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataHist.html:34488,cache,cacheValidEntries,34488,root/html534/RooDataHist.html,https://root.cern,https://root.cern/root/html534/RooDataHist.html,1,['cache'],['cacheValidEntries']
Performance,"ative use. const RooArgSet* get(const RooArgSet& coord) const; Return a RooArgSet with center coordinates of the bin; enclosing the point 'coord'. Double_t binVolume(const RooArgSet& bin); Return the volume of the bin enclosing coordinates 'coord'. void setAllWeights(Double_t value); Set all the event weight of all bins to the specified value. TIterator* sliceIterator(RooAbsArg& sliceArg, const RooArgSet& otherArgs); Create an iterator over all bins in a slice defined by the subset of observables; listed in sliceArg. The position of the slice is given by otherArgs. void SetName(const char* name); Change the name of the RooDataHist. void SetNameTitle(const char* name, const char* title); Change the title of this RooDataHist. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. void cacheValidEntries(); Cache the datahist entries with bin centers that are inside/outside the; current observable definitio. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Bool_t isNonPoissonWeighted() const; Returns true if datasets contains entries with a non-integer weight. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print the details on the dataset contents. void Streamer(TBuffer& b); Stream an object of class RooDataHist. TObject* Clone(const char* newname = 0) const; { return new RooDataHist(*this,newname?newname:GetName()) ; }. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const; Return empty clone of this RooDataHist. void add(const RooArgSet& row, Double_t wgt = 1.0); Add one ore more rows of data. const RooArgSet* get() const; Return set with coordinates of center of current bin. Bool_t isWeighted() const; Return true as all histo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDataHist.html:32023,cache,cacheValidEntries,32023,root/html528/RooDataHist.html,https://root.cern,https://root.cern/root/html528/RooDataHist.html,3,['cache'],['cacheValidEntries']
Performance,"atomic<Int_t>TFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. private:. XrdClient*fClientHandle to the client object; void*fInitMtxProtects fInitDone, serializes the; Bool_tfIsRootdNature of remote file server; static TFileStager*fgFileStagerStager for IsStaged checks; static Bool_tfgInitDoneAvoid initializing more than once; static Bool_tfgRootdBCControl rootd backward compatibility. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TDirectory. ←; TDirectoryFile. ←; TFile. ←; TNetFile. ←; TXNetFile. Function documentation; TXNetFile(const char* url, Option_t* option = """", const char* fTitle = """", Int_t compress = 1, Int_t netopt = 0, Bool_t parallelopen = kFALSE, const char* logicalurl = 0); Create a TXNetFile object. A TXNetFile object is the same as a TNetFile; (from which the former derives) except that the protocol is extended to; support dealing with new xrootd data server or xrootd load balancer; server. The ""url"" argument must be of the form. root://server1:port1[,server2:port2,...,serverN:portN]/pathfile,. Note that this means that multiple servers (>= 1) can be specified in; the url. The connection will try to connect to the first server:port; and if that does not succeed, it will try the second one, and so on; until it finds a server that will respond. See the TNetFile documentation for the description of the other arguments. The creation consists of internal variable settings (most important is; the client's domain), creation of a TXUrl array containing all specified; urls (a single url is serverX:portX/pathfile), trying to connect to the; servers calling Connect() method, getting a valid access to the remote; server the client is connected to using GetAccessToSrv() method,; recognizing the remote server (if an old rootd the TNetFile's Create; method will be called). The options fiel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXNetFile.html:26237,load,load,26237,root/html602/TXNetFile.html,https://root.cern,https://root.cern/root/html602/TXNetFile.html,1,['load'],['load']
Performance,"ator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&RooAbsCategoryLValue::operator=(int index); RooAbsArg&RooAbsCategoryLValue::operator=(const char* label); RooAbsArg&RooAbsCategoryLValue::operator=(const RooAbsCategory& other); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCategory.html:11121,optimiz,optimizeCacheMode,11121,root/html526/RooCategory.html,https://root.cern,https://root.cern/root/html526/RooCategory.html,2,['optimiz'],['optimizeCacheMode']
Performance,"ator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&RooAbsCategoryLValue::operator=(int index); RooAbsArg&RooAbsCategoryLValue::operator=(const char* label); RooAbsArg&RooAbsCategoryLValue::operator=(const RooAbsCategory& other); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCategory.html:11236,optimiz,optimizeCacheMode,11236,root/html528/RooCategory.html,https://root.cern,https://root.cern/root/html528/RooCategory.html,8,['optimiz'],['optimizeCacheMode']
Performance,"ator line; TGVerticalFrame Composite frame with vertical child layout; TGVerticalLayout Vertical layout manager; TGView View widget base class; TGViewFrame Frame containing the actual text; TGViewPort Viewport through which to look at a container frame; TGWidget Widget base class; TGWindow GUI Window base class; TGX11 Interface to X11; TGX11TTF Interface to X11 + TTF font handling; TGXYLayout X / Y - layout manager; TGXYLayoutHints Hits for the X / Y - layout manager; TGaxis Graphics axis; TGedEditor ROOT graphics editor; TGedFrame base editor's frame; TGedMarkerPopup marker select popup; TGedMarkerSelect Marker selection button; TGedNameFrame frame showing the selected object name; TGedPatternFrame pattern frame; TGedPatternPopup Color selector popup; TGedPatternSelect pattern selection check-button; TGedPatternSelector select pattern frame; TGedPopup popup window; TGedSelect selection check-button; TGenCollectionProxy ; TGenCollectionProxy::Method ; TGenCollectionProxy::Value ; TGenPhaseSpace Simple Phase Space Generator; TGenerator Event generator interface abstract baseclass; TGenericTable Generic array of C-structure (a'la STL vector); TGenericTable::iterator ; TGeoArb8 arbitrary trapezoid with 8 vertices; TGeoAtt class for visibility, activity and optimization attributes for volumes/nodes; TGeoBBox box primitive; TGeoBBoxEditor TGeoBBox editor; TGeoBatemanSol Solution for the Bateman equation; TGeoBoolNode a boolean node; TGeoBuilder geometry builder singleton; TGeoCacheState class storing the cache state; TGeoChecker a simple geometry checker; TGeoCombiTrans rotation + translation; TGeoCombiTransEditor TGeoCombiTrans editor; TGeoCompositeShape boolean composite shape; TGeoCone conical tube class; TGeoConeEditor TGeoCone editor; TGeoConeSeg conical tube segment class ; TGeoConeSegEditor TGeoConeSeg editor; TGeoCtub cut tube segment class ; TGeoCtubEditor TGeoCtub editor; TGeoDecayChannel Decay channel for Elements; TGeoElemIter Iterator for radionuclide chains.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:81613,optimiz,optimization,81613,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,6,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,ator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealVar*RooAbsAnaConvPdf::_convVar! Convolution variable; RooRealProxy_delMistag; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dm; RooRealProxy_effRatio; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerR,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBCPEffDecay.html:39064,cache,cache,39064,root/html526/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html526/RooBCPEffDecay.html,1,['cache'],['cache']
Performance,ator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealVar*RooAbsAnaConvPdf::_convVar! Convolution variable; RooRealProxy_delMistag; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dm; RooRealProxy_effRatio; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of pl,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBCPEffDecay.html:39638,cache,cache,39638,root/html528/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html528/RooBCPEffDecay.html,3,['cache'],['cache']
Performance,"ator.Definition WrappedMultiTF1.h:273; ROOT::Math::WrappedMultiTF1Templ::fLinearbool fLinearDefinition WrappedMultiTF1.h:184; ROOT::Math::WrappedMultiTF1Templ::ParameterNamestd::string ParameterName(unsigned int i) const overridereturn parameter name (from TF1)Definition WrappedMultiTF1.h:121; ROOT::Math::WrappedMultiTF1Templ::GetFunctionconst TF1 * GetFunction() constmethod to retrieve the internal function pointerDefinition WrappedMultiTF1.h:147; ROOT::Math::WrappedMultiTF1Templ::NDimunsigned int NDim() const overrideRetrieve the dimension of the function.Definition WrappedMultiTF1.h:94; ROOT::Math::WrappedMultiTF1Templ::NParunsigned int NPar() const overridereturn number of parametersDefinition WrappedMultiTF1.h:114; ROOT::Math::WrappedMultiTF1Templ::CloneIMultiGenFunctionTempl< T > * Clone() const overrideClone the wrapper but not the original function.Definition WrappedMultiTF1.h:86; ROOT::Math::WrappedMultiTF1Templ::SetParametersvoid SetParameters(const double *p) overrideset parameter values (only the cached one in this class,leave unchanges those of TF1)Definition WrappedMultiTF1.h:107; ROOT::Math::WrappedMultiTF1Templ::ParameterGradientvoid ParameterGradient(const T *x, const double *par, T *grad) const overrideEvaluate the all the derivatives (gradient vector) of the function with respect to the parameters at ...Definition WrappedMultiTF1.h:286; ROOT::Math::WrappedMultiTF1Templ::fOwnFuncbool fOwnFuncDefinition WrappedMultiTF1.h:186; ROOT::Math::WrappedMultiTF1Templ::BaseFuncROOT::Math::IParametricFunctionMultiDimTempl< T >::BaseFunc BaseFuncDefinition WrappedMultiTF1.h:53; ROOT::Math::WrappedMultiTF1Templ::DoEvalVecT DoEvalVec(const T *x) constevaluate function using the cached parameter values (of TF1) re-implement for better efficiencyDefinition WrappedMultiTF1.h:165; ROOT::Math::WrappedMultiTF1Templ::fPolynomialbool fPolynomialDefinition WrappedMultiTF1.h:185; ROOT::Math::WrappedMultiTF1Templ::DoEvalParT DoEvalPar(const T *x, const double *p) const overr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:18836,cache,cached,18836,doc/master/WrappedMultiTF1_8h_source.html,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html,1,['cache'],['cached']
Performance,"ator.cxx. Member Function Documentation. ◆ ApproximatePosterior(). void RooStats::BayesianCalculator::ApproximatePosterior ; (; ); const. protected . approximate posterior in nbins using a TF1 scan the poi values and evaluate the posterior at each point and save the result in a cloned TF1 For each point the posterior is evaluated by integrating the nuisance parameters ; Definition at line 1319 of file BayesianCalculator.cxx. ◆ Class(). static TClass * RooStats::BayesianCalculator::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooStats::BayesianCalculator::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooStats::BayesianCalculator::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 194 of file BayesianCalculator.h. ◆ ClearAll(). void RooStats::BayesianCalculator::ClearAll ; (; ); const. protected . clear all cached pdf objects ; Definition at line 714 of file BayesianCalculator.cxx. ◆ ComputeIntervalFromApproxPosterior(). void RooStats::BayesianCalculator::ComputeIntervalFromApproxPosterior ; (; double ; c1, . double ; c2 . ); const. protected . compute the interval using the approximate posterior function ; Definition at line 1364 of file BayesianCalculator.cxx. ◆ ComputeIntervalFromCdf(). void RooStats::BayesianCalculator::ComputeIntervalFromCdf ; (; double ; c1, . double ; c2 . ); const. protected . internal function compute the interval using Cdf integration ; Definition at line 1243 of file BayesianCalculator.cxx. ◆ ComputeIntervalUsingRooFit(). void RooStats::BayesianCalculator::ComputeIntervalUsingRooFit ; (; double ; c1, . double ; c2 . ); const. protected . internal function compute the interval using RooFit ; Definition at line 1194 of file BayesianCalculator.cxx. ◆ ComputeShortestInterval(). void RooStats::BayesianCalculator::ComputeShortestInterval ; (; ); const. protected . compute the shortest interval fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html:22844,cache,cached,22844,doc/master/classRooStats_1_1BayesianCalculator.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html,1,['cache'],['cached']
Performance,"ator::_funcValPtrRRVs storing function value in context and in output dataset; RooRealVar*RooAbsNumGenerator::_funcValStore; Bool_tRooAbsNumGenerator::_isValidVerbose and valid flag; static Int_tRooPrintable::_nameLength; Double_t*_rangeRange of observables to be generated ;; RooArgSetRooAbsNumGenerator::_realVarsSets of discrete and real valued observabeles; TIterator*_rvIterIteratator over _realVars ;; TFoam*_tfoamInstance of TFOAM generator; Double_t*_vecTransfer array for FOAM output; Bool_tRooAbsNumGenerator::_verbose; Double_t*_xminLower bound of observables to be generated ;; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerSampler(RooNumGenFactory& fact); Register RooIntegrator1D, is parameters and capabilities with RooNumIntFactory. RooFoamGenerator(const RooAbsReal& func, const RooArgSet& genVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0). ~RooFoamGenerator(); Destructor. const RooArgSet * generateEvent(UInt_t remaining, Double_t& resampleRatio); are we actually generating anything? (the cache always contains at least our function value). RooFoamGenerator(); {}. RooFoamGenerator(const RooAbsReal& func, const RooArgSet& genVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0). RooAbsNumGenerator* clone(const RooAbsReal& func, const RooArgSet& genVars, const RooArgSet& , const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const. TFoam& engine(); { return *_tfoam; }. Bool_t canSampleConditional() const; { return kFALSE ; }. Bool_t canSampleCategories() const; { return kFALSE ; }. » Last changed: Mon Dec 7 13:47:39 2009 » Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFoamGenerator.html:9437,cache,cache,9437,root/html526/RooFoamGenerator.html,https://root.cern,https://root.cern/root/html526/RooFoamGenerator.html,1,['cache'],['cache']
Performance,"ator::_funcValPtrRRVs storing function value in context and in output dataset; RooRealVar*RooAbsNumGenerator::_funcValStore; Bool_tRooAbsNumGenerator::_isValidVerbose and valid flag; static Int_tRooPrintable::_nameLength; Double_t*_rangeRange of observables to be generated ;; RooArgSetRooAbsNumGenerator::_realVarsSets of discrete and real valued observabeles; TIterator*_rvIterIteratator over _realVars ;; TFoam*_tfoamInstance of TFOAM generator; Double_t*_vecTransfer array for FOAM output; Bool_tRooAbsNumGenerator::_verbose; Double_t*_xminLower bound of observables to be generated ;; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerSampler(RooNumGenFactory& fact); Register RooIntegrator1D, is parameters and capabilities with RooNumIntFactory. RooFoamGenerator(const RooAbsReal& func, const RooArgSet& genVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0). ~RooFoamGenerator(); Destructor. const RooArgSet * generateEvent(UInt_t remaining, Double_t& resampleRatio); are we actually generating anything? (the cache always contains at least our function value). RooFoamGenerator(); {}. RooFoamGenerator(const RooAbsReal& func, const RooArgSet& genVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0). RooAbsNumGenerator* clone(const RooAbsReal& func, const RooArgSet& genVars, const RooArgSet& , const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const. TFoam& engine(); { return *_tfoam; }. Bool_t canSampleConditional() const; { return kFALSE ; }. Bool_t canSampleCategories() const; { return kFALSE ; }. » Last changed: Mon Jul 4 15:22:50 2011 » Last generated: 2011-07-04 15:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooFoamGenerator.html:9492,cache,cache,9492,root/html530/RooFoamGenerator.html,https://root.cern,https://root.cern/root/html530/RooFoamGenerator.html,1,['cache'],['cache']
Performance,"ator::_funcValPtrRRVs storing function value in context and in output dataset; RooRealVar*RooAbsNumGenerator::_funcValStore; Bool_tRooAbsNumGenerator::_isValidVerbose and valid flag; static Int_tRooPrintable::_nameLength; Double_t*_rangeRange of observables to be generated ;; RooArgSetRooAbsNumGenerator::_realVarsSets of discrete and real valued observabeles; TIterator*_rvIterIteratator over _realVars ;; TFoam*_tfoamInstance of TFOAM generator; Double_t*_vecTransfer array for FOAM output; Bool_tRooAbsNumGenerator::_verbose; Double_t*_xminLower bound of observables to be generated ;; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerSampler(RooNumGenFactory& fact); Register RooIntegrator1D, is parameters and capabilities with RooNumIntFactory. RooFoamGenerator(const RooAbsReal& func, const RooArgSet& genVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0). ~RooFoamGenerator(); Destructor. const RooArgSet * generateEvent(UInt_t remaining, Double_t& resampleRatio); are we actually generating anything? (the cache always contains at least our function value). RooFoamGenerator(); {}. RooFoamGenerator(const RooAbsReal& func, const RooArgSet& genVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0). RooAbsNumGenerator* clone(const RooAbsReal& func, const RooArgSet& genVars, const RooArgSet& , const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const. TFoam& engine(); { return *_tfoam; }. Bool_t canSampleConditional() const; { return kFALSE ; }. Bool_t canSampleCategories() const; { return kFALSE ; }. » Last changed: Thu Nov 3 20:08:08 2011 » Last generated: 2011-11-03 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFoamGenerator.html:9492,cache,cache,9492,root/html532/RooFoamGenerator.html,https://root.cern,https://root.cern/root/html532/RooFoamGenerator.html,1,['cache'],['cache']
Performance,"ator<string>{}};; 3346 // Skip the first element: it is a relative path to `lib`.; 3347 for (auto I = libs.begin() + 1, E = libs.end(); I != E; ++I); 3348 if (!f(I->c_str())); 3349 break;; 3350 };; 3351 auto LoadLibrary = [useCxxModules, produceRootmap, ForeachSharedLibDep](const TString &lib) {; 3352 // We have no rootmap files or modules to construct `-l` flags enabling; 3353 // explicit linking. We have to resolve the dependencies by ourselves; 3354 // taking the job of the dyld.; 3355 // FIXME: This is a rare case where we have rootcling running with; 3356 // modules disabled. Remove this code once we fully switch to modules,; 3357 // or implement a special flag in rootcling which selective enables; 3358 // modules for dependent libraries and does not produce a module for; 3359 // the ACLiC library.; 3360 if (useCxxModules && !produceRootmap) {; 3361 std::function<bool(const char *)> LoadLibF = [](const char *dep) {; 3362 return gInterpreter->Load(dep, /*skipReload*/ true) >= 0;; 3363 };; 3364 ForeachSharedLibDep(lib, LoadLibF);; 3365 }; 3366 return !gSystem->Load(lib);; 3367 };; 3368 ; 3369 if (!recompile) {; 3370 // The library already exist, let's just load it.; 3371 if (loadLib) {; 3372 TNamed *k = new TNamed(library,library);; 3373 Long_t lib_time;; 3374 gSystem->GetPathInfo( library, nullptr, (Long_t*)nullptr, nullptr, &lib_time );; 3375 k->SetUniqueID(lib_time);; 3376 if (!keep) k->SetBit(kMustCleanup);; 3377 fCompiled->Add(k);; 3378 ; 3379 gInterpreter->GetSharedLibDeps(library);; 3380 ; 3381 return LoadLibrary(library);; 3382 }; 3383 else return kTRUE;; 3384 }; 3385 ; 3386 if (!canWrite && recompile) {; 3387 ; 3388 if (mkdirFailed) {; 3389 ::Warning(""ACLiC"",""Could not create the directory: %s"",; 3390 build_loc.Data());; 3391 } else {; 3392 ::Warning(""ACLiC"",""%s is not writable!"",; 3393 build_loc.Data());; 3394 }; 3395 if (emergency_loc == build_dir ) {; 3396 ::Error(""ACLiC"",""%s is the last resort location (i.e. temp location)"",build_loc.Data());; 3397 r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:112748,load,load,112748,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['load']
Performance,"ator=(CachedPyString &&) = delete;; 111 ; 112 ~CachedPyString() { Py_DECREF(fObj); }; 113 ; 114 PyObject *obj() { return fObj; }; 115 ; 116private:; 117 PyObject *fObj = nullptr;; 118};; 119 ; 120PyThreadState *mainThreadState;; 121 ; 122// To acquire the GIL as described here:; 123// https://docs.python.org/3/c-api/init.html#non-python-created-threads; 124class PyGILRAII {; 125 PyGILState_STATE m_GILState;; 126 ; 127public:; 128 PyGILRAII() : m_GILState(PyGILState_Ensure()) {}; 129 ~PyGILRAII() { PyGILState_Release(m_GILState); }; 130};; 131 ; 132} // namespace; 133 ; 134//- static public members ----------------------------------------------------; 135/// Initialization method: setup the python interpreter and load the; 136/// ROOT module.; 137Bool_t TPython::Initialize(); 138{; 139 // Don't initialize Python from two concurrent threads; 140 static std::mutex initMutex;; 141 const std::lock_guard<std::mutex> lock(initMutex);; 142 ; 143 static Bool_t isInitialized = kFALSE;; 144 if (isInitialized); 145 return kTRUE;; 146 ; 147 if (!Py_IsInitialized()) {; 148// this happens if Cling comes in first; 149#if PY_VERSION_HEX < 0x03020000; 150 PyEval_InitThreads();; 151#endif; 152 ; 153// set the command line arguments on python's sys.argv; 154#if PY_VERSION_HEX < 0x03000000; 155 char *argv[] = {const_cast<char *>(""root"")};; 156#else; 157 wchar_t *argv[] = {const_cast<wchar_t *>(L""root"")};; 158#endif; 159 int argc = sizeof(argv) / sizeof(argv[0]);; 160#if PY_VERSION_HEX < 0x030b0000; 161 Py_Initialize();; 162#else; 163 PyStatus status;; 164 PyConfig config;; 165 ; 166 PyConfig_InitPythonConfig(&config);; 167 ; 168 status = PyConfig_SetArgv(&config, argc, argv);; 169 if (PyStatus_Exception(status)) {; 170 PyConfig_Clear(&config);; 171 std::cerr << ""Error when setting command line arguments."" << std::endl;; 172 return kFALSE;; 173 }; 174 ; 175 status = Py_InitializeFromConfig(&config);; 176 if (PyStatus_Exception(status)) {; 177 PyConfig_Clear(&config);; 178 std::cerr << ""E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPython_8cxx_source.html:5135,concurren,concurrent,5135,doc/master/TPython_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html,1,['concurren'],['concurrent']
Performance,"atrices. The requisite is that the matrix data are stored, for example in the case of a Lorentz rotation, from (0,0) thru (3,3); TMatrixD(4,4) m;; LorentzRotation r(m); //create Lorentz r; 13.12.6.2 Connection to Other Vector Classes; The 3D and 4D vectors of the GenVector package can be constructed and assigned from any vector which satisfies the following requisites:. for 3D vectors implementing the x(), y() and z() methods; for Lorentz vectors implementing the x(), y(), z() and t() methods. CLHEP::Hep3Vector hv;; XYZVector v1(hv); //create 3D vector from; //CLHEP 3D Vector; HepGeom::Point3D hp;; XYZPoint p1(hp); //create a 3D p; 13.13 Linear Algebra: SMatrix Package; The ROOT Linear algebra package is documented in a separate chapter (see “Linear Algebra in ROOT”). SMatrix is a C++ package, for high performance vector and matrix computations. It has been introduced in ROOT v5.08. It is optimized for describing small matrices and vectors and It can be used only in problems when the size of the matrices is known at compile time, like in the tracking reconstruction of physics experiments. It is based on a C++ technique, called expression templates, to achieve an high level optimization. The C++ templates can be used to implement vector and matrix expressions such that these expressions can be transformed at compile time to code which is equivalent to hand optimized code in a low-level language like FORTRAN or C (see for example T. Veldhuizen, Expression Templates, C++ Report, 1995).; The SMatrix has been developed initially by T. Glebe in Max-Planck-Institut, Heidelberg, as part of the HeraB analysis framework. A subset of the original package has been now incorporated in the ROOT distribution, with the aim to provide a stand-alone and high performance matrix package. The API of the current package differs from the original one, in order to be compliant to the ROOT coding conventions.; SMatrix contains the generic ROOT::Math::SMatrix and ROOT::Math::SVector classes ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:747950,optimiz,optimized,747950,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['optimiz'],['optimized']
Performance,"atrix (double *hMat) const;  Fill the passed array with the Hessian matrix elements The Hessian matrix is the matrix of the second derivatives and is the inverse of the covariance matrix If the variable is fixed or const the values for that variables are zero. ;  ; virtual bool GetMinosError (unsigned int ivar, double &errLow, double &errUp, int option=0);  minos error for variable i, return false if Minos failed or not supported and the lower and upper errors are returned in errLow and errUp An extra flag specifies if only the lower (option=-1) or the upper (option=+1) error calculation is run ;  ; virtual double GlobalCC (unsigned int ivar) const;  return global correlation coefficient for variable i This is a number between zero and one which gives the correlation between the i-th parameter and that linear combination of all other parameters which is most strongly correlated with i. ;  ; virtual bool Hesse ();  perform a full calculation of the Hessian matrix for error calculation ;  ; bool IsValidError () const;  return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit) ;  ; unsigned int MaxFunctionCalls () const;  max number of function calls ;  ; unsigned int MaxIterations () const;  max iterations ;  ; virtual const double * MinGradient () const;  return pointer to gradient values at the minimum ;  ; virtual int MinosStatus () const;  status code of Minos (to be re-implemented by the minimizers supporting Minos) ;  ; virtual unsigned int NCalls () const;  number of function calls to reach the minimum ;  ; virtual unsigned int NIterations () const;  number of iterations to reach the minimum ;  ; Minimizer & operator= (Minimizer &&)=delete;  ; Minimizer & operator= (Minimizer const &)=delete;  ; virtual MinimizerOptions Options () const;  retrieve the minimizer options (implement derived class if needed) ;  ; double Precision () const;  precision of minimizer in the evaluation of the objective function ( a value <=0 correspon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1BasicMinimizer.html:6995,perform,perform,6995,doc/master/classROOT_1_1Math_1_1BasicMinimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1BasicMinimizer.html,2,['perform'],"['perform', 'performed']"
Performance,"atrix (double *hMat) const;  Fill the passed array with the Hessian matrix elements The Hessian matrix is the matrix of the second derivatives and is the inverse of the covariance matrix If the variable is fixed or const the values for that variables are zero. ;  ; virtual bool GetMinosError (unsigned int ivar, double &errLow, double &errUp, int option=0);  minos error for variable i, return false if Minos failed or not supported and the lower and upper errors are returned in errLow and errUp An extra flag specifies if only the lower (option=-1) or the upper (option=+1) error calculation is run ;  ; virtual double GlobalCC (unsigned int ivar) const;  return global correlation coefficient for variable i This is a number between zero and one which gives the correlation between the i-th parameter and that linear combination of all other parameters which is most strongly correlated with i. ;  ; virtual bool Hesse ();  perform a full calculation of the Hessian matrix for error calculation ;  ; bool IsValidError () const;  return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit) ;  ; unsigned int MaxFunctionCalls () const;  max number of function calls ;  ; unsigned int MaxIterations () const;  max iterations ;  ; virtual const double * MinGradient () const;  return pointer to gradient values at the minimum ;  ; virtual int MinosStatus () const;  status code of Minos (to be re-implemented by the minimizers supporting Minos) ;  ; virtual unsigned int NIterations () const;  number of iterations to reach the minimum ;  ; Minimizer & operator= (Minimizer &&)=delete;  ; Minimizer & operator= (Minimizer const &)=delete;  ; virtual MinimizerOptions Options () const;  retrieve the minimizer options (implement derived class if needed) ;  ; double Precision () const;  precision of minimizer in the evaluation of the objective function ( a value <=0 corresponds to the let the minimizer choose its default one) ;  ; int PrintLevel () const;  minimiz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLSimAnMinimizer.html:8386,perform,perform,8386,doc/master/classROOT_1_1Math_1_1GSLSimAnMinimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLSimAnMinimizer.html,4,['perform'],"['perform', 'performed']"
Performance,"atrix (double *hMat) const;  Fill the passed array with the Hessian matrix elements The Hessian matrix is the matrix of the second derivatives and is the inverse of the covariance matrix If the variable is fixed or const the values for that variables are zero. ;  ; virtual bool GetMinosError (unsigned int ivar, double &errLow, double &errUp, int option=0);  minos error for variable i, return false if Minos failed or not supported and the lower and upper errors are returned in errLow and errUp An extra flag specifies if only the lower (option=-1) or the upper (option=+1) error calculation is run ;  ; virtual double GlobalCC (unsigned int ivar) const;  return global correlation coefficient for variable i This is a number between zero and one which gives the correlation between the i-th parameter and that linear combination of all other parameters which is most strongly correlated with i. ;  ; virtual bool Hesse ();  perform a full calculation of the Hessian matrix for error calculation ;  ; bool IsValidError () const;  return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit) ;  ; unsigned int MaxFunctionCalls () const;  max number of function calls ;  ; unsigned int MaxIterations () const;  max iterations ;  ; virtual int MinosStatus () const;  status code of Minos (to be re-implemented by the minimizers supporting Minos) ;  ; virtual unsigned int NIterations () const;  number of iterations to reach the minimum ;  ; Minimizer & operator= (Minimizer &&)=delete;  ; Minimizer & operator= (Minimizer const &)=delete;  ; virtual MinimizerOptions Options () const;  retrieve the minimizer options (implement derived class if needed) ;  ; double Precision () const;  precision of minimizer in the evaluation of the objective function ( a value <=0 corresponds to the let the minimizer choose its default one) ;  ; int PrintLevel () const;  minimizer configuration parameters ;  ; virtual void PrintResults ();  return reference to the objective fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMinimizer.html:7632,perform,perform,7632,doc/master/classROOT_1_1Math_1_1GSLMinimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMinimizer.html,4,['perform'],"['perform', 'performed']"
Performance,"atrix* modviewMat = 0) const; virtual Bool_tZoom(Int_t delta, Bool_t mod1, Bool_t mod2). protected:. voidUpdateCache() const. private:. TGLBoundingBoxFrustum(Bool_t asBox = kTRUE) const; TGLCamera&operator=(const TGLCamera&). Data Members; public:. enum EFrustumPlane { kNear; kLeft; kRight; kTop; kBottom; kFar; kPlanesPerFrustum; };. protected:. Bool_tfCacheDirty! cached items dirty?; TGLMatrixfCamBase! tranformation to center and rotation from up to x vector; TGLMatrixfCamTrans! transformation relative to fCamTrans; TGLVector3*fCenter! current camera center; TGLMatrixfClipM! object space clip matrix (cached); TGLVector3fDefCenter! deafult camera center; Double_tfDollyDefault! default distnce from viewing centre; Double_tfDollyDistance! unit distance for camera movement in fwd/bck direction; TGLVector3fExtCenter! external camera center; Bool_tfExternalCenter! use external center insead of scene center; TGLVector3fFDCenter! fixed deafult camera center; Double_tfFarClip! last applied far-clip; Bool_tfFixDefCenter! use fixed default center; TGLPlanefFrustumPlanes[6]! frustum planes (cached); TGLBoundingBoxfInterestBox! the interest box - created in UpdateInterest(); Double_tfLargestSeen! largest box diagonal seen in OfInterest() - used when; TGLMatrixfLastNoPickProjM! no-pick projection matrix (cached); TGLMatrixfModVM! modelView matrix (cached); Double_tfNearClip! last applied near-clip; TGLMatrixfProjM! projection matrix (cached); UInt_tfTimeStamp! timestamp; Float_tfVAxisMinAngle! minimal allowed angle between up and fCamTrans Z vector; TGLRectfViewport! viewport (GL coords - origin bottom left); static UInt_tfgDollyDeltaSens. private:. TGLBoundingBoxfInterestFrustum! frustum basis of current interest box - NOT a true BB! (DEBUG); TGLBoundingBoxfInterestFrustumAsBox! frustum basis (as box) of current interest box (DEBUG); TGLBoundingBoxfPreviousInterestBox! previous interest box (DEBUG); static const Double_tfgInterestBoxExpansion! expansion c.f. aligned current frus",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLCamera.html:4933,cache,cached,4933,root/html528/TGLCamera.html,https://root.cern,https://root.cern/root/html528/TGLCamera.html,18,['cache'],['cached']
Performance,"atrixT<Element> c(a, TMatrixT::kMult, b);; 277/// Supported operations are: kMult (a*b), kTransposeMult (a'*b), kInvMult (a^(-1)*b); 278/// Whenever kInvMult is invoked and b is not squared, additional memory is allocated for a^(-1); 279 ; 280template <class Element>; 281TMatrixT<Element>::TMatrixT(const TMatrixTSym<Element> &a, EMatrixCreatorsOp2 op, const TMatrixT<Element> &b); 282{; 283 R__ASSERT(a.IsValid());; 284 R__ASSERT(b.IsValid());; 285 ; 286 switch (op) {; 287 case kMult:; 288 Allocate(a.GetNrows(), b.GetNcols(), a.GetRowLwb(), b.GetColLwb(), 1);; 289 Mult(a, b);; 290 break;; 291 ; 292 case kTransposeMult:; 293 Allocate(a.GetNcols(), b.GetNcols(), a.GetColLwb(), b.GetColLwb(), 1);; 294 TMult(a, b);; 295 break;; 296 ; 297 case kMultTranspose:; 298 Allocate(a.GetNrows(), b.GetNrows(), a.GetRowLwb(), b.GetRowLwb(), 1);; 299 MultT(a, b);; 300 break;; 301 ; 302 case kInvMult: {; 303 Allocate(a.GetNrows(), b.GetNcols(), a.GetRowLwb(), b.GetColLwb(), 1);; 304 // if size(a) == size(b), perform in place computation; 305 if (a.GetNrows() == b.GetNcols()) {; 306 *this = a;; 307 const Element oldTol = this->SetTol(std::numeric_limits<Element>::min());; 308 this->Invert();; 309 this->SetTol(oldTol);; 310 *this *= b;; 311 } else {; 312 TMatrixTSym<Element> ainv = a;; 313 const Element oldTol = ainv.SetTol(std::numeric_limits<Element>::min());; 314 ainv.Invert();; 315 ainv.SetTol(oldTol);; 316 Mult(ainv, b);; 317 }; 318 break;; 319 }; 320 ; 321 case kPlus: {; 322 Allocate(a.GetNrows(), a.GetNcols(), a.GetRowLwb(), a.GetColLwb(), 1);; 323 Plus(a, b);; 324 break;; 325 }; 326 ; 327 case kMinus: {; 328 Allocate(a.GetNrows(), a.GetNcols(), a.GetRowLwb(), a.GetColLwb(), 1);; 329 Minus(a, b);; 330 break;; 331 }; 332 ; 333 default: Error(""TMatrixT(EMatrixCreatorOp2)"", ""operation %d not yet implemented"", op);; 334 }; 335}; 336 ; 337////////////////////////////////////////////////////////////////////////////////; 338/// Constructor of matrix applying a specific operation to two p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMatrixT_8cxx_source.html:10783,perform,perform,10783,doc/master/TMatrixT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html,1,['perform'],['perform']
Performance,"atstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TSystem::GetFromPipevirtual TString GetFromPipe(const char *command)Execute command and return output in TString.Definition TSystem.cxx:680; TTextBase class for several text objects.Definition TText.h:22; TText::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute distance from point px,py to a string.Definition TText.cxx:144; TText::Paintvoid Paint(Option_t *option="""") overridePaint this text with its current attributes.Definition TText.cxx:687; TText::SetNDCvirtual void SetNDC(Bool_t isNDC=kTRUE)Set NDC mode on if isNDC = kTRUE, off otherwise.Definition TText.cxx:823; TTimeStampThe TTimeStamp encapsulates seconds and ns since EPOCH.Definition TTimeStamp.h:45; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeCache::GetCachedBranchesconst TObjArray * GetCachedBranches() constDefinition TTreeCache.h:139; TTreePerfStatsTTree I/O performance measurement.Definition TTreePerfStats.h:38; TTreePerfStats::fGraphIOTGraphErrors * fGraphIOPointer to the graph with IO data.Definition TTreePerfStats.h:69; TTreePerfStats::fUnzipInputSizeLong64_t fUnzipInputSizeCompressed bytes seen by the decompressor.Definition TTreePerfStats.h:62; TTreePerfStats::fNameTString fNameName of this TTreePerfStats.Definition TTreePerfStats.h:65; TTreePerfStats::fNleavesInt_t fNleavesNumber of leaves in the tree.Definition TTreePerfStats.h:52; TTreePerfStats::Browsevoid Browse(TBrowser *b) overrideBrowse.Definition TTreePerfStats.cxx:208; TTreePerfStats::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideReturn distance to one of the objects in the TTreePerfStats.Definition TTreePerfStats.cxx:277; TTreePerfStats::fRealNormDouble_t fRealNormRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:38738,cache,cache,38738,doc/master/TTreePerfStats_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html,1,['cache'],['cache']
Performance,"attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooResolutionModel.html:42351,cache,cache,42351,root/html534/RooResolutionModel.html,https://root.cern,https://root.cern/root/html534/RooResolutionModel.html,2,['cache'],['cache']
Performance,"atus of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooSetProxy_varSetNot used anymore?; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooConvCoefVar.html:31959,cache,cache,31959,root/html526/RooConvCoefVar.html,https://root.cern,https://root.cern/root/html526/RooConvCoefVar.html,2,['cache'],['cache']
Performance,"atusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Int_tfDebugLocal verbosity level; TStringfDirNameThe name of the subdir with the perfomance tree; TH1F*fEventsEvent distribution per worker; TH1F*fEvtRateEvent processing rate vs query time; Double_tfEvtRateAvgAverage event processing rate; Double_tfEvtRateAvgMaxMax running event processing rate; Double_tfEvtRateMaxMax event processing rate per packet; TH1F*fEvtRateRunEvent processing rate running avg vs query time; TFile*fFileThe open performance file; TStringfFileResultFile where to save basics of a run when requested; TSortedListfFilesInfoSorted list of files info; Float_tfInitTimeEnd of initialization time for this query; Double_tfLatencyMaxMax retrieval latency per packet; TH1F*fMBRateByte processing rate vs query time; Double_tfMBRateAvgAverage MB processing rate; Double_tfMBRateAvgMaxMax running MB processing rate; Double_tfMBRateMaxMax MB processing rate per packet; TH1F*fMBRateRunByte processing rate running avg vs query time; Float_tfMaxTimeMax time for this query (slowest worker); Float_tfMergeTimeBegin of merging time for this query; TH1F*fPacketsPacket distribution per worker; Bool_tfSaveResultWhether to save the results of a run; TTree*fTreeThe performance tree; TStringfTreeNameThe name of the performance tree; TSortedListfWrksInfoSorted list of workers info; static Bool_tfgDebugGlobal verbosity on/off. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t CompareOrd(const char* ord1, const char* ord2). void FillFileDist(TH1F* hf, TH1F* hb, TH2F* hx, Bool_t wdet = kFALSE). void FillFileDistOneSrv(TH1F* hx, Bool_t wdet = kFALSE). void FillWrkInfo(Bool_t force = kFALSE). void FillFileInf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPerfAnalysis.html:7475,perform,performance,7475,root/html534/TProofPerfAnalysis.html,https://root.cern,https://root.cern/root/html534/TProofPerfAnalysis.html,4,"['latency', 'perform']","['latency', 'performance']"
Performance,"atusBitsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*fTableHashtable used for quick lookup of objects; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashList object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehash is the value at which a rehash will be triggered. I.e. when the; average size of the linked lists at a slot becomes longer than rehash; then the hashtable will be resized and refilled to reduce the collision; rate to about 1. The higher the collision rate, i.e. the longer the; linked lists, the longer lookup will take. If rehash=0 the table will; NOT automatically be rehashed. Use R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THashList.html:10682,cache,cache,10682,root/html602/THashList.html,https://root.cern,https://root.cern/root/html602/THashList.html,2,['cache'],['cache']
Performance,"atusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; RooArgSetRooAbsDataStore::_cachedVars; Int_t_curIndex! Index associated with current event; RooAbsDataStore*_curStore! Datastore associated with current event; map<Int_t,RooAbsDataStore*>_dataMap; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; RooCategory*_indexCat; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; Bool_t_ownComps!; RooArgSetRooAbsDataStore::_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCompositeDataStore(). RooCompositeDataStore(const char* name, const char* title, const RooArgSet& vars, RooCategory& indexCat, map<string,RooAbsDataStore*> inputData); Convert map by label to map by index for more efficient internal use. RooCompositeDataStore(const RooCompositeDataStore& other, const char* newname = 0); Convert map by label to map by index for more efficient internal use. RooCompositeDataStore(const RooCompositeDataStore& other, const RooArgSet& vars, const char* newname = 0); Update index category pointer, if it is contained in input argument vars. ~RooCompositeD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCompositeDataStore.html:10247,cache,cached,10247,root/html602/RooCompositeDataStore.html,https://root.cern,https://root.cern/root/html602/RooCompositeDataStore.html,4,"['cache', 'load']","['cached', 'loading']"
Performance,"ault is copy everything. Returns kTRUE in case file needs to be send, returns kFALSE in case file is already on remote node. . Definition at line 6799 of file TProof.cxx. ◆ Class(). static TClass * TProof::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TProof::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TProof::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 1073 of file TProof.h. ◆ CleanGDirectory(). void TProof::CleanGDirectory ; (; TList * ; ol). private . Remove links to objects in list 'ol' from gDirectory. ; Definition at line 3046 of file TProof.cxx. ◆ CleanupSession(). Int_t TProof::CleanupSession ; (; const char * ; sessiontag). Send cleanup request for the session specified by tag. ; Definition at line 6092 of file TProof.cxx. ◆ ClearCache(). void TProof::ClearCache ; (; const char * ; file = 0). virtual . Remove file from all file caches. ; If file is 0 or """" or ""*"", remove all the files ; Reimplemented in TProofLite.; Definition at line 7714 of file TProof.cxx. ◆ ClearData(). void TProof::ClearData ; (; UInt_t ; what = kUnregistered, . const char * ; dsname = 0 . ). Remove files for the data directory. ; The option 'what' can take the values: kPurge remove all files and directories under '~/data' kUnregistered remove only files not in registered datasets (default) kDataset remove files belonging to dataset 'dsname' User is prompt for confirmation, unless kForceClear is ORed with the option ; Definition at line 7412 of file TProof.cxx. ◆ ClearDataProgress(). void TProof::ClearDataProgress ; (; Int_t ; r, . Int_t ; t . ). private . Progress bar for clear data. ; Definition at line 7670 of file TProof.cxx. ◆ ClearDataSetCache(). void TProof::ClearDataSetCache ; (; const char * ; dataset = 0). virtual . Clear the content of the dataset cache, if any (matching 'dataset', if defined). ; Reimplemented in TPr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:74407,cache,caches,74407,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['cache'],['caches']
Performance,"ault transformer; static TVirtualFFT*TVirtualFFT::fgFFTcurrent transformer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFFTReal(); default. TFFTReal(Int_t n, Bool_t inPlace = kFALSE); For 1d transforms; n here is the physical size of the transform (see FFTW manual for more details). TFFTReal(Int_t ndim, Int_t* n, Bool_t inPlace = kFALSE); For multidimensional transforms; 1st parameter is the # of dimensions,; 2nd is the sizes (physical) of the transform in each dimension. ~TFFTReal(); clean-up. void Init(Option_t* flags, Int_t sign, const Int_t* kind); Creates the fftw-plan. NOTE: input and output arrays are overwritten during initialisation,; so don't set any points, before running this function!!!!!. 1st parameter:; Possible flag_options:; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performance; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type.; 2nd parameter is dummy and doesn't need to be specified; 3rd parameter- transform kind for each dimension; 4 different kinds of sine and cosine transforms are available; DCT-I - kind=0; DCT-II - kind=1; DCT-III - kind=2; DCT-IV - kind=3; DST-I - kind=4; DST-II - kind=5; DSTIII - kind=6; DSTIV - kind=7. void Transform(); Computes the transform, specified in Init() function. Option_t * GetType() const; Returns the type of the transform. void GetPoints(Double_t* data, Bool_t fromInput = kFALSE) const; Copies the output (or input) points into the provided array, that should; be big enough. Double_t GetPointReal(Int_t ipoint, Bool_t fromInput = kFALSE) const; For 1d tranforms. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFFTReal.html:9772,perform,performance,9772,root/html528/TFFTReal.html,https://root.cern,https://root.cern/root/html528/TFFTReal.html,6,['perform'],['performance']
Performance,"ault value is 5.; The default value for all axis can be set with the static function TGaxis::SetMaxDigits. ; Definition at line 268 of file TAttAxis.cxx. ◆ SetNdivisions() [1/2]. void TAttAxis::SetNdivisions ; (; Int_t ; n1, . Int_t ; n2, . Int_t ; n3, . Bool_t ; optim = kTRUE . ). virtual . Set the number of divisions for this axis using one int per division level. ; Definition at line 247 of file TAttAxis.cxx. ◆ SetNdivisions() [2/2]. void TAttAxis::SetNdivisions ; (; Int_t ; n = 510, . Bool_t ; optim = kTRUE . ). virtual . Set the number of divisions for this axis. . if optim = kTRUE (default), the number of divisions will be optimized around the specified value.; if optim = kFALSE, or n < 0, the axis will be forced to use exactly n divisions. n = n1 + 100*n2 + 10000*n3; nconst Int_t nDefinition legend1.C:16; Where n1 is the number of primary divisions, n2 is the number of second order divisions and n3 is the number of third order divisions. If the number of divisions is ""optimized"" (see above) n1, n2, n3 are maximum values.; Examples:. ndiv = 0: no tick marks.; ndiv = 2: 2 divisions, one tick mark in the middle of the axis.; ndiv = 510: 10 primary divisions, 5 secondary divisions.; ndiv = -10: exactly 10 primary divisions. . Definition at line 233 of file TAttAxis.cxx. ◆ SetTickLength(). void TAttAxis::SetTickLength ; (; Float_t ; length = 0.03). virtual . Set tick mark length. ; The length is expressed in per cent of the pad width. ; Definition at line 284 of file TAttAxis.cxx. ◆ SetTickSize(). virtual void TAttAxis::SetTickSize ; (; Float_t ; size = 0.03). inlinevirtual . Definition at line 59 of file TAttAxis.h. ◆ SetTitleColor(). void TAttAxis::SetTitleColor ; (; Color_t ; color = 1). virtual . Set color of axis title. ; Definition at line 318 of file TAttAxis.cxx. ◆ SetTitleFont(). void TAttAxis::SetTitleFont ; (; Style_t ; font = 62). virtual . Set the title font. ; Definition at line 327 of file TAttAxis.cxx. ◆ SetTitleOffset(). void TAttAxis::SetTitleOffs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAttAxis.html:9994,optimiz,optimized,9994,doc/master/classTAttAxis.html,https://root.cern,https://root.cern/doc/master/classTAttAxis.html,1,['optimiz'],['optimized']
Performance,"ault), it is then optionally compressed; 4566/// and written to disk (this operation is also called committing or; 4567/// 'flushing' the basket). The committed baskets are then; 4568/// immediately removed from memory.; 4569///; 4570/// The function returns the number of bytes committed to the; 4571/// individual branches.; 4572///; 4573/// If a write error occurs, the number of bytes returned is -1.; 4574///; 4575/// If no data are written, because, e.g., the branch is disabled,; 4576/// the number of bytes returned is 0.; 4577///; 4578/// __The baskets are flushed and the Tree header saved at regular intervals__; 4579///; 4580/// At regular intervals, when the amount of data written so far is; 4581/// greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; 4582/// This makes future reading faster as it guarantees that baskets belonging to nearby; 4583/// entries will be on the same disk region.; 4584/// When the first call to flush the baskets happen, we also take this opportunity; 4585/// to optimize the baskets buffers.; 4586/// We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; 4587/// In this case we also write the Tree header. This makes the Tree recoverable up to this point; 4588/// in case the program writing the Tree crashes.; 4589/// The decisions to FlushBaskets and Auto Save can be made based either on the number; 4590/// of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; 4591/// written (fAutoFlush and fAutoSave positive).; 4592/// Note that the user can decide to call FlushBaskets and AutoSave in her event loop; 4593/// base on the number of events written instead of the number of bytes written.; 4594///; 4595/// \note Calling `TTree::FlushBaskets` too often increases the IO time.; 4596///; 4597/// \note Calling `TTree::AutoSave` too often increases the IO time and also the; 4598/// file size.; 4599///; 4600/// \note This method calls `TTree::ChangeFile` wh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:186005,optimiz,optimize,186005,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['optimiz'],['optimize']
Performance,"aus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits are set. . ""C"" In case of linear fitting, do no calculate the chisquare (saves CPU time). . ""G"" Uses the gradient implemented in TF1::GradientPar for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function. . ""EX0"" When fitting a TGraphErrors or TGraphAsymErrors do not consider errors in the X coordinates . ""ROB"" In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points ""ROB=0.x"" - compute the LTS regression coefficients, using 0.x as a fraction of good points . This function is used for fitting also the derived TGraph classes such as TGraphErrors or TGraphAsymmErrors. See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; The fitting of the TGraph, i.e simple data points without any error associated, is performed using the un-weighted least-square (chi-square) method. TGraphErrors fit:; In case of a TGraphErrors or TGraphAsymmErrors object, when x errors are present, the error along x, is projected along the y-direction by calculating the function at the points x-ex_low and x+ex_high, where ex_low and ex_high are the corresponding lower and upper error in x. The chi-square is then computed as the sum of the quantity below at each data point:. \[; \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; \]. where x and y are the point coordinates, and ‘f’(x)is the derivative of the functionf(x)`.; In case of asymmetric errors, if the function lies below (above) the data point, ey is ey_low (ey_high).; The approach used to approximate the uncertainty in y because of the errors in x is to make it equal the error in x times the slope of the line. This approach is called ""effective variance method"" and the implementation is provided in the function FitUtil::EvaluateChi2Effective. Linear fitt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph.html:49966,perform,performed,49966,doc/master/classTGraph.html,https://root.cern,https://root.cern/doc/master/classTGraph.html,1,['perform'],['performed']
Performance,automatically created; Bool_tTFileCacheRead::fBIsSorted; Bool_tTFileCacheRead::fBIsTransferred; Int_t*TFileCacheRead::fBLen; Int_tTFileCacheRead::fBNb; Int_tTFileCacheRead::fBNseek; Int_tTFileCacheRead::fBNtot; Long64_t*TFileCacheRead::fBPos; Long64_t*TFileCacheRead::fBSeek; Int_t*TFileCacheRead::fBSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCacheUnzip.html:11535,cache,cache,11535,root/html534/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html,1,['cache'],['cache']
Performance,"automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:4705,optimiz,optimization,4705,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['optimiz'],['optimization']
Performance,"ave != 0) {; 4689 // Is it time to flush or autosave baskets?; 4690 if (fFlushedBytes == 0) {; 4691 // If fFlushedBytes == 0, it means we never flushed or saved, so; 4692 // we need to check if it's time to do it and recompute the values; 4693 // of fAutoFlush and fAutoSave in terms of the number of entries.; 4694 // Decision can be based initially either on the number of bytes; 4695 // or the number of entries written.; 4696 Long64_t zipBytes = GetZipBytes();; 4697 ; 4698 if (fAutoFlush); 4699 autoFlush = fAutoFlush < 0 ? (zipBytes > -fAutoFlush) : fEntries % fAutoFlush == 0;; 4700 ; 4701 if (fAutoSave); 4702 autoSave = fAutoSave < 0 ? (zipBytes > -fAutoSave) : fEntries % fAutoSave == 0;; 4703 ; 4704 if (autoFlush || autoSave) {; 4705 // First call FlushBasket to make sure that fTotBytes is up to date.; 4706 FlushBasketsImpl();; 4707 autoFlush = false; // avoid auto flushing again later; 4708 ; 4709 // When we are in one-basket-per-cluster mode, there is no need to optimize basket:; 4710 // they will automatically grow to the size needed for an event cluster (with the basket; 4711 // shrinking preventing them from growing too much larger than the actually-used space).; 4712 if (!TestBit(TTree::kOnlyFlushAtCluster)) {; 4713 OptimizeBaskets(GetTotBytes(), 1, """");; 4714 if (gDebug > 0); 4715 Info(""TTree::Fill"", ""OptimizeBaskets called at entry %lld, fZipBytes=%lld, fFlushedBytes=%lld\n"",; 4716 fEntries, GetZipBytes(), fFlushedBytes);; 4717 }; 4718 fFlushedBytes = GetZipBytes();; 4719 fAutoFlush = fEntries; // Use test on entries rather than bytes; 4720 ; 4721 // subsequently in run; 4722 if (fAutoSave < 0) {; 4723 // Set fAutoSave to the largest integer multiple of; 4724 // fAutoFlush events such that fAutoSave*fFlushedBytes; 4725 // < (minus the input value of fAutoSave); 4726 Long64_t totBytes = GetTotBytes();; 4727 if (zipBytes != 0) {; 4728 fAutoSave = TMath::Max(fAutoFlush, fEntries * ((-fAutoSave / zipBytes) / fEntries));; 4729 } else if (totBytes != 0) {; 4730 f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:190705,optimiz,optimize,190705,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['optimiz'],['optimize']
Performance,"ave As… dialog shows up.; 2.3.7 Printing the Canvas; The Print command in the canvas File menu pops-up a print dialog where the user can specify a preferred print command and the printer name. Both print parameters can be set via the new Print.Command and Print.Printer rootrc resources as follows:; # Printer settings.; WinNT.*.Print.Command: AcroRd32.exe; Unix.*.Print.Command: xprint -P%p %f; Print.Printer: 32-rb205-hp; Print.Directory: .; If the %p and %f are specified as a part of the print command, they will be replaced by the specified printer name and the file name. All other parameters will be kept as they are written. A print button is available in the canvas toolbar (activated via View menu/Toolbar).; 2.4 The ROOT Command Line; We have briefly touched on how to use the command line. There are different types of commands. Cling commands start with “.”. root[] .? //this command will list all the Cling commands; root[] .L <filename> //load [filename]; root[] .x <filename> //load and execute [filename]. SHELL commands start with “.!” for example:. root[] .! ls. C++ commands follow C++ syntax (almost). root[] TBrowser *b = new TBrowser(); 2.4.1 Multi-line Commands; You can use the command line to execute multi-line commands. To begin a multi-line command you must type a single left curly bracket {, and to end it you must type a single right curly bracket }. For example:; root[] {; end with '}'> Int_t j = 0;; end with '}'> for (Int_t i = 0; i < 3; i++); end with '}'> {; end with '}'> j= j + i;; end with '}'> cout << ""i = "" << i << "", j = "" << j << endl;; end with '}'> }; end with '}'> }; i = 0, j = 0; i = 1, j = 1; i = 2, j = 3; It is more convenient to edit a script than the command line, and if your multi line commands are getting unmanageable, you may want to start with a script instead.; 2.4.2 Cling Extensions; We should say that some things are not standard C++. The Cling interpreter has several extensions. See “ROOT/Cling Extensions to C++”.; 2.4.3 Helpful Hi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:53538,load,load,53538,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['load']
Performance,"ave a canvas into file.xml file format instead of file.root. XML files do not have any advantages compared to the normal ROOT files, except that the information in these files can be edited via a normal editor. The main motivation for this new format is to facilitate the communication with other non ROOT applications. Currently writing and reading XML files is limited to ROOT applications. It is our intention to develop a simple reader independent of the ROOT libraries that could be used as an example for real applications.; The XML format should be used only for small data volumes, typically histogram files, pictures, geometries, calibrations. The XML file is built in memory before being dumped to disk. Like for normal ROOT files, XML files use the same I/O mechanism exploiting the ROOT/Cling dictionary. Any class having a dictionary can be saved in XML format. This first implementation does not support subdirectories or trees.; The shared library libRXML.so may be loaded dynamically via gSystem->Load(""libRXML""). This library is also automatically loaded by the plug-in manager as soon a XML file is created. To create an XTM file, simply specify a filename with an .xml extension when calling TFile::Open. TFile::Open will recognize that you are trying to open an XML file and return a TXMLFile object. When a XML file is open in write mode, one can use the normal TObject::Write to write an object in the file.; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2); h->FillRandom(""gaus"");; h->Write();; delete f;; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*)f->Get(""h"");; h->Draw();; The canvas can be saved as a XML file format via File menu / Save or Save As menu entries. One can do also:; canvas->Print(""Example.xml"");; 12 Trees; 12.1 Why Should You Use a Tree?; In the “Input/Output” chapter, we saw how obje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:518448,load,loaded,518448,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loaded']
Performance,"ave a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. NOTE: the action specifies how to behave when detaching a cache from the; the TFile. If set to (default) kDisconnect, the contents of the cache; will be flushed when it is removed from the file, and it will disconnect; the cache object from the file. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& ); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (bytes 1->fBEGIN). Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0) const; One can not save a const TDirectory object. Bool_t WriteBuffer(const char* buf, Int_t len); Write a buffer to the file. This is the basic low level write operation.; Retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFile.html:41624,cache,cache,41624,root/html602/TFile.html,https://root.cern,https://root.cern/root/html602/TFile.html,2,['cache'],['cache']
Performance,"ave a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. NOTE: the action specifies how to behave when detaching a cache from the; the TFile. If set to (default) kDisconnect, the contents of the cache; will be flushed when it is removed from the file, and it will disconnect; the cache object from the file. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& ); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFile.html:40795,cache,cache,40795,root/html534/TFile.html,https://root.cern,https://root.cern/root/html534/TFile.html,1,['cache'],['cache']
Performance,"ave the histogram as ""hsqrt"" in the current; directory. See also TTree::UnbinnedFit. Return status. The function returns the status of the histogram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null is the fit is OK). Int_t FlushBaskets() const; Write to disk all the basket that have not yet been individually written. Return the number of bytes written or -1 in case of write error. const char* GetAlias(const char* aliasName) const; Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); Return pointer to the branch with the given name in this tree or its friends. Bool_t GetBranchStatus(const char* branchname) const; Return status of branch with name branchname.; 0 if branch is not activated; 1 if branch is activated. Int_t GetBranchStyle(); Static function returning the current branch style.; style = 0 old Branch; style = 1 new Bronch. Long64_t GetCacheAutoSize(Bool_t withDefault = kFALSE) const; Used for automatic sizing of the cache.; Estimates a suitable size for the tree cache based on AutoFlush.; A cache sizing factor is taken from the configuration. If this yields zero; and withDefault is true the historical algoirthm for default size is used. TFile* GetCurrentFile() const; Return pointer to the current file. Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEntries) for; additional option.; If SetEventList was used on the TTree or TChain, only that subset; of entries will be considered. Long64_t GetEntriesFriend() const; Return pointer to the 1st Leaf named name in any Branch of this Tree or; any branch in the list of friend trees. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:93754,cache,cache,93754,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['cache'],['cache']
Performance,"ave. ;  ; void StoreOutput (TList *out) override;  Store received output list. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProofPlayer;  TProofPlayer (TProof *proof=0);  Default ctor. ;  ;  ~TProofPlayer () override;  Destructor. ;  ; void AddEventsProcessed (Long64_t ev) override;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name accordingly. ;  ; Long64_t GetEventsProcessed () const override;  ; EExitStatus GetExitStatus () const override;  ; TList * GetInputList () const override;  ; Int_t GetLearnEntries () override;  Return the number of entries in the learning phase. ;  ; TList * GetListOfResults () const override;  ; TObject * GetOutput (const char *name) const override;  Get output object by name. ;  ; TList * GetOutputList () const override;  Get output list. ;  ; TProofProgressStatus * GetProgressStatus () const override;  ; TQueryResult * GetQueryResult (const char *ref) override;  Get query result instances referenced 'ref' from the list of results. ;  ; void HandleGetTreeHeader (TMessage *mess) override;  Hand",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:5631,cache,cache,5631,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,2,['cache'],['cache']
Performance,"aveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsCachedReal::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsCachedReal::setInterpolationOrder(Int_t order); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsSelfCachedReal.html:24845,cache,cache,24845,root/html534/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsSelfCachedReal.html,9,['cache'],['cache']
Performance,"aveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetCacheAlpha(Bool_t flag); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsCachedPdf::setInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooIntegralMorph.html:31613,cache,cache,31613,root/html532/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html532/RooIntegralMorph.html,1,['cache'],['cache']
Performance,"avePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TTreePerfStats.cxx:657; TTreePerfStats::Classstatic TClass * Class(); TTreePerfStats::PrintBasketInfovoid PrintBasketInfo(Option_t *option="""") const overridePrint the TTree basket information.Definition TTreePerfStats.cxx:581; TTreePerfStats::Drawvoid Draw(Option_t *option="""") overrideDraw the TTree I/O perf graph.Definition TTreePerfStats.cxx:250; TTreePerfStats::fFileTFile * fFile! Pointer to the file containing the TreeDefinition TTreePerfStats.h:67; TTreePerfStats::GetHostInfoconst char * GetHostInfo() constDefinition TTreePerfStats.h:101; TTreePerfStats::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideReturn distance to one of the objects in the TTreePerfStats.Definition TTreePerfStats.cxx:217; TTreePerfStats::fRealTimeDouble_t fRealTimeReal time.Definition TTreePerfStats.h:58; TTreePerfStats::fReadaheadSizeInt_t fReadaheadSizeRead-ahead cache size.Definition TTreePerfStats.h:54; TTreePerfStats::fBranchIndexCachestd::unordered_map< TBranch *, size_t > fBranchIndexCacheDefinition TTreePerfStats.h:76; TTreePerfStats::~TTreePerfStats~TTreePerfStats() overrideDestructor.Definition TTreePerfStats.cxx:188; TTreePerfStats::fDiskTimeDouble_t fDiskTimeTime spent in pure raw disk IO.Definition TTreePerfStats.h:60; TTreePerfStats::fRealTimeAxisTGaxis * fRealTimeAxisPointer to TGaxis object showing real-time.Definition TTreePerfStats.h:73; TTreePerfStats::fUnzipTimeDouble_t fUnzipTimeTime spent uncompressing the data.Definition TTreePerfStats.h:61; TTreePerfStats::BasketList_tstd::vector< std::pair< TBranch *, std::vector< size_t > > > BasketList_tDefinition TTreePerfStats.h:48; TTreePerfStats::fPaveTPaveText * fPavePointer to annotation pavetext.Definition TTreePerfStats.h:71; TTreePerfStats::fTreeCacheSizeInt_t fTreeCacheSizeTTreeCache buffer size.Definition TTreePerfStats.h:51; TTreePerfStats::fGraph",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:43300,cache,cache,43300,doc/master/TTreePerfStats_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html,1,['cache'],['cache']
Performance,"aved as a starting state for later use.; Nodes can be declared as overlapping in case they do overlap with other nodes inside the same container or extrude this container (see also ‘Checking the Geometry'). Non-overlapping nodes can be created with:; TGeoVolume::AddNode(TGeoVolume *daughter,Int_t copy_No,; TGeoMatrix *matr);; Int_tint Int_tDefinition RtypesCore.h:45; TGeoMatrixGeometrical transformation package.Definition TGeoMatrix.h:38; TGeoVolume::AddNodevirtual TGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:975; The creation of overlapping nodes can be done with a similar prototype:; TGeoVolume::AddNodeOverlap(/*same arguments*/);; TGeoVolume::AddNodeOverlapvirtual void AddNodeOverlap(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:1044; When closing the geometry, overlapping nodes perform a check of possible overlaps with their neighbors. These are stored and checked all the time during navigation; therefore, navigation is slower when embedding such nodes into geometry. Nodes have visualization attributes as the volume has. When undefined by users, painting a node on a pad will take the corresponding volume attributes. Creating and Positioning Volumes; Making Volumes; As mentioned before, volumes are the basic objects used in building the geometrical hierarchy. They represent objects that are not positioned, but store all information about the placement of the other volumes they may contain. Therefore a volume can be replicated several times in the geometry. As it was explained, in order to create a volume, one has to put together a shape and a medium, which are already defined.; Volumes have to be named by users at creation time. Every different name may represent a unique volume object, but may also represent more general a family (class) of volume objects havin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:23931,perform,perform,23931,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['perform'],['perform']
Performance,"avigator(Int_t index); Switch to another existing navigator for the calling thread. void ClearNavigators(); Clear all navigators. void RemoveNavigator(const TGeoNavigator* nav); Clear a single navigator. void ClearThreadsMap(); Clear the current map of threads. This will be filled again by the calling; threads via ThreadId calls. Int_t ThreadId(); Translates the current thread id to an ordinal number. This can be used to; manage data which is pspecific for a given thread. void Browse(TBrowser* b); Describe how to browse this object. void Edit(Option_t* option = """"); Append a pad for this geometry. void SetVisibility(TObject* obj, Bool_t vis); Set visibility for a volume. void BombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'bombed' translation vector according current exploded view mode. void UnbombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'unbombed' translation vector according current exploded view mode. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. void RegisterMatrix(const TGeoMatrix* matrix); Register a matrix to the list of matrices. It will be cleaned-up at the; destruction TGeoManager. Int_t ReplaceVolume(TGeoVolume* vorig, TGeoVolume* vnew); Replaces all occurences of VORIG with VNEW in the geometry tree. The volume VORIG; is not replaced from the list of volumes, but all node referencing it will reference; VNEW instead. Returns number of occurences changed. Int_t TransformVolumeToAssembly(const char* vname); Transform all volumes named VNAME to assemblies. The volumes must be virtual. TGeoVolume * Division(const char* name, const char* mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); Create a new volume by dividing an existing one (GEANT3 like). Divides MOTHER into NDIV divisions called NAME; along axis IAXIS starting at coordinate value START;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoManager.html:39088,cache,cache,39088,root/html532/TGeoManager.html,https://root.cern,https://root.cern/root/html532/TGeoManager.html,1,['cache'],['cache']
Performance,"aving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCacheUnzip.html:16204,cache,cache,16204,root/html528/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html528/TTreeCacheUnzip.html,6,['cache'],['cache']
Performance,"avior.; Int_tTSystem::fBeepDurationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetXNGSystem.html:17202,optimiz,optimized,17202,root/html534/TNetXNGSystem.html,https://root.cern,https://root.cern/root/html534/TNetXNGSystem.html,18,"['cache', 'optimiz']","['cache', 'optimized']"
Performance,"aw parametric functions with log scales ;  multicolor.C Use a THStack to show a 2-D hist with cells with different colors ;  ratioplot1.C Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot2.C Example of a fit residual plot ;  ratioplot3.C Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot4.C Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot5.C Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot6.C Example showing a fit residual plot, where the separation margin has been set to 0 ;  ratioplotOld.CExample displaying two histograms and their ratio ;  rebin.C Rebin a variable bin-width histogram ;  reverseaxis.C Example showing an histogram with reverse axis ;  sparsehist.CEvaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension ;  statsEditing.C Edit statistics box ;  testSmooth.C Histogram smoothing ;  th2polyBoxes.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly) ;  th2polyEurope.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it ;  th2polyHoneycomb.C This tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly) ;  th2polyUSA.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option ;  thstack2palettecolor.C Palette coloring for 2D histograms' stack is activated thanks to the option PFC (Palette Fill Color) ;  thstackpalettecolor.C Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  tprofile2polyRealistic.C;  tprofile2polyRealisticModuleError.C;  transpad.C Example of a canvas s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:124819,perform,performance,124819,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['perform'],['performance']
Performance,"aw parametric functions with log scales ;  multicolor.C Use a THStack to show a 2-D hist with cells with different colors ;  ratioplot1.C Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot2.C Example of a fit residual plot ;  ratioplot3.C Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot4.C Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot5.C Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot6.C Example showing a fit residual plot, where the separation margin has been set to 0 ;  ratioplotOld.CExample displaying two histograms and their ratio ;  rebin.C Rebin a variable bin-width histogram ;  reverseaxis.C Example showing an histogram with reverse axis ;  sparsehist.CEvaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension ;  statsEditing.C Edit statistics box ;  testSmooth.C Histogram smoothing ;  th2polyBoxes.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly) ;  th2polyEurope.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it ;  th2polyHoneycomb.CThis tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly), fill it and draw it using GL ;  th2polyUSA.CThis tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using GL ;  transpad.C Example of a canvas showing two histograms with different scales ;  twoscales.C Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad ;  xyplot.C Example showing how to produce a plot with an orthogonal axis system centered at (0,0) ;  ► histfactory;  example.C;  example.py;  makeExample.C;  makeQuickModel.py;  ModifyInterpola",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:123722,perform,performance,123722,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['perform'],['performance']
Performance,"aw the frame on the canvas; c = ROOT.TCanvas(""rf201_composite"", ""rf201_composite"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); ; c.SaveAs(""rf201_composite.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (sig); 0x5b64db0 RooAddPdf::model = 0.886326/1 [Auto,Clean] ; 0x7475710/V- RooChebychev::bkg = 0.734412 [Auto,Dirty] ; 0x6e5aa50/V- RooRealVar::x = 5; 0x703aa10/V- RooRealVar::a0 = 0.506755 +/- 0.0795919; 0x6eef060/V- RooRealVar::a1 = 0.265588 +/- 0.133931; 0x748b980/V- RooRealVar::bkgfrac = 0.428008 +/- 0.0356013; 0x7492e20/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x7078360/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x6e5aa50/V- RooRealVar::x = 5; 0x6dab710/V- RooRealVar::mean = 5; 0x69f2060/V- RooRealVar::sigma1 = 0.5; 0x72776d0/V- RooRealVar::sig1frac = 0.641992 +/- 0.0969095; 0x",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf201__composite_8py.html:4232,optimiz,optimization,4232,doc/master/rf201__composite_8py.html,https://root.cern,https://root.cern/doc/master/rf201__composite_8py.html,2,['optimiz'],['optimization']
Performance,"aw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidDLCacheDrop(); virtual voidDLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTEveDigitSetGL::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTEveDigitSetGL::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidRender(TGLRnrCtx& rnrCtx); virtual voidTEveDigitSetGL::SetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, const Option_t* opt = 0); virtual Bool_tShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTEveDigitSetGL::SupportsSecondarySelect() const; TEveBoxSetGL(); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveBoxSetGL.html:1904,cache,cached,1904,root/html602/TEveBoxSetGL.html,https://root.cern,https://root.cern/root/html602/TEveBoxSetGL.html,2,['cache'],['cached']
Performance,"awProfile2D Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TProofDrawProfile2D Class Reference. . Definition at line 184 of file TProofDraw.h. Public Member Functions;  TProofDrawProfile2D ();  ; void Begin (TTree *t) override;  See TProofDraw::Begin(). ;  ; void Init (TTree *) override;  See TProofDraw::Init(). ;  ; TClass * IsA () const override;  ; void SlaveBegin (TTree *) override;  See TProofDraw::SlaveBegin(). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Terminate () override;  See TProofDraw::Terminate(). ;  ;  Public Member Functions inherited from TProofDraw;  TProofDraw ();  Constructor. ;  ;  ~TProofDraw () override;  Destructor. ;  ; Bool_t Notify () override;  Called when a new tree is loaded. ;  ; Bool_t Process (Long64_t) override;  Executed for each entry. ;  ; void SlaveTerminate () override;  Executed by each slave after the processing has finished, before returning the results to the client. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; int Version () const override;  ;  Public Member Functions inherited from TSelector;  TSelector ();  Default selector ctor. ;  ;  ~TSelector () override;  Selector destructor. ;  ; virtual void Abort (const char *why, EAbort what=kAbortProcess);  Abort processing. ;  ; virtual EAbort GetAbort () const;  ; virtual Int_t GetEntry (Long64_t, Int_t=0);  ; virtual TList * GetInputList () const;  ; const char * GetOption () const override;  ; virtual TList * GetOutputList () const;  ; virtual Long64_t GetStatus () const;  ; virtual void ImportOutput (TList *output);  Imports the content of 'output' in the internal output list. ;  ; TClass * IsA () const override;  ; bool Notify () over",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDrawProfile2D.html:1043,load,loaded,1043,doc/master/classTProofDrawProfile2D.html,https://root.cern,https://root.cern/doc/master/classTProofDrawProfile2D.html,1,['load'],['loaded']
Performance,"ax like arg1%, arg2% and so on. For example: serv->RegisterCommand(""/ResetHPX"", ""/hpx/->SetTitle(\""%arg1%\"")"");; serv->RegisterCommand(""/RebinHPXPY"", ""/hpxpy/->Rebin2D(%arg1%,%arg2%)"");; Such parameter(s) will be requested when command clicked in the browser.; Once command is registered, one could specify icon which will appear in the browser: serv->SetIcon(""/ResetHPX"", ""rootsys/icons/ed_execute.png"");; One also can set extra property '_fastcmd', that command appear as tool button on the top of the browser tree: serv->SetItemField(""/ResetHPX"", ""_fastcmd"", ""true"");; Or it is equivalent to specifying extra argument when register command: serv->RegisterCommand(""/ResetHPX"", ""/hpx/->Reset()"", ""button;rootsys/icons/ed_delete.png""); . Definition at line 1428 of file THttpServer.cxx. ◆ RegisterWS(). void THttpServer::RegisterWS ; (; std::shared_ptr< THttpWSHandler > ; ws). Register WS handler. ; Register WS handler to the THttpServer.; Only such handler can be used in multi-threaded processing of websockets ; Definition at line 1263 of file THttpServer.cxx. ◆ ReplaceJSROOTLinks(). void THttpServer::ReplaceJSROOTLinks ; (; std::shared_ptr< THttpCallArg > & ; arg, . const std::string & ; version = """" . ). protected . Replaces all references like ""jsrootsys/..."" or other pre-configured pathes. ; Either using pre-configured JSROOT installation from web or redirect to jsrootsys from the main server path to benefit from browser caching Creates appropriate importmap instead of placeholder ; Definition at line 847 of file THttpServer.cxx. ◆ Restrict(). void THttpServer::Restrict ; (; const char * ; path, . const char * ; options . ). Restrict access to specified object. ; See TRootSniffer::Restrict() for more details ; Definition at line 1386 of file THttpServer.cxx. ◆ SetCors(). void THttpServer::SetCors ; (; const std::string & ; domain = ""*""). inline . Enable CORS header to ProcessRequests() responses Specified location (typically ""*"") add as ""Access-Control-Allow-Origin"" header.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpServer.html:32026,multi-thread,multi-threaded,32026,doc/master/classTHttpServer.html,https://root.cern,https://root.cern/doc/master/classTHttpServer.html,1,['multi-thread'],['multi-threaded']
Performance,"ax size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); Long64_tfTotalUnzipBytes! The total sum of the currently unzipped blks; TTree*TTreeCache::fTree! pointer to the current Tree; Long64_tfUnzipBufferSize! Max Size for the ready unzipped blocks (default is 2*fBufferSize); char**fUnzipChunks! [fNseek] Individual unzipped chunks. Their summed size is kept under control.; TCondition*fUnzipDoneConditionUsed to wait for an unzip tour to finish. Gives the Async feel.; Int_t*fUnzipLen! [fNseek] Length of the unzipped buffers; TCondition*fUnzipStartConditionUsed to signal the threads to start.; Byte_t*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCacheUnzip.html:15036,cache,cache,15036,root/html602/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html,2,['cache'],['cache']
Performance,"axDigits(). void TAttAxis::SetMaxDigits ; (; Int_t ; maxDigits = 5). virtual . This function sets the maximum number of digits permitted for the axis labels above which the notation with 10^N is used. ; For example, to accept 6 digits number like 900000 on the X axis of the histogram h call:; h->GetXaxis()->SetMaxDigits(6);; h#define h(i)Definition RSha256.hxx:106; The default value is 5.; The default value for all axis can be set with the static function TGaxis::SetMaxDigits. ; Definition at line 268 of file TAttAxis.cxx. ◆ SetNdivisions() [1/2]. void TAttAxis::SetNdivisions ; (; Int_t ; n1, . Int_t ; n2, . Int_t ; n3, . Bool_t ; optim = kTRUE . ). virtual . Set the number of divisions for this axis using one int per division level. ; Definition at line 247 of file TAttAxis.cxx. ◆ SetNdivisions() [2/2]. void TAttAxis::SetNdivisions ; (; Int_t ; n = 510, . Bool_t ; optim = kTRUE . ). virtual . Set the number of divisions for this axis. . if optim = kTRUE (default), the number of divisions will be optimized around the specified value.; if optim = kFALSE, or n < 0, the axis will be forced to use exactly n divisions. n = n1 + 100*n2 + 10000*n3; nconst Int_t nDefinition legend1.C:16; Where n1 is the number of primary divisions, n2 is the number of second order divisions and n3 is the number of third order divisions. If the number of divisions is ""optimized"" (see above) n1, n2, n3 are maximum values.; Examples:. ndiv = 0: no tick marks.; ndiv = 2: 2 divisions, one tick mark in the middle of the axis.; ndiv = 510: 10 primary divisions, 5 secondary divisions.; ndiv = -10: exactly 10 primary divisions. . Definition at line 233 of file TAttAxis.cxx. ◆ SetTickLength(). void TAttAxis::SetTickLength ; (; Float_t ; length = 0.03). virtual . Set tick mark length. ; The length is expressed in per cent of the pad width. ; Definition at line 284 of file TAttAxis.cxx. ◆ SetTickSize(). virtual void TAttAxis::SetTickSize ; (; Float_t ; size = 0.03). inlinevirtual . Definition at line 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAttAxis.html:9641,optimiz,optimized,9641,doc/master/classTAttAxis.html,https://root.cern,https://root.cern/doc/master/classTAttAxis.html,1,['optimiz'],['optimized']
Performance,"axQ); static voidLoadMacro(const char* mac); static voidMacro(const char* mac); TEveUtil&operator=(const TEveUtil&); static voidSetColorBrightness(Float_t value, Bool_t full_redraw = kFALSE); static voidSetupEnvironment(); static voidSetupGUI(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. static TObjArray*fgDefaultColors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupEnvironment(); Setup Include and Macro paths.; Since inclusion into ROOT this does nothing but could; potentially be reactivated if some common macros are established; and shipped with binary ROOT (in macros/eve). For example, these; might be used to spawn specific GUI / GL configurations. void SetupGUI(); Setup icon pictures and mime-types. Bool_t CheckMacro(const char* mac); Checks if macro 'mac' is loaded. void AssertMacro(const char* mac); Load and execute macro 'mac' if it has not been loaded yet. void Macro(const char* mac); Execute macro 'mac'. Do not reload the macro. void LoadMacro(const char* mac); Makes sure that macro 'mac' is loaded, but do not reload it. void ColorFromIdx(Color_t ci, UChar_t* col, Bool_t alpha = kTRUE); Fill col with RGBA values corresponding to index ci. If alpha; is true, set alpha component of col to 255.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Color_t ci, UChar_t* col, Char_t transparency); Fill col with RGBA values corresponding to index ci and transparency.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Float_t f1, Color_t c1, Float_t f2, Color_t c2, UChar_t* col, Bool_t alpha = kTRUE); Fill col with weighted RGBA values corresponding to; color-indices c1 and c2. If alpha is true, set alpha component; of col to 255. Color_t* FindColorVar(TObject* obj, const char* varname); Find address of Color_t data-member with name varname in o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveUtil.html:2390,load,loaded,2390,root/html534/TEveUtil.html,https://root.cern,https://root.cern/root/html534/TEveUtil.html,1,['load'],['loaded']
Performance,"axWtRej;  Maximum weight in rejection for getting wt=1 events. ;  ; Double_t fMCerror;  and its error ;  ; TFoamMaxwt * fMCMonit;  Monitor of the MC weight for measuring MC efficiency. ;  ; Double_t fMCresult;  True Integral R from MC series. ;  ; Double_t * fMCvect;  [fDim] Generated MC vector for the outside user ;  ; Double_t fMCwt;  MC weight. ;  ; TMethodCall * fMethodCall;  ! ROOT's pointer to user-defined global distribution function ;  ; TString fName;  Name of a given instance of the FOAM class. ;  ; Int_t fNBin;  No. of bins in the edge histogram for cell MC exploration. ;  ; Long_t fNCalls;  Total number of the function calls. ;  ; Int_t fNCells;  Maximum number of cells. ;  ; Long_t fNEffev;  Total number of effective events (wt=1) in the foam buildup. ;  ; Double_t fNevGen;  Total number of the generated MC events. ;  ; Int_t fNoAct;  Number of active cells. ;  ; Int_t fNSampl;  No. of MC events, when dividing (exploring) cell. ;  ; Int_t fOptDrive;  Optimization switch =1,2 for variance or maximum weight optimization. ;  ; Int_t fOptPRD;  Option switch for predefined division, for quick check. ;  ; Int_t fOptRej;  Switch =0 for weighted events; =1 for unweighted events in MC. ;  ; Double_t * fPrimAcu;  [fNoAct] Array of cumulative probability of all active cells ;  ; Double_t fPrime;  Primary integral R' (R=R'<wt>) ;  ; TRandom * fPseRan;  Pointer to user-defined generator of pseudorandom numbers. ;  ; TFoamIntegrand * fRho;  ! Pointer to the user-defined integrand function/distribution ;  ; Int_t fRNmax;  Maximum No. of the rand. numb. requested at once. ;  ; Double_t * fRvec;  [fRNmax] random number vector from r.n. generator fDim+1 maximum elements ;  ; Double_t fSumOve;  Total Sum of overweighted events. ;  ; Double_t fSumWt;  ; Double_t fSumWt2;  Total sum of wt and wt^2. ;  ; TString fVersion;  Actual version of the FOAM like (1.01m) ;  ; Double_t fWtMax;  ; Double_t fWtMin;  Maximum/Minimum MC weight. ;  ; TFoamVect ** fXdivPRD;  ! Lists of divis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFoam.html:22078,optimiz,optimization,22078,doc/master/classTFoam.html,https://root.cern,https://root.cern/doc/master/classTFoam.html,1,['optimiz'],['optimization']
Performance,"aximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:33558,cache,cache,33558,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,1,['cache'],['cache']
Performance,"axlevel);. TGeoBranchArray * MakeCopy(const TGeoBranchArray& other); Make a copy of a branch array at the location (if indicated). TGeoBranchArray * MakeCopyAt(const TGeoBranchArray& other, void* addr); Make a copy of a branch array at the location (if indicated). void CopyTo(TGeoBranchArray* dest); Raw memcpy of the branch array content to an existing destination. void ReleaseInstance(TGeoBranchArray* obj); Releases the space allocated for the object. void UpdateArray(size_t nobj); Updates the internal addresses for n contiguous objects which have the same; fMaxLevel; Updates the internal addresses for n contiguous objects which have the same fMaxLevel. TGeoBranchArray(const TGeoBranchArray& ); Copy constructor. Not callable anymore. Use TGeoBranchArray::MakeCopy instead. TGeoBranchArray& operator=(const TGeoBranchArray& ); Assignment. Not valid anymore. Use TGeoBranchArray::MakeCopy instead. void AddLevel(Int_t dindex); Add and extra daughter to the current path array. No validity check performed !. Long64_t BinarySearch(Long64_t n, const TGeoBranchArray** array, TGeoBranchArray* value); Binary search in an array of n pointers to branch arrays, to locate value.; Returns element index or index of nearest element smaller than value. Int_t Compare(const TObject* obj) const; Compare with other object of same type. Returns -1 if this is smaller (first; smaller array value prevails), 0 if equal (size and values) and 1 if this is; larger. void CleanMatrix(); Garbage collect the stored matrix. void Init(TGeoNode** branch, TGeoMatrix* global, Int_t level); Init the branch array from an array of nodes, the global matrix for the path and; the level. void InitFromNavigator(TGeoNavigator* nav); Init the branch array from current navigator state. void GetPath(TString& path) const; Fill path pointed by the array. void Print(Option_t* option = """") const; Print branch information. void Sort(Int_t n, TGeoBranchArray** array, Int_t* index, Bool_t down = kTRUE); Sorting of an array of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBranchArray.html:8980,perform,performed,8980,root/html534/TGeoBranchArray.html,https://root.cern,https://root.cern/root/html534/TGeoBranchArray.html,2,['perform'],['performed']
Performance,"ay *branches); 361{; 362 fBranchIndexCache.clear();; 363 ; 364 for (int i = 0; i < branches->GetEntries(); ++i) {; 365 fBranchIndexCache.emplace((TBranch*)(branches->UncheckedAt(i)), i);; 366 }; 367}; 368 ; 369////////////////////////////////////////////////////////////////////////////////; 370/// Return the BasketInfo corresponding to the given branch and basket.; 371 ; 372TTreePerfStats::BasketInfo &TTreePerfStats::GetBasketInfo(TBranch *br, size_t basketNumber); 373{; 374 static BasketInfo fallback;; 375 ; 376 // First find the branch index.; 377 TFile *file = fTree->GetCurrentFile();; 378 if (!file); 379 return fallback;; 380 ; 381 TTreeCache *cache = dynamic_cast<TTreeCache *>(file->GetCacheRead(fTree));; 382 if (!cache); 383 return fallback;; 384 ; 385 Int_t index = -1;; 386 auto iter = fBranchIndexCache.find(br);; 387 if (iter == fBranchIndexCache.end()) {; 388 auto branches = cache->GetCachedBranches();; 389 for (Int_t i = 0; i < branches->GetEntries(); ++i) {; 390 if (br == branches->UncheckedAt(i)) {; 391 index = i;; 392 break;; 393 }; 394 }; 395 if (index < 0); 396 return fallback;; 397 fBranchIndexCache.emplace(br, index);; 398 } else {; 399 index = iter->second;; 400 }; 401 ; 402 return GetBasketInfo(index, basketNumber);; 403}; 404 ; 405////////////////////////////////////////////////////////////////////////////////; 406/// Return the BasketInfo corresponding to the given branch and basket.; 407 ; 408TTreePerfStats::BasketInfo &TTreePerfStats::GetBasketInfo(size_t index, size_t basketNumber); 409{; 410 if (fBasketsInfo.size() <= (size_t)index); 411 fBasketsInfo.resize(index + 1);; 412 ; 413 auto &brvec(fBasketsInfo[index]);; 414 if (brvec.size() <= basketNumber); 415 brvec.resize(basketNumber + 1);; 416 ; 417 return brvec[basketNumber];; 418}; 419 ; 420////////////////////////////////////////////////////////////////////////////////; 421/// Return the collection of baskets which have been read by the TTreeCache more; 422/// than once; 423 ; 424TTreePerf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:13434,cache,cache,13434,doc/master/TTreePerfStats_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html,1,['cache'],['cache']
Performance,"ay have a different type), whereas builtin types will be cast implicitly, if possible, to the type of the local variable to which they are assigned.; Bind(TObject* obj,const char* label) - transfer a ROOT object from the Cling to the Python interpreter, where it will be referenced with a variable called “label”.; Prompt() - Transfer the interactive prompt to Python.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first with gSystem->Load() before use. Refer back to the other example of the use of TPython that was given in “Access to Python from ROOT”.; To show in detail how Python access can be used, an example Python module is needed, as follows:; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; This module can now be loaded into a Cling session, the class used to instantiate objects, and their member functions called for showing how different types can cross:; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; Note that the LoadMacro() call makes the class automatically available, such that it can be used directly. Otherwise, a gROOT->GetClass() call is required first.; 19.1.5.5 Callbacks; The simplest way of setting a callback to Python from Cling, e.g. for a button, is by providing the execution string. See for example tutorials/pyroot/demo.py that comes with the ROOT installation:; # [..]; bar = ROOT.TControlBar('vertical','Demos'); bar.AddButton('Help on Demos',r'TPython::Exec(""execfile('demoshelp.py')"");','Click Here For Help on Running the Demos'); bar.AddButton('browser',r'TPython::Exec(""b = Tbrowser()"");','Start the ROOT browser'); # [..]; Here, the callback is a string that will be interpreted by Cling to call",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1058470,load,loaded,1058470,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loaded']
Performance,"ay of clone (identical) objects.Definition TClonesArray.h:29; TCollection::RemoveAllvirtual void RemoveAll(TCollection *col)Remove all objects in collection col from this collection.Definition TCollection.cxx:594; TCollection::Browsevoid Browse(TBrowser *b) overrideBrowse this collection (called by TBrowser).Definition TCollection.cxx:248; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDirectory::TContextTDirectory::TContext keeps track and restore the current directory.Definition TDirectory.h:89; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::GetFilevirtual TFile * GetFile() constDefinition TDirectory.h:220; TDirectory::FindObjectTObject * FindObject(const char *name) const overrideFind object by name in the list of memory objects.Definition TDirectory.cxx:784; TDirectory::IsWritablevirtual Bool_t IsWritable() constDefinition TDirectory.h:237; TFileCacheReadA cache when reading files over the network.Definition TFileCacheRead.h:22; TFileCacheRead::SetSkipZipvirtual void SetSkipZip(Bool_t=kTRUE)Definition TFileCacheRead.h:112; TFileCacheRead::IsLearningvirtual Bool_t IsLearning() constDefinition TFileCacheRead.h:102; TFileCacheRead::LearnBranchvirtual Int_t LearnBranch(TBranch *, Bool_t=kFALSE)Definition TFileCacheRead.h:103; TFileMergeInfoDefinition TFileMergeInfo.h:42; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::GetCompressionSettingsInt_t GetCompressionSettings() constDefinition TFile.h:397; TFile::GetCompressionLevelInt_t GetCompressionLevel() constDefinition TFile.h:391; TFile::MakeFreevirtual void MakeFree(Long64_t first, Long64_t last)Mark unused bytes on the file.Definition TFile.cxx:1484; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefau",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:146354,cache,cache,146354,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,1,['cache'],['cache']
Performance,"ayMode & (~2);; 760 ; 761 if (needIncrement) b.IncrementLevel(thisVar);; 762 ; 763 //loop on all active members; 764 ; 765 // In order to speed up the case where the object being written is; 766 // not in a collection (i.e. arrayMode is false), we actually; 767 // duplicate the code for the elementary types using this typeOffset.; 768 static const int kHaveLoop = 1024;; 769 const Int_t typeOffset = arrayMode ? kHaveLoop : 0;; 770 ; 771 TClass *cle = 0;; 772 TClass *newCle = 0;; 773 TMemberStreamer *pstreamer=0;; 774 Int_t isPreAlloc = 0;; 775 for (Int_t i=first;i<last;i++) {; 776 TStreamerElement * aElement = (TStreamerElement*)compinfo[i]->fElem;; 777 CurrentElement() = aElement;; 778 ; 779 if (needIncrement) b.SetStreamerElementNumber(aElement,compinfo[i]->fType);; 780 ; 781 if (aElement->TestBit(TStreamerElement::kWrite)) continue;; 782 ; 783 if (R__TestUseCache<T>(aElement)) {; 784 Int_t bufpos = b.Length();; 785 if (((TBufferFile&)b).PeekDataCache()==0) {; 786 Warning(""ReadBuffer"",""Skipping %s::%s because the cache is missing."",thisVar->GetName(),aElement->GetName());; 787 thisVar->ReadBufferSkip(b,arr,compinfo[i],compinfo[i]->fType+TStreamerInfo::kSkip,aElement,narr,eoffset);; 788 } else {; 789 if (gDebug > 1) {; 790 printf(""ReadBuffer, class:%s, name=%s, fType[%d]=%d,""; 791 "" %s, bufpos=%d, arr=%p, eoffset=%d, Redirect=%p\n"",; 792 fClass->GetName(),aElement->GetName(),i,compinfo[i]->fType,; 793 aElement->ClassName(),b.Length(),arr[0], eoffset,((TBufferFile&)b).PeekDataCache()->GetObjectAt(0));; 794 }; 795 thisVar->ReadBuffer(b,*((TBufferFile&)b).PeekDataCache(),compinfo,i,i+1,narr,eoffset, arrayMode);; 796 }; 797 if (aElement->TestBit(TStreamerElement::kRepeat)) { b.SetBufferOffset(bufpos); }; 798 continue;; 799 }; 800 const Int_t ioffset = compinfo[i]->fOffset+eoffset;; 801 ; 802 if (gDebug > 1) {; 803 printf(""ReadBuffer, class:%s, name=%s, fType[%d]=%d,""; 804 "" %s, bufpos=%d, arr=%p, offset=%d\n"",; 805 fClass->GetName(),aElement->GetName(),i,compinfo[i]->fT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoReadBuffer_8cxx_source.html:32554,cache,cache,32554,doc/master/TStreamerInfoReadBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoReadBuffer_8cxx_source.html,1,['cache'],['cache']
Performance,"ayout engine as far as; possible with the text that is available. The display is updated; appropriately. void SetTableRelief(int relief); Sets relief mode of html table. void SetRuleRelief(int relief); Sets relief mode of html rule. void UnderlineLinks(int onoff); Set/reset html links underline. void SetBaseUri(const char* uri); Sets base URI. int GotoAnchor(const char* name); Go to anchor position. const char * GetUid(const char* string); Given a string, this procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other calls to this; procedure with a string equal to ""string"" will return exactly the same; result (i.e. can compare pointer *values* directly, without having to; call strcmp on what they point to). void ComputeVirtualSize(); Computes virtual size of html area. void ClearGcCache(); Clear the cache of GCs. void ResetLayoutContext(); Reset the main layout context in the main widget. This happens; before we redo the layout, or just before deleting the widget. void Redraw(); This routine is invoked in order to redraw all or part of the HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGHtml.html:33366,cache,cache,33366,root/html528/TGHtml.html,https://root.cern,https://root.cern/root/html528/TGHtml.html,6,['cache'],['cache']
Performance,"ays be capable of displaying the object described by this buffer. If either does not meet this requirement the object may not be displayed.; 9.13.4.8 Scene Rebuilds; TBuffer3D::AddObject is not an explicit command to the viewer - it may for various reasons decide to ignore it:. It already has the object internally cached.; The object falls outside some ‘interest’ limits of the viewer camera.; The object is too small to be worth drawing. In all these cases TBuffer3D::AddObject() returns kNone, as it does for successful addition, indicating it does not require further information about this object. Hence you should not try to make any assumptions about what the viewer did with the object. The viewer may decide to force the client to rebuild (republish) the scene, obtaining a different collection of objects, if the internal viewer state changes .e.g. significant camera move. It does this presently by forcing a repaint on the attached TPad object - hence you should attach you master geometry object to the pad (via TObject::Draw()), and perform the publishing to the viewer in response to TObject::Paint().; 9.13.4.9 Physical IDs; TVirtualViewer3D provides for two methods of object addition:; virtual Int_t AddObject(const TBuffer3D &buffer,; Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID,; const TBuffer3D & buffer,; Bool_t *addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs will generate sequential IDs for each physical object internally. Scene rebuilds will require destruction and recreation of all physical objects. For the second you can specify an identifier from the client side, which must be unique and stable - i.e. the IDs of a published object is consistent, regardless of changes in termination of contained child geometry branches. In this case the viewer can safely cache the physical objects across scene rebuilds, discarding those no longer of interest.; 9.13.4.10 Child Objects; In many geometries there i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:416335,perform,perform,416335,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['perform']
Performance,"b, Bool_t quiet=kFALSE);  Find a dynamic library called lib using the system search paths. ;  ; virtual Func_t DynFindSymbol (const char *module, const char *entry);  Find specific entry point in specified library. ;  ; virtual Int_t Exec (const char *shellcmd);  Execute a command. ;  ; virtual void Exit (int code, Bool_t mode=kTRUE);  Exit the application. ;  ; virtual void ExitLoop ();  Exit from event loop. ;  ; virtual char * ExpandPathName (const char *path);  Expand a pathname getting rid of special shell characters like ~. ;  ; virtual Bool_t ExpandPathName (TString &path);  Expand a pathname getting rid of special shell characters like ~. ;  ; virtual const char * FindDynamicLibrary (TString &lib, Bool_t quiet=kFALSE);  Find a dynamic library using the system search paths. ;  ; virtual const char * FindFile (const char *search, TString &file, EAccessMode mode=kFileExists);  Find location of file in a search path. ;  ; virtual EAclicMode GetAclicMode () const;  AclicMode indicates whether the library should be built in debug mode or optimized. ;  ; virtual Int_t GetAclicProperties () const;  Return the ACLiC properties field. ;  ; void GetBeepDefaults (Int_t &freq, Int_t &duration) const;  ; virtual const char * GetBuildArch () const;  Return the build architecture. ;  ; virtual const char * GetBuildCompiler () const;  Return the build compiler. ;  ; virtual const char * GetBuildCompilerVersion () const;  Return the build compiler version. ;  ; virtual const char * GetBuildCompilerVersionStr () const;  Return the build compiler version identifier string. ;  ; virtual const char * GetBuildDir () const;  Return the path of the build directory. ;  ; virtual const char * GetBuildNode () const;  Return the build node name. ;  ; virtual int GetCpuInfo (CpuInfo_t *info, Int_t sampleTime=1000) const;  Returns cpu load average and load info into the CpuInfo_t structure. ;  ; virtual Int_t GetCryptoRandom (void *buf, Int_t len);  Return cryptographic random number Fill",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixSystem.html:5761,optimiz,optimized,5761,doc/master/classTDavixSystem.html,https://root.cern,https://root.cern/doc/master/classTDavixSystem.html,5,['optimiz'],['optimized']
Performance,"bConn::fEmbedstd::map< int, std::shared_ptr< RWebWindow > > fEmbed! map of embed window for that connection, key value is channel idDefinition RWebWindow.hxx:90; ROOT::RWebWindow::WebConn::fKeystd::string fKey! key value supplied to the window (when exists)Definition RWebWindow.hxx:72; ROOT::RWebWindow::WebConn::WebConnWebConn(unsigned connid, bool headless_mode, const std::string &key)Definition RWebWindow.hxx:94; ROOT::RWebWindow::WebConn::fSendSequnsigned long fSendSeq! sequence id of last send packetDefinition RWebWindow.hxx:88; ROOT::RWebWindow::WebConn::fKeyUsedint fKeyUsed! key value used to verify connectionDefinition RWebWindow.hxx:73; ROOT::RWebWindow::WebConn::~WebConn~WebConn()Destructor for WebConn Notify special HTTP request which blocks headless browser from exit.Definition RWebWindow.cxx:42; ROOT::RWebWindow::WebConn::fMutexstd::mutex fMutex! mutex must be used to protect all following dataDefinition RWebWindow.hxx:81; ROOT::RWebWindow::WebConn::fDoingSendbool fDoingSend! true when performing send operationDefinition RWebWindow.hxx:86; ROOT::RWebWindow::WebConn::fSendCreditsint fSendCredits! how many send operation can be performed without confirmation from other sideDefinition RWebWindow.hxx:84; ROOT::RWebWindow::WebConn::WebConnWebConn(unsigned connid, unsigned wsid)Definition RWebWindow.hxx:93; ROOT::RWebWindow::WebConn::fNewKeystd::string fNewKey! new key if connection request reloadDefinition RWebWindow.hxx:74; ROOT::RWebWindow::WebConn::fWSIdunsigned fWSId! websocket idDefinition RWebWindow.hxx:79; ROOT::RWebWindow::WebConn::fSendStamptimestamp_t fSendStamp! last server operation, always used from window threadDefinition RWebWindow.hxx:77; ROOT::RWebWindow::WebConn::fRecvStamptimestamp_t fRecvStamp! last receive operation, protected with connection mutexDefinition RWebWindow.hxx:82; ROOT::RWebWindow::WebConn::fRecvCountint fRecvCount! number of received packets, should return back with next sendingDefinition RWebWindow.hxx:83; ROOT::RWebWindow::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:49756,perform,performing,49756,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['perform'],['performing']
Performance,"bConn::fEmbedstd::map< int, std::shared_ptr< RWebWindow > > fEmbed! map of embed window for that connection, key value is channel idDefinition RWebWindow.hxx:93; ROOT::RWebWindow::WebConn::fKeystd::string fKey! key value supplied to the window (when exists)Definition RWebWindow.hxx:75; ROOT::RWebWindow::WebConn::WebConnWebConn(unsigned connid, bool headless_mode, const std::string &key)Definition RWebWindow.hxx:97; ROOT::RWebWindow::WebConn::fSendSequnsigned long fSendSeq! sequence id of last send packetDefinition RWebWindow.hxx:91; ROOT::RWebWindow::WebConn::fKeyUsedint fKeyUsed! key value used to verify connectionDefinition RWebWindow.hxx:76; ROOT::RWebWindow::WebConn::~WebConn~WebConn()Destructor for WebConn Notify special HTTP request which blocks headless browser from exit.Definition RWebWindow.cxx:42; ROOT::RWebWindow::WebConn::fMutexstd::mutex fMutex! mutex must be used to protect all following dataDefinition RWebWindow.hxx:84; ROOT::RWebWindow::WebConn::fDoingSendbool fDoingSend! true when performing send operationDefinition RWebWindow.hxx:89; ROOT::RWebWindow::WebConn::fWasFirstbool fWasFirst! indicate if this was first connection, will be reinjected also on first placeDefinition RWebWindow.hxx:74; ROOT::RWebWindow::WebConn::fSendCreditsint fSendCredits! how many send operation can be performed without confirmation from other sideDefinition RWebWindow.hxx:87; ROOT::RWebWindow::WebConn::WebConnWebConn(unsigned connid, unsigned wsid)Definition RWebWindow.hxx:96; ROOT::RWebWindow::WebConn::fNewKeystd::string fNewKey! new key if connection request reloadDefinition RWebWindow.hxx:77; ROOT::RWebWindow::WebConn::fWSIdunsigned fWSId! websocket idDefinition RWebWindow.hxx:82; ROOT::RWebWindow::WebConn::fSendStamptimestamp_t fSendStamp! last server operation, always used from window threadDefinition RWebWindow.hxx:80; ROOT::RWebWindow::WebConn::fRecvStamptimestamp_t fRecvStamp! last receive operation, protected with connection mutexDefinition RWebWindow.hxx:85; ROOT::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:50040,perform,performing,50040,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['perform'],['performing']
Performance,"baked into the parsing. More...;  ; template<typename T > ; TClass * GetClass (const T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; UInt_t GetImplicitMTPoolSize ();  Returns the size of the pool used for implicit multi-threading. More...;  ; TString & GetMacroPath ();  ; TROOT * GetROOT ();  ; void GetRuleIncludes (std::list< std::string > &result);  Get the list of includes specified in the shema rules. More...;  ; bool HasValidDataMembers (SchemaRuleMap_t &rule, MembersTypeMap_t &members, std::string &error_string);  Check if given rule contains references to valid data members. More...;  ; Bool_t IsImplicitMTEnabled ();  Returns true if the implicit multi-threading in ROOT is enabled. More...;  ; template<class T > ; TSeq< T > MakeSeq (T begin, T end, T step=1);  ; template<class T > ; TSeq< T > MakeSeq (T end);  ; bool ParseRule (std::string command, ROOT::Internal::MembersMap_t &result, std::string &error_string);  Parse the schema rule as specified in the LinkDef file. More...;  ; void ProcessReadPragma (const char *args, std::string &error_string);  I am being called when a read pragma is encountered. More...;  ; void ProcessReadRawPragma (const char *args, std::string &error_string);  I am being called then a readraw pragma is encountered. More...;  ; TNamed * RegisterClassTemplate (const char *name, const char *file, Int_t line);  Global function to register the implementation file and line of a class template (i.e. More...;  ; void RemoveClass (const char *cname);  Global function called by the dtor of a class's init class (see the ClassImp macro). More...;  ; void ResetClassVersion (TClass *, const char *, S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:8925,multi-thread,multi-threading,8925,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,2,['multi-thread'],['multi-threading']
Performance,"bal function by name. If params != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The param string must be of the form: ""3189,\""aap\"",1.3"". TFunction * GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); Return pointer to global function by name. If proto != 0; it will also resolve overloading. If load is true force reading; of all currently defined global functions from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return list containing all TDataTypes (typedefs) currently defined.; Since types can be added and removed during execution of the; program, we need to update the list of types every time we; execute this method. However, when calling this function in; a (tight) loop where no new types will be created; you can set load=kFALSE (default). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t Ig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:24932,load,load,24932,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,4,['load'],['load']
Performance,"bal instance of string that matches object named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; Bool_t_nlo; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGExpModel.html:45151,cache,cache,45151,root/html534/RooGExpModel.html,https://root.cern,https://root.cern/root/html534/RooGExpModel.html,1,['cache'],['cache']
Performance,"bc,e,xc,xw,yc,yw; 1807/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1808 ; 1809void TFumili::FitChisquareI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1810{; 1811 Double_t cu,eu,fu,fsum;; 1812 Double_t x[3];; 1813 Double_t *zik=nullptr;; 1814 Double_t *pl0=nullptr;; 1815 ; 1816 TH1 *hfit = (TH1*)GetObjectFit();; 1817 TF1 *f1 = (TF1*)GetUserFunc();; 1818 Int_t nd = hfit->GetDimension();; 1819 Int_t j;; 1820 ; 1821 f1->InitArgs(x,u);; 1822 npar = f1->GetNpar();; 1823 SetParNumber(npar);; 1824 if(flag == 9) return;; 1825 zik = GetZ();; 1826 pl0 = GetPL0();; 1827 ; 1828 Double_t *df=new Double_t[npar];; 1829 f = 0;; 1830 ; 1831 Int_t npfit = 0;; 1832 Double_t *cache = fCache;; 1833 for (Int_t i=0;i<fNpoints;i++) {; 1834 cu = cache[0];; 1835 TF1::RejectPoint(kFALSE);; 1836 f1->SetParameters(u);; 1837 if (nd < 2) {; 1838 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 1839 } else if (nd < 3) {; 1840 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 1841 } else {; 1842 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 1843 }; 1844 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 1845 eu = cache[1];; 1846 Derivatives(df,x);; 1847 Int_t n = 0;; 1848 fsum = (fu-cu)/eu;; 1849 if (flag!=1) {; 1850 for (j=0;j<npar;j++) {; 1851 if (pl0[j]>0){; 1852 df[n] = df[j]/eu;; 1853 // left only non-fixed param derivatives / by Sigma; 1854 gin[j] += df[n]*fsum;; 1855 n++;; 1856 }; 1857 }; 1858 Int_t l = 0;; 1859 for (j=0;j<n;j++); 1860 for (Int_t k=0;k<=j;k++); 1861 zik[l++] += df[j]*df[k];; 1862 }; 1863 f += .5*fsum*fsum;; 1864 npfit++;; 1865 cache += fPointSize;; 1866 }; 1867 f1->SetNumberFitPoints(npfit);; 1868 delete[] df;; 1869}; 1870 ; 1871///////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:52710,cache,cache,52710,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,2,['cache'],['cache']
Performance,"bdirectories. void DrawMap(const char* keys = ""*"", Option_t* option = """"); Draw map of objects in this file. void Flush(); Synchronize a file's in-core and on-disk states. Bool_t FlushWriteCache(); Flush the write cache if active.; Return kTRUE in case of error. void FillBuffer(char*& buffer); Encode file output buffer.; The file output buffer contains only the FREE data record. Int_t GetBestBuffer() const; Return the best buffer size of objects on this file.; The best buffer size is estimated based on the current mean value; and standard deviation of all objects written so far to this file.; Returns mean value + one standard deviation. Float_t GetCompressionFactor(); Return the file compression factor.; Add total number of compressed/uncompressed bytes for each key.; return ratio of the two. Int_t GetErrno() const; Method returning errno. Is overriden in TRFIOFile. void ResetErrno() const; Method resetting the errno. Is overridden in TRFIOFile. TFileCacheRead * GetCacheRead() const; Return a pointer to the current read cache. TFileCacheWrite * GetCacheWrite() const; Return a pointer to the current write cache. Int_t GetRecordHeader(char* buf, Long64_t first, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header starting at position first.; Maxbytes bytes are read into buf the function reads nread bytes; where nread is the minimum of maxbytes and the number of bytes; before the end of file. The function returns nread.; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16. Long64_t GetSize() const; Returns the current file size. Returns -1 in case the file could not; be stat'ed. const TList * GetStreamerInfoCache(); Returns the cached list of StreamerInfos used in this file. TLi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:29417,cache,cache,29417,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,3,['cache'],['cache']
Performance,"be displayed by SaveGraph as they are; 134/// effectively optimized away from the computation graph.; 135///; 136/// Note that SaveGraph is not thread-safe and must not be called concurrently from different threads.; 137// clang-format on; 138template <typename NodeType>; 139void SaveGraph(NodeType node, const std::string &outputFile); 140{; 141 ROOT::Internal::RDF::GraphDrawing::GraphCreatorHelper helper;; 142 std::string dotGraph = helper.RepresentGraph(node);; 143 ; 144 std::ofstream out(outputFile);; 145 if (!out.is_open()) {; 146 throw std::runtime_error(""Could not open output file \"""" + outputFile + ""\""for reading"");; 147 }; 148 ; 149 out << dotGraph;; 150 out.close();; 151}; 152 ; 153// clang-format off; 154/// Cast a RDataFrame node to the common type ROOT::RDF::RNode; 155/// \param[in] node Any node of a RDataFrame graph; 156// clang-format on; 157template <typename NodeType>; 158RNode AsRNode(NodeType node); 159{; 160 return node;; 161}; 162 ; 163// clang-format off; 164/// Trigger the event loop of multiple RDataFrames concurrently; 165/// \param[in] handles A vector of RResultHandles; 166/// \return The number of distinct computation graphs that have been processed; 167///; 168/// This function triggers the event loop of all computation graphs which relate to the; 169/// given RResultHandles. The advantage compared to running the event loop implicitly by accessing the; 170/// RResultPtr is that the event loops will run concurrently. Therefore, the overall; 171/// computation of all results is generally more efficient.; 172/// It should be noted that user-defined operations (e.g., Filters and Defines) of the different RDataFrame graphs are assumed to be safe to call concurrently.; 173///; 174/// ~~~{.cpp}; 175/// ROOT::RDataFrame df1(""tree1"", ""file1.root"");; 176/// auto r1 = df1.Histo1D(""var1"");; 177///; 178/// ROOT::RDataFrame df2(""tree2"", ""file2.root"");; 179/// auto r2 = df2.Sum(""var2"");; 180///; 181/// // RResultPtr -> RResultHandle conversion is autom",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8hxx_source.html:7145,concurren,concurrently,7145,doc/master/RDFHelpers_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html,1,['concurren'],['concurrently']
Performance,"be done if there is a parallel world. Activating navigation will automatically close the parallel geometry. ; Definition at line 4288 of file TGeoManager.cxx. ◆ SetUserPaintVolume(). void TGeoManager::SetUserPaintVolume ; (; TGeoVolume * ; vol). inline . Definition at line 235 of file TGeoManager.h. ◆ SetVerboseLevel(). void TGeoManager::SetVerboseLevel ; (; Int_t ; vl). static . Return current verbosity level (static function). ; Definition at line 4074 of file TGeoManager.cxx. ◆ SetVisDensity(). void TGeoManager::SetVisDensity ; (; Double_t ; density = 0.01). Set density threshold. ; Volumes with densities lower than this become transparent. ; Definition at line 2449 of file TGeoManager.cxx. ◆ SetVisibility(). void TGeoManager::SetVisibility ; (; TObject * ; obj, . Bool_t ; vis . ). Set visibility for a volume. ; Definition at line 1060 of file TGeoManager.cxx. ◆ SetVisLevel(). void TGeoManager::SetVisLevel ; (; Int_t ; level = 3). set default level down to which visualization is performed ; Definition at line 2459 of file TGeoManager.cxx. ◆ SetVisOption(). void TGeoManager::SetVisOption ; (; Int_t ; option = 0). set drawing mode : . option=0 (default) all nodes drawn down to vislevel; option=1 leaves and nodes at vislevel drawn; option=2 path is drawn; option=4 visibility changed . Definition at line 2426 of file TGeoManager.cxx. ◆ SetVolumeAttribute(). void TGeoManager::SetVolumeAttribute ; (; const char * ; name, . const char * ; att, . Int_t ; val . ). Set volume attributes in G3 style. ; Definition at line 2308 of file TGeoManager.cxx. ◆ SizeOf(). ULong_t TGeoManager::SizeOf ; (; const TGeoNode * ; node, . Option_t * ; option . ). virtual . computes the total size in bytes of the branch starting with node. ; The option can specify if all the branch has to be parsed or only the node ; Definition at line 3926 of file TGeoManager.cxx. ◆ SortOverlaps(). void TGeoManager::SortOverlaps ; (; ). Sort overlaps by decreasing overlap distance. Extrusions comes first. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:140077,perform,performed,140077,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['perform'],['performed']
Performance,"be done like:. TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N);. where SLICE is the name of the new family representing all slices and 1 is the; slicing axis. The meaning of the axis index is the following: for all volumes; having shapes like box, trd1, trd2, trap, gtra or para - 1,2,3 means X,Y,Z; for; tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and; pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi.; In fact, the division operation has the same effect as positioning volumes; in a given order inside the divided container - the advantage being that the; navigation in such a structure is much faster. When a volume is divided, a; volume family corresponding to the slices is created. In case all slices can; be represented by a single shape, only one volume is added to the family and; positioned N times inside the divided volume, otherwise, each slice will be; represented by a distinct volume in the family.; Divisions can be also performed in a given range of one axis. For that, one; have to specify also the starting coordinate value and the step:. TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N, start, step);. A check is always done on the resulting division range : if not fitting into; the container limits, an error message is posted. If we will browse the divided; volume we will notice that it will contain N nodes starting with index 1 upto; N. The first one has the lower X limit at START position, while the last one; will have the upper X limit at START+N*STEP. The resulting slices cannot; be positioned inside an other volume (they are by default positioned inside the; divided one) but can be further divided and may contain other volumes:. TGeoVolume *slicey = slicex->Divide(""SLICEY"", 2, N1);; slicey->AddNode(other_vol, index, some_matrix);. When doing that, we have to remember that SLICEY represents a family, therefore; all members of the family will be divided on Y and the other volume will be; added as node insi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:14305,perform,performed,14305,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,9,['perform'],['performed']
Performance,"be recalculated; if the observable p changes. RooCachedReal(const RooCachedReal& other, const char* name = 0); Copy constructor. ~RooCachedReal(); Destructor. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Update contents of cache histogram by resampling the input function. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the external input p.d.f that are not one of; the cache observables. If this p.d.f is operated in automatic mode,; return the parameters of the external input p.d.f. RooCachedReal(); {}. TObject* clone(const char* newname) const; { return new RooCachedReal(*this,newname); }. void setCdfBoundaries(Bool_t flag); If flag is true the RooHistFunc that represent the cache histogram; will use special boundary conditions for use with cumulative distribution; functions: at the lower bound the function is forced to converge at zero and the upper; bound is the function is forced to converge at 1.0. Bool_t getCdfBoundaries() const; If true the c.d.f boundary mode is active. const char* inputBaseName() const; Return base name for caches, i.e. the name of the cached function. Double_t evaluate() const; Dummy evaluate, it is never called. const char* payloadUniqueSuffix() const; { return func.arg().aggregateCacheUniqueSuffix() ; }. » Last changed: Thu Sep 23 19:59:12 2010 » Last generated: 2010-09-23 19:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCachedReal.html:36209,cache,cache,36209,root/html528/RooCachedReal.html,https://root.cern,https://root.cern/root/html528/RooCachedReal.html,3,['cache'],"['cache', 'cached', 'caches']"
Performance,"be used on the client).; Returns 0 in case of success and -1 in case of error. Int_t BuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0, Int_t chkveropt = kCheckROOT); Build specified package on the client. Executes the PROOF-INF/BUILD.sh; script if it exists on the client.; If opt == 0, both the preparation and building phases are run.; If opt == 1, only the preparation phase (asserting and, eventually, downloading; of the package) is done; '*path' contains the full path to the; package to be passed in the next call; If opt == 2, only the building phase is run using *path .; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kBuildPackage; case). Keep in sync in case of changes. Int_t LoadPackage(const char* package, Bool_t notOnClient = kFALSE, TList* loadopts = 0, TList* workers = 0); Load specified package. Executes the PROOF-INF/SETUP.C script; on all active nodes. If notOnClient = true, don't load package; on the client. The default is to load the package also on the client.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t LoadPackageOnClient(const char* package, TList* loadopts = 0); Load specified package in the client. Executes the PROOF-INF/SETUP.C; script on the client. Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kLoadPackage; case). Keep in sync in case of changes.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackage(const char* package); Unload specified package.; Returns 0 in case of success an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:74639,load,load,74639,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,2,['load'],['load']
Performance,"bed by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends the cluster range information stored in 'fromtree' to this tree, including the value of fAutoFlush. ;  ; virtual void KeepCircular ();  Keep a maximum of fMaxEntries in memory. ;  ; void MoveReadCache (TFile *src, TDirectory *dir);  Move a cache from a file to the current file in dir. ;  ; Int_t SetBranchAddressImp (TBranch *branch, void *addr, TBranch **ptr);  Change branch address, dealing with clone trees properly. ;  ; Int_t SetCacheSizeAux (bool autocache=true, Long64_t cacheSize=0);  Set the size of the file cache and create it if possible. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Double_t * fArgs;  ! [fNvar] Array of variables ;  ; Int_t fNvar;  Number of columns. ;  ;  Protected Attributes inherited from TTree; TList * fAliases;  List of aliases for expressions based on the tree branches. ;  ; std::atomic< UInt_t > fAllocationCount {0};  indicates basket should be resized to exact memory usage, but causes significant ;  ; Long64_t fAutoFlush;  Auto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced. ;  ; Long64_t fAutoSave;  Autosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced. ;  ; TObjArray fBranches;  List of Branches. ;  ; TBranchRef * fBranchRef;  Branch supporting the TRefTable (if any) ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNtupleD.html:41393,cache,cacheSize,41393,doc/master/classTNtupleD.html,https://root.cern,https://root.cern/doc/master/classTNtupleD.html,2,['cache'],"['cache', 'cacheSize']"
Performance,"bed by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends the cluster range information stored in 'fromtree' to this tree, including the value of fAutoFlush. ;  ; virtual void KeepCircular ();  Keep a maximum of fMaxEntries in memory. ;  ; void MoveReadCache (TFile *src, TDirectory *dir);  Move a cache from a file to the current file in dir. ;  ; Int_t SetBranchAddressImp (TBranch *branch, void *addr, TBranch **ptr);  Change branch address, dealing with clone trees properly. ;  ; Int_t SetCacheSizeAux (bool autocache=true, Long64_t cacheSize=0);  Set the size of the file cache and create it if possible. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Float_t * fArgs;  ! [fNvar] Array of variables ;  ; Int_t fNvar;  Number of columns. ;  ;  Protected Attributes inherited from TTree; TList * fAliases;  List of aliases for expressions based on the tree branches. ;  ; std::atomic< UInt_t > fAllocationCount {0};  indicates basket should be resized to exact memory usage, but causes significant ;  ; Long64_t fAutoFlush;  Auto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced. ;  ; Long64_t fAutoSave;  Autosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced. ;  ; TObjArray fBranches;  List of Branches. ;  ; TBranchRef * fBranchRef;  Branch supporting the TRefTable (if any) ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNtuple.html:41432,cache,cacheSize,41432,doc/master/classTNtuple.html,https://root.cern,https://root.cern/doc/master/classTNtuple.html,2,['cache'],"['cache', 'cacheSize']"
Performance,"bed by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends the cluster range information stored in 'fromtree' to this tree, including the value of fAutoFlush. ;  ; virtual void KeepCircular ();  Keep a maximum of fMaxEntries in memory. ;  ; void MoveReadCache (TFile *src, TDirectory *dir);  Move a cache from a file to the current file in dir. ;  ; Int_t SetBranchAddressImp (TBranch *branch, void *addr, TBranch **ptr);  Change branch address, dealing with clone trees properly. ;  ; Int_t SetCacheSizeAux (bool autocache=true, Long64_t cacheSize=0);  Set the size of the file cache and create it if possible. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TList * fAliases;  List of aliases for expressions based on the tree branches. ;  ; std::atomic< UInt_t > fAllocationCount {0};  indicates basket should be resized to exact memory usage, but causes significant ;  ; Long64_t fAutoFlush;  Auto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced. ;  ; Long64_t fAutoSave;  Autosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced. ;  ; TObjArray fBranches;  List of Branches. ;  ; TBranchRef * fBranchRef;  Branch supporting the TRefTable (if any) ;  ; bool fCacheDoAutoInit;  ! true if cache auto creation or resize check is needed ;  ; bool fCacheDoClusterPrefetch;  ! true if cache",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:59192,cache,cacheSize,59192,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,4,['cache'],"['cache', 'cacheSize']"
Performance,"bed by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends the cluster range information stored in 'fromtree' to this tree, including the value of fAutoFlush. ;  ; virtual void KeepCircular ();  Keep a maximum of fMaxEntries in memory. ;  ; void MoveReadCache (TFile *src, TDirectory *dir);  Move a cache from a file to the current file in dir. ;  ; Int_t SetBranchAddressImp (TBranch *branch, void *addr, TBranch **ptr);  Change branch address, dealing with clone trees properly. ;  ; Int_t SetCacheSizeAux (bool autocache=true, Long64_t cacheSize=0);  Set the size of the file cache and create it if possible. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; bool fBranchChecked;  ; Int_t fCurrentEntry;  ; TString fDB;  ; TString fInsertQuery;  ; TString fQuery;  ; TSQLResult * fResult;  ; TSQLRow * fRow;  ; TSQLServer * fServer;  ; TString fTable;  ; TSQLTableInfo * fTableInfo;  ;  Protected Attributes inherited from TTree; TList * fAliases;  List of aliases for expressions based on the tree branches. ;  ; std::atomic< UInt_t > fAllocationCount {0};  indicates basket should be resized to exact memory usage, but causes significant ;  ; Long64_t fAutoFlush;  Auto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced. ;  ; Long64_t fAutoSave;  Autosave tree when fAutoSave entries written or -fAutoSave (compressed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeSQL.html:41375,cache,cacheSize,41375,doc/master/classTTreeSQL.html,https://root.cern,https://root.cern/doc/master/classTTreeSQL.html,2,['cache'],"['cache', 'cacheSize']"
Performance,"bed by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends the cluster range information stored in 'fromtree' to this tree, including the value of fAutoFlush. ;  ; virtual void KeepCircular ();  Keep a maximum of fMaxEntries in memory. ;  ; void MoveReadCache (TFile *src, TDirectory *dir);  Move a cache from a file to the current file in dir. ;  ; Int_t SetBranchAddressImp (TBranch *branch, void *addr, TBranch **ptr);  Change branch address, dealing with clone trees properly. ;  ; Int_t SetCacheSizeAux (bool autocache=true, Long64_t cacheSize=0);  Set the size of the file cache and create it if possible. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; bool fCanDeleteRefs;  ! If true, TProcessIDs are deleted when closing a file ;  ; TFile * fFile;  ! Pointer to current file (We own the file). ;  ; TObjArray * fFiles;  -> List of file names containing the trees (TChainElement, owned) ;  ; bool fGlobalRegistration;  ! if true, bypass use of global lists ;  ; Int_t fNtrees;  Number of trees. ;  ; TChain * fProofChain;  ! chain proxy when going to be processed by PROOF ;  ; TList * fStatus;  -> List of active/inactive branches (TChainElement, owned) ;  ; TTree * fTree;  ! Pointer to current tree (Note: We do not own this tree.) ;  ; Int_t fTreeNumber;  ! Current Tree number in fTreeOffset table ;  ; Long64_t * fTreeOffset;  [fTreeOffsetLen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:45281,cache,cacheSize,45281,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,4,['cache'],"['cache', 'cacheSize']"
Performance,"bed by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends the cluster range information stored in 'fromtree' to this tree, including the value of fAutoFlush. ;  ; virtual void KeepCircular ();  Keep a maximum of fMaxEntries in memory. ;  ; void MoveReadCache (TFile *src, TDirectory *dir);  Move a cache from a file to the current file in dir. ;  ; Int_t SetBranchAddressImp (TBranch *branch, void *addr, TBranch **ptr);  Change branch address, dealing with clone trees properly. ;  ; Int_t SetCacheSizeAux (bool autocache=true, Long64_t cacheSize=0);  Set the size of the file cache and create it if possible. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Attributes inherited from TTree; static Int_t fgBranchStyle = 1;  Old/New branch style. ;  ; static Long64_t fgMaxTreeSize = 100000000000LL;  Maximum size of a file containing a Tree. ;  . #include <THbookTree.h>. Inheritance diagram for THbookTree:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ THbookTree() [1/2]. THbookTree::THbookTree ; (; ). default constructor ; Definition at line 61 of file THbookTree.cxx. ◆ THbookTree() [2/2]. THbookTree::THbookTree ; (; const char * ; name, . Int_t ; id . ). constructor ; Definition at line 73 of file THbookTree.cxx. ◆ ~THbookTree(). THbookTree::~THbookTree ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHbookTree.html:48826,cache,cacheSize,48826,doc/master/classTHbookTree.html,https://root.cern,https://root.cern/doc/master/classTHbookTree.html,2,['cache'],"['cache', 'cacheSize']"
Performance,"bed by the last 3 parameters matches the content of the branch. ;  ; Long64_t GetCacheAutoSize (bool withDefault=false);  Used for automatic sizing of the cache. ;  ; virtual TLeaf * GetLeafImpl (const char *branchname, const char *leafname);  Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of friend trees. ;  ; char GetNewlineValue (std::istream &inputStream);  Determine which newline this file is using. ;  ; void ImportClusterRanges (TTree *fromtree);  Appends the cluster range information stored in 'fromtree' to this tree, including the value of fAutoFlush. ;  ; virtual void KeepCircular ();  Keep a maximum of fMaxEntries in memory. ;  ; void MoveReadCache (TFile *src, TDirectory *dir);  Move a cache from a file to the current file in dir. ;  ; Int_t SetBranchAddressImp (TBranch *branch, void *addr, TBranch **ptr);  Change branch address, dealing with clone trees properly. ;  ; Int_t SetCacheSizeAux (bool autocache=true, Long64_t cacheSize=0);  Set the size of the file cache and create it if possible. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Attributes inherited from TTree; static Int_t fgBranchStyle = 1;  Old/New branch style. ;  ; static Long64_t fgMaxTreeSize = 100000000000LL;  Maximum size of a file containing a Tree. ;  . #include <TProofChain.h>. Inheritance diagram for TProofChain:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ anonymous enum. anonymous enum. EnumeratorkOwnsChain . Definition at line 35 of file TProofChain.h. Constructor & Destructor Documentation. ◆ TProofChain() [1/3]. TProofChain::TProofChain ; (; ). Crates a new PROOF chain proxy. ; Definition at line 35 of file TProofChain.cxx. ◆ TProofChain() [2/3]. TProofChain::TP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofChain.html:53474,cache,cacheSize,53474,doc/master/classTProofChain.html,https://root.cern,https://root.cern/doc/master/classTProofChain.html,2,['cache'],"['cache', 'cacheSize']"
Performance,"been invalidated by server value change. Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. const TNamed* namePtr() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE). void attachToVStore(RooVectorDataStore& vstore). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). void setLocalNoDirtyInhibit(Bool_t flag) const; { _localNoInhibitDirty = flag ; }. Bool_t localNoDirtyInhibit() const; { return _localNoInhibitDirty ; }. » Last changed: Sat Jun 20 17:29:22 2015 » Last generated: 2015-06-20 17:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsArg.html:46021,cache,cacheUniqueSuffix,46021,root/html604/RooAbsArg.html,https://root.cern,https://root.cern/root/html604/RooAbsArg.html,1,['cache'],['cacheUniqueSuffix']
Performance,"been invalidated by server value change. Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. const TNamed* namePtr() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE). void attachToVStore(RooVectorDataStore& vstore). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). void setLocalNoDirtyInhibit(Bool_t flag) const; { _localNoInhibitDirty = flag ; }. Bool_t localNoDirtyInhibit() const; { return _localNoInhibitDirty ; }. » Last changed: Sun Jun 28 16:37:40 2015 » Last generated: 2015-06-28 16:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsArg.html:44325,cache,cacheUniqueSuffix,44325,root/html534/RooAbsArg.html,https://root.cern,https://root.cern/root/html534/RooAbsArg.html,1,['cache'],['cacheUniqueSuffix']
Performance,"been invalidated by server value change. Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. const TNamed* namePtr() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE). void attachToVStore(RooVectorDataStore& vstore). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). void setLocalNoDirtyInhibit(Bool_t flag) const; { _localNoInhibitDirty = flag ; }. Bool_t localNoDirtyInhibit() const; { return _localNoInhibitDirty ; }. » Last changed: Tue Jun 30 14:29:52 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsArg.html:46021,cache,cacheUniqueSuffix,46021,root/html602/RooAbsArg.html,https://root.cern,https://root.cern/root/html602/RooAbsArg.html,1,['cache'],['cacheUniqueSuffix']
Performance,"bel, Bool_t printError = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual Double_tvolume(const char* rangeName) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCategoryLValue.html:16100,cache,cache,16100,root/html526/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html526/RooAbsCategoryLValue.html,1,['cache'],['cache']
Performance,"belPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_t_valueConstant value of self; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooConstVar(const char* name, const char* title, Double_t value); Constructor with value; _fast = kTRUE ;. RooConstVar(const RooConstVar& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooConstVar.html:35894,cache,cache,35894,root/html602/RooConstVar.html,https://root.cern,https://root.cern/root/html602/RooConstVar.html,4,['cache'],['cache']
Performance,"ber Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const override;  If this pdf is operated with a fixed set of observables, return the subset of the fixed observables that are actual dependents of the external input p.d.f. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  If this p.d.f is operated with a fixed set of observables, return all variables of the external input p.d.f that are not one of the cache observables. ;  ; FuncCacheElem * createCache (const RooArgSet *nset) const override;  Interface function to create an internal cache object that represent each cached function configuration. ;  ; double evaluate () const override;  Dummy evaluate, it is never called. ;  ; void fillCacheObject (FuncCacheElem &cacheFunc) const override;  Update contents of cache histogram by resampling the input function. ;  ; const char * inputBaseName () const override;  Return base name for caches, i.e. the name of the cached function. ;  ; void operModeHook () override;  ; const char * payloadUniqueSuffix () const override;  ;  Protected Member Functions inherited from RooAbsCachedReal; virtual const char * binningName () const;  ; TString cacheNameSuffix (const RooArgSet &nset) const;  Construct unique suffix name for cache p.d.f object. ;  ; FuncCacheElem * getCache (const RooArgSet *nset) const;  Retrieve cache corresponding to observables in nset. ;  ;  Protected Member Functions inher",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:49557,cache,cache,49557,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,1,['cache'],['cache']
Performance,"ber Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const override;  If this pdf is operated with a fixed set of observables, return the subset of the fixed observables that are actual dependents of the external input p.d.f. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  If this p.d.f is operated with a fixed set of observables, return all variables of the external input p.d.f that are not one of the cache observables. ;  ; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; void fillCacheObject (PdfCacheElem &cachePdf) const override;  Update contents of cache histogram by resampling the input p.d.f. ;  ; const char * inputBaseName () const override;  Return the base name for cache objects, in this case the name of the cached p.d.f. ;  ; const char * payloadUniqueSuffix () const override;  ;  Protected Member Functions inherited from RooAbsCachedPdf; virtual const char * binningName () const;  ; std::string cacheNameSuffix (const RooArgSet &nset) const;  Construct string with unique suffix for cache objects based on observable names that define cache configuration. ;  ; virtual PdfCacheElem * createCache (const RooArgSet *nset) const;  ; void disableCache (bool flag);  ; void doEval (RooFit::EvalContext &) const override;  Base function for computing multiple values of a RooAbsReal. ;  ; PdfCacheElem ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:61019,cache,cache,61019,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,1,['cache'],['cache']
Performance,"ber Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; void doEval (RooFit::EvalContext &) const override;  Base function for computing multiple values of a RooAbsReal. ;  ; double evaluate () const override;  Note: P_0^0 = 1, so P_l^m = P_l^m P_0^0. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLegendre.html:48378,cache,cached,48378,doc/master/classRooLegendre.html,https://root.cern,https://root.cern/doc/master/classRooLegendre.html,2,['cache'],"['cache', 'cached']"
Performance,"ber Functions |; Static Public Member Functions |; Protected Member Functions |; Private Member Functions |; Private Attributes |; Friends |; List of all members ; RooBinSamplingPdf Class Reference. ; The RooBinSamplingPdf is supposed to be used as an adapter between a continuous PDF and a binned distribution. ; When RooFit is used to fit binned data, and the PDF is continuous, it takes the probability density at the bin centre as a proxy for the probability averaged (integrated) over the entire bin. This is correct only if the second derivative of the function vanishes, though. This is shown in the plots below.; For PDFs that have larger curvatures, the RooBinSamplingPdf can be used. It integrates the PDF in each bin using an adaptive integrator. This usually requires 21 times more function evaluations, but significantly reduces biases due to better sampling of the PDF. The integrator can be accessed from the outside using integrator(). This can be used to change the integration rules, so less/more function evaluations are performed. The target precision of the integrator can be set in the constructor. How to use it; There are two ways to use this class:; Manually wrap a PDF: RooBinSamplingPdf binSampler(""<name>"", ""title"", <binned observable of PDF>, <original PDF> [, <precision for integrator>]);; binSampler.fitTo(data);; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; RooBinSamplingPdfThe RooBinSamplingPdf is supposed to be used as an adapter between a continuous PDF and a binned dist...Definition RooBinSamplingPdf.h:28; RooBinSamplingPdf::integratorstd::unique_ptr< ROOT::Math::IntegratorOneDim > & integrator() constDirect access to the unique_ptr holding the integrator that's used to sample the bins.Definition RooBinSamplingPdf.cxx:278; RooBinSamplingPdf::observableconst RooAbsReal & observable() constDefini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:1197,perform,performed,1197,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['perform'],['performed']
Performance,"ber function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. THashTable * GetClassShortTypedefHash(); Return the class' names massaged with TClassEdit::ShortType with kDropStlDefault. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. VoidFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. VoidFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TRealData* GetRealData(const char* name) const; -- Return pointer to TRealData element with name ""name"". Name can be a data member in the class itself,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. const char * GetSharedLibs(); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClass.html:27507,load,loading,27507,root/html528/TClass.html,https://root.cern,https://root.cern/root/html528/TClass.html,4,['load'],['loading']
Performance,ber of processors to use in parallel calculation mode; Int_tRooAbsTestStatistic::_nEventsTotal number of events in test statistic calculation; Int_tRooAbsTestStatistic::_nGofNumber of sub-contexts; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_optimized!; RooAbsData*_origDataOriginal data; RooAbsReal*_origFuncOriginal function; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood; Bool_t_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsOptTestStatistic.html:41923,cache,cache,41923,root/html602/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html,2,['cache'],['cache']
Performance,"ber of template arguments of the function template described by ft_info. ;  ; void FuncTempInfo_Title (FuncTempInfo_t *, TString &name) const final;  Return the comments associates with this function template. ;  ; bool FunctionDeclId_IsMethod (DeclId_t fdeclid) const;  ; Int_t GenerateDictionary (const char *classes, const char *includes="""", const char *options=nullptr) final;  Generate the dictionary for the C++ classes listed in the first argument (in a semi-colon separated list). ;  ; TClass * GenerateTClass (ClassInfo_t *classinfo, Bool_t silent=kFALSE) final;  Generate a TClass for the given class. ;  ; TClass * GenerateTClass (const char *classname, Bool_t emulation, Bool_t silent=kFALSE) final;  Generate a TClass for the given class. ;  ; void GenericError (const char *error) const final;  Let the interpreter issue a generic error, and set its error state. ;  ; void * GetAutoLoadCallBack () const final;  ; TClass * GetClass (const std::type_info &typeinfo, Bool_t load) const final;  Demangle the name (from the typeinfo) and then request the class via the usual name based interface (TClass::GetClass). ;  ; const char * GetClassSharedLibs (const char *cls, bool skipCore=true) final;  Get the list of shared libraries containing the code for class cls. ;  ; const char * GetCurrentMacroName () const final;  Return the file name of the currently interpreted file, included or not. ;  ; DeclId_t GetDataMember (ClassInfo_t *cl, const char *name) const final;  Return pointer to cling Decl of global/static variable that is located at the address given by addr. ;  ; DeclId_t GetDataMemberAtAddr (const void *addr) const final;  Return pointer to cling DeclId for a data member with a given name. ;  ; DeclId_t GetDataMemberWithValue (const void *ptrvalue) const final;  NOT IMPLEMENTED. ;  ; DeclId_t GetDeclId (CallFunc_t *info) const final;  Return a unique identifier of the declaration represented by the CallFunc. ;  ; DeclId_t GetDeclId (ClassInfo_t *info) const final;  R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:15563,load,load,15563,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['load'],['load']
Performance,"ber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxyalphaInterpolation parameter; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdf1First input shape; RooRealProxypdf2Second input shape; RooRealProxyxObservable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooIntegralMorph(const char* name, const char* title, RooAbsReal& _pdf1, RooAbsReal& _pdf2, RooAbsReal& _x, RooAbsReal& _alpha, Bool_t cacheAlpha = kFALSE); Constructor with observables x, pdf shapes pdf1 and pdf2 which represent; the shapes at the end points of the interpolation parameter alpha; If doCacheAlpha is true, a two-dimensional cache is constructed in; both alpha and x. RooIntegralMorph(const RooIntegralMorph& other, const char* name = 0); Copy constructor. RooArgSet* actualObservables(const RooArgSet& nset) const; Observable to be cached for given choice of normalization.; Returns the 'x' observable unless doCacheAlpha is set in which; case a set with both x and alpha. RooArgSet* actualParameters(const RooArgSet& nset) const; Parameters of the cache. Returns parameters of both pdf1 and pdf2; and parameter cache, in case doCacheAlpha is not set. const char* inputBaseName() const; Return base name component for cache components in this case; a string encoding the names of both end point p.d.f.s. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Fill the cache with the interpolated shape. RooAbsCachedPdf::PdfCacheElem* createCache(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooIntegralMorph.html:50653,cache,cacheAlpha,50653,root/html602/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html602/RooIntegralMorph.html,4,['cache'],"['cache', 'cacheAlpha']"
Performance,"ber points to (or both are nullptr). ;  ; double normalizeWithNaNPacking (double rawVal, double normVal) const;  ; RooPlot * plotOn (RooPlot *frame, PlotOpt o) const override;  Plot oneself on 'frame'. ;  ; Int_t * randomizeProtoOrder (Int_t nProto, Int_t nGen, bool resample=false) const;  Return lookup table with randomized order for nProto prototype events. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  The cache manager. ;  ; virtual bool syncNormalization (const RooArgSet *dset, bool adjustProxies=true) const;  Verify that the normalization integral cached with this PDF is valid for given set of normalization observables. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; virtual double evaluate () const =0;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:65427,cache,cached,65427,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,4,['cache'],"['cache', 'cached']"
Performance,"ber points to (or both are nullptr). ;  ; double normalizeWithNaNPacking (double rawVal, double normVal) const;  ; RooPlot * plotOn (RooPlot *frame, PlotOpt o) const override;  Plot oneself on 'frame'. ;  ; Int_t * randomizeProtoOrder (Int_t nProto, Int_t nGen, bool resample=false) const;  Return lookup table with randomized order for nProto prototype events. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  The cache manager. ;  ; virtual bool syncNormalization (const RooArgSet *dset, bool adjustProxies=true) const;  Verify that the normalization integral cached with this PDF is valid for given set of normalization observables. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBMixDecay.html:70016,cache,cached,70016,doc/master/classRooBMixDecay.html,https://root.cern,https://root.cern/doc/master/classRooBMixDecay.html,124,['cache'],"['cache', 'cached']"
Performance,"ber; theta1 polar angle for axis X; phi1 azimuthal angle for axis X; theta2 polar angle for axis Y; phi2 azimuthal angle for axis Y; theta3 polar angle for axis Z; phi3 azimuthal angle for axis Z . Definition at line 497 of file TGeoBuilder.cxx. ◆ Medium(). TGeoMedium * TGeoBuilder::Medium ; (; const char * ; name, . Int_t ; numed, . Int_t ; nmat, . Int_t ; isvol, . Int_t ; ifield, . Double_t ; fieldm, . Double_t ; tmaxfd, . Double_t ; stemax, . Double_t ; deemax, . Double_t ; epsil, . Double_t ; stmin . ). Create tracking medium. . numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm); ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking performed with g3helix; ifield = 3 if tracking performed with g3helx3. . Definition at line 568 of file TGeoBuilder.cxx. ◆ Mixture() [1/2]. TGeoMaterial * TGeoBuilder::Mixture ; (; const char * ; name, . Double_t * ; a, . Double_t * ; z, . Double_t ; dens, . Int_t ; nelem, . Double_t * ; wmat, . Int_t ; uid . ). Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem materials defined by arrays A,Z and WMAT, having an unique id. ; Definition at line 537 of file TGeoBuilder.cxx. ◆ Mixture() [2/2]. TGeoMaterial * TGeoBuilder::Mixture ; (; const char * ; name, . Float_t * ; a, . Float_t * ; z, . Double_t ; dens, . Int_t ; nelem, . Float_t * ; wmat, . Int_t ; uid . ). Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem materials defined by arrays A,Z and WMAT, having an unique id. ; Definition at line 521 of file TGeoBuilder.cxx. ◆ Node() [1/2]. void TGeoBuilder::Node ; (; const char * ; name, . Int_t ; nr, . const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBuilder.html:29312,perform,performed,29312,doc/master/classTGeoBuilder.html,https://root.cern,https://root.cern/doc/master/classTGeoBuilder.html,3,['perform'],['performed']
Performance,"berStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; virtual Bool_t HasCounter () const;  ; virtual void Init (TVirtualStreamerInfo *obj=nullptr);  Initliaze the element. ;  ; TClass * IsA () const override;  ; virtual Bool_t IsaPointer () const;  ; virtual Bool_t IsBase () const;  Return kTRUE if the element represent a base class. ;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ;  ; virtual Bool_t IsTransient () const;  Return kTRUE if the element represent an entity that is not written to the disk (transient members, cache allocator/deallocator, etc.) ;  ; void ls (Option_t *option="""") const override;  Print the content of the element. ;  ; virtual void SetArrayDim (Int_t dim);  Set number of array dimensions. ;  ; virtual void SetMaxIndex (Int_t dim, Int_t max);  set maximum index for array with dimension dim ;  ; virtual void SetNewClass (TClass *cl);  ; virtual void SetNewType (Int_t dtype);  ; virtual void SetOffset (Int_t offset);  ; virtual void SetSize (Int_t dsize);  ; virtual void SetStreamer (TMemberStreamer *streamer);  set pointer to Streamer function for this element ;  ; virtual void SetTObjectOffset (Int_t tobjoffset);  ; virtual void SetType (Int_t dtype);  ; virtual void SetTypeName (const char *name);  ; void Streamer (TBuffer &) override;  Stream an object of class TStreamerElement. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Update (const TClass *oldClass, TClass *newClass);  function c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerArtificial.html:3370,cache,cache,3370,doc/master/classTStreamerArtificial.html,https://root.cern,https://root.cern/doc/master/classTStreamerArtificial.html,2,['cache'],['cache']
Performance,"berStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; virtual Bool_t HasCounter () const;  ; virtual void Init (TVirtualStreamerInfo *obj=nullptr);  Initliaze the element. ;  ; TClass * IsA () const override;  ; virtual Bool_t IsaPointer () const;  ; virtual Bool_t IsBase () const;  Return kTRUE if the element represent a base class. ;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ;  ; virtual Bool_t IsTransient () const;  Return kTRUE if the element represent an entity that is not written to the disk (transient members, cache allocator/deallocator, etc.) ;  ; void ls (Option_t *option="""") const override;  Print the content of the element. ;  ; virtual void SetArrayDim (Int_t dim);  Set number of array dimensions. ;  ; virtual void SetMaxIndex (Int_t dim, Int_t max);  set maximum index for array with dimension dim ;  ; virtual void SetNewClass (TClass *cl);  ; virtual void SetNewType (Int_t dtype);  ; virtual void SetOffset (Int_t offset);  ; virtual void SetSize (Int_t dsize);  ; virtual void SetStreamer (TMemberStreamer *streamer);  set pointer to Streamer function for this element ;  ; virtual void SetTObjectOffset (Int_t tobjoffset);  ; virtual void SetType (Int_t dtype);  ; virtual void SetTypeName (const char *name);  ; void Streamer (TBuffer &) override;  Stream an object of class TStreamerElement. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerBasicType.html:3533,cache,cache,3533,doc/master/classTStreamerBasicType.html,https://root.cern,https://root.cern/doc/master/classTStreamerBasicType.html,1,['cache'],['cache']
Performance,"bers ; TViewPubFunctions Class Reference. ; View implementing the TList interface and giving access all the TFunction describing public methods in a class and all its base classes without caching any of the TFunction pointers. ; Adding to this collection directly is prohibited. Iteration can only be done via the TIterator interfaces. ; Definition at line 28 of file TViewPubFunctions.h. Public Member Functions;  TViewPubFunctions (TClass *cl=nullptr);  Usual constructor. ;  ; virtual ~TViewPubFunctions ();  Default destructor. ;  ; TObject * At (Int_t idx) const override;  Returns the object at position idx. Returns 0 if idx is out of range. ;  ; TObject * FindObject (const char *name) const override;  Find an object in this list using its name. ;  ; TObject * FindObject (const TObject *obj) const override;  Find an object in this list using the object's IsEqual() member function. ;  ; virtual const TList * GetListOfClasses () const;  ; Int_t GetSize () const override;  Return the total number of public methods (currently loaded in the list of functions) in this class and all its base classes. ;  ; void Load ();  Load all the functions known to the interpreter for the scope 'fClass' and all its bases classes. ;  ; TIterator * MakeIterator (Bool_t dir=kIterForward) const override;  Return a list iterator. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *obj, Option_t *opt);  ; TClass * IsA () const override;  ; Bool_t IsAscending ();  ; TObject * Remove (const TObjLinkPtr_t &lnk);  ; void RemoveLast () override;  Remove the last object of the list. ;  ; virtual void Sort (Bool_t order=kSortAscending);  Sort linked list. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void Streamer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTViewPubFunctions.html:1308,load,loaded,1308,doc/master/classTViewPubFunctions.html,https://root.cern,https://root.cern/doc/master/classTViewPubFunctions.html,1,['load'],['loaded']
Performance,"bers:; find the mapping of data members to otuput list entries in the output list; and apply it. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE). Long64_t Finalize(TQueryResult* qr); Finalize the results of a query already processed. Bool_t SendSelector(const char* selector_file); Send the selector file(s) to master or worker nodes. void MergeOutput(); Merge objects in output the lists. void Progress(Long64_t total, Long64_t processed); Progress signal. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Progress signal. void Progress(TProofProgressInfo* pi); Progress signal. void Feedback(TList* objs); Feedback signal. void StopProcess(Bool_t abort, Int_t timeout = -1); Stop process after this event. Int_t AddOutputObject(TObject* obj); Incorporate the received object 'obj' into the output list fOutput.; The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' optimizing the memory; consumption.; Returns -1 in case of error, 1 if the object has been merged into another; one (so that its ownership has not been taken and can be deleted), and 0; otherwise. void RedirectOutput(Bool_t on = kTRUE); Control output redirection to TProof::fLogFileW. void AddOutput(TList* out); Incorporate the content of the received output list 'out' into the final; output list fOutput. The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' limiting the memory; consumption. void NotifyMemory(TObject* obj); Printout the memory record after merging object 'obj'; This record is used by the memory monitor. void SetLastMergingMsg(TObject* obj); Set the message to be notified in case of exception. Int_t Incorporate(TObject* obj, TList* out, Bool_t& merged); Incorporate object 'newobj' in the list 'outlist'.; The object is merged with an object of the same name already existing in; the list, or just added.; The boolean merged is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayerRemote.html:17275,optimiz,optimizing,17275,root/html528/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html528/TProofPlayerRemote.html,4,['optimiz'],['optimizing']
Performance,"bers; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase *const method, map<TString,TMVA::Interval> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). std::vector< int > GetScanIndices(int val, vector<int> base); helper function to scan through the all the combinations in the; parameter space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete possible MVA ouput values.; (I still leave the code here, but use this with care!!! The default; however is to use the distributions!!!. Double_t GetSigEffAtBkgEff(Double_t bkgEff = 0.1); calculate the signal efficiency for a given background efficiency. Double_t GetBkgEffAtSigEff(Double_t sigEff = 0.5); calculate the background efficiency for a given signal efficiency. Double_t G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__OptimizeConfigParameters.html:3544,optimiz,optimization,3544,root/html530/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html530/TMVA__OptimizeConfigParameters.html,2,['optimiz'],['optimization']
Performance,"bers; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase*const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). std::vector< int > GetScanIndices(int val, vector<int> base); helper function to scan through the all the combinations in the; parameter space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete possible MVA ouput values.; (I still leave the code here, but use this with care!!! The default; however is to use the distributions!!!. Double_t GetSigEffAtBkgEff(Double_t bkgEff = 0.10000000000000001); calculate the signal efficiency for a given background efficiency. Double_t GetBkgEffAtSigEff(Double_t sigEff = 0.5); calculate the background efficiency for a given signal effici",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__OptimizeConfigParameters.html:3859,optimiz,optimization,3859,root/html602/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html602/TMVA__OptimizeConfigParameters.html,2,['optimiz'],['optimization']
Performance,"bers; data members; class charts. ROOT; » GRAF2D; » GPAD; » TPad. class TPad: public TVirtualPad. The Pad class is the most important graphics class in the ROOT system. /*. */. A Pad is contained in a Canvas.; A Pad may contain other pads (unlimited pad hierarchy).; A pad is a linked list of primitives of any type (graphics objects,; histograms, detectors, tracks, etc.).; Adding a new element into a pad is in general performed by the Draw; member function of the object classes.; It is important to realize that the pad is a linked list of references; to the original object.; For example, in case of a histogram, the histogram.Draw() operation; only stores a reference to the histogram object and not a graphical; representation of this histogram.; When the mouse is used to change (say the bin content), the bin content; of the original histogram is changed !!. The convention used in ROOT is that a Draw operation only adds; a reference to the object. The effective drawing is performed; when the canvas receives a signal to be painted.; This signal is generally sent when typing carriage return in the; command input or when a graphical operation has been performed on one; of the pads of this canvas.; When a Canvas/Pad is repainted, the member function Paint for all; objects in the Pad linked list is invoked. When the mouse is moved on the Pad, The member function DistancetoPrimitive; is called for all the elements in the pad. DistancetoPrimitive returns; the distance in pixels to this object.; when the object is within the distance window, the member function; ExecuteEvent is called for this object.; in ExecuteEvent, move, changes can be performed on the object.; For examples of DistancetoPrimitive and ExecuteEvent functions,; see classes TLine::DistancetoPrimitive, TLine::ExecuteEvent; TBox::DistancetoPrimitive, TBox::ExecuteEvent; TH1::DistancetoPrimitive, TH1::ExecuteEvent. A Pad supports linear and log scales coordinate systems.; The transformation coefficients are explai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPad.html:1165,perform,performed,1165,root/html528/TPad.html,https://root.cern,https://root.cern/root/html528/TPad.html,3,['perform'],['performed']
Performance,"bers; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::HypoTestInverterOriginal. class RooStats::HypoTestInverterOriginal: public RooStats::IntervalCalculator, public TNamed. HypoTestInverterOriginal class for performing an hypothesis test inversion by scanning the hypothesis test results of the; HybridCalculator for various values of the parameter of interest. By looking at the confidence level curve of; the result an upper limit, where it intersects the desired confidence level, can be derived.; The class implements the RooStats::IntervalCalculator interface and returns an RooStats::HypoTestInverterResult class.; The result is a SimpleInterval, which via the method UpperLimit returns to the user the upper limit value. The HypoTestInverterOriginal implements various option for performing the scan. HypoTestInverterOriginal::RunFixedScan will scan using a fixed grid the parameter of interest. HypoTestInverterOriginal::RunAutoScan will perform an automatic scan to find optimally the curve and it will stop until the desired precision is obtained.; The confidence level value at a given point can be done via HypoTestInverterOriginal::RunOnePoint.; The class can scan the CLs+b values or alternativly CLs (if the method HypoTestInverterOriginal::UseCLs has been called). New contributions to this class have been written by Matthias Wolf (advanced AutoRun algorithm). Function Members (Methods); public:. virtual~HypoTestInverterOriginal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Double_tConfidenceLevel() const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """"",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HypoTestInverterOriginal.html:1178,perform,perform,1178,root/html530/RooStats__HypoTestInverterOriginal.html,https://root.cern,https://root.cern/root/html530/RooStats__HypoTestInverterOriginal.html,5,['perform'],['perform']
Performance,"between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstAverage; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstCurrent; static TVirtualPacketizer::EUseEstOptTVirtualPacketizer::kEstOff. private:. TList*fActivenodes with unfinished files; Float_tfBaseLocalPreferenceindicates how much more likely the nodes will be; Bool_tfCachePacketSynccontrol synchronization of cache and packet sizes; TList*fFileNodesnodes with files; TSortedList*fFilesToProcessGlobal list of files (TFileStat) to be processed; Bool_tfForceLocalif 1 - eliminate the remote processing; Float_tfFractionOfRemoteFilesfraction of TDSetElements that are on non-workers; Double_tfMaxEntriesRatiomax file entries to avg allowed ratio for cache-to-packet sync; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Long64_tfNEventsOnRemLocnumber of events in currently; Int_tfPacketAsAFractionused to calculate the packet size; TList*fPartitionslist of partitions on nodes; Int_tfStrategy0 means the classic and 1 (default) - the adaptive strategy; Int_tfTryReassignControls attempts to reassign packets (0 == no reassignment); TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPacketizerAdaptive.html:11651,cache,cache,11651,root/html602/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html602/TPacketizerAdaptive.html,6,"['cache', 'perform']","['cache', 'cache-to-packet', 'performance']"
Performance,"bility density function for each bin.; The negative log-likelihood to be minimized is; NLL = Sum{ log Poisson( y(i) |{ f(x(i) | p ) ) }; The exact likelihood used is the Poisson likelihood described in this paper:; S. Baker and R. D. Cousins, “Clarification of the use of chi-square and likelihood functions in fits to histograms,”; Nucl. Instrum. Meth. 221 (1984) 437.; This method can then be used only when the bin content represents counts (i.e. errors are sqrt(N) ).; The likelihood method has the advantage of treating correctly bins with low statistics. In case of high; statistics/bin the distribution of the bin content becomes a normal distribution and the likelihood and chi2 fit; give the same result.; The likelihood method, although a bit slower, it is therefore the recommended method in case of low; bin statistics, where the chi2 method may give incorrect results, in particular when there are; several empty bins (see also below).; In case of a weighted histogram, it is possible to perform a likelihood fit by using the; option ""WL"". Note a weighted histogram is an histogram which has been filled with weights and it; contains the sum of the weight square ( TH1::Sumw2() has been called). The bin error for a weighted; histogram is the square root of the sum of the weight square. Treatment of Empty Bins. Empty bins, which have the content equal to zero AND error equal to zero,; are excluded by default from the chisquare fit, but they are considered in the likelihood fit.; since they affect the likelihood if the function value in these bins is not negligible.; When using option ""WW"" these bins will be considered in the chi2 fit with an error of 1.; Note that if the histogram is having bins with zero content and non zero-errors they are considered as; any other bins in the fit. Instead bins with zero error and non-zero content are excluded in the chi2 fit.; A likelihood fit should also not be peformed on such an histogram, since we are assuming a wrong pdf for each bi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:83166,perform,perform,83166,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,2,['perform'],['perform']
Performance,"bilityAttkVisStreamed; static TGeoAtt::EGeoVisibilityAttkVisThis; static TGeoAtt::EGeoVisibilityAttkVisTouched. protected:. UInt_tfGeoAttoption flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoAtt(); Default constructor. TGeoAtt(Option_t* vis_opt, Option_t* activity_opt = """", Option_t* optimization_opt = """"); Constructor. ~TGeoAtt(); Destructor. void SetVisBranch(); Set branch type visibility. void SetVisContainers(Bool_t flag = kTRUE); Set branch type visibility. void SetVisLeaves(Bool_t flag = kTRUE); Set branch type visibility. void SetVisOnly(Bool_t flag = kTRUE); Set branch type visibility. void SetVisibility(Bool_t vis = kTRUE); Set visibility for this object. void SetVisDaughters(Bool_t vis = kTRUE); Set visibility for the daughters. void SetVisStreamed(Bool_t vis = kTRUE); Mark attributes as ""streamed to file"". void SetVisTouched(Bool_t vis = kTRUE); Mark visualization attributes as ""modified"". void SetOptimization(Option_t* option); Set optimization flags. TGeoAtt(); constructors. void SetAttBit(UInt_t f); methods. {fGeoAtt |= f & kBitMask;}. void SetAttBit(UInt_t f, Bool_t set); {(set)?SetAttBit(f):ResetAttBit(f);}. void ResetAttBit(UInt_t f); {fGeoAtt &= ~(f & kBitMask);}. Bool_t TestAttBit(UInt_t f) const; {return (Bool_t)((fGeoAtt & f) != 0);}. void SetVisRaytrace(Bool_t flag = kTRUE); {SetAttBit(kVisRaytrace, flag);}. void SetActivity(Bool_t flag = kTRUE); {SetAttBit(kActThis, flag);}. void SetActiveDaughters(Bool_t flag = kTRUE); {SetAttBit(kActDaughters,flag);}. Bool_t IsActive() const; {return TestAttBit(kActThis);}. Bool_t IsActiveDaughters() const; {return TestAttBit(kActDaughters);}. Bool_t IsVisRaytrace() const; {return TestAttBit(kVisRaytrace);}. Bool_t IsVisible() const; {return TestAttBit(kVisThis);}. Bool_t IsVisDaughters() const; {return TestAttBit(kVisDaughters);}. Bool_t IsVisBranch() const; {return TestAttBit(kVisBranch);}. Bool_t IsVisContainers() const; {return TestAttBit(kVisContain",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoAtt.html:3748,optimiz,optimization,3748,root/html602/TGeoAtt.html,https://root.cern,https://root.cern/root/html602/TGeoAtt.html,2,['optimiz'],['optimization']
Performance,"bin number. void ReleaseRangeZ(); Release restrictions on the Z range of the histogram to be used in the fit. void ExcludeBin(Int_t bin); Exclude the given bin from the fit. The bin numbering to be used is that; of TH1::GetBin(). void IncludeBin(Int_t bin); Include the given bin in the fit, if it was excluded before using ExcludeBin().; The bin numbering to be used is that of TH1::GetBin(). bool IsExcluded(Int_t bin) const; Function for internal use, checking whether the given bin is; excluded from the fit or not. void Constrain(Int_t parm, Double_t low, Double_t high); Constrain the values of parameter number <parm> (the parameter numbering; follows that of the input template vector).; Use UnConstrain() to remove this constraint. void UnConstrain(Int_t parm); Remove the constraints on the possible values of parameter <parm>. void CheckConsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& mi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFractionFitter.html:16686,perform,performed,16686,root/html530/TFractionFitter.html,https://root.cern,https://root.cern/root/html530/TFractionFitter.html,3,['perform'],['performed']
Performance,"bin number. void ReleaseRangeZ(); Release restrictions on the Z range of the histogram to be used in the fit. void ExcludeBin(Int_t bin); Exclude the given bin from the fit. The bin numbering to be used is that; of TH1::GetBin(). void IncludeBin(Int_t bin); Include the given bin in the fit, if it was excluded before using ExcludeBin().; The bin numbering to be used is that of TH1::GetBin(). bool IsExcluded(Int_t bin) const; Function for internal use, checking whether the given bin is; excluded from the fit or not. void Constrain(Int_t parm, Double_t low, Double_t high); Constrain the values of parameter number <parm> (the parameter numbering; follows that of the input template vector).; Use UnConstrain() to remove this constraint. void UnConstrain(Int_t parm); Remove the constraints on the possible values of parameter <parm>. void CheckConsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. TFitResultPtr Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "".; Note also that the histogram is managed by the TFractionFitter clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFractionFitter.html:17290,perform,performed,17290,root/html602/TFractionFitter.html,https://root.cern,https://root.cern/root/html602/TFractionFitter.html,2,['perform'],['performed']
Performance,"bin,ibin,binx,biny,binz;; 5349 for (ibin =0; ibin < hold->fNcells; ibin++) {; 5350 // get the binx,y,z values . The x-y-z (axis) bin values will stay the same between new-old after the expanding; 5351 hold->GetBinXYZ(ibin,binx,biny,binz);; 5352 bin = GetBin(binx,biny,binz);; 5353 ; 5354 // underflow and overflow will be cleaned up because their meaning has been altered; 5355 if (hold->IsBinUnderflow(ibin,iaxis) || hold->IsBinOverflow(ibin,iaxis)) {; 5356 continue;; 5357 }; 5358 else {; 5359 AddBinContent(bin, hold->RetrieveBinContent(ibin));; 5360 if (errors) fSumw2.fArray[bin] += hold->fSumw2.fArray[ibin];; 5361 }; 5362 }; 5363 fEntries = oldEntries;; 5364 delete hold;; 5365}; 5366 ; 5367////////////////////////////////////////////////////////////////////////////////; 5368/// Sort bins with labels or set option(s) to draw axis with labels; 5369/// \param[in] option; 5370/// - ""a"" sort by alphabetic order; 5371/// - "">"" sort by decreasing values; 5372/// - ""<"" sort by increasing values; 5373/// - ""h"" draw labels horizontal; 5374/// - ""v"" draw labels vertical; 5375/// - ""u"" draw labels up (end of label right adjusted); 5376/// - ""d"" draw labels down (start of label left adjusted); 5377///; 5378/// In case not all bins have labels sorting will work only in the case; 5379/// the first `n` consecutive bins have all labels and sorting will be performed on; 5380/// those label bins.; 5381///; 5382/// \param[in] ax axis; 5383 ; 5384void TH1::LabelsOption(Option_t *option, Option_t *ax); 5385{; 5386 Int_t iaxis = AxisChoice(ax);; 5387 TAxis *axis = nullptr;; 5388 if (iaxis == 1); 5389 axis = GetXaxis();; 5390 if (iaxis == 2); 5391 axis = GetYaxis();; 5392 if (iaxis == 3); 5393 axis = GetZaxis();; 5394 if (!axis); 5395 return;; 5396 THashList *labels = axis->GetLabels();; 5397 if (!labels) {; 5398 Warning(""LabelsOption"", ""Axis %s has no labels!"",axis->GetName());; 5399 return;; 5400 }; 5401 TString opt = option;; 5402 opt.ToLower();; 5403 Int_t iopt = -1;; 5404 if (opt.Conta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:216222,perform,performed,216222,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['perform'],['performed']
Performance,"bin_13 = 0.890724 +/- 0.195929 (limited); p_ph_sig_gamma_bin_14 = 0.947374 +/- 0.309135 (limited); p_ph_sig_gamma_bin_15 = 1.14132 +/- 0.81204 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (hc_sigbkg); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (Abkg,Asig,p_ph_sig2_gamma_bin_0,p_ph_sig2_gamma_bin_1,p_ph_sig2_gamma_bin_10,p_ph_sig2_gamma_bin_11,p_ph_sig2_gamma_bin_12,p_ph_sig2_gamma_bin_13,p_ph_sig2_gamma_bin_14,p_ph_sig2_gamma_bin_15,p_ph_sig2_gamma_bin_16,p_ph_sig2_gamma_bin_17,p_ph_sig2_gamma_bin_18,p_ph_sig2_gamma_bin_19,p_ph_sig2_gamma_bin_2,p_ph_sig2_gamma_bin_20,p_ph_sig2_gamma_bin_21,p_ph_sig2_gamma_bin_22,p_ph_sig2_gamma_bin_23,p_ph_sig2_gamma_bin_24,p_ph_sig2_gamma_bin_3,p_ph_sig2_gamma_bin_4,p_ph_sig2_gamma_bin_5,p_ph_sig2_gamma_bin_6,p_ph_sig2_gamma_bin_7,p_ph_sig2_gamma_bin_8,p_ph_sig2_gamma_bin_9); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model2) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model2_sumData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 13500 convergence for edm < 1 strategy 1; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=7.28945 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:19929,optimiz,optimization,19929,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,2,['optimiz'],['optimization']
Performance,"binding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. RooRealBinding(const RooRealBinding& other, const RooArgSet* nset = 0); Construct a lightweight function binding of RooAbsReal func to; variables 'vars'. Use the provided nset as normalization set to; be passed to RooAbsReal::getVal() If rangeName is not null, use; the range of with that name as range associated with the; variables of this function binding. If clipInvalid is true,; values requested to the function binding that are outside the; defined range of the variables are clipped to fit in the defined; range. ~RooRealBinding(); Destructor. void saveXVec() const; Save value of all variables. void restoreXVec() const; Restore value of all variables to previously; saved values by saveXVec(). void loadValues(const Double_t* xvector) const; Load the vector of variable values into the RooRealVars associated; as variables with the bound RooAbsReal function. Double_t operator()(const Double_t* xvector) const; Evaluate the bound RooAbsReal at the variable values provided in xvector. Double_t getMinLimit(UInt_t dimension) const; Return lower limit on i-th variable. Double_t getMaxLimit(UInt_t dimension) const; Return upper limit on i-th variable. const char* getName() const; Return name of function. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const. std::list<Double_t>* binBoundaries(Int_t ) const. » Last changed: Tue Mar 10 17:18:43 2015 » Last generated: 2015-03-10 17:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealBinding.html:3389,load,loadValues,3389,root/html534/RooRealBinding.html,https://root.cern,https://root.cern/root/html534/RooRealBinding.html,1,['load'],['loadValues']
Performance,"binfo = (TNamed*)fCompiled->FindObject(library);; 3252 if (libinfo) {; 3253 Long_t load_time = libinfo->GetUniqueID();; 3254 Long_t lib_time;; 3255 if ( gSystem->GetPathInfo( library, nullptr, (Long_t*)nullptr, nullptr, &lib_time ) == 0; 3256 && (lib_time>load_time)) {; 3257 reload = kTRUE;; 3258 }; 3259 }; 3260 ; 3261 if ( !recompile && reload ) {; 3262 ; 3263 if (withInfo) {; 3264 ::Info(""ACLiC"",""%s has been modified and will be reloaded"",; 3265 libname.Data());; 3266 }; 3267 if ( gInterpreter->UnloadFile( library.Data() ) != 0 ) {; 3268 // The library is being used. We can not unload it.; 3269 return kFALSE;; 3270 }; 3271 if (libinfo) {; 3272 fCompiled->Remove(libinfo);; 3273 delete libinfo;; 3274 libinfo = nullptr;; 3275 }; 3276 TNamed *k = new TNamed(library,library);; 3277 Long_t lib_time;; 3278 gSystem->GetPathInfo( library, nullptr, (Long_t*)nullptr, nullptr, &lib_time );; 3279 k->SetUniqueID(lib_time);; 3280 if (!keep) k->SetBit(kMustCleanup);; 3281 fCompiled->Add(k);; 3282 ; 3283 return !gSystem->Load(library);; 3284 }; 3285 ; 3286 if (withInfo) {; 3287 ::Info(""ACLiC"",""%s script has already been compiled and loaded"",; 3288 modified ? ""modified"" : ""unmodified"");; 3289 }; 3290 ; 3291 if ( !recompile ) {; 3292 return kTRUE;; 3293 } else {; 3294 if (withInfo) {; 3295 ::Info(""ACLiC"",""it will be regenerated and reloaded!"");; 3296 }; 3297 if ( gInterpreter->UnloadFile( library.Data() ) != 0 ) {; 3298 // The library is being used. We can not unload it.; 3299 return kFALSE;; 3300 }; 3301 if (libinfo) {; 3302 fCompiled->Remove(libinfo);; 3303 delete libinfo;; 3304 libinfo = nullptr;; 3305 }; 3306 Unlink(library);; 3307 }; 3308 ; 3309 }; 3310 ; 3311 TString libmapfilename;; 3312 AssignAndDelete( libmapfilename, ConcatFileName( build_loc, libname ) );; 3313 libmapfilename += "".rootmap"";; 3314#if (defined(R__MACOSX) && !defined(MAC_OS_X_VERSION_10_5)) || defined(R__WIN32); 3315 Bool_t produceRootmap = kTRUE;; 3316#else; 3317 Bool_t produceRootmap = kFALSE;; 3318#endif;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:109612,load,loaded,109612,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['loaded']
Performance,"bitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; voidSummary() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/Roo2DMomentMorphFunction.html:25214,cache,cache,25214,root/html532/Roo2DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html532/Roo2DMomentMorphFunction.html,1,['cache'],['cache']
Performance,"bjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; const ROOT::Math::IBaseFunctionMultiDim*funcFunctor; RooListProxyvarsArgument reference; Double_t*xArgument value array.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFunctorPdfBinding.html:39150,cache,cache,39150,root/html526/RooFunctorPdfBinding.html,https://root.cern,https://root.cern/root/html526/RooFunctorPdfBinding.html,2,['cache'],['cache']
Performance,"bjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdfProxy to p.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCachedPdf.html:40876,cache,cache,40876,root/html528/RooCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooCachedPdf.html,2,['cache'],['cache']
Performance,"bjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Long64_tfBytesRead!track bytes read of main file; TH2D*fCpuTimeHist!histogram of cpu time spent processing packets; TDSet*fDSet!Saved pointer to the TDSet object; TStringfDataSet!Dataset string; Int_tfDataSetLen!Maximum size of the dataset string fDataSet ; Int_tfDataSetSize!# of files in the dataset ; Bool_tfDoHist!Fill histos; Bool_tfDoQuota!Save stats on SQL server for quota management; Bool_tfDoSlaveTrace!Full tracing in workers; Bool_tfDoTrace!Trace details in master; Bool_tfDoTraceRate!Trace processing rate in master; TH1D*fEventsHist!histogram of events processed per slave; TH2D*fLatencyHist!histogram of latency due to packet requests; TObjArrayfMonSenders!Monitoring engines; Bool_tfMonitorPerPacket!Whether to send the full entry per each packet ; TH1D*fNodeHist!histogram of slaves per file serving node; Long64_tfNumEvents!total number of events to be processed; TList*fOutput!Saved pointer to the output list ; TH1D*fPacketsHist!histogram of packets processed per slave; TPerfEvent*fPerfEvent!TPerfEvent used to fill tree; TH1I*fProcPcktHist!histogram of packets being processed per slave; TH2D*fProcTimeHist!histogram of real time spent processing packets; Int_tfSlaves!number of active slaves; Long64_tfTotBytesRead!total bytes read on all slaves; Double_tfTotCpuTime!total cpu time of all slaves; Long64_tfTotEvents!total number of events processed; TTree*fTrace!TTree with trace events; TTimeStampfTzero!start time of this run; static Long_tfgResMemMax! Max resident memory used by this process; static Long_tfgVirtMemMax! Max virtual memory used by this process. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPerfStats(TList* input, TList* output); Normal constructor. ~TPerfStats(); Destructor. void SimpleEvent(TVirtualP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPerfStats.html:7218,latency,latency,7218,root/html534/TPerfStats.html,https://root.cern,https://root.cern/root/html534/TPerfStats.html,1,['latency'],['latency']
Performance,"bjString*)objOptions->At(n))->GetName();; 3924 TObjArray *objTags = loption.Tokenize(""="");; 3925 if (objTags->GetEntries() == 2) {; 3926 TString key = ((TObjString*)objTags->At(0))->GetName();; 3927 TString value = ((TObjString*)objTags->At(1))->GetName();; 3928 if (key.CompareTo(""zip"", TString::kIgnoreCase)) {; 3929 if (optioncount!=0) {; 3930 newoptions += ""&"";; 3931 }; 3932 newoptions += key;; 3933 newoptions += ""="";; 3934 newoptions += value;; 3935 ++optioncount;; 3936 } else {; 3937 zipname = value;; 3938 }; 3939 }; 3940 delete objTags;; 3941 }; 3942 delete objOptions;; 3943 fileurl.SetOptions(newoptions.Data());; 3944 cachefilepath += ""__"";; 3945 cachefilepath += zipname;; 3946 fileurl.SetAnchor("""");; 3947 }; 3948 ; 3949 Bool_t need2copy = kFALSE;; 3950 ; 3951 // check if file is in the cache; 3952 Long_t id;; 3953 Long64_t size;; 3954 Long_t flags;; 3955 Long_t modtime;; 3956 if (!gSystem->GetPathInfo(cachefilepath, &id, &size, &flags, &modtime)) {; 3957 // file is in the cache; 3958 if (!fgCacheFileDisconnected) {; 3959 char cacheblock[256];; 3960 char remotblock[256];; 3961 // check the remote file for it's size and compare some magic bytes; 3962 TString cfurl;; 3963 cfurl = cachefilepath;; 3964 cfurl += ""?filetype=raw"";; 3965 TUrl rurl(name);; 3966 TString ropt = rurl.GetOptions();; 3967 ropt += ""&filetype=raw"";; 3968 rurl.SetOptions(ropt);; 3969 ; 3970 Bool_t forcedcache = fgCacheFileForce;; 3971 fgCacheFileForce = kFALSE;; 3972 ; 3973 TFile *cachefile = TFile::Open(cfurl, ""READ"");; 3974 TFile *remotfile = TFile::Open(rurl.GetUrl(), ""READ"");; 3975 ; 3976 fgCacheFileForce = forcedcache;; 3977 ; 3978 if (!cachefile) {; 3979 need2copy = kTRUE;; 3980 ::Error(""TFile::OpenFromCache"",; 3981 ""cannot open the cache file to check cache consistency"");; 3982 return nullptr;; 3983 }; 3984 ; 3985 if (!remotfile) {; 3986 ::Error(""TFile::OpenFromCache"",; 3987 ""cannot open the remote file to check cache consistency"");; 3988 return nullptr;; 3989 }; 3990 ; 3991 cachefile->",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:143772,cache,cache,143772,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,5,['cache'],"['cache', 'cacheblock', 'cachefilepath']"
Performance,"bject *obj);  Add to the list of things to be cleaned up. ;  ; static TCollection * GetCurrentCollection ();  Return the globally accessible collection. ;  ; static void StartGarbageCollection ();  Set up for garbage collection. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TCollection; enum  EStatusBits { kIsOwner = (1ULL << ( 14 )); , kUseRWLock = (1ULL << ( 16 )); };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/core/base/src/TListOfTypes.h>. Inheritance diagram for TListOfTypes:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfTypes.html:14906,perform,perform,14906,doc/master/classTListOfTypes.html,https://root.cern,https://root.cern/doc/master/classTListOfTypes.html,1,['perform'],['perform']
Performance,"bject * fField;  pointer to TGeoManager owning this volume ;  ; TGeoPatternFinder * fFinder;  dummy medium ;  ; TGeoExtension * fFWExtension;  Transient user-defined extension to volumes. ;  ; TGeoManager * fGeoManager;  ; TGeoMedium * fMedium;  ; TObjArray * fNodes;  ; Int_t fNtotal;  ; Int_t fNumber;  option - if any ;  ; TString fOption;  just a hook for now ;  ; Int_t fRefCount;  ; TGeoShape * fShape;  ; Char_t fTransparency;  ; TGeoExtension * fUserExtension;  ; TGeoVoxelFinder * fVoxels;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TGeoAtt; UInt_t fGeoAtt;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth;  Line width. ;  ;  Protected Attributes inherited from TAttFill; Color_t fFillColor;  Fill area color. ;  ; Style_t fFillStyle;  Fill area style. ;  . Private Member Functions;  TGeoVolumeAssembly (const TGeoVolumeAssembly &)=delete;  Mutex for concurrent operations. ;  ; TGeoVolumeAssembly & operator= (const TGeoVolumeAssembly &)=delete;  . Additional Inherited Members;  Public Types inherited from TGeoVolume; enum  EGeoVolumeTypes { ;   kVolumeReplicated = (1ULL << ( 14 )); , kVolumeSelected = (1ULL << ( 15 )); , kVolumeDiv = (1ULL << ( 16 )); , kVolumeOverlap = (1ULL << ( 17 )); , ;   kVolumeImportNodes = (1ULL << ( 18 )); , kVolumeMulti = (1ULL << ( 19 )); , kVoxelsXYZ = (1ULL << ( 20 )); , kVoxelsCyl = (1ULL << ( 21 )); , ;   kVolumeClone = (1ULL << ( 22 )); , kVolumeAdded = (1ULL << ( 23 )); , kVolumeOC = (1ULL << ( 21 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 ));",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolumeAssembly.html:28008,concurren,concurrent,28008,doc/master/classTGeoVolumeAssembly.html,https://root.cern,https://root.cern/doc/master/classTGeoVolumeAssembly.html,1,['concurren'],['concurrent']
Performance,"bject for a; RooAbsReal implementation with class name 'name', taking all; elements of 'vars' as constructor arguments. The initial value; expression is taken to be 'expression' which can be any one-line; C++ expression in terms of variables that occur in 'vars'. The returned object is an instance of the object you just defined; connected to the variables listed in 'vars'. The name of the; object is 'name', its class name Roo<name>Class. This function is an effective compiled replacement of RooFormulaVar. You can add optional expressions for analytical integrals to be; advertised by your class in the syntax; ""<intObsName>:<CPPAnaIntExpression>;<intObsName,intObsName>:<CPPAnaIntExpression>""; where <intObsName> a name of the observable integrated over and; <CPPAnaIntExpression> is the C++ expression that calculates that; integral. RooAbsReal* makeFunctionInstance(const char* className, const char* name, const char* expression, const RooArgList& vars, const char* intExpression = 0); Write, compile and load code and instantiate object for a; RooAbsReal implementation with class name 'name', taking all; elements of 'vars' as constructor arguments. The initial value; expression is taken to be 'expression' which can be any one-line; C++ expression in terms of variables that occur in 'vars'. The returned object is an instance of the object you just defined; connected to the variables listed in 'vars'. The name of the; object is 'name', its class name Roo<name>Class. This function is an effective compiled replacement of RooFormulaVar. You can add optional expressions for analytical integrals to be; advertised by your class in the syntax; ""<intObsName>:<CPPAnaIntExpression>;<intObsName,intObsName>:<CPPAnaIntExpression>""; where <intObsName> a name of the observable integrated over and; <CPPAnaIntExpression> is the C++ expression that calculates that; integral. RooAbsPdf* makePdfInstance(const char* name, const char* expression, const RooArgList& vars, const char* intExpression",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooClassFactory.html:10679,load,load,10679,root/html526/RooClassFactory.html,https://root.cern,https://root.cern/root/html526/RooClassFactory.html,7,['load'],['load']
Performance,"bject instances. An example usage:; >>> from ROOT import std; >>> v = std.vector(int)(); >>> for i in range(0,10):; ... v.push_back(i); ...; >>> for i in v:; ... print(i, end=' '); 1 2 3 4 5 6 7 8 9; >>>; >>> list(v); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; The parameters to the template instantiation can either be an actual type or value (as is used here, “int”), or a string representation of the parameters (e.g. “‘double’”), or a mixture of both (e.g. “‘TCanvas, 0’” or “‘double’, 0” ). The “std::vector<int>” class is one of the classes builtin by default into the Cling extension dlls. You will get a non-functional class (instances of which can still be passed around to C++) if the corresponding dictionary doesn’t exist.; 19.1.5.3 Access to ROOT Globals; Most globals and global functions can be imported directly from the ROOT.py module, but some common ones (most notably gMinuit, although that variable now exists at startup from release 5.08 onward) do not exist yet at program startup, as they exist in modules that are loaded later (e.g. through the auto-loading mechanism). An example session should make this clear:; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; It is also possible to create globals interactively, either by executing a Cling macro, or by a call to gROOT.ProcessLine(). These globals are made available in the same way: either use them directly after creation in ‘from ROOT import *’ more, or get them from the ROOT namespace after an ‘import ROOT’.; As of 5.08, the behaviour of ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1053875,load,loaded,1053875,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loaded']
Performance,"bject is also 0, then the text size is automatically computed to fit the legend box. If gStyle->GetLegendTextSize() is non equal to 0 and if text size directly set on the TLegend object is 0, then the gStyle value is used to draw the legend text. If the text size directly set on the TLegend object is not null, then it is used to draw the legend text. TTexDump. The hollow fill style was not rendered correctly. (see https://sft.its.cern.ch/jira/browse/ROOT-6841); Better line width matching with screen and pdf output.; Text color was ignored. It was always black.; Text color was ignored. It was always black.; The underscore _ produced an error outside the TeX math context.; Fix an issue with transparent pads.; Implement transparent colors using TiKZ “opacity”.; Implement TStyle::SetLineScalePS() to control le global basic line width.; Offer 0 as line width option. Useful to make a line invisible. TPostScript. Small fix for fill patterns 1, 2 and 3.; With TMathtext, only the fonts really used are now loaded in the PostScript file. Typically it reduces the file size by a factor 10 (compare to the previous implementation) for normal plots with math formulae and greek characters.; Offer 0 as line width option. Useful to make a line invisible. TPDF. When a text size was equal or smaller than 0 the PDF file was corrupted.; Small fix for fill patterns 1, 2 and 3.; When printing a coloured 2D histograms (with option COLZ) into a PDF or PostScript file, the preview on screen using many standard PDF previewer tools showed very thin white lines between the bins as well as in the color palette. This made very ugly the final output. This problem is due to bad implementation of anti-aliasing in these previewers. A way to bypass this issue was to turn off the anti-aliasing in the previewer but then the rest of the document does not look nice. This problem is now bypassed with a fix in both PDF and PostScript output.; Offer 0 as line width option. Useful to make a line invisible. TSVG.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:22103,load,loaded,22103,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['load'],['loaded']
Performance,bject named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet_ownedComps! Owned components; TIterator*_pdfIter! Iterator over PDF list; RooListProxy_pdfListList of component PDFs; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooObjCacheManager_projCacheMgrManager of cache with coefficient projections and transformations; Bool_t_projectCoefsIf true coefficients need to be projected for use in evaluate(); RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; RooSetProxy_refCoefNorm! Reference observable set for coefficient interpretation; TNamed*_refCoefRangeName! Reference range name for coefficient interpreation; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooArgList*_snormList! List of supplemental normalization factors; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorC,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddModel.html:46315,cache,cache,46315,root/html602/RooAddModel.html,https://root.cern,https://root.cern/root/html602/RooAddModel.html,2,['cache'],['cache']
Performance,"bject title; RooRealProxyfuncProxy to functions whose running integral is calculated; RooRealProxyxIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* binningName = ""cache""); Construct running integral of function '_func' over x_print from; the lower bound on _x to the present value of _x using a numeric; sampling technique. The sampling frequency is controlled by the; binning named 'bname' and a default second order interpolation; is applied to smooth the histogram-based c.d.f. RooNumRunningInt(const RooNumRunningInt& other, const char* name = 0); Copy constructor. ~RooNumRunningInt(); Destructor. const char* inputBaseName() const; Return unique name for RooAbsCachedPdf cache components; constructed from input function name. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill the cache object by calling its calculate() method. RooArgSet* actualObservables(const RooArgSet& nset) const; Return observable in nset to be cached by RooAbsCachedPdf; this is always the x observable that is integrated. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters of the cache created by RooAbsCachedPdf.; These are always the input functions parameter, but never the; integrated variable x. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Create custom cache element for running integral calculations. Double_t evaluate() const; Dummy function that is never called. TObject* clone(const char* newname) const; { return new RooNumRunningInt(*this,newname); }. const char* binningName() const; { return _binningName.c_str() ; }. » Last changed: Mon Dec 7 13:48:34 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumRunningInt.html:34976,cache,cached,34976,root/html526/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html526/RooNumRunningInt.html,3,['cache'],"['cache', 'cached']"
Performance,"bject title; TList*TSocket::fUUIDslist of TProcessIDs already sent through the socket; TStringTSocket::fUrlneeds this for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. TSeqCollection*fSecContextsList of TSecContext with cleanup info; static UChar_tfgAcceptOptDefault accept options; static SrvClup_tfgSrvAuthClupHook; static SrvAuth_tfgSrvAuthHook. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TSocket. ←; TServerSocket. ←. TPServerSocket. Function documentation; TServerSocket(const char* service, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); Create a server socket object for a named service. Set reuse to true; to force reuse of the server socket (i.e. do not wait for the time; out to pass). Using backlog one can set the desirable queue length; for pending connections.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. TServerSocket(Int_t port, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); Create a server socket object on a specified port. Set reuse to true; to force reuse of the server socket (i.e. do not wait for the time; out to pass). Using backlog one can set the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TServerSocket.html:11544,queue,queue,11544,root/html602/TServerSocket.html,https://root.cern,https://root.cern/root/html602/TServerSocket.html,2,['queue'],['queue']
Performance,"bject to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; TObjArray fAji;  Array of pointers to predictions of real template distributions. ;  ; Double_t fChisquare;  Template fit chisquare. ;  ; std::vector< Int_t > fExcludedBins;  Bins excluded from the fit. ;  ; Bool_t fFitDone;  Flags whether a valid fit has been performed. ;  ; Int_t fHighLimitX;  Last bin in X dimension. ;  ; Int_t fHighLimitY;  Last bin in Y dimension. ;  ; Int_t fHighLimitZ;  Last bin in Z dimension. ;  ; Int_t fLowLimitX;  First bin in X dimension. ;  ; Int_t fLowLimitY;  First bin in Y dimension. ;  ; Int_t fLowLimitZ;  First bin in Z dimension. ;  ; Int_t fNDF;  Number of degrees of freedom in the fit. ;  ; Int_t fNpar;  number of fit parameters ;  ; Int_t fNpfits;  Number of points used in the fit. ;  ; Histograms; TH1 * fData;  Pointer to the ""data"" histogram to be fitted to. ;  ; TObjArray fMCs;  Array of pointers to template histograms. ;  ; TObjArray fWeights;  Array of pointers to corresponding weight factors (may be null) ;  ; Double_t fIntegralData;  ""data"" histogram content integral over allowed fit range ;  ; Double_t * fIntegralMCs;  Same for template histograms (weights not taken into account) ;  ; Double_t * fFractions;  Template fractions scaled to the ""data"" histogram statistics. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFractionFitter.html:18099,perform,performed,18099,doc/master/classTFractionFitter.html,https://root.cern,https://root.cern/doc/master/classTFractionFitter.html,1,['perform'],['performed']
Performance,"bject*fObjectcurrent object if processing object (vs. TTree); TStringfOptionoption given to TTree::Process; TSelectorList*fOutputlist of objects created during processing; Long64_tfStatusselector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TSelector object. Bool_t IsStandardDraw(const char* selec); Find out if this is a standard selection used for Draw actions; (either TSelectorDraw, TProofDraw or deriving from them). TSelector(const TSelector& ). TSelector& operator=(const TSelector& ). int Version() const; { return 0; }. void Init(TTree* ); { }. void Begin(TTree* ); { }. void SlaveBegin(TTree* ); { }. Bool_t Notify(); { return kT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSelector.html:9561,load,loaded,9561,root/html528/TSelector.html,https://root.cern,https://root.cern/root/html528/TSelector.html,3,['load'],['loaded']
Performance,bject.; ROOT::DelArrFunc_tfDeleteArraypointer to a function deleting an array of objects.; ROOT::DesFunc_tfDestructorpointer to a function call an object's destructor.; ROOT::DirAutoAdd_tfDirAutoAddpointer which implements the Directory Auto Add feature for this class.']'; atomic<TListOfEnums*>fEnumslinked list for the enums; TListOfFunctionTemplates*fFuncTemplatelinked list for function templates [Not public until implemented as active list]; IsAGlobalFunc_tfGlobalIsApointer to a global IsA function.; atomic<Bool_t>fHasRootPcmInfo!Whether info was loaded from a root pcm.; Short_tfImplFileLineline of class implementation; const char*fImplFileNamename of class implementation file; UInt_tfInstanceCountnumber of instances of this class; TVirtualIsAProxy*fIsA!pointer to the class's IsA proxy.; atomic<TMethodCall*>fIsAMethod!saved info to call a IsA member function; atomic<Bool_t>fIsOffsetStreamerSet!saved remember if fOffsetStreamer has been set.; atomic<TVirtualStreamerInfo*>fLastReadInfo!cached streamer info used in the last read.; ROOT::MergeFunc_tfMergepointer to a function implementing Merging objects of this class.; atomic<TListOfFunctions*>fMethodlinked list for methods; ROOT::NewFunc_tfNewpointer to a function newing one object.; ROOT::NewArrFunc_tfNewArraypointer to a function newing an array of objects.; static TClass::TDeclNameRegistryfNoInfoOrEmuOrFwdDeclNameRegistryStore the decl names of the forwardd and no info instances; Long_tfOffsetStreamer!saved info to call Streamer; UInt_tfOnHeapnumber of instances on heap; atomic<TClass**>fPersistentRef!Persistent address of pointer to this TClass object and its successors.; atomic<Long_t>fProperty!Property; TList*fRealDatalinked list for persistent members including base classes; TVirtualRefProxy*fRefProxy!Pointer to reference proxy if this class represents a reference; ROOT::ResetAfterMergeFunc_tfResetAfterMergepointer to a function implementing Merging objects of this class.; ROOT::TSchemaRuleSet*fSchemaRules! S,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:21859,cache,cached,21859,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['cache'],['cached']
Performance,"bject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TCondor::EStatekSuspended; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TList*fClaimslist of claims we manage; TStringfPoolthe condor pool to be accessed; TCondor::EStatefStateour claim state; Bool_tfValidaccess to Condor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondor(const char* pool = """"); Create Condor interface object. Uses Condor apps since there is no; API yet. ~TCondor(); Cleanup Condor interface. void Print(Option_t* option = """") const; Print master status. TCondorSlave * ClaimVM(const char* vm, const char* cmd); Claim a VirtualMachine for PROOF usage. TList * GetVirtualMachines() const; Get the names of the virtual machines in the pool.; Return a TList of TObjString or 0 in case of failure. TList * Claim(Int_t n, const char* cmd); Claim n virtual machines; This function figures out the image and performance index before returning; the list of condor slaves. TCondorSlave * Claim(const char* vmname, const char* cmd); Claim virtual machine with name vmname; This function does not figure out the image and performance index before; returning the condor slave. Bool_t SetState(TCondor::EState state); Set the state of workers. Bool_t Suspend(); Suspend worker. Bool_t Resume(); Resume worker. Bool_t Release(); Release worker. Bool_t GetVmInfo(const char* vm, TString& image, Int_t& perfidx) const; Get info about worker status. TString GetImage(const char* host) const; Get image of the worker. TCondor(const char* pool = """"). Bool_t IsValid() const; { return fValid; }. EState GetState() const; {return fState;}. » Author: Maarten Ballintijn 06/12/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-02 15:40; This page has been automatically generated. For comments or suggestions regarding the docume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TCondor.html:7053,perform,performance,7053,root/html604/TCondor.html,https://root.cern,https://root.cern/root/html604/TCondor.html,1,['perform'],['performance']
Performance,"bject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TCondor::EStatekSuspended; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TList*fClaimslist of claims we manage; TStringfPoolthe condor pool to be accessed; TCondor::EStatefStateour claim state; Bool_tfValidaccess to Condor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCondor(const char* pool = """"); Create Condor interface object. Uses Condor apps since there is no; API yet. ~TCondor(); Cleanup Condor interface. void Print(Option_t* option = """") const; Print master status. TCondorSlave * ClaimVM(const char* vm, const char* cmd); Claim a VirtualMachine for PROOF usage. TList * GetVirtualMachines() const; Get the names of the virtual machines in the pool.; Return a TList of TObjString or 0 in case of failure. TList * Claim(Int_t n, const char* cmd); Claim n virtual machines; This function figures out the image and performance index before returning; the list of condor slaves. TCondorSlave * Claim(const char* vmname, const char* cmd); Claim virtual machine with name vmname; This function does not figure out the image and performance index before; returning the condor slave. Bool_t SetState(TCondor::EState state); Set the state of workers. Bool_t Suspend(); Suspend worker. Bool_t Resume(); Resume worker. Bool_t Release(); Release worker. Bool_t GetVmInfo(const char* vm, TString& image, Int_t& perfidx) const; Get info about worker status. TString GetImage(const char* host) const; Get image of the worker. TCondor(const char* pool = """"). Bool_t IsValid() const; { return fValid; }. EState GetState() const; {return fState;}. » Author: Maarten Ballintijn 06/12/03 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the docume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCondor.html:7053,perform,performance,7053,root/html602/TCondor.html,https://root.cern,https://root.cern/root/html602/TCondor.html,1,['perform'],['performance']
Performance,"bject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfCPUParList of par files to be loaded for CPU benchmarks; TStringfCPUSelSelector to be used for CPU benchmarks; TProofBenchDataSet*fDSInstance to handle datasets operations; TStringfDataGenParList of par files to be loaded to generate data for benchmarks; TStringfDataGenSelSelector to be used for generate data for benchmarks; TStringfDataParList of par files to be loaded for data benchmarks; TStringfDataSelSelector to be used for data benchmarks; TStringfDataSetName of the dataset; Bool_tfDebugDebug switch; TNamed*fDescriptionStrings describing the cluster for this test (saved in the output file); TPBHistType*fHistTypeType of histograms for CPU runs; Int_tfNFilesWrkNumber of files generated files per worker; Int_tfNHistNumber of histograms to be created in default CPU runs; Int_tfNtriesNumber of times a measurement is repeated; Int_tfNumWrkMaxMax number of workers (required for dynamic setups); TFile*fOutFileOutput file; TStringfOutFileNameName of the output file; TProof*fProofProof; TProof*fProofDSProof to be used for dataset actions; TPBReadType*fReadTypeType of read (partial, full); Bool_tfReleaseCacheRelease cache for data reads between runs; TProofBenchRunCPU*fRunCPUInstance to run CPU scans; TProofBenchRunDataRead*fRunDSInstance to run data-read scans; TStringfSelOptionOption field for processing the selector; static TF1*fgFioFunction used for I/O rate fits; static TF1*fgFioVFunction used for I/O rate fits with non-constant Rcpu; static TF1*fgFp1Simple 1st degree polynomial; static TF1*fgFp1nNormalized 1st degree; static TF1*fgFp2Simple 2nd degree polynomial; static TF1*fgFp2nNormalized 2nd degree; static TF1*fgFp3Function with varying Rcpu; static TF1*fgFp3nNormalized Function with varying Rcpu; static TList*fgGraphsList of TGraphErrors created by Draw actions. private:. Bool_tfUnlinkOutfileWhether to remove empty output files. Class Charts. Inheritance; I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofBench.html:7755,load,loaded,7755,root/html602/TProofBench.html,https://root.cern,https://root.cern/root/html602/TProofBench.html,8,"['cache', 'load']","['cache', 'loaded']"
Performance,"bject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCurrentIDunique ID of current node; Int_tfGeoCacheMaxLevelsmaximum supported number of levels; Int_tfGeoCacheStackSizemaximum size of the stack; Int_tfGeoInfoStackSizemaximum size of the stack of info states; Int_tfIdBranch[100]current branch of indices; Int_tfIndexindex in array of ID's; TGeoStateInfo**fInfoBranchcurrent branch of nodes; Int_tfInfoLevelcurrent level in the stack; Int_tfLevellevel in the current branch; TGeoHMatrix**fMPBpre-built matrices; TGeoHMatrix*fMatrix! current matrix; TGeoHMatrix**fMatrixBranchcurrent branch of global matrices; TGeoNode*fNode! current node; TGeoNode**fNodeBranchcurrent branch of nodes; Int_t*fNodeIdArray! array of node id's; TStringfPathpath for current branch; TObjArray*fStackstack of cache states; Int_tfStackLevelcurrent level in the stack; TGeoNode*fToptop node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNodeCache(); Dummy constructor. TGeoNodeCache(TGeoNode* top, Bool_t nodeid = kFALSE, Int_t capacity = 30); Default constructor. ~TGeoNodeCache(); Destructor. void BuildIdArray(); Builds node id array. void BuildInfoBranch(); Bulds info branch. Navigation is possible only after this step. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Bool_t CdDown(Int_t index); Make daugh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoNodeCache.html:8021,cache,cache,8021,root/html602/TGeoNodeCache.html,https://root.cern,https://root.cern/root/html602/TGeoNodeCache.html,1,['cache'],['cache']
Performance,"bject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TPerfStats&operator=(const TPerfStats&); virtual voidPacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidRateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBytesRead(Long64_t num); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetNumEvents(Long64_t num); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); static voidS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPerfStats.html:3920,latency,latency,3920,root/html528/TPerfStats.html,https://root.cern,https://root.cern/root/html528/TPerfStats.html,1,['latency'],['latency']
Performance,"bject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidselectDefaultAlgorithm(); voidselectFastAlgorithm(); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooVoigtian.html:27770,cache,cache,27770,root/html530/RooVoigtian.html,https://root.cern,https://root.cern/root/html530/RooVoigtian.html,1,['cache'],['cache']
Performance,"bject::SavePrimitive(ostream& out, Option_t* option = """"); voidRooAbsOptTestStatistic::seal(const char* notice = """"); const char*RooAbsOptTestStatistic::sealNotice() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsTestStatistic::setData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChi2Var.html:26562,cache,cache,26562,root/html534/RooChi2Var.html,https://root.cern,https://root.cern/root/html534/RooChi2Var.html,12,['cache'],['cache']
Performance,"bject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786. The option COL can be combined with the option POL:; {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hcol1 = new TH2F(""hcol1"",""Option COLor combined with POL"",40,-4,4,40,-4,4);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcol1->Fill(px,py);; }; hcol1->Draw(""COLZPOL"");; }. SinceROOT version 6.07/03:; A second rendering technique is also available with the COL2 and COLZ2 options.; These options provide potential performance improvements compared to the standard COL option. The performance comparison of the COL2 to the COL option depends on the histogram and the size of the rendering region in the current pad. In general, a small (approx. less than 100 bins per axis), sparsely populated TH2 will render faster with the COL option.; However, for larger histograms (approx. more than 100 bins per axis) that are not sparse, the COL2 option will provide up to 20 times performance improvements. For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude faster with the COL2 option.; The COL2 option will also scale its performance based on the size of the pixmap the histogram image is being rendered into. It also is much better optimized for sessions where the user is forwarding X11 windows through an ssh connection.; For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL and COLZ options. There is one major difference and that concerns the treatment of bins with zero content. The COL2 and COLZ2 options color these bins the color of zero.; COL2 option renders the histogram as a bitmap. Therefore it cannot be saved in vector graphics file format like PostScript or PDF (an empty image will be generated). It can be saved only in bitmap files like PNG format for instance. The CANDLE and VIOLIN options; The mechanism behind Candle plots and Violin plots is very similar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:48419,perform,performance,48419,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['perform'],['performance']
Performance,"bject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGenericPdf.html:30671,cache,cache,30671,root/html532/RooGenericPdf.html,https://root.cern,https://root.cern/root/html532/RooGenericPdf.html,1,['cache'],['cache']
Performance,"bject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsRealLValue.html:37920,cache,cache,37920,root/html602/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsRealLValue.html,324,['cache'],"['cache', 'caches']"
Performance,"bject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <TGeoNavigator.h>. Inheritance diagram for TGeoNavigator:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGeoNavigator() [1/3]. TGeoNavigator::TGeoNavigator ; (; const TGeoNavigator & ; ). protecteddelete . ◆ TGeoNavigator() [2/3]. TGeoNavigator::TGeoNavigator ; (; ). global mode is caching enabled for parallel world safety calls ; Constructor. ; Definition at line 57 of file TGeoNavigator.cxx. ◆ TGeoNavigator() [3/3]. TGeoNavigator::TGeoNavigator ; (; TGeoManager * ; geom). Constructor. ; Definition at line 109 of file TGeoNavigator.cxx. ◆ ~TGeoNavigator(). TGeoNavigator::~TGeoNavigator ; (; ). override . Destructor. ; Definition at line 169 of file TGeoNavigator.cxx. Member Function Documentation. ◆ BuildCache(). void TGeoNavigator::BuildCache ; (; Bool_t ; dummy = kFALSE, . Bool_t ; nodeid = kFALSE . ). Builds the cache for physical nodes and global matrices. ; Definition at line 182 of file TGeoNavigator.cxx. ◆ cd(). Bool_t TGeoNavigator::cd ; (; const char * ; path = """"). Browse the tree of nodes starting from top node according to pathname. ; Changes the path accordingly. The path is changed to point to the top node in case of failure. ; Definition at line 210 of file TGeoNavigator.cxx. ◆ CdDown() [1/2]. void TGeoNavigator::CdDown ; (; Int_t ; index). Make a daughter of current node current. ; Can be called only with a valid daughter index (no check). Updates cache accordingly. ; Definition at line 313 of file TGeoNavigator.cxx. ◆ CdDown() [2/2]. void TGeoNavigator::CdDown ; (; TGeoNode * ; node). Make a daughter of current node current. ; Can be called only with a valid daughter node (no check). Updates cache accordingly. ; Definition at line 333 of file TGeoNavigator.cxx. ◆ CdNext(). void TGeoNavigator::CdNext ; (; ). Do a cd to the node found next by FindNextBoundary. ; Definition at line 405 of file TGeoN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:23117,cache,cache,23117,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['cache'],['cache']
Performance,"bjectTable. ;  . Protected Member Functions; Int_t GetHead () override;  Overwrites TWebFile::GetHead() for retrieving the HTTP headers of this file. ;  ; void ProcessHttpHeader (const TString &headerLine) override;  This method is called by the super-class TWebFile when a HTTP header for this file is retrieved. ;  ; void SetAccessKey (const TString &accessKey);  ; void SetMsgReadBuffer10 (const char *redirectLocation=nullptr, Bool_t tempRedirect=kFALSE) override;  Overwrites TWebFile::SetMsgReadBuffer10() for setting the HTTP GET request compliant to the authentication mechanism used by the S3 protocol. ;  ; void SetSecretKey (const TString &secretKey);  ;  Protected Member Functions inherited from TWebFile; virtual TString BasicAuthentication ();  Return basic authentication scheme, to be added to the request. ;  ; virtual void CheckProxy ();  Check if shell var ""http_proxy"" has been set and should be used. ;  ; virtual Int_t GetFromCache (char *buf, Int_t len, Int_t nseg, Long64_t *seg_pos, Int_t *seg_len);  Extract requested segments from the cached content. ;  ; virtual Int_t GetFromWeb (char *buf, Int_t len, const TString &msg);  Read request from web server. ;  ; virtual Int_t GetFromWeb10 (char *buf, Int_t len, const TString &msg, Int_t nseg=0, Long64_t *seg_pos=nullptr, Int_t *seg_len=nullptr);  Read multiple byte range request from web server. ;  ; virtual Int_t GetHunk (TSocket *s, char *hunk, Int_t maxsize);  Read a hunk of data from the socket, up until a terminator. ;  ; virtual Int_t GetLine (TSocket *s, char *line, Int_t maxsize);  Read a line from the socket. ;  ; virtual const char * HttpTerminator (const char *start, const char *peeked, Int_t peeklen);  Determine whether [START, PEEKED + PEEKLEN) contains an HTTP new line [\r]\n. ;  ; void Init (Bool_t readHeadOnly) override;  Initialize a TWebFile object. ;  ; virtual Bool_t ReadBuffer10 (char *buf, Int_t len);  Read specified byte range from remote file via HTTP 1.0 daemon (without mod-root inst",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:33283,cache,cached,33283,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,1,['cache'],['cached']
Performance,"bjective function over the data; TMVA::DNN trains the deep neural networks in parallel; TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel. EnableImplicitMT calls in turn EnableThreadSafety. The 'numthreads' parameter allows to control the number of threads to be used by the implicit multi-threading. However, this parameter is just a hint for ROOT: it will try to satisfy the request if the execution scenario allows it. For example, if ROOT is configured to use an external scheduler, setting a value for 'numthreads' might not have any effect.; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 527 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enables the global mutex to make ROOT thread safe/aware. ; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableTh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v626/namespaceROOT.html:24487,concurren,concurrent,24487,doc/v626/namespaceROOT.html,https://root.cern,https://root.cern/doc/v626/namespaceROOT.html,1,['concurren'],['concurrent']
Performance,"bjects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach the category index and label as branches to the given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  Attach the category index and label to as branches to the given vector store. ;  ; void clearTypes ();  Delete all currently defined states. ;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValueDirty=true) override;  Copy the cached value from given source and raise dirty flag. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label);  Define a new state with given label. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label, value_type index);  Define new state with given name and index number. ;  ; void defineStateUnchecked (const std::string &label, value_type index);  Internal version of defineState() that does not check if type already exists. ;  ; virtual value_type evaluate () const =0;  Evaluate the category state and return. ;  ; void fillTreeBranch (TTree &t) override;  Fill tree branches associated with current object with current value. ;  ; bool isValid () const override;  WVE (08/21/01) Probably obsolete now. ;  ; value_type nextAvailableStateIndex () const;  ; virtual void recomputeShape ()=0;  If a category depends on the shape",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategory.html:36406,cache,cached,36406,doc/master/classRooAbsCategory.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategory.html,1,['cache'],['cached']
Performance,"bjects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedPdf.html:43937,cache,cache,43937,root/html532/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedPdf.html,1,['cache'],['cache']
Performance,bjects written so far; 75 Long64_t fBytesWrite{0}; ///<Number of bytes written to this file; 76 Long64_t fBytesRead{0}; ///<Number of bytes read from this file; 77 Long64_t fBytesReadExtra{0}; ///<Number of extra bytes (overhead) read by the readahead buffer; 78 Long64_t fBEGIN{0}; ///<First used byte in file; 79 Long64_t fEND{0}; ///<Last used byte in file; 80 Long64_t fSeekFree{0}; ///<Location on disk of free segments structure; 81 Long64_t fSeekInfo{0}; ///<Location on disk of StreamerInfo record; 82 Int_t fD{-1}; ///<File descriptor; 83 Int_t fVersion{0}; ///<File format version; 84 Int_t fCompress{0}; ///<Compression level and algorithm; 85 Int_t fNbytesFree{0}; ///<Number of bytes for free segments structure; 86 Int_t fNbytesInfo{0}; ///<Number of bytes for StreamerInfo record; 87 Int_t fWritten{0}; ///<Number of objects written so far; 88 Int_t fNProcessIDs{0}; ///<Number of TProcessID written to this file; 89 Int_t fReadCalls{0}; ///<Number of read calls ( not counting the cache calls ); 90 TString fRealName; ///<Effective real file name (not original url); 91 TString fOption; ///<File options; 92 Char_t fUnits{0}; ///<Number of bytes for file pointers; 93 TList *fFree{nullptr}; ///<Free segments linked list table; 94 TArrayC *fClassIndex{nullptr}; ///<!Index of TStreamerInfo classes written to this file; 95 TObjArray *fProcessIDs{nullptr}; ///<!Array of pointers to TProcessIDs; 96 Long64_t fOffset{0}; ///<!Seek offset cache; 97 TArchiveFile *fArchive{nullptr}; ///<!Archive file from which we read this file; 98 TFileCacheRead *fCacheRead{nullptr}; ///<!Pointer to the read cache (if any); 99 TMap *fCacheReadMap{nullptr}; ///<!Pointer to the read cache (if any); 100 TFileCacheWrite *fCacheWrite{nullptr}; ///<!Pointer to the write cache (if any); 101 Long64_t fArchiveOffset{0}; ///<!Offset at which file starts in archive; 102 Bool_t fIsArchive{kFALSE}; ///<!True if this is a pure archive file; 103 Bool_t fNoAnchorInName{kFALSE}; ///<!True if we don't want to f,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:3360,cache,cache,3360,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['cache'],['cache']
Performance,"ble by us return kFALSE. ; Definition at line 4626 of file TFile.cxx. ◆ SetCacheRead(). void TFile::SetCacheRead ; (; TFileCacheRead * ; cache, . TObject * ; tree = nullptr, . ECacheAction ; action = kDisconnect . ). virtual . Set a pointer to the read cache. ; This relinquishes ownership of the previous cache, so if you do not already have a pointer to the previous cache (and there was a previous cache), you ought to retrieve (and delete it if needed) using: TFileCacheRead *older = myfile->GetCacheRead();; The action specifies how to behave when detaching a cache from the the TFile. If set to (default) kDisconnect, the contents of the cache will be flushed when it is removed from the file, and it will disconnect the cache object from the file. In almost all cases, this is what you want. If you want to disconnect the cache temporarily from this tree and re-attach later to the same fil, you can set action to kDoNotDisconnect. This will allow things like prefetching to continue in the background while it is no longer the default cache for the TTree. Except for a few expert use cases, kDisconnect is likely the correct setting.; WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. ; Definition at line 2365 of file TFile.cxx. ◆ SetCacheWrite(). void TFile::SetCacheWrite ; (; TFileCacheWrite * ; cache). virtual . Set a pointer to the write cache. ; If file is null the existing write cache is deleted. ; Definition at line 2388 of file TFile.cxx. ◆ SetCompressionAlgorithm(). void TFile::SetCompressionAlgorithm ; (; Int_t ; algorithm = ROOT::RCompressionSetting::EAlgorithm::kUseGlobal). virtual . See comments for function SetCompressionSettings. ; Definition at line 2305 of file TFile.cxx. ◆ SetCompressionLevel(). void TFile::SetCompressionLevel ; (; Int_t ; level = ROOT::RCompressionSetting::ELevel::kUseMin). virtual . See comments for function SetCompressionSettings. ; Definition at line 2319 of file TFile.cxx. ◆ SetCompressionSettings(). void TFile:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:92737,cache,cache,92737,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['cache'],['cache']
Performance,"ble names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset); Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset); Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Mon Dec 7 13:45:33 2009 » Last generate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedPdf.html:43040,cache,cache,43040,root/html526/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedPdf.html,1,['cache'],['cache']
Performance,"ble(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int ivar, double val); set the value of an existing variable. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of existing parameters). bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fValues.size(); }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total number of free parameters. { return fObjFunc->NDim(); }. bool ProvidesError() const; minimizer provides error and error matrix. { return false; }. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int , unsigned int ) const; return covariance ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__GSLMinimizer.html:7263,perform,perform,7263,root/html528/ROOT__Math__GSLMinimizer.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__GSLMinimizer.html,3,['perform'],['perform']
Performance,"ble(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int ivar, double val); set the value of an existing variable. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of existing parameters). bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fValues.size(); }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total number of free parameters. { return fObjFunc->NDim(); }. bool ProvidesError() const; minimizer provides error and error matrix. { return false; }. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int , unsigned int ) const; ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__GSLMinimizer.html:7040,perform,perform,7040,root/html526/ROOT__Math__GSLMinimizer.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__GSLMinimizer.html,1,['perform'],['perform']
Performance,"ble. Double_t Result(Int_t event, Int_t index = 0) const; Computes the output for a given event.; Look at the output neuron designed by index. Double_t GetError(Int_t event) const; Error on the output for a given event. Double_t GetError(TMultiLayerPerceptron::EDataSet set) const; Error on the whole dataset. Double_t GetSumSquareError() const; Error on the output for a given event. Double_t GetCrossEntropyBinary() const; Cross entropy error for sigmoid output neurons, for a given event. Double_t GetCrossEntropy() const; Cross entropy error for a softmax output neuron, for a given event. void ComputeDEDw() const; Compute the DEDw = sum on all training events of dedw for each weight; normalized by the number of events. void Randomize() const; Randomize the weights. void AttachData(); Connects the TTree to Neurons in input and output; layers. The formulas associated to each neuron are created; and reported to the network formula manager.; By default, the branch is not normalised since this would degrade; performance for classification jobs.; Normalisation can be requested by putting '@' in front of the formula. void ExpandStructure(); Expand the structure of the first layer. void BuildNetwork(); Instanciates the network from the description. void BuildFirstLayer(TString& ); Instanciates the neurons in input; Inputs are normalised and the type is set to kOff; (simple forward of the formula value). void BuildHiddenLayers(TString& ); Builds hidden layers. void BuildOneHiddenLayer(const TString& sNumNodes, Int_t& layer, Int_t& prevStart, Int_t& prevStop, Bool_t lastLayer); Builds a hidden layer, updates the number of layers. void BuildLastLayer(TString& , Int_t ); Builds the output layer; Neurons are linear combinations of input, by defaul.; If the structure ends with ""!"", neurons are set up for classification,; ie. with a sigmoid (1 neuron) or softmax (more neurons) activation function. void DrawResult(Int_t index = 0, Option_t* option = ""test"") const; Draws the neural net",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:26332,perform,performance,26332,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,6,['perform'],['performance']
Performance,"ble::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(const char*) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsString.html:9581,optimiz,optimizeCacheMode,9581,root/html530/RooAbsString.html,https://root.cern,https://root.cern/root/html530/RooAbsString.html,2,['optimiz'],['optimizeCacheMode']
Performance,"bleOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsTestStatistic::offset() const; virtual Double_tRooAbsTestStatistic::offsetCarry() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooNLLVar&operator=(const RooNLLVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNLLVar.html:20133,optimiz,optimizeCacheMode,20133,root/html602/RooNLLVar.html,https://root.cern,https://root.cern/root/html602/RooNLLVar.html,2,['optimiz'],['optimizeCacheMode']
Performance,"bleOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBinningCategory.html:10392,optimiz,optimizeCacheMode,10392,root/html526/RooBinningCategory.html,https://root.cern,https://root.cern/root/html526/RooBinningCategory.html,5,['optimiz'],['optimizeCacheMode']
Performance,"bleOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBinningCategory.html:10507,optimiz,optimizeCacheMode,10507,root/html528/RooBinningCategory.html,https://root.cern,https://root.cern/root/html528/RooBinningCategory.html,5,['optimiz'],['optimizeCacheMode']
Performance,"ble_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:19496,cache,cache,19496,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,1,['cache'],['cache']
Performance,"ble_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCache.html:21362,cache,cache,21362,root/html530/TTreeCache.html,https://root.cern,https://root.cern/root/html530/TTreeCache.html,1,['cache'],['cache']
Performance,"ble_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:22204,cache,cache,22204,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,1,['cache'],['cache']
Performance,"ble_t Uniform(Double_t x1=1)Returns a uniform deviate on the interval (0, x1).Definition TRandom.cxx:682; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::Setenvvirtual void Setenv(const char *name, const char *value)Set environment variable.Definition TSystem.cxx:1649; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; c1return c1Definition legend1.C:41; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definition legend1.C:5; f1TF1 * f1Definition legend1.C:11; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; TMVA_CNN_ClassificationDefinition TMVA_CNN_Classification.py:1; TMVA::Python_ExecutableTString Python_Executable()Function to find current Python executable used by ROOT If ""Python3"" is installed,...Definition PyMethodBase.cxx:43; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4; AuthorLorenzo Moneta ; Definition in file TMVA_CNN_Classification.C. tutorialstmvaTMVA_CNN_Classification.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:65860,multi-thread,multi-threading,65860,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['multi-thread'],['multi-threading']
Performance,"ble_t xmin = 0, Double_t xmax = 1, Int_t npar = 0); F1 constructor using the Functor class. xmin and xmax define the plotting range of the function; npar is the number of free parameters used by the function. This constructor can be used only in compiled code. WARNING! A function created with this constructor cannot be Cloned. void CreateFromFunctor(const char* name, Int_t npar); Internal Function to Create a TF1 using a Functor. Used by the template constructors. TF1& operator=(const TF1& rhs); Operator =. ~TF1(); TF1 default destructor. TF1(const TF1& f1); Constuctor. void AbsValue(Bool_t reject = kTRUE); Static function: set the fgAbsValue flag.; By default TF1::Integral uses the original function value to compute the integral; However, TF1::Moment, CentralMoment require to compute the integral; using the absolute value of the function. void Browse(TBrowser* b); Browse. void Copy(TObject& f1) const; Copy this F1 to a new F1.; Note that the cached integral with its related arrays are not copied; (they are also set as transient data members). Double_t Derivative(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the first derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF1.html:34069,cache,cached,34069,root/html602/TF1.html,https://root.cern,https://root.cern/root/html602/TF1.html,1,['cache'],['cached']
Performance,"ble_t xmin = 0.65, Double_t xmax = 0.99, Double_t ymax = 0.95, const RooCmdArg* formatCmd = 0); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsPdf::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; static voidRooAbsPdf::raiseEvalError(); Int_t*RooAbsPdf::randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; virtual Bool_tRooAbsPdf::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidselectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidselectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); virtual Bool_tRooAbsPdf::syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Double_tRooAbsReal::traceEval(const RooArgSet* set) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy); voidupdateCoefficients(RooAddPdf::CacheElem& cache, const RooArgSet* nset) const. Data Members; public:. enum RooAbsPdf::ExtendMode { CanNot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddPdf.html:39038,cache,cache,39038,root/html534/RooAddPdf.html,https://root.cern,https://root.cern/root/html534/RooAddPdf.html,1,['cache'],['cache']
Performance,"ble_t z); 180 {; 181 fLastPoint[0] = x;; 182 fLastPoint[1] = y;; 183 fLastPoint[2] = z;; 184 }; 185 void SetCurrentDirection(const Double_t *dir) { memcpy(fDirection, dir, 3 * sizeof(Double_t)); }; 186 void SetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); 187 {; 188 fDirection[0] = nx;; 189 fDirection[1] = ny;; 190 fDirection[2] = nz;; 191 }; 192 // void SetNormalChecked(Double_t norm) {fNormalChecked=norm;}; 193 void SetCldirChecked(Double_t *dir) { memcpy(fCldirChecked, dir, 3 * sizeof(Double_t)); }; 194 void SetLastSafetyForPoint(Double_t safe, const Double_t *point); 195 {; 196 fLastSafety = safe;; 197 memcpy(fLastPoint, point, 3 * sizeof(Double_t));; 198 }; 199 void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); 200 {; 201 fLastSafety = safe;; 202 fLastPoint[0] = x;; 203 fLastPoint[1] = y, fLastPoint[2] = z;; 204 }; 205 ; 206 // Check if we have a cached safety value from parallel world, and if this can still be used.; 207 // Return negative value if no cache available.; 208 Double_t GetPWSafetyEstimateFromCache(Double_t cpoint[3]) const; 209 {; 210 // disregard too small or invalid safeties; 211 if (fLastPWSafety < TGeoShape::Tolerance()) {; 212 return -1.;; 213 }; 214 const auto d0 = fLastPWSaftyPnt[0] - cpoint[0];; 215 const auto d1 = fLastPWSaftyPnt[1] - cpoint[1];; 216 const auto d2 = fLastPWSaftyPnt[2] - cpoint[2];; 217 const auto d_sq = d0 * d0 + d1 * d1 + d2 * d2;; 218 // if we have moved too much return -1 as ""invalid""; 219 if (d_sq >= (fLastPWSafety * fLastPWSafety)) {; 220 return -1.;; 221 }; 222 // or return a reasonable cache estimate for safety; 223 return fLastPWSafety - std::sqrt(d_sq);; 224 }; 225 ; 226 // Wrapper for getting the safety from the parallel world.; 227 // Takes care of caching mechanics and talking to the Safety function of parallel world.; 228 Double_t GetPWSafety(Double_t cpoint[3], Double_t saf_max);; 229 ; 230 // enable/disable parallel world safety caching; 231 static void SetPWSafetyCachi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:10400,cache,cache,10400,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['cache'],['cache']
Performance,"ble_t* eyhd = 0); TGraphBentErrors normal constructor. if exl,h or eyl,h are null, the corresponding arrays are preset to zero. ~TGraphBentErrors(); TGraphBentErrors default destructor. void Apply(TF1* f); apply a function to all data points; y = f(x,y). Errors are calculated as eyh = f(x,y+eyh)-f(x,y) and; eyl = f(x,y)-f(x,y-eyl). Special treatment has to be applied for the functions where the; role of ""up"" and ""down"" is reversed.; function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>. void ComputeRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; Compute range. void CopyAndRelease(Double_t** newarrays, Int_t ibegin, Int_t iend, Int_t obegin); Copy and release. Bool_t CopyPoints(Double_t** arrays, Int_t ibegin, Int_t iend, Int_t obegin); Copy errors from fE*** to arrays[***]; or to f*** Copy points. Bool_t CtorAllocate(void); Should be called from ctors after fNpoints has been set. Bool_t DoMerge(const TGraph* g); protected function to perform the merge operation of a graph with asymmetric errors. Double_t GetErrorX(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorY(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along Y at point i. Double_t GetErrorXhigh(Int_t bin) const; Get high error on X[i]. Double_t GetErrorXlow(Int_t bin) const; Get low error on X[i]. Double_t GetErrorYhigh(Int_t bin) const; Get high error on Y[i]. Double_t GetErrorYlow(Int_t bin) const; Get low error on Y[i]. void FillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE); Set zero values for point arrays in the range [begin, end). void Print(Option_t* chopt = """") const; Print graph and errors values. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh, Double_t exld = 0, Double_t exhd = 0, Double_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraphBentErrors.html:17627,perform,perform,17627,root/html534/TGraphBentErrors.html,https://root.cern,https://root.cern/root/html534/TGraphBentErrors.html,3,['perform'],['perform']
Performance,"ble_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id: TFitter.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFitter.html:16945,cache,cache,16945,root/html528/TFitter.html,https://root.cern,https://root.cern/root/html528/TFitter.html,1,['cache'],['cache']
Performance,"ble_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id: TFitter.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFitter.html:17014,cache,cache,17014,root/html530/TFitter.html,https://root.cern,https://root.cern/root/html530/TFitter.html,1,['cache'],['cache']
Performance,"ble_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id: TFitter.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFitter.html:17014,cache,cache,17014,root/html532/TFitter.html,https://root.cern,https://root.cern/root/html532/TFitter.html,1,['cache'],['cache']
Performance,"ble_t*TQpSolverBase::fPhi_history[fMaxit] history of values of phi obtained on all iterations to date; Double_t*TQpSolverBase::fPhi_min_history[fMaxit] the i-th entry of this array contains the minimum value of phi; Int_tfPrintlevelparameter in range [0,100] determines verbosity. (Higher value; Double_t*TQpSolverBase::fRnorm_history[fMaxit] history of values of residual norm obtained on all iterations to date; TQpVar*fStep; Double_tfStepFactor0various parameters associated with Gondzio correction; Double_tfStepFactor1; TQpLinSolverBase*TQpSolverBase::fSys; Double_tfTsigexponent in Mehrotra's centering parameter, which is usually. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGondzioSolver(); Default constructor. TGondzioSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); Constructor. TGondzioSolver(const TGondzioSolver& another); Copy constructor. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); Solve the quadratic programming problem as formulated through prob, store; the final solution in iterate->fX . Monitor the residuals during the iterations; through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); Print information about the optimization process and monitor the convergence; status of thye algorithm. ~TGondzioSolver(); Deconstructor. TGondzioSolver & operator=(const TGondzioSolver& source); Assignment operator. void Reset_parameters(); {}. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TGondzioSolver.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGondzioSolver.html:9129,optimiz,optimization,9129,root/html528/TGondzioSolver.html,https://root.cern,https://root.cern/root/html528/TGondzioSolver.html,1,['optimiz'],['optimization']
Performance,"ble_t*TQpSolverBase::fPhi_history[fMaxit] history of values of phi obtained on all iterations to date; Double_t*TQpSolverBase::fPhi_min_history[fMaxit] the i-th entry of this array contains the minimum value of phi; Int_tfPrintlevelparameter in range [0,100] determines verbosity. (Higher value; Double_t*TQpSolverBase::fRnorm_history[fMaxit] history of values of residual norm obtained on all iterations to date; TQpVar*fStep; Double_tfStepFactor0various parameters associated with Gondzio correction; Double_tfStepFactor1; TQpLinSolverBase*TQpSolverBase::fSys; Double_tfTsigexponent in Mehrotra's centering parameter, which is usually. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGondzioSolver(); Default constructor. TGondzioSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); Constructor. TGondzioSolver(const TGondzioSolver& another); Copy constructor. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); Solve the quadratic programming problem as formulated through prob, store; the final solution in iterate->fX . Monitor the residuals during the iterations; through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); Print information about the optimization process and monitor the convergence; status of thye algorithm. ~TGondzioSolver(); Deconstructor. TGondzioSolver & operator=(const TGondzioSolver& source); Assignment operator. void Reset_parameters(); {}. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TGondzioSolver.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGondzioSolver.html:9198,optimiz,optimization,9198,root/html530/TGondzioSolver.html,https://root.cern,https://root.cern/root/html530/TGondzioSolver.html,1,['optimiz'],['optimization']
Performance,"ble_t*TQpSolverBase::fPhi_history[fMaxit] history of values of phi obtained on all iterations to date; Double_t*TQpSolverBase::fPhi_min_history[fMaxit] the i-th entry of this array contains the minimum value of phi; Int_tfPrintlevelparameter in range [0,100] determines verbosity. (Higher value; Double_t*TQpSolverBase::fRnorm_history[fMaxit] history of values of residual norm obtained on all iterations to date; TQpVar*fStep; Double_tfStepFactor0various parameters associated with Gondzio correction; Double_tfStepFactor1; TQpLinSolverBase*TQpSolverBase::fSys; Double_tfTsigexponent in Mehrotra's centering parameter, which is usually. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGondzioSolver(); Default constructor. TGondzioSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); Constructor. TGondzioSolver(const TGondzioSolver& another); Copy constructor. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); Solve the quadratic programming problem as formulated through prob, store; the final solution in iterate->fX . Monitor the residuals during the iterations; through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); Print information about the optimization process and monitor the convergence; status of thye algorithm. ~TGondzioSolver(); Deconstructor. TGondzioSolver & operator=(const TGondzioSolver& source); Assignment operator. void Reset_parameters(); {}. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TGondzioSolver.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGondzioSolver.html:9198,optimiz,optimization,9198,root/html532/TGondzioSolver.html,https://root.cern,https://root.cern/root/html532/TGondzioSolver.html,1,['optimiz'],['optimization']
Performance,"ble_t>fMethodWeight; vector<IMethod*>fMethodsvector of all classifiers; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMVA::IMethod* GetMethod(const TString& title) const; returns pointer to MVA that corresponds to given method title. TMVA::IMethod* GetMethod(const Int_t index) const; returns pointer to MVA that corresponds to given method index. void AddWeightsXMLTo(void* parent) const. ~MethodCompositeBase( void ); delete methods. void ReadWeightsFromXML(void* wghtnode); XML streamer. void ReadWeightsFromStream(istream& istr); text streamer. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); return composite MVA response. void Train(); performs classifier training. const Ranking* CreateRanking(); create ranking. UInt_t GetMethodIndex(); { return fMethodIndex; }. IMethod* GetLastMethod(); { return fMethods.back(); }. IMethod* GetPreviousMethod(); { return (fMethodIndex>0)?fMethods[fMethodIndex-1]:0; }. IMethod* GetCurrentMethod(); { return (fMethodIndex>0)?fMethods[fMethodIndex]:0; }. void DeclareOptions(). void ProcessOptions(). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Or Cohen » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodCompositeBase.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCompositeBase.html:16427,perform,performs,16427,root/html528/TMVA__MethodCompositeBase.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCompositeBase.html,1,['perform'],['performs']
Performance,"ble_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooIntegralMorph.html:5737,cache,cacheUniqueSuffix,5737,root/html602/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html602/RooIntegralMorph.html,2,['cache'],['cacheUniqueSuffix']
Performance,"ble_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; const RooFormulaVar&basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooResolutionModel.html:3766,cache,cacheUniqueSuffix,3766,root/html528/RooResolutionModel.html,https://root.cern,https://root.cern/root/html528/RooResolutionModel.html,2,['cache'],['cacheUniqueSuffix']
Performance,"ble_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; const RooArgList&boundaries(); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStepFunction.html:2321,cache,cacheUniqueSuffix,2321,root/html602/RooStepFunction.html,https://root.cern,https://root.cern/root/html602/RooStepFunction.html,2,['cache'],['cacheUniqueSuffix']
Performance,ble_t_d; RooDataSet&_data; vector<vector<Double_t> >_dataPts; vector<TVectorD>_dataPtsR; RooArgSet_dataVars; Bool_t_debug; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; TVectorD*_dx; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_fixedShape; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooNDKeysPdf::BoxInfo_fullBoxInfo; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; vector<Int_t>_idx; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Double_t_maxWeight; vector<Double_t>_mean; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; Double_t_minWeight; Bool_t_mirror; Double_t_n; Int_t_nDim; Int_t_nEvents; Double_t_nEventsBMSW; Double_t_nEventsBW; Int_t_nEventsM; Double_t_nEventsW; Double_t_nSigma; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; Bool_t_netFluxZ; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; TString_options; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot b,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNDKeysPdf.html:39285,cache,cache,39285,root/html526/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html526/RooNDKeysPdf.html,1,['cache'],['cache']
Performance,ble_t_d; RooDataSet&_data; vector<vector<Double_t> >_dataPts; vector<TVectorD>_dataPtsR; RooArgSet_dataVars; Bool_t_debug; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; TVectorD*_dx; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_fixedShape; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooNDKeysPdf::BoxInfo_fullBoxInfo; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; vector<Int_t>_idx; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Double_t_maxWeight; vector<Double_t>_mean; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; Double_t_minWeight; Bool_t_mirror; Double_t_n; Int_t_nDim; Int_t_nEvents; Double_t_nEventsBMSW; Double_t_nEventsBW; Int_t_nEventsM; Double_t_nEventsW; Double_t_nSigma; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; Bool_t_netFluxZ; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; TString_options; RooArgSet*R,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNDKeysPdf.html:39667,cache,cache,39667,root/html528/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html528/RooNDKeysPdf.html,3,['cache'],['cache']
Performance,"bles ; (; const RooArgSet & ; nset); const. protectedpure virtual . Implemented in RooCachedReal, and RooNumRunningInt. ◆ actualParameters(). virtual RooFit::OwningPtr< RooArgSet > RooAbsCachedReal::actualParameters ; (; const RooArgSet & ; nset); const. protectedpure virtual . Implemented in RooCachedReal, and RooNumRunningInt. ◆ analyticalIntegralWN(). double RooAbsCachedReal::analyticalIntegralWN ; (; Int_t ; code, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Forward call to implementation in relevant RooHistFunc instance. ; Reimplemented from RooAbsReal.; Definition at line 320 of file RooAbsCachedReal.cxx. ◆ binningName(). virtual const char * RooAbsCachedReal::binningName ; (; ); const. inlineprotectedvirtual . Reimplemented in RooNumRunningInt.; Definition at line 96 of file RooAbsCachedReal.h. ◆ cacheNameSuffix(). TString RooAbsCachedReal::cacheNameSuffix ; (; const RooArgSet & ; nset); const. protected . Construct unique suffix name for cache p.d.f object. ; Definition at line 225 of file RooAbsCachedReal.cxx. ◆ Class(). static TClass * RooAbsCachedReal::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCachedReal::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCachedReal::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 120 of file RooAbsCachedReal.h. ◆ createCache(). RooAbsCachedReal::FuncCacheElem * RooAbsCachedReal::createCache ; (; const RooArgSet * ; nset); const. protectedvirtual . Interface function to create an internal cache object that represent each cached function configuration. ; This interface allows to create and return a class derived from RooAbsCachedReal::FuncCacheElem so that a derived class fillCacheObject implementation can utilize extra functionality defined in such a derived cache class ; Reimplemented in RooCachedReal, and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedReal.html:63967,cache,cache,63967,doc/master/classRooAbsCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedReal.html,1,['cache'],['cache']
Performance,"bles this is the index in IndexValues table, not entry# ! use lower_bound STD algorithm. ; Definition at line 381 of file TTreeIndex.cxx. ◆ GetEntryNumberFriend(). Long64_t TTreeIndex::GetEntryNumberFriend ; (; const TTree * ; parent). overridevirtual . Returns the entry number in this (friend) Tree corresponding to entry in the master Tree 'parent'. ; In case this (friend) Tree and 'master' do not share an index with the same major and minor name, the entry serial number in the (friend) tree and in the master Tree are assumed to be the same ; Implements TVirtualIndex.; Definition at line 343 of file TTreeIndex.cxx. ◆ GetEntryNumberWithBestIndex(). Long64_t TTreeIndex::GetEntryNumberWithBestIndex ; (; Long64_t ; major, . Long64_t ; minor . ); const. overridevirtual . Return entry number corresponding to major and minor number. ; Note that this function returns only the entry number, not the data To read the data corresponding to an entry number, use TTree::GetEntryWithIndex the BuildIndex function has created a table of Double_t* of sorted values corresponding to val = major<<31 + minor; The function performs binary search in this sorted table. If it finds a pair that maches val, it returns directly the index in the table. If an entry corresponding to major and minor is not found, the function returns the index of the major,minor pair immediately lower than the requested value, ie it will return -1 if the pair is lower than the first entry in the index.; See also GetEntryNumberWithIndex ; Implements TVirtualIndex.; Definition at line 416 of file TTreeIndex.cxx. ◆ GetEntryNumberWithIndex(). Long64_t TTreeIndex::GetEntryNumberWithIndex ; (; Long64_t ; major, . Long64_t ; minor . ); const. overridevirtual . Return entry number corresponding to major and minor number. ; Note that this function returns only the entry number, not the data To read the data corresponding to an entry number, use TTree::GetEntryWithIndex the BuildIndex function has created a table of Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeIndex.html:20715,perform,performs,20715,doc/master/classTTreeIndex.html,https://root.cern,https://root.cern/doc/master/classTTreeIndex.html,1,['perform'],['performs']
Performance,"bles; 2976/// (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; 2977/// F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; 2978/// current values of x2 and x4. The caller takes ownership of the returned adaptor.; 2979 ; 2980RooFit::OwningPtr<RooAbsFunc> RooAbsReal::bindVars(const RooArgSet &vars, const RooArgSet* nset, bool clipInvalid) const; 2981{; 2982 auto binding = std::make_unique<RooRealBinding>(*this,vars,nset,clipInvalid);; 2983 if(!binding->isValid()) {; 2984 coutE(InputArguments) << ClassName() << ""::"" << GetName() << "":bindVars: cannot bind to "" << vars << std::endl ;; 2985 return nullptr;; 2986 }; 2987 return RooFit::makeOwningPtr(std::unique_ptr<RooAbsFunc>{std::move(binding)});; 2988}; 2989 ; 2990 ; 2991 ; 2992////////////////////////////////////////////////////////////////////////////////; 2993/// Copy the cached value of another RooAbsArg to our cache.; 2994/// Warning: This function just copies the cached values of source,; 2995/// it is the callers responsibility to make sure the cache is clean.; 2996 ; 2997void RooAbsReal::copyCache(const RooAbsArg* source, bool /*valueOnly*/, bool setValDirty); 2998{; 2999 auto other = static_cast<const RooAbsReal*>(source);; 3000 assert(dynamic_cast<const RooAbsReal*>(source));; 3001 ; 3002 _value = other->_treeReadBuffer ? other->_treeReadBuffer->operator double() : other->_value;; 3003 ; 3004 if (setValDirty) {; 3005 setValueDirty() ;; 3006 }; 3007}; 3008 ; 3009 ; 3010////////////////////////////////////////////////////////////////////////////////; 3011 ; 3012void RooAbsReal::attachToVStore(RooVectorDataStore& vstore); 3013{; 3014 vstore.addReal(this)->setBuffer(this,&_value);; 3015}; 3016 ; 3017 ; 3018////////////////////////////////////////////////////////////////////////////////; 3019/// Attach object to a branch of given TTree. By default it will; 3020/// register the internal value cache RooAbsReal::_value as branch; 3021/// buffer for a double tree branch wit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:129991,cache,cached,129991,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,2,['cache'],"['cache', 'cached']"
Performance,"bles; RooRefArrayRooAbsArg::_proxyListlist of proxies; string_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_t_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_t_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_t_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_t_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsTestStatistic(); Destructor. Double_t evaluate() const; Calculates and return value of test statistic. If the test statistic; is calculated from on a RooSimultaneous, the test statistic calculation; is performed separately on each simultaneous p.d.f component and associated; data and then combined. If the test statistic calculation is parallelized; partitions are calculated in nCPU processes and a posteriori combined. Bool_t initialize(); One-time initialization of the test",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsTestStatistic.html:38544,cache,cache,38544,root/html534/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsTestStatistic.html,1,['cache'],['cache']
Performance,"blic Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TMultiGraph Class ReferenceHistogram Library » Graph classes. ; A TMultiGraph is a collection of TGraph (or derived) objects. . Introduction; MultiGraphs' drawing; Setting drawing options; Titles setting; The option &quot;3D&quot;; Legend drawing; Automatic coloring; Reverse axis. MultiGraphs' fitting; Fit box position. Axis' limits setting. Introduction; A TMultiGraph allows to manipulate a set of graphs as a single entity. In particular, when drawn, the X and Y axis ranges are automatically computed such as all the graphs will be visible.; TMultiGraph::Add should be used to add a new graph to the list.; The TMultiGraph owns the objects in the list.; The number of graphs in a multigraph can be retrieve with: mg->GetListOfGraphs()->GetEntries();. MultiGraphs' Drawing; The drawing options are the same as for TGraph. Like for TGraph, the painting is performed thanks to the TGraphPainter class. All details about the various painting options are given in this class.; Example: TGraph *gr1 = new TGraph(...; TGraphErrors *gr2 = new TGraphErrors(...; TMultiGraph *mg = new TMultiGraph();; mg->Add(gr1,""lp"");; mg->Add(gr2,""cp"");; mg->Draw(""a"");; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects.Definition TMultiGraph.h:34; TMultiGraph::TMultiGraphTMultiGraph()TMultiGraph default constructor.Definition TMultiGraph.cxx:369; TMultiGraph::Addvirtual void Add(TGraph *graph, Option_t *chopt="""")Add a new graph to the list of graphs.Definition TMultiGraph.cxx:419; Setting drawing options; The drawing option for each TGraph may be specified as an optional second argument of the Add function.; If a draw option is specified, it will be used to draw the gr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiGraph.html:1138,perform,performed,1138,doc/master/classTMultiGraph.html,https://root.cern,https://root.cern/doc/master/classTMultiGraph.html,1,['perform'],['performed']
Performance,"blic RooSimWSTool::BuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'maste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimWSTool__MultiBuildConfig.html:1331,perform,performed,1331,root/html526/RooSimWSTool__MultiBuildConfig.html,https://root.cern,https://root.cern/root/html526/RooSimWSTool__MultiBuildConfig.html,4,['perform'],['performed']
Performance,"blities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooKeysPdf.html:39626,cache,cache,39626,root/html526/RooKeysPdf.html,https://root.cern,https://root.cern/root/html526/RooKeysPdf.html,6,['cache'],['cache']
Performance,"blocks with indices of passing events (TEntryListBlocks) ; Definition at line 35 of file TEntryList.h. ◆ fCurrent. TEntryList* TEntryList::fCurrent. protected . ! currently filled entry list ; Definition at line 32 of file TEntryList.h. ◆ fDirectory. TDirectory* TEntryList::fDirectory. protected . ! Pointer to directory holding this tree ; Definition at line 48 of file TEntryList.h. ◆ fEntriesToProcess. Long64_t TEntryList::fEntriesToProcess. protected . used on proof to set the number of entries to process in a packet ; Definition at line 37 of file TEntryList.h. ◆ fFileName. TString TEntryList::fFileName. protected . name of the file, where the tree is ; Definition at line 39 of file TEntryList.h. ◆ fLastIndexQueried. Long64_t TEntryList::fLastIndexQueried. protected . ! used to optimize GetEntry() function from a loop ; Definition at line 44 of file TEntryList.h. ◆ fLastIndexReturned. Long64_t TEntryList::fLastIndexReturned. protected . ! used to optimize GetEntry() function from a loop ; Definition at line 45 of file TEntryList.h. ◆ fLists. TList* TEntryList::fLists. protected . a list of underlying entry lists for each tree of a chain ; Definition at line 31 of file TEntryList.h. ◆ fN. Long64_t TEntryList::fN. protected . number of entries in the list ; Definition at line 36 of file TEntryList.h. ◆ fNBlocks. Int_t TEntryList::fNBlocks. protected . number of TEntryListBlocks ; Definition at line 34 of file TEntryList.h. ◆ fReapply. bool TEntryList::fReapply. protected . If true, TTree::Draw will 'reapply' the original cut. ; Definition at line 49 of file TEntryList.h. ◆ fShift. bool TEntryList::fShift. protected . ! true when some sub-lists don't correspond to trees (when the entry list is used as input in TChain) ; Definition at line 46 of file TEntryList.h. ◆ fStringHash. ULong_t TEntryList::fStringHash. protected . ! Hash value of a string of treename and filename ; Definition at line 40 of file TEntryList.h. ◆ fTreeName. TString TEntryList::fTreeName. protect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryList.html:42881,optimiz,optimize,42881,doc/master/classTEntryList.html,https://root.cern,https://root.cern/doc/master/classTEntryList.html,1,['optimiz'],['optimize']
Performance,"bnormal termination of minimization."");; 919 ; 920 const ROOT::Fit::FitResult & fitResult = fitter->Result();; 921 // one could set directly the fit result in TF1; 922 int iret = fitResult.Status();; 923 if (!fitResult.IsEmpty() ) {; 924 // set in fitfunc the result of the fit; 925 fitfunc->SetNDF(fitResult.Ndf() );; 926 fitfunc->SetNumberFitPoints(fitdata->Size() );; 927 ; 928 assert( (Int_t)fitResult.Parameters().size() >= fitfunc->GetNpar() );; 929 fitfunc->SetParameters( const_cast<double*>(&(fitResult.Parameters().front())));; 930 if ( int( fitResult.Errors().size()) >= fitfunc->GetNpar() ); 931 fitfunc->SetParErrors( &(fitResult.Errors().front()) );; 932 ; 933 }; 934 ; 935 // store fitting result in the backward compatible TVirtualFitter object; 936 // lock in case running in a multi-thread enabled mode; 937 {; 938 R__LOCKGUARD(gROOTMutex);; 939 TVirtualFitter * lastFitter = TVirtualFitter::GetFitter();; 940 TBackCompFitter * bcfitter = new TBackCompFitter(fitter, fitdata);; 941 // cannot use anymore now fitdata (given away ownership); 942 fitdata = nullptr;; 943 bcfitter->SetFitOption(fitOption);; 944 bcfitter->SetUserFunc(fitfunc);; 945 // delete previous fitter and replace with the new one; 946 if (lastFitter) delete lastFitter;; 947 TVirtualFitter::SetFitter( bcfitter );; 948 ; 949 // print results; 950 if (fitOption.Verbose) fitResult.PrintCovMatrix(std::cout);; 951 else if (!fitOption.Quiet) fitResult.Print(std::cout);; 952 }; 953 ; 954 ; 955 if (fitOption.StoreResult); 956 {; 957 TString name = ""TFitResult-"";; 958 name = name + ""UnBinData-"" + fitfunc->GetName();; 959 TString title = ""TFitResult-"";; 960 title += name;; 961 tfr->SetName(name);; 962 tfr->SetTitle(title);; 963 return TFitResultPtr(tfr);; 964 }; 965 else; 966 return TFitResultPtr(iret);; 967}; 968 ; 969 ; 970// implementations of ROOT::Fit::FitObject functions (defined in HFitInterface) in terms of the template HFit::Fit; 971 ; 972TFitResultPtr ROOT::Fit::FitObject(TH1 * h1, TF1 *f1 , Foption",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitImpl_8cxx_source.html:35136,multi-thread,multi-thread,35136,doc/master/HFitImpl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitImpl_8cxx_source.html,1,['multi-thread'],['multi-thread']
Performance,"boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsPdf.html:44931,cache,cache,44931,root/html602/RooAbsPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html,4,['cache'],['cache']
Performance,"boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooArgSet*_curNormSet!; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProjectedPdf.html:42221,cache,cache,42221,root/html602/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html602/RooProjectedPdf.html,2,['cache'],['cache']
Performance,"boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooArgSet*_curNormSet! Current normalization set; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; TVectorD*_mref; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMomentMorph.html:40690,cache,cache,40690,root/html534/RooMomentMorph.html,https://root.cern,https://root.cern/root/html534/RooMomentMorph.html,2,['cache'],['cache']
Performance,"boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooArgSet*_curNormSet! Current normalization set; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; TVectorD*_mref; static Int_tRooPrinta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMomentMorph.html:40411,cache,cache,40411,root/html534/RooMomentMorph.html,https://root.cern,https://root.cern/root/html534/RooMomentMorph.html,1,['cache'],['cache']
Performance,"boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; vector<double>_high; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Double_t_interpBoundary; vector<int>_interpCode; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Bool_t_logInit! flag used for chaching polynomial coefficients; vector<double>_low; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__FlexibleInterpVar.html:34258,cache,cache,34258,root/html534/RooStats__HistFactory__FlexibleInterpVar.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__FlexibleInterpVar.html,2,['cache'],['cache']
Performance,"boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooResolutionModel.html:44207,cache,cache,44207,root/html602/RooResolutionModel.html,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html,4,['cache'],['cache']
Performance,"boolean attributes (not copied in ctor); UChar_t_byteValue! Transient cache for byte values from tree branches ; static Bool_t_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_t_floatValue! Transient cache for floating point values from tree branches ; Bool_t_forceNumIntForce numerical integration if flag set; static Bool_t_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intValue! Transient cache for integer values from tree branches ; TString_labelPlot label for objects value; RooArgSet*_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_t_plotBinsNumber of plot bins; Double_t_plotMaxMaximum of plot range; Double_t_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_t_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:29189,cache,cache,29189,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,1,['cache'],['cache']
Performance,"boolean attributes (not copied in ctor); UChar_t_byteValue! Transient cache for byte values from tree branches ; static Bool_t_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_t_floatValue! Transient cache for floating point values from tree branches ; Bool_t_forceNumIntForce numerical integration if flag set; static Bool_t_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intValue! Transient cache for integer values from tree branches ; TString_labelPlot label for objects value; RooArgSet*_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_t_plotBinsNumber of plot bins; Double_t_plotMaxMaximum of plot range; Double_t_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_t_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsReal.html:29719,cache,cache,29719,root/html528/RooAbsReal.html,https://root.cern,https://root.cern/root/html528/RooAbsReal.html,2,['cache'],['cache']
Performance,"bool GetTopVisible () const;  Returns draw options, used for JSROOT TGeoPainter. ;  ; int GetVisLevel () const;  Returns maximal visible level. ;  ; bool HasDrawData () const;  Check if there is draw data available. ;  ; bool IsBuild () const;  ; int IsBuildShapes () const;  Returns true if binary 3D model build already by C++ server (default) ;  ; bool IsPreferredOffline () const;  Is offline operations preferred. ;  ; bool IsPrincipalEndNode (int nodeid);  return true when node used in main geometry drawing and does not have childs for such nodes one could provide optimize toggling of visibility flags ;  ; void IssueSignal (const void *handler, const std::string &kind);  Issue signal, which distributed on all handlers - excluding source handler. ;  ; std::vector< int > MakeIdsByStack (const std::vector< int > &stack);  Produce list of node ids for given stack If found nodes preselected - use their ids. ;  ; std::unique_ptr< RGeomNodeInfo > MakeNodeInfo (const std::vector< int > &stack);  Change visibility for specified element Returns true if changes was performed. ;  ; std::vector< std::string > MakePathByStack (const std::vector< int > &stack);  Returns path string for provided stack. ;  ; std::vector< int > MakeStackByIds (const std::vector< int > &ids);  Creates stack for given array of ids, first element always should be 0. ;  ; std::vector< int > MakeStackByPath (const std::vector< std::string > &path);  Produce stack based on string path Used to highlight geo volumes by browser hover event. ;  ; std::string ProcessBrowserRequest (const std::string &req="""");  Find description object for requested shape If not exists - will be created. ;  ; void ProduceDrawData ();  Collect all information required to draw geometry on the client This includes list of each visible nodes, meshes and matrixes. ;  ; bool ProduceDrawingFor (int nodeid, std::string &json, bool check_volume=false);  Produce shape rendering data for given stack All nodes, which are referencing same s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html:3634,perform,performed,3634,doc/v632/classROOT_1_1RGeomDescription.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html,2,['perform'],['performed']
Performance,"bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgSet &set) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgsByName (const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;  Check if allArgs contains matching elements for each name in nameList. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  ; virtual RooPlot * plotOn (RooPlot *frame, PlotOpt o) const;  Plotting engine function for internal use. ;  ; void plotOnCompSelect (RooArgSet *selNodes) const;  Helper function for plotting of composite p.d.fs. ;  ; RooPlot * plotOnWithErrorBand (RooPlot *frame, const RooFitResult &fr, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  Function that is called at the end of redirectServers(). ;  ; virtual void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; virtual void selectNormalizationRange (const char *rangeName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the dat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooErrorVar.html:61037,perform,perform,61037,doc/master/classRooErrorVar.html,https://root.cern,https://root.cern/doc/master/classRooErrorVar.html,1,['perform'],['perform']
Performance,"bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgSet &set) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgsByName (const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;  Check if allArgs contains matching elements for each name in nameList. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  ; virtual RooPlot * plotOn (RooPlot *frame, PlotOpt o) const;  Plotting engine function for internal use. ;  ; void plotOnCompSelect (RooArgSet *selNodes) const;  Helper function for plotting of composite p.d.fs. ;  ; RooPlot * plotOnWithErrorBand (RooPlot *frame, const RooFitResult &fr, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  Function that is called at the end of redirectServers(). ;  ; virtual void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; virtual void selectNormalizationRange (const char *rangeName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinWidthFunction.html:54176,perform,perform,54176,doc/master/classRooBinWidthFunction.html,https://root.cern,https://root.cern/doc/master/classRooBinWidthFunction.html,61,['perform'],['perform']
Performance,"bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgSet &set) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgsByName (const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;  Check if allArgs contains matching elements for each name in nameList. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCategoryLValue &asymCat, PlotOpt o) const;  ; virtual RooPlot * plotOn (RooPlot *frame, PlotOpt o) const;  Plotting engine function for internal use. ;  ; void plotOnCompSelect (RooArgSet *selNodes) const;  Helper function for plotting of composite p.d.fs. ;  ; RooPlot * plotOnWithErrorBand (RooPlot *frame, const RooFitResult &fr, double Z, const RooArgSet *params, const RooLinkedList &argList, bool method1) const;  Plot function or PDF on frame with support for visualization of the uncertainty encoded in the given fit result fr. ;  ; bool plotSanityChecks (RooPlot *frame) const;  Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. ;  ; virtual void selectNormalization (const RooArgSet *depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; virtual void selectNormalizationRange (const char *rangeName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:56521,perform,perform,56521,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,6,['perform'],['perform']
Performance,"box, this can be done like:; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N);; Here SLICEX is the name of the new family representing all slices and 1 is the slicing axis. The meaning of the axis index is the following: for all volumes having shapes like box, trd1, trd2, trap, gtraorpara -1, 2, 3 mean X, Y, Z; for tube, tubs, cone, cons -1 means Rxy, 2 means phi and 3 means Z; for pcon and pgon - 2 means phi and 3 means Z; for spheres 1 means Rand 2 means phi.; In fact, the division operation has the same effect as positioning volumes in a given order inside the divided container - the advantage being that the navigation in such a structure is much faster. When a volume is divided, a volume family corresponding to the slices is created. In case all slices can be represented by a single shape, only one volume is added to the family and positioned N times inside the divided volume, otherwise, each slice will be represented by a distinct volume in the family.; Divisions can be also performed in a given range of one axis. For that, one has to specify also the starting coordinate value and the step:; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N,start,step);; A check is always done on the resulting division range: if not fitting into the container limits, an error message is posted. If we will browse the divided volume we will notice that it will contain N nodes starting with index 1 up to N. The first one has the lower X limit at START position, while the last one will have the upper X limit at START+N*STEP. The resulting slices cannot be positioned inside another volume (they are by default positioned inside the divided one) but can be further divided and may contain other volumes:; TGeoVolume *slicey = slicex->Divide(""SLICEY"",2,N1);; slicey->AddNode(other_vol,index,some_matrix);; When doing that, we have to remember that SLICEY represents a family, therefore all members of the family will be divided on Y and the other volume will be added as node inside all.; In the exa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:955355,perform,performed,955355,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performed']
Performance,"branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:134053,cache,cache,134053,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,1,['cache'],['cache']
Performance,"branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:39589,cache,cache,39589,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['cache'],['cache']
Performance,"branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:40130,cache,cache,40130,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,2,['cache'],['cache']
Performance,"branches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 541 of file TTreeCache.cxx. ◆ Enable(). virtual void TTreeCache::Enable ; (; ). inlinevirtual . Definition at line 137 of file TTreeCache.h. ◆ FillBuffer(). bool TTreeCache::FillBuffer ; (; ). virtual . Fill the cache buffer with the branches in the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 1114 of file TTreeCache.cxx. ◆ FillMissCache(). bool TTreeCache::FillMissCache ; (; ). private . Fill the miss cache from the current set of active branches. . ◆ FindBranchBasketPos(). TTreeCache::IOPos TTreeCache::FindBranchBasketPos ; (; TBranch & ; b, . Long64_t ; entry . ). private . Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ; For the event currently being fetched into the miss cache, find the IO (offset / length tuple) to pull in the current basket for a given branch.; Returns:; IOPos describing the IO operation necessary for the basket on this branch; On failure, IOPos.length will be set to 0. . Definition at line 716 of file TTreeCache.cxx. ◆ GetCachedBranches(). const TObjArray * TTreeCache::GetCachedBranches ; (; ); const. inline . Definition at line 139 of file TTreeCache.h. ◆ GetConfiguredPrefillType(). TTreeCache::EPrefillType TTreeCache::GetConfiguredPrefillType ; (; ); const. Return the desired prefill type from the environment or resource variable. . 0 - No prefill; 1 - All branches . Definition at line 1802 of file TTreeCache.cxx. ◆ GetEfficiency(). Double_t TTreeCache::GetEfficiency ; (; ); const. Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ; the number of blocks prefetched ( it could be more than 1 if we read the same block from the cache more than once ); Note: This should eb used at the end of the proce",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:39709,cache,cache,39709,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cache']
Performance,"branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:24250,cache,cache,24250,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,1,['cache'],['cache']
Performance,"branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:23633,cache,cache,23633,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,1,['cache'],['cache']
Performance,"branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Readin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:20931,cache,cache,20931,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,1,['cache'],['cache']
Performance,"branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:22931,cache,cache,22931,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,2,['cache'],['cache']
Performance,"branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranch(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... he",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:5101,cache,cachesize,5101,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,6,['cache'],"['cache', 'cachesize']"
Performance,"branchname' as if it was a data member; protection against array out-of-bounds errors; ability to use the branch data as an object (when the user code is available). For example with Event.root, if Double_t somePx = fTracks.fPx[2];; double; is executed by one of the method of the skeleton, somePx will updated with the current value of fPx of the 3rd track.; Both macrofilename and the optional cutfilename are expected to be the name of source files which contain at least a free standing function with the signature: x_t macrofilename(); // i.e function with the same name as the file; and y_t cutfilename(); // i.e function with the same name as the file; x_t and y_t needs to be types that can convert respectively to a double and a bool (because the skeleton uses: if (cutfilename()) htemp->Fill(macrofilename());; These two functions are run in a context such that the branch names are available as local variables of the correct (read-only) type.; Note that if you use the same 'variable' twice, it is more efficient to 'cache' the value. For example: Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; nconst Int_t nDefinition legend1.C:16; is more efficient than if (fEventNumber<10 || fEventNumber>10); Also, optionally, the generated selector will also call methods named macrofilename_methodname in each of 6 main selector methods if the method macrofilename_methodname exist (Where macrofilename is stripped of its extension).; Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> bool h1analysisProxy_Notify();; Process -> bool h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist it is included before the declaration of the proxy class. This can ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:177292,cache,cache,177292,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['cache'],['cache']
Performance,"brary. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int OpenConnection(const char* server, int port, int tcpwindowsize = -1); Open a connection to another host. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service. int AnnounceUnixService(int port, int backlog); Announce unix domain service. int AnnounceUnixService(const char* sockpath, int backlog); Announce unix domain service. int AcceptConnection(int sock); A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:34793,load,loaded,34793,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,2,['load'],['loaded']
Performance,"brary. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); Open a connection to another host. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service. int AnnounceUdpService(int port, int backlog); Announce UDP service. int AnnounceUnixService(int port, int backlog); Announce unix domain service. int AnnounceUnixService(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSystem.html:34946,load,loaded,34946,root/html532/TSystem.html,https://root.cern,https://root.cern/root/html532/TSystem.html,1,['load'],['loaded']
Performance,"brary; not loaded. int UnixDynLoad(const char* lib); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. Func_t UnixDynFindSymbol(const char* lib, const char* entry); Finds and returns a function pointer to a symbol in the shared library.; Returns 0 when symbol not found. void UnixDynListSymbols(const char* lib, const char* re = """"); List symbols in a shared library. One can use wildcards to list only; the interesting symbols. void UnixDynListLibs(const char* lib = """"); List all loaded shared libraries. void UnixDynUnload(const char* lib); Unload a shared library. int ReadUtmpFile(); Read utmp file. Returns number of entries in utmp file. void * SearchUtmpEntry(int nentries, const char* tty); Look for utmp entry which is connected to terminal tty. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/unix:$Id: TUnixSystem.h 37109 2010-11-30 16:30:58Z pcanal $ » Last generated: 2010-12-09 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:42634,load,load,42634,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,3,['load'],['load']
Performance,"brary; not loaded. int UnixDynLoad(const char* lib); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. Func_t UnixDynFindSymbol(const char* lib, const char* entry); Finds and returns a function pointer to a symbol in the shared library.; Returns 0 when symbol not found. void UnixDynListSymbols(const char* lib, const char* re = """"); List symbols in a shared library. One can use wildcards to list only; the interesting symbols. void UnixDynListLibs(const char* lib = """"); List all loaded shared libraries. void UnixDynUnload(const char* lib); Unload a shared library. int ReadUtmpFile(); Read utmp file. Returns number of entries in utmp file. void * SearchUtmpEntry(int nentries, const char* tty); Look for utmp entry which is connected to terminal tty. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/unix:$Id: TUnixSystem.h 37109 2010-11-30 16:30:58Z pcanal $ » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TUnixSystem.html:42703,load,load,42703,root/html530/TUnixSystem.html,https://root.cern,https://root.cern/root/html530/TUnixSystem.html,3,['load'],['load']
Performance,"bsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsCategory::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBinningCategory.html:16520,cache,cache,16520,root/html534/RooBinningCategory.html,https://root.cern,https://root.cern/root/html534/RooBinningCategory.html,1,['cache'],['cache']
Performance,"bsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Int_t_coefIdxIndex code of the coefficient; RooRealProxy_convPdfRooAbsAnaConv object implementing our coefficient; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooConvCoefVar.html:33301,cache,cache,33301,root/html534/RooConvCoefVar.html,https://root.cern,https://root.cern/root/html534/RooConvCoefVar.html,3,['cache'],['cache']
Performance,bsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealProxyRooAbsAnaConvPdf::_convVarConvolution variable; RooRealProxy_delMistag; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooRealProxy_dm; RooRealProxy_effRatio; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode fo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBCPEffDecay.html:43788,cache,cache,43788,root/html602/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html602/RooBCPEffDecay.html,2,['cache'],['cache']
Performance,bsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; TIterator*_highIter! Iterator over highSet; RooListProxy_highSetHigh-side varaition; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; TIterator*_lowIter! Iterator over lowSet; RooListProxy_lowSetLow-side variation; static Int_tRooPrintable::_nameLength; RooRealProxy_nominalThe nominal value; RooObjCacheManager_normIntMgrThe integration cache manager; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; TIterator*_paramIter! Iterator over paramSet; RooListProxy_paramSetinterpolation parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_t_positiveDefiniteprotect against negative and 0 bins.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/PiecewiseInterpolation.html:31620,cache,cache,31620,root/html530/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html530/PiecewiseInterpolation.html,2,['cache'],['cache']
Performance,bsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealProxyRooAbsAnaConvPdf::_convVarConvolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooR,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDecay.html:41586,cache,cache,41586,root/html534/RooDecay.html,https://root.cern,https://root.cern/root/html534/RooDecay.html,1,['cache'],['cache']
Performance,"bsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; TIterator*_lowIter! Iterator over lowSet; RooListProxy_lowSetLow-side variation; static Int_tRooPrintable::_nameLength; RooRealProxy_nominalThe nominal value; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; TIterator*_paramIter! Iterator over paramSet; RooListProxy_paramSetinterpolation parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/PiecewiseInterpolation.html:32373,cache,cache,32373,root/html528/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html528/PiecewiseInterpolation.html,2,['cache'],['cache']
Performance,"bsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidsetVal(const char* newVal); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStringVar.html:12856,cache,cache,12856,root/html528/RooStringVar.html,https://root.cern,https://root.cern/root/html528/RooStringVar.html,1,['cache'],['cache']
Performance,"bsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidsetVal(const char* newVal); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStringVar.html:12721,cache,cache,12721,root/html526/RooStringVar.html,https://root.cern,https://root.cern/root/html526/RooStringVar.html,1,['cache'],['cache']
Performance,"bsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCategory.html:13766,cache,cache,13766,root/html528/RooAbsCategory.html,https://root.cern,https://root.cern/root/html528/RooAbsCategory.html,7,['cache'],['cache']
Performance,"bsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCategory.html:13631,cache,cache,13631,root/html526/RooAbsCategory.html,https://root.cern,https://root.cern/root/html526/RooAbsCategory.html,7,['cache'],['cache']
Performance,"bsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsHiddenReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooUnblindCPAsymVar.html:25389,cache,cache,25389,root/html532/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html532/RooUnblindCPAsymVar.html,4,['cache'],['cache']
Performance,"bsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsAnaConvPdf.html:31370,cache,cache,31370,root/html528/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsAnaConvPdf.html,130,['cache'],['cache']
Performance,"bsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; RooAbsReal & cloneModel () const;  ; RooAbsReal & clonePdf () const;  ; RooRealVar & cloneVar () const;  ; void initialize () const;  One-time initialization of object. ;  ; void printCompactTreeHook (std::ostream &os, const char *indent="""") override;  Hook function to intercept printCompactTree() calls so that it can print out the content of its private cache in the print sequence. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursive) override;  Intercept server redirects. Throw away cache, as figuring out redirections on the cache is an unsolvable problem. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvolution.html:51656,cache,cached,51656,doc/master/classRooNumConvolution.html,https://root.cern,https://root.cern/doc/master/classRooNumConvolution.html,2,['cache'],"['cache', 'cached']"
Performance,"bsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. return getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx, const char* isetRangeName). Int_t setObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Setter function without integration set. Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface function to intercept server redirects. void operModeHook(); Interface function to intercept cache operation mode changes. void printCompactTreeHook(ostream& , const char* ); Interface function to cache add contents to output in tree printing mode. void insertObjectHook(RooAbsCacheElement& ); Interface function to perform post-insert operations on cached object. void wireCache(). » Last changed: Fri Jun 19 21:36:03 2015 » Last generated: 2015-06-19 21:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCacheManager_RooAbsCacheElement_.html:5005,cache,cacheSize,5005,root/html602/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html602/RooCacheManager_RooAbsCacheElement_.html,6,"['cache', 'perform']","['cache', 'cacheSize', 'cached', 'perform']"
Performance,"bsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. return getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx, const char* isetRangeName). Int_t setObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Setter function without integration set. Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface function to intercept server redirects. void operModeHook(); Interface function to intercept cache operation mode changes. void printCompactTreeHook(ostream& , const char* ); Interface function to cache add contents to output in tree printing mode. void insertObjectHook(RooAbsCacheElement& ); Interface function to perform post-insert operations on cached object. void wireCache(). » Last changed: Sat Jun 20 17:30:05 2015 » Last generated: 2015-06-20 17:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooCacheManager_RooAbsCacheElement_.html:5005,cache,cacheSize,5005,root/html604/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html604/RooCacheManager_RooAbsCacheElement_.html,6,"['cache', 'perform']","['cache', 'cacheSize', 'cached', 'perform']"
Performance,"bsCachedPdf::PdfCacheElem& cache) const; Fill the contents of the cache the FFT convolution output. void fillCacheSlice(RooFFTConvPdf::FFTCacheElem& cache, const RooArgSet& slicePosition) const; Fill a slice of cachePdf with the output of the FFT convolution calculation. Double_t* scanPdf(RooRealVar& obs, RooAbsPdf& pdf, const RooDataHist& hist, const RooArgSet& slicePos, Int_t& N, Int_t& N2, Int_t& zeroBin, Double_t shift) const; Scan the values of 'pdf' in observable 'obs' using the bin values stored in 'hist' at slice position 'slicePos'; N is filled with the number of bins defined in hist, N2 is filled with N plus the number of buffer bins; The return value is an array of doubles of length N2 with the sampled values. The caller takes ownership; of the array. RooArgSet* actualObservables(const RooArgSet& nset) const; Return the observables to be cached given the normalization set nset. If the cache observables is in nset then this is; - the convolution observable plus; - any member of nset that is either a RooCategory,; - or was previously specified through setCacheObservables(). In case the cache observable is _not_ in nset, then it is; - the convolution observable plus; - all member of nset are observables of this p.d.f. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters on which the cache depends given normalization; set nset. For this p.d.f these are the parameters of the input p.d.f.; but never the convolution variable, it case it is not part of nset. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; Return p.d.f. observable (which can be a function) to substitute given; p.d.f. observable. Substitute x by xprime if xprime is set. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Create appropriate generator context for this convolution. If both input p.d.f.s support; internal generation, if it is safe to use them and if no o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:48622,cache,cache,48622,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,7,['cache'],['cache']
Performance,"bsCachedReal.h. ◆ fillCacheObject(). virtual void RooAbsCachedReal::fillCacheObject ; (; FuncCacheElem & ; cache); const. protectedpure virtual . Implemented in RooCachedReal, RooNumCdf, and RooNumRunningInt. ◆ forceAnalyticalInt(). bool RooAbsCachedReal::forceAnalyticalInt ; (; const RooAbsArg & ; ); const. inlineoverridevirtual . Reimplemented from RooAbsReal.; Definition at line 43 of file RooAbsCachedReal.h. ◆ getAnalyticalIntegralWN(). Int_t RooAbsCachedReal::getAnalyticalIntegralWN ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. ; Reimplemented from RooAbsReal.; Definition at line 306 of file RooAbsCachedReal.cxx. ◆ getCache(). RooAbsCachedReal::FuncCacheElem * RooAbsCachedReal::getCache ; (; const RooArgSet * ; nset); const. protected . Retrieve cache corresponding to observables in nset. ; Definition at line 113 of file RooAbsCachedReal.cxx. ◆ getInterpolationOrder(). Int_t RooAbsCachedReal::getInterpolationOrder ; (; ); const. inline . Definition at line 38 of file RooAbsCachedReal.h. ◆ getValV(). double RooAbsCachedReal::getValV ; (; const RooArgSet * ; nset = nullptr); const. overridevirtual . Implementation of getVal() overriding default implementation of RooAbsReal. ; Return value stored in cache p.d.f rather than return value of evaluate() which is undefined for RooAbsCachedReal ; Reimplemented from RooAbsReal.; Definition at line 77 of file RooAbsCachedReal.cxx. ◆ inputBaseName(). virtual const char * RooAbsCachedReal::inputBaseName ; (; ); const. protectedpure virtual . Implemented in RooCachedReal, and RooNumRunningInt. ◆ IsA(). TClass * RooAbsCachedReal::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in RooCachedReal, RooNumCdf, and RooNumRunningInt.; D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedReal.html:66329,cache,cache,66329,doc/master/classRooAbsCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedReal.html,1,['cache'],['cache']
Performance,"bsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); virtual voidRooAbsCategoryLValue::setIndexFast(Int_t index); Bool_tRooAbsCategoryLValue::setOrdinal(UInt_t index, const char* rangeName); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); Bool_tsetType(const RooCatType* type, Bool_t prinError = kTRUE); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSuperCategory.html:19922,optimiz,optimizeDirtyHook,19922,root/html602/RooSuperCategory.html,https://root.cern,https://root.cern/root/html602/RooSuperCategory.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"bsCategoryLValue::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); virtual voidRooAbsCategoryLValue::setIndexFast(Int_t index); Bool_tRooAbsCategoryLValue::setOrdinal(UInt_t index, const char* rangeName); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCategory.html:19446,optimiz,optimizeDirtyHook,19446,root/html602/RooCategory.html,https://root.cern,https://root.cern/root/html602/RooCategory.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"bsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual RooAbsGenContext*RooAbsPdf::autoGenContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """") const; const RooFormulaVar&basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&basisConvVar() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; virtual RooAbsGenContext*RooAbsPdf::binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; virtual voidchangeBasis(RooFormulaVar* basis); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooResolutionModel.html:4189,cache,cacheUniqueSuffix,4189,root/html604/RooResolutionModel.html,https://root.cern,https://root.cern/root/html604/RooResolutionModel.html,1,['cache'],['cacheUniqueSuffix']
Performance,"bsData::RealSpans getBatches (std::size_t first, std::size_t len) const override;  Retrieve batches for all observables in this data store. ;  ; Stat_t GetEntries () const;  Interface function to TTree::GetEntries. ;  ; Int_t GetEntry (Int_t entry=0, Int_t getall=0);  Interface function to TTree::GetEntry. ;  ; std::span< const double > getWeightBatch (std::size_t first, std::size_t len) const override;  Get the weights of the events in the range [first, first+len). ;  ; TClass * IsA () const override;  ; bool isWeighted () const override;  ; void loadValues (const RooAbsDataStore *tds, const RooFormulaVar *select=nullptr, const char *rangeName=nullptr, std::size_t nStart=0, std::size_t nStop=std::numeric_limits< std::size_t >::max()) override;  Load values from dataset 't' into this data collection, optionally selecting events using 'select' RooFormulaVar. ;  ; void loadValues (const TTree *t, const RooFormulaVar *select=nullptr, const char *rangeName=nullptr, Int_t nStart=0, Int_t nStop=2000000000);  Load values from tree 't' into this data collection, optionally selecting events using the RooFormulaVar 'select'. ;  ; RooAbsDataStore * merge (const RooArgSet &allvars, std::list< RooAbsDataStore * > dstoreList) override;  Merge columns of supplied data set(s) with this data set. ;  ; Int_t numEntries () const override;  ; std::unique_ptr< RooAbsDataStore > reduce (RooStringView name, RooStringView title, const RooArgSet &vars, const RooFormulaVar *cutVar, const char *cutRange, std::size_t nStart, std::size_t nStop) override;  ; void reset () override;  ; void Reset (Option_t *option=nullptr);  Interface function to TTree::Reset. ;  ; void resetBuffers () override;  ; void resetCache () override;  Remove tree with values of cached observables and clear list of cached observables. ;  ; void restoreAlternateBuffers ();  ; const RooArgSet & row ();  ; void setArgStatus (const RooArgSet &set, bool active) override;  Activate or deactivate the branch status of the TTree b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:5114,load,loadValues,5114,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,1,['load'],['loadValues']
Performance,"bsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; [#0] ERROR:Minimization -- RooMinimizer: all function calls during minimization gave invalid NLL values!; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#0] ERROR:Eval -- RooAbsReal::logEvalError(pol3) evaluation error, ; origin : RooPolynomial::pol3[ x=x coefList=(a1,a2,a3) ]; message : p.d.f normalization integral is zero or negative: -2220.000000; server values: x=x=0, coefList=(a1 = 10 +/- 0,a2 = -1 +/- 0,a3 = 0.01); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pol3_over_pol3_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pol3_over_pol3_Int[x]_pol3Data) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -1002.2262595660759; Edm = 2.95538313214564806e-09; Nfcn = 251; a1 = -0.498159 +/- 0.0227242 (limited); a2 = 0.198316 +/- 0.00564906 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 0, estimated distance to minimum: 0; covariance matrix quality: Not calculated at all; Status : MINIMIZE=-1 HESSE=302 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a1 1.0000e+01 +/- 0.00e+00; a2 -1.0000e+00 +/- 0.00e+00; ; ; RooFitResult: minimized FCN value: 29650.9, estimated distance to minimum: 2.95925e-09; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html:6739,optimiz,optimization,6739,doc/master/rf612__recoverFromInvalidParameters_8py.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8py.html,1,['optimiz'],['optimization']
Performance,"bsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAddModel&operator=(const RooAddModel&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddModel.html:24467,optimiz,optimizeCacheMode,24467,root/html602/RooAddModel.html,https://root.cern,https://root.cern/root/html602/RooAddModel.html,4,['optimiz'],['optimizeCacheMode']
Performance,"bsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidwriteHistToFile(char* outputFile, const char* histName) const; voidwriteNTupleToFile(char* outputFile, const char* name) const; voidwriteToFile(char* outputFile, const char* name) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo2DKeysPdf.html:31965,cache,cache,31965,root/html534/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html534/Roo2DKeysPdf.html,1,['cache'],['cache']
Performance,bsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooAbsData*RooAbsOptTestStatistic::_origDataOriginal data ; RooAbsReal*RooAbsOptTestStatistic::_origFuncOriginal function ; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDataWeightedAverage.html:36123,cache,cache,36123,root/html532/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html532/RooDataWeightedAverage.html,1,['cache'],['cache']
Performance,"bsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tagFlav; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBMixDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBMixDecay.html:41668,cache,cache,41668,root/html528/RooBMixDecay.html,https://root.cern,https://root.cern/root/html528/RooBMixDecay.html,2,['cache'],['cache']
Performance,"bsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooTruthModel.html:44387,cache,cache,44387,root/html534/RooTruthModel.html,https://root.cern,https://root.cern/root/html534/RooTruthModel.html,1,['cache'],['cache']
Performance,"bsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxyalphaInterpolation parameter; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdf1First input shape; RooRealProxypdf2Second input shape; RooRealProxyxObservable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooIntegralMorph.html:48130,cache,cache,48130,root/html534/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html534/RooIntegralMorph.html,1,['cache'],['cache']
Performance,"bsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfItr!; RooListProxy_pdfList; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooMomentMorph::Setting_setting; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; TIterator*_varItr! do not persist; RooSetProxy_varList; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxym.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMomentMorph.html:39883,cache,cache,39883,root/html528/RooMomentMorph.html,https://root.cern,https://root.cern/root/html528/RooMomentMorph.html,2,['cache'],['cache']
Performance,"bsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction1Ref<double,double>funcFunction pointer reference; RooRealProxyxArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCFunction1PdfBinding_double_double_.html:39857,cache,cache,39857,root/html530/RooCFunction1PdfBinding_double_double_.html,https://root.cern,https://root.cern/root/html530/RooCFunction1PdfBinding_double_double_.html,2,['cache'],['cache']
Performance,"bsReal.; Definition at line 77 of file RooLognormal.cxx. ◆ generateEvent(). void RooLognormal::generateEvent ; (; Int_t ; code). overridevirtual . Interface for generation of an event using the algorithm corresponding to the specified code. ; The meaning of each code is defined by the getGenerator() implementation. The default implementation does nothing. ; Reimplemented from RooAbsPdf.; Definition at line 135 of file RooLognormal.cxx. ◆ getAnalyticalIntegral(). Int_t RooLognormal::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 102 of file RooLognormal.cxx. ◆ getGenerator(). Int_t RooLognormal::getGenerator ; (; const RooArgSet & ; directVars, . RooArgSet & ; generateVars, . bool ; staticInitOK = true . ); const. overridevirtual . Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ; A code of zero indicates that we cannot generate any of the directVars (in this case, nothing should be added to generatedVars). Any non-zero codes will be passed to our generateEvent() implementation, but otherwise its value is arbitrary. The default implementation of this method returns zero. Subclasses will usually implement this method using the matchArgs() methods to advertise the algorithms they provide. ; Reimplemented from RooAbsPdf.; Definition at line 128 of file RooLognormal.cxx. ◆ getMedian(). RooAbsReal const & RooLognormal::getMedian ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLognormal.html:78406,perform,performed,78406,doc/master/classRooLognormal.html,https://root.cern,https://root.cern/doc/master/classRooLognormal.html,1,['perform'],['performed']
Performance,"bsReal.cxx. ◆ createRunningIntegral() [1/2]. RooFit::OwningPtr< RooAbsReal > RooAbsReal::createRunningIntegral ; (; const RooArgSet & ; iset, . const RooArgSet & ; nset = {} . ). Calls createRunningIntegral(const RooArgSet&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&) ; Definition at line 3706 of file RooAbsReal.cxx. ◆ createRunningIntegral() [2/2]. RooAbsReal::createRunningIntegral ; (; const RooArgSet & ; iset, . const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). Create an object that represents the running integral of the function over one or more observables listed in iset, i.e. . \[; \int_{x_\mathrm{lo}}^x f(x') \, \mathrm{d}x'; \]. The actual integration calculation is only performed when the return object is evaluated. The name of the integral object is automatically constructed from the name of the input function, the variables it integrates and the range integrates over. The default strategy to calculate the running integrals is. If the integrand (this object) supports analytical integration, construct an integral object that calculate the running integrals value by calculating the analytical integral each time the running integral object is evaluated; If the integrand (this object) requires numeric integration to construct the running integral create an object of class RooNumRunningInt which first samples the entire function and integrates the sampled function numerically. This method has superior performance as there is no need to perform a full (numeric) integration for each evaluation of the running integral object, but only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:93724,perform,performed,93724,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['perform'],['performed']
Performance,"bsReal.cxx. ◆ createRunningIntegral() [1/2]. RooFit::OwningPtr< RooAbsReal > RooAbsReal::createRunningIntegral ; (; const RooArgSet & ; iset, . const RooArgSet & ; nset = {} . ). Calls createRunningIntegral(const RooArgSet&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&) ; Definition at line 3782 of file RooAbsReal.cxx. ◆ createRunningIntegral() [2/2]. RooAbsReal::createRunningIntegral ; (; const RooArgSet & ; iset, . const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). Create an object that represents the running integral of the function over one or more observables listed in iset, i.e. . \[; \int_{x_\mathrm{lo}}^x f(x') \, \mathrm{d}x'; \]. The actual integration calculation is only performed when the return object is evaluated. The name of the integral object is automatically constructed from the name of the input function, the variables it integrates and the range integrates over. The default strategy to calculate the running integrals is. If the integrand (this object) supports analytical integration, construct an integral object that calculate the running integrals value by calculating the analytical integral each time the running integral object is evaluated; If the integrand (this object) requires numeric integration to construct the running integral create an object of class RooNumRunningInt which first samples the entire function and integrates the sampled function numerically. This method has superior performance as there is no need to perform a full (numeric) integration for each evaluation of the running integral object, but only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:94992,perform,performed,94992,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['perform'],['performed']
Performance,"bsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_flatSFInt; Bool_t_flip; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGExpModel.html:45729,cache,cache,45729,root/html602/RooGExpModel.html,https://root.cern,https://root.cern/root/html602/RooGExpModel.html,4,['cache'],['cache']
Performance,"bsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; const ROOT::Math::IBaseFunctionOneDim*funcFunctor; RooRealProxyvarArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFunctor1DBinding.html:32216,cache,cache,32216,root/html526/RooFunctor1DBinding.html,https://root.cern,https://root.cern/root/html526/RooFunctor1DBinding.html,2,['cache'],['cache']
Performance,"bsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdf. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooExtendedBinding(const char* name, const char* title, RooAbsPdf& _pdf). RooExtendedBinding(const RooExtendedBinding& other, const char* name = 0). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExtendedBinding.html:35945,cache,cache,35945,root/html602/RooExtendedBinding.html,https://root.cern,https://root.cern/root/html602/RooExtendedBinding.html,4,['cache'],['cache']
Performance,"bsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooObjCacheManager_normIntMgrThe integration cache manager; Int_t_numBins; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; RooListProxy_paramSetinterpolation parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ParamHistFunc(). ParamHistFunc(const char* name, const char* title, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ParamHistFunc.html:32899,cache,cache,32899,root/html532/ParamHistFunc.html,https://root.cern,https://root.cern/root/html532/ParamHistFunc.html,3,['cache'],['cache']
Performance,"bsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; const ROOT::Math::IBaseFunctionMultiDim*funcFunctor; RooListProxyvarsArgument reference; Double_t*xArgument value array. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooFunctorBinding(const char* name, const char* title, const ROOT::Math::IBaseFunctionMulti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFunctorBinding.html:34966,cache,cache,34966,root/html534/RooFunctorBinding.html,https://root.cern,https://root.cern/root/html534/RooFunctorBinding.html,2,['cache'],['cache']
Performance,"bsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,double,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction2Ref<VO,VI1,VI2> Streamer(TBuffer& ); Custom streamer for function pointer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2Binding_double_double_int_.html:36700,cache,cache,36700,root/html602/RooCFunction2Binding_double_double_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2Binding_double_double_int_.html,4,['cache'],['cache']
Performance,"bsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction2Ref<VO,VI1,VI2> Streamer(TBuffer& ); Custom streamer for function pointer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2Binding_double_int_double_.html:36700,cache,cache,36700,root/html602/RooCFunction2Binding_double_int_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2Binding_double_int_double_.html,4,['cache'],['cache']
Performance,"bsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidapplyNLLWeightSquared(Bool_t flag); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidcalculate() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealMPFE.html:2836,cache,cacheUniqueSuffix,2836,root/html602/RooRealMPFE.html,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html,2,['cache'],['cacheUniqueSuffix']
Performance,"bsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_toffset() const; virtual Double_toffsetCarry() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsTestStatistic&operator=(const RooAbsTestStatistic&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsTestStatistic.html:20409,optimiz,optimizeCacheMode,20409,root/html602/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsTestStatistic.html,2,['optimiz'],['optimizeCacheMode']
Performance,"bsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual RooAbsArg&RooAbsRealLValue::operator=(const RooAbsReal& other); virtual RooAbsArg&RooAbsRealLValue::operator=(Double_t newValue); virtual RooAbsArg&RooAbsRealLValue::operator=(Int_t ival); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooErrorVar.html:21391,optimiz,optimizeCacheMode,21391,root/html526/RooErrorVar.html,https://root.cern,https://root.cern/root/html526/RooErrorVar.html,6,['optimiz'],['optimizeCacheMode']
Performance,"bsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); const RooArgList&paramList() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/PiecewiseInterpolation.html:18344,optimiz,optimizeCacheMode,18344,root/html530/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html530/PiecewiseInterpolation.html,1,['optimiz'],['optimizeCacheMode']
Performance,"bsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); const RooArgList&paramList() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ParamHistFunc.html:18962,optimiz,optimizeCacheMode,18962,root/html532/ParamHistFunc.html,https://root.cern,https://root.cern/root/html532/ParamHistFunc.html,2,['optimiz'],['optimizeCacheMode']
Performance,"bservables of the function. If the fixed set of cache observables does not match the observables defined in the use context of the p.d.f the cache is still filled completely. Ee.g. when it is specified to cache x and p and only x is a observable in the given use context the cache histogram will store sampled values for all values of observable x and parameter p. In such a mode of operation the cache will also not be recalculated if the observable p changes ; Definition at line 66 of file RooCachedPdf.cxx. ◆ RooCachedPdf() [3/4]. RooCachedPdf::RooCachedPdf ; (; const char * ; name, . const char * ; title, . RooAbsPdf & ; _pdf . ). Constructor taking name, title and function to be cached. ; To control granularity of the binning of the cache histogram set the desired properties in the binning named ""cache"" in the observables of the function. The dimensions of the cache are automatically matched to the number of observables used in each use context. Multiple cache in different observable may exists simultaneously if the cached p.d.f is used with multiple observable configurations simultaneously ; Definition at line 44 of file RooCachedPdf.cxx. ◆ RooCachedPdf() [4/4]. RooCachedPdf::RooCachedPdf ; (; const RooCachedPdf & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 79 of file RooCachedPdf.cxx. Member Function Documentation. ◆ actualObservables(). RooFit::OwningPtr< RooArgSet > RooCachedPdf::actualObservables ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . If this pdf is operated with a fixed set of observables, return the subset of the fixed observables that are actual dependents of the external input p.d.f. ; If this p.d.f is operated without a fixed set of cache observables, return the actual observables of the external input p.d.f given the choice of observables defined in nset ; Implements RooAbsCachedPdf.; Definition at line 129 of file RooCachedPdf.cxx. ◆ actualParameters(). RooFit::OwningPtr< RooArgSet > Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:78537,cache,cache,78537,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,2,['cache'],"['cache', 'cached']"
Performance,"bservables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Bool_t_showProgressShow progress indication during evaluation if true; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Double_t_sumWeightGlobal sum of weights needed for normalization; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooDataWeightedAverage(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t showProgress = kFALSE, Bool_t verbose = kTRUE); Constructor of data weighted average of given p.d.f over given data. If nCPU>1 the calculation is parallelized; over multuple processes. If showProgress is true a progress indicator printing a single dot for e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataWeightedAverage.html:35174,cache,cache,35174,root/html526/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html526/RooDataWeightedAverage.html,2,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this obj,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsSelfCachedReal.html:32193,cache,cache,32193,root/html526/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsSelfCachedReal.html,8,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntCon,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsSelfCachedReal.html:32926,cache,cache,32926,root/html530/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html530/RooAbsSelfCachedReal.html,4,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIn,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsSelfCachedReal.html:33301,cache,cache,33301,root/html532/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html532/RooAbsSelfCachedReal.html,4,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::stri,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedReal.html:32044,cache,cache,32044,root/html526/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedReal.html,2,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_s,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCachedReal.html:32759,cache,cache,32759,root/html530/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html,1,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; TIterator*_listIter! do not persist; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::stri,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRecursiveFraction.html:30840,cache,cache,30840,root/html526/RooRecursiveFraction.html,https://root.cern,https://root.cern/root/html526/RooRecursiveFraction.html,2,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; TIterator*_listIter! do not persist; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_s,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRecursiveFraction.html:31507,cache,cache,31507,root/html530/RooRecursiveFraction.html,https://root.cern,https://root.cern/root/html530/RooRecursiveFraction.html,1,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; TIterator*_listIter! do not persist; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRecursiveFraction.html:31882,cache,cache,31882,root/html532/RooRecursiveFraction.html,https://root.cern,https://root.cern/root/html532/RooRecursiveFraction.html,1,['cache'],['cache']
Performance,"bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooMinuit*_minuit! Internal minuit instance; static Int_tRooPrintable::_nameLength; Int_t_nevalNumber evaluations used in last minimization; RooRealProxy_nllInput -log(L) function; RooSetProxy_obsParameters of profile likelihood; RooArgSet_obsAbsMinObservable values at absolute minimum; TIterator*_oiter! Iterator of profile likelihood output parameter(s); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_parMarginialized parameters of likelihood; RooArgSet_paramAbsMinParameter values at absolute minimum; map<std::string,bool>_paramFixedParameter constant status at last time of use; TIterator*_piter! Iterator over profile likelihood parameters to be minimized ; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooProfileLL.html:31999,cache,cache,31999,root/html530/RooProfileLL.html,https://root.cern,https://root.cern/root/html530/RooProfileLL.html,2,['cache'],['cache']
Performance,"bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooMinuit*_minuit! Internal minuit instance; static Int_tRooPrintable::_nameLength; RooRealProxy_nllInput -log(L) function; RooSetProxy_obsParameters of profile likelihood; RooArgSet_obsAbsMinObservable values at absolute minimum; TIterator*_oiter! Iterator of profile likelihood output parameter(s); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_parMarginialized parameters of likelihood; RooArgSet_paramAbsMinParameter values at absolute minimum; map<std::string,bool>_paramFixedParameter constant status at last time of use; TIterator*_piter! Iterator over profile likelihood parameters to be minimized ; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProfileLL.html:31294,cache,cache,31294,root/html526/RooProfileLL.html,https://root.cern,https://root.cern/root/html526/RooProfileLL.html,2,['cache'],['cache']
Performance,"bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooRealProxy_meas; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooPullVar.html:30873,cache,cache,30873,root/html526/RooPullVar.html,https://root.cern,https://root.cern/root/html526/RooPullVar.html,2,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooRealProxy_meas; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooPullVar.html:31540,cache,cache,31540,root/html530/RooPullVar.html,https://root.cern,https://root.cern/root/html530/RooPullVar.html,1,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooRealProxy_meas; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooPullVar.html:31915,cache,cache,31915,root/html532/RooPullVar.html,https://root.cern,https://root.cern/root/html532/RooPullVar.html,1,['cache'],['cache']
Performance,"bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsRealLValue.html:34557,cache,cache,34557,root/html526/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html526/RooAbsRealLValue.html,48,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_set1Set of input fractions; TIterator*_setIter1! Iterator over set of input fractions; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configura,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFracRemainder.html:30804,cache,cache,30804,root/html526/RooFracRemainder.html,https://root.cern,https://root.cern/root/html526/RooFracRemainder.html,2,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration spec,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsRealLValue.html:35224,cache,cache,35224,root/html530/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html530/RooAbsRealLValue.html,24,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_set1Set of input fractions; TIterator*_setIter1! Iterator over set of input fractions; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input sha,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooFracRemainder.html:31471,cache,cache,31471,root/html530/RooFracRemainder.html,https://root.cern,https://root.cern/root/html530/RooFracRemainder.html,1,['cache'],['cache']
Performance,"bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; RooRealProxy_realVarRealVar with the original error; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooErrorVar.html:35551,cache,cache,35551,root/html526/RooErrorVar.html,https://root.cern,https://root.cern/root/html526/RooErrorVar.html,2,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; RooRealProxy_realVarRealVar with the original error; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_spec,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooErrorVar.html:36218,cache,cache,36218,root/html530/RooErrorVar.html,https://root.cern,https://root.cern/root/html530/RooErrorVar.html,1,['cache'],['cache']
Performance,"bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; TString_rangeName; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRangeBoolean.html:30837,cache,cache,30837,root/html528/RooRangeBoolean.html,https://root.cern,https://root.cern/root/html528/RooRangeBoolean.html,1,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; TString_rangeName; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRangeBoolean.html:31263,cache,cache,31263,root/html530/RooRangeBoolean.html,https://root.cern,https://root.cern/root/html530/RooRangeBoolean.html,1,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; vector<Double_t>_realRefReference values for reals; RooListProxy_realSetList of reals to track ; TIterator*_realSetIter! do not persist; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegra,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChangeTracker.html:31416,cache,cache,31416,root/html526/RooChangeTracker.html,https://root.cern,https://root.cern/root/html526/RooChangeTracker.html,2,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; vector<Double_t>_realRefReference values for reals; RooListProxy_realSetList of reals to track ; TIterator*_realSetIter! do not persist; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooChangeTracker.html:32083,cache,cache,32083,root/html530/RooChangeTracker.html,https://root.cern,https://root.cern/root/html530/RooChangeTracker.html,1,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsRealLValue.html:35599,cache,cache,35599,root/html532/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html532/RooAbsRealLValue.html,23,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_set1Set of input fractions; TIterator*_setIter1! Iterator over set of input fractions; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFracRemainder.html:31846,cache,cache,31846,root/html532/RooFracRemainder.html,https://root.cern,https://root.cern/root/html532/RooFracRemainder.html,1,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; TString_rangeName; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRangeBoolean.html:31638,cache,cache,31638,root/html532/RooRangeBoolean.html,https://root.cern,https://root.cern/root/html532/RooRangeBoolean.html,1,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; vector<Double_t>_realRefReference values for reals; RooListProxy_realSetList of reals to track ; TIterator*_realSetIter! do not persist; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if va,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooChangeTracker.html:32458,cache,cache,32458,root/html532/RooChangeTracker.html,https://root.cern,https://root.cern/root/html532/RooChangeTracker.html,1,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_set1First set of terms to be summed; RooListProxy_set2Second set of terms to be summed; TIterator*_setIter1! Iterator over set1; TIterator*_setIter2! Iterator over set2; Bool_tRooAbsArg::_shapeDirtyFlag set if value,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddition.html:31009,cache,cache,31009,root/html526/RooAddition.html,https://root.cern,https://root.cern/root/html526/RooAddition.html,1,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_setset of terms to be summed; TIterator*_setIter! Iterator over set; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfig,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddition.html:31498,cache,cache,31498,root/html528/RooAddition.html,https://root.cern,https://root.cern/root/html528/RooAddition.html,1,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_setset of terms to be summed; TIterator*_setIter! Iterator over set; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs rec,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAddition.html:31687,cache,cache,31687,root/html530/RooAddition.html,https://root.cern,https://root.cern/root/html530/RooAddition.html,1,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramSetSet of parameters to which constraints apply; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_set1Set of constraint terms; TIterator*_setIter1! do not persist; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_spe,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooConstraintSum.html:30880,cache,cache,30880,root/html526/RooConstraintSum.html,https://root.cern,https://root.cern/root/html526/RooConstraintSum.html,2,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramSetSet of parameters to which constraints apply; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_set1Set of constraint terms; TIterator*_setIter1! do not persist; Bool_tRooAbsArg::_shapeDirtyFlag set i,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooConstraintSum.html:31547,cache,cache,31547,root/html530/RooConstraintSum.html,https://root.cern,https://root.cern/root/html530/RooConstraintSum.html,1,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramSetSet of parameters to which constraints apply; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_set1Set of constraint terms; TIterator*_setIter1! do not persist; Bool_tRooAbsArg::_shapeDirtyFlag s,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooConstraintSum.html:31922,cache,cache,31922,root/html532/RooConstraintSum.html,https://root.cern,https://root.cern/root/html532/RooConstraintSum.html,1,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooRealProxy_offsetOffset of transformation; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooRealProxy_slopeSlope of transformation; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specifi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooLinearVar.html:35685,cache,cache,35685,root/html526/RooLinearVar.html,https://root.cern,https://root.cern/root/html526/RooLinearVar.html,2,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooRealProxy_offsetOffset of transformation; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooRealProxy_slopeSlope of transformation,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooLinearVar.html:36352,cache,cache,36352,root/html530/RooLinearVar.html,https://root.cern,https://root.cern/root/html530/RooLinearVar.html,1,['cache'],['cache']
Performance,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooRealProxy_offsetOffset of transformation; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooRealProxy_slopeSlope of transforma,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooLinearVar.html:36743,cache,cache,36743,root/html532/RooLinearVar.html,https://root.cern,https://root.cern/root/html532/RooLinearVar.html,1,['cache'],['cache']
Performance,bset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_epsPrecision; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooFunctor*_ftor! Functor binding of RooAbsReal; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderDerivation order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; ROOT::Math::RichardsonDerivator*_rd! Derivator ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNume,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDerivative.html:31060,cache,cache,31060,root/html526/RooDerivative.html,https://root.cern,https://root.cern/root/html526/RooDerivative.html,2,['cache'],['cache']
Performance,bset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_epsPrecision; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooFunctor*_ftor! Functor binding of RooAbsReal; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderDerivation order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; ROOT::Math::RichardsonDerivator*_rd! Derivator ; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalcu,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDerivative.html:31727,cache,cache,31727,root/html530/RooDerivative.html,https://root.cern,https://root.cern/root/html530/RooDerivative.html,1,['cache'],['cache']
Performance,bset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_epsPrecision; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooFunctor*_ftor! Functor binding of RooAbsReal; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooSetProxy_nsetNormalization set (optional); RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Int_t_orderDerivation order; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; ROOT::Math::RichardsonDerivator*_rd! Derivator ; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs rec,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDerivative.html:32102,cache,cache,32102,root/html532/RooDerivative.html,https://root.cern,https://root.cern/root/html532/RooDerivative.html,1,['cache'],['cache']
Performance,"btr)=0; TVirtualGeoPainter::CheckShapevirtual void CheckShape(TGeoShape *shape, Int_t testNo, Int_t nsamples, Option_t *option)=0; TVirtualGeoPainter::ExecuteManagerEventvirtual void ExecuteManagerEvent(TGeoManager *geom, Int_t event, Int_t px, Int_t py)=0; TVirtualGeoPainter::SetBombFactorsvirtual void SetBombFactors(Double_t bombx=1.3, Double_t bomby=1.3, Double_t bombz=1.3, Double_t bombr=1.3)=0; TVirtualGeoPainter::CheckBoundaryErrorsvirtual void CheckBoundaryErrors(Int_t ntracks=1000000, Double_t radius=-1.)=0; TVirtualGeoTrackBase class for user-defined tracks attached to a geometry.Definition TVirtualGeoTrack.h:23; TVirtualGeoTrack::GetIdInt_t GetId() constDefinition TVirtualGeoTrack.h:43; TVirtualGeoTrack::GetMotherTVirtualGeoTrack * GetMother() constDefinition TVirtualGeoTrack.h:46; TVirtualGeoTrack::FindTrackWithIdvirtual TVirtualGeoTrack * FindTrackWithId(Int_t id) constRecursively search through this track for a daughter particle (at any depth) with the specified id.Definition TVirtualGeoTrack.cxx:83; bool; double; int; unsigned int; boxvoid box(Int_t pat, Double_t x1, Double_t y1, Double_t x2, Double_t y2)Definition fillpatterns.C:1; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; h1TH1F * h1Definition legend1.C:5; ROOT::EnableThreadSafetyvoid EnableThreadSafety()Enable support for multi-threading within the ROOT code in particular, enables the global mutex to ma...Definition TROOT.cxx:501; TMath::ATan2Double_t ATan2(Double_t y, Double_t x)Returns the principal value of the arc tangent of y/x, expressed in radians.Definition TMath.h:646; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; TMath::RadToDegconstexpr Double_t RadToDeg()Conversion from radian to degree: .Definition TMath.h:72. geomgeomsrcTGeoManager.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:249419,multi-thread,multi-threading,249419,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['multi-thread'],['multi-threading']
Performance,"buf, Int_t len); Interface to system write. All arguments like in POSIX write(). Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence); Interface to system lseek. All arguments like in POSIX lseek(); except that the offset and return value are of a type which are; able to handle 64 bit file systems. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Return file stat information. The interface and return value is; identical to TSystem::GetPathInfo(). The function returns 0 in; case of success and 1 if the file could not be stat'ed. Int_t SysSync(Int_t fd); Interface to system fsync. All arguments like in POSIX fsync(). Long64_t GetBytesWritten() const; Return the total number of bytes written so far to the file. Long64_t GetFileBytesRead(); Static function returning the total number of bytes read from all files. Long64_t GetFileBytesWritten(); Static function returning the total number of bytes written to all files.; Does not take into account what might still be in the write caches. Int_t GetFileReadCalls(); Static function returning the total number of read calls from all files. Int_t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:48987,cache,caches,48987,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,6,['cache'],['caches']
Performance,"buffer and return class object.; 5714 ; 5715TClass *TClass::Load(TBuffer &b); 5716{; 5717 UInt_t maxsize = 256;; 5718 char *s = new char[maxsize];; 5719 ; 5720 Int_t pos = b.Length();; 5721 ; 5722 b.ReadString(s, maxsize); // Reads at most maxsize - 1 characters, plus null at end.; 5723 while (strlen(s) == (maxsize - 1)) {; 5724 // The classname is too large, try again with a large buffer.; 5725 b.SetBufferOffset(pos);; 5726 maxsize = 2*maxsize;; 5727 delete [] s;; 5728 s = new char[maxsize];; 5729 b.ReadString(s, maxsize); // Reads at most maxsize - 1 characters, plus null at end.; 5730 }; 5731 ; 5732 TClass *cl = TClass::GetClass(s, kTRUE);; 5733 if (!cl); 5734 ::Error(""TClass::Load"", ""dictionary of class %s not found"", s);; 5735 ; 5736 delete [] s;; 5737 return cl;; 5738}; 5739 ; 5740////////////////////////////////////////////////////////////////////////////////; 5741/// Helper function used by TClass::GetClass().; 5742/// This function attempts to load the dictionary for 'classname'; 5743/// either from the TClassTable or from the list of generator.; 5744/// If silent is 'true', do not warn about missing dictionary for the class.; 5745/// (typically used for class that are used only for transient members); 5746///; 5747/// The 'requestedname' is expected to be already normalized.; 5748 ; 5749TClass *TClass::LoadClass(const char *requestedname, Bool_t silent); 5750{; 5751 // This function does not (and should not) attempt to check in the; 5752 // list of loaded classes or in the typedef.; 5753 ; 5754 R__LOCKGUARD(gInterpreterMutex);; 5755 ; 5756 TClass *result = LoadClassDefault(requestedname, silent);; 5757 ; 5758 if (result) return result;; 5759 else return LoadClassCustom(requestedname,silent);; 5760}; 5761 ; 5762////////////////////////////////////////////////////////////////////////////////; 5763/// Helper function used by TClass::GetClass().; 5764/// This function attempts to load the dictionary for 'classname' from; 5765/// the TClassTable or the autoloade",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:219883,load,load,219883,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"buffer and return class object.; 5781 ; 5782TClass *TClass::Load(TBuffer &b); 5783{; 5784 UInt_t maxsize = 256;; 5785 char *s = new char[maxsize];; 5786 ; 5787 Int_t pos = b.Length();; 5788 ; 5789 b.ReadString(s, maxsize); // Reads at most maxsize - 1 characters, plus null at end.; 5790 while (strlen(s) == (maxsize - 1)) {; 5791 // The classname is too large, try again with a large buffer.; 5792 b.SetBufferOffset(pos);; 5793 maxsize = 2*maxsize;; 5794 delete [] s;; 5795 s = new char[maxsize];; 5796 b.ReadString(s, maxsize); // Reads at most maxsize - 1 characters, plus null at end.; 5797 }; 5798 ; 5799 TClass *cl = TClass::GetClass(s, kTRUE);; 5800 if (!cl); 5801 ::Error(""TClass::Load"", ""dictionary of class %s not found"", s);; 5802 ; 5803 delete [] s;; 5804 return cl;; 5805}; 5806 ; 5807////////////////////////////////////////////////////////////////////////////////; 5808/// Helper function used by TClass::GetClass().; 5809/// This function attempts to load the dictionary for 'classname'; 5810/// either from the TClassTable or from the list of generator.; 5811/// If silent is 'true', do not warn about missing dictionary for the class.; 5812/// (typically used for class that are used only for transient members); 5813///; 5814/// The 'requestedname' is expected to be already normalized.; 5815 ; 5816TClass *TClass::LoadClass(const char *requestedname, Bool_t silent); 5817{; 5818 // This function does not (and should not) attempt to check in the; 5819 // list of loaded classes or in the typedef.; 5820 ; 5821 R__LOCKGUARD(gInterpreterMutex);; 5822 ; 5823 TClass *result = LoadClassDefault(requestedname, silent);; 5824 ; 5825 if (result) return result;; 5826 else return LoadClassCustom(requestedname,silent);; 5827}; 5828 ; 5829////////////////////////////////////////////////////////////////////////////////; 5830/// Helper function used by TClass::GetClass().; 5831/// This function attempts to load the dictionary for 'classname' from; 5832/// the TClassTable or the autoloade",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:222634,load,load,222634,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"buffer. ;  ; DeserializeType GetDeserializeType () const override;  ; Int_t GetMaximum () const override;  ; Int_t GetMinimum () const override;  ; const char * GetTypeName () const override;  Returns name of leaf type. ;  ; Double_t GetValue (Int_t i=0) const override;  Returns current value of leaf. ;  ; void * GetValuePointer () const override;  ; void Import (TClonesArray *list, Int_t n) override;  Import element from ClonesArray into local leaf buffer. ;  ; bool IncludeRange (TLeaf *) override;  Copy/set fMinimum and fMaximum to include/be wide than those of the parameter. ;  ; TClass * IsA () const override;  ; void PrintValue (Int_t i=0) const override;  Prints leaf value. ;  ; void ReadBasket (TBuffer &b) override;  Read leaf elements from Basket input buffer. ;  ; void ReadBasketExport (TBuffer &b, TClonesArray *list, Int_t n) override;  Read leaf elements from Basket input buffer and export buffer to TClonesArray objects. ;  ; bool ReadBasketFast (TBuffer &, Long64_t) override;  Deserialize input by performing byteswap as needed. ;  ; void ReadValue (std::istream &s, Char_t delim=' ') override;  Read a integer integer from std::istream s and store it into the branch buffer. ;  ; void SetAddress (void *add=nullptr) override;  Set leaf buffer data address. ;  ; virtual void SetMaximum (Short_t max);  ; virtual void SetMinimum (Short_t min);  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TLeaf;  TLeaf ();  ;  TLeaf (TBranch *parent, const char *name, const char *type);  Create a Leaf. ;  ;  ~TLeaf () override;  Destructor. ;  ; void Browse (TBrowser *b) override;  Browse the content of this leaf. ;  ; virtual bool CanGenerateOffsetArray ();  ; virtual Int_t * GenerateOffsetArray (Int_t base, Int_t events);  ; TBranch * GetBranch () const;  ; virtual TString GetFullName () const;  Return the full name (including the parent's branch name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLeafS.html:1795,perform,performing,1795,doc/master/classTLeafS.html,https://root.cern,https://root.cern/doc/master/classTLeafS.html,1,['perform'],['performing']
Performance,"buffer. ;  ; DeserializeType GetDeserializeType () const override;  ; Int_t GetMaximum () const override;  ; Int_t GetMinimum () const override;  ; const char * GetTypeName () const override;  Returns name of leaf type. ;  ; Double_t GetValue (Int_t i=0) const override;  Returns current value of leaf. ;  ; void * GetValuePointer () const override;  ; void Import (TClonesArray *list, Int_t n) override;  Import element from ClonesArray into local leaf buffer. ;  ; bool IncludeRange (TLeaf *) override;  Copy/set fMinimum and fMaximum to include/be wide than those of the parameter. ;  ; TClass * IsA () const override;  ; void PrintValue (Int_t i=0) const override;  Prints leaf value. ;  ; void ReadBasket (TBuffer &b) override;  Read leaf elements from Basket input buffer. ;  ; void ReadBasketExport (TBuffer &b, TClonesArray *list, Int_t n) override;  Read leaf elements from Basket input buffer and export buffer to TClonesArray objects. ;  ; bool ReadBasketFast (TBuffer &, Long64_t) override;  Deserialize input by performing byteswap as needed. ;  ; void ReadValue (std::istream &s, Char_t delim=' ') override;  Read an integer from std::istream s and store it into the branch buffer. ;  ; void SetAddress (void *add=nullptr) override;  Set leaf buffer data address. ;  ; virtual void SetMaximum (Int_t max);  ; virtual void SetMinimum (Int_t min);  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TLeaf;  TLeaf ();  ;  TLeaf (TBranch *parent, const char *name, const char *type);  Create a Leaf. ;  ;  ~TLeaf () override;  Destructor. ;  ; void Browse (TBrowser *b) override;  Browse the content of this leaf. ;  ; virtual bool CanGenerateOffsetArray ();  ; virtual Int_t * GenerateOffsetArray (Int_t base, Int_t events);  ; TBranch * GetBranch () const;  ; virtual TString GetFullName () const;  Return the full name (including the parent's branch names) of the l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLeafI.html:1789,perform,performing,1789,doc/master/classTLeafI.html,https://root.cern,https://root.cern/doc/master/classTLeafI.html,1,['perform'],['performing']
Performance,"but if we do, let's just; 3046 // continue as before ...; 3047 }; 3048 ; 3049 std::string normalizedName;; 3050 Bool_t checkTable = kFALSE;; 3051 ; 3052 if (!cl) {; 3053 {; 3054 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3055 TClassEdit::GetNormalizedName(normalizedName, name);; 3056 }; 3057 // Try the normalized name.; 3058 if (normalizedName != name) {; 3059 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(normalizedName.c_str());; 3060 ; 3061 if (cl) {; 3062 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3063 ; 3064 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3065 load = kTRUE;; 3066 }; 3067 checkTable = kTRUE;; 3068 }; 3069 } else {; 3070 normalizedName = cl->GetName(); // Use the fact that all TClass names are normalized.; 3071 checkTable = load && (normalizedName != name);; 3072 }; 3073 ; 3074 if (!load) return nullptr;; 3075 ; 3076// This assertion currently fails because of; 3077// TClass *c1 = TClass::GetClass(""basic_iostream<char,char_traits<char> >"");; 3078// TClass *c2 = TClass::GetClass(""std::iostream"");; 3079// where the TClassEdit normalized name of iostream is basic_iostream<char>; 3080// i.e missing the addition of the default parameter. This is because TClingLookupHelper; 3081// uses only 'part' of TMetaUtils::GetNormalizedName.; 3082 ; 3083// if (!cl) {; 3084// TDataType* dataType = (TDataType*)gROOT->GetListOfTypes()->FindObject(name);; 3085// TClass *altcl = dataType ? (TClass*)gROOT->GetListOfClasses()->FindObject(dataType->GetFullTypeName()) : 0;; 3086// if (altcl && normalizedName != altcl->GetName()); 3087// ::Fatal(""TClass::GetClass"",""The existing name (%s) for %s is different from the normalized name: %s\n"",; 3088// altcl->GetName(), name, normalizedName.c_str());; 3089// }; 3090 ; 3091 // We want to avoid auto-parsing due to intentionally missing dictionary for std::pair.; 3092 // However, we don't need this special treatement in rootcling (there is no auto-parsing); 30",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:115581,load,load,115581,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,['load'],['load']
Performance,"but if we do, let's just; 3113 // continue as before ...; 3114 }; 3115 ; 3116 std::string normalizedName;; 3117 Bool_t checkTable = kFALSE;; 3118 ; 3119 if (!cl) {; 3120 {; 3121 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3122 TClassEdit::GetNormalizedName(normalizedName, name);; 3123 }; 3124 // Try the normalized name.; 3125 if (normalizedName != name) {; 3126 cl = (TClass*)gROOT->GetListOfClasses()->FindObject(normalizedName.c_str());; 3127 ; 3128 if (cl) {; 3129 if (cl->IsLoaded() || cl->TestBit(kUnloading)) return cl;; 3130 ; 3131 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3132 load = kTRUE;; 3133 }; 3134 checkTable = kTRUE;; 3135 }; 3136 } else {; 3137 normalizedName = cl->GetName(); // Use the fact that all TClass names are normalized.; 3138 checkTable = load && (normalizedName != name);; 3139 }; 3140 ; 3141 if (!load) return nullptr;; 3142 ; 3143// This assertion currently fails because of; 3144// TClass *c1 = TClass::GetClass(""basic_iostream<char,char_traits<char> >"");; 3145// TClass *c2 = TClass::GetClass(""std::iostream"");; 3146// where the TClassEdit normalized name of iostream is basic_iostream<char>; 3147// i.e missing the addition of the default parameter. This is because TClingLookupHelper; 3148// uses only 'part' of TMetaUtils::GetNormalizedName.; 3149 ; 3150// if (!cl) {; 3151// TDataType* dataType = (TDataType*)gROOT->GetListOfTypes()->FindObject(name);; 3152// TClass *altcl = dataType ? (TClass*)gROOT->GetListOfClasses()->FindObject(dataType->GetFullTypeName()) : 0;; 3153// if (altcl && normalizedName != altcl->GetName()); 3154// ::Fatal(""TClass::GetClass"",""The existing name (%s) for %s is different from the normalized name: %s\n"",; 3155// altcl->GetName(), name, normalizedName.c_str());; 3156// }; 3157 ; 3158 // We want to avoid auto-parsing due to intentionally missing dictionary for std::pair.; 3159 // However, we don't need this special treatement in rootcling (there is no auto-parsing); 31",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:118332,load,load,118332,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['load'],['load']
Performance,"but possibly a new shape,...Definition TGeoVolume.cxx:2269; TGeoVolume::InvisibleAllvoid InvisibleAll(Bool_t flag=kTRUE)Make volume and each of it daughters (in)visible.Definition TGeoVolume.cxx:795; TGeoVolume::IsVisibleDaughtersBool_t IsVisibleDaughters() constDefinition TGeoVolume.h:156; TGeoVolume::fOptionTString fOptionjust a hook for nowDefinition TGeoVolume.h:54; TGeoVolume::GetIndexInt_t GetIndex(const TGeoNode *node) constget index number for a given daughterDefinition TGeoVolume.cxx:1743; TGeoVolume::SetNodesvoid SetNodes(TObjArray *nodes)Definition TGeoVolume.h:223; TGeoVolume::GetFinderTGeoPatternFinder * GetFinder() constDefinition TGeoVolume.h:177; TGeoVolume::PrintVoxelsvoid PrintVoxels() constPrint the voxels for this volume.Definition TGeoVolume.cxx:1282; TGeoVolume::fUserExtensionTGeoExtension * fUserExtensionDefinition TGeoVolume.h:59; TGeoVolume::SetMediumvirtual void SetMedium(TGeoMedium *medium)Definition TGeoVolume.h:242; TGeoVolume::GetVoxelsTGeoVoxelFinder * GetVoxels() constGetter for optimization structure.Definition TGeoVolume.cxx:1802; TGeoVolume::SetAttVisibilityvoid SetAttVisibility(Bool_t vis)Definition TGeoVolume.h:233; TGeoVolume::~TGeoVolume~TGeoVolume() overrideDestructor.Definition TGeoVolume.cxx:510; TGeoVolume::SetShapevoid SetShape(const TGeoShape *shape)set the shape associated with this volumeDefinition TGeoVolume.cxx:2067; TGeoVolume::DummyMediumstatic TGeoMedium * DummyMedium()Definition TGeoVolume.cxx:445; TGeoVolume::fFieldTObject * fFieldpointer to TGeoManager owning this volumeDefinition TGeoVolume.h:53; TGeoVolume::GetNumberInt_t GetNumber() constDefinition TGeoVolume.h:184; TGeoVolume::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".Definition TGeoVolume.cxx:1535; TGeoVolume::CleanAllvoid CleanAll()Clean data of the volume.Definition TGeoVolume.cxx:659; TGeoVolume::SetActiveDaughtersvoid SetActiveDaughters(Bool_t flag=kTRUE)D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8h_source.html:42173,optimiz,optimization,42173,doc/master/TGeoVolume_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8h_source.html,1,['optimiz'],['optimization']
Performance,"but possibly a new shape,...Definition TGeoVolume.cxx:2269; TGeoVolume::InvisibleAllvoid InvisibleAll(Bool_t flag=kTRUE)Make volume and each of it daughters (in)visible.Definition TGeoVolume.cxx:795; TGeoVolume::IsVisibleDaughtersBool_t IsVisibleDaughters() constDefinition TGeoVolume.h:156; TGeoVolume::fOptionTString fOptionjust a hook for nowDefinition TGeoVolume.h:54; TGeoVolume::GetIndexInt_t GetIndex(const TGeoNode *node) constget index number for a given daughterDefinition TGeoVolume.cxx:1743; TGeoVolume::SetNodesvoid SetNodes(TObjArray *nodes)Definition TGeoVolume.h:223; TGeoVolume::GetFinderTGeoPatternFinder * GetFinder() constDefinition TGeoVolume.h:177; TGeoVolume::PrintVoxelsvoid PrintVoxels() constPrint the voxels for this volume.Definition TGeoVolume.cxx:1282; TGeoVolume::fUserExtensionTGeoExtension * fUserExtensionDefinition TGeoVolume.h:59; TGeoVolume::SetMediumvirtual void SetMedium(TGeoMedium *medium)Definition TGeoVolume.h:242; TGeoVolume::GetVoxelsTGeoVoxelFinder * GetVoxels() constGetter for optimization structure.Definition TGeoVolume.cxx:1802; TGeoVolume::SetAttVisibilityvoid SetAttVisibility(Bool_t vis)Definition TGeoVolume.h:233; TGeoVolume::~TGeoVolume~TGeoVolume() overrideDestructor.Definition TGeoVolume.cxx:510; TGeoVolume::SetShapevoid SetShape(const TGeoShape *shape)set the shape associated with this volumeDefinition TGeoVolume.cxx:2067; TGeoVolume::DummyMediumstatic TGeoMedium * DummyMedium()Definition TGeoVolume.cxx:445; TGeoVolume::fFieldTObject * fFieldpointer to TGeoManager owning this volumeDefinition TGeoVolume.h:53; TGeoVolume::SetLineColorvoid SetLineColor(Color_t lcolor) overrideSet the line color.Definition TGeoVolume.cxx:2169; TGeoVolume::GetNumberInt_t GetNumber() constDefinition TGeoVolume.h:184; TGeoVolume::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave a primitive as a C++ statement(s) on output stream ""out"".Definition TGeoVolume.cxx:1535; TGeoVolume::CleanAllvoid CleanAll()Clean data o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:149566,optimiz,optimization,149566,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['optimiz'],['optimization']
Performance,"bute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooRealVar&var() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNumConvPdf.html:31917,cache,cache,31917,root/html528/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html528/RooNumConvPdf.html,2,['cache'],['cache']
Performance,"butes() constRooAbsArginline; StyleOption enum nameRooPrintable; substituteServer(RooAbsArg *oldServer, RooAbsArg *newServer)RooAbsArgprivate; syncCache(const RooArgSet *set=nullptr) overrideRooAbsRealinlineprotectedvirtual; syncNormalization(const RooArgSet *dset, bool adjustProxies=true) constRooAbsPdfprotectedvirtual; SysError(const char *method, const char *msgfmt,...) constTObjectvirtual; TestBit(UInt_t f) constTObjectinline; TestBits(UInt_t f) constTObjectinline; TNamed()TNamedinline; TNamed(const char *name, const char *title)TNamedinline; TNamed(const TString &name, const TString &title)TNamedinline; TNamed(const TNamed &named)TNamed; TObject()TObjectinline; TObject(const TObject &object)TObjectinline; traceEval(const RooArgSet *set) constRooAbsRealprotected; traceEvalPdf(double value) constRooAbsPdfprivate; transientAttributes() constRooAbsArginline; translate(RooFit::Detail::CodeSquashContext &ctx) constRooAbsArgvirtual; treeNodeServerList(RooAbsCollection *list, const RooAbsArg *arg=nullptr, bool doBranch=true, bool doLeaf=true, bool valueOnly=false, bool recurseNonDerived=false) constRooAbsArg; unRegisterCache(RooAbsCache &cache)RooAbsArg; unRegisterProxy(RooArgProxy &proxy)RooAbsArgprotected; unRegisterProxy(RooSetProxy &proxy)RooAbsArgprotected; unRegisterProxy(RooListProxy &proxy)RooAbsArgprotected; UseCurrentStyle()TObjectvirtual; value_type typedefRooAbsReal; ValueChange enum valueRooAbsArg; valueClients() constRooAbsArginline; verboseDirty(bool flag)RooAbsArgstatic; verboseEval(Int_t stat)RooAbsPdfstatic; verboseEval()RooAbsPdfstatic; Warning(const char *method, const char *msgfmt,...) constTObjectvirtual; wireAllCaches()RooAbsArg; workspace() constRooAbsArginline; Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)TObjectvirtual; Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0) constTObjectvirtual; writeToStream(std::ostream &os, bool compact) const overrideRooAbsRealvirtual; ~RooAbsArg() overrideRooAbsArg; ~RooAbsPdf()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf-members.html:39205,cache,cache,39205,doc/master/classRooAbsPdf-members.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf-members.html,1,['cache'],['cache']
Performance,"butes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Int_t_coefIdxIndex code of the coefficient; RooRealProxy_convPdfRooAbsAnaConv object implementing our coefficient; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooConvCoefVar.html:30296,cache,cache,30296,root/html526/RooConvCoefVar.html,https://root.cern,https://root.cern/root/html526/RooConvCoefVar.html,3,['cache'],['cache']
Performance,"by default; when in learning phase rather than reading each requested branch individually, the TTreeCache will read all the branches thus trading off the latencies inherent to multiple small reads for the potential of requesting more data than needed by read from the disk or server the baskets for too many branches.; The default behavior can be changed by either updating one of the rootrc files or by setting environment variables. The rootrc files, both the global and the local ones, now support the following the resource variable TTreeCache.Size which set the default size factor for auto sizing TTreeCache for TTrees. The estimated cluster size for the TTree and this factor is used to give the cache size. If option is set to zero auto cache creation is disabled and the default cache size is the historical one (equivalent to factor 1.0). If set to non zero auto cache creation is enabled and both auto created and default sized caches will use the configured factor: 0.0 no automatic cache and greater than 0.0 to enable cache. This value can be overridden by the environment variable ROOT_TTREECACHE_SIZE.; The resource variable TTreeCache.Prefill sets the default TTreeCache prefilling type. The prefill type may be: 0 for no prefilling and 1 to prefill all the branches. It can be overridden by the environment variable ROOT_TTREECACHE_PREFILL; In particular the default can be set back to the same as in version 5 by setting TTreeCache.Size (or ROOT_TTREECACHE_SIZE) and TTreeCache.Prefill (or ROOT_TTREECACHE_PREFILL) both to zero.; TTree methods which are expected to modify a cache, like AddBranchToCache, will attempt to setup a cache of default size if one does not exist, irrespective of whether the auto cache creation is enabled. Additionally several methods giving control of the cache have changed return type from void to Int_t, to be able to return a code to indicate if there was an error.; Usually TTree::SetCacheSize will no longer reset the list of branches to be cache",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:12977,cache,cache,12977,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['cache'],['cache']
Performance,"by multiple threads concurrently: it needs not be thread-safe. For example the snippet; 309 /// above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; 310 /// - will always be executed ""everyNEvents"": partial results will ""contain"" that number of events more from; 311 /// one call to the next; 312 /// - might be executed by a different worker thread at different times: the value of `std::this_thread::get_id()`; 313 /// might change between calls; 314 ///; 315 /// To register a callback that is called by _each_ worker thread (concurrently) every N events one can use; 316 /// OnPartialResultSlot().; 317 // clang-format on; 318 RResultPtr<T> &OnPartialResult(ULong64_t everyNEvents, std::function<void(T &)> callback); 319 {; 320 ThrowIfNull();; 321 const auto nSlots = fLoopManager->GetNSlots();; 322 auto actionPtr = fActionPtr;; 323 auto c = [nSlots, actionPtr, callback](unsigned int slot) {; 324 if (slot != nSlots - 1); 325 return;; 326 auto partialResult = static_cast<Value_t *>(actionPtr->PartialUpdate(slot));; 327 callback(*partialResult);; 328 };; 329 fLoopManager->RegisterCallback(everyNEvents, std::move(c));; 330 return *this;; 331 }; 332 ; 333 // clang-format off; 334 /// Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's partial result.; 335 ///; 336 /// \param[in] everyNEvents Frequency at which the callback will be called by each thread, as a number of events processed; 337 /// \param[in] callback A callable with signature `void(unsigned int, Value_t&)` where Value_t is the type of the value contained in this RResultPtr; 338 /// \return this RResultPtr, to allow chaining of OnPartialResultSlot with other calls; 339 ///; 340 /// See `OnPartialResult` for a generic explanation of the callback mechanism.; 341 /// Compared to `OnPartialResult`, this method has two major differences:; 342 /// - all worker threads invoke the callback once every specified number of events. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RResultPtr_8hxx_source.html:14470,concurren,concurrently,14470,doc/master/RResultPtr_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html,1,['concurren'],['concurrently']
Performance,"by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. void unRegisterProxy(RooSetProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. void registerProxy(RooListProxy& proxy); Register an RooListProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. void unRegisterProxy(RooListProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. RooAbsProxy* getProxy(Int_t index) const; Return the nth proxy from the proxy list. Int_t numProxies() const; Return the number of registered proxies. void setProxyNormSet(const RooArgSet* nset); Forward a change in the cached normalization argset; to all the registered proxies. void attachToTree(TTree& t, Int_t bufSize = 32000); Overloadable function for derived classes to implement; attachment as branch to a TTree. Bool_t isValid() const; WVE (08/21/01) Probably obsolete now. void copyList(TList& dest, const TList& source); WVE (08/21/01) Probably obsolete now. void printName(ostream& os) const; Print object name. void printTitle(ostream& os) const; Print object title. void printClassName(ostream& os) const; Print object class name. void printAddress(ostream& os) const; Print addrss of this RooAbsArg. void printArgs(ostream& os) const; Print object arguments, ie its proxies. Int_t defaultPrintContents(Option_t* opt) const; Define default contents to print. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Implement multi-line detailed printing. void printTree(ostream& os, TString indent = """") const; Print object tree structure. void printAttri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:27350,cache,cached,27350,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,3,['cache'],['cached']
Performance,"by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. void unRegisterProxy(RooSetProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. void registerProxy(RooListProxy& proxy); Register an RooListProxy in the proxy list. This function is called by owned; proxies upon creation. After registration, this arg wil forward pointer; changes from serverRedirects and updates in cached normalization sets; to the proxies immediately after they occur. void unRegisterProxy(RooListProxy& proxy); Remove proxy from proxy list. This functions is called by owned proxies; upon their destruction. RooAbsProxy* getProxy(Int_t index) const; Return the nth proxy from the proxy list. Int_t numProxies() const; Return the number of registered proxies. void setProxyNormSet(const RooArgSet* nset); Forward a change in the cached normalization argset; to all the registered proxies. void attachToTree(TTree& t, Int_t bufSize = 32000); Overloadable function for derived classes to implement; attachment as branch to a TTree. Bool_t isValid() const; WVE (08/21/01) Probably obsolete now. void printName(ostream& os) const; Print object name. void printTitle(ostream& os) const; Print object title. void printClassName(ostream& os) const; Print object class name. void printAddress(ostream& os) const; Print addrss of this RooAbsArg. void printArgs(ostream& os) const; Print object arguments, ie its proxies. Int_t defaultPrintContents(Option_t* opt) const; Define default contents to print. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Implement multi-line detailed printing. void printTree(ostream& os, TString indent = """") const; Print object tree structure. void printAttribList(ostream& os) const; Print the attribute list. void attachDataSet(const RooAbsData",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsArg.html:27897,cache,cached,27897,root/html532/RooAbsArg.html,https://root.cern,https://root.cern/root/html532/RooAbsArg.html,4,['cache'],['cached']
Performance,by using instead seriaql execution. ; Definition at line 87 of file Config.h. ◆ DrawProgressBar(). Bool_t TMVA::Config::DrawProgressBar ; (; ); const. inline . Definition at line 68 of file Config.h. ◆ EnableMT(). void TMVA::Config::EnableMT ; (; int ; numthreads = 0). inline . Enable MT in TMVA (by default is on when ROOT::EnableImplicitMT() is set. ; Definition at line 84 of file Config.h. ◆ GetIONames(). IONames & TMVA::Config::GetIONames ; (; ). inline . Definition at line 98 of file Config.h. ◆ GetMultiThreadExecutor(). ROOT::TThreadExecutor & TMVA::Config::GetMultiThreadExecutor ; (; ). inline . Definition at line 76 of file Config.h. ◆ GetNCpu(). UInt_t TMVA::Config::GetNCpu ; (; ). inline . Definition at line 70 of file Config.h. ◆ GetNumWorkers(). UInt_t TMVA::Config::GetNumWorkers ; (; ); const. inline . Definition at line 72 of file Config.h. ◆ GetThreadExecutor(). Executor & TMVA::Config::GetThreadExecutor ; (; ). inline . Get executor class for multi-thread usage In case when MT is not enabled will return a serial executor. ; Definition at line 81 of file Config.h. ◆ GetVariablePlotting(). VariablePlotting & TMVA::Config::GetVariablePlotting ; (; ). inline . Definition at line 97 of file Config.h. ◆ Instance(). TMVA::Config & TMVA::Config::Instance ; (; ). static . static function: returns TMVA instance ; Definition at line 98 of file Config.cxx. ◆ IsA(). virtual TClass * TMVA::Config::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Definition at line 148 of file Config.h. ◆ IsMTEnabled(). Bool_t TMVA::Config::IsMTEnabled ; (; ); const. inline . Check if IMT is enabled. ; Definition at line 90 of file Config.h. ◆ IsSilent(). Bool_t TMVA::Config::IsSilent ; (; ); const. inline . Definition at line 62 of file Config.h. ◆ Log(). MsgLogger & TMVA::Config::Log ; (; ); const. inlineprivate . Definition at line 146 of file Config.h. ◆ operator=(). Config & TMVA::Config::operator= ; (; const Config & ; ). private . ◆ SetDrawProgress,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Config.html:5168,multi-thread,multi-thread,5168,doc/master/classTMVA_1_1Config.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Config.html,1,['multi-thread'],['multi-thread']
Performance,"byte range request from web server. ;  ; virtual Int_t GetHunk (TSocket *s, char *hunk, Int_t maxsize);  Read a hunk of data from the socket, up until a terminator. ;  ; virtual Int_t GetLine (TSocket *s, char *line, Int_t maxsize);  Read a line from the socket. ;  ; virtual const char * HttpTerminator (const char *start, const char *peeked, Int_t peeklen);  Determine whether [START, PEEKED + PEEKLEN) contains an HTTP new line [\r]\n. ;  ; void Init (Bool_t readHeadOnly) override;  Initialize a TWebFile object. ;  ; virtual Bool_t ReadBuffer10 (char *buf, Int_t len);  Read specified byte range from remote file via HTTP 1.0 daemon (without mod-root installed). ;  ; virtual Bool_t ReadBuffers10 (char *buf, Long64_t *pos, Int_t *len, Int_t nbuf);  Read specified byte ranges from remote file via HTTP 1.0 daemon (without mod-root installed). ;  ;  Protected Member Functions inherited from TFile; virtual Long64_t DirCreateEntry (TDirectory *);  ; virtual Int_t DirReadKeys (TDirectory *);  ; virtual void DirWriteHeader (TDirectory *);  ; virtual void DirWriteKeys (TDirectory *);  ; Bool_t FlushWriteCache ();  Flush the write cache if active. ;  ; virtual EAsyncOpenStatus GetAsyncOpenStatus ();  ; virtual InfoListRet GetStreamerInfoListImpl (bool lookupSICache);  See documentation of GetStreamerInfoList for more details. ;  ; Int_t MakeProjectParMake (const char *packname, const char *filename);  Create makefile at 'filemake' for PAR package 'pack'. ;  ; Int_t MakeProjectParProofInf (const char *packname, const char *proofinfdir);  Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'. ;  ; Int_t ReadBufferViaCache (char *buf, Int_t len);  Read buffer via cache. ;  ; virtual Int_t SysClose (Int_t fd);  Interface to system close. All arguments like in POSIX close(). ;  ; virtual Int_t SysOpen (const char *pathname, Int_t flags, UInt_t mode);  Interface to system open. All arguments like in POSIX open(). ;  ; virtual Int_t SysRead (Int_t fd, void *buf, Int_t len",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:34696,cache,cache,34696,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,1,['cache'],['cache']
Performance,"byte values from tree branches ; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealVar*_yvarY variable if so designated; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooXYChi2Var(); coverity[UNINIT_CTOR]. RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, Bool_t integrate = kFALSE). RooXYChi2Var constructor with function and X-Y values dataset. An X-Y dataset is a weighted dataset with one or more observables X where the weight is interpreted; as the Y value and the weight error is interpreted as the Y value error. The weight must have an; non-zero error defined at e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooXYChi2Var.html:36970,cache,cache,36970,root/html530/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html530/RooXYChi2Var.html,2,['cache'],['cache']
Performance,"byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager; RooSetProxy_cacheObsNon-convolution observables that are also cached; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFFTConvPdf.html:48682,cache,cache,48682,root/html602/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html602/RooFFTConvPdf.html,6,['cache'],['cache']
Performance,"bytes of the branch starting with node.Definition TGeoManager.cxx:3926; TGeoManager::fUniqueVolumesTObjArray * fUniqueVolumesDefinition TGeoManager.h:129; TGeoManager::fgExportPrecisionstatic UInt_t fgExportPrecisionMaximum number of Xtru vertices.Definition TGeoManager.h:55; TGeoManager::fRegionsTObjArray * fRegionsDefinition TGeoManager.h:109; TGeoManager::Nodevoid Node(const char *name, Int_t nr, const char *mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t *upar, Int_t npar=0)Create a node called <name_nr> pointing to the volume called <name> as daughter of the volume called ...Definition TGeoManager.cxx:1353; TGeoManager::fGShapesTObjArray * fGShapesDefinition TGeoManager.h:97; TGeoManager::fPaintVolumeTGeoVolume * fPaintVolumeDefinition TGeoManager.h:134; TGeoManager::GetSkinSurfaceTGeoSkinSurface * GetSkinSurface(const char *name) constGet skin surface with a given name;.Definition TGeoManager.cxx:2041; TGeoManager::UpdateElementsvoid UpdateElements()Update element flags when geometry is loaded from a file.Definition TGeoManager.cxx:4167; TGeoManager::TGeoManagerTGeoManager()Default constructor.Definition TGeoManager.cxx:311; TGeoManager::Classstatic TClass * Class(); TGeoManager::fPropertiesConstPropMap_t fPropertiesDefinition TGeoManager.h:149; TGeoManager::MakeTubeTGeoVolume * MakeTube(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz)Make in one step a volume pointing to a tube shape with given medium.Definition TGeoManager.cxx:3204; TGeoManager::CdUpvoid CdUp()Go one level up in geometry.Definition TGeoManager.cxx:1681; TGeoManager::DoBackupStatevoid DoBackupState()Backup the current state without affecting the cache stack.Definition TGeoManager.cxx:1098; TGeoManager::fMaterialsTList * fMaterialsDefinition TGeoManager.h:105; TGeoManager::CheckBoundaryErrorsvoid CheckBoundaryErrors(Int_t ntracks=1000000, Double_t radius=-1.)Check pushes and pulls needed to cross the next boundary with respect to th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:182084,load,loaded,182084,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['load'],['loaded']
Performance,"bytesInfo-1);; 3855 //Create new key; 3856 TKey key(&list,""StreamerInfo"",GetBestBuffer(), this);; 3857 fKeys->Remove(&key);; 3858 fSeekInfo = key.GetSeekKey();; 3859 fNbytesInfo = key.GetNbytes();; 3860 SumBuffer(key.GetObjlen());; 3861 key.WriteFile(0);; 3862 ; 3863 fClassIndex->fArray[0] = 0;; 3864 ; 3865 list.RemoveLast(); // remove the listOfRules.; 3866}; 3867 ; 3868////////////////////////////////////////////////////////////////////////////////; 3869/// Open a file for reading through the file cache.; 3870///; 3871/// The file will be downloaded to the cache and opened from there.; 3872/// If the download fails, it will be opened remotely.; 3873/// The file will be downloaded to the directory specified by SetCacheFileDir().; 3874 ; 3875TFile *TFile::OpenFromCache(const char *name, Option_t *, const char *ftitle,; 3876 Int_t compress, Int_t netopt); 3877{; 3878 TFile *f = nullptr;; 3879 ; 3880 if (fgCacheFileDir == """") {; 3881 ::Warning(""TFile::OpenFromCache"",; 3882 ""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache; 3896 // now create cachepath to put it; 3897 TString cachefilepath;; 3898 TString cachefilepathbasedir;; 3899 cachefilepath = fgCacheFileDir;; 3900 cachefilepath += fileurl.GetFile();; 3901 cachefilepathbasedir = gSystem->GetDirName(cachefilepath);; 3902 if ((gSystem->mkdir(cachefilepathbasedir, kTRUE) < 0) &&; 3903 (gSystem->AccessPathName(cachefilepathbasedir, kFileExists",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:141163,cache,cache,141163,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,3,['cache'],['cache']
Performance,"c . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooProjectedPdf::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 73 of file RooProjectedPdf.h. ◆ clone(). TObject * RooProjectedPdf::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Reimplemented in xRooProjectedPdf.; Definition at line 27 of file RooProjectedPdf.h. ◆ compileForNormSet(). std::unique_ptr< RooAbsArg > RooProjectedPdf::compileForNormSet ; (; RooArgSet const & ; normSet, . RooFit::Detail::CompileContext & ; ctx . ); const. overridevirtual . Reimplemented from RooAbsPdf.; Definition at line 283 of file RooProjectedPdf.cxx. ◆ createProjection(). RooAbsPdf * RooProjectedPdf::createProjection ; (; const RooArgSet & ; iset). overridevirtual . Special version of RooAbsReal::createProjection that deals with projections of projections. ; Instead of integrating twice, a new RooProjectedPdf is returned that is configured to perform the complete integration in one step ; Reimplemented from RooAbsPdf.; Definition at line 145 of file RooProjectedPdf.cxx. ◆ DeclFileName(). static const char * RooProjectedPdf::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 73 of file RooProjectedPdf.h. ◆ evaluate(). double RooProjectedPdf::evaluate ; (; ); const. overrideprotectedvirtual . Evaluate projected p.d.f. ; Implements RooAbsReal.; Reimplemented in xRooProjectedPdf.; Definition at line 94 of file RooProjectedPdf.cxx. ◆ expectedEvents(). double RooProjectedPdf::expectedEvents ; (; const RooArgSet * ; nset); const. inlineoverridevirtual . Return expected number of events to be used in calculation of extended likelihood. ; Return expected number of events from this p.d.f for use in extended likelihood calculations.; This default implementation returns zero ; Reimplemented from RooAbsPdf.; Reimplemented in xRooProjectedPdf.; Definition at line 46 of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProjectedPdf.html:76826,perform,perform,76826,doc/master/classRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classRooProjectedPdf.html,1,['perform'],['perform']
Performance,"c Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::HandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*TProof::MakePlayer(const char* player = 0, TSocket* s = 0); TProofQueryResult*MakeQueryResult(Long64_t nent, const char* opt, Long64_t fst, TDSet* dset, const char* selec); voidTObject::MakeZombie(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary | kForward | kCp | kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString& emsg); voidTProof::SetDSet(TDSet* dset); voidTProof::SetFeedback(TString& opt, TString& optfb, Int_t action); voidTProof::SetPlayer(TVirtualProofPlayer* player); voidSetQueryRunning(TProofQueryResult* pq); Int_tSetupWorkers(Int_t opt = 0, TList* wrks = 0); static void*TProof::SlaveStartupThread(void* arg); virtual Bool_tTProof::StartSlaves(Bool_t attach = kFALSE); static voidTProof::SystemCmd(const char* cmd, Int_t fdout); TProofLite(); voidTProof::UpdateDialog(); virtual voidTProof::ValidateDSet(TDSet* dset); Int_tTProof::VerifyDataSetParallel(const char* uri, const char* optStr).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofLite.html:22117,cache,cachedir,22117,root/html602/TProofLite.html,https://root.cern,https://root.cern/root/html602/TProofLite.html,1,['cache'],['cachedir']
Performance,"c Int_t_evalErrorCount; static map<const RooAbsArg*,std::pair<std::string,std::list<EvalError> > >_evalErrorList; static RooAbsReal::ErrorLoggingMode_evalErrorMode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void setHideOffset(Bool_t flag); { _hideOffset = flag ; }. Bool_t hideOffset(); { return _hideOffset ; }. ~RooAbsReal(); Destructor. Bool_t operator==(Double_t value) const; Equality operator comparing to a Double_t. Bool_t operator==(const RooAbsArg& other); Equality operator when comparing to another RooAbsArg.; Only functional when the other arg is a RooAbsReal. Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). TString getTitle(Bool_t appendUnit = kFALSE) const; Return this variable's title string. If appendUnit is true and; this variable has units, also append a string "" (<unit>)"". Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Int_t numEvalErrorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function sho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:34975,cache,cache,34975,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,3,['cache'],"['cache', 'cached']"
Performance,"c RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*_coefThresh[_nComp] Array of coefficient thresholds; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; vector<RooAbsGenContext*>_gcListList of component generator contexts; RooDataSet*RooAbsGenContext::_genData! Data being generated; Bool_t_isModelAre we generating from a RooAddPdf or a RooAddModel; Bool_tRooAbsGenContext::_isValidIs context in valid state?; RooAddModel::CacheElem*_mcache! RooAddModel cache element; Int_t_nCompNumber of PDF components; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; TStringRooAbsGenContext::_normRangeNormalization range of pdf; RooAddPdf::CacheElem*_pcache! RooAddPdf cache element; RooAbsPdf*_pdfPointer to cloned p.d.f; RooArgSet*_pdfSetSet owned all nodes of internal clone of p.d.f; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; const RooArgSet*_vars; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAddGenContext(const RooAddPdf& model, const RooArgSet& vars, const RooDataS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddGenContext.html:9588,cache,cache,9588,root/html602/RooAddGenContext.html,https://root.cern,https://root.cern/root/html602/RooAddGenContext.html,6,"['cache', 'load']","['cache', 'load']"
Performance,"c RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooArgSet_actual! Set of actual dependents; Bool_t_compiledFlag set if formula is compiled; Bool_t_isOKIs internal state OK?; RooLinkedList_labelListList of label names for category objects; static Int_tRooPrintable::_nameLength; RooArgSet*_nset; RooLinkedList_origList! Original list of dependents; vector<Bool_t>_useIsCat! Is given slot in _useList a category?; RooLinkedList_useList! List of actual dependents; TBitsROOT::v5::TFormula::fAlreadyFound! cache for information; Double_t*ROOT::v5::TFormula::fConst[fNconst] Array of fNconst formula constants; TString*ROOT::v5::TFormula::fExpr[fNoper] List of expressions; TString*ROOT::v5::TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayROOT::v5::TFormula::fFunctionsArray of function calls to make; TObjArrayROOT::v5::TFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_tROOT::v5::TFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*ROOT::v5::TFormula::fNames[fNpar] Array of parameter names; Int_tROOT::v5::TFormula::fNconstNumber of constants; Int_tROOT::v5::TFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tROOT::v5::TFormula::fNoperNumber of operators; Int_tROOT::v5::TFormula::fNparNumber of parameters; Int_tROOT::v5::TFormula::fNstringNumber of different constants character strings; Int_tROOT::v5::TFormula::fNumberformula number identifier; Int_tROOT::v5::TFormula::fNvalNumber of different variables in expression; ROOT::v5::TOperOffset*ROOT::v5::TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*ROOT::v5::TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); ROOT::v5::TFormula::TFuncGROOT::v5::TFormula::fOptimal!pointer to optimal function; Double_t*ROOT::v5::TF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooFormula.html:13863,cache,cache,13863,root/html604/RooFormula.html,https://root.cern,https://root.cern/root/html604/RooFormula.html,2,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"c TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfChangedtrue if file has changed; TGClient*fClientclient to which mime types belong (display server); TStringfFilenamefile name of mime type file; TOrdCollection*fListlist of mime types. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGMimeTypes(TGClient* client, const char* file); Create a mime type cache. Read the mime types file ""filename"" and; built a list of mime types. ~TGMimeTypes(); Delete mime type pool. TGMimeTypes(const TGMimeTypes& gmt); Copy constructor. TGMimeTypes& operator=(const TGMimeTypes& gmt); Assignment operator. TGMime * Find(const char* filename); Given a filename find the matching mime type object. const TGPicture * GetIcon(const char* filename, Bool_t small_icon); Return icon belonging to mime type of filename. Bool_t GetAction(const char* filename, char* action); Return in action the mime action string belonging to filename. Bool_t GetType(const char* filename, char* type); Return in type the mime type belonging to filename. void Print(Option_t* option = """") const; Print list of mime types. void SaveMimes(); Save mime types in user's mime type file. void AddType(const char* type, const char* pat, const char* icon, const char* sicon, const char* action); Add a mime type to the list of mime types. Bool_t HasChanged",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGMimeTypes.html:6447,cache,cache,6447,root/html602/TGMimeTypes.html,https://root.cern,https://root.cern/root/html602/TGMimeTypes.html,2,['cache'],['cache']
Performance,"c TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTEveCaloViz::fAutoRangeset eta phi limits on DataChanged(); Float_t*TAttBBox::fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max); Float_tTEveCaloViz::fBarrelRadiusbarrel raidus in cm; UChar_tTEveElement::fCSCBits; Bool_tTEveElement::fCanEditMainColorAllow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; Bool_tTEveCaloViz::fCellIdCacheOKdata cell ids cache state; vector<TEveCaloData::vCellId_t*>fCellLists; vector<TEveCaloData::vCellId_t*>fCellListsHighlighted; vector<TEveCaloData::vCellId_t*>fCellListsSelected; UChar_tTEveElement::fChangeBits!; TEveElement::List_tTEveElement::fChildrenList of children.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; TEveCaloData*TEveCaloViz::fDataevent data reference; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Float_tTEveProjected::fDepthz coordinate; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Float_tTEveCaloViz::fEndCapPosBbackward end cap z coordinate in cm (should be < 0); Float_tTEveCaloViz::fEndCapPosFforward end cap z coordinate in cm; Double_tTEveCaloViz::fEtaMax; Double_tTEveCaloViz::fEtaMin; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; TEveElement::sLTI_tTEveElement::fItems! Set of list-tree-items.; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main trans",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveCalo2D.html:21933,cache,cache,21933,root/html602/TEveCalo2D.html,https://root.cern,https://root.cern/root/html602/TEveCalo2D.html,2,['cache'],['cache']
Performance,"c TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Int_tfDebugLocal verbosity level; TStringfDirNameThe name of the subdir with the perfomance tree; TH1F*fEventsEvent distribution per worker; TH1F*fEvtRateEvent processing rate vs query time; Double_tfEvtRateAvgAverage event processing rate; Double_tfEvtRateAvgMaxMax running event processing rate; Double_tfEvtRateMaxMax event processing rate per packet; TH1F*fEvtRateRunEvent processing rate running avg vs query time; TFile*fFileThe open performance file; TStringfFileResultFile where to save basics of a run when requested; TSortedListfFilesInfoSorted list of files info; Float_tfInitTimeEnd of initialization time for this query; Double_tfLatencyMaxMax retrieval latency per packet; TH1F*fMBRateByte processing rate vs query time; Double_tfMBRateAvgAverage MB processing rate; Double_tfMBRateAvgMaxMax running MB processing rate; Double_tfMBRateMaxMax MB processing rate per packet; TH1F*fMBRateRunByte processing rate running avg vs query time; Float_tfMaxTimeMax time for this query (slowest worker); Float_tfMergeTimeBegin of merging time for this query; TH1F*fPacketsPacket distribution per worker; Bool_tfSaveResultWhether to save the results of a run; TTree*fTreeThe performance tree; TStringfTreeNameThe name of the performance tree; TSortedListfWrksInfoSorted list of workers info; static Bool_tfgDebugGlobal verbosity on/off. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofPerfAnalysis(const char* perffile, const char* title = """", const char* treename = ""PROOF_PerfStats""); Constructor: open the file and attach to the tree. TProofPerfAnalysis(TTree* tree, const char* title = """"); Constructor: open the f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofPerfAnalysis.html:8019,perform,performance,8019,root/html604/TProofPerfAnalysis.html,https://root.cern,https://root.cern/root/html604/TProofPerfAnalysis.html,4,"['latency', 'perform']","['latency', 'performance']"
Performance,"c TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTruthModel.html:46988,cache,cache,46988,root/html602/RooTruthModel.html,https://root.cern,https://root.cern/root/html602/RooTruthModel.html,2,['cache'],['cache']
Performance,"c TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,double,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCFunction2PdfBinding_double_double_int_.html:39353,cache,cache,39353,root/html528/RooCFunction2PdfBinding_double_double_int_.html,https://root.cern,https://root.cern/root/html528/RooCFunction2PdfBinding_double_double_int_.html,2,['cache'],['cache']
Performance,"c TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCFunction2PdfBinding_double_int_double_.html:39353,cache,cache,39353,root/html528/RooCFunction2PdfBinding_double_int_double_.html,https://root.cern,https://root.cern/root/html528/RooCFunction2PdfBinding_double_int_double_.html,2,['cache'],['cache']
Performance,"c UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . Private Member Functions;  TFile (const TFile &)=delete;  ; void operator= (const TFile &)=delete;  . Static Private Member Functions; static void CpProgress (Long64_t bytesread, Long64_t size, TStopwatch &watch);  Print file copy progress. ;  ; static TFile * OpenFromCache (const char *name, Option_t *="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0);  Open a file for reading through the file cache. ;  . Friends; class TBasket;  ; class TDirectoryFile;  ; class TFilePrefetch;  . Additional Inherited Members;  Protected Types inherited from TDirectory; using SharedGDirectory_t = std::shared_ptr< std::atomic< TDirectory * > >;  Pointer to a list of TContext object pointing to this TDirectory. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TDirectory; static Bool_t Cd1 (const char *path);  Change current directory to ""path"". ;  ; static SharedGDirectory_t & GetSharedLocalCurrentDirectory ();  Return the (address of) a shared pointer to the struct holding the actual thread local gDirectory pointer and the atomic_flag for its lock. ;  . #include <TFile.h>. Inheritance diagram for TFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [lege",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:44932,cache,cache,44932,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['cache'],['cache']
Performance,"c ULong64_t fgBytesSent = 0;  ; static Int_t fgClientProtocol = 17;  . #include <TServerSocket.h>. Inheritance diagram for TServerSocket:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ anonymous enum. anonymous enum. EnumeratorkDefaultBacklog . Definition at line 56 of file TServerSocket.h. Constructor & Destructor Documentation. ◆ TServerSocket() [1/4]. TServerSocket::TServerSocket ; (; ). inlineprivate . Definition at line 50 of file TServerSocket.h. ◆ TServerSocket() [2/4]. TServerSocket::TServerSocket ; (; const TServerSocket & ; ). private . ◆ TServerSocket() [3/4]. TServerSocket::TServerSocket ; (; Int_t ; port, . Bool_t ; reuse = kFALSE, . Int_t ; backlog = kDefaultBacklog, . Int_t ; tcpwindowsize = -1 . ). Create a server socket object on a specified port. ; Set reuse to true to force reuse of the server socket (i.e. do not wait for the time out to pass). Using backlog one can set the desirable queue length for pending connections. If port is 0 a port scan will be done to find a free port. This option is mutual exlusive with the reuse option. Use tcpwindowsize to specify the size of the receive buffer, it has to be specified here to make sure the window scale option is set (for tcpwindowsize > 65KB and for platforms supporting window scaling). Use IsValid() to check the validity of the server socket. In case server socket is not valid use GetErrorCode() to obtain the specific error value. These values are: 0 = no error (socket is valid) -1 = low level socket() call failed -2 = low level bind() call failed -3 = low level listen() call failed Every valid server socket is added to the TROOT sockets list which will make sure that any open sockets are properly closed on program termination. ; Definition at line 139 of file TServerSocket.cxx. ◆ TServerSocket() [4/4]. TServerSocket::TServerSocket ; (; const char * ; service, . Bool_t ; reuse = kFALSE, . Int_t ; backlog = kDefaultB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTServerSocket.html:19776,queue,queue,19776,doc/master/classTServerSocket.html,https://root.cern,https://root.cern/doc/master/classTServerSocket.html,1,['queue'],['queue']
Performance,"c integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Fitting -- RooAbsPdf::fitTo(pdf_over_pdf_Int[cosa,t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_pdf_over_pdf_Int[cosa,t]_pdfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl1); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) indirectly selected PDF components: (poly1,coshGBasis); [#1] INFO:Plotting -- RooAbsReal::plotOn(pdf) plot on t integrates over variables (cosa); [#1] INFO:NumericIntegration -- RooRealIntegral::init(coshGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:NumericIntegration -- RooRealIntegral::init(sinhGBasis_Int[t]) using numeric integrator RooIntegrator1D to calculate Int(t); [#1] INFO:Plotting -- RooAbsPdf::plotOn(pdf) directly selected PDF components: (ampl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf704__amplitudefit_8C.html:8005,optimiz,optimization,8005,doc/master/rf704__amplitudefit_8C.html,https://root.cern,https://root.cern/doc/master/rf704__amplitudefit_8C.html,2,['optimiz'],['optimization']
Performance,"c voidMacro(const char* mac); TEveUtil&operator=(const TEveUtil&); static voidSetColorBrightness(Float_t value, Bool_t full_redraw = kFALSE); static voidSetupEnvironment(); static voidSetupGUI(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TEveUtil(); TEveUtil(const TEveUtil&). Data Members; private:. static TObjArray*fgDefaultColors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupEnvironment(); Setup Include and Macro paths.; Since inclusion into ROOT this does nothing but could; potentially be reactivated if some common macros are established; and shipped with binary ROOT (in macros/eve). For example, these; might be used to spawn specific GUI / GL configurations. void SetupGUI(); Setup icon pictures and mime-types. Bool_t CheckMacro(const char* mac); Checks if macro 'mac' is loaded. void AssertMacro(const char* mac); Load and execute macro 'mac' if it has not been loaded yet. void Macro(const char* mac); Execute macro 'mac'. Do not reload the macro. void LoadMacro(const char* mac); Makes sure that macro 'mac' is loaded, but do not reload it. void ColorFromIdx(Color_t ci, UChar_t[4] col, Bool_t alpha = kTRUE); Fill col with RGBA values corresponding to index ci. If alpha; is true, set alpha component of col to 255.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Color_t ci, UChar_t[4] col, Char_t transparency); Fill col with RGBA values corresponding to index ci and transparency.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Float_t f1, Color_t c1, Float_t f2, Color_t c2, UChar_t[4] col, Bool_t alpha = kTRUE); Fill col with weighted RGBA values corresponding to; color-indices c1 and c2. If alpha is true, set alpha component; of col to 255. Color_t* FindColorVar(TObject* obj, const char* varname); Find address of Color_t data-member with name varnam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveUtil.html:2407,load,loaded,2407,root/html602/TEveUtil.html,https://root.cern,https://root.cern/root/html602/TEveUtil.html,2,['load'],['loaded']
Performance,"c voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. (unknown)(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClass * GetClass(const char* classname, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const type_info& typeinfo, Bool_t load, Bool_t silent); Default implementation for backward compatibility ignoring the value of 'silent'. TClass * GetClass(const char* classname, Bool_t load). TClass * GetClass(const type_info& typeinfo, Bool_t load). » Author: Philippe Canal 24/06/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers, and al. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-12 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClassGenerator.html:5819,load,load,5819,root/html534/TClassGenerator.html,https://root.cern,https://root.cern/root/html534/TClassGenerator.html,4,['load'],['load']
Performance,"c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; WARNING: Currently only ONE TTree object can be 'cached' per TFile object.; This call disable the cache for the other TTree objects read from the same; TFile object as this TTree (The SetCacheSize called __last__ wins).; To cache multiple TTree objects in the same ROOT file, you must create; one TFile object per TTree object. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled again. void SetDebug(Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:120275,cache,cache,120275,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,3,['cache'],['cache']
Performance,"c,xw,yc,yw,zc,zw; 1971 ; 1972void TFumili::FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.5*cache[7],cache[6] + 0.5*cache[7])/(cache[3]*cache[5]*cache[7]);; 2009 }; 2010 if (TF1::RejectedPoint()) {cache += fPointSize; continue;}; 2011 if (flag == 2) {; 2012 for (j=0;j<npar;j++) {; 2013 dersum[j] += 1; //should be the derivative; 2014 //grad[j] += dersum[j]*(fu-cu)/eu; dersum[j] = 0;; 2015 }; 2016 }; 2017 if (fu < 1.e-9) fu = 1.e-9;; 2018 icu = Int_t(cu);; 2019 fsub = -fu +icu*TMath::Log(fu);; 2020 fobs = GetSumLog(icu);; 2021 fsub -= fobs;; 2022 Derivatives(df,x);; 2023 int n=0;; 2024 // Here we need gradients of Log likelihood function; 2025 //; 2026 for (j=0;j<npar;j++) {; 2027 if (pl0[j]>0){; 2028 df[n] = df[j]",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:58062,cache,cache,58062,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,2,['cache'],['cache']
Performance,"c. refer to “Graphical Containers: Canvas and Pad”.; root[] myShapes->Draw(""ogl"");; Valid option strings are:. “ogl” : external GL viewer; “x3d”: external X3D viewer; “pad”: pad viewer. If no option is passed to Draw() then the “pad” is used by default. If you already have content in a pad, which you would like to display in one of the external viewers you can select from the canvas View menu / View With, and pick the viewer type. Invoking external 3D viewers from canvas menus. Note: A current limitation means that when an external viewer is created the pad is no longer redrawn. When the external viewer is closed, clicking in the pad will refresh.; 9.13.2 The GL Viewer; The GL Viewer uses <OpenGL®> (or compliant libraries such as ) to generate high quality, high-performance 3D renderings, with sophisticated lighting, materials and rendering styles for 3D scenes. Many users will be able to take advantage of hardware acceleration of the underlying OpenGL commands by their computer’s video card, resulting is considerable performance gains - up to interactive manipulation of 1000’s of complex shapes in real-time.; The GL Viewer is supported on all official ROOT platforms (assuming you have suitable <OpenGL®> libraries), and is the main 3D viewer, which development effort is concentrated upon. As OpenGL® is a trademark we refer to our viewer built on this technology as the ‘GL Viewer’. The code for it can be found under $ROOTSYS/gl. The GL 3D Viewer. You can manipulate the viewer via the GUI or via the base TGLViewer object behind the interface. These are detailed below - see also $ROOTSYS/tutorials/gl/glViewerExercise.C.; 9.13.2.1 Projections Modes (Cameras); The GL Viewer supports two basic types of camera, which affect how the 3D world is projected onto the 2D render area:. Perspective: Objects are drawn with characteristic ‘foreshortening’ effect, where distant objects appear smaller than near ones. This is useful for obtaining a ‘real world’ views. The degree of for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:387648,perform,performance,387648,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performance']
Performance,"c:. TGLPolyMarker(const TBuffer3D& buffer); ~TGLPolyMarker(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals(). pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLPolyMarker.html:1793,cache,cached,1793,root/html528/TGLPolyMarker.html,https://root.cern,https://root.cern/root/html528/TGLPolyMarker.html,3,['cache'],['cached']
Performance,"cHeader (std::ostream &, const TString &) const;  Specific class header. ;  ; virtual std::map< TString, Double_t > OptimizeTuningParameters (TString fomType=""ROCIntegral"", TString fitType=""FitGA"");  Call the Optimizer with the set of parameters and ranges that are meant to be tuned. ;  ; void ProcessOptions ();  The option string is decoded, for available options see ""DeclareOptions"". ;  ; virtual void ReadWeightsFromStream (std::istream &)=0;  ; void ReadWeightsFromStream (std::istream &istr);  Read the weights (BDT coefficients). ;  ; virtual void ReadWeightsFromStream (TFile &);  ; void ReadWeightsFromXML (void *parent);  Reads the BDT from the xml file. ;  ; void Reset (void);  Reset the method, as if it had just been instantiated (forget all training etc.). ;  ; void SetAdaBoostBeta (Double_t b);  ; void SetBaggedSampleFraction (Double_t f);  ; void SetMaxDepth (Int_t d);  ; void SetMinNodeSize (Double_t sizeInPercent);  ; void SetMinNodeSize (TString sizeInPercent);  ; void SetNodePurityLimit (Double_t l);  ; void SetNTrees (Int_t d);  ; void SetShrinkage (Double_t s);  ; virtual void SetTuneParameters (std::map< TString, Double_t > tuneParameters);  Set the tuning parameters according to the argument. ;  ; void SetUseNvars (Int_t n);  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Double_t TestTreeQuality (DecisionTree *dt);  Test the tree quality.. in terms of Misclassification. ;  ; void Train (void);  BDT training. ;  ; void WriteMonitoringHistosToFile (void) const;  Here we could write some histograms created during the processing to the output file. ;  ;  Public Member Functions inherited from TMVA::MethodBase;  MethodBase (const TString &jobName, Types::EMVA methodType, const TString &methodTitle, DataSetInfo &dsi, const TString &theOption="""");  standard constructor ;  ;  MethodBase (Types::EMVA methodType, DataSetInfo &dsi, const TString &weightFile);  constructor used for Testing + Application ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:7671,tune,tuneParameters,7671,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['tune'],['tuneParameters']
Performance,"c_tGetDestructor() const; static DictFuncPtr_tGetDict(const char* cname); static DictFuncPtr_tGetDict(const type_info& info); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); ROOT::DirAutoAdd_tGetDirectoryAutoAdd() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFunctionTemplate*GetFunctionTemplate(const char* name); UInt_tGetHeapInstanceCount() const; virtual const char*TObject::GetIconName() const; Short_tGetImplFileLine() const; const char*GetImplFileName() const; UInt_tGetInstanceCount() const; TVirtualIsAProxy*GetIsAProxy() const; TVirtualStreamerInfo*GetLastReadInfo() const; TList*GetListOfAllPublicDataMembers(Bool_t load = kTRUE); const TList*GetListOfAllPublicMethods(Bool_t load = kTRUE); TList*GetListOfBases(); TList*GetListOfDataMembers(Bool_t load = kTRUE); TList*GetListOfEnums(Bool_t load = kTRUE); TList*GetListOfFunctionTemplates(Bool_t load = kTRUE); TCollection*GetListOfMethodOverloads(const char* name) const; TList*GetListOfMethods(Bool_t load = kTRUE); TList*GetListOfRealData() const; voidGetMenuItems(TList* listitems); TList*GetMenuList() const; ROOT::MergeFunc_tGetMerge() const; TMethod*GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); TMethod*GetMethodAllAny(const char* method); TMethod*GetMethodAny(const char* method); TMethod*GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); voidGetMissingDictionaries(THashTable& result, bool recurse = false); virtual const char*TNamed::GetName() const; Int_tGetNdata(); ROOT::NewFunc_tGetNew() const; ROOT::NewArrFunc_tGetNewArray() const; Int_tGetNmethods(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TClass*const*GetPersistentRef() const; TRealDat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:6670,load,load,6670,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['load'],['load']
Performance,"cache (and there was a previous cache), you ought to retrieve (and delete it if needed) using: TFileCacheRead *older = myfile->GetCacheRead();; The action specifies how to behave when detaching a cache from the the TFile. If set to (default) kDisconnect, the contents of the cache will be flushed when it is removed from the file, and it will disconnect the cache object from the file. In almost all cases, this is what you want. If you want to disconnect the cache temporarily from this tree and re-attach later to the same fil, you can set action to kDoNotDisconnect. This will allow things like prefetching to continue in the background while it is no longer the default cache for the TTree. Except for a few expert use cases, kDisconnect is likely the correct setting.; WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. ; Definition at line 2365 of file TFile.cxx. ◆ SetCacheWrite(). void TFile::SetCacheWrite ; (; TFileCacheWrite * ; cache). virtual . Set a pointer to the write cache. ; If file is null the existing write cache is deleted. ; Definition at line 2388 of file TFile.cxx. ◆ SetCompressionAlgorithm(). void TFile::SetCompressionAlgorithm ; (; Int_t ; algorithm = ROOT::RCompressionSetting::EAlgorithm::kUseGlobal). virtual . See comments for function SetCompressionSettings. ; Definition at line 2305 of file TFile.cxx. ◆ SetCompressionLevel(). void TFile::SetCompressionLevel ; (; Int_t ; level = ROOT::RCompressionSetting::ELevel::kUseMin). virtual . See comments for function SetCompressionSettings. ; Definition at line 2319 of file TFile.cxx. ◆ SetCompressionSettings(). void TFile::SetCompressionSettings ; (; Int_t ; settings = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault). virtual . Used to specify the compression level and algorithm. ; See the TFile constructor for the details. ; Definition at line 2338 of file TFile.cxx. ◆ SetEND(). virtual void TFile::SetEND ; (; Long64_t ; last). inlinevirtual . Reimplemented in TSQLFile, an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:93074,cache,cache,93074,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['cache'],['cache']
Performance,"cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedReal.html:31686,cache,cache,31686,root/html526/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedReal.html,2,['cache'],['cache']
Performance,"cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCachedReal.html:32401,cache,cache,32401,root/html530/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html,1,['cache'],['cache']
Performance,"cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddition.html:31140,cache,cache,31140,root/html528/RooAddition.html,https://root.cern,https://root.cern/root/html528/RooAddition.html,1,['cache'],['cache']
Performance,"cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAddition.html:31329,cache,cache,31329,root/html530/RooAddition.html,https://root.cern,https://root.cern/root/html530/RooAddition.html,1,['cache'],['cache']
Performance,"cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooListProxy_highSetHigh-side varaition; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; vector<int>_interpCode; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_lowSetLow-side variation; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooRealProxy_nominalThe nominal value; RooObjCacheManager_normIntMgrThe integration cache manager; RooListProxy_normSetinterpolation parameters; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; RooListProxy_paramSetinterpolation parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_t_positiveDefiniteprotect against negative and 0 bins.; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/PiecewiseInterpolation.html:32728,cache,cache,32728,root/html532/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html532/PiecewiseInterpolation.html,1,['cache'],['cache']
Performance,"cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxyRooAbsHiddenReal::_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; RooRealProxy_valueHolder of the blind value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooUnblindPrecision.html:32831,cache,cache,32831,root/html526/RooUnblindPrecision.html,https://root.cern,https://root.cern/root/html526/RooUnblindPrecision.html,2,['cache'],['cache']
Performance,"cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedPdf.html:45444,cache,cache,45444,root/html534/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html,1,['cache'],['cache']
Performance,"cache manager; RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealSumPdf.html:43642,cache,cache,43642,root/html534/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html534/RooRealSumPdf.html,1,['cache'],['cache']
Performance,"cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxybeta; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxygamma; RooRealProxymu; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGamma.html:44040,cache,cache,44040,root/html602/RooGamma.html,https://root.cern,https://root.cern/root/html602/RooGamma.html,2,['cache'],['cache']
Performance,"cache training. ; The contents of the miss cache will be emptied as well as the list of branches used. ; Definition at line 697 of file TTreeCache.cxx. ◆ SetAutoCreated(). void TTreeCache::SetAutoCreated ; (; bool ; val). inline . Definition at line 164 of file TTreeCache.h. ◆ SetBufferSize(). Int_t TTreeCache::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2072 of file TTreeCache.cxx. ◆ SetEntryRange(). void TTreeCache::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2105 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line 2127 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2144 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:48866,optimiz,optimize,48866,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['optimiz'],['optimize']
Performance,"cache; 1180/// - -1 on error; 1181 ; 1182Int_t TTree::DropBranchFromCache(TBranch *b, bool subbranches); 1183{; 1184 if (!GetTree()) {; 1185 if (LoadTree(0)<0) {; 1186 Error(""DropBranchFromCache"",""Could not load a tree"");; 1187 return -1;; 1188 }; 1189 }; 1190 if (GetTree()) {; 1191 if (GetTree() != this) {; 1192 Int_t res = GetTree()->DropBranchFromCache(b, subbranches);; 1193 if (res<0) {; 1194 Error(""DropBranchFromCache"", ""Error dropping branch"");; 1195 }; 1196 return res;; 1197 }; 1198 } else {; 1199 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1200 return -1;; 1201 }; 1202 ; 1203 TFile *f = GetCurrentFile();; 1204 if (!f) {; 1205 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1206 return -1;; 1207 }; 1208 TTreeCache *tc = GetReadCache(f,true);; 1209 if (!tc) {; 1210 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1211 return -1;; 1212 }; 1213 return tc->DropBranch(b,subbranches);; 1214}; 1215 ; 1216////////////////////////////////////////////////////////////////////////////////; 1217/// Add a cloned tree to our list of trees to be notified whenever we change; 1218/// our branch addresses or when we are deleted.; 1219 ; 1220void TTree::AddClone(TTree* clone); 1221{; 1222 if (!fClones) {; 1223 fClones = new TList();; 1224 fClones->SetOwner(false);; 1225 // So that the clones are automatically removed from the list when; 1226 // they are deleted.; 1227 {; 1228 R__LOCKGUARD(gROOTMutex);; 1229 gROOT->GetListOfCleanups()->Add(fClones);; 1230 }; 1231 }; 1232 if (!fClones->FindObject(clone)) {; 1233 fClones->Add(clone);; 1234 }; 1235}; 1236 ; 1237// Check whether mainTree and friendTree can be friends w.r.t. the kEntriesReshuffled bit.; 1238// In particular, if any has the bit set, then friendTree must have a TTreeIndex and the; 1239// branches used for indexing must be present in mainTree.; 1240// Return true if the trees can be friends, false ot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:42641,cache,cache,42641,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,2,['cache'],['cache']
Performance,"cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Tue Jun 2 15:26:55 2015 » Last generated: 2015-06-02 15:26; This page has",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsCachedPdf.html:49065,cache,cached,49065,root/html604/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html604/RooAbsCachedPdf.html,1,['cache'],['cached']
Performance,"cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Tue Jun 30 14:29:56 2015 » Last generated: 2015-06-30 14:29; This page ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedPdf.html:49065,cache,cached,49065,root/html602/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html,1,['cache'],['cached']
Performance,"cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Int_t_coefIdxIndex code of the coefficient; RooRealProxy_convPdfRooAbsAnaConv object implementing our coefficient; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooConvCoefVar.html:30513,cache,cache,30513,root/html526/RooConvCoefVar.html,https://root.cern,https://root.cern/root/html526/RooConvCoefVar.html,2,['cache'],['cache']
Performance,"cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Int_t_coefIdxIndex code of the coefficient; RooRealProxy_convPdfRooAbsAnaConv object implementing our coefficient; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed by",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooConvCoefVar.html:31180,cache,cache,31180,root/html530/RooConvCoefVar.html,https://root.cern,https://root.cern/root/html530/RooConvCoefVar.html,1,['cache'],['cache']
Performance,"cacheListlist of caches; Bool_t_cacheNumCache integral if numeric; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jacobian; TIterator*_jacListIter! Iterator over lvalue observables with Jacobian; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_mode; static Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealIntegral.html:32350,cache,cache,32350,root/html532/RooRealIntegral.html,https://root.cern,https://root.cern/root/html532/RooRealIntegral.html,1,['cache'],['cache']
Performance,"cacheListlist of caches; Bool_t_cacheNumCache integral if numeric; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jacobian; TIterator*_jacListIter! Iterator over lvalue observables with Jacobian; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealIntegral.html:34003,cache,cache,34003,root/html534/RooRealIntegral.html,https://root.cern,https://root.cern/root/html534/RooRealIntegral.html,1,['cache'],['cache']
Performance,"cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependentOverlaps(const RooAbsData *dset;  ;  R__DEPRECATED (6, 36, ""Use observableOverl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBMixDecay.html:49506,cache,cache,49506,doc/master/classRooBMixDecay.html,https://root.cern,https://root.cern/doc/master/classRooBMixDecay.html,7,['cache'],['cache']
Performance,"cachedIntegral->setCacheSource(true) ;; 561 if (normInt->operMode()==ADirty) {; 562 cachedIntegral->setOperMode(ADirty) ;; 563 }; 564 normInt= cachedIntegral ;; 565 }; 566 ; 567 }; 568 _norm = normInt ;; 569 }; 570 ; 571 // Register new normalization with manager (takes ownership); 572 cache = new CacheElem(*_norm) ;; 573 _normMgr.setObj(nset,cache) ;; 574 ; 575// cout << ""making new object "" << _norm->GetName() << endl ;; 576 ; 577 return true ;; 578}; 579 ; 580 ; 581 ; 582////////////////////////////////////////////////////////////////////////////////; 583/// Reset error counter to given value, limiting the number; 584/// of future error messages for this pdf to 'resetValue'; 585 ; 586void RooAbsPdf::resetErrorCounters(Int_t resetValue); 587{; 588 _errorCount = resetValue ;; 589 _negCount = resetValue ;; 590}; 591 ; 592 ; 593 ; 594////////////////////////////////////////////////////////////////////////////////; 595/// Reset trace counter to given value, limiting the; 596/// number of future trace messages for this pdf to 'value'; 597 ; 598void RooAbsPdf::setTraceCounter(Int_t value, bool allNodes); 599{; 600 if (!allNodes) {; 601 _traceCount = value ;; 602 return ;; 603 } else {; 604 RooArgList branchList ;; 605 branchNodeServerList(&branchList) ;; 606 for(auto * pdf : dynamic_range_cast<RooAbsPdf*>(branchList)) {; 607 if (pdf) pdf->setTraceCounter(value,false) ;; 608 }; 609 }; 610 ; 611}; 612 ; 613 ; 614 ; 615 ; 616////////////////////////////////////////////////////////////////////////////////; 617/// Return the log of the current value with given normalization; 618/// An error message is printed if the argument of the log is negative.; 619 ; 620double RooAbsPdf::getLogVal(const RooArgSet* nset) const; 621{; 622 return getLog(getVal(nset), this);; 623}; 624 ; 625 ; 626////////////////////////////////////////////////////////////////////////////////; 627/// Check for infinity or NaN.; 628/// \param[in] inputs Array to check; 629/// \return True if either infinity ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:22282,cache,cache,22282,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['cache'],['cache']
Performance,"caching of slow numeric integrals and parameterization of slow numeric integrals . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooDataHist.h""; #include ""RooGaussian.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooWorkspace.h""; #include ""RooExpensiveObjectCache.h""; #include ""TFile.h""; #include ""TH1.h""; ; using namespace RooFit;; ; RooWorkspace *getWorkspace(Int_t mode);; ; void rf903_numintcache(Int_t mode = 0); {; // Mode = 0 : Run plain fit (slow); // Mode = 1 : Generate workspace with pre-calculated integral and store it on file (prepare for accelerated running); // Mode = 2 : Run fit from previously stored workspace including cached integrals (fast, requires run in mode=1; // first); ; // C r e a t e , s a v e o r l o a d w o r k s p a c e w i t h p . d . f .; // -----------------------------------------------------------------------------------; ; // Make/load workspace, exit here in mode 1; RooWorkspace *w1 = getWorkspace(mode);; if (mode == 1) {; ; // Show workspace that was created; w1->Print();; ; // Show plot of cached integral values; RooDataHist *hhcache = (RooDataHist *)w1->expensiveObjectCache().getObj(1);; if (hhcache) {; ; new TCanvas(""rf903_numintcache"", ""rf903_numintcache"", 600, 600);; hhcache->createHistogram(""a"")->Draw();; ; } else {; Error(""rf903_numintcache"", ""Cached histogram is not existing in workspace"");; }; return;; }; ; // U s e p . d . f . f r o m w o r k s p a c e f o r g e n e r a t i o n a n d f i t t i n g; // -----------------------------------------------------------------------------------; ; // This is always slow (need to find maximum function value empirically in 3D space); std::unique_ptr<RooDataSet> d{w1->pdf(""model"")->generate({*w1->var(""x""), *w1->var(""y""), *w1->var(""z"")}, 1000)};; ; // This is slow in mode 0, but fast in mode 1; w1->pdf(""model"")->fitTo(*d, Verbose(true), Timer(true), PrintLevel(-1));; ; // Projection on x (always slow as 2D integral over Y,Z at fitted value ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf903__numintcache_8C.html:1177,load,load,1177,doc/master/rf903__numintcache_8C.html,https://root.cern,https://root.cern/doc/master/rf903__numintcache_8C.html,2,"['cache', 'load']","['cached', 'load']"
Performance,"caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; RooRealProxy_mu; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tag; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBCPGenDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBCPGenDecay.html:41446,cache,cache,41446,root/html532/RooBCPGenDecay.html,https://root.cern,https://root.cern/root/html532/RooBCPGenDecay.html,1,['cache'],['cache']
Performance,"cal integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveDDo we have a denominator term?; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooListProxy_intListMaster integrals representing numerator and denominator; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooGenProdProj.html:32880,cache,cache,32880,root/html530/RooGenProdProj.html,https://root.cern,https://root.cern/root/html530/RooGenProdProj.html,2,['cache'],['cache']
Performance,"cal integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; const ROOT::Math::IBaseFunctionMultiDim*funcFunctor; RooListProxyvarsArgument reference; Double_t*xArgument value array.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooFunctorBinding.html:32967,cache,cache,32967,root/html530/RooFunctorBinding.html,https://root.cern,https://root.cern/root/html530/RooFunctorBinding.html,1,['cache'],['cache']
Performance,"cal integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxyRooAbsHiddenReal::_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; RooRealProxy_valueHolder of the blind value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooUnblindPrecision.html:33968,cache,cache,33968,root/html532/RooUnblindPrecision.html,https://root.cern,https://root.cern/root/html532/RooUnblindPrecision.html,1,['cache'],['cache']
Performance,"calFrame Composite frame with vertical child layout; TGVerticalLayout Vertical layout manager; TGView View widget base class; TGViewFrame Frame containing the actual text; TGViewPort Viewport through which to look at a container frame; TGWidget Widget base class; TGWindow GUI Window base class; TGX11 Interface to X11; TGX11TTF Interface to X11 + TTF font handling; TGXYLayout X / Y - layout manager; TGXYLayoutHints Hits for the X / Y - layout manager; TGaxis Graphics axis; TGedEditor ROOT graphics editor; TGedFrame base editor's frame; TGedMarkerPopup marker select popup; TGedMarkerSelect Marker selection button; TGedNameFrame frame showing the selected object name; TGedPatternFrame pattern frame; TGedPatternPopup Color selector popup; TGedPatternSelect pattern selection check-button; TGedPatternSelector select pattern frame; TGedPopup popup window; TGedSelect selection check-button; TGenCollectionProxy ; TGenCollectionProxy::Method ; TGenCollectionProxy::Value ; TGenPhaseSpace Simple Phase Space Generator; TGenerator Event generator interface abstract baseclass; TGenericTable Generic array of C-structure (a'la STL vector); TGenericTable::iterator ; TGeoArb8 arbitrary trapezoid with 8 vertices; TGeoAtt class for visibility, activity and optimization attributes for volumes/nodes; TGeoBBox box primitive; TGeoBBoxEditor TGeoBBox editor; TGeoBatemanSol Solution for the Bateman equation; TGeoBoolNode a boolean node; TGeoBranchArray ; TGeoBuilder geometry builder singleton; TGeoCacheState class storing the cache state; TGeoChecker a simple geometry checker; TGeoCombiTrans rotation + translation; TGeoCombiTransEditor TGeoCombiTrans editor; TGeoCompositeShape boolean composite shape; TGeoCone conical tube class; TGeoConeEditor TGeoCone editor; TGeoConeSeg conical tube segment class ; TGeoConeSegEditor TGeoConeSeg editor; TGeoCtub cut tube segment class ; TGeoCtubEditor TGeoCtub editor; TGeoDecayChannel Decay channel for Elements; TGeoElemIter Iterator for radionuclide chains.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:87561,optimiz,optimization,87561,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,6,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"calIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidapplyWeightSquared(Bool_t flag); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsOptTestStatistic::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNLLVar.html:3355,cache,cacheUniqueSuffix,3355,root/html534/RooNLLVar.html,https://root.cern,https://root.cern/root/html534/RooNLLVar.html,1,['cache'],['cacheUniqueSuffix']
Performance,"calIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidapplyWeightSquared(Bool_t flag); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsOptTestStatistic::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNLLVar.html:3246,cache,cacheUniqueSuffix,3246,root/html532/RooNLLVar.html,https://root.cern,https://root.cern/root/html532/RooNLLVar.html,1,['cache'],['cacheUniqueSuffix']
Performance,"calNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,int>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction4Ref<VO,VI1,VI2,VI3,VI4> Streamer(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_int_.html:36886,cache,cache,36886,root/html602/RooCFunction4Binding_double_double_double_double_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_int_.html,4,['cache'],['cache']
Performance,"calShape(TObject* obj); Constructor with external object. TGLLogicalShape(const TBuffer3D& buffer); Constructor from TBuffer3D. ~TGLLogicalShape(); Destroy logical shape. void AddRef(TGLPhysicalShape* phys) const; Add reference to given physical shape. void SubRef(TGLPhysicalShape* phys) const; Remove reference to given physical shape, potentially deleting; *this* object when hitting zero ref-count (if fRefStrong is; true). void DestroyPhysicals(); Destroy all physicals attached to this logical. UInt_t UnrefFirstPhysical(); Unreference first physical in the list, returning its id and; making it fit for destruction somewhere else.; Returns 0 if there are no replicas attached. void UpdateBoundingBoxesOfPhysicals(); Update bounding-boxed of all dependent physicals. Bool_t SetDLCache(Bool_t cached); Modify capture of draws into display list cache kTRUE - capture,; kFALSE direct draw. Return kTRUE is state changed, kFALSE if not. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Returns kTRUE if draws should be display list cached; kFALSE otherwise. Here we check that:; a) fScene is set (Scene manages link to GL-context);; b) secondary selection is not in progress as different; render-path is usually taken in this case. Otherwise we return internal bool. Override this in sub-class if different behaviour is required. void DLCacheClear(); Clear all entries for all LODs for this drawable from the; display list cache but keeping the reserved ids from GL context. void DLCacheDrop(); Drop all entries for all LODs for this drawable from the display; list cache, WITHOUT returning the reserved ids to GL context. This is called by scene if it realized that the GL context was; destroyed. void DLCachePurge(); Purge all entries for all LODs for this drawable from the; display list cache, returning the reserved ids to GL context. If you override this function:; 1. call the base-class version from it;; 2. call it from the destructor of the derived class!. void PurgeDLRange(UInt_t bas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLLogicalShape.html:6117,cache,cached,6117,root/html602/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html602/TGLLogicalShape.html,2,['cache'],['cached']
Performance,"calar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:21350,perform,perform,21350,root/html528/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,3,['perform'],['perform']
Performance,"cale! size scale for points; TGLViewer::EPushActionTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; TGLViewerBase::SceneInfoList_tTGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds; Bool_tTGLViewer::fSmoothLines! smooth line edge rendering; Bool_tTGLViewer::fSmoothPoints! smooth point edge rendering; Bool_tTGLViewer::fStereo! use stereo rendering; Float_tTGLViewer::fStereoEyeOffsetFac!; Float_tTGLViewer::fStereoFrustumAsymFac!; Float_tTGLViewer::fStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectTGLViewer::fViewport! viewport - drawn area; TGLViewerBase::SceneInfoVec_tTGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetTGLViewer::fgDefaultColorSet! a shared, default color-set; static Bool_tTGLViewer::fgUseDefaultColorSetForNewViewers! name says it all. private:. Int_tfBorder; TGCompositeFrame*fFrame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLEmbeddedVie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLEmbeddedViewer.html:25205,cache,cache,25205,root/html602/TGLEmbeddedViewer.html,https://root.cern,https://root.cern/root/html602/TGLEmbeddedViewer.html,1,['cache'],['cache']
Performance,"cale! size scale for points; TGLViewer::EPushActionTGLViewer::fPushAction; TGLRedrawTimer*TGLViewer::fRedrawTimer! timer for triggering redraws; Bool_tTGLViewer::fReferenceOn! reference marker on?; TGLVertex3TGLViewer::fReferencePos! reference position; Bool_tTGLViewer::fResetCamerasOnNextUpdatereposition camera on next update; Bool_tTGLViewer::fResetCamerasOnUpdatereposition camera on each update; Bool_tTGLViewerBase::fResetSceneInfosOnRenderRequest rebuild of view-specific scene data.; TGLRnrCtx*TGLViewerBase::fRnrCtx; TGLViewerBase::SceneInfoList_tTGLViewerBase::fScenesRegistered scenes.; TGLSelectRecordTGLViewer::fSecSelRec! select record from last secondary select (should go to context); TGLSelectRecordTGLViewer::fSelRec! select record from last select (should go to context); TGLManipSet*TGLViewer::fSelectedPShapeRef!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTGLViewer::fSmartRefresh! cache logicals during scene rebuilds; Bool_tTGLViewer::fSmoothLines! smooth line edge rendering; Bool_tTGLViewer::fSmoothPoints! smooth point edge rendering; Bool_tTGLViewer::fStereo! use stereo rendering; Float_tTGLViewer::fStereoEyeOffsetFac!; Float_tTGLViewer::fStereoFrustumAsymFac!; Float_tTGLViewer::fStereoZeroParallax! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane; Short_tTGLViewerBase::fStyleViewer-style for rendering.; TGLRectTGLViewer::fViewport! viewport - drawn area; TGLViewerBase::SceneInfoVec_tTGLViewerBase::fVisScenesVisible scenes.; Float_tTGLViewerBase::fWFLineWOptional override of scene wire-frame line-width; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TGLColorSetTGLViewer::fgDefaultColorSet! a shared, default color-set; static Bool_tTGLViewer::fgUseDefaultColorSetForNewViewers! name says it all. private:. TGPopupMenu*fCameraMenu; Bool_tfDeleteMenuBar; TStringfDirName; TGPopupMenu*fFileMenu; TGPopupMenu*fFileSaveMenu; TGLFormat*fFormat; TGLSAFrame*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLSAViewer.html:26581,cache,cache,26581,root/html602/TGLSAViewer.html,https://root.cern,https://root.cern/root/html602/TGLSAViewer.html,1,['cache'],['cache']
Performance,"caling is automatic.; the largest dimension will be allocated a size of 20 centimeters. void Streamer(TBuffer& ); Stream a class object. void ToggleAutoExec(); Toggle pad auto execution of list of TExecs. void ToggleEventStatus(); Toggle event statusbar. void ToggleToolBar(); Toggle toolbar. void ToggleEditor(); Toggle editor. void ToggleToolTips(); Toggle tooltip display. Bool_t SupportAlpha(); Static function returning ""true"" if transparency is supported. void Update(); Update canvas pad buffers. void DisconnectWidget(); Used by friend class TCanvasImp. Bool_t IsGrayscale(); Check whether this canvas is to be drawn in grayscale mode. void SetGrayscale(Bool_t set = kTRUE); Set whether this canvas should be painted in grayscale, and re-paint; it if necessary. void CreatePainter(); Probably, TPadPainter must be placed in a separate ROOT module -; ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; gpad dir, so, in case of default painter, no *.so should be loaded,; no need in plugin managers.; May change in future. TVirtualPadPainter * GetCanvasPainter(); Access and (probably) creation of pad painter. void DeleteCanvasPainter(); assert on IsBatch() == false?. TCanvas(const TCanvas& canvas). TCanvas & operator=(const TCanvas& rhs). void Delete(Option_t* = """"); { MayNotUse(""Delete()""); }. void ForceUpdate(); { fCanvasImp->ForceUpdate(); }. const char * GetDISPLAY() const; {return fDISPLAY.Data();}. TContextMenu * GetContextMenu() const; {return fContextMenu;}. Int_t GetDoubleBuffer() const; {return fDoubleBuffer;}. Int_t GetEvent() const; { return fEvent; }. Int_t GetEventX() const; { return fEventX; }. Int_t GetEventY() const; { return fEventY; }. Color_t GetHighLightColor() const; { return fHighLightColor; }. TVirtualPad * GetPadSave() const; { return fPadSave; }. void ClearPadSave(); { fPadSave = 0; }. TObject * GetSelected() const; {return fSelected;}. TObject * GetClickSelected() const; {return fClickSelected;}. Int_t GetSelectedX() const; {retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCanvas.html:46971,load,loaded,46971,root/html602/TCanvas.html,https://root.cern,https://root.cern/root/html602/TCanvas.html,2,['load'],['loaded']
Performance,"call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:132009,cache,cache,132009,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,4,['cache'],['cache']
Performance,"callable that computes the new value of the defined column. . Returnsthe first node of the computation graph for which the new quantity is defined.; The signature of the callable passed as second argument should be T(unsigned int slot, const ROOT::RDF::RSampleInfo &id) where:; T is the type of the defined column; slot is a number in the range [0, nThreads) that is different for each processing thread. This can simplify the definition of thread-safe callables if you are interested in using parallel capabilities of RDataFrame.; id is an instance of a ROOT::RDF::RSampleInfo object which contains information about the sample which is being processed (see the class docs for more information). DefinePerSample() is useful to e.g. define a quantity that depends on which TTree in which TFile is being processed or to inject a callback into the event loop that is only called when the processing of a new sample starts rather than at every entry.; The callable will be invoked once per input TTree or once per multi-thread task, whichever is more often. Example usage:; ROOT::RDataFrame df{""mytree"", {""sample1.root"",""sample2.root""}};; df.DefinePerSample(""weightbysample"",; [](unsigned int slot, const ROOT::RDF::RSampleInfo &id); { return id.Contains(""sample1"") ? 1.0f : 2.0f; });; ROOT::RDF::RInterface::DefinePerSampleRInterface< Proxied, DS_t > DefinePerSample(std::string_view name, F expression)Define a new column that is updated when the input sample changes.Definition RInterface.hxx:735; ROOT::RDF::RSampleInfoThis type represents a sample identifier, to be used in conjunction with RDataFrame features such as ...Definition RSampleInfo.hxx:35. Definition at line 735 of file RInterface.hxx. ◆ DefinePerSample() [2/2]. template<typename Proxied , typename DataSource = void> . RInterface< Proxied, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::DefinePerSample ; (; std::string_view ; name, . std::string_view ; expression . ). inline . Define a new column that is updated when the inp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:54912,multi-thread,multi-thread,54912,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['multi-thread'],['multi-thread']
Performance,"callbacks); 76 - [Default column lists](\ref default-branches); 77 - [Special helper columns: `rdfentry_` and `rdfslot_`](\ref helper-cols); 78 - [Just-in-time compilation: column type inference and explicit declaration of column types](\ref jitting); 79 - [User-defined custom actions](\ref generic-actions); 80 - [Dataset joins with friend trees](\ref friends); 81 - [Reading data formats other than ROOT trees](\ref other-file-formats); 82 - [Computation graphs (storing and reusing sets of transformations)](\ref callgraphs); 83 - [Visualizing the computation graph](\ref representgraph); 84 - [Activating RDataFrame execution logs](\ref rdf-logging); 85 - [Creating an RDataFrame from a dataset specification file](\ref rdf-from-spec); 86 - [Adding a progress bar](\ref progressbar); 87- [Efficient analysis in Python](\ref python); 88- <a class=""el"" href=""classROOT_1_1RDataFrame.html#reference"" onclick=""javascript:toggleInherit('pub_methods_classROOT_1_1RDF_1_1RInterface')"">Class reference</a>; 89 ; 90\anchor cheatsheet; 91## Cheat sheet; 92These are the operations which can be performed with RDataFrame.; 93 ; 94### Transformations; 95Transformations are a way to manipulate the data.; 96 ; 97| **Transformation** | **Description** |; 98|------------------|--------------------|; 99| Alias() | Introduce an alias for a particular column name. |; 100| Define() | Create a new column in the dataset. Example usages include adding a column that contains the invariant mass of a particle, or a selection of elements of an array (e.g. only the `pt`s of ""good"" muons). |; 101| DefinePerSample() | Define a new column that is updated when the input sample changes, e.g. when switching tree being processed in a chain. |; 102| DefineSlot() | Same as Define(), but the user-defined function must take an extra `unsigned int slot` as its first parameter. `slot` will take a different value, `0` to `nThreads - 1`, for each thread of execution. This is meant as a helper in writing thread-safe Define",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:4586,perform,performed,4586,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['perform'],['performed']
Performance,"called tree1.C to tree4.C. The examples are:. tree1.C: a tree with several simple (integers and floating point) variables.; tree2.C: a tree built from a C structure (struct). This example uses the Geant3 C wrapper as an example of a FORTRAN common block ported to C with a C structure.; tree3.C: in this example, we will show how to extend a tree with a branch from another tree with the Friends feature. These trees have branches with variable length arrays. Each entry has a variable number of tracks, and each track has several variables.; tree4.C: a tree with a class (Event). The class Event is defined in $ROOTSYS/test. In this example we first encounter the impact of splitting a branch. Each script contains the main function, with the same name as the file (i.e. tree1), the function to write - tree1w, and the function to read - tree1r. If the script is not run in batch mode, it displays the tree in the browser and tree viewer. To study the example scripts, you can either execute the main script, or load the script and execute a specific function. For example:; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); 12.14 Example 1: A Tree with Simple Variables; This example shows how to write, view, and read a tree with several simple (integers and floating-point) variables.; 12.14.1 Writing the Tree; Below is the function that writes the tree (tree1w). First, the variables are defined (px, py, pz, random and ev). Then we add a branch for each of the variables to the tree, by calling the TTree::Branch method for each variable.; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:552043,load,load,552043,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['load']
Performance,"cally generated Streamer will not call ...Definition TClass.cxx:4908; TClass::GetStreamerTClassStreamer * GetStreamer() constReturn the Streamer Class allowing streaming (if any).Definition TClass.cxx:2981; TClass::GetBaseClassTClass * GetBaseClass(const char *classname)Return pointer to the base class ""classname"".Definition TClass.cxx:2722; TClass::GetDataMemberOffsetLongptr_t GetDataMemberOffset(const char *membername) constreturn offset for member name.Definition TClass.cxx:3544; TClass::MatchLegacyCheckSumBool_t MatchLegacyCheckSum(UInt_t checksum) constReturn true if the checksum passed as argument is one of the checksum value produced by the older che...Definition TClass.cxx:6561; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3837; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5771; TClass::CanIgnoreTObjectStreamerBool_t CanIgnoreTObjectStreamer()Definition TClass.h:393; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::GetListOfBasesTList * GetListOfBases()Return list containing the TBaseClass(es) of a class.Definition TClass.cxx:3703; TClass::GetStreamerInfosconst TObjArray * GetStreamerInfos() constDefinition TClass.h:492; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5979; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:600",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:252221,load,load,252221,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['load'],['load']
Performance,"cals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidDrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tTGLObject::SetModel(TObject* obj, const Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tSupportsSecondarySelect() const; TEveDigitSetGL(); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveDigitSetGL.html:1989,cache,cached,1989,root/html602/TEveDigitSetGL.html,https://root.cern,https://root.cern/root/html602/TEveDigitSetGL.html,2,['cache'],['cached']
Performance,"camera to defaults - reframe the world volume established in Setup(); in default state. Note: limits defined in Setup() are not adjusted. Bool_t Zoom(Int_t delta, Bool_t mod1, Bool_t mod2); Zoom the camera - 'adjust lens focal length, retaining camera position'.; Arguments are:. 'delta' - mouse viewport delta (pixels) - +ive zoom in, -ive zoom out; 'mod1' / 'mod2' - sensitivity modifiers - see TGLCamera::AdjustAndClampVal(). Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& box, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - used to adjust near/far clipping; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Configure the camera state.; fov - set directly field-of-view in degrees (default = 30);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. Bool_t IsPerspective() const; { return kTRUE; }. Double_t GetFOV() const; { return fFOV; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-03-13 19:25; This page has been automatically generated. For comments or suggestions regarding the documentation or",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLPerspectiveCamera.html:12765,cache,cached,12765,root/html534/TGLPerspectiveCamera.html,https://root.cern,https://root.cern/root/html534/TGLPerspectiveCamera.html,1,['cache'],['cached']
Performance,"camera to defaults - reframe the world volume established in Setup(); in default state. Note: limits defined in Setup() are not adjusted. Bool_t Zoom(Int_t delta, Bool_t mod1, Bool_t mod2); Zoom the camera - 'adjust lens focal length, retaining camera position'.; Arguments are:. 'delta' - mouse viewport delta (pixels) - +ive zoom in, -ive zoom out; 'mod1' / 'mod2' - sensitivity modifiers - see TGLCamera::AdjustAndClampVal(). Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& box, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - used to adjust near/far clipping; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Configure the camera state.; fov - set directly field-of-view in degrees (default = 30);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. Bool_t IsPerspective() const; { return kTRUE; }. Double_t GetFOV() const; { return fFOV; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPerspectiveCamera.h 31821 2009-12-10 18:22:44Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLPerspectiveCamera.html:8241,cache,cached,8241,root/html528/TGLPerspectiveCamera.html,https://root.cern,https://root.cern/root/html528/TGLPerspectiveCamera.html,1,['cache'],['cached']
Performance,"camera to defaults - reframe the world volume established in Setup(); in default state. Note: limits defined in Setup() are not adjusted. Bool_t Zoom(Int_t delta, Bool_t mod1, Bool_t mod2); Zoom the camera - 'adjust lens focal length, retaining camera position'.; Arguments are:. 'delta' - mouse viewport delta (pixels) - +ive zoom in, -ive zoom out; 'mod1' / 'mod2' - sensitivity modifiers - see TGLCamera::AdjustAndClampVal(). Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& box, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - used to adjust near/far clipping; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Configure the camera state.; fov - set directly field-of-view in degrees (default = 30);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. Bool_t IsPerspective() const; { return kTRUE; }. Double_t GetFOV() const; { return fFOV; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPerspectiveCamera.h 31821 2009-12-10 18:22:44Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLPerspectiveCamera.html:8241,cache,cached,8241,root/html530/TGLPerspectiveCamera.html,https://root.cern,https://root.cern/root/html530/TGLPerspectiveCamera.html,1,['cache'],['cached']
Performance,"camera to defaults - reframe the world volume established in Setup(); in default state. Note: limits defined in Setup() are not adjusted. Bool_t Zoom(Int_t delta, Bool_t mod1, Bool_t mod2); Zoom the camera - 'adjust lens focal length, retaining camera position'.; Arguments are:. 'delta' - mouse viewport delta (pixels) - +ive zoom in, -ive zoom out; 'mod1' / 'mod2' - sensitivity modifiers - see TGLCamera::AdjustAndClampVal(). Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& box, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - used to adjust near/far clipping; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Configure the camera state.; fov - set directly field-of-view in degrees (default = 30);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. Bool_t IsPerspective() const; { return kTRUE; }. Double_t GetFOV() const; { return fFOV; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLPerspectiveCamera.h 31821 2009-12-10 18:22:44Z matevz $ » Last generated: 2011-11-03 20:14; This page has been automatically generated.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLPerspectiveCamera.html:8241,cache,cached,8241,root/html532/TGLPerspectiveCamera.html,https://root.cern,https://root.cern/root/html532/TGLPerspectiveCamera.html,1,['cache'],['cached']
Performance,"camera to defaults - reframe the world volume established in Setup(); in default state. Note: limits defined in Setup() are not adjusted. Bool_t Zoom(Int_t delta, Bool_t mod1, Bool_t mod2); Zoom the camera - 'adjust lens focal length, retaining camera position'.; Arguments are:. 'delta' - mouse viewport delta (pixels) - +ive zoom in, -ive zoom out; 'mod1' / 'mod2' - sensitivity modifiers - see TGLCamera::AdjustAndClampVal(). Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& box, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - used to adjust near/far clipping; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t fov, Double_t dolly, Double_t[3] center, Double_t hRotate, Double_t vRotate); Configure the camera state.; fov - set directly field-of-view in degrees (default = 30);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. TGLPerspectiveCamera(). Bool_t IsPerspective() const; { return kTRUE; }. Double_t GetFOV() const; { return fFOV; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-02 15:53; This page has been automatically generated. For comments or suggestions rega",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLPerspectiveCamera.html:13550,cache,cached,13550,root/html604/TGLPerspectiveCamera.html,https://root.cern,https://root.cern/root/html604/TGLPerspectiveCamera.html,1,['cache'],['cached']
Performance,"camera to defaults - reframe the world volume established in Setup(); in default state. Note: limits defined in Setup() are not adjusted. Bool_t Zoom(Int_t delta, Bool_t mod1, Bool_t mod2); Zoom the camera - 'adjust lens focal length, retaining camera position'.; Arguments are:. 'delta' - mouse viewport delta (pixels) - +ive zoom in, -ive zoom out; 'mod1' / 'mod2' - sensitivity modifiers - see TGLCamera::AdjustAndClampVal(). Returns kTRUE is redraw required (camera change), kFALSE otherwise. Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2); Truck the camera - 'move camera parallel to film plane'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& box, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - used to adjust near/far clipping; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t fov, Double_t dolly, Double_t[3] center, Double_t hRotate, Double_t vRotate); Configure the camera state.; fov - set directly field-of-view in degrees (default = 30);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. TGLPerspectiveCamera(). Bool_t IsPerspective() const; { return kTRUE; }. Double_t GetFOV() const; { return fFOV; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:53; This page has been automatically generated. For comments or suggestions rega",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLPerspectiveCamera.html:13550,cache,cached,13550,root/html602/TGLPerspectiveCamera.html,https://root.cern,https://root.cern/root/html602/TGLPerspectiveCamera.html,1,['cache'],['cached']
Performance,"can be enabled via: ;  ; class  RField< T, typename std::enable_if< std::is_enum_v< T > >::type >;  ; class  RField< T, typename std::enable_if< std::is_integral_v< T > >::type >;  ; class  RField< TObject >;  TObject requires special handling of the fBits and fUniqueID members. More...;  ; class  RField< void >;  Template specializations for concrete C++ fundamental types. More...;  ; class  RFieldBase;  A field translates read and write calls from/to underlying columns to/from tree values. More...;  ; class  RFieldDescriptor;  Meta-data stored for every field of an ntuple. More...;  ; class  RFieldZero;  The container field for an ntuple model, which itself has no physical representation. More...;  ; class  RFile;  A ROOT file. More...;  ; class  RFilePtr;  Points to an object that stores or reads objects in ROOT's binary format. More...;  ; class  RFitPanel;  ; struct  RFitPanelModel;  Data structure for the fit panel. More...;  ; class  RFitResult;  ; class  RFrame;  Holds an area where drawing on user coordinate-system can be performed. More...;  ; class  RFunction;  ; class  RHist;  Histogram class for histograms with DIMENSIONS dimensions, where each bin count is stored by a value of type PRECISION. More...;  ; class  RHist1Drawable;  ; class  RHist1StatBox;  ; class  RHist2Drawable;  ; class  RHist2StatBox;  ; class  RHist3Drawable;  ; class  RHist3StatBox;  ; class  RHist< DIMENSIONS, PRECISION >;  RHist with no STAT parameter uses RHistStatContent by default. More...;  ; class  RHistBufferedFill;  Buffers calls to Fill(). More...;  ; class  RHistConcurrentFiller;  Buffers a thread's Fill calls and submits them to the RHistConcurrentFillManager. More...;  ; class  RHistConcurrentFillManager;  Manages the synchronization of calls to FillN(). More...;  ; class  RHistDataMomentUncert;  For now do as RH1: calculate first (xw) and second (x^2w) moment. More...;  ; class  RHistDisplayItem;  ; class  RHistDrawable;  ; class  RHistDrawableBase;  ; class  RHistStatB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Experimental.html:14065,perform,performed,14065,doc/master/namespaceROOT_1_1Experimental.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Experimental.html,1,['perform'],['performed']
Performance,"can be used to identify the running application. The initfunc argument can contain an array of function pointers (last element must be 0). These functions are executed at the end of the constructor. This way one can easily extend the ROOT system without adding permanent dependencies (e.g. the graphics system is initialized via such a function). ; Definition at line 639 of file TROOT.cxx. ◆ ~TROOT(). TROOT::~TROOT ; (; ). virtual . Clean up and free resources used by ROOT (files, network sockets, shared memory segments, etc.). ; Definition at line 867 of file TROOT.cxx. Member Function Documentation. ◆ AddClass(). void TROOT::AddClass ; (; TClass * ; cl). Add a class to the list and map of classes. ; This routine is deprecated, use TClass::AddClass directly. ; Definition at line 1025 of file TROOT.cxx. ◆ AddClassGenerator(). void TROOT::AddClassGenerator ; (; TClassGenerator * ; generator). Add a class generator. ; This generator will be called by TClass::GetClass in case its does not find a loaded rootcint dictionary to request the creation of a TClass object. ; Definition at line 1035 of file TROOT.cxx. ◆ AddExtraInterpreterArgs(). const std::vector< std::string > & TROOT::AddExtraInterpreterArgs ; (; const std::vector< std::string > & ; args). static . Provide command line arguments to the interpreter construction. ; These arguments are added to the existing flags (e.g. -DNDEBUG). They are evaluated once per process, at the time where TROOT (and thus TInterpreter) is constructed. Returns the new flags. ; Definition at line 2952 of file TROOT.cxx. ◆ Append(). void TROOT::Append ; (; TObject * ; obj, . Bool_t ; replace = kFALSE . ). overridevirtual . Append object to this directory. ; If replace is true: remove any existing objects with the same same (if the name is not """") ; Reimplemented from TDirectory.; Definition at line 1047 of file TROOT.cxx. ◆ Browse(). void TROOT::Browse ; (; TBrowser * ; b). overridevirtual . Add browsable objects to TBrowser. ; Reimplement",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:41710,load,loaded,41710,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,1,['load'],['loaded']
Performance,"can be used to identify the running application. The initfunc argument can contain an array of function pointers (last element must be 0). These functions are executed at the end of the constructor. This way one can easily extend the ROOT system without adding permanent dependencies (e.g. the graphics system is initialized via such a function). ; Definition at line 639 of file TROOT.cxx. ◆ ~TROOT(). TROOT::~TROOT ; (; ). virtual . Clean up and free resources used by ROOT (files, network sockets, shared memory segments, etc.). ; Definition at line 867 of file TROOT.cxx. Member Function Documentation. ◆ AddClass(). void TROOT::AddClass ; (; TClass * ; cl). Add a class to the list and map of classes. ; This routine is deprecated, use TClass::AddClass directly. ; Definition at line 1025 of file TROOT.cxx. ◆ AddClassGenerator(). void TROOT::AddClassGenerator ; (; TClassGenerator * ; generator). Add a class generator. ; This generator will be called by TClass::GetClass in case its does not find a loaded rootcint dictionary to request the creation of a TClass object. ; Definition at line 1035 of file TROOT.cxx. ◆ AddExtraInterpreterArgs(). const std::vector< std::string > & TROOT::AddExtraInterpreterArgs ; (; const std::vector< std::string > & ; args). static . Provide command line arguments to the interpreter construction. ; These arguments are added to the existing flags (e.g. -DNDEBUG). They are evaluated once per process, at the time where TROOT (and thus TInterpreter) is constructed. Returns the new flags. ; Definition at line 2956 of file TROOT.cxx. ◆ Append(). void TROOT::Append ; (; TObject * ; obj, . Bool_t ; replace = kFALSE . ). overridevirtual . Append object to this directory. ; If replace is true: remove any existing objects with the same same (if the name is not """") ; Reimplemented from TDirectory.; Definition at line 1047 of file TROOT.cxx. ◆ Browse(). void TROOT::Browse ; (; TBrowser * ; b). overridevirtual . Add browsable objects to TBrowser. ; Reimplement",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT.html:41679,load,loaded,41679,doc/master/classTROOT.html,https://root.cern,https://root.cern/doc/master/classTROOT.html,1,['load'],['loaded']
Performance,"can conclude that the; technique is itself an optimal method to reconstruct distributions of control variables. Different steps followed by TSPlot. A maximum Likelihood fit is performed to obtain the yields of the various species. ; The fit relies on discriminating variables  uncorrelated with a control variable :; the later is therefore totally absent from the fit. . The weights are calculated using Eq. (2) where the covariance matrix is taken from Minuit. Histograms of  are filled by weighting the events with . . Error bars per bin are given by Eq. (6). . The ; reproduce the true distributions of the species in the control variable , within the above defined statistical uncertainties. Illustrations. To illustrate the technique, one considers an example derived from the analysis where . have been first used (charmless B decays). One is dealing with a data; sample in which two species are present: the first is termed signal and; the second background. A maximum Likelihood fit is performed to obtain; the two yields and . The fit relies on two discriminating variables collectively denoted  which are chosen within three possible variables denoted , and .; The variable which is not incorporated in  is used as the control variable . The six distributions of the three variables are assumed to be the ones depicted in Fig. 1. Figure 1:; Distributions of the three discriminating variables available to perform the Likelihood fit: ; , , .; Among the three variables, two are used to perform the fit while one is; kept out of the fit to serve the purpose of a control variable. The; three distributions on the top (resp. bottom) of the figure correspond; to the signal (resp. background). The unit of the vertical axis is; chosen such that it indicates the number of entries per bin, if one; slices the histograms in 25 bins. A data sample being built through a Monte Carlo simulation based on the distributions shown in Fig. 1, one obtains the three distributions of Fig. 2. Whereas the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSPlot.html:5208,perform,performed,5208,root/html528/TSPlot.html,https://root.cern,https://root.cern/root/html528/TSPlot.html,4,['perform'],['performed']
Performance,"can; kFumili; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; voidTVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitterFumili(). TFitterFumili(Int_t maxpar). virtual ~TFitterFumili(). Double_t Chisquare(Int_t npar, Double_t* params) const; inherited interface. void CreateMinimizer(TFitterMinuit::EMini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFitterFumili.html:10762,cache,cache,10762,root/html528/TFitterFumili.html,https://root.cern,https://root.cern/root/html528/TFitterFumili.html,4,['cache'],['cache']
Performance,"can; kFumili; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; voidTVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. vector<double>fCovarcached covariance matrix (NxN); intfDebug; doublefEDMVal; doublefErrorDef; boolfGradient; doublefMinTolerance; ROOT::Minuit2::ModularFunctionMinimizer*fMinimizer; vector<ROOT::Minuit2::MinosError>fMinosErrors; ROOT::Minuit2::FCNBase*fMinuitFCN; ROOT::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFitterMinuit.html:10203,cache,cache,10203,root/html528/TFitterMinuit.html,https://root.cern,https://root.cern/root/html528/TFitterMinuit.html,4,['cache'],['cache']
Performance,"canMinMin Value for Contour; TGComboBox*fScanParParameter for Scan; TGNumberEntry*fScanPointsNumber of points for the graph; TGTab*fTabTab containing the available methods. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAdvancedGraphicsDialog(const TGWindow* p, const TGWindow* main); Creates the Advanced Graphics Dialog. void CreateContourFrame(); Create the frame that contains all the necessary information for; the Contour method. void CreateScanFrame(); Create the frame that contains all the necessary information for; the Scan method. void CreateConfFrame(); Create the frame that contains all the necessary information for; the Confidence Level method. void AddParameters(TGComboBox* ); Add all the parameters of the VirtualFitter into a comboBox; (helper method). void ConnectSlots(); Connect the slots (buttons mainly + specific methods). void DoChangedScanPar(Int_t selected); Changes the Min and Max default values of the scan method,; depending on the selected parameter. void DoDraw(); Calls the correspoding method, depending on the selected tab. void DrawContour(); Generates all necessary data for the Contour method from its; tab. Then it call Virtual Fitter to perform it. void DrawScan(); Generates all necessary data for the Scan method from its; tab. Then it call Virtual Fitter to perform it. void DrawConfidenceLevels(); Generates all necessary data for the Scan method from its; tab. Then it call Virtual Fitter to perform it. ~TAdvancedGraphicsDialog(); Cleanup dialog. TAdvancedGraphicsDialog(const TAdvancedGraphicsDialog& ). TAdvancedGraphicsDialog & operator=(const TAdvancedGraphicsDialog& ). » Author: David Gonzalez Maline 11/12/2008 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/fitpanel:$Id$ » Last generated: 2015-06-30 14:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TAdvancedGraphicsDialog.html:25435,perform,perform,25435,root/html602/TAdvancedGraphicsDialog.html,https://root.cern,https://root.cern/root/html602/TAdvancedGraphicsDialog.html,3,['perform'],['perform']
Performance,"canMinMin Value for Contour; TGComboBox*fScanParParameter for Scan; TGNumberEntry*fScanPointsNumber of points for the graph; TGTab*fTabTab containing the available methods. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAdvancedGraphicsDialog(const TGWindow* p, const TGWindow* main); Creates the Advanced Graphics Dialog. void CreateContourFrame(); Create the frame that contains all the necessary information for; the Contour method. void CreateScanFrame(); Create the frame that contains all the necessary information for; the Scan method. void CreateConfFrame(); Create the frame that contains all the necessary information for; the Confidence Level method. void AddParameters(TGComboBox* ); Add all the parameters of the VirtualFitter into a comboBox; (helper method). void ConnectSlots(); Connect the slots (buttons mainly + specific methods). void DoChangedScanPar(Int_t selected); Changes the Min and Max default values of the scan method,; depending on the selected parameter. void DoDraw(); Calls the correspoding method, depending on the selected tab. void DrawContour(); Generates all necessary data for the Contour method from its; tab. Then it call Virtual Fitter to perform it. void DrawScan(); Generates all necessary data for the Scan method from its; tab. Then it call Virtual Fitter to perform it. void DrawConfidenceLevels(); Generates all necessary data for the Scan method from its; tab. Then it call Virtual Fitter to perform it. ~TAdvancedGraphicsDialog(); Cleanup dialog. TAdvancedGraphicsDialog(const TAdvancedGraphicsDialog& ). TAdvancedGraphicsDialog & operator=(const TAdvancedGraphicsDialog& ). » Author: David Gonzalez Maline 11/12/2008 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/fitpanel:$Id$ » Last generated: 2015-09-08 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TAdvancedGraphicsDialog.html:25379,perform,perform,25379,root/html604/TAdvancedGraphicsDialog.html,https://root.cern,https://root.cern/root/html604/TAdvancedGraphicsDialog.html,3,['perform'],['perform']
Performance,"cans the memory list of all files. TObject * FindObjectAnyFile(const char* name) const; Scan the memory lists of all files for an object with name. const char * FindObjectClassName(const char* name) const; Returns class name of a ROOT object including CINT globals. const char * FindObjectPathName(const TObject* obj) const; Return path name of obj somewhere in the //root/... path.; The function returns the first occurence of the object in the list; of folders. The returned string points to a static char array in TROOT.; If this function is called in a loop or recursively, it is the; user's responsability to copy this string in his area. TClass * FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; return a TClass object corresponding to 'name' assuming it is an STL container.; In particular we looking for possible alternative name (default template; parameter, typedefs template arguments, typedefed name). TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class with name. Obsolete, use TClass::GetClass directly. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const char* name) const; Return pointer to function with name. TGlobal * GetGlobal(const char* name, Bool_t load = kFALSE) const; Return pointer to global variable by name. If load is true force; reading of all currently defined globals from CINT (more expensive). TGlobal * GetGlobal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TROOT.html:23092,load,load,23092,root/html530/TROOT.html,https://root.cern,https://root.cern/root/html530/TROOT.html,3,['load'],['load']
Performance,"case where the class derived from an STL collection, to spurrious autoparsing (to look at the base class of the collection!), we use a custom walk through the tree of base classes that checks their value of fCanSplit. This also has the side-effect of allowing the extension of the concept ‘base class that prevent its derived class from being split’ to any user class. This fixes ROOT-7972.; TTree. Do not automatically setup read cache during TTree::Fill(). This fixes ROOT-8031.; Fast Cloning We added a cache specifically for the fast option of the TTreeCloner to significantly reduce the run-time when fast-cloning remote files to address ROOT-5078. It can be controlled from the TTreeCloner, TTree::CopyEntries or hadd interfaces. The new cache is enabled by default, to update the size of the cache or disable it from TTreeCloner use: TTreeCloner::SetCacheSize. To do the same from TTree::CopyEntries add to the option string “cachesize=SIZE”. To update the size of the cache or disable it from hadd, use the command line option -cachesize SIZE. SIZE shouyld be given in number bytes and can be expressed in ‘human readable form’ (number followed by size unit like MB, MiB, GB or GiB, etc. or SIZE can be set zero to disable the cache. Histogram Libraries. Protect access to TROOT::GetListOfGlobalFunctions in TFormula. Math. Update MixMax random number generator for 32 bit architectures. TColor. Import TColor from master to make sure the high quality palettes are defined only ones. This was requested here. PyROOT. Fix case where c++ exception in a constructor were not propagated to python ROOT-7864; Fix case where PyROOT was unable to call copy constructor ROOT-7783; Fix handling of vector<enums> ROOT-7916; Fix the wrong return value when calling a c++ function returning short, or when retuning a char with a negative value ROOT-7872; Added a new configuration option (ROOT.PyConfig.DisableRootLogon) to disable processing of the rootlogon[.py|C] macro in addition to the -n option in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:26006,cache,cache,26006,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,2,['cache'],"['cache', 'cachesize']"
Performance,"cated in method. The value of the parameter 'method' determines in which; order the branches' baskets are written to the output file. When a TTree is filled the data is stored in the individual; branches' basket. Each basket is written individually to; the disk as soon as it is full. In consequence the baskets; of branches that contain 'large' data chunk are written to; the disk more often. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as in the original file; (i.e. the basket are sorted on their offset in the original; file; Usually this also means that the baskets are sorted; on the index/number of the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each; individual branches are stored contiguously. This tends to; optimize reading speed when reading a small number (1->5) of; branches, since all their baskets will be clustered together; instead of being spread across the file. However it might; decrease the performance when reading more branches (or the full; entry). When using SortBasketsByEntry the baskets with the lowest; starting entry are written first. (i.e. the baskets are; sorted on the index/number of the first entry they contain).; This means that on the file the baskets will be in the order; in which they will be needed when reading the whole tree; sequentially. Bool_t Exec(); Execute the cloning. ~TTreeCloner(); TTreeCloner destructor. void CloseOutWriteBaskets(); Before we can start adding new basket, we need to flush to; disk the partially filled baskets (the WriteBasket). UInt_t CollectBranches(TBranch* from, TBranch* to); Fill the array of branches, adding the branch 'from' and 'to',; and matching the sub-branches of the 'from' and 'to' branches.; Returns the total number of baskets in all the from branch and; it sub-branches. UInt_t CollectBranches(TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCloner.html:3644,optimiz,optimize,3644,root/html602/TTreeCloner.html,https://root.cern,https://root.cern/root/html602/TTreeCloner.html,2,['optimiz'],['optimize']
Performance,"cation.h""; 138#include ""TInterpreter.h""; 139#include ""TGuiFactory.h""; 140#include ""TMessageHandler.h""; 141#include ""TFolder.h""; 142#include ""TQObject.h""; 143#include ""TProcessUUID.h""; 144#include ""TPluginManager.h""; 145#include ""TVirtualMutex.h""; 146#include ""TListOfTypes.h""; 147#include ""TListOfDataMembers.h""; 148#include ""TListOfEnumsWithLock.h""; 149#include ""TListOfFunctions.h""; 150#include ""TListOfFunctionTemplates.h""; 151#include ""TFunctionTemplate.h""; 152#include ""ThreadLocalStorage.h""; 153#include ""TVirtualMapFile.h""; 154#include ""TVirtualRWMutex.h""; 155#include ""TVirtualX.h""; 156 ; 157#if defined(R__UNIX); 158#if defined(R__HAS_COCOA); 159#include ""TMacOSXSystem.h""; 160#include ""TUrl.h""; 161#else; 162#include ""TUnixSystem.h""; 163#endif; 164#elif defined(R__WIN32); 165#include ""TWinNTSystem.h""; 166#endif; 167 ; 168extern ""C"" void R__SetZipMode(int);; 169 ; 170static DestroyInterpreter_t *gDestroyInterpreter = nullptr;; 171static void *gInterpreterLib = nullptr;; 172 ; 173// Mutex for protection of concurrent gROOT access; 174TVirtualMutex* gROOTMutex = nullptr;; 175ROOT::TVirtualRWMutex *ROOT::gCoreMutex = nullptr;; 176 ; 177// For accessing TThread::Tsd indirectly.; 178void **(*gThreadTsd)(void*,Int_t) = nullptr;; 179 ; 180//-------- Names of next three routines are a small homage to CMZ --------------; 181////////////////////////////////////////////////////////////////////////////////; 182/// Return version id as an integer, i.e. ""2.22/04"" -> 22204.; 183 ; 184static Int_t IVERSQ(); 185{; 186 Int_t maj, min, cycle;; 187 sscanf(ROOT_RELEASE, ""%d.%d.%d"", &maj, &min, &cycle);; 188 return 10000*maj + 100*min + cycle;; 189}; 190 ; 191////////////////////////////////////////////////////////////////////////////////; 192/// Return built date as integer, i.e. ""Apr 28 2000"" -> 20000428.; 193 ; 194static Int_t IDATQQ(const char *date); 195{; 196 if (!date) {; 197 Error(""TSystem::IDATQQ"", ""nullptr date string, expected e.g. 'Dec 21 2022'"");; 198 return -1;; 199 }; 200 ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:5306,concurren,concurrent,5306,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['concurren'],['concurrent']
Performance,"cause input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useCdfBoundariesAre c.d.f boundary conditions used by the RooHistFuncs?; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to function being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedReal(const char* name, const char* title, RooAbsReal& _func); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedReal.html:33812,cache,cached,33812,root/html526/RooCachedReal.html,https://root.cern,https://root.cern/root/html526/RooCachedReal.html,5,['cache'],['cached']
Performance,"ccessful and the contents of buf were populated with the requested data. ; Definition at line 921 of file TTreeCache.cxx. ◆ Class(). static TClass * TTreeCache::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTreeCache::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTreeCache::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 175 of file TTreeCache.h. ◆ DeclFileName(). static const char * TTreeCache::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 175 of file TTreeCache.h. ◆ Disable(). virtual void TTreeCache::Disable ; (; ). inlinevirtual . Definition at line 136 of file TTreeCache.h. ◆ DropBranch() [1/2]. Int_t TTreeCache::DropBranch ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ; It works in exactly the same way as TTree::SetBranchStatus so you probably want to look over there for details about the use of bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 586 of file TTreeCache.cxx. ◆ DropBranch() [2/2]. Int_t TTreeCache::DropBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ; Returns:; 0 branch dropped or not in cache; -1 on error . Definition at line 541 of file TTreeCache.cxx. ◆ Enable(). virtual void TTreeCache::Enable ; (; ). inlinevirtual . Definition at line 137 of file TTreeCache.h. ◆ FillBuffer(). bool TTreeCache::FillBuff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:38125,cache,cache,38125,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cache']
Performance,ccording to pathname. ; Changes the path accordingly. The path is changed to point to the top node in case of failure. ; Definition at line 210 of file TGeoNavigator.cxx. ◆ CdDown() [1/2]. void TGeoNavigator::CdDown ; (; Int_t ; index). Make a daughter of current node current. ; Can be called only with a valid daughter index (no check). Updates cache accordingly. ; Definition at line 313 of file TGeoNavigator.cxx. ◆ CdDown() [2/2]. void TGeoNavigator::CdDown ; (; TGeoNode * ; node). Make a daughter of current node current. ; Can be called only with a valid daughter node (no check). Updates cache accordingly. ; Definition at line 333 of file TGeoNavigator.cxx. ◆ CdNext(). void TGeoNavigator::CdNext ; (; ). Do a cd to the node found next by FindNextBoundary. ; Definition at line 405 of file TGeoNavigator.cxx. ◆ CdNode(). void TGeoNavigator::CdNode ; (; Int_t ; nodeid). Change current path to point to the node having this id. ; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons) ; Definition at line 301 of file TGeoNavigator.cxx. ◆ CdTop(). void TGeoNavigator::CdTop ; (; ). Make top level node the current node. ; Updates the cache accordingly. Determine the overlapping state of current node. ; Definition at line 386 of file TGeoNavigator.cxx. ◆ CdUp(). void TGeoNavigator::CdUp ; (; ). Go one level up in geometry. ; Updates cache accordingly. Determine the overlapping state of current node. ; Definition at line 352 of file TGeoNavigator.cxx. ◆ CheckPath(). Bool_t TGeoNavigator::CheckPath ; (; const char * ; path); const. Check if a geometry path is valid without changing the state of the navigator. ; Definition at line 256 of file TGeoNavigator.cxx. ◆ Class(). static TClass * TGeoNavigator::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGeoNavigator::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGeoNavigator::Class_Version ; (; ). inlines,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNavigator.html:24326,perform,performance,24326,doc/master/classTGeoNavigator.html,https://root.cern,https://root.cern/doc/master/classTGeoNavigator.html,1,['perform'],['performance']
Performance,"ce ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:19419,cache,cache,19419,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,1,['cache'],['cache']
Performance,"ce ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCache.html:21285,cache,cache,21285,root/html530/TTreeCache.html,https://root.cern,https://root.cern/root/html530/TTreeCache.html,1,['cache'],['cache']
Performance,"ce ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the br",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:22127,cache,cache,22127,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,1,['cache'],['cache']
Performance,"ce Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Private Attributes |; List of all members ; TMVA::VariableImportance Class ReferenceTMVA. . Definition at line 44 of file VariableImportance.h. Public Member Functions;  VariableImportance (DataLoader *loader);  ;  ~VariableImportance ();  ; virtual void Evaluate ();  Virtual method to be implemented with your algorithm. ;  ; const VariableImportanceResult & GetResults () const;  ; VIType GetType ();  ; virtual TClass * IsA () const;  ; void SetType (VIType type);  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TMVA::Envelope;  ~Envelope ();  Default destructor. ;  ; virtual void BookMethod (TString methodname, TString methodtitle, TString options="""");  Method to book the machine learning method to perform the algorithm. ;  ; virtual void BookMethod (Types::EMVA method, TString methodtitle, TString options="""");  Method to book the machine learning method to perform the algorithm. ;  ; DataLoader * GetDataLoader ();  Method to get the pointer to TMVA::DataLoader object. ;  ; TFile * GetFile ();  Method to get the pointer to TFile object. ;  ; std::vector< OptionMap > & GetMethods ();  Method get the Booked methods in a option map object. ;  ; Bool_t HasMethod (TString methodname, TString methodtitle);  function to check methods booked ;  ; Bool_t IsModelPersistence ();  Method to see if the algorithm model is saved in xml or serialized files. ;  ; Bool_t IsSilentFile ();  Method to see if a file is available to save results. ;  ; Bool_t IsVerbose ();  Method to see if the algorithm should print extra information. ;  ; virtual void ParseOptions ();  Method to parse the internal option string. ;  ; void SetDataLoader (DataLo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1VariableImportance.html:1089,perform,perform,1089,doc/master/classTMVA_1_1VariableImportance.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1VariableImportance.html,1,['perform'],['perform']
Performance,"ce Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Member Functions |; Private Member Functions |; Private Attributes |; Friends |; List of all members ; ROOT::RGeomDescription Class Reference. . Definition at line 210 of file RGeomData.hxx. Classes; class  ShapeDescr;  . Public Member Functions;  RGeomDescription ()=default;  ; void AddSignalHandler (const void *handler, RGeomSignalFunc_t func);  Add signal handler. ;  ; void Build (TGeoManager *mgr, const std::string &volname="""");  Collect information about geometry hierarchy into flat list like it done in JSROOT ClonedNodes.createClones. ;  ; void Build (TGeoVolume *vol);  Collect information about geometry from single volume like it done in JSROOT ClonedNodes.createClones. ;  ; bool ChangeConfiguration (const std::string &json);  Change configuration by client Returns true if any parameter was really changed. ;  ; bool ChangeNodeVisibility (const std::vector< std::string > &path, bool on);  Change visibility for specified element Returns true if changes was performed. ;  ; bool ClearAllPhysVisibility ();  Reset all custom visibility settings. ;  ; void ClearCache ();  Clear cached data, need to be clear when connection broken. ;  ; void ClearDrawData ();  Clear raw data. Will be rebuild when next connection will be established. ;  ; bool ClearPhysNodeVisibility (const std::vector< std::string > &path);  Reset custom visibility of physical node by path. ;  ; int FindNodeId (const std::vector< int > &stack);  Returns nodeid for given stack array, returns -1 in case of failure. ;  ; std::string GetActiveItem () const;  ; std::vector< int > GetClickedItem () const;  ; std::string GetDrawJson () const;  ; std::string GetDrawOptions () const;  Returns draw options, used for JSROOT TGeoPainter. ;  ; std::vector< int > GetHighlightedItem () const;  ; int GetJsonComp () const;  Returns JSON compression level for data transfer. ;  ; int GetMaxVisFaces () const;  Returns maximal ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html:1145,perform,performed,1145,doc/v632/classROOT_1_1RGeomDescription.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html,2,['perform'],['performed']
Performance,"ce file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooBrentRootFinder. class RooBrentRootFinder: public RooAbsRootFinder. Implement the abstract 1-dimensional root finding interface using; the Brent-Decker method. This implementation is based on the one; in the GNU scientific library (v0.99).; . Function Members (Methods); public:. RooBrentRootFinder(const RooAbsFunc& function); RooBrentRootFinder(const RooBrentRootFinder&); virtual~RooBrentRootFinder(); static TClass*Class(); virtual Bool_tfindRoot(Double_t& result, Double_t xlo, Double_t xhi, Double_t value = 0) const; virtual TClass*IsA() const; voidsetTol(Double_t tol); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. enum { MaxIterations; };. protected:. const RooAbsFunc*RooAbsRootFinder::_functionPointer to input function; Double_t_tol; Bool_tRooAbsRootFinder::_validTrue if current state is valid. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooBrentRootFinder(const RooAbsFunc& function); Constructor taking function binding as input. Bool_t findRoot(Double_t& result, Double_t xlo, Double_t xhi, Double_t value = 0) const; Do the root finding using the Brent-Decker method. Returns a boolean status and; loads 'result' with our best guess at the root if true.; Prints a warning if the initial interval does not bracket a single; root or if the root is not found after a fixed number of iterations. RooBrentRootFinder(const RooAbsFunc& function). virtual ~RooBrentRootFinder(); { }. void setTol(Double_t tol); Set convergence tolerance parameter. » Last changed: Tue Mar 10 17:14:41 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBrentRootFinder.html:1541,load,loads,1541,root/html534/RooBrentRootFinder.html,https://root.cern,https://root.cern/root/html534/RooBrentRootFinder.html,1,['load'],['loads']
Performance,"ce for partial derivative. ;  ; double Derivative (double x) const;  Return the derivative of the function at a point x Use the private method DoDerivative. ;  ; void FdF (const double *x, double &f, double *df) const;  Compatibility method with multi-dimensional interface for Gradient and function evaluation. ;  ; void Gradient (const double *x, double *g) const;  Compatibility method with multi-dimensional interface for Gradient. ;  ; bool HasGradient () const override;  . interface inherited from IParamFunction; bool fLinear;  ; bool fPolynomial;  ; TF1 * fFunc;  ; double fX [1];  ; const double * Parameters () const override;  get the parameter values (return values cachen inside, those inside TF1 might be different) ;  ; void SetParameters (const double *p) override;  set parameter values need to call also SetParameters in TF1 in ace some other operations (re-normalizations) are needed ;  ; unsigned int NPar () const override;  return number of parameters ;  ; std::string ParameterName (unsigned int i) const override;  return parameter name (this is stored in TF1) ;  ; void ParameterGradient (double x, const double *par, double *grad) const override;  evaluate the derivative of the function with respect to the parameters ;  ; void FdF (double x, double &f, double &deriv) const override;  calculate function and derivative at same time (required by IGradient interface) ;  ; static void SetDerivPrecision (double eps);  precision value used for calculating the derivative step-size h = eps * |x|. ;  ; static double GetDerivPrecision ();  get precision value used for calculating the derivative step-size ;  ; double DoEvalPar (double x, const double *p) const override;  evaluate function passing coordinates x and vector of parameters ;  ; double DoEval (double x) const override;  evaluate function using the cached parameter values (of TF1) re-implement for better efficiency ;  ; double DoDerivative (double x) const override;  return the function derivatives w.r.t. x ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedTF1.html:4704,cache,cachen,4704,doc/master/classROOT_1_1Math_1_1WrappedTF1.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedTF1.html,1,['cache'],['cachen']
Performance,"ce matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. Exte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:53289,perform,performed,53289,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['perform'],['performed']
Performance,"ce matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are suppo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:54023,perform,performed,54023,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,6,['perform'],['performed']
Performance,"ce of char-like objects with the first element of the sequence at position zero.; This type is used throughout the ROOT code to avoid copying strings when a sub-string is needed and to extent interfaces that uses to take a const char* to take a std::string_view as thus be able to be directly directly passed a TString, a std::string or a std::string_view. Usage example:; // With SetName(std::string_view); std::string str; …; obj.SetName( str );; obj.SetName( {str.data()+pos, len} );; Meta library; Backward Incompatibilities; TIsAProxy’s constructor no longer take the optional and unused 2nd argument which was reserved for a ‘context’. This context was unused in TIsAProxy itself and was not accessible from derived classes.; Interpreter; The new interface TInterpreter::Declare(const char* code) will declare the code to the interpreter with all interpreter extensions disabled, i.e. as “proper” C++ code. No autoloading or synamic lookup will be performed.; A new R__LOAD_LIBRARY(libWhatever) will load libWhatever at parse time. This allows ROOT to resolve symbols from this library very early on. It is a work-around for the following code from ROOT 5:; // ROOT 5:; void func() {; gSystem->Load(""libEvent"");; Event* e = new Event;; }; Instead, write:; // ROOT 6:; R__LOAD_LIBRARY(libEvent); #include ""Event.h"". void func() {; Event* e = new Event;; }; TClass; Introduced new overload for calculating the TClass CheckSum:; UInt_t TClass::GetCheckSum(ECheckSum code, Bool_t &isvalid) const;; which indicates via the ‘isvalid’ boolean whether the checksum could be calculated correctly or not.; TROOT; Implemented new gROOT->GetTutorialsDir() static method to return the actual location of the tutorials directory. This is $ROOTSYS/tutorials when not configuring with –prefix or -Dgnuinstall for CMake.; TColor; Add an enum to access the palette by name.; Add new palettes with 255 colors. Names and colors’ definitions have been taken from here. Except for the kBird palette. These palettes ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:4448,load,load,4448,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['load'],['load']
Performance,"ce of the object in the list; 1469/// of folders. The returned string points to a static char array in TROOT.; 1470/// If this function is called in a loop or recursively, it is the; 1471/// user's responsibility to copy this string in their area.; 1472 ; 1473const char *TROOT::FindObjectPathName(const TObject *) const; 1474{; 1475 Error(""FindObjectPathName"",""Not yet implemented"");; 1476 return ""??"";; 1477}; 1478 ; 1479////////////////////////////////////////////////////////////////////////////////; 1480/// return a TClass object corresponding to 'name' assuming it is an STL container.; 1481/// In particular we looking for possible alternative name (default template; 1482/// parameter, typedefs template arguments, typedefed name).; 1483 ; 1484TClass *TROOT::FindSTLClass(const char *name, Bool_t load, Bool_t silent) const; 1485{; 1486 // Example of inputs are; 1487 // vector<int> (*); 1488 // vector<Int_t>; 1489 // vector<long long>; 1490 // vector<Long_64_t> (*); 1491 // vector<int, allocator<int> >; 1492 // vector<Int_t, allocator<int> >; 1493 //; 1494 // One of the possibly expensive operation is the resolving of the typedef; 1495 // which can provoke the parsing of the header files (and/or the loading; 1496 // of clang pcms information).; 1497 ; 1498 R__LOCKGUARD(gInterpreterMutex);; 1499 ; 1500 // Remove std::, allocator, typedef, add Long64_t, etc. in just one call.; 1501 std::string normalized;; 1502 TClassEdit::GetNormalizedName(normalized, name);; 1503 ; 1504 TClass *cl = nullptr;; 1505 if (normalized != name) cl = TClass::GetClass(normalized.c_str(),load,silent);; 1506 ; 1507 if (load && cl==nullptr) {; 1508 // Create an Emulated class for this container.; 1509 cl = gInterpreter->GenerateTClass(normalized.c_str(), kTRUE, silent);; 1510 }; 1511 ; 1512 return cl;; 1513}; 1514 ; 1515////////////////////////////////////////////////////////////////////////////////; 1516/// Return pointer to class with name. Obsolete, use TClass::GetClass directly; 1517 ; 1518TCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:57334,load,load,57334,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,4,['load'],"['load', 'loading']"
Performance,"ce reasons (instead of std::vector<Bool_t>) ;  ; std::vector< std::vector< Long64_t > > fClassEvents;  number of events of class 0,1,2,... in training[0] and testing[1] (+validation, trainingoriginal) ;  ; Long64_t fCurrentEventIdx;  ; UInt_t fCurrentTreeIdx;  ; const DataSetInfo * fdsi;  -> datasetinfo that created this dataset ;  ; std::vector< std::vector< Event * > > fEventCollection;  list of events for training/testing/... ;  ; Bool_t fHasNegativeEventWeights;  true if at least one signal or bkg event has negative weight ;  ; MsgLogger * fLogger;  ! message logger ;  ; std::vector< std::map< TString, Results * > > fResults;  ! [train/test/...][method-identifier] ;  ; std::vector< Char_t > fSampling;  random or importance sampling (not all events are taken) !! Bool_t are stored ( no std::vector<bool> taken for speed (performance) issues ) ;  ; std::vector< std::vector< std::pair< Float_t, Long64_t > > > fSamplingEventList;  weights and indices for sampling ;  ; std::vector< Int_t > fSamplingNEvents;  number of events which should be sampled ;  ; TRandom3 * fSamplingRandom;  -> random generator for sampling ;  ; std::vector< std::vector< std::pair< Float_t, Long64_t > > > fSamplingSelected;  selected events ;  ; std::vector< Float_t > fSamplingWeight;  weight change factor [weight is indicating if sampling is random (1.0) or importance (<1.0)] ;  ; Long64_t fTrainingBlockSize;  block size into which the training dataset is divided ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataSet.html:14576,perform,performance,14576,doc/master/classTMVA_1_1DataSet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataSet.html,1,['perform'],['performance']
Performance,"ce's only); and it allows conversions of void* to an CPPInstance and vice versa. ; Definition at line 44 of file TPython.h. Static Public Member Functions; static const TPyReturn Eval (const char *expr) R__DEPRECATED(6;  Evaluate a python expression (e.g. ;  ; static Bool_t Exec (const char *cmd, std::any *result=nullptr, std::string const &resultName=""_anyresult"");  Executes a Python command within the current Python environment. ;  ; static void ExecScript (const char *name, int argc=0, const char **argv=nullptr);  Execute a python stand-alone script, with argv CLI arguments. ;  ; static Bool_t Import (const char *name);  Import the named python module and create Cling equivalents for its classes and methods. ;  ; static void LoadMacro (const char *name);  Execute the give python script as if it were a macro (effectively an execfile in main), and create Cling equivalents for any newly available python classes. ;  . Static Private Member Functions; static Bool_t Initialize ();  Initialization method: setup the python interpreter and load the ROOT module. ;  . #include <TPython.h>; Member Function Documentation. ◆ Eval(). const TPyReturn TPython::Eval ; (; const char * ; expr). static . Evaluate a python expression (e.g. ; ""ROOT.TBrowser()"").; Caution: do not hold on to the return value: either store it in a builtin type (implicit casting will work), or in a pointer to a ROOT object (explicit casting to a void* is required).; Deprecated:Use TPython::Exec() with an std::any output parameter instead. ; Definition at line 465 of file TPython.cxx. ◆ Exec(). Bool_t TPython::Exec ; (; const char * ; cmd, . std::any * ; result = nullptr, . std::string const & ; resultName = ""_anyresult"" . ). static . Executes a Python command within the current Python environment. ; This function initializes the Python environment if it is not already initialized. It then executes the specified Python command string using the Python C API.; In the Python command, you can change the value of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPython.html:3965,load,load,3965,doc/master/classTPython.html,https://root.cern,https://root.cern/doc/master/classTPython.html,1,['load'],['load']
Performance,"ce, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); const RooCatType*RooAbsCategory::defineType(const char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMappedCategory.html:17692,optimiz,optimizeDirtyHook,17692,root/html532/RooMappedCategory.html,https://root.cern,https://root.cern/root/html532/RooMappedCategory.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"ce-time is used for physics vectors representing relativistic particles. These 3D and 4D vectors are different from vectors of the linear algebra package, which describe generic N-dimensional vectors. Similar functionality is currently provided by the CLHEP and packages and the ROOT Physics vector classes (See “Physics Vectors”). It also re-uses concepts and ideas from the CMS Common Vector package. In contrast to CLHEP or the ROOT physics libraries, GenVector provides class templates for modeling the vectors. The user can control how the vector is internally represented. This is expressed by a choice of coordinate system, which is supplied as a template parameter when the vector is constructed. Furthermore, each coordinate system is itself a template, so that the user can specify the underlying scalar type.; The GenVector classes do not inherit from TObject, therefore cannot be used as in the case of the physics vector classes in ROOT collections.; In addition, to optimize performances, no virtual destructors are provided. In the following paragraphs, the main characteristics of GenVector are described. A more detailed description of all the GenVector classes is available also at http://seal.cern.ch/documents/mathlib/GenVector.pdf; 13.12.1 Main Characteristics; 13.12.1.1 Optimal Runtime Performances; We try to minimize any overhead in the run-time performance. We have deliberately avoided the use of any virtual function and even virtual destructors in the classes. In addition, as much as possible functions are defined as inline. For this reason, we have chosen to use template classes to implement the GenVector concepts instead of abstract or base classes and virtual functions. It is then recommended to avoid using the GenVector classes polymorphically and developing classes inheriting from them.; 13.12.1.2 Points and Vector Concept; Mathematically vectors and points are two distinct concepts. They have different transformations, as vectors only rotate while points r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:719320,optimiz,optimize,719320,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,"['optimiz', 'perform']","['optimize', 'performances']"
Performance,"ce; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedPdf(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedPdf(const RooAbsCachedPdf& other, const char* name = 0); Copy constructor. ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. RooAbsCachedPdf(); Default constructor. Bool_t selfNormalized() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedPdf.html:47772,cache,cacheNameSuffix,47772,root/html602/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html,6,['cache'],"['cache', 'cacheNameSuffix']"
Performance,"ce; colors to distinguish contours (""SURF"" option at theta = 0). Combined; with the option ""CONT"" (or ""CONT0""), the option ""Z""; allows to display the color palette defined by gStyle->SetPalette(). Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *hcont4 = new TH2F(""hcont4"",""Option CONT4Z example "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcont4->Fill(px-1,5*py);; hcont4->Fill(2+0.5*px,2*py-10.,0.1);; }; gStyle->SetPalette(57);; hcont4->Draw(""CONT4Z"");; return c1;; }; The default number of contour levels is 20 equidistant levels and can be changed; with TH1::SetContour() or TStyle::SetNumberContours().; The LIST option; When option ""LIST"" is specified together with option; ""CONT"", the points used to draw the contours are saved in; TGraph objects:. h->Draw(""CONT LIST"");; gPad->Update();. The contour are saved in TGraph objects once the pad is painted.; Therefore to use this functionnality in a macro, gPad->Update(); should be performed after the histogram drawing. Once the list is; built, the contours are accessible in the following way:. TObjArray *contours = gROOT->GetListOfSpecials()->FindObject(""contours""); Int_t ncontours = contours->GetSize();; TList *list = (TList*)contours->At(i);. Where i is a contour number, and list contains a list of; TGraph objects.; For one given contour, more than one disjoint polyline may be generated.; The number of TGraphs per contour is given by:. list->GetSize();. To access the first graph in the list one should do:. TGraph *gr1 = (TGraph*)list->First();. The following example shows how to use this functionality. Picture; Source. // Getting Contours From TH2D; // Author: Josh de Bever; // CSI Medical Physics Group; // The University of Western Ontario; // London, Ontario, Canada; // Date: Oct. 22, 2004; // Modified by O.Couet (Nov. 26, 2004). Double_t SawTooth(Double_t x, Double_t WaveLen);. TCanvas *ContourList(){. const Double_t PI = TMath::Pi();. TC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THistPainter.html:41770,perform,performed,41770,root/html604/THistPainter.html,https://root.cern,https://root.cern/root/html604/THistPainter.html,1,['perform'],['performed']
Performance,"ced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. UShort_tfCurrent! to fasten Contains() in list mode; UShort_t*fIndices[fN]; Int_tfLastIndexQueried! to optimize GetEntry() in a loop; Int_tfLastIndexReturned! to optimize GetEntry() in a loop; Int_tfNsize of fIndices for I/O =fNPassed for list, fBlockSize for bits; Int_tfNPassednumber of entries in the entry list (if fPassing=0 - number of entries; Bool_tfPassing1 - stores entries that belong to the list; Int_tfType0 - bits, 1 - list. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEntryListBlock(); default c-tor. TEntryListBlock(const TEntryListBlock& eblock); copy c-tor. ~TEntryListBlock(); destructor. TEntryListBlock & operator=(const TEntryListBlock& rhs). Bool_t Enter(Int_t entry); If the block has already been optimized and the entries; are stored as a list and not as bits, trying to enter a new entry; will make the block switch to bits representation. Bool_t Remove(Int_t entry); Remove entry #entry; If the block has already been optimized and the entries; are stored as a list and not as bits, trying to remove a new entry; will make the block switch to bits representation. Int_t Contains(Int_t entry); true if the block contains entry #entry. Int_t Merge(TEntryListBlock* block); Merge with the other block; Returns the resulting number of entries in the block. Int_t GetNPassed(); Returns the number of entries, passing the selection.; In case, when the block stores entries that pass (fPassing=1) returns fNPassed. Int_t GetEntry(Int_t entry); Return entry #entry; See also Next(). Int_t Next(); Return the next non-zero entry; Faster than GetEntry() function. void Print(Option_t* option = """") const; Print the entries in this block. void PrintWithShift(Int_t shift) const; print the indices of this block + shift (used from TEntryList::Print(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEntryListBlock.html:15315,optimiz,optimized,15315,root/html534/TEntryListBlock.html,https://root.cern,https://root.cern/root/html534/TEntryListBlock.html,1,['optimiz'],['optimized']
Performance,"cementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quant",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:21488,perform,perform,21488,root/html526/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,4,['perform'],['perform']
Performance,"cementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:21275,perform,perform,21275,root/html526/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,4,['perform'],['perform']
Performance,"cene rebuilds, discarding those no longer of interest.; 9.13.4.10 Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer is not interested in a certain object due to limits/size then it will also not be interest in any of the contained branch of siblings. Both TBuffer3D::AddObject() methods have an addChildren return parameter. The viewer will complete this (if passed) indicating if children of the object just sent are worth sending.; 9.13.4.11 Recycling TBuffer3D; Once add TBuffer3D::AddObject() has been called, the contents are copied to the viewer’s internal data structures. You are free to destroy this TBuffer3D, or recycle it for the next object if suitable.; 9.13.4.12 Examples; For an example of a simple geometry, working in master reference frame examine the code under $ROOTSYS/g3d. For a more complex example, which works in both master and local frames, and uses logical/physical division of shape geometry and placement, examine the code under $ROOTSYS/geom - in particular TGeoShape hierarchy, and the painter object TGeoPainter (under geopainter) where the negotiation with the viewer is performed.; 10 Folders and Tasks; 10.1 Folders. A TFolder is a collection of objects visible and expandable in the ROOT object browser. Folders have a name and a title and are identified in the folder hierarchy by an “UNIX-like” naming convention. The base of all folders is //root. It is visible at the top of the left panel in the browser. The browser shows several folders under //root.; New folders can be added and removed to/from a folder.; 10.2 Why Use Folders?; One reason to use folders is to reduce class dependencies and improve modularity. Each set of data has a producer class and one or many consumer classes. When using folders, the producer class places a pointer to the data into a folder, and the consumer class retrieves a reference to the folder.; The consumer can access the objects in a folder by specifying the path name of the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:418332,perform,performed,418332,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['performed']
Performance,"ces in the respective languages: C++ is much harder to parse, but once parsed, it is much easier to optimize. Consequently, individual calls to ROOT are typically faster from PyROOT, whereas loops are typically slower.; When programming in Python, the modus operandi is to consider performance generally “good enough” on the outset, and when it turns out that, it is not good enough; the performance critical part is converted into C/C++ in an extension module. The school of thought where pre-mature optimization is the root of all evil should find this way of working very satisfying. In addition, if you look at their history, you will see that many of the standard Python modules have followed this path.; Your code should always make maximum use of ROOT facilities; such that most of the time is spending in compiled code. This goes even for very simple things: e.g. do not compute invariant masses in Python, use TLorentzVector instead. Moreover, before you start optimizing, make sure that you have run a profiler to find out where the bottlenecks are. Some performance, without cost in terms of programmer effort, may be gained by using psyco, see the next link: http://psyco.sourceforge.net, a Python just in time compiler (JIT). Note, however, that psyco is limited to Intel i386 CPUs. Since psyco optimizes Python, not PyROOT calls; it generally does not improve performance that much if most of your code consists of ROOT API calls. Mathematical computations in Python, on the other hand, benefit a lot.; Every call to a Python member function results in a lookup of that member function and an association of this method with 'self'. Furthermore, a temporary object is created during this process that is discarded after the method call. In inner loops, it may be worth your while (up to 30%), to short-cut this process by looking up and binding the method before the loop, and discarding it afterwards. Here is an example:; hpx = TH1F('hpx','px',100,-4,4); hpxFill = hpx.Fill # cache bou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1063866,optimiz,optimizing,1063866,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,"['bottleneck', 'optimiz']","['bottlenecks', 'optimizing']"
Performance,"ces the flowchart of TFormula::Compile ;  ; file  crown.C;   Draw crowns. ;  ; file  diamond.C;   Draw a diamond. ;  ; file  earth.C;   This tutorial illustrates the special contour options. ;  ; file  ellipse.C;   Draw ellipses. ;  ; file  eval.C;   This macro produces the flowchart of TFormula::Eval. ;  ; file  event.C;   Illustrate some basic primitives. ;  ; file  feynman.C;   Draw Feynman diagrams. ;  ; file  first.C;   Show some basic primitives. ;  ; file  formula1.C;   Display interpreted functions. ;  ; file  framework.C;   An example with basic graphics illustrating the Object Oriented User Interface of ROOT. ;  ; file  gaxis.C;   Simple example illustrating how to draw TGaxis objects in various formats. ;  ; file  gaxis2.C;   Example illustrating how to draw TGaxis with labels defined by a function. ;  ; file  gaxis3.C;   Example illustrating how to modify individual labels of a TGaxis. ;  ; file  graph_edit_playback.C;  This macro plays a recorded ROOT session showing how to perform various interactive graphical editing operations. ;  ; file  gtime.C;  Example of a graph of data moving in time. ;  ; file  inside.C;   Test the IsInside methods of various graphics primitives. ;  ; file  latex.C;   This macro draws 5 Latex-style formula in a canvas and prints the canvas as a Postscript file. ;  ; file  latex2.C;   This macro draws 4 Latex-style formula in a canvas and prints the canvas as a Postscript file. ;  ; file  latex3.C;   Example illustrating a TPaveText with Latex inside. ;  ; file  latex4.C;   Draw the Greek letters as a table and save the result as GIF, PS, PDF and SVG files. ;  ; file  latex5.C;   This draws the Mathematical Symbols letters as a table and save the result as GIF, PS, PDF and SVG files. ;  ; file  mandelbrot.C;   Using TExec to handle keyboard events and TComplex to draw the Mandelbrot set. ;  ; file  markerwarning.C;   This script illustrates the danger of using asymmetric symbols. ;  ; file  mass_spectrum.C;   This macro makes us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__graphics.html:1878,perform,perform,1878,doc/master/group__tutorial__graphics.html,https://root.cern,https://root.cern/doc/master/group__tutorial__graphics.html,1,['perform'],['perform']
Performance,"cessLine().; The possible error codes are defined by TInterpreter::EErrorCode. void ReadGitInfo(); Read Git commit information and branch name from the; etc/gitinfo.txt file. Bool_t ReadingObject() const; Deprecated (will be removed in next release). void SetReadingObject(Bool_t flag = kTRUE). const char * GetGitDate(); Return date/time make was run. void RefreshBrowsers(); Refresh all browsers. Call this method when some command line; command or script has changed the browser contents. Not needed; for objects that have the kMustCleanup bit set. Most useful to; update browsers that show the file system or other objects external; to the running ROOT session. void RemoveClass(TClass* ); Remove a class from the list and map of classes.; This routine is deprecated, use TClass::RemoveClass directly. void Reset(Option_t* option = """"); Delete all global interpreter objects created since the last call to Reset. If option=""a"" is set reset to startup context (i.e. unload also; all loaded files, classes, structs, typedefs, etc.). This function is typically used at the beginning (or end) of an unnamed macro; to clean the environment. IMPORTANT WARNING:; Do not use this call from within any function (neither compiled nor; interpreted. This should only be used from a unnamed macro; (which starts with a { (curly braces) ). For example, using TROOT::Reset; from within an interpreted function will lead to the unloading of the; dictionary and source file, including the one defining the function being; executed. void SaveContext(); Save the current interpreter context. void SetCutClassName(const char* name = ""TCutG""); Set the default graphical cut class name for the graphics editor; By default the graphics editor creates an instance of a class TCutG.; This function may be called to specify a different class that MUST; derive from TCutG. void SetEditorMode(const char* mode = """"); Set editor mode. void SetStyle(const char* stylename = ""Default""); Change current style to style with name ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TROOT.html:32118,load,loaded,32118,root/html534/TROOT.html,https://root.cern,https://root.cern/root/html534/TROOT.html,1,['load'],['loaded']
Performance,"ch a node) these regions are invisible since the current track has not yet reached its mother. This is not the case when going the other way since the track has first to exit the extruding node before checking the mother. In other words, an extrusion behavior is dependent on the track parameters, which is a highly undesirable effect.; B) We will call ""overlaps"" only the regions in space contained by more than one node inside the same container. The owner of such regions cannot be determined based on hierarchical considerations; therefore they will be considered as belonging to the node from which the current track is coming from.; When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker. Overlap checking; This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; TGeoManager::C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:100845,perform,performed,100845,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['perform'],['performed']
Performance,"ch an object will be created (e.g. TRFIOFile), the library to be loaded (in short libRFIO.so to RFIO), and the constructor to be called (e.g. “TRFIOFile()”). This can be specified in the .rootrc which already contains many plugin definitions, or by calls to gROOT->GetPluginManager()->AddHandler().; 1.6.2.4 Library AutoLoading; When using a class in Cling, e.g. in an interpreted source file, ROOT will automatically load the library that defines this class. On start-up, ROOT parses all files ending on .rootmap rootmap that are in one of the $LD_LIBRARY_PATH (or $DYLD_LIBRARY_PATH for MacOS, or $PATH for Windows). They contain class names and the library names that the class depends on. After reading them, ROOT knows which classes are available, and which libraries to load for them.; When TSystem::Load(""ALib"") is called, ROOT uses this information to determine which libraries libALib.so depends on. It will load these libraries first. Otherwise, loading the requested library could cause a system (dynamic loader) error due to unresolved symbols.; 1.6.3 $ROOTSYS/tutorials; tutorials The tutorials directory contains many example example scripts. They assume some basic knowledge of ROOT, and for the new user we recommend reading the chapters: “Histograms” and “Input/Output” before trying the examples. The more experienced user can jump to chapter “The Tutorials and Tests” to find more explicit and specific information about how to build and run the examples.; The $ROOTSYS/tutorials/ directory include the following sub-directories:; fft: Fast Fourier Transform with the fftw package fit: Several examples illustrating minimization/fitting foam: Random generator in multidimensional space geom: Examples of use of the geometry package (TGeo classes) gl: Visualisation with OpenGL graphics: Basic graphics graphs: Use of TGraph, TGraphErrors, etc. gui: Scripts to create Graphical User Interface hist: Histogramming image: Image Processing io: Input/Output math: Maths and Statistics f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:24731,load,loading,24731,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],"['loader', 'loading']"
Performance,"ch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,bool>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCFunction4Binding_double_double_double_double_bool_.html:33419,cache,cache,33419,root/html530/RooCFunction4Binding_double_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html530/RooCFunction4Binding_double_double_double_double_bool_.html,1,['cache'],['cache']
Performance,"ch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df105_WBosonAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b: ROOT.gROOT.SetBatch(True); if args.t: ROOT.EnableImplicitMT(); ; if not args.full_dataset: lumi_scale = 0.001 # The preskimmed dataset contains only 0.01 fb^-1; else: lumi_scale = args.lumi_scale; lumi = 10064.0; print('Run on data corresponding to {:.2f} fb^-1 ...'.format(lumi * lumi_scale / 1000.0)); ; if args.full_dataset: dataset_path = ""root://eospublic.cern.ch//eos/opendata/atlas/OutreachDatasets/2020-01-22""; else: dataset_path = ""root://eospublic.cern.ch//eos/root-eos/reduced_atlas_opendata/w""; ; # Create a ROOT dataframe for each dataset; # Note that we load the filenames from the external json file placed in the same folder than this script.; files = json.load(open(os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe/df105_WBosonAnalysis.json""))); processes = files.keys(); df = {}; xsecs = {}; sumws = {}; samples = []; for p in processes:; for d in files[p]:; # Construct the dataframes; folder = d[0] # Folder name; sample = d[1] # Sample name; xsecs[sample] = d[2] # Cross-section; sumws[sample] = d[3] # Sum of weights; num_events = d[4] # Number of events; samples.append(sample); df[sample] = ROOT.RDataFrame(""mini"", ""{}/1lep/{}/{}.1lep.root"".format(dataset_path, folder, sample)); ; # Scale down the datasets if requested; if args.full_dataset and lumi_scale < 1.0:; df[sample] = df[sample].Range(int(num_events * lumi_scale)); ; # Select events for the analysis; ; # Just-in-time compile custom helper function performing complex computations; ROOT.gInterpreter.Declare(""""""; bool GoodElectronOrMuon(int type, float pt, float eta, float phi, float e, float trackd0pv, float tracksigd0pv, float z0); {; ROOT::Math::PtEtaPhiEVector p(pt / 1000.0, eta, ph",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:2652,load,load,2652,doc/master/df105__WBosonAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html,1,['load'],['load']
Performance,"ch(bname,subbranches);; 1171}; 1172 ; 1173////////////////////////////////////////////////////////////////////////////////; 1174/// Remove the branch b from the Tree cache.; 1175/// if subbranches is true all the branches of the subbranches are; 1176/// also removed from the cache.; 1177///; 1178/// Returns:; 1179/// - 0 branch dropped or not in cache; 1180/// - -1 on error; 1181 ; 1182Int_t TTree::DropBranchFromCache(TBranch *b, bool subbranches); 1183{; 1184 if (!GetTree()) {; 1185 if (LoadTree(0)<0) {; 1186 Error(""DropBranchFromCache"",""Could not load a tree"");; 1187 return -1;; 1188 }; 1189 }; 1190 if (GetTree()) {; 1191 if (GetTree() != this) {; 1192 Int_t res = GetTree()->DropBranchFromCache(b, subbranches);; 1193 if (res<0) {; 1194 Error(""DropBranchFromCache"", ""Error dropping branch"");; 1195 }; 1196 return res;; 1197 }; 1198 } else {; 1199 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1200 return -1;; 1201 }; 1202 ; 1203 TFile *f = GetCurrentFile();; 1204 if (!f) {; 1205 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1206 return -1;; 1207 }; 1208 TTreeCache *tc = GetReadCache(f,true);; 1209 if (!tc) {; 1210 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1211 return -1;; 1212 }; 1213 return tc->DropBranch(b,subbranches);; 1214}; 1215 ; 1216////////////////////////////////////////////////////////////////////////////////; 1217/// Add a cloned tree to our list of trees to be notified whenever we change; 1218/// our branch addresses or when we are deleted.; 1219 ; 1220void TTree::AddClone(TTree* clone); 1221{; 1222 if (!fClones) {; 1223 fClones = new TList();; 1224 fClones->SetOwner(false);; 1225 // So that the clones are automatically removed from the list when; 1226 // they are deleted.; 1227 {; 1228 R__LOCKGUARD(gROOTMutex);; 1229 gROOT->GetListOfCleanups()->Add(fClones);; 1230 }; 1231 }; 1232 if (!fClones->FindObject(clone)) {; 1233 fClone",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:42459,cache,cache,42459,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,chAddressStatus { kMissingBranch; kInternalError; kMissingCompiledCollectionProxy; kMismatch; kClassMismatch; kMatch; kMatchConversion; kMatchConversionCollection; kMakeClass; kVoidPtr; kNoCheck; };; enum TTree::[unnamed] { kForceRead; kCircular; kSplitCollectionOfPointers; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Double_t*fArgs! [fNvar] Array of variables; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave bytes produced; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList*TTree::fEventList! P,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNtupleD.html:22579,cache,cache,22579,root/html534/TNtupleD.html,https://root.cern,https://root.cern/root/html534/TNtupleD.html,2,['cache'],['cache']
Performance,"chNames(TTree &t)Get all the top-level branches names, including the ones of the friend trees.Definition InternalTreeUtils.cxx:74; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOT::RDF::RNodeRInterface<::ROOT::Detail::RDF::RNodeBase, void > RNodeDefinition InterfaceUtils.hxx:57; ROOT::RDF::ColumnNames_tstd::vector< std::string > ColumnNames_tDefinition RInterfaceBase.hxx:35; ROOT::TypeTraitsROOT type_traits extensions.Definition TypeTraits.hxx:21; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::DisableImplicitMTvoid DisableImplicitMT()Disables the implicit multi-threading in ROOT (see EnableImplicitMT).Definition TROOT.cxx:556; graphDefinition graph.py:1; ROOT::Detail::RDF::RInferredTypeDefinition Utils.hxx:59; ROOT::Internal::RDF::RemoveFirstParameterIftype is TypeList if MustRemove is false, otherwise it is a TypeList with the first type removedDefinition Utils.hxx:141; ROOT::Internal::RDF::RemoveFirstTwoParametersIfDefinition Utils.hxx:154; ROOT::RDF::RSnapshotOptionsA collection of options to steer the creation of the dataset on file.Definition RSnapshotOptions.hxx:22; ROOT::RDF::RSnapshotOptions::fLazybool fLazyDo not start the event loop when Snapshot is called.Definition RSnapshotOptions.hxx:45; ROOT::RDF::TH1DModelA struct which stores the parameters of a TH1D.Definition HistoModels.hxx:30; ROOT::RDF::TH1DModel::GetHistogramstd::shared_ptr<::TH1D > GetHistogram() constDefinition RDFHistoModels.cxx:103; ROOT::RDF::TH2DModelA struct which stores the parameters of a TH2D.Definition HistoModels.hxx:48; ROOT::RDF::TH2DM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:225279,multi-thread,multi-threading,225279,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['multi-thread'],['multi-threading']
Performance,"chStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8660 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 609 of fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:207857,cache,cache,207857,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['cache'],['cache']
Performance,"changed by the user.; Finding If Current State Is Changed For a New Point; One can find fast if a point different from the current one has or not the same location inside the geometry tree. To do that, the new point should not be introduced by using TGeoManager::SetCurrentPoint() method, but rather by calling the specific method:; Bool_t TGeoManager::IsSameLocation(Double_t x,Double_t y,; Double_t z,Bool_t change=kFALSE);; TGeoManager::IsSameLocationBool_t IsSameLocation() constDefinition TGeoManager.h:393; In the prototype above, x, y and z are the coordinates of the new point. The modeller will check whether the current volume still contains the new point or its location has changed in the geometry hierarchy. If the new location is different, two actions are possible according to the value of change:. change = kFALSE (default) - the modeller does not change the current state but just inform the caller about this change.; change = kTRUE - the modeller will actually perform a new ‘‘Where am I?’ `search after finding out that the location has changed. The current state will be actualized accordingly. Note that even when performing a normal search on the current state after changing the current point coordinates (e.g. gGeoManager->FindNode(newX,newY,newZ)), users can always query if the previous state has changed by using a method having the same name but without parameters:; Bool_t TGeoManager::IsSameLocation();; Finding the Distance to the Next Boundary; All tracking engines need to compare the currently proposed physical step with the maximum allowed distance in the current material. The modeller provides this information by computing the distance to the first boundary starting from the current point along a straight line. The starting point and direction for this procedure are the ones corresponding to the current state. The boundary search is initialized inside the current volume and the crossed boundary can belong either to the current node or to one of its daugh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:81764,perform,perform,81764,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['perform'],['perform']
Performance,"char *fmt)Calculate scan fields.Definition TGraphErrors.cxx:449; TGraphErrors::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraphErrors.Definition TGraphErrors.cxx:817; TGraphErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphErrors.cxx:598; TGraphErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t ex=0., Double_t ey=0.)Add a point with errorbars to the graph.Definition TGraphErrors.cxx:377; TGraphErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraphErrors.h:29; TGraphErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphErrors.cxx:711; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex and ey values for point pointed by the mouse.Definition TGraphErrors.cxx:769; TGraphErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with errors.Definition TGraphErrors.cxx:573; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphErrors.cxx:856; TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply function to all the data points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:671; TGraphErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:659; TGraphErrors::operator=TGraphErrors & operator=(const TGraphErrors &gr)TGraphErrors assignment operator.Definition TGraphErrors.cxx:184;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:34340,perform,perform,34340,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['perform'],['perform']
Performance,"char *function, const char *params,; 1686 Bool_t load); 1687{; 1688 if (!params) {; 1689 R__LOCKGUARD(gROOTMutex);; 1690 return (TFunction *)GetListOfGlobalFunctions(load)->FindObject(function);; 1691 } else {; 1692 if (!fInterpreter); 1693 Fatal(""GetGlobalFunction"", ""fInterpreter not initialized"");; 1694 ; 1695 R__LOCKGUARD(gROOTMutex);; 1696 TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithValues(nullptr,; 1697 function, params,; 1698 false);; 1699 ; 1700 if (!decl) return nullptr;; 1701 ; 1702 TFunction *f = GetGlobalFunctions()->Get(decl);; 1703 if (f) return f;; 1704 ; 1705 Error(""GetGlobalFunction"",; 1706 ""\nDid not find matching TFunction <%s> with \""%s\""."",; 1707 function,params);; 1708 return nullptr;; 1709 }; 1710}; 1711 ; 1712////////////////////////////////////////////////////////////////////////////////; 1713/// Return pointer to global function by name. If proto != 0; 1714/// it will also resolve overloading. If load is true force reading; 1715/// of all currently defined global functions from CINT (more expensive).; 1716/// The proto string must be of the form: ""int, char*, float"".; 1717 ; 1718TFunction *TROOT::GetGlobalFunctionWithPrototype(const char *function,; 1719 const char *proto, Bool_t load); 1720{; 1721 if (!proto) {; 1722 R__LOCKGUARD(gROOTMutex);; 1723 return (TFunction *)GetListOfGlobalFunctions(load)->FindObject(function);; 1724 } else {; 1725 if (!fInterpreter); 1726 Fatal(""GetGlobalFunctionWithPrototype"", ""fInterpreter not initialized"");; 1727 ; 1728 R__LOCKGUARD(gROOTMutex);; 1729 TInterpreter::DeclId_t decl = gInterpreter->GetFunctionWithPrototype(nullptr,; 1730 function, proto);; 1731 ; 1732 if (!decl) return nullptr;; 1733 ; 1734 TFunction *f = GetGlobalFunctions()->Get(decl);; 1735 if (f) return f;; 1736 ; 1737 Error(""GetGlobalFunctionWithPrototype"",; 1738 ""\nDid not find matching TFunction <%s> with \""%s\""."",; 1739 function,proto);; 1740 return nullptr;; 1741 }; 1742}; 1743 ; 1744/////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:66030,load,load,66030,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['load'],['load']
Performance,"char *namecycle, char *name, Short_t &cycle, const size_t namesize=0);  Decode a namecycle ""aap;2"" into name ""aap"" and cycle ""2"". ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; virtual Long64_t DirCreateEntry (TDirectory *);  ; virtual Int_t DirReadKeys (TDirectory *);  ; virtual void DirWriteHeader (TDirectory *);  ; virtual void DirWriteKeys (TDirectory *);  ; Bool_t FlushWriteCache ();  Flush the write cache if active. ;  ; virtual EAsyncOpenStatus GetAsyncOpenStatus ();  ; virtual InfoListRet GetStreamerInfoListImpl (bool lookupSICache);  See documentation of GetStreamerInfoList for more details. ;  ; virtual void Init (Bool_t create);  Initialize a TFile object. ;  ; Int_t MakeProjectParMake (const char *packname, const char *filename);  Create makefile at 'filemake' for PAR package 'pack'. ;  ; Int_t MakeProjectParProofInf (const char *packname, const char *proofinfdir);  Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'. ;  ; Int_t ReadBufferViaCache (char *buf, Int_t len);  Read buffer via cache. ;  ; virtual Int_t SysClose (Int_t fd);  Interface to system close. All arguments like in POSIX close(). ;  ; virtual Int_t SysOpen (const char *pathname, Int_t flags, UInt_t mode);  Interface to system open. All arguments like in POSIX open(). ;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:35581,cache,cache,35581,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['cache'],['cache']
Performance,"char *ptr = (char*)start;; 1641 UInt_t n = (((char*)end)-((char*)start))/((TVectorLoopConfig*)loopconf)->fIncrement;; 1642 info->ReadBufferSkip(b,&ptr,config->fCompInfo,config->fCompInfo->fType+TStreamerInfo::kSkip,aElement,n,0);; 1643 } else {; 1644 TVectorLoopConfig cached_config( nullptr, cached->fClass->Size(), /* read */ kTRUE );; 1645 void *cached_start = (*cached)[0];; 1646 void *cached_end = ((char*)cached_start) + cached->fSize * cached_config.fIncrement;; 1647 config->fAction(b,cached_start,cached_end,&cached_config);; 1648 }; 1649 // Idea: Factor out this 'if' to a UseCacheRepeat function; 1650 if (config->fNeedRepeat) {; 1651 b.SetBufferOffset(bufpos);; 1652 }; 1653 return 0;; 1654 }; 1655 ; 1656 INLINE_TEMPLATE_ARGS Int_t UseCacheGenericCollection(TBuffer &b, void *, const void *, const TLoopConfiguration *loopconfig, const TConfiguration *conf); 1657 {; 1658 TConfigurationUseCache *config = (TConfigurationUseCache*)conf;; 1659 ; 1660 Int_t bufpos = b.Length();; 1661 TVirtualArray *cached = b.PeekDataCache();; 1662 if (cached==0) {; 1663 TStreamerElement *aElement = config->fCompInfo->fElem;; 1664 TStreamerInfo *info = (TStreamerInfo*)config->fInfo;; 1665 ; 1666 TVirtualCollectionProxy *proxy = ((TGenericLoopConfig*)loopconfig)->fProxy;; 1667 Warning(""ReadBuffer"",""Skipping %s::%s because the cache is missing."",info->GetName(),aElement->GetName());; 1668 UInt_t n = proxy->Size();; 1669 info->ReadBufferSkip(b, *proxy,config->fCompInfo,config->fCompInfo->fType+TStreamerInfo::kSkip,aElement,n,0);; 1670 } else {; 1671 TVectorLoopConfig cached_config( nullptr, cached->fClass->Size(), /* read */ kTRUE );; 1672 void *cached_start = (*cached)[0];; 1673 void *cached_end = ((char*)cached_start) + cached->fSize * cached_config.fIncrement;; 1674 config->fAction(b,cached_start,cached_end,&cached_config);; 1675 }; 1676 // Idea: Factor out this 'if' to a UseCacheRepeat function; 1677 if (config->fNeedRepeat) {; 1678 b.SetBufferOffset(bufpos);; 1679 }; 1680 return 0;; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:68942,cache,cached,68942,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['cache'],['cached']
Performance,"char *requestedname, Bool_t silent); 5750{; 5751 // This function does not (and should not) attempt to check in the; 5752 // list of loaded classes or in the typedef.; 5753 ; 5754 R__LOCKGUARD(gInterpreterMutex);; 5755 ; 5756 TClass *result = LoadClassDefault(requestedname, silent);; 5757 ; 5758 if (result) return result;; 5759 else return LoadClassCustom(requestedname,silent);; 5760}; 5761 ; 5762////////////////////////////////////////////////////////////////////////////////; 5763/// Helper function used by TClass::GetClass().; 5764/// This function attempts to load the dictionary for 'classname' from; 5765/// the TClassTable or the autoloader.; 5766/// If silent is 'true', do not warn about missing dictionary for the class.; 5767/// (typically used for class that are used only for transient members); 5768///; 5769/// The 'requestedname' is expected to be already normalized.; 5770 ; 5771TClass *TClass::LoadClassDefault(const char *requestedname, Bool_t /* silent */); 5772{; 5773 // This function does not (and should not) attempt to check in the; 5774 // list of loaded classes or in the typedef.; 5775 ; 5776 DictFuncPtr_t dict = TClassTable::GetDictNorm(requestedname);; 5777 ; 5778 if (!dict) {; 5779 if (gInterpreter->AutoLoad(requestedname,kTRUE)) {; 5780 dict = TClassTable::GetDictNorm(requestedname);; 5781 }; 5782 }; 5783 ; 5784 if (dict) {; 5785 TClass *ncl = (dict)();; 5786 if (ncl) ncl->PostLoadCheck();; 5787 return ncl;; 5788 }; 5789 return nullptr;; 5790}; 5791 ; 5792////////////////////////////////////////////////////////////////////////////////; 5793/// Helper function used by TClass::GetClass().; 5794/// This function attempts to load the dictionary for 'classname'; 5795/// from the list of generator.; 5796/// If silent is 'true', do not warn about missing dictionary for the class.; 5797/// (typically used for class that are used only for transient members); 5798///; 5799/// The 'requestedname' is expected to be already normalized.; 5800 ; 5801TClass *TCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:221345,load,loaded,221345,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"char *requestedname, Bool_t silent); 5817{; 5818 // This function does not (and should not) attempt to check in the; 5819 // list of loaded classes or in the typedef.; 5820 ; 5821 R__LOCKGUARD(gInterpreterMutex);; 5822 ; 5823 TClass *result = LoadClassDefault(requestedname, silent);; 5824 ; 5825 if (result) return result;; 5826 else return LoadClassCustom(requestedname,silent);; 5827}; 5828 ; 5829////////////////////////////////////////////////////////////////////////////////; 5830/// Helper function used by TClass::GetClass().; 5831/// This function attempts to load the dictionary for 'classname' from; 5832/// the TClassTable or the autoloader.; 5833/// If silent is 'true', do not warn about missing dictionary for the class.; 5834/// (typically used for class that are used only for transient members); 5835///; 5836/// The 'requestedname' is expected to be already normalized.; 5837 ; 5838TClass *TClass::LoadClassDefault(const char *requestedname, Bool_t /* silent */); 5839{; 5840 // This function does not (and should not) attempt to check in the; 5841 // list of loaded classes or in the typedef.; 5842 ; 5843 DictFuncPtr_t dict = TClassTable::GetDictNorm(requestedname);; 5844 ; 5845 if (!dict) {; 5846 if (gInterpreter->AutoLoad(requestedname,kTRUE)) {; 5847 dict = TClassTable::GetDictNorm(requestedname);; 5848 }; 5849 }; 5850 ; 5851 if (dict) {; 5852 TClass *ncl = (dict)();; 5853 if (ncl) ncl->PostLoadCheck();; 5854 return ncl;; 5855 }; 5856 return nullptr;; 5857}; 5858 ; 5859////////////////////////////////////////////////////////////////////////////////; 5860/// Helper function used by TClass::GetClass().; 5861/// This function attempts to load the dictionary for 'classname'; 5862/// from the list of generator.; 5863/// If silent is 'true', do not warn about missing dictionary for the class.; 5864/// (typically used for class that are used only for transient members); 5865///; 5866/// The 'requestedname' is expected to be already normalized.; 5867 ; 5868TClass *TCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:224096,load,loaded,224096,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"char * ; fontname, . Int_t ; max, . Int_t & ; count . ). overridevirtual . Returns list of font names matching fontname regexp, like ""-*-times-*"". ; The pattern string can contain any characters, but each asterisk (*) is a wildcard for any number of characters, and each question mark (?) is a wildcard for a single character. If the pattern string is not in the Host Portable Character Encoding, the result is implementation dependent. Use of uppercase or lowercase does not matter. Each returned string is null-terminated.; Parameters. [in]fontnamespecifies the null-terminated pattern string that can contain wildcard characters ; [in]maxspecifies the maximum number of names to be returned ; [in]countreturns the actual number of font names . Reimplemented from TVirtualX.; Definition at line 2882 of file TGCocoa.mm. ◆ LoadQueryFont(). FontStruct_t TGCocoa::LoadQueryFont ; (; const char * ; font_name). overridevirtual . Provides the most common way for accessing a font: opens (loads) the specified font and returns a pointer to the appropriate FontStruct_t structure. ; If the font does not exist, it returns NULL. ; Reimplemented from TVirtualX.; Definition at line 2809 of file TGCocoa.mm. ◆ LookupString(). void TGCocoa::LookupString ; (; Event_t * ; event, . char * ; buf, . Int_t ; buflen, . UInt_t & ; keysym . ). overridevirtual . Converts the keycode from the event structure to a key symbol (according to the modifiers specified in the event structure and the current keyboard mapping). ; In ""buf"" a null terminated ASCII string is returned representing the string that is currently mapped to the key code.; Parameters. [in]eventspecifies the event structure to be used ; [in]bufreturns the translated characters ; [in]buflenthe length of the buffer ; [in]keysymreturns the ""keysym"" computed from the event if this argument is not NULL . Reimplemented from TVirtualX.; Definition at line 2788 of file TGCocoa.mm. ◆ LowerWindow(). void TGCocoa::LowerWindow ; (; Window_t ; id). overrid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:96406,load,loads,96406,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['load'],['loads']
Performance,"char * ; title, . Int_t ; splitlevel = 99, . TDirectory * ; dir = (::ROOT::Internal::TDirectoryAtomicAdapter{}) . ). Normal tree constructor. ; The tree is created in the current directory. Use the various functions Branch below to add branches to this tree.; If the first character of title is a ""/"", the function assumes a folder name. In this case, it creates automatically branches following the folder hierarchy. splitlevel may be used in this case to control the split level. ; Definition at line 817 of file TTree.cxx. ◆ ~TTree(). TTree::~TTree ; (; ). override . Destructor. ; Definition at line 920 of file TTree.cxx. ◆ TTree() [3/3]. TTree::TTree ; (; const TTree & ; tt). delete . Member Function Documentation. ◆ AddAllocationCount(). void TTree::AddAllocationCount ; (; UInt_t ; count). inline . Definition at line 337 of file TTree.h. ◆ AddBranchToCache() [1/2]. Int_t TTree::AddBranchToCache ; (; const char * ; bname, . bool ; subbranches = false . ). virtual . Add branch with name bname to the Tree cache. ; If bname=""*"" all branches are added to the cache. if subbranches is true all the branches of the subbranches are also put to the cache.; Returns:; 0 branch added or already included; -1 on error . Definition at line 1059 of file TTree.cxx. ◆ AddBranchToCache() [2/2]. Int_t TTree::AddBranchToCache ; (; TBranch * ; b, . bool ; subbranches = false . ). virtual . Add branch b to the Tree cache. ; if subbranches is true all the branches of the subbranches are also put to the cache.; Returns:; 0 branch added or already included; -1 on error . Definition at line 1098 of file TTree.cxx. ◆ AddClone(). void TTree::AddClone ; (; TTree * ; clone). Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ; Definition at line 1219 of file TTree.cxx. ◆ AddFriend() [1/3]. TFriendElement * TTree::AddFriend ; (; const char * ; treename, . const char * ; filename = """" . ). virtual . Add a TFriendElement to the list of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:69217,cache,cache,69217,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['cache'],['cache']
Performance,"char * ; uri = ""*"", . const char * ; opt = """" . ). virtual . Prints formatted information about the dataset 'uri'. ; The type and format of output is driven by 'opt':. opt = ""server:srv1[,srv2[,srv3[,...]]]"" Print info about the subsets of 'uri' on servers srv1, srv2, ...; opt = ""servers[:exclude:srv1[,srv2[,srv3[,...]]]]"" Print info about the subsets of 'uri' on all servers, except the ones in the exclude list srv1, srv2, ...; opt = <any> Print info about all datasets matching 'uri'. If 'opt' contains 'full:' the list of files in the datasets are also printed. In case 3. this is enabled only if 'uri' matches a single dataset.; In case 3, if 'opt' contains 'full:' the list of files in the datasets are also printed. 'forcescan:' the dataset are open to get the information; otherwise the pre-processed information is used. 'noheader:' the labelling header is not printed; usefull when to chain several printouts 'noupdate:' do not update the cache (which may be slow on very remote servers) 'refresh:' refresh the information (requires appropriate credentials; typically it can be done only for owned datasets) ; Definition at line 1098 of file TDataSetManager.cxx. ◆ ShowQuota(). void TDataSetManager::ShowQuota ; (; const char * ; opt). virtual . Display quota information. ; Definition at line 585 of file TDataSetManager.cxx. ◆ Streamer(). void TDataSetManager::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in TDataSetManagerFile. ◆ StreamerNVirtual(). void TDataSetManager::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 158 of file TDataSetManager.h. ◆ ToBytes(). Long64_t TDataSetManager::ToBytes ; (; const char * ; size = 0). staticprotected . Static utility function to gt the number of bytes from a string representation in the form ""`<digit>``<sfx>`"" with <sfx> = {"""", ""k"", ""M"", ""G"", ""T"", ""P""} (case insensitive). ; Returns -1 if the format is wrong",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManager.html:37719,cache,cache,37719,doc/master/classTDataSetManager.html,https://root.cern,https://root.cern/doc/master/classTDataSetManager.html,1,['cache'],['cache']
Performance,"char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; AnaIntData & anaIntData (Int_t code) const;  Check if cache entry was previously created. ;  ; void decodeCode (Int_t code, std::vector< int > &map1, std::vector< int > &map2) const;  Decode analytical integration/generation code into index map of integrated/generated (map2) and non-integrated/generated observables (map1) ;  ; double evaluate () const override;  Do not persist. ;  ; GenData & genData (Int_t code) const;  WVE – CHECK THAT GENDATA IS VALID GIVEN CURRENT VALUES OF _MU. ;  ; void syncMuVec () const;  ;  Protected Member Functions inherited from RooAbsPdf;  RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr);  Copy constructor. ;  ; virtual std::unique_ptr< RooAbsReal > createNLLImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the NLL creation routine. ;  ; virtual std::unique_ptr< RooFitResult > fitToImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the likelihood fitting routine. ;  ; bool isActiveNormSet (RooArgSet const *n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMultiVarGaussian.html:59650,cache,cache,59650,doc/master/classRooMultiVarGaussian.html,https://root.cern,https://root.cern/doc/master/classRooMultiVarGaussian.html,1,['cache'],['cache']
Performance,"char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; TObject.h; gMainDictstatic PyObject * gMainDictDefinition TPython.cxx:98; TPython.h; operator=Binding & operator=(OUT(*fun)(void))Definition TRInterface_Binding.h:15; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::IsATClass * IsA() const overrideDefinition TClass.h:618; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjectMother of all ROOT objects.Definition TObject.h:41; TPyClassGeneratorDefinition TPyClassGenerator.h:18; TPyReturnDefinition TPyReturn.h:30; TPythonAccessing the Python interpreter from C++.Definition TPython.h:44; TPython::ExecScriptstatic void ExecScript(const char *name, int argc=0, const char **argv=nullptr)Execute a python stand-alone script, with argv CLI arguments.Definition TPython.cxx:381; TPython::Importstatic Bool_t Import(const char *name)Import the named python module and create Cling equivalents for its classes and methods.Definition TPython.cxx:237; TPython::LoadMacrostatic void LoadMacro(const char *name)Execute the give python script as if it were a macro (effectively an execfile in main),...Definition TPython.cxx:305; TPython::Execstatic Bool_t Exec(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPython_8cxx_source.html:22797,load,load,22797,doc/master/TPython_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html,1,['load'],['load']
Performance,"char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGMimeTypes(const TGMimeTypes& gmt); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TGMime*Find(const char* filename); voidTObject::MakeZombie(); TGMimeTypes&operator=(const TGMimeTypes& gmt). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfChangedtrue if file has changed; TGClient*fClientclient to which mime types belong (display server); TStringfFilenamefile name of mime type file; TOrdCollection*fListlist of mime types. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGMimeTypes(TGClient* client, const char* file); Create a mime type cache. Read the mime types file ""filename"" and; built a list of mime types. ~TGMimeTypes(); Delete mime type pool. TGMimeTypes(const TGMimeTypes& gmt); Copy constructor. TGMimeTypes& operator=(const TGMimeTypes& gmt); Assignment operator. TGMime * Find(const char* filename); Given a filename find the matching mime type object. const TGPicture * GetIcon(const char* filename, Bool_t small_icon); Return icon belonging to mime type of filename. Bool_t GetAction(const char* filename, char* action); Return in action the mime action string belonging to filename. Bool_t GetType(const char* filename, char* type); Return in type the mime type belonging to filename. void Print(Option_t* option = """") const; Print list of mime types. void SaveMimes(); Save mime types in user's mime type file. void AddType(const char* type, const char* pat, const char* icon, const char* sicon, const char* action); Add a mime type to the list of mime types. Bool_t HasChanged",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGMimeTypes.html:5898,cache,cache,5898,root/html528/TGMimeTypes.html,https://root.cern,https://root.cern/root/html528/TGMimeTypes.html,4,['cache'],['cache']
Performance,"char* ord, Int_t perf, const char* image, const char* workdir); TSlave*CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TList*GetEnabledPackages() const; static Bool_tGetFileInCmd(const char* cmd, TString& fn); static Int_tGetInputData(TList* input, const char* cachedir, TString& emsg); TList*GetListOfActiveSlaves() const; TVirtualProofPlayer*GetPlayer() const; TPluginHandler*GetProgressDialog() const; Int_tGetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidHandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tHandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidInitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); virtual Int_tPollForNewWorkers(); voidPrepareInputDataFile(TString& dataFile); Int_tRemoveWorkers(TList* wrks); static Int_tSaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidSaveWorkerInfo(); Int_tSendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tSendInputData(TQueryResult* qr, TProof* p, TString& emsg); virtual voidSendInputDataFile(); voidSetDSet(TDSet* dset); voidSetFeedback(TString& opt, TString& optfb, Int_t action); voidSetPlayer(TVirtualProofPlayer* player); voidSetupWorkersEnv(TList* wrks, Bool_t increasingpool = kFALSE); static void*SlaveStartupThread(void* arg); virtual Bool_tStartSlaves(Bool_t attach = kFALSE); static voidSystemCmd(const char* cmd, Int_t fdout); voidUpdateDialog(); virtual voidValidateDSet(TDSet* dset); Int_tVerifyDataSetParallel(const char* uri, const char* optStr).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:20794,cache,cachedir,20794,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,1,['cache'],['cachedir']
Performance,"che ; (; const char * ; file = 0). overridevirtual . Remove files from all file caches. ; Reimplemented from TProof.; Definition at line 1519 of file TProofLite.cxx. ◆ ClearDataSetCache(). void TProofLite::ClearDataSetCache ; (; const char * ; dataset = 0). overridevirtual . Clear the content of the dataset cache, if any (matching 'dataset', if defined). ; Reimplemented from TProof.; Definition at line 2282 of file TProofLite.cxx. ◆ CopyMacroToCache(). Int_t TProofLite::CopyMacroToCache ; (; const char * ; macro, . Int_t ; headerRequired = 0, . TSelector ** ; selector = 0, . Int_t ; opt = 0, . TList * ; wrks = 0 . ). protected . Copy a macro, and its possible associated .h[h] file, to the cache directory, from where the workers can get the file. ; If headerRequired is 1, return -1 in case the header is not found. If headerRequired is 0, try to copy header too. If headerRequired is -1, don't look for header, only copy macro. If the selector pionter is not 0, consider the macro to be a selector and try to load the selector and set it to the pointer. The mask 'opt' is an or of ESendFileOpt: kCpBin (0x8) Retrieve from the cache the binaries associated with the file kCp (0x10) Retrieve the files from the cache Return -1 in case of error, 0 otherwise. ; Definition at line 1593 of file TProofLite.cxx. ◆ CreateSandbox(). Int_t TProofLite::CreateSandbox ; (; ). private . Create the sandbox for this session. ; Definition at line 880 of file TProofLite.cxx. ◆ DeclFileName(). static const char * TProofLite::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 170 of file TProofLite.h. ◆ DrawSelect(). Long64_t TProofLite::DrawSelect ; (; TDSet * ; dset, . const char * ; varexp, . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; first = 0 . ). overridevirtual . Execute the specified drawing action on a data set (TDSet). ; Event- or Entry-lists should be set in the data ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:49843,load,load,49843,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['load'],['load']
Performance,"che for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsSelfCachedPdf.html:42159,cache,cache,42159,root/html534/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsSelfCachedPdf.html,3,['cache'],['cache']
Performance,"che for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenProdProj(); Default constructor. RooGenProdProj(const char* name, const char* title, const RooArgSet& _prodSet, const RooArgSet& _intSet, const RooArgSet& _normSet, const char* isetRangeName, const char* normRangeName = 0, Bool_t doFactorize = kTRUE); Constructor for a normalization projection of the product of p.d.f.s _prodSet; integrated over _intSet in range isetRangeName while normalized over _normSet. RooGenProdProj(const RooGenProdProj& other, const char* name = 0); Copy constructor. ~RooGenProdProj(); Destructor. RooAbsReal* makeIntegral(const char* name, const RooArgSet& compSet, const RooArgSet& intSet, RooArgSet& saveSet, const char* isetRangeName, Bool_t doFactorize); Utility function to create integral over observables intSet in range isetRangeName over product of p.d.fs in compSet.; The integration is factorized into components as much as possible and done analytically as far as possible.; All component object needed to represent product integral are added as owned members to saveSet.; The return value is a RooAbsReal object representing the requested integral. Double_t evaluate() const; Calculate and return value of normalization projection. void operModeHook(); Intercept cache mode operation changes and propagate them to the components. TObject* clone(const char* newname) const; { return new RooGenProdProj(*this, newname); }. » Last changed: Thu Sep 23 19:59:52 2010 » Last generated: 2010-09-23 19:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGenProdProj.html:34657,cache,cache,34657,root/html528/RooGenProdProj.html,https://root.cern,https://root.cern/root/html528/RooGenProdProj.html,1,['cache'],['cache']
Performance,"che for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenProdProj(); Default constructor. RooGenProdProj(const char* name, const char* title, const RooArgSet& _prodSet, const RooArgSet& _intSet, const RooArgSet& _normSet, const char* isetRangeName, const char* normRangeName = 0, Bool_t doFactorize = kTRUE); Constructor for a normalization projection of the product of p.d.f.s _prodSet; integrated over _intSet in range isetRangeName while normalized over _normSet. RooGenProdProj(const RooGenProdProj& other, const char* name = 0); Copy constructor. ~RooGenProdProj(); Destructor. RooAbsReal* makeIntegral(const char* name, const RooArgSet& compSet, const RooArgSet& intSet, RooArgSet& saveSet, const char* isetRangeName, Bool_t doFactorize); Utility function to create integral over observables intSet in range isetRangeName over product of p.d.fs in compSet.; The integration is factorized into components as much as possible and done analytically as far as possible.; All component object needed to represent product integral are added as owned members to saveSet.; The return value is a RooAbsReal object representing the requested integral. Double_t evaluate() const; Calculate and return value of normalization projection. void operModeHook(); Intercept cache mode operation changes and propagate them to the components. TObject* clone(const char* newname) const; { return new RooGenProdProj(*this, newname); }. » Last changed: Tue Jun 30 14:33:19 2015 » Last generated: 2015-06-30 14:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenProdProj.html:39229,cache,cache,39229,root/html602/RooGenProdProj.html,https://root.cern,https://root.cern/root/html602/RooGenProdProj.html,1,['cache'],['cache']
Performance,"che for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenProdProj(); Default constructor. RooGenProdProj(const char* name, const char* title, const RooArgSet& _prodSet, const RooArgSet& _intSet, const RooArgSet& _normSet, const char* isetRangeName, const char* normRangeName = 0, Bool_t doFactorize = kTRUE); Constructor for a normalization projection of the product of p.d.f.s _prodSet; integrated over _intSet in range isetRangeName while normalized over _normSet. RooGenProdProj(const RooGenProdProj& other, const char* name = 0); Copy constructor. ~RooGenProdProj(); Destructor. RooAbsReal* makeIntegral(const char* name, const RooArgSet& compSet, const RooArgSet& intSet, RooArgSet& saveSet, const char* isetRangeName, Bool_t doFactorize); Utility function to create integral over observables intSet in range isetRangeName over product of p.d.fs in compSet.; The integration is factorized into components as much as possible and done analytically as far as possible.; All component object needed to represent product integral are added as owned members to saveSet.; The return value is a RooAbsReal object representing the requested integral. Double_t evaluate() const; Calculate and return value of normalization projection. void operModeHook(); Intercept cache mode operation changes and propagate them to the components. TObject* clone(const char* newname) const; { return new RooGenProdProj(*this, newname); }. » Last changed: Tue Mar 10 17:17:10 2015 » Last generated: 2015-03-10 17:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGenProdProj.html:37726,cache,cache,37726,root/html534/RooGenProdProj.html,https://root.cern,https://root.cern/root/html534/RooGenProdProj.html,1,['cache'],['cache']
Performance,"che for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedPdf(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsCachedPdf(const RooAbsCachedPdf& other, const char* name = 0); Copy constructor. ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedPdf.html:47280,cache,cache,47280,root/html602/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html,2,['cache'],['cache']
Performance,"che manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypeak; RooRealProxytail; RooRealProxywidth; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNovosibirsk.html:44264,cache,cache,44264,root/html602/RooNovosibirsk.html,https://root.cern,https://root.cern/root/html602/RooNovosibirsk.html,2,['cache'],['cache']
Performance,"che manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; TString_sigCatNameName of accept state of accept/reject category; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooEfficiency.html:39624,cache,cache,39624,root/html528/RooEfficiency.html,https://root.cern,https://root.cern/root/html528/RooEfficiency.html,2,['cache'],['cache']
Performance,"che operation mode of all objects in the expression tree will modified such that all nodes that depend directly or indirectly on any of the listed observables will be set to ADirty, as they are expected to change every time. This save change tracking overhead for nodes that are a priori known to change every time ; Definition at line 1782 of file RooAbsArg.cxx. ◆ optimizeCacheMode() [2/2]. void RooAbsArg::optimizeCacheMode ; (; const RooArgSet & ; observables, . RooArgSet & ; optimizedNodes, . RooLinkedList & ; processedNodes . ). virtual . Activate cache mode optimization with given definition of observables. ; The cache operation mode of all objects in the expression tree will modified such that all nodes that depend directly or indirectly on any of the listed observables will be set to ADirty, as they are expected to change every time. This save change tracking overhead for nodes that are a priori known to change every time ; Definition at line 1801 of file RooAbsArg.cxx. ◆ optimizeDirtyHook(). virtual void RooAbsArg::optimizeDirtyHook ; (; const RooArgSet * ; ). inlineprotectedvirtual . Definition at line 564 of file RooAbsArg.h. ◆ overlaps(). bool RooAbsArg::overlaps ; (; const RooAbsArg & ; testArg, . bool ; valueOnly = false . ); const. Test if any of the nodes of tree are shared with that of the given tree. ; Definition at line 900 of file RooAbsArg.cxx. ◆ ownedComponents(). const RooArgSet * RooAbsArg::ownedComponents ; (; ); const. inline . Definition at line 519 of file RooAbsArg.h. ◆ Print(). void RooAbsArg::Print ; (; Option_t * ; options = nullptr); const. inlineoverridevirtual . Print the object to the defaultPrintStream(). ; Parameters. [in]optionsV print verbose. T print a tree structure with all children. . Reimplemented from TObject.; Definition at line 294 of file RooAbsArg.h. ◆ printAddress(). void RooAbsArg::printAddress ; (; std::ostream & ; os); const. overridevirtual . Print address of this RooAbsArg. ; Reimplemented from RooPrintable.; Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:79110,optimiz,optimizeDirtyHook,79110,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"che*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useCdfBoundariesAre c.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCachedReal.html:33286,cache,cache,33286,root/html530/RooCachedReal.html,https://root.cern,https://root.cern/root/html530/RooCachedReal.html,2,['cache'],['cache']
Performance,"cheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidsterilize(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. Int_t_lastIndex! Last slot accessed; Int_t_maxSize! Maximum size; vector<RooNormSetCache>_nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_size! Actual use; Bool_t_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCacheManager<T> reset(); Clear the cache. void RooCacheManager<T> sterilize(); Clear the cache payload but retain slot mapping w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. return getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx, const char* isetRangeN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCacheManager_RooAbsCacheElement_.html:3838,cache,cache,3838,root/html602/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html602/RooCacheManager_RooAbsCacheElement_.html,2,['cache'],['cache']
Performance,"cheElement>::wireCache(). Data Members; protected:. static Bool_t_clearObsListClear obslist on sterilize?; Bool_t_clearOnRedirect; Int_tRooCacheManager<RooAbsCacheElement>::_lastIndexLast slot accessed; Int_tRooCacheManager<RooAbsCacheElement>::_maxSizeMaximum size; RooNormSetCache*RooCacheManager<RooAbsCacheElement>::_nsetCache! Normalization/Integration set manager; RooAbsCacheElement**RooCacheManager<RooAbsCacheElement>::_object! Payload; Bool_t_optCacheModeSeen! ; list<RooArgSet*>_optCacheObsList! list of all optCacheObservables owned; RooArgSet*_optCacheObservables! current optCacheObservables ; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_sizeActual use; Bool_tRooCacheManager<RooAbsCacheElement>::_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooObjCacheManager.html:4109,cache,cache,4109,root/html532/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html532/RooObjCacheManager.html,1,['cache'],['cache']
Performance,"cheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8702 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 609 of file TTree.h. ◆ SetCircular(). void TTree::SetCircular ; (; Long64_t ; maxEntries). virtual . Enable/Disable circularity for this tree. ; if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this function is called (maxEntries>0) the Tree must be empty or having only one basket per branch. if maxEntries <= 0 the tree circularity is disabled.; NOTE 1:; Circular Trees are interesting in online real time environments to store the results of the last maxEntries events. NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before merging circular Trees that have been saved on files. NOTE 3:; SetCircular with maxEntries ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:208532,cache,cache,208532,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['cache'],['cache']
Performance,"ched isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static Int_t _cacheAllNDim;  ! Cache all integrals with given numeric dimension ;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Private Member Functions; void addNumIntDep (RooAbsArg const &arg);  Sort numeric integration variables in summation and integration lists. ;  . Additional Inherited Members;  Public Types inherited from RooAbsReal; enum  ErrorLoggingMode { PrintErrors; , CollectErrors; , CountErrors; , Ignore; };  ; enum  ScaleType { Raw; , Relative; , NumEvent; , RelativeExpected; };  ; using value_type = double;  ;  Public Types inherited from RooAbsArg; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeActivate =1; , ConfigChange =2; , ValueChange =3; };  ; enum  OperMode { Auto =0; , AClean =1; , ADirty =2; };  ; using RefCountList_t = RooSTLRefCountList< RooAbsArg >;  ; using RefCountListLegacyIterator_t = TIteratorToSTLInterface< RefCountList_t::Container_t >; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealIntegral.html:60869,cache,cache,60869,doc/master/classRooRealIntegral.html,https://root.cern,https://root.cern/doc/master/classRooRealIntegral.html,1,['cache'],['cache']
Performance,"chedReal::FuncCacheElem * RooCachedReal::createCache ; (; const RooArgSet * ; nset); const. overrideprotectedvirtual . Interface function to create an internal cache object that represent each cached function configuration. ; This interface allows to create and return a class derived from RooAbsCachedReal::FuncCacheElem so that a derived class fillCacheObject implementation can utilize extra functionality defined in such a derived cache class ; Reimplemented from RooAbsCachedReal.; Definition at line 103 of file RooCachedReal.cxx. ◆ DeclFileName(). static const char * RooCachedReal::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 72 of file RooCachedReal.h. ◆ evaluate(). double RooCachedReal::evaluate ; (; ); const. inlineoverrideprotectedvirtual . Dummy evaluate, it is never called. ; Implements RooAbsReal.; Definition at line 55 of file RooCachedReal.h. ◆ fillCacheObject(). void RooCachedReal::fillCacheObject ; (; RooAbsCachedReal::FuncCacheElem & ; cache); const. overrideprotectedvirtual . Update contents of cache histogram by resampling the input function. ; Implements RooAbsCachedReal.; Definition at line 117 of file RooCachedReal.cxx. ◆ getCdfBoundaries(). bool RooCachedReal::getCdfBoundaries ; (; ); const. inline . If true the c.d.f boundary mode is active. ; Definition at line 38 of file RooCachedReal.h. ◆ inputBaseName(). const char * RooCachedReal::inputBaseName ; (; ); const. inlineoverrideprotectedvirtual . Return base name for caches, i.e. the name of the cached function. ; Implements RooAbsCachedReal.; Definition at line 48 of file RooCachedReal.h. ◆ IsA(). TClass * RooCachedReal::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsCachedReal.; Definition at line 72 of file RooCachedReal.h. ◆ operModeHook(). void RooCachedReal::operModeHook ; (; ). overrideprotectedvirtual . Reimplemented from RooAbsArg.; Definition at line 184 of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:67709,cache,cache,67709,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,1,['cache'],['cache']
Performance,"ches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxyRooAbsHiddenReal::_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooUnblindCPAsymVar.html:33450,cache,cache,33450,root/html530/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html530/RooUnblindCPAsymVar.html,1,['cache'],['cache']
Performance,"ches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* binningName() const; Returns name of binning to be used fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedReal.html:34197,cache,cacheNameSuffix,34197,root/html526/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedReal.html,2,['cache'],"['cache', 'cacheNameSuffix']"
Performance,"ches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedReal.html:34486,cache,cacheNameSuffix,34486,root/html528/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedReal.html,4,['cache'],"['cache', 'cacheNameSuffix']"
Performance,"ches ; map<Int_t,Bool_t>_bpsIdcs; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TMatrixDSym*_corrMat; TMatrixDSym*_covMat; Double_t_d; RooDataSet&_data; vector<std::vector<Double_t> >_dataPts; vector<TVectorD>_dataPtsR; RooArgSet_dataVars; Bool_t_debug; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; TVectorD*_dx; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_fixedShape; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooNDKeysPdf::BoxInfo_fullBoxInfo; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; vector<Int_t>_idx; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Preven",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNDKeysPdf.html:42289,cache,cache,42289,root/html534/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html534/RooNDKeysPdf.html,1,['cache'],['cache']
Performance,"ches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCacheUnzip.html:13563,queue,queue,13563,root/html528/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html528/TTreeCacheUnzip.html,3,['queue'],['queue']
Performance,"ches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:132155,cache,cacheSize,132155,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,4,['cache'],"['cache', 'cacheSize']"
Performance,"ches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; RooLinearVar Class Reference. ; RooLinearVar is the most general form of a derived real-valued object that can be used by RooRealIntegral to integrate over. ; The requirements for this are; Can be modified directly (i.e. invertible formula); Jacobian term in integral is constant (but not necessarily 1). This class implements the most general form that satisfies these requirements ; \[; RLV = \mathrm{slope} \cdot x + \mathrm{offset}; \]. \( x \) is required to be a RooRealVar to meet the invertibility criterium, slope and offset are RooAbsReals, but cannot overlap with \( x \), i.e., \( x \) may not be a server of slope and offset.; In the context of a dataset, slope may not contain any real-valued dependents (to satisfyt the constant Jacobian requirement). This check cannot be enforced at construction time, but can be performed at run time through the isJacobianOK(depList) member function. ; Definition at line 29 of file RooLinearVar.h. Public Member Functions;  RooLinearVar ();  ;  RooLinearVar (const char *name, const char *title, RooAbsRealLValue &variable, const RooAbsReal &slope, const RooAbsReal &offset, const char *unit="""");  Constructor with RooAbsRealLValue variable and RooAbsReal slope and offset. ;  ;  RooLinearVar (const RooLinearVar &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooLinearVar () override;  Destructor. ;  ; TObject * clone (const char *newname) const override;  ; const RooAbsBinning & getBinning (const char *name=nullptr, bool verbose=true, bool createOnTheFly=false) const override;  Const version of getBinning() ;  ; RooAbsBinning & getBinning (const char *name=nullptr, bool verbose=true, bool createOnTheFly=false) override;  Retrieve binning of this linear transformation. ;  ; std::list< std::string > getBinningNames () const override;  Get a list of all binni",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLinearVar.html:1109,perform,performed,1109,doc/master/classRooLinearVar.html,https://root.cern,https://root.cern/doc/master/classRooLinearVar.html,1,['perform'],['performed']
Performance,"ches. TGraphBentErrors.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Dave Morrison 30/06/2003; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include <cstring>; 13#include <iostream>; 14 ; 15#include ""TROOT.h""; 16#include ""TGraphBentErrors.h""; 17#include ""TMath.h""; 18#include ""TVirtualPad.h""; 19#include ""TH1.h""; 20#include ""TF1.h""; 21 ; 22ClassImp(TGraphBentErrors);; 23 ; 24 ; 25////////////////////////////////////////////////////////////////////////////////; 26 ; 27/** \class TGraphBentErrors; 28 \ingroup Graphs; 29A TGraphBentErrors is a TGraph with bent, asymmetric error bars.; 30 ; 31The TGraphBentErrors painting is performed thanks to the TGraphPainter; 32class. All details about the various painting options are given in this class.; 33 ; 34The picture below gives an example:; 35Begin_Macro(source); 36{; 37 auto c1 = new TCanvas(""c1"",""A Simple Graph with bent error bars"",200,10,700,500);; 38 const Int_t n = 10;; 39 Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; 40 Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; 41 Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; 42 Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; 43 Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; 44 Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; 45 Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 46 Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; 47 Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 48 Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; 49 auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; 50 gr->SetTitle(""TGrap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:1129,perform,performed,1129,doc/master/TGraphBentErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html,1,['perform'],['performed']
Performance,"chi2 and the number of fitting data points) to store and have them printed in the FitResult class. ; Definition at line 311 of file FitResult.cxx. ◆ SetMinosError(). void ROOT::Fit::FitResult::SetMinosError ; (; unsigned int ; i, . double ; elow, . double ; eup . ). set the Minos errors for parameter i (called by the Fitter class when running Minos) ; Definition at line 346 of file FitResult.cxx. ◆ SetModelFunction(). void ROOT::Fit::FitResult::SetModelFunction ; (; const std::shared_ptr< IModelFunction > & ; func). inlineprotected . Definition at line 338 of file FitResult.h. ◆ Status(). int ROOT::Fit::FitResult::Status ; (; ); const. inline . minimizer status code ; Definition at line 128 of file FitResult.h. ◆ Update(). bool ROOT::Fit::FitResult::Update ; (; const std::shared_ptr< ROOT::Math::Minimizer > & ; min, . const ROOT::Fit::FitConfig & ; fconfig, . bool ; isValid, . unsigned int ; ncalls = 0 . ). Update the fit result with a new minimization status To be run only if same fit is performed with same configuration Note that in this case MINOS is not re-run. ; If one wants to run also MINOS a new result must be created ; Definition at line 224 of file FitResult.cxx. ◆ UpperError(). double ROOT::Fit::FitResult::UpperError ; (; unsigned int ; i); const. upper Minos error. If Minos has not run for parameter i return the parabolic error ; Definition at line 339 of file FitResult.cxx. ◆ Value(). double ROOT::Fit::FitResult::Value ; (; unsigned int ; i); const. inline . parameter value by index ; Definition at line 172 of file FitResult.h. Friends And Related Symbol Documentation. ◆ Fitter. friend class Fitter. friend . Definition at line 340 of file FitResult.h. Member Data Documentation. ◆ fBoundParams. std::map<unsigned int, unsigned int> ROOT::Fit::FitResult::fBoundParams. protected . list of limited parameters ; Definition at line 358 of file FitResult.h. ◆ fChi2. double ROOT::Fit::FitResult::fChi2. protected . fit chi2 value (different than fval in case of chi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitResult.html:24105,perform,performed,24105,doc/master/classROOT_1_1Fit_1_1FitResult.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitResult.html,1,['perform'],['performed']
Performance,"ching with considerable performance gains in these cases.; For this to work correctly the logical object in must be described in TBuffer3D in the local reference frame, complete with the local/master translation. The viewer indicates this through the interface method; PreferLocalFrame(); If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers to the properties of logical object, with the fLocalMaster transform and the fColor and fTransparency attributes, which can be varied for each physical object.; As a minimum requirement all clients must be capable of filling the raw tessellation of the object buffer, in the master reference frame. Conversely viewers must always be capable of displaying the object described by this buffer. Scene Rebuilds; It should be understood that AddObject is not an explicit command to the viewer; it may for various reasons decide to ignore it:; It already has the object internally cached .; The object falls outside some 'interest' limits of the viewer camera.; The object is too small to be worth drawing. In all these cases AddObject() returns kNone, as it does for successful addition, simply indicating it does not require you to provide further information about this object. You should not try to make any assumptions about what the viewer did with it.; This enables the viewer to be connected to a client which sends potentially millions of objects, and only accept those that are of interest at a certain time, caching the relatively small number of CPU/memory costly logical shapes, and retaining/discarding the physical placements as required. The viewer may decide to force the client to rebuild (republish) the scene (via a TPad repaint at present), and thus collect these objects if the internal viewer state changes. It does this presently by forcing a repaint on the attached TP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBuffer3D.html:6912,cache,cached,6912,doc/master/classTBuffer3D.html,https://root.cern,https://root.cern/doc/master/classTBuffer3D.html,1,['cache'],['cached']
Performance,"ching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidnormLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooResolutionModel.html:23203,optimiz,optimizeCacheMode,23203,root/html528/RooResolutionModel.html,https://root.cern,https://root.cern/root/html528/RooResolutionModel.html,2,['optimiz'],['optimizeCacheMode']
Performance,"ching...; No Matches. Namespaces ; rf211_paramconv.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'ADDITION AND CONVOLUTION' RooFit tutorial macro #211 Working a with a p.d.f. ; with a convolution operator in terms of a parameter; (require ROOT to be compiled with –enable-fftw3). ; import ROOT; ; # Set up component pdfs; # ---------------------------------------; ; # Gaussian g(x ; mean,sigma); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); mean = ROOT.RooRealVar(""mean"", ""mean"", -3, 3); sigma = ROOT.RooRealVar(""sigma"", ""sigma"", 0.5, 0.1, 10); modelx = ROOT.RooGaussian(""gx"", ""gx"", x, mean, sigma); ; # Block function in mean; a = ROOT.RooRealVar(""a"", ""a"", 2, 1, 10); model_mean = ROOT.RooGenericPdf(""model_mean"", ""abs(mean)<a"", [mean, a]); ; # Convolution in mean model = g(x,mean,sigma) (x) block(mean); x.setBins(1000, ""cache""); mean.setBins(50, ""cache""); model = ROOT.RooFFTConvPdf(""model"", ""model"", mean, modelx, model_mean); ; # Configure convolution to construct a 2-D cache in (x,mean); # rather than a 1-d cache in mean that needs to be recalculated; # for each value of x; model.setCacheObservables({x}); model.setBufferFraction(1.0); ; # Integrate model over projModel = Int model dmean; projModel = model.createProjection({mean}); ; # Generate 1000 toy events; d = projModel.generateBinned({x}, 1000); ; # Fit p.d.f. to toy data; projModel.fitTo(d, Verbose=True, PrintLevel=-1); ; # Plot data and fitted p.d.f.; frame = x.frame(Bins=25); d.plotOn(frame); projModel.plotOn(frame); ; # Make 2d histogram of model(x;mean); hh = model.createHistogram(; ""hh"",; x,; Binning=50,; YVar=dict(var=mean, Binning=50),; ConditionalObservables={mean},; ); hh.SetTitle(""histogram of model(x|mean)""); hh.SetLineColor(ROOT.kBlue); ; # Draw frame on canvas; c = ROOT.TCanvas(""rf211_paramconv"", ""rf211_paramconv"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.20); hh.GetZaxis().SetT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf211__paramconv_8py.html:1115,cache,cache,1115,doc/master/rf211__paramconv_8py.html,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8py.html,2,['cache'],['cache']
Performance,"ching...; No Matches. TFormula.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Maciej Zimnoch 30/09/2013; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TROOT.h""; 13#include ""TBuffer.h""; 14#include ""TMethod.h""; 15#include ""TF1.h""; 16#include ""TMethodCall.h""; 17#include <TBenchmark.h>; 18#include ""TError.h""; 19#include ""TInterpreter.h""; 20#include ""TInterpreterValue.h""; 21#include ""TFormula.h""; 22#include ""TRegexp.h""; 23 ; 24#include ""ROOT/StringUtils.hxx""; 25 ; 26#include <array>; 27#include <iostream>; 28#include <memory>; 29#include <unordered_map>; 30#include <functional>; 31#include <set>; 32#include <sstream>; 33 ; 34using std::map, std::pair, std::make_pair, std::list, std::max, std::string;; 35 ; 36#ifdef WIN32; 37#pragma optimize("""",off); 38#endif; 39#include ""v5/TFormula.h""; 40 ; 41ClassImp(TFormula);; 42 ; 43/** \class TFormula TFormula.h ""inc/TFormula.h""; 44 \ingroup Hist; 45 The Formula class; 46 ; 47 This is a new version of the TFormula class based on Cling.; 48 This class is not 100% backward compatible with the old TFormula class, which is still available in ROOT as; 49 `ROOT::v5::TFormula`. Some of the TFormula member functions available in version 5, such as; 50 `Analyze` and `AnalyzeFunction` are not available in the new TFormula.; 51 On the other hand formula expressions which were valid in version 5 are still valid in TFormula version 6; 52 ; 53 This class has been implemented during Google Summer of Code 2013 by Maciej Zimnoch.; 54 ; 55 ### Example of valid expressions:; 56 ; 57 - `sin(x)/x`; 58 - `[0]*sin(x) + [1]*exp(-[2]*x)`; 59 - `x + y**2`; 60 - `x^2 + y^2`; 61 - `[0]*p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:1223,optimiz,optimize,1223,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['optimiz'],['optimize']
Performance,"ching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; RooCategoryProxy_rhoQ; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooCategoryProxy_tag; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooNonCPEigenDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNonCPEigenDecay.html:42078,cache,cache,42078,root/html530/RooNonCPEigenDecay.html,https://root.cern,https://root.cern/root/html530/RooNonCPEigenDecay.html,1,['cache'],['cache']
Performance,"chitecture=CPU:Layout=TANH|50,TANH|50,TANH|50,LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.3,ConvergenceSteps=20,BatchSize=50,TestRepetitions=1,WeightDecay=0.0,Regularization=None,Optimizer=Adam""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""G"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : Layout: ""TANH|50,TANH|50,TANH|50,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""SUMOFSQUARES"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.3,ConvergenceSteps=20,BatchSize=50,TestRepetitions=1,WeightDecay=0.0,Regularization=None,Optimizer=Adam"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layout of the input]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DNN_CPU : [datasetreg] : Create Transfor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:3743,perform,perform,3743,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['perform'],['perform']
Performance,"chname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:101000,cache,cache,101000,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,6,['cache'],['cache']
Performance,"chy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:36979,cache,cache,36979,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,2,['cache'],['cache']
Performance,"cial case:; class MyClass : public AnotherClass, public TObject; then on return, one must do:; MyClass *obj = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));. Of course, dynamic_cast<> can also be used in the example 1. void * GetObjectUnchecked(const char* namecycle); return pointer to object identified by namecycle.; The returned object may or may not derive from TObject. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. VERY IMPORTANT NOTE:; The calling application must cast the returned object to; the final type, e.g.; MyClass *obj = (MyClass*)directory->GetObject(""some object of MyClass"");. void * GetObjectChecked(const char* namecycle, const char* classname); See documentation of TDirectory::GetObjectCheck(const char *namecycle, const TClass *cl). void * GetObjectChecked(const char* namecycle, const TClass* cl); return pointer to object identified by namecycle if and only if the actual; object is a type suitable to be stored as a pointer to a ""expectedClass""; If expectedClass is null, no check is performed. namecycle has the format name;cycle; name = * is illegal, cycle = * is illegal; cycle = """" or cycle = 9999 ==> apply to a memory object. VERY IMPORTANT NOTE:; The calling application must cast the returned pointer to; the type described by the 2 arguments (i.e. cl):; MyClass *obj = (MyClass*)directory->GetObjectChecked(""some object of MyClass"",""MyClass""));. Note: We recommend using the method TDirectory::GetObject:; MyClass *obj = 0;; directory->GetObject(""some object inheriting from MyClass"",obj);; if (obj) { ... we found what we are looking for ... }. const char * GetPathStatic() const; Returns the full path of the directory. E.g. file:/dir1/dir2.; The returned path will be re-used by the next call to GetPath(). const char * GetPath() const; Returns the full path of the directory. E.g. file:/dir1/dir2.; The returned path will be re-used by the next call",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDirectory.html:17388,perform,performed,17388,root/html528/TDirectory.html,https://root.cern,https://root.cern/root/html528/TDirectory.html,6,['perform'],['performed']
Performance,"ciated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). const TObject* retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); Retrieve object from cache that was registered under given name with given parameters, _if_; current parameter values match those that were stored in the registry for this object.; The return object is owned by the cache instance. const TObject* getObj(Int_t uniqueID); Retrieve payload object of cache element with given unique ID. Bool_t clearObj(Int_t uniqueID); Clear cache element with given unique ID; Retrieve payload object of cache element with given unique ID. Bool_t setObj(Int_t uniqueID, TObject* obj); Place new payload object in cache element with given unique ID. Cache; will take ownership of provided object!. void clearAll(); Clear all cache elements. void print() const. void importCacheObjects(RooExpensiveObjectCache& other, const char* ownerName, Bool_t verbose = kFALSE). Int_t size() const; { return _map.size() ; }. » Last changed: Mon Jul 4 15:22:45 2011 » Last generated: 2011-07-04 15:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooExpensiveObjectCache.html:7998,cache,cache,7998,root/html530/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html530/RooExpensiveObjectCache.html,6,['cache'],['cache']
Performance,"ciated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). const TObject* retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); Retrieve object from cache that was registered under given name with given parameters, _if_; current parameter values match those that were stored in the registry for this object.; The return object is owned by the cache instance. const TObject* getObj(Int_t uniqueID); Retrieve payload object of cache element with given unique ID. Bool_t clearObj(Int_t uniqueID); Clear cache element with given unique ID; Retrieve payload object of cache element with given unique ID. Bool_t setObj(Int_t uniqueID, TObject* obj); Place new payload object in cache element with given unique ID. Cache; will take ownership of provided object!. void clearAll(); Clear all cache elements. void print() const. void importCacheObjects(RooExpensiveObjectCache& other, const char* ownerName, Bool_t verbose = kFALSE). Int_t size() const; { return _map.size() ; }. » Last changed: Thu Nov 3 20:08:03 2011 » Last generated: 2011-11-03 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooExpensiveObjectCache.html:7998,cache,cache,7998,root/html532/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html532/RooExpensiveObjectCache.html,6,['cache'],['cache']
Performance,"ciated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). const TObject* retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); Retrieve object from cache that was registered under given name with given parameters, _if_; current parameter values match those that were stored in the registry for this object.; The return object is owned by the cache instance. const TObject* getObj(Int_t uniqueID); Retrieve payload object of cache element with given unique ID. Bool_t clearObj(Int_t uniqueID); Clear cache element with given unique ID; Retrieve payload object of cache element with given unique ID. Bool_t setObj(Int_t uniqueID, TObject* obj); Place new payload object in cache element with given unique ID. Cache; will take ownership of provided object!. void clearAll(); Clear all cache elements. void print() const. void importCacheObjects(RooExpensiveObjectCache& other, const char* ownerName, Bool_t verbose = kFALSE). Int_t size() const; { return _map.size() ; }. » Last changed: Tue Jun 2 15:30:37 2015 » Last generated: 2015-06-02 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooExpensiveObjectCache.html:8503,cache,cache,8503,root/html604/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html604/RooExpensiveObjectCache.html,6,['cache'],['cache']
Performance,"ciency: from test sample (from training sample) ; : Name: Method: @B=0.01 @B=0.10 @B=0.30 ; : -------------------------------------------------------------------------------------------------------------------; : dataset DNN_CPU : 0.147 (0.142) 0.404 (0.444) 0.678 (0.708); : dataset PyKeras : 0.132 (0.121) 0.404 (0.410) 0.669 (0.673); : dataset BDT : 0.098 (0.099) 0.393 (0.402) 0.657 (0.681); : dataset Likelihood : 0.085 (0.082) 0.355 (0.363) 0.580 (0.596); : dataset Fisher : 0.015 (0.015) 0.121 (0.131) 0.487 (0.506); : -------------------------------------------------------------------------------------------------------------------; : ; Dataset:dataset : Created tree 'TestTree' with 6000 events; : ; Dataset:dataset : Created tree 'TrainTree' with 14000 events; : ; Factory : ␛[1mThank you for using TMVA!␛[0m; : ␛[1mFor citation information, please visit: http://tmva.sf.net/citeTMVA.html␛[0m; ; /***; ## Declare Factory; ; Create the Factory class. Later you can choose the methods; whose performance you'd like to investigate.; ; The factory is the major TMVA object you have to interact with. Here is the list of parameters you need to pass; ; - The first argument is the base of the name of all the output; weightfiles in the directory weight/ that will be created with the; method parameters; ; - The second argument is the output file for the training results; ; - The third argument is a string option defining some general configuration for the TMVA session. For example all TMVA output can be suppressed by removing the ""!"" (not) in front of the ""Silent"" argument in the option string; ; **/; ; void TMVA_Higgs_Classification() {; ; // options to control used methods; ; bool useLikelihood = true; // likelihood based discriminant; bool useLikelihoodKDE = false; // likelihood based discriminant; bool useFischer = true; // Fischer discriminant; bool useMLP = false; // Multi Layer Perceptron (old TMVA NN implementation); bool useBDT = true; // Boosted Decision Tree; bool useDL ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:57142,perform,performance,57142,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['perform'],['performance']
Performance,"cified in the parameter settings created before For the options same consideration as in the previous method ;  . Public Member Functions;  Fitter ();  Default constructor. ;  ;  Fitter (const Fitter &)=delete;  Copy constructor (disabled, class is not copyable) ;  ;  Fitter (const std::shared_ptr< FitResult > &result);  Constructor from a result. ;  ; virtual ~Fitter ();  Destructor. ;  ; bool ApplyWeightCorrection (const ROOT::Math::IMultiGenFunction &loglw2, bool minimizeW2L=false);  apply correction in the error matrix for the weights for likelihood fits This method can be called only after a fit. ;  ; bool CalculateHessErrors ();  perform an error analysis on the result using the Hessian Errors are obtained from the inverse of the Hessian matrix To be called only after fitting and when a minimizer supporting the Hessian calculations is used otherwise an error (false) is returned. ;  ; bool CalculateMinosErrors ();  perform an error analysis on the result using MINOS To be called only after fitting and when a minimizer supporting MINOS is used otherwise an error (false) is returned. ;  ; FitConfig & Config ();  access to the configuration (non const method) ;  ; const FitConfig & Config () const;  access to the fit configuration (const method) ;  ; bool EvalFCN ();  Perform a simple FCN evaluation. ;  ; bool Fit (const BinData &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential);  Fit a binned data set using a least square fit. ;  ; template<class Data , class Function , class cond = typename std::enable_if<!(std::is_same<Function, ROOT::EExecutionPolicy>::value || std::is_same<Function, int>::value), Function>::type> ; bool Fit (const Data &data, const Function &func, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential);  fit a data set using any generic model function If data set is binned a least square fit is performed If data set is unbinned a maximum likelihood fit (not extended) is done Pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html:2799,perform,perform,2799,doc/master/classROOT_1_1Fit_1_1Fitter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html,1,['perform'],['perform']
Performance,"cify the parent widget and a string object holding the desired text.; TGLabel *label = new TGLabel(parentWidget, ""Label's string"");; Next sample creates an icon object. First we create an object of type TGPicture. The TGPicture objects are never created directly by the application code. We call TGClient telling it the pixmap’s file name to create a TGPicture object and, in turn, it will return a pointer to the created object. If the pixmap file cannot be found the returned pointer will be NULL. As usual, the first parameter of a TGIcon constructor is the parent frame. The second one is the TGPicture object holding the pixmap we want to show. Last two parameters define the width and height of pixmap in pixels. In the end we add the created icon object to its parent.; // icon widget; const TGPicture *ipic=(TGPicture *)gClient->GetPicture(""leaf.xpm"");; TGIcon *icon = new TGIcon(parent,ipic,40,40);; parent->AddFrame(icon,new TGLayoutHints(kLHintsLeft|kLHintsBottom,; 1, 15, 1, 1));; The TGPicture objects are cached by TGClient in order to keep the resource usage low and to improve the efficiency of the client-server windowing systems. TGClient will check whether a pixmap with the same name was already loaded before to register a new picture object. If it finds it, it will return a pointer to the existing object. Also, it will increase the usage counter for the object.; All TGPicture objects are managed by the class TGPicturePool. TGClient creates an object of this type upon initialization. Normally your application program does not deal directly with this class because all manipulations go through TGClient class.; Once you have finished with using of the TGPicture object, you should call the method TGClient::FreePicture(const TGPicture *pic) to free it. The usage counter of the picture object will be decreased and when it reaches zero - the TGPicture object will be deleted.; 25.8.12 Status Bar; The status bar widget is used to display some information about the current ap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1210741,cache,cached,1210741,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['cache'],['cached']
Performance,"cit LorentzRotation( BoostZ const & ) {} // TODO. { b.GetLorentzRotation( fM+0 ); }. explicit LorentzRotation( BoostX const & bx ); { bx.GetLorentzRotation( fM+0 ); }. explicit LorentzRotation( BoostY const & by ); { by.GetLorentzRotation( fM+0 ); }. explicit LorentzRotation( BoostZ const & bz ); { bz.GetLorentzRotation( fM+0 ); }. explicit LorentzRotation( Rotation3D const & r ). Construct from a 3-D rotation (no space-time mixing). explicit LorentzRotation( AxisAngle const & a ). explicit LorentzRotation( EulerAngles const & e ). explicit LorentzRotation( Quaternion const & q ). explicit LorentzRotation( RotationX const & r ). explicit LorentzRotation( RotationY const & r ). explicit LorentzRotation( RotationZ const & r ). explicit LorentzRotation(const ForeignMatrix & m). Construct from a linear algebra matrix of size at least 4x4,; which must support operator()(i,j) to obtain elements (0,3) thru (3,3).; Precondition: The matrix is assumed to be orthosymplectic. NO checking; or re-adjusting is performed.; Note: (0,0) refers to the XX component; (3,3) refers to the TT component. { SetComponents(m); }. LorentzRotation(const Foreign4Vector& v1, const Foreign4Vector& v2, const Foreign4Vector& v3, const Foreign4Vector& v4 ). Construct from four orthosymplectic vectors (which must have methods; x(), y(), z() and t()) which will be used as the columns of the Lorentz; rotation matrix. The orthosymplectic conditions will be checked, and; values adjusted so that the result will always be a good Lorentz rotation; matrix. SetComponents(ROOT::Math::LorentzRotation::Scalar xx, ROOT::Math::LorentzRotation::Scalar xy, ROOT::Math::LorentzRotation::Scalar xz, ROOT::Math::LorentzRotation::Scalar xt, ROOT::Math::LorentzRotation::Scalar yx, ROOT::Math::LorentzRotation::Scalar yy, ROOT::Math::LorentzRotation::Scalar yz, ROOT::Math::LorentzRotation::Scalar yt, ROOT::Math::LorentzRotation::Scalar zx, ROOT::Math::LorentzRotation::Scalar zy, ROOT::Math::LorentzRotation::Scalar zz, ROOT::Ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzRotation.html:7962,perform,performed,7962,root/html526/ROOT__Math__LorentzRotation.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzRotation.html,1,['perform'],['performed']
Performance,"ck is coming from.; When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker. Overlap checking; This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; TGeoManager::CheckOverlapsvoid CheckOverlaps(Double_t ovlp=0.1, Option_t *option="""")Check all geometry for illegal overlaps within a limit OVLP.Definition TGeoManager.cxx:3869; Here precision represents the desired maximum accepted overlap value in centimeters (default value is 0.1). This tool checks all possible significant pairs of candidates inside a given volume (not declared as overlapping or division volumes). The check is performed by verifying the mesh representation of one candidate against the shape of the other. This sort of check cannot identify all possible overlapping topologies, but it works for more than 95% ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:101463,load,loaded,101463,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['load'],['loaded']
Performance,"ck(ETypes::kBlob);; 425 break;; 426 case SQLITE_NULL:; 427 // TODO: Null values in first rows are not well handled; 428 fColumnTypes.push_back(ETypes::kNull);; 429 fValues.emplace_back(ETypes::kNull);; 430 break;; 431 default: throw std::runtime_error(""Unhandled data type"");; 432 }; 433 }; 434}; 435 ; 436////////////////////////////////////////////////////////////////////////////; 437/// Frees the sqlite resources and closes the file.; 438RSqliteDS::~RSqliteDS(); 439{; 440 // sqlite3_finalize returns the error code of the most recent operation on fQuery.; 441 sqlite3_finalize(fDataSet->fQuery);; 442 // Closing can possibly fail with SQLITE_BUSY, in which case resources are leaked. This should not happen; 443 // the way it is used in this class because we cleanup the prepared statement before.; 444 sqlite3_close(fDataSet->fDb);; 445}; 446 ; 447////////////////////////////////////////////////////////////////////////////; 448/// Returns the SELECT queries names. The column names have been cached in the constructor.; 449/// For expressions, the column name is the string of the expression unless the query defines a column name with as; 450/// like in ""SELECT 1 + 1 as mycolumn FROM table""; 451const std::vector<std::string> &RSqliteDS::GetColumnNames() const; 452{; 453 return fColumnNames;; 454}; 455 ; 456////////////////////////////////////////////////////////////////////////////; 457/// Activates the given column's result value.; 458RDataSource::Record_t RSqliteDS::GetColumnReadersImpl(std::string_view name, const std::type_info &ti); 459{; 460 const auto index = std::distance(fColumnNames.begin(), std::find(fColumnNames.begin(), fColumnNames.end(), name));; 461 const auto type = fColumnTypes[index];; 462 ; 463 if ((type == ETypes::kInteger && typeid(Long64_t) != ti) || (type == ETypes::kReal && typeid(double) != ti) ||; 464 (type == ETypes::kText && typeid(std::string) != ti) ||; 465 (type == ETypes::kBlob && typeid(std::vector<unsigned char>) != ti) ||; 466 (type == ET",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RSqliteDS_8cxx_source.html:18835,cache,cached,18835,doc/master/RSqliteDS_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html,1,['cache'],['cached']
Performance,"ck; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_attachedBuffers! Currently attached buffers (if different from _varsww); TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooTreeDataStore.html:10636,cache,cached,10636,root/html532/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html,8,"['cache', 'load']","['cache', 'cached', 'loading']"
Performance,"ck; static TObject::EStatusBitsTObject::kHasUUID; static TCollection::(anonymous)TCollection::kInitCapacity; static TCollection::(anonymous)TCollection::kInitHashTableCapacity; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfNRargsnumber of redo arguments; Int_tfNUargsnumber of undo arguments; TStringfNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tfNewDeletekTRUE if Redo/Undo methods are new/delete; void*fObjectobject to which undo/redo actions applied; TQConnection*fRedodo/redo action; Long_t*fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQCommand.html:17246,cache,cache,17246,root/html602/TQCommand.html,https://root.cern,https://root.cern/root/html602/TQCommand.html,2,['cache'],['cache']
Performance,"ckStatusBitskRemoveFriend; static TTree::ELockStatusBitskSetBranchStatus. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. Int_t AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache.; Returns 0 branch added or already included; -1 on error. Int_t DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in cache; -1 on error. Int_t DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache.; Returns 0 branch dropped or not in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:37739,cache,cache,37739,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,1,['cache'],['cache']
Performance,"ckage. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; If specified, enables packages only on the specified workers.; Returns 0 in case of success and -1 in case of error.; Provided for backward compatibility. Int_t EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; It is is possible to specify options for the loading step via 'loadopts';; the string will be passed passed as argument to SETUP.; Special option 'chkv=<o>' (or 'checkversion=<o>') can be used to control; plugin version checking during building: possible choices are:; off no check; failure may occur at loading; on check ROOT version [default]; svn check ROOT version and Git commit SHA1.; (Use ';', ' ' or '|' to separate 'chkv=<o>' from the rest.); If specified, enables packages only on the specified workers.; Returns 0 in case of success and -1 in case of error. Int_t EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; It is is possible to specify a list of objects to be passed to the SETUP; functions via 'loadopts'; the objects must be streamable.; Returns 0 in case of success and -1 in case of error. Int_t DownloadPackage(const char* par, const char* dstdir = 0); Download a PROOF archive (PAR file) from the master package repository.; The PAR file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:77179,load,loading,77179,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,2,['load'],['loading']
Performance,"ckages(); Unload all packages.; Returns 0 in case of success and -1 in case of error. Int_t EnablePackage(const char* package, Bool_t notOnClient = kFALSE, TList* workers = 0); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; If specified, enables packages only on the specified workers.; Returns 0 in case of success and -1 in case of error.; Provided for backward compatibility. Int_t EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; It is is possible to specify options for the loading step via 'loadopts';; the string will be passed passed as argument to SETUP.; Special option 'chkv=<o>' (or 'checkversion=<o>') can be used to control; plugin version checking during building: possible choices are:; off no check; failure may occur at loading; on check ROOT version [default]; svn check ROOT version and Git commit SHA1.; (Use ';', ' ' or '|' to separate 'chkv=<o>' from the rest.); If specified, enables packages only on the specified workers.; Returns 0 in case of success and -1 in case of error. Int_t EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; It is is possible to specify a list of objects to be passed to the SETUP; functions via 'loadopts'; the objects must be streamable.; Returns ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:76920,load,loading,76920,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,4,['load'],"['loading', 'loadopts']"
Performance,"ckages(); Unload all packages.; Returns 0 in case of success and -1 in case of error. Int_t EnablePackage(const char* package, Bool_t notOnClient = kFALSE, TList* workers = 0); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; If specified, enables packages only on the specified workers.; Returns 0 in case of success and -1 in case of error.; Provided for backward compatibility. Int_t EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; It is is possible to specify options for the loading step via 'loadopts';; the string will be passed passed as argument to SETUP.; Special option 'chkv=<o>' (or 'checkversion=<o>') can be used to control; plugin version checking during building: possible choices are:; off no check; failure may occur at loading; on check ROOT version [default]; svn check ROOT version and SVN revision number.; (Use ';', ' ' or '|' to separate 'chkv=<o>' from the rest.); If specified, enables packages only on the specified workers.; Returns 0 in case of success and -1 in case of error. Int_t EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; It is is possible to specify a list of objects to be passed to the SETUP; functions via 'loadopts'; the objects must be streamable.; Retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:74764,load,loading,74764,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,2,['load'],"['loading', 'loadopts']"
Performance,"cket emulations from the beginning, for instance when clients connected via proxys. Although JSROOT should automatically fallback to longpoll engine, one can configure this directly (default no) WebGui.WSLongpoll: no; Following parameter controls browser max-age caching parameter for files (default 3600) When 0 is specified, browser cache will be disabled WebGui.HttpMaxAge: 3600; Also one can provide extra URL options for, see TCivetweb::Create for list of supported options WebGui.HttpExtraArgs: winsymlinks=no; One also can configure usage of FastCGI server for web windows: WebGui.FastCgiPort: 4000; WebGui.FastCgiThreads: 10; To be able start web browser for such windows, one can provide real URL of the web server which will connect with that FastCGI instance: WebGui.FastCgiServer: https://your_apache_server.com/root_cgi_path; For some custom applications one requires to load JavaScript modules or other files. For such applications one may require to load files from other locations which can be configured with AddServerLocation() method or directly via: WebGui.ServerLocations: location1:/file/path/to/location1;location2:/file/path/to/location2 . Definition at line 430 of file RWebWindowsManager.cxx. ◆ CreateWindow(). std::shared_ptr< RWebWindow > RWebWindowsManager::CreateWindow ; (; ). Creates new window To show window, RWebWindow::Show() have to be called. ; Definition at line 619 of file RWebWindowsManager.cxx. ◆ GenerateKey(). std::string RWebWindowsManager::GenerateKey ; (; int ; keylen = 32). staticprivate . Static method to generate cryptographic key Parameter keylen defines length of cryptographic key in bytes Output string will be hex formatted and includes ""-"" separator after every 4 bytes Example for 16 bytes: ""fca45856-41bee066-ff74cc96-9154d405"". ; Definition at line 250 of file RWebWindowsManager.cxx. ◆ GetLaunchTmout(). float ROOT::RWebWindowsManager::GetLaunchTmout ; (; ); const. inlineprivate . Returns timeout for launching new browser process. ; De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html:11993,load,load,11993,doc/master/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html,1,['load'],['load']
Performance,"cks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the next request comes. Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all entries such that not all branch buffers are read. General Description; This class acts as a file cache, registering automatically the baskets from the branches being processed via direct manipulation of TTrees or with tools such as TTree::Draw, TTree::Process, TSelector, TTreeReader and RDataFrame when in the learning phase. The learning phase is by default 100 entries. It can be changed via TTreeCache::SetLearnEntries.; The usage of a TTreeCache can considerably improve the runtime performance at the price of a modest investment in memory, in particular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:2672,perform,performance,2672,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['perform'],['performance']
Performance,"cl->GetState() == kInterpreter) return cl; 3005 //; 3006 // In this case, if a ROOT dictionary was available when the TClass; 3007 // was first requested it would have been used and if a ROOT dictionary is; 3008 // loaded later on TClassTable::Add will take care of updating the TClass.; 3009 // So as far as ROOT dictionary are concerned, if the current TClass is; 3010 // in interpreted state, we are sure there is nothing to load.; 3011 //; 3012 // However (see TROOT::LoadClass), the TClass can also be loaded/provided; 3013 // by a user provided TClassGenerator. We have no way of knowing whether; 3014 // those do (or even can) behave the same way as the ROOT dictionary and; 3015 // have the 'dictionary is now available for use' step informs the existing; 3016 // TClass that their dictionary is now available.; 3017 ; 3018 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3019 load = kTRUE;; 3020 }; 3021 ; 3022 if (TClassEdit::IsArtificial(name)) {; 3023 // If there is a @ symbol (followed by a version number) then this is a synthetic class name created; 3024 // from an already normalized name for the purpose of supporting schema evolution.; 3025 // There is no dictionary or interpreter information about this kind of class, the only; 3026 // (undesirable) side-effect of doing the search would be a waste of CPU time and potential; 3027 // auto-loading or auto-parsing based on the scope of the name.; 3028 return cl;; 3029 }; 3030 ; 3031 // To avoid spurious auto parsing, let's check if the name as-is is; 3032 // known in the TClassTable.; 3033 DictFuncPtr_t dict = TClassTable::GetDictNorm(name);; 3034 if (dict) {; 3035 // The name is normalized, so the result of the first search is; 3036 // authoritative.; 3037 if (!cl && !load) return nullptr;; 3038 ; 3039 TClass *loadedcl = (dict)();; 3040 if (loadedcl) {; 3041 loadedcl->PostLoadCheck();; 3042 return loadedcl;; 3043 }; 3044 ; 3045 // We should really not fall through to here, but if we do, le",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:113685,load,load,113685,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"cl->GetState() == kInterpreter) return cl; 3072 //; 3073 // In this case, if a ROOT dictionary was available when the TClass; 3074 // was first requested it would have been used and if a ROOT dictionary is; 3075 // loaded later on TClassTable::Add will take care of updating the TClass.; 3076 // So as far as ROOT dictionary are concerned, if the current TClass is; 3077 // in interpreted state, we are sure there is nothing to load.; 3078 //; 3079 // However (see TROOT::LoadClass), the TClass can also be loaded/provided; 3080 // by a user provided TClassGenerator. We have no way of knowing whether; 3081 // those do (or even can) behave the same way as the ROOT dictionary and; 3082 // have the 'dictionary is now available for use' step informs the existing; 3083 // TClass that their dictionary is now available.; 3084 ; 3085 //we may pass here in case of a dummy class created by TVirtualStreamerInfo; 3086 load = kTRUE;; 3087 }; 3088 ; 3089 if (TClassEdit::IsArtificial(name)) {; 3090 // If there is a @ symbol (followed by a version number) then this is a synthetic class name created; 3091 // from an already normalized name for the purpose of supporting schema evolution.; 3092 // There is no dictionary or interpreter information about this kind of class, the only; 3093 // (undesirable) side-effect of doing the search would be a waste of CPU time and potential; 3094 // auto-loading or auto-parsing based on the scope of the name.; 3095 return cl;; 3096 }; 3097 ; 3098 // To avoid spurious auto parsing, let's check if the name as-is is; 3099 // known in the TClassTable.; 3100 DictFuncPtr_t dict = TClassTable::GetDictNorm(name);; 3101 if (dict) {; 3102 // The name is normalized, so the result of the first search is; 3103 // authoritative.; 3104 if (!cl && !load) return nullptr;; 3105 ; 3106 TClass *loadedcl = (dict)();; 3107 if (loadedcl) {; 3108 loadedcl->PostLoadCheck();; 3109 return loadedcl;; 3110 }; 3111 ; 3112 // We should really not fall through to here, but if we do, le",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:116436,load,load,116436,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"clFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 55 of file RooParametricStepFunction.h. ◆ evaluate(). double RooParametricStepFunction::evaluate ; (; ); const. overrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 189 of file RooParametricStepFunction.cxx. ◆ getAnalyticalIntegral(). Int_t RooParametricStepFunction::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 127 of file RooParametricStepFunction.cxx. ◆ getLimits(). double * RooParametricStepFunction::getLimits ; (; ). inline . Definition at line 40 of file RooParametricStepFunction.h. ◆ getnBins(). Int_t RooParametricStepFunction::getnBins ; (; ); const. inline . Definition at line 39 of file RooParametricStepFunction.h. ◆ IsA(). TClass * RooParametricStepFunction::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 55 of file RooParametricStepFunction.h. ◆ lastBinValue(). double RooParametricStepFunction::lastBinValue ; (; ); const. protected . Definition at line 174 of file RooParametricStepFunction.cxx. ◆ plotSamplingHint(). std::list< double > * RooParametricStepFunction::plotSamplingHint ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Interface for returning an optional hint fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooParametricStepFunction.html:80501,perform,performed,80501,doc/master/classRooParametricStepFunction.html,https://root.cern,https://root.cern/doc/master/classRooParametricStepFunction.html,1,['perform'],['performed']
Performance,class IBaseParam. More...;  ; class  IGradientFunctionMultiDimTempl;  Interface (abstract class) for multi-dimensional functions providing a gradient calculation. More...;  ; class  IGradientFunctionOneDim;  Interface (abstract class) for one-dimensional functions providing a gradient calculation. More...;  ; class  IGradientMultiDimTempl;  ; class  IMinimizer1D;  Interface class for numerical methods for one-dimensional minimization. More...;  ; class  IntegrandTransform;  Auxiliary inner class for mapping infinite and semi-infinite integrals. More...;  ; class  IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  Interpolator;  Class for performing function interpolation of points. More...;  ; class  Inverter;  Matrix Inverter class Class to specialize calls to Dinv. More...;  ; class  Inverter< 0 >;  Inverter<0>. More...;  ; class  Inverter< 1 >;  1x1 matrix inversion \(a_{11} \to 1/a_{11}\) More...;  ; class  Inverter< 2 >;  2x2 matrix inversion using Cramers rule. More...;  ; class  IOptions;  Generic interface for defining configuration options of a numerical algorithm. More...;  ; class  IParametricFunctionMultiDimTempl;  IParamFunction interface (abstract class) describing multi-dimensional parametric functions It is a derived class from ROOT::Math::IBaseFunctionMultiDim and ROOT::Math::IBaseParam. More...;  ; class  IParametricFunctionOneDim;  Specialized IParamFunction interface (abstract class) for one-dimensional parametric functions It is a derived class from ROOT::Math::IBaseFunctionOneDim and ROOT::Math::IBaseParam. More...;  ; class  IParametricGradFunctionMultiDimTempl;  Interface (abstract class) for parame,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:17582,perform,performing,17582,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['perform'],['performing']
Performance,"class charts. ROOT; » ROOSTATS; » RooStats::PdfProposal. class RooStats::PdfProposal: public RooStats::ProposalFunction. PdfProposal is a concrete implementation of the ProposalFunction interface.; It proposes points across the parameter space in the distribution of the; given PDF. To make Propose(xPrime, x) dependent on x, configure with; PdfProposal::AddMapping(varToUpdate, valueToUse). For example, suppose we have:. // our parameter; RooRealVar p(""p"", ""p"", 5, 0, 10);; // create mean and sigma for gaussian proposal function; RooRealVar meanP(""meanP"", ""meanP"", 0, 10);; RooRealVar sigma(""sigma"", ""sigma"", 1, 0, 5);; RooGaussian pGaussian(""pGaussian"", ""pGaussian"", p, meanP, sigma);; // configure proposal function; PdfProposal pdfProposal(pGaussian);; pdfProposal.AddMapping(meanP, p); // each call of Propose(xPrime, x), meanP in; // the proposal function will be updated to; // the value of p in x. this will center the; // proposal function about x's p when; // proposing for xPrime; // To improve performance, PdfProposal has the ability to cache a specified; // number of proposals. If you don't call this function, the default cache size; // is 1, which can be slow.; pdfProposal.SetCacheSize(desiredCacheSize);. PdfProposal currently uses a fixed cache size. Adaptive caching methods are in the works; for future versions. Function Members (Methods); public:. virtual~PdfProposal(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddMapping(RooRealVar& proposalParam, RooAbsReal& update); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual boolRooStats::ProposalFunction::CheckParameters(RooArgSet& params); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__PdfProposal.html:1226,perform,performance,1226,root/html528/RooStats__PdfProposal.html,https://root.cern,https://root.cern/root/html528/RooStats__PdfProposal.html,2,"['cache', 'perform']","['cache', 'performance']"
Performance,"class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:1188,cache,cache,1188,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,2,['cache'],['cache']
Performance,"class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:1212,cache,cache,1212,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,1,['cache'],['cache']
Performance,"class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:1188,cache,cache,1188,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,3,['cache'],['cache']
Performance,"class for the geometry package.; TGeoManager class is embedding all the API needed for building and tracking a geometry. It defines a global pointer (gGeoManager) in order to be fully accessible from external code. The mechanism of handling multiple geometries at the same time will be soon implemented.; TGeoManager is the owner of all geometry objects defined in a session, therefore users must not try to control their deletion. It contains lists of media, materials, transformations, shapes and volumes. Logical nodes (positioned volumes) are created and destroyed by the TGeoVolume class. Physical nodes and their global transformations are subjected to a caching mechanism due to the sometimes very large memory requirements of logical graph expansion. The caching mechanism is triggered by the total number of physical instances of volumes and the cache manager is a client of TGeoManager. The manager class also controls the painter client. This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions. Rules for building a valid geometry; A given geometry can be built in various ways, but there are mandatory steps that have to be followed in order to be validated by the modeler. There are general rules : volumes needs media and shapes in order to be created, both container and containee volumes must be created before linking them together, and the relative transformation matrix must be provided. All branches must have an upper link point otherwise they will not be considered as part of the geometry. Visibility or tracking properties of volumes can be provided both at build time or after geometry is closed, but global visualization settings (see TGeoPainter class) should not be provided at build time, otherwise the drawing package will be loaded. There is also a list of specific rules : positioned daughters should not extrude their mother or intersect with sisters unless this is specified (see TGeoVolume::AddNodeOverlap()), the top ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:13944,load,loaded,13944,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['load'],['loaded']
Performance,"class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*TProof::CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TStringGetJobAd(); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*TProof::MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, TString& emsg); virtual voidTProof::SendInputDataFile(); voidTProof::SetDSet(TDSet* dset); voidTProof::SetPlayer(TVirtualProofPlayer* player); static void*TProof::SlaveStartupThread(void* arg); virtual Bool_tStartSlaves(Bool_t); static voidTProof::SystemCmd(const char* cmd, Int_t fdout); voidTProof::UpdateDialog(); virtual voidTProof::ValidateDSet(TDSet* dset).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofCondor.html:20846,cache,cachedir,20846,root/html530/TProofCondor.html,https://root.cern,https://root.cern/root/html530/TProofCondor.html,2,['cache'],['cachedir']
Performance,"class-dependent behavior after server redirection, e.g. resetting of caches. The return value is meant to be an error flag, so in case something goes wrong the function should return true. If you overload this function, don't forget to also call the function of the base class.; See alsoredirectServers() For a detailed explanation of the function parameters. ; Reimplemented in RooAddPdf, RooDerivative, RooProdPdf, RooProfileLL, RooFormulaVar, RooGenericPdf, RooNumConvolution, RooRealIntegral, RooResolutionModel, RooAbsOptTestStatistic, RooAbsTestStatistic, RooAbsPdf, RooAbsReal, and RooProjectedPdf.; Definition at line 1313 of file RooAbsArg.cxx. ◆ registerCache(). void RooAbsArg::registerCache ; (; RooAbsCache & ; cache). Register RooAbsCache with this object. ; This function is called by RooAbsCache constructors for objects that are a datamember of this RooAbsArg. By registering itself the RooAbsArg is aware of all its cache data members and will forward server change and cache mode change calls to the cache objects, which in turn can forward them their contents ; Definition at line 2117 of file RooAbsArg.cxx. ◆ registerProxy() [1/3]. void RooAbsArg::registerProxy ; (; RooArgProxy & ; proxy). protected . Register an RooArgProxy in the proxy list. ; This function is called by owned proxies upon creation. After registration, this arg will forward pointer changes from serverRedirects and updates in cached normalization sets to the proxies immediately after they occur. The proxied argument is also added as value and/or shape server ; Definition at line 1329 of file RooAbsArg.cxx. ◆ registerProxy() [2/3]. void RooAbsArg::registerProxy ; (; RooListProxy & ; proxy). protected . Register an RooListProxy in the proxy list. ; This function is called by owned proxies upon creation. After registration, this arg will forward pointer changes from serverRedirects and updates in cached normalization sets to the proxies immediately after they occur. ; Definition at line 1408 of file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:92142,cache,cache,92142,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,3,['cache'],['cache']
Performance,"class; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tfTypebranch type; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchElement(); -- Default and I/O constructor. TBranchElement(TTree *tree, const char* bname, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize, Int_t splitlevel, Int_t btype); FIXME: What if the streamer info is optimized here?; -- Constructor when the branch object is not a TClonesArray nor an STL container. If splitlevel > 0 this branch in turn is split into sub-branches. TBranchElement(TBranch *parent, const char* bname, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize, Int_t splitlevel, Int_t btype); FIXME: What if the streamer info is optimized here?; -- Constructor when the branch object is not a TClonesArray nor an STL container. If splitlevel > 0 this branch in turn is split into sub-branches. void Init(TTree* tree, TBranch* parent, const char* name, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t btype = 0); -- Init when the branch object is not a TClonesArray nor an STL container. If splitlevel > 0 this branch in turn is split into sub-branches. TBranchElement(TTree *tree, const char* bname, TClonesArray* clones, Int_t basketsize, Int_t splitlevel, Int_t compress); FIXME: Bad, the streamer info will be optimized here.; -- Constructor when the branch object is a TClonesArray. If splitlevel > 0 this branch in turn is split into sub branches. TBranchElement(TBranch *parent, const char* bname, TClonesArray* clones, Int_t basketsize, Int_t splitlevel, Int_t compress); FIXME: Bad, the streamer info will be optimized here.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranchElement.html:16602,optimiz,optimized,16602,root/html526/TBranchElement.html,https://root.cern,https://root.cern/root/html526/TBranchElement.html,1,['optimiz'],['optimized']
Performance,"cle="""") override;  Delete object namecycle. ;  ; void Draw (Option_t *option="""") override;  Fill Graphics Structure and Paint. ;  ; virtual void DrawMap (const char *keys=""*"", Option_t *option="""");  Draw map of objects in this file. ;  ; void FillBuffer (char *&buffer) override;  Encode file output buffer. ;  ; virtual void Flush ();  Synchronize a file's in-memory and on-disk states. ;  ; TArchiveFile * GetArchive () const;  ; Long64_t GetArchiveOffset () const;  ; Int_t GetBestBuffer () const;  Return the best buffer size of objects on this file. ;  ; virtual Long64_t GetBytesRead () const;  ; virtual Long64_t GetBytesReadExtra () const;  ; virtual Int_t GetBytesToPrefetch () const;  Max number of bytes to prefetch. ;  ; virtual Long64_t GetBytesWritten () const;  Return the total number of bytes written so far to the file. ;  ; TFileCacheRead * GetCacheRead (const TObject *tree=nullptr) const;  Return a pointer to the current read cache. ;  ; TFileCacheWrite * GetCacheWrite () const;  Return a pointer to the current write cache. ;  ; TArrayC * GetClassIndex () const;  ; Int_t GetCompressionAlgorithm () const;  ; Float_t GetCompressionFactor ();  Return the file compression factor. ;  ; Int_t GetCompressionLevel () const;  ; Int_t GetCompressionSettings () const;  ; virtual Long64_t GetEND () const;  ; virtual const TUrl * GetEndpointUrl () const;  ; virtual Int_t GetErrno () const;  Method returning errno. ;  ; Int_t GetFd () const;  ; TList * GetListOfFree () const;  ; TObjArray * GetListOfProcessIDs () const;  ; virtual Int_t GetNbytesFree () const;  ; virtual Int_t GetNbytesInfo () const;  ; virtual Int_t GetNfree () const;  ; virtual Int_t GetNProcessIDs () const;  ; Option_t * GetOption () const override;  ; virtual Int_t GetReadCalls () const;  ; Int_t GetRecordHeader (char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header starting at a certain postion. ;  ; Long64_t GetRelOffset () const;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixFile.html:3794,cache,cache,3794,doc/master/classTDavixFile.html,https://root.cern,https://root.cern/doc/master/classTDavixFile.html,1,['cache'],['cache']
Performance,"cle="""") override;  Delete object namecycle. ;  ; void Draw (Option_t *option="""") override;  Fill Graphics Structure and Paint. ;  ; virtual void DrawMap (const char *keys=""*"", Option_t *option="""");  Draw map of objects in this file. ;  ; void FillBuffer (char *&buffer) override;  Encode file output buffer. ;  ; virtual void Flush ();  Synchronize a file's in-memory and on-disk states. ;  ; TArchiveFile * GetArchive () const;  ; Long64_t GetArchiveOffset () const;  ; Int_t GetBestBuffer () const;  Return the best buffer size of objects on this file. ;  ; virtual Long64_t GetBytesRead () const;  ; virtual Long64_t GetBytesReadExtra () const;  ; virtual Int_t GetBytesToPrefetch () const;  Max number of bytes to prefetch. ;  ; virtual Long64_t GetBytesWritten () const;  Return the total number of bytes written so far to the file. ;  ; TFileCacheRead * GetCacheRead (const TObject *tree=nullptr) const;  Return a pointer to the current read cache. ;  ; TFileCacheWrite * GetCacheWrite () const;  Return a pointer to the current write cache. ;  ; TArrayC * GetClassIndex () const;  ; Int_t GetCompressionAlgorithm () const;  ; Float_t GetCompressionFactor ();  Return the file compression factor. ;  ; Int_t GetCompressionLevel () const;  ; Int_t GetCompressionSettings () const;  ; virtual Long64_t GetEND () const;  ; virtual const TUrl * GetEndpointUrl () const;  ; virtual Int_t GetErrno () const;  Method returning errno. ;  ; Int_t GetFd () const;  ; TList * GetListOfFree () const;  ; TObjArray * GetListOfProcessIDs () const;  ; virtual Int_t GetNbytesFree () const;  ; virtual Int_t GetNbytesInfo () const;  ; virtual TString GetNewUrl ();  ; virtual Int_t GetNfree () const;  ; virtual Int_t GetNProcessIDs () const;  ; Option_t * GetOption () const override;  ; virtual Int_t GetReadCalls () const;  ; Int_t GetRecordHeader (char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header starting at a certain postion. ;  ; Lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TBufferMergerFile.html:4994,cache,cache,4994,doc/v632/classROOT_1_1TBufferMergerFile.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TBufferMergerFile.html,10,['cache'],['cache']
Performance,"client.; It is is possible to specify options for the loading step via 'loadopts';; the string will be passed passed as argument to SETUP.; Special option 'chkv=<o>' (or 'checkversion=<o>') can be used to control; plugin version checking during building: possible choices are:; off no check; failure may occur at loading; on check ROOT version [default]; svn check ROOT version and SVN revision number.; (Use ';', ' ' or '|' to separate 'chkv=<o>' from the rest.); If specified, enables packages only on the specified workers.; Returns 0 in case of success and -1 in case of error. Int_t EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; It is is possible to specify a list of objects to be passed to the SETUP; functions via 'loadopts'; the objects must be streamable.; Returns 0 in case of success and -1 in case of error. Int_t DownloadPackage(const char* par, const char* dstdir = 0); Download a PROOF archive (PAR file) from the master package repository.; The PAR file is downloaded in the current directory or in the directory; specified by 'dstdir'. If a package with the same name already exists; at destination, a check on the MD5 sum is done and the user warned or; prompted for action, depending is the file is equal or different.; Returns 0 in case of success and -1 in case of error. Int_t UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar, TList* workers = 0); Upload a PROOF archive (PAR file). A PAR file is a compressed; tar file with one special additional directory, PROOF-INF; (blatantly copied from Java's jar format). It must have the extension; .par. A PAR file can be directly a binary or a source with a build; procedure. In the PROOF-INF directory there ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:75735,load,loadopts,75735,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,1,['load'],['loadopts']
Performance,clientListValue ; RooAbsReal*_cloneModelPointer to cloned model; RooAbsReal*_clonePdfPointer to cloned PDF ; RooAbsReal*_cloneVarPointer to cloned convolution variable; RooNumIntConfig_convIntConfigConfiguration of numeric convolution integral ;; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_t_doProfSwitch to activate profiling option; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; RooConvIntegrandBinding*_integrand! Binding of Convolution Integrand function; RooAbsIntegrator*_integrator! Numeric integrator of convolution integrand; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooRealProxy_origModelOriginal resolution model; RooRealProxy_origPdfOriginal input PDF; RooRealProxy_origVarOriginal convolution variable; RooArgSet_ownedClonedModelSetOwning set of cloned model components; RooArgSet_ownedClonedPdfSetOwning set of cloned PDF components; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of p,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvolution.html:33765,cache,cache,33765,root/html526/RooNumConvolution.html,https://root.cern,https://root.cern/root/html526/RooNumConvolution.html,3,['cache'],['cache']
Performance,clientListValue ; RooAbsReal*_cloneModelPointer to cloned model; RooAbsReal*_clonePdfPointer to cloned PDF ; RooAbsReal*_cloneVarPointer to cloned convolution variable; RooNumIntConfig_convIntConfigConfiguration of numeric convolution integral ;; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_t_doProfSwitch to activate profiling option; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; RooConvIntegrandBinding*_integrand! Binding of Convolution Integrand function; RooAbsIntegrator*_integrator! Numeric integrator of convolution integrand; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooRealProxy_origModelOriginal resolution model; RooRealProxy_origPdfOriginal input PDF; RooRealProxy_origVarOriginal convolution variable; RooArgSet_ownedClonedModelSetOwning set of cloned model components; RooArgSet_ownedClonedPdfSetOwning set of cloned PDF components; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumConvolution.html:34807,cache,cache,34807,root/html532/RooNumConvolution.html,https://root.cern,https://root.cern/root/html532/RooNumConvolution.html,1,['cache'],['cache']
Performance,clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealProxyRooAbsAnaConvPdf::_convVarConvolution variable; RooRealProxy_correctQ; RooRealProxy_delC; RooRealProxy_delS; RooRealProxy_delW; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; Double_t_genRhoPlusFrac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prev,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNonCPEigenDecay.html:44658,cache,cache,44658,root/html602/RooNonCPEigenDecay.html,https://root.cern,https://root.cern/root/html602/RooNonCPEigenDecay.html,2,['cache'],['cache']
Performance,"close to the edges of the spectrum region. Usually peak finders fail to detect them.; resolution, decomposition of Double_tts and multiplets. The algorithm should be able to recognise close positioned peaks.; ability to identify peaks with different sigma. Fig. 27 An example of one-dimensional synthetic spectrum with found peaks denoted by markers.; References:. M.A. Mariscotti: A method for identification of peaks in the presence of background and its application to spectrum analysis. NIM 50 (1967), 309-320.; M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky, I. Turzo.:Identification of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000) 108-125.; Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376 (1996), 451. Examples of peak searching method:; The SearchHighRes function provides users with the possibility to vary the input parameters and with the access to the output deconvolved data in the destination spectrum. Based on the output data one can tune the parameters. Example 15 - script SearchHR1.C:; One-dimensional spectrum with found peaks denoted by markers, 3 iterations steps in the deconvolution.; Script:; ; void SearchHR1() {; Double_t fPositionX[100];; Double_t fPositionY[100];; Int_t fNPeaks = 0;; Int_t i,nfound,bin;; const Int_t nbins = 1024;; Double_t xmin = 0;; Double_t xmax = nbins;; Double_t a;; Double_t source[nbins], dest[nbins];; gROOT->ForceStyle();; ; TString dir = gROOT->GetTutorialDir();; TString file = dir+""/spectrum/TSpectrum.root"";; TFile *f = new TFile(file.Data());; TH1F *h = (TH1F*) f->Get(""back2"");; h->SetTitle(""High resolution peak searching, number of iterations = 3"");; h->GetXaxis()->SetRange(1,nbins);; TH1F *d = new TH1F(""d"","""",nbins,xmin,xmax);; h->Draw(""L"");; ; for (i = 0; i < nbins; i++) source[i]=h->GetBinContent(i + 1);; ; h->Draw(""L"");; ; TSpectrum *s = new TSpectrum();; ; nfound = s->SearchHighRes(source, dest, nbins, 8, 2, kTRUE, 3, kTRUE, 3);; Double_t *xpeaks = s->GetPositionX();;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum.html:58694,tune,tune,58694,doc/master/classTSpectrum.html,https://root.cern,https://root.cern/doc/master/classTSpectrum.html,1,['tune'],['tune']
Performance,"clude:. Minuit:library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits. Minuit2: new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions. ; Fumili: library providing the implementation of the original Fumili fitting algorithm. Linear algebra. Two libraries are contained in ROOT for describing linear algebra matrices and vector classes:. Matrix: general matrix package providing matrix TMatrix and vector TVector classes and the complete environment to perform linear algebra calculations, like equation solving and eigenvalue decompositions.; SMatrix: package optimized for high performances matrix and vector computations of small and fixed size. It is based on expression templates to achieve an high level optimization. Physics Vectors: classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:. Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. Unuran: package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions. ; Foam: multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW: library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of (FFTW).; MLP: library with the neural ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/MATH_Index.html:2801,optimiz,optimized,2801,root/html602/MATH_Index.html,https://root.cern,https://root.cern/root/html602/MATH_Index.html,4,"['optimiz', 'perform']","['optimized', 'performances']"
Performance,"cludes; Libraries. Function documentation; TAttAxis(); Constructor. ~TAttAxis(); Destructor. void Copy(TAttAxis& attaxis) const; Copy of the object. void ResetAttAxis(Option_t* option = """"); Reset axis attributes. void SaveAttributes(ostream& out, const char* name, const char* subname); Save axis attributes as C++ statement(s) on output stream out. void SetAxisColor(Color_t color = 1, Float_t alpha = 1.); Set color of the line axis and tick marks. void SetLabelColor(Color_t color = 1, Float_t alpha = 1.); Set color of labels. void SetLabelFont(Style_t font = 62); Set labels' font. void SetLabelOffset(Float_t offset = 0.005); Set distance between the axis and the labels; The distance is expressed in per cent of the pad width. void SetLabelSize(Float_t size = 0.04); Set size of axis labels; The size is expressed in per cent of the pad width. void SetNdivisions(Int_t n = 510, Bool_t optim = kTRUE); Set the number of divisions for this axis. if optim = kTRUE (default), the number of divisions will be; optimized around the specified value.; if optim = kFALSE, or n < 0, the axis will be forced to use; exactly n divisions. n = n1 + 100*n2 + 10000*n3. Where n1 is the number of primary divisions,; n2 is the number of second order divisions and; n3 is the number of third order divisions. e.g. 512 means 12 primary and 5 secondary divisions. If the number of divisions is ""optimized"" (see above) n1, n2, n3 are; maximum values. void SetNdivisions(Int_t n1, Int_t n2, Int_t n3, Bool_t optim = kTRUE); see function above. void SetTickLength(Float_t length = 0.03); Set tick mark length; The length is expressed in per cent of the pad width. void SetTitleOffset(Float_t offset = 1); Set distance between the axis and the axis title; Offset is a correction factor with respect to the ""standard"" value.; offset = 1 uses the default position that is computed in function; of the label offset and size.; offset = 1.2 will add 20 per cent more to the default offset. void SetTitleSize(Float_t size =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TAttAxis.html:3480,optimiz,optimized,3480,root/html534/TAttAxis.html,https://root.cern,https://root.cern/root/html534/TAttAxis.html,1,['optimiz'],['optimized']
Performance,"code features many changes compared to the Fortran version.; Note that this function is currently called only by TF2::Integral (n=2); and TF3::Integral (n=3). This function computes, to an attempted specified accuracy, the value of; the integral over an n-dimensional rectangular region. Input parameters:. n : Number of dimensions [2,15]; a,b : One-dimensional arrays of length >= N . On entry A[i], and B[i],; contain the lower and upper limits of integration, respectively.; minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; eps : Specified relative accuracy. Output parameters:. relerr : Contains, on exit, an estimation of the relative accuracy of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Rid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:58076,perform,performed,58076,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,4,['perform'],['performed']
Performance,"code should #include this directly.; 31// #include ""TObjString.h""; 32// #include ""ThreadLocalStorage.h""; 33// #include <set>; 34#endif; 35 ; 36#include <cstddef>; 37#include <map>; 38#include <string>; 39#include <unordered_set>; 40#include <vector>; 41#include <atomic>; 42 ; 43class TBaseClass;; 44class TBrowser;; 45class TDataMember;; 46class TCling;; 47class TMethod;; 48class TRealData;; 49class TBuffer;; 50class TVirtualStreamerInfo;; 51class TVirtualCollectionProxy;; 52class TMethodCall;; 53class TVirtualIsAProxy;; 54class TVirtualRefProxy;; 55class THashTable;; 56class TListOfFunctions;; 57class TListOfFunctionTemplates;; 58class TListOfDataMembers;; 59class TListOfEnums;; 60class TViewPubFunctions;; 61class TViewPubDataMembers;; 62class TFunctionTemplate;; 63class TProtoClass;; 64 ; 65namespace ROOT {; 66 class TGenericClassInfo;; 67 class TMapTypeToTClass;; 68 class TMapDeclIdToTClass;; 69 namespace Detail {; 70 class TSchemaRuleSet;; 71 class TCollectionProxyInfo;; 72 }; 73 namespace Internal {; 74 class TCheckHashRecursiveRemoveConsistency;; 75 }; 76}; 77 ; 78typedef ROOT::TMapTypeToTClass IdMap_t;; 79typedef ROOT::TMapDeclIdToTClass DeclIdMap_t;; 80 ; 81class TClass : public TDictionary {; 82 ; 83friend class TCling;; 84friend void ROOT::ResetClassVersion(TClass*, const char*, Short_t);; 85friend class ROOT::TGenericClassInfo;; 86friend class TProtoClass;; 87friend class ROOT::Internal::TCheckHashRecursiveRemoveConsistency;; 88friend class TStreamerInfo;; 89 ; 90public:; 91 // TClass status bits; 92 enum EStatusBits {; 93 kReservedLoading = BIT(7), // Internal status bits, set and reset only during initialization; 94 ; 95 /* had kClassSaved = BIT(12), */; 96 kHasLocalHashMember = BIT(14),; 97 kIgnoreTObjectStreamer = BIT(15),; 98 kUnloaded = BIT(16), // The library containing the dictionary for this class was; 99 // loaded and has been unloaded from memory.; 100 kIsTObject = BIT(17),; 101 kIsForeign = BIT(18),; 102 /* had kIsEmulation = BIT(19), // Depreca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:2935,load,loaded,2935,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,2,['load'],['loaded']
Performance,"coefList, Int_t lowestOrder = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPolyVar.html:24285,cache,cache,24285,root/html602/RooPolyVar.html,https://root.cern,https://root.cern/root/html602/RooPolyVar.html,2,['cache'],['cache']
Performance,"coefficients. ; [in]verboseIf this function will log to the standard output when comparisons fail. As the relative tolerance for the parameter errors, the default value of 1e-3 will be used. ; Definition at line 863 of file RooFitResult.cxx. ◆ isIdenticalNoCov(). bool RooFitResult::isIdenticalNoCov ; (; const RooFitResult & ; other, . double ; tol = 1e-6, . double ; tolErr = 1e-3, . bool ; verbose = true . ); const. Return true if this fit result is identical to other within tolerances, ignoring the correlation matrix. ; Parameters. [in]otherFit result to test against. ; [in]tolRelative tolerance for parameters and NLL. ; [in]tolErrRelative tolerance for parameter errors. ; [in]verboseIf this function will log to the standard output when comparisons fail. . Definition at line 801 of file RooFitResult.cxx. ◆ lastMinuitFit(). RooFitResult * RooFitResult::lastMinuitFit ; (; const RooArgList & ; varList = RooArgList()). static . Import the results of the last fit performed by gMinuit, interpreting the fit parameters as the given varList of parameters. ; Definition at line 917 of file RooFitResult.cxx. ◆ minNll(). double RooFitResult::minNll ; (; ); const. inline . Return minimized -log(L) value. ; Definition at line 99 of file RooFitResult.h. ◆ numInvalidNLL(). Int_t RooFitResult::numInvalidNLL ; (; ); const. inline . Return number of NLL evaluations with problems. ; Definition at line 91 of file RooFitResult.h. ◆ numStatusHistory(). UInt_t RooFitResult::numStatusHistory ; (; ); const. inline . Definition at line 82 of file RooFitResult.h. ◆ plotOn() [1/2]. RooPlot * RooFitResult::plotOn ; (; RooPlot * ; frame, . const RooAbsArg & ; par1, . const RooAbsArg & ; par2, . const char * ; options = ""ME"" . ); const. inline . Add objects to a 2D plot. ; Plot error ellipse in par1 and par2 on frame. ; Definition at line 144 of file RooFitResult.h. ◆ plotOn() [2/2]. RooPlot * RooFitResult::plotOn ; (; RooPlot * ; frame, . const char * ; parName1, . const char * ; parName2, . const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFitResult.html:30818,perform,performed,30818,doc/master/classRooFitResult.html,https://root.cern,https://root.cern/doc/master/classRooFitResult.html,1,['perform'],['performed']
Performance,"column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs.; WarningBy default, RDataFrame will use as many threads as the hardware supports, using up all the resources on a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use ROOT::EnableImplicitMT(i); replacing i with the number of CPUs/slots that were allocated for this job. Thread-safety of user-defined expressions; RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops. User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate() will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define() expressions will often be pure in the functional programming sense (no side-effects, no dependency on external state), which eliminates all risks of race conditions.; In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or OnPartialResult() offer thread-aware counterparts (ForeachSlot(), DefineSlot(), OnPartialResultSlot()): their only difference is that they will pass an extra slot argument (an unsigned integer) to the user-defined expression. When calling user-defined code concurrently, RDataFrame guarantees that different threads will employ different values of the slot parameter, where slot will be a number between 0 and GetNSlots() - 1. In other words, within a slot, computation runs sequentially and events are processed sequentially. Note that the same slot might be associated to different threads over the course of a single event loop, but two threads will never receive the same slot at the same time. This extra parameter might facilitate writi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:46924,race condition,race conditions,46924,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['race condition'],['race conditions']
Performance,"compinfo));; 3529 }; 3530 } else if (generic); 3531 readSequence->AddAction(GenericReadAction, new TGenericConfiguration(this, i, compinfo));; 3532}; 3533 ; 3534////////////////////////////////////////////////////////////////////////////////; 3535/// Add a read action for the given element.; 3536/// This is for streaming via a TClonesArray (or a vector of pointers of this type).; 3537 ; 3538void TStreamerInfo::AddReadMemberWiseVecPtrAction(TStreamerInfoActions::TActionSequence *readSequence, Int_t i, TStreamerInfo::TCompInfo *compinfo); 3539{; 3540 TStreamerElement *element = compinfo->fElem;; 3541 ; 3542 if (element->TestBit(TStreamerElement::kWrite)) return;; 3543 ; 3544 if (element->TestBit(TStreamerElement::kCache)) {; 3545 TConfiguredAction action( GetCollectionReadAction<VectorLooper>(this,element,compinfo->fType,i,compinfo,compinfo->fOffset) );; 3546 readSequence->AddAction( UseCacheVectorPtrLoop, new TConfigurationUseCache(this,action,element->TestBit(TStreamerElement::kRepeat)) );; 3547 } else {; 3548 readSequence->AddAction( GetCollectionReadAction<VectorPtrLooper>(this,element,compinfo->fType,i,compinfo,compinfo->fOffset) );; 3549 }; 3550}; 3551 ; 3552////////////////////////////////////////////////////////////////////////////////; 3553 ; 3554void TStreamerInfo::AddWriteAction(TStreamerInfoActions::TActionSequence *writeSequence, Int_t i, TStreamerInfo::TCompInfo *compinfo); 3555{; 3556 TStreamerElement *element = compinfo->fElem;; 3557 if (element->TestBit(TStreamerElement::kCache) && !element->TestBit(TStreamerElement::kWrite)) {; 3558 // Skip element cached for reading purposes.; 3559 return;; 3560 }; 3561 if (element->GetType() >= kArtificial && !element->TestBit(TStreamerElement::kWrite)) {; 3562 // Skip artificial element used for reading purposes.; 3563 return;; 3564 }; 3565 switch (compinfo->fType) {; 3566 // write basic types; 3567 case TStreamerInfo::kBool: writeSequence->AddAction( WriteBasicType<Bool_t>, new TConfiguration(this,i,compinfo,comp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:162365,cache,cached,162365,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['cache'],['cached']
Performance,"configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:4964,cache,cache,4964,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,6,['cache'],['cache']
Performance,"configure usage of special thread of processing of http server requests WebGui.HttpThrd: no; Extra threads can be used to send data to different clients via websocket (default no) WebGui.SenderThrds: no; If required, one could change websocket timeouts (default is 10000 ms) WebGui.HttpWSTmout: 10000; By default, THttpServer created in restricted mode which only allows websocket handlers and processes only very few other related http requests. For security reasons such mode should be always enabled. Only if it is really necessary to process all other kinds of HTTP requests, one could specify no for following parameter (default yes): WebGui.WSOnly: yes; In some applications one may need to force longpoll websocket emulations from the beginning, for instance when clients connected via proxys. Although JSROOT should automatically fallback to longpoll engine, one can configure this directly (default no) WebGui.WSLongpoll: no; Following parameter controls browser max-age caching parameter for files (default 3600) When 0 is specified, browser cache will be disabled WebGui.HttpMaxAge: 3600; Also one can provide extra URL options for, see TCivetweb::Create for list of supported options WebGui.HttpExtraArgs: winsymlinks=no; One also can configure usage of FastCGI server for web windows: WebGui.FastCgiPort: 4000; WebGui.FastCgiThreads: 10; To be able start web browser for such windows, one can provide real URL of the web server which will connect with that FastCGI instance: WebGui.FastCgiServer: https://your_apache_server.com/root_cgi_path. Definition at line 351 of file RWebWindowsManager.cxx. ◆ CreateWindow(). std::shared_ptr< RWebWindow > RWebWindowsManager::CreateWindow ; (; ). Creates new window To show window, RWebWindow::Show() have to be called. ; Definition at line 536 of file RWebWindowsManager.cxx. ◆ GenerateKey(). std::string RWebWindowsManager::GenerateKey ; (; int ; keylen = 32). staticprivate . Static method to generate cryptographic key Parameter keylen defines ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html:9795,cache,cache,9795,doc/v632/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html,1,['cache'],['cache']
Performance,"configure usage of special thread of processing of http server requests WebGui.HttpThrd: no; Extra threads can be used to send data to different clients via websocket (default no) WebGui.SenderThrds: no; If required, one could change websocket timeouts (default is 10000 ms) WebGui.HttpWSTmout: 10000; By default, THttpServer created in restricted mode which only allows websocket handlers and processes only very few other related http requests. For security reasons such mode should be always enabled. Only if it is really necessary to process all other kinds of HTTP requests, one could specify no for following parameter (default yes): WebGui.WSOnly: yes; In some applications one may need to force longpoll websocket emulations from the beginning, for instance when clients connected via proxys. Although JSROOT should automatically fallback to longpoll engine, one can configure this directly (default no) WebGui.WSLongpoll: no; Following parameter controls browser max-age caching parameter for files (default 3600) When 0 is specified, browser cache will be disabled WebGui.HttpMaxAge: 3600; Also one can provide extra URL options for, see TCivetweb::Create for list of supported options WebGui.HttpExtraArgs: winsymlinks=no; One also can configure usage of FastCGI server for web windows: WebGui.FastCgiPort: 4000; WebGui.FastCgiThreads: 10; To be able start web browser for such windows, one can provide real URL of the web server which will connect with that FastCGI instance: WebGui.FastCgiServer: https://your_apache_server.com/root_cgi_path; For some custom applications one requires to load JavaScript modules or other files. For such applications one may require to load files from other locations which can be configured with AddServerLocation() method or directly via: WebGui.ServerLocations: location1:/file/path/to/location1;location2:/file/path/to/location2 . Definition at line 430 of file RWebWindowsManager.cxx. ◆ CreateWindow(). std::shared_ptr< RWebWindow > RWebWindowsManage",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html:11363,cache,cache,11363,doc/master/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html,1,['cache'],['cache']
Performance,"connections.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. TPServerSocket(const char* service, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); Create a parallel server socket object for a named service. Set reuse; to true to force reuse of the server socket (i.e. do not wait for the; time out to pass). Using backlog one can set the desirable queue length; for pending connections.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. TSocket * Accept(UChar_t Opt = kSrvNoAuth); Accept a connection on a parallel server socket. Returns a full-duplex; parallel communication TPSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call bloc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPServerSocket.html:11738,queue,queue,11738,root/html528/TPServerSocket.html,https://root.cern,https://root.cern/root/html528/TPServerSocket.html,6,['queue'],['queue']
Performance,"consider only negatively charged muons with a pseudorapidity; 1377smaller or equal to 2 and with a transverse momentum greater than 10 GeV.; 1378Such a selection would require, among the other things, the management of an explicit; 1379loop, for example:; 1380~~~{.cpp}; 1381std::vector<float> goodMuons_pt;; 1382const auto size = mu_charge.size();; 1383for (size_t i=0; i < size; ++i) {; 1384 if (mu_pt[i] > 10 && abs(mu_eta[i]) <= 2. && mu_charge[i] == -1) {; 1385 goodMuons_pt.emplace_back(mu_pt[i]);; 1386 }; 1387}; 1388~~~; 1389These operations become straightforward with RVec - we just need to *write what; 1390we mean*:; 1391~~~{.cpp}; 1392auto goodMuons_pt = mu_pt[ (mu_pt > 10.f && abs(mu_eta) <= 2.f && mu_charge == -1) ]; 1393~~~; 1394Now the clean collection of transverse momenta can be used within the rest of the data analysis, for; 1395example to fill a histogram.; 1396 ; 1397\anchor operationsandfunctions; 1398## Arithmetic operations, logical operations and mathematical functions; 1399Arithmetic operations on RVec instances can be performed: for example, they can be added, subtracted, multiplied.; 1400~~~{.cpp}; 1401RVec<double> v1 {1.,2.,3.,4.};; 1402RVec<float> v2 {5.f,6.f,7.f,8.f};; 1403auto v3 = v1+v2;; 1404auto v4 = 3 * v1;; 1405~~~; 1406The supported operators are ; 1407 - +, -, *, /; 1408 - +=, -=, *=, /=; 1409 - <, >, ==, !=, <=, >=, &&, ||; 1410 - ~, !; 1411 - &, |, ^; 1412 - &=, |=, ^=; 1413 - <<=, >>=; 1414 ; 1415The most common mathematical functions are supported. It is possible to invoke them passing ; 1416RVecs as arguments.; 1417 - abs, fdim, fmod, remainder; 1418 - floor, ceil, trunc, round, lround, llround; 1419 - exp, exp2, expm1; 1420 - log, log10, log2, log1p; 1421 - pow; 1422 - sqrt, cbrt; 1423 - sin, cos, tan, asin, acos, atan, atan2, hypot; 1424 - sinh, cosh, tanh, asinh, acosh; 1425 - erf, erfc; 1426 - lgamma, tgamma; 1427 ; 1428If the VDT library is available, the following functions can be invoked. Internally the calculations; 1429ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:49241,perform,performed,49241,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['perform'],['performed']
Performance,"const & ; normSet, . RooAbsArg const & ; server . ); const. private . Definition at line 2281 of file RooProdPdf.cxx. ◆ findPdfNSet(). RooArgSet * RooProdPdf::findPdfNSet ; (; RooAbsPdf const & ; pdf); const. Look up user specified normalization set for given input PDF component. ; Definition at line 1852 of file RooProdPdf.cxx. ◆ fixRefRange(). void RooProdPdf::fixRefRange ; (; const char * ; rangeName). Definition at line 2096 of file RooProdPdf.cxx. ◆ forceAnalyticalInt(). bool RooProdPdf::forceAnalyticalInt ; (; const RooAbsArg & ; dep); const. overridevirtual . Force RooRealIntegral to offer all observables for internal integration. ; Reimplemented from RooAbsReal.; Definition at line 1580 of file RooProdPdf.cxx. ◆ genContext(). RooAbsGenContext * RooProdPdf::genContext ; (; const RooArgSet & ; vars, . const RooDataSet * ; prototype = nullptr, . const RooArgSet * ; auxProto = nullptr, . bool ; verbose = false . ); const. overrideprivatevirtual . Return generator context optimized for generating events from product p.d.f.s. ; Reimplemented from RooAbsPdf.; Definition at line 1695 of file RooProdPdf.cxx. ◆ generateEvent(). void RooProdPdf::generateEvent ; (; Int_t ; code). overridevirtual . Generate a single event with configuration specified by 'code' Defer internal generation to components as encoded in the _genCode registry for given generator code. ; Reimplemented from RooAbsPdf.; Definition at line 1767 of file RooProdPdf.cxx. ◆ getAnalyticalIntegralWN(). Int_t RooProdPdf::getAnalyticalIntegralWN ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Determine which part (if any) of given integral can be performed analytically. ; If any analytical integration is possible, return integration scenario code.; RooProdPdf implements two strategies in implementing analytical integrals; First, PDF components whose entire set of dependents are requested to be integrated c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:90969,optimiz,optimized,90969,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,1,['optimiz'],['optimized']
Performance,"const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidsetAsymError(Double_t lo, Double_t hi); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const char* rangeName = 0); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const RooAbsBinning& binning); virtual voidRooAbsRealLValue::setBinFast(Int_t ibin, const RooAbsBinning& binning); voidsetBinning(const RooAbsBinning& binning, const char* name = 0); voidsetBins(Int_t nBins, const char* name = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidRooAbsRealLValue::setConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidsetError(Double_t value); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetMax(Double_t value); voidsetMax(const char* name, Double_t value); voidsetMin(Double_t value); voidsetMin(const char* name, Double_t value); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidsetRange(Double_t min, Double_t max); voidsetRange(RooAbsReal& min, RooAbsReal& max); voidsetRange(const char* name, Double_t min, Double_t max); voidsetRange(const char* name, RooAbsReal& min, RooAbsReal& max); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealVar.html:27185,cache,cache,27185,root/html526/RooRealVar.html,https://root.cern,https://root.cern/root/html526/RooRealVar.html,1,['cache'],['cache']
Performance,"const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual RooAbsGenContext*RooAbsPdf::autoGenContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """") const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; virtual RooAbsGenContext*RooAbsPdf::binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; virtual Bool_tchangeModel(const RooResolutionModel& newModel); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsAnaConvPdf.html:3987,cache,cacheUniqueSuffix,3987,root/html604/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html604/RooAbsAnaConvPdf.html,1,['cache'],['cacheUniqueSuffix']
Performance,"const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual RooAbsGenContext*RooAbsPdf::autoGenContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """") const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; virtual RooAbsGenContext*RooAbsPdf::binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooCFunction1PdfBinding_double_double_.html:2788,cache,cacheUniqueSuffix,2788,root/html604/RooCFunction1PdfBinding_double_double_.html,https://root.cern,https://root.cern/root/html604/RooCFunction1PdfBinding_double_double_.html,16,['cache'],['cacheUniqueSuffix']
Performance,"const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooBinningCategory&operator=(const RooBinningCategory&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBinningCategory.html:11184,optimiz,optimizeCacheMode,11184,root/html602/RooBinningCategory.html,https://root.cern,https://root.cern/root/html602/RooBinningCategory.html,2,['optimiz'],['optimizeCacheMode']
Performance,"const TClass* cl, Bool_t useBcnt = kFALSE). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidoperator=(const TBuffer&); virtual Int_tRead(const char* name); virtual Int_tWrite(const char* name, Int_t opt, Int_t bufs); virtual Int_tWrite(const char* name, Int_t opt, Int_t bufs) const. Data Members; public:. enum EMode { kRead; kWrite; };; enum { kIsOwner; kCannotHandleMemberWiseStreaming; kInitialSize; kMinimalSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBufCurCurrent position in buffer; char*fBufMaxEnd of buffer; Int_tfBufSizeSize of buffer; char*fBufferBuffer used to store objects; vector<TVirtualArray*>fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfModeRead or write mode; TObject*fParentPointer to parent object owning this buffer; ReAllocCharFun_tfReAllocFunc! Realloc function to be used when extending the buffer.; Int_tfVersionBuffer format version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TBuffer(); Delete an I/O buffer object. void AutoExpand(Int_t size_needed); Automatically calculate a new size and expand the buffer to fit at least size_needed.; The goals is to minimize the number of memory allocation and the memory allocation; which avoiding too much memory wastage.; If the size_needed is larger than the current size, the policy; is to expand to double the current size or the size_needed which ever is largest. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same si",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBuffer.html:16102,cache,cache,16102,root/html530/TBuffer.html,https://root.cern,https://root.cern/root/html530/TBuffer.html,3,['cache'],['cache']
Performance,"const TClass* cl, Bool_t useBcnt = kFALSE). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidoperator=(const TBuffer&); virtual Int_tRead(const char* name); virtual Int_tWrite(const char* name, Int_t opt, Int_t bufs); virtual Int_tWrite(const char* name, Int_t opt, Int_t bufs) const. Data Members; public:. enum EMode { kRead; kWrite; };; enum { kIsOwner; kCannotHandleMemberWiseStreaming; kInitialSize; kMinimalSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBufCurCurrent position in buffer; char*fBufMaxEnd of buffer; Int_tfBufSizeSize of buffer; char*fBufferBuffer used to store objects; vector<TVirtualArray*>fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Bool_tfModeRead or write mode; TObject*fParentPointer to parent object owning this buffer; ReAllocCharFun_tfReAllocFunc! Realloc function to be used when extending the buffer.; Int_tfVersionBuffer format version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TBuffer(); Delete an I/O buffer object. void SetBuffer(void* buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0); Sets a new buffer in an existing TBuffer object. If newsiz=0 then the; new buffer is expected to have the same size as the previous buffer.; The current buffer position is reset to the start of the buffer.; If the TBuffer owned the previous buffer, it will be deleted prior; to accepting the new buffer. By default the new buffer will be; adopted unless adopt is false.; If the new buffer is _not_ adopted and no memory allocation routine; is provided, a Fatal error will be issued if the Buffer attempts to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBuffer.html:15912,cache,cache,15912,root/html528/TBuffer.html,https://root.cern,https://root.cern/root/html528/TBuffer.html,1,['cache'],['cache']
Performance,"const TEmulatedCollectionProxy &);  . Friends; class TCollectionProxy;  . Additional Inherited Members;  Static Public Attributes inherited from TVirtualCollectionProxy; static const Int_t fgIteratorArenaSize = 16;  The size of a small buffer that can be allocated on the stack to store iterator-specific information. ;  ;  Protected Types inherited from TGenCollectionProxy; typedef void *(* ArrIterfunc_t) (void *from, size_t size);  ; typedef void *(* Collectfunc_t) (void *from, void *to);  ; typedef ROOT::Detail::TCollectionProxyInfo::Environ< char[64]> Env_t;  ; typedef ROOT::Detail::TCollectionProxyInfo::EnvironBase EnvironBase_t;  ; typedef void *(* Feedfunc_t) (void *from, void *to, size_t size);  ; typedef std::vector< EnvironBase_t * > Proxies_t;  ; typedef void(* Sizing_t) (void *obj, size_t size);  ; typedef std::vector< TStaging * > Staged_t;  Collection of pre-allocated staged array for associative containers. ;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEmulatedCollectionProxy.html:11242,cache,cache,11242,doc/master/classTEmulatedCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTEmulatedCollectionProxy.html,1,['cache'],['cache']
Performance,"const TGLVector3 &vAxis);  Default base camera constructor. ;  ;  ~TGLCamera () override;  Base camera destructor. ;  ; Bool_t AdjustAndClampVal (Double_t &val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const;  Adjust a passed REFERENCE value 'val', based on screenShift delta. ;  ; Double_t AdjustDelta (Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const;  Adjust a passed screen value and apply modifiers. ;  ; virtual Bool_t Dolly (Int_t delta, Bool_t mod1, Bool_t mod2);  Dolly the camera - 'move camera along eye line, retaining lens focal length'. ;  ; void DrawDebugAids () const;  Draw out some debugging aids for the camera: ;  ; TGLVector3 EyeDirection () const;  Extract the camera eye direction (vector), running from EyePoint() Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; TGLVertex3 EyePoint () const;  Return the camera eye point (vertex) in world space Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; TGLVertex3 FrustumCenter () const;  Find the center of the camera frustum from intersection of planes This method will work even with parallel left/right & top/bottom and infinite eye point of ortho cameras Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; Rgl::EOverlap FrustumOverlap (const TGLBoundingBox &box) const;  Calculate overlap (kInside, kOutside, kPartial) of box with camera frustum Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; const TGLPlane & FrustumPlane (EFrustumPlane plane) const;  ; const TGLMatrix & GetCamBase () const;  ; const TGLMatrix & GetCamTrans () const;  ; Double_t * GetCenterVec ();  ; Bool_t GetExternalCenter ();  ; Double_t GetFarClip () const;  ; Double_t * GetFixDefCenterVec ();  ; Double_t GetNearClip () const;  ; Double_t GetTheta () const;  Get angle between camer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLPerspectiveCamera.html:3358,cache,cache,3358,doc/master/classTGLPerspectiveCamera.html,https://root.cern,https://root.cern/doc/master/classTGLPerspectiveCamera.html,1,['cache'],['cache']
Performance,"const TObject * ; obj); const. overridevirtual . Find object using its hash value (returned by its Hash() member). ; Reimplemented from THashList.; Reimplemented in TListOfEnumsWithLock.; Definition at line 52 of file THashList.cxx. ◆ FindUnloaded(). TEnum * TListOfEnums::FindUnloaded ; (; const char * ; name). inlineprotected . Definition at line 64 of file TListOfEnums.h. ◆ Get(). TEnum * TListOfEnums::Get ; (; DeclId_t ; id, . const char * ; name . ). protected . Return (after creating it if necessary) the TEnum describing the enum corresponding to the Decl 'id'. ; Definition at line 205 of file TListOfEnums.cxx. ◆ GetClass(). TClass * TListOfEnums::GetClass ; (; ); const. inlineprotected . Definition at line 62 of file TListOfEnums.h. ◆ GetIds(). TExMap * TListOfEnums::GetIds ; (; ). inlineprotected . Definition at line 63 of file TListOfEnums.h. ◆ GetObject(). TEnum * TListOfEnums::GetObject ; (; const char * ; name); const. virtual . Return an object from the list of enums if and only if is has already been loaded in the list. ; This is an internal routine. ; Reimplemented in TListOfEnumsWithLock.; Definition at line 268 of file TListOfEnums.cxx. ◆ IsA(). TClass * TListOfEnums::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from THashList.; Reimplemented in TListOfEnumsWithLock.; Definition at line 95 of file TListOfEnums.h. ◆ IsLoaded(). Bool_t TListOfEnums::IsLoaded ; (; ); const. inline . Definition at line 80 of file TListOfEnums.h. ◆ Load(). void TListOfEnums::Load ; (; ). private . Load all the DataMembers known to the interpreter for the scope 'fClass' into this collection. ; Definition at line 337 of file TListOfEnums.cxx. ◆ MapObject(). void TListOfEnums::MapObject ; (; TObject * ; obj). private . Add pair<id, object> to the map of functions and their ids. ; Definition at line 56 of file TListOfEnums.cxx. ◆ operator=(). TListOfEnums & TListOfEnums::operator= ; (; const TListOfEnums & ; ). privatedelet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnums.html:29645,load,loaded,29645,doc/master/classTListOfEnums.html,https://root.cern,https://root.cern/doc/master/classTListOfEnums.html,1,['load'],['loaded']
Performance,"const TOrdCollection &)=delete;  ; Bool_t IllegalIndex (const char *method, Int_t idx) const;  Return true when index out of bounds and print error. ;  ; void Init (Int_t capacity);  Initialize ordered collection. ;  ; Int_t LogIndex (Int_t idx) const;  ; Bool_t LowWaterMark () const;  ; void MoveGapTo (Int_t newGapStart);  Move gap to new position. ;  ; TOrdCollection & operator= (const TOrdCollection &)=delete;  ; Int_t PhysIndex (Int_t idx) const;  ; void SetCapacity (Int_t newCapacity);  Set/change ordered collection capacity. ;  . Private Attributes; Int_t fCapacity;  ; TObject ** fCont;  ; Int_t fGapSize;  ; Int_t fGapStart;  . Friends; class TOrdCollectionIter;  . Additional Inherited Members;  Protected Types inherited from TCollection; enum  EStatusBits { kIsOwner = (1ULL << ( 14 )); , kUseRWLock = (1ULL << ( 16 )); };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  . #include <TOrdCollection.h>. Inheritance diagram for TOrdCollection:. This browser is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTOrdCollection.html:17683,perform,perform,17683,doc/master/classTOrdCollection.html,https://root.cern,https://root.cern/doc/master/classTOrdCollection.html,1,['perform'],['perform']
Performance,"const TSlave&). Data Members; public:. enum ESlaveType { kMaster; kSlave; };; enum ESlaveStatus { kInvalid; kActive; kInactive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tfBytesReadbytes read by slave (info is obtained from slave); Float_tfCpuTimeCPU time spent executing commands (info obtained from slave); TStringfGroupslave's group id; TStringfImageslave's image name; TFileHandler*fInputinput handler related to this slave; TStringfMsdmass storage domain of slave; TStringfNameslave's hostname; TStringfOrdinalslave's ordinal number; Int_tfParallelnumber of active slaves; Int_tfPerfIdxrelative CPU performance index; Int_tfPortslave's port number; TProof*fProofproof cluster to which slave belongs; TStringfProofWorkDirbase proofserv working directory (info obtained from slave); Int_tfProtocolslave's protocol level; TStringfROOTVersROOT version run by worker; Float_tfRealTimereal time spent executing commands (info obtained from slave); TStringfSessionTagunique tag for ths worker process; TSlave::ESlaveTypefSlaveTypetype of slave (either kMaster or kSlave); TSocket*fSocketsocket to slave; Int_tfStatusremote return status; TStringfUserslave's user id; TStringfWorkDirslave's working directory (info obtained from slave). private:. static TSlave_tfgTXSlaveHook. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSlave(const char* host, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); Create a PROOF slave object. Called via the TProof ctor. TSlave(); Default constructor used by derived classes. void Init(const char* host, Int_t port, Int_t stype); Init a PROOF slave ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSlave.html:7670,perform,performance,7670,root/html530/TSlave.html,https://root.cern,https://root.cern/root/html530/TSlave.html,2,['perform'],['performance']
Performance,"const TVectorD& imageData, UInt_t width, TImagePalette* palette = 0); Create an image depending on the values of imageData.; The size of the image is width X (imageData.fN / width).; For more information see function SetImage() which is called by; this constructor. TASImage(const TASImage& img); Image copy constructor. TASImage & operator=(const TASImage& img); Image assignment operator. ~TASImage(); Image destructor, clean up image and visual. const char * TypeFromMagicNumber(const char* file); Guess the file type from the first byte of file. void ReadImage(const char* file, TImage::EImageFileTypes type = TImage::kUnknown); Read specified image file.; The file type is determined by the file extension (the type argument is; ignored). It will attempt to append .gz and then .Z to the filename and; find such a file. If the filename ends with extension consisting of digits; only, it will attempt to find the file with this extension stripped; off. On success this extension will be used to load subimage from; the file with that number. Subimage is supported for GIF files; (ICO, BMP, CUR, TIFF, XCF to be supported in future).; For example,; i1 = TImage::Open(""anim.gif.0""); // read the first subimage; i4 = TImage::Open(""anim.gif.3""); // read the forth subimage. It is also possible to put XPM raw string (see also SetImageBuffer) as; the first input parameter (""filename""), such string is returned by; GetImageBuffer method. void WriteImage(const char* file, TImage::EImageFileTypes type = TImage::kUnknown); Write image to specified file.; If there is no file extension or if the file extension is unknown, the; type argument will be used to determine the file type. The quality and; compression is derived from the TAttImage values.; It's posiible to write image into an animated GIF file by specifying file; name as ""myfile.gif+"" of ""myfile.gif+NN"", where NN is delay of displaying; subimages during animation in 10ms seconds units.; If NN is ommitted the delay between subimages is zer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TASImage.html:20764,load,load,20764,root/html528/TASImage.html,https://root.cern,https://root.cern/root/html528/TASImage.html,4,['load'],['load']
Performance,"const TVectorD& imageData, UInt_t width, TImagePalette* palette = 0); Create an image depending on the values of imageData.; The size of the image is width X (imageData.fN / width).; For more information see function SetImage() which is called by; this constructor. TASImage(const TASImage& img); Image copy constructor. TASImage & operator=(const TASImage& img); Image assignment operator. ~TASImage(); Image destructor, clean up image and visual. const char * TypeFromMagicNumber(const char* file); Guess the file type from the first byte of file. void ReadImage(const char* file, TImage::EImageFileTypes type = TImage::kUnknown); Read specified image file.; The file type is determined by the file extension (the type argument is; ignored). It will attempt to append .gz and then .Z to the filename and; find such a file. If the filename ends with extension consisting of digits; only, it will attempt to find the file with this extension stripped; off. On success this extension will be used to load subimage from; the file with that number. Subimage is supported for GIF files; (ICO, BMP, CUR, TIFF, XCF to be supported in future).; For example,; i1 = TImage::Open(""anim.gif.0""); // read the first subimage; i4 = TImage::Open(""anim.gif.3""); // read the forth subimage. It is also possible to put XPM raw string (see also SetImageBuffer) as; the first input parameter (""filename""), such string is returned by; GetImageBuffer method. void WriteImage(const char* file, TImage::EImageFileTypes type = TImage::kUnknown); Write image to specified file.; If there is no file extension or if the file extension is unknown, the; type argument will be used to determine the file type. The quality and; compression is derived from the TAttImage values.; It's possible to write image into an animated GIF file by specifying file; name as ""myfile.gif+"" or ""myfile.gif+NN"", where NN is the delay of displaying; subimages during animation in 10ms seconds units. NN is not restricted; to two digits. If NN is omm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TASImage.html:20994,load,load,20994,root/html534/TASImage.html,https://root.cern,https://root.cern/root/html534/TASImage.html,2,['load'],['load']
Performance,"const char * TPluginHandler::GetOrigin ; (; ); const. inlineprivate . Definition at line 140 of file TPluginManager.h. ◆ GetPlugin(). const char * TPluginHandler::GetPlugin ; (; ); const. inlineprivate . Definition at line 138 of file TPluginManager.h. ◆ GetRegexp(). const char * TPluginHandler::GetRegexp ; (; ); const. inlineprivate . Definition at line 137 of file TPluginManager.h. ◆ IsA(). TClass * TPluginHandler::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 254 of file TPluginManager.h. ◆ LoadPlugin(). Int_t TPluginHandler::LoadPlugin ; (; ). Load the plugin library for this handler. ; Returns 0 on successful loading and -1 in case the library does not exist or in case of error. ; Definition at line 293 of file TPluginManager.cxx. ◆ LoadPluginImpl(). void TPluginHandler::LoadPluginImpl ; (; ). private . Load the plugin library for this handler. ; Sets status to 0 on successful loading and -1 in case the library does not exist or in case of error. ; Definition at line 274 of file TPluginManager.cxx. ◆ operator=(). TPluginHandler & TPluginHandler::operator= ; (; const TPluginHandler & ; ). privatedelete . ◆ Print(). void TPluginHandler::Print ; (; Option_t * ; opt = """"); const. overridevirtual . Print info about the plugin handler. ; If option is ""a"" print also the ctor's that will be used. ; Reimplemented from TObject.; Definition at line 341 of file TPluginManager.cxx. ◆ SetupCallEnv(). void TPluginHandler::SetupCallEnv ; (; ). private . Setup ctor or static method call environment. ; Definition at line 198 of file TPluginManager.cxx. ◆ Streamer(). void TPluginHandler::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TPluginHandler::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 254 of file TPluginManager.h. Friends And Related Symbol Docu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPluginHandler.html:17426,load,loading,17426,doc/master/classTPluginHandler.html,https://root.cern,https://root.cern/doc/master/classTPluginHandler.html,1,['load'],['loading']
Performance,"const char *url, TSocket *sock=nullptr);  Create a TNetSystem object. ;  ; void InitRemoteEntity (const char *url);  Parse and save coordinates of the remote entity (user, host, port, ...) ;  ;  Protected Member Functions inherited from TSystem; virtual void DoBeep (Int_t=-1, Int_t=-1) const;  ; virtual const char * ExpandFileName (const char *fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; virtual Bool_t ExpandFileName (TString &fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; TSystem * FindHelper (const char *path, void *dirptr=nullptr);  Create helper TSystem to handle file and directory operations that might be special for remote file access. ;  ; TString & GetLastErrorString ();  Return the thread local storage for the custom last error message. ;  ; const TString & GetLastErrorString () const;  Return the thread local storage for the custom last error message. ;  ; virtual const char * GetLinkedLibraries ();  Get list of shared libraries loaded at the start of the executable. ;  ; virtual void SigAlarmInterruptsSyscalls (Bool_t);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Bool_t fIsLocal;  ; TString fLocalPrefix;  ;  Protected Attributes inherited from TSystem; EAclicMode fAclicMode {kDefault};  ; Int_t fAclicProperties {0};  ; Int_t fBeepDuration {0};  ; Int_t fBeepFreq {0};  ; TString fBuildArch;  ; TString fBuildCompiler;  ; TString fBuildCompilerVersion;  ; TString fBuildCompilerVersionStr;  ; TString fBuildDir;  ; TString fBuildNode;  ; TSeqCollection * fCompiled {nullptr};  ; Bool_t fDone {kFALSE};  ; TSeqCollection * fFileHandler {nullptr};  ; TString fFlagsDebug;  ; TString fFlagsOpt;  ; TSeqCollection * fHelpers {nullptr};  ; TString fHostname;  ; TString fIncludePath;  ; Bool_t fInControl {kFALSE}; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetSystem.html:30782,load,loaded,30782,doc/master/classTNetSystem.html,https://root.cern,https://root.cern/doc/master/classTNetSystem.html,1,['load'],['loaded']
Performance,"const char * ; name, . const char * ; title, . RooAbsReal & ; _func, . const RooArgSet & ; cacheObs . ). Constructor taking name, title and function to be cached and fixed choice of variable to cache. ; To control granularity of the binning of the cache histogram set the desired properties in the binning named ""cache"" in the observables of the function. If the fixed set of cache observables does not match the observables defined in the use context of the p.d.f the cache is still filled completely. Ee.g. when it is specified to cache x and p and only x is a observable in the given use context the cache histogram will store sampled values for all values of observable x and parameter p. In such a mode of operation the cache will also not be recalculated if the observable p changes ; Definition at line 68 of file RooCachedReal.cxx. ◆ RooCachedReal() [3/4]. RooCachedReal::RooCachedReal ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; _func . ). Constructor taking name, title and function to be cached. ; To control granularity of the binning of the cache histogram set the desired properties in the binning named ""cache"" in the observables of the function ; Definition at line 42 of file RooCachedReal.cxx. ◆ RooCachedReal() [4/4]. RooCachedReal::RooCachedReal ; (; const RooCachedReal & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 87 of file RooCachedReal.cxx. Member Function Documentation. ◆ actualObservables(). RooFit::OwningPtr< RooArgSet > RooCachedReal::actualObservables ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . If this pdf is operated with a fixed set of observables, return the subset of the fixed observables that are actual dependents of the external input p.d.f. ; If this p.d.f is operated without a fixed set of cache observables, return the actual observables of the external input p.d.f given the choice of observables defined in nset ; Implements RooAbsCachedReal.; Definition at line 16",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:64476,cache,cached,64476,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,1,['cache'],['cached']
Performance,"const char * getCoefRange () const;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  If all components that depend on obs are binned, so is their sum. ;  ; const RooArgList & pdfList () const;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const override;  Loop over components for plot sampling hints and merge them if there are multiple. ;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooAddPdf to more intuitively reflect the contents of the product operator construction. ;  ; void resetErrorCounters (Int_t resetValue=10) override;  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; bool selfNormalized () const override;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setCacheAndTrackHints (RooArgSet &) override;  Label OK'ed components of a RooAddPdf with cache-and-track. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; virtual RooAbsGenContext * autoGenContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, bool autoBinned=true, const char *binnedTag="""") const;  ; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:6305,cache,cache-and-track,6305,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,2,['cache'],['cache-and-track']
Performance,"const char* aliasName, const char* aliasFormula); virtual voidSetAutoDelete(Bool_t autodel = kTRUE); virtual voidTTree::SetAutoFlush(Long64_t autof = -30000000); virtual voidTTree::SetAutoSave(Long64_t autos = -300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tSetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidSetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual Int_tTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual Int_tSetCacheSize(Long64_t cacheSize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidSetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* elist, Option_t* opt = """"); virtual voidSetEntryListFile(const char* filename = """", Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidSetEventList(TEventList* evlist); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TChain.html:16530,cache,cacheSize,16530,root/html604/TChain.html,https://root.cern,https://root.cern/root/html604/TChain.html,1,['cache'],['cacheSize']
Performance,"const char* cutSpec = 0, const char* cutRange = 0) const; { return moment(var,1,0,cutSpec,cutRange) ; }. Double_t sigma(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return sqrt(moment(var,2,cutSpec,cutRange)) ; }. Double_t skewness(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,3,cutSpec,cutRange) ; }. Double_t kurtosis(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,4,cutSpec,cutRange) ; }. Double_t covariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kFALSE) ; }. Double_t correlation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kTRUE) ; }. TMatrixDSym* covarianceMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return covarianceMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return correlationMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* covarianceMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kFALSE) ; }. TMatrixDSym* correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kTRUE) ; }. RooAbsData* cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0). RooAbsData* reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE). » Last changed: Mon Oct 11 11:18:50 2010 » Last generated: 2010-10-11 11:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsData.html:37359,cache,cacheClone,37359,root/html528/RooAbsData.html,https://root.cern,https://root.cern/root/html528/RooAbsData.html,1,['cache'],['cacheClone']
Performance,"const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); voidTMVA::MethodANNBase::SetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodMLP.html:12043,tune,tuneParameters,12043,root/html530/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodMLP.html,2,['tune'],['tuneParameters']
Performance,"const char* label, Bool_t printError = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual Double_tvolume(const char* rangeName) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCategoryLValue.html:16221,cache,cache,16221,root/html528/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html528/RooAbsCategoryLValue.html,2,['cache'],['cache']
Performance,"const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. static RooExpensiveObjectCache*_instance!; map<TString,ExpensiveObject*>_map; Int_t_nextUID. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooExpensiveObjectCache(); Constructor. RooExpensiveObjectCache(const RooExpensiveObjectCache& ); Copy constructor. ~RooExpensiveObjectCache(); Destructor. RooExpensiveObjectCache& instance(); Return reference to singleton instance. void cleanup(); Static function called by RooSentinel atexit() handler to cleanup at end of program. Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, const RooArgSet& params); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* parIter); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). const TObject* retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); Retrieve o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooExpensiveObjectCache.html:6705,cache,cacheObject,6705,root/html526/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html526/RooExpensiveObjectCache.html,2,['cache'],"['cache', 'cacheObject']"
Performance,"const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. static RooExpensiveObjectCache*_instance!; map<TString,ExpensiveObject*>_map; Int_t_nextUID. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooExpensiveObjectCache(); Constructor. RooExpensiveObjectCache(const RooExpensiveObjectCache& ); Copy constructor. ~RooExpensiveObjectCache(); Destructor. RooExpensiveObjectCache& instance(); Return reference to singleton instance. void cleanup(); Static function called by RooSentinel atexit() handler to cleanup at end of program. Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, const RooArgSet& params); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). const TObject* retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); Retrieve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooExpensiveObjectCache.html:6691,cache,cacheObject,6691,root/html528/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html528/RooExpensiveObjectCache.html,8,['cache'],"['cache', 'cacheObject']"
Performance,"const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num, int strat) -- Parallelize NLL calculation on num CPUs. Strategy 0 = RooFit::BulkPartition (Default) --> Divide events in N equal chunks; Strategy 1 = RooFit::Interleave --> Process event i%N in process N. Recommended for binned data with; a substantial number of zero-bins, which will be distributed across processes more equitably in this strategy; Strategy 2 = RooFit::SimComponents --> Process each component likelihood of a RooSimultaneous fully in a single process; and distribute components over processes. This approach can be benificial if normalization calculation time; dominates the total computation time of a component (since the normalization calculation must be performed; in each process in strategies 0 and 1. However beware that if the RooSimultaneous components do not share many; parameters this strategy is inefficient: as most minuit-induced likelihood calculations involve changing; a single parameter, only 1 of the N processes will be active most of the time if RooSimultaneous components; do not share many parameters; Strategy 3 = RooFit::Hybrid --> Follow strategy 0 for all RooSimultaneous components, except those with less than; 30 dataset entries, for which strategy 2 is followed. Optimize(Bool_t flag) -- Activate constant term optimization (on by default); SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrain(const RooArgSet&pars) -- For p.d.f.s that contain internal parameter constraint ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:50876,perform,performed,50876,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,3,['perform'],['performed']
Performance,"const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num, int strat) -- Parallelize NLL calculation on num CPUs. Strategy 0 = RooFit::BulkPartition (Default) --> Divide events in N equal chunks; Strategy 1 = RooFit::Interleave --> Process event i%N in process N. Recommended for binned data with; a substantial number of zero-bins, which will be distributed across processes more equitably in this strategy; Strategy 2 = RooFit::SimComponents --> Process each component likelihood of a RooSimultaneous fully in a single process; and distribute components over processes. This approach can be benificial if normalization calculation time; dominates the total computation time of a component (since the normalization calculation must be performed; in each process in strategies 0 and 1. However beware that if the RooSimultaneous components do not share many; parameters this strategy is inefficient: as most minuit-induced likelihood calculations involve changing; a single parameter, only 1 of the N processes will be active most of the time if RooSimultaneous components; do not share many parameters; Strategy 3 = RooFit::Hybrid --> Follow strategy 0 for all RooSimultaneous components, except those with less than; 30 dataset entries, for which strategy 2 is followed. SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrained() -- Apply all constrained contained in the p.d.f. in the likelihood; Contrain(const RooArgSet&pars) -- Apply constraints to listed parameters in likelihood",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:55148,perform,performed,55148,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,3,['perform'],['performed']
Performance,"const char* signal, TClass* receiver_class, const char* slot); Int_tCollect(TProof::ESlaves list = kActive, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TList*GetEnabledPackages() const; static Bool_tGetFileInCmd(const char* cmd, TString& fn); static Int_tGetInputData(TList* input, const char* cachedir, TString& emsg); TList*GetListOfActiveSlaves() const; TVirtualProofPlayer*GetPlayer() const; TPluginHandler*GetProgressDialog() const; Int_tGetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidHandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tHandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidInitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); virtual Int_tPollForNewWorkers(); voidPrepareInputDataFile(TString& dataFile); Int_tRemoveWorkers(TList* wrks); static Int_tSaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidSaveWorkerInfo(); Int_tSendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:19932,cache,cachedir,19932,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,1,['cache'],['cachedir']
Performance,"const char* slot); Int_tCollect(TProof::ESlaves list = kActive, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd, Int_t nwk = 1); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tGetFileInCmd(const char* cmd, TString& fn); static Int_tGetInputData(TList* input, const char* cachedir, TString& emsg); TList*GetListOfActiveSlaves() const; TVirtualProofPlayer*GetPlayer() const; TPluginHandler*GetProgressDialog() const; Int_tGetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidHandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tHandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidInitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); voidPrepareInputDataFile(TString& dataFile); Int_tRemoveWorkers(TList* wrks); static Int_tSaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidSaveWorkerInfo(); Int_tSendFile(const char* file, Int_t opt = (kBinary | kForward | kCp | kCpBin), const char* rfile = 0, TSlave* sl = 0); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:19912,cache,cachedir,19912,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,1,['cache'],['cachedir']
Performance,"const char* title, RooAbsReal& _intpdf, const RooArgSet& intObs); Construct projection of input pdf '_intpdf' over observables 'intObs'. RooProjectedPdf(const RooProjectedPdf& other, const char* name = 0); Copy constructor. Double_t getVal(const RooArgSet* set = 0) const; Special version of getVal() overrides RooAbsReal::getVal() to save value of current normalization set. Double_t evaluate() const; Evaluate projected p.d.f. const RooAbsReal* getProjection(const RooArgSet* iset, const RooArgSet* nset, const char* rangeName, int& code) const; Retrieve object representing projection integral of input p.d.f; over observables iset, while normalizing over observables; nset. The code argument returned by reference is the unique code; defining this particular projection configuration. RooAbsPdf* createProjection(const RooArgSet& iset); Special version of RooAbsReal::createProjection that deals with; projections of projections. Instead of integrating twice, a new; RooProjectedPdf is returned that is configured to perform the; complete integration in one step. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to relegate integration of all observables to internal logic. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Mark all requested variables as internally integrated. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral represent by appropriate element of projection cache. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; No internal generator is implemented. void generateEvent(Int_t code); No internal generator is implemented. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t , Bool_t , Bool_t ); Intercept a server redirection all and update list of dependents if necessary; Specifically update the set proxy ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProjectedPdf.html:41327,perform,perform,41327,root/html526/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html526/RooProjectedPdf.html,3,['perform'],['perform']
Performance,"const double *p) override;  set parameter values need to call also SetParameters in TF1 in ace some other operations (re-normalizations) are needed ;  ; unsigned int NPar () const override;  return number of parameters ;  ; std::string ParameterName (unsigned int i) const override;  return parameter name (this is stored in TF1) ;  ; void ParameterGradient (double x, const double *par, double *grad) const override;  evaluate the derivative of the function with respect to the parameters ;  ; void FdF (double x, double &f, double &deriv) const override;  calculate function and derivative at same time (required by IGradient interface) ;  ; static void SetDerivPrecision (double eps);  precision value used for calculating the derivative step-size h = eps * |x|. ;  ; static double GetDerivPrecision ();  get precision value used for calculating the derivative step-size ;  ; double DoEvalPar (double x, const double *p) const override;  evaluate function passing coordinates x and vector of parameters ;  ; double DoEval (double x) const override;  evaluate function using the cached parameter values (of TF1) re-implement for better efficiency ;  ; double DoDerivative (double x) const override;  return the function derivatives w.r.t. x ;  ; double DoParameterDerivative (double x, const double *p, unsigned int ipar) const override;  evaluate the derivative of the function with respect to the parameters ;  . #include <Math/WrappedTF1.h>. Inheritance diagram for ROOT::Math::WrappedTF1:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ BaseFunc. typedef ROOT::Math::IParamGradFunction::BaseFunc ROOT::Math::WrappedTF1::BaseFunc. Definition at line 45 of file WrappedTF1.h. ◆ BaseGradFunc. typedef ROOT::Math::IParamGradFunction ROOT::Math::WrappedTF1::BaseGradFunc. Definition at line 44 of file WrappedTF1.h. ◆ IGrad. typedef ROOT::Math::IGradientFunctionOneDim ROOT::Math::WrappedTF1::IGrad. Definition at line ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedTF1.html:5862,cache,cached,5862,doc/master/classROOT_1_1Math_1_1WrappedTF1.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedTF1.html,1,['cache'],['cached']
Performance,"const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only after fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Fit__Fitter.html:10628,perform,perform,10628,root/html530/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html530/ROOT__Fit__Fitter.html,1,['perform'],['perform']
Performance,"const overridePrint object value.Definition RooAbsReal.cxx:445; RooAbsReal::forceAnalyticalIntvirtual bool forceAnalyticalInt(const RooAbsArg &) constDefinition RooAbsReal.h:164; RooAbsReal::isIdenticalbool isIdentical(const RooAbsArg &other, bool assumeSameType=false) const overrideDefinition RooAbsReal.cxx:270; RooAbsReal::setUnitvoid setUnit(const char *unit)Definition RooAbsReal.h:147; RooAbsReal::getForceNumIntbool getForceNumInt() constDefinition RooAbsReal.h:174; RooAbsReal::createProfilevirtual RooFit::OwningPtr< RooAbsReal > createProfile(const RooArgSet &paramsOfInterest)Create a RooProfileLL object that eliminates all nuisance parameters in the present function.Definition RooAbsReal.cxx:471; RooAbsReal::_hideOffsetstatic bool _hideOffsetOffset hiding flag.Definition RooAbsReal.h:546; RooAbsReal::attachToVStorevoid attachToVStore(RooVectorDataStore &vstore) overrideDefinition RooAbsReal.cxx:3012; RooAbsReal::copyCachevoid copyCache(const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) overrideCopy the cached value of another RooAbsArg to our cache.Definition RooAbsReal.cxx:2997; RooAbsReal::gradientvirtual void gradient(double *) constDefinition RooAbsReal.h:388; RooAbsReal::createHistogramTH1 * createHistogram(RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) constCreate and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables w...Definition RooAbsReal.cxx:1183; RooAbsReal::fixAddCoefRangevirtual void fixAddCoefRange(const char *rangeName=nullptr, bool force=true)Fix the interpretation of the coefficient of any RooAddPdf component in the expression tree headed by...Definition RooAbsReal.cxx:3675; RooAbsReal::_valuedouble _valueCache for current value of object.Definition RooAbsReal.h:536; RooAbsReal::analyticalIntegralvirtual double analyticalIntegral(Int_t code, const char *rangeName=nullptr) constImplements the actual analytical integral(s) advertised by getAnalyticalIntegral.Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8h_source.html:43187,cache,cached,43187,doc/master/RooAbsReal_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html,2,['cache'],"['cache', 'cached']"
Performance,"const std::string &name)Configure window to show some of existing JSROOT panels It uses ""file:rootui5sys/panel/panel....Definition RWebWindow.cxx:132; ROOT::RWebWindow::SetPositionvoid SetPosition(unsigned x, unsigned y)Set window position. Will be applied if supported by used web display (like CEF or Chromium)Definition RWebWindow.hxx:269; ROOT::RWebWindow::IsRequireAuthKeybool IsRequireAuthKey() constreturns true if authentication string is requiredDefinition RWebWindow.hxx:320; ROOT::RWebWindow::RWebWindowRWebWindow()RWebWindow constructor Should be defined here because of std::unique_ptr<RWebWindowWSHandler>Definition RWebWindow.cxx:76; ROOT::RWebWindow::SetNativeOnlyConnvoid SetNativeOnlyConn(bool on=true)configures that only native (own-created) connections are allowedDefinition RWebWindow.hxx:308; ROOT::RWebWindow::fProtocolPrefixstd::string fProtocolPrefix! prefix for created files namesDefinition RWebWindow.hxx:173; ROOT::RWebWindow::GetSendQueueLengthint GetSendQueueLength(unsigned connid) constReturns send queue length for specified connection.Definition RWebWindow.cxx:1509; ROOT::RWebWindow::RemoveConnectionstd::shared_ptr< WebConn > RemoveConnection(unsigned wsid)Remove connection with given websocket id.Definition RWebWindow.cxx:279; ROOT::RWebWindow::CreateWSHandlerstd::shared_ptr< RWebWindowWSHandler > CreateWSHandler(std::shared_ptr< RWebWindowsManager > mgr, unsigned id, double tmout)Assigns manager reference, window id and creates websocket handler, used for communication with the c...Definition RWebWindow.cxx:152; ROOT::RWebWindow::fProtocolstd::string fProtocol! protocolDefinition RWebWindow.hxx:174; ROOT::RWebWindow::CanSendbool CanSend(unsigned connid, bool direct=true) constReturns true if sending via specified connection can be performed.Definition RWebWindow.cxx:1484; ROOT::RWebWindow::GetUserArgsstd::string GetUserArgs() constReturns configured user arguments for web window See SetUserArgs method for more details.Definition RWebWindow.cxx:1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:35740,queue,queue,35740,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['queue'],['queue']
Performance,"const std::string &name)Configure window to show some of existing JSROOT panels It uses ""file:rootui5sys/panel/panel....Definition RWebWindow.cxx:132; ROOT::RWebWindow::SetPositionvoid SetPosition(unsigned x, unsigned y)Set window position. Will be applied if supported by used web display (like CEF or Chromium)Definition RWebWindow.hxx:272; ROOT::RWebWindow::IsRequireAuthKeybool IsRequireAuthKey() constreturns true if authentication string is requiredDefinition RWebWindow.hxx:323; ROOT::RWebWindow::RWebWindowRWebWindow()RWebWindow constructor Should be defined here because of std::unique_ptr<RWebWindowWSHandler>Definition RWebWindow.cxx:76; ROOT::RWebWindow::SetNativeOnlyConnvoid SetNativeOnlyConn(bool on=true)configures that only native (own-created) connections are allowedDefinition RWebWindow.hxx:311; ROOT::RWebWindow::fProtocolPrefixstd::string fProtocolPrefix! prefix for created files namesDefinition RWebWindow.hxx:176; ROOT::RWebWindow::GetSendQueueLengthint GetSendQueueLength(unsigned connid) constReturns send queue length for specified connection.Definition RWebWindow.cxx:1551; ROOT::RWebWindow::RemoveConnectionstd::shared_ptr< WebConn > RemoveConnection(unsigned wsid)Remove connection with given websocket id.Definition RWebWindow.cxx:279; ROOT::RWebWindow::CreateWSHandlerstd::shared_ptr< RWebWindowWSHandler > CreateWSHandler(std::shared_ptr< RWebWindowsManager > mgr, unsigned id, double tmout)Assigns manager reference, window id and creates websocket handler, used for communication with the c...Definition RWebWindow.cxx:152; ROOT::RWebWindow::fProtocolstd::string fProtocol! protocolDefinition RWebWindow.hxx:177; ROOT::RWebWindow::CanSendbool CanSend(unsigned connid, bool direct=true) constReturns true if sending via specified connection can be performed.Definition RWebWindow.cxx:1526; ROOT::RWebWindow::GetUserArgsstd::string GetUserArgs() constReturns configured user arguments for web window See SetUserArgs method for more details.Definition RWebWindow.cxx:1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:36129,queue,queue,36129,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['queue'],['queue']
Performance,"const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values.Definition TGraphAsymmErrors.cxx:1468; TGraphAsymmErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphAsymmErrors.cxx:1456; TGraphAsymmErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphAsymmErrors.h:75; TGraphAsymmErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphAsymmErrors.h:29; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphAsymmErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphAsymmErrors.cxx:444; TGraphAsymmErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphAsymmErrors.h:76; TGraphAsymmErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphAsymmErrors.cxx:1077; TGraphAsymmErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphAsymmErrors.cxx:1007; TGraphAsymmErrors::IsATClass * IsA() const overrideDefinition TGraphAsymmErrors.h:89; TGraphAsymmErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exh)Set EXhigh for point i.Definition TGraphAsymmErrors.cxx:1362; TGraphAsymmErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on Y.Definition TGraphAsymmErrors.cxx:1184; TGraphAsymmErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideReturns the combined error along X at point i by computing the average of the lower and upper varianc...Definition TGraphAsymmErrors.cxx:1122; TGraphAsymmErrors::TGraphAsymmErrorsTGraphAsymmErrors()TGraphAsymmErrors default constructor.Definition TGraphAsymmErrors.cx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:63383,perform,perform,63383,doc/master/TGraphAsymmErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html,1,['perform'],['perform']
Performance,"const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values.Definition TGraphAsymmErrors.cxx:1468; TGraphAsymmErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphAsymmErrors.cxx:1456; TGraphAsymmErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphAsymmErrors.h:75; TGraphAsymmErrors::fEXlowDouble_t * fEXlow[fNpoints] array of X low errorsDefinition TGraphAsymmErrors.h:29; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphAsymmErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphAsymmErrors.cxx:444; TGraphAsymmErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphAsymmErrors.h:76; TGraphAsymmErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphAsymmErrors.cxx:1077; TGraphAsymmErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphAsymmErrors.cxx:1007; TGraphAsymmErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exh)Set EXhigh for point i.Definition TGraphAsymmErrors.cxx:1362; TGraphAsymmErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on Y.Definition TGraphAsymmErrors.cxx:1184; TGraphAsymmErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideReturns the combined error along X at point i by computing the average of the lower and upper varianc...Definition TGraphAsymmErrors.cxx:1122; TGraphAsymmErrors::TGraphAsymmErrorsTGraphAsymmErrors()TGraphAsymmErrors default constructor.Definition TGraphAsymmErrors.cxx:72; TGraphAsymmErrors::operator=TGraphAsymmErrors & operator=(const TGraphAsymmError",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:12131,perform,perform,12131,doc/master/TGraphAsymmErrors_8h_source.html,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html,1,['perform'],['perform']
Performance,"const struct mg_connection *conn); 4019{; 4020 if (!conn || !conn->dom_ctx) {; 4021 return 0;; 4022 }; 4023 ; 4024 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_URL], ""yes"") == 0);; 4025}; 4026 ; 4027 ; 4028static int; 4029should_decode_query_string(const struct mg_connection *conn); 4030{; 4031 if (!conn || !conn->dom_ctx) {; 4032 return 0;; 4033 }; 4034 ; 4035 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_QUERY_STRING], ""yes""); 4036 == 0);; 4037}; 4038 ; 4039 ; 4040static const char *; 4041suggest_connection_header(const struct mg_connection *conn); 4042{; 4043 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4044}; 4045 ; 4046 ; 4047#include ""response.inl""; 4048 ; 4049 ; 4050static void; 4051send_no_cache_header(struct mg_connection *conn); 4052{; 4053 /* Send all current and obsolete cache opt-out directives. */; 4054 mg_response_header_add(conn,; 4055 ""Cache-Control"",; 4056 ""no-cache, no-store, ""; 4057 ""must-revalidate, private, max-age=0"",; 4058 -1);; 4059 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4060 ; 4061 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4062 /* Obsolete, but still send it for HTTP/1.0 */; 4063 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4064 }; 4065}; 4066 ; 4067 ; 4068static void; 4069send_static_cache_header(struct mg_connection *conn); 4070{; 4071#if !defined(NO_CACHING); 4072 int max_age;; 4073 char val[64];; 4074 ; 4075 const char *cache_control =; 4076 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4077 ; 4078 /* If there is a full cache-control option configured,0 use it */; 4079 if (cache_control != NULL) {; 4080 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4081 return;; 4082 }; 4083 ; 4084 /* Read the server config to check how long a file may be cached.; 4085 * The configuration is in seconds. */; 4086 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4087 if (max_age <= 0) {; 4088 /* 0 means ""do not cache"". All values <0 are reserved; 4089 * and may ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:119873,cache,cache,119873,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['cache'],['cache']
Performance,"const struct mg_connection *conn); 4020{; 4021 if (!conn || !conn->dom_ctx) {; 4022 return 0;; 4023 }; 4024 ; 4025 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_URL], ""yes"") == 0);; 4026}; 4027 ; 4028 ; 4029static int; 4030should_decode_query_string(const struct mg_connection *conn); 4031{; 4032 if (!conn || !conn->dom_ctx) {; 4033 return 0;; 4034 }; 4035 ; 4036 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_QUERY_STRING], ""yes""); 4037 == 0);; 4038}; 4039 ; 4040 ; 4041static const char *; 4042suggest_connection_header(const struct mg_connection *conn); 4043{; 4044 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4045}; 4046 ; 4047 ; 4048#include ""response.inl""; 4049 ; 4050 ; 4051static void; 4052send_no_cache_header(struct mg_connection *conn); 4053{; 4054 /* Send all current and obsolete cache opt-out directives. */; 4055 mg_response_header_add(conn,; 4056 ""Cache-Control"",; 4057 ""no-cache, no-store, ""; 4058 ""must-revalidate, private, max-age=0"",; 4059 -1);; 4060 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4061 ; 4062 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4063 /* Obsolete, but still send it for HTTP/1.0 */; 4064 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4065 }; 4066}; 4067 ; 4068 ; 4069static void; 4070send_static_cache_header(struct mg_connection *conn); 4071{; 4072#if !defined(NO_CACHING); 4073 int max_age;; 4074 char val[64];; 4075 ; 4076 const char *cache_control =; 4077 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4078 ; 4079 /* If there is a full cache-control option configured,0 use it */; 4080 if (cache_control != NULL) {; 4081 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4082 return;; 4083 }; 4084 ; 4085 /* Read the server config to check how long a file may be cached.; 4086 * The configuration is in seconds. */; 4087 max_age = atoi(conn->dom_ctx->config[STATIC_FILE_MAX_AGE]);; 4088 if (max_age <= 0) {; 4089 /* 0 means ""do not cache"". All values <0 are reserved; 4090 * and may ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:119905,cache,cache,119905,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['cache'],['cache']
Performance,"const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TSeqCollection*GetClipboard() const; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TObject*GetGeometry(const char* name) const; const char*GetGitBranch() const; const char*GetGitCommit() const; const char*GetGitDate(); TGlobal*GetGlobal(const char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfClosedObjects() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctions() const; TSeqCollection*GetListOfGeometries() const; TCollection*GetListOfGlobalFunctions(Bool_t load = kFALSE); TCollection*GetListOfGlobals(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TROOT.html:6105,load,load,6105,root/html534/TROOT.html,https://root.cern,https://root.cern/root/html534/TROOT.html,1,['load'],['load']
Performance,"const { return fNormErrors; }; 203 ; 204 ///do analysis for parabolic errors; 205 bool ParabErrors() const { return fParabErrors; }; 206 ; 207 ///do minos errors analysis on the parameters; 208 bool MinosErrors() const { return fMinosErrors; }; 209 ; 210 ///Update configuration after a fit using the FitResult; 211 bool UpdateAfterFit() const { return fUpdateAfterFit; }; 212 ; 213 ///Apply Weight correction for error matrix computation; 214 bool UseWeightCorrection() const { return fWeightCorr; }; 215 ; 216 ; 217 /// return vector of parameter indices for which the Minos Error will be computed; 218 const std::vector<unsigned int> & MinosParams() const { return fMinosParams; }; 219 ; 220 /**; 221 set the option to normalize the error on the result according to chi2/ndf; 222 */; 223 void SetNormErrors(bool on = true) { fNormErrors= on; }; 224 ; 225 ///set parabolic errors; 226 void SetParabErrors(bool on = true) { fParabErrors = on; }; 227 ; 228 ///set Minos errors computation to be performed after fitting; 229 void SetMinosErrors(bool on = true) { fMinosErrors = on; }; 230 ; 231 ///apply the weight correction for error matrix computation; 232 void SetWeightCorrection(bool on = true) { fWeightCorr = on; }; 233 ; 234 /// set parameter indices for running Minos; 235 /// this can be used for running Minos on a subset of parameters - otherwise is run on all of them; 236 /// if MinosErrors() is set; 237 void SetMinosErrors(const std::vector<unsigned int> & paramInd ) {; 238 fMinosErrors = true;; 239 fMinosParams = paramInd;; 240 }; 241 ; 242 ///Update configuration after a fit using the FitResult; 243 void SetUpdateAfterFit(bool on = true) { fUpdateAfterFit = on; }; 244 ; 245 ; 246 /**; 247 static function to control default minimizer type and algorithm; 248 */; 249 static void SetDefaultMinimizer(const char *type, const char *algo = nullptr);; 250 ; 251 ; 252 ; 253 ; 254protected:; 255 ; 256 ; 257private:; 258 ; 259 bool fNormErrors; ///< flag for error normalization; 260 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitConfig_8h_source.html:6688,perform,performed,6688,doc/master/FitConfig_8h_source.html,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html,1,['perform'],['performed']
Performance,"const. inline . Definition at line 495 of file TTree.h. ◆ GetMaxEntryLoop(). virtual Long64_t TTree::GetMaxEntryLoop ; (; ); const. inlinevirtual . Definition at line 497 of file TTree.h. ◆ GetMaximum(). Double_t TTree::GetMaximum ; (; const char * ; columname). virtual . Return maximum of column with name columname. ; if the Tree has an associated TEventList or TEntryList, the maximum is computed for the entries in this list. ; Reimplemented in TChain.; Definition at line 6235 of file TTree.cxx. ◆ GetMaxTreeSize(). Long64_t TTree::GetMaxTreeSize ; (; ). static . Static function which returns the tree file size limit in bytes. ; Definition at line 6265 of file TTree.cxx. ◆ GetMaxVirtualSize(). virtual Long64_t TTree::GetMaxVirtualSize ; (; ); const. inlinevirtual . Definition at line 500 of file TTree.h. ◆ GetMedianClusterSize(). Long64_t TTree::GetMedianClusterSize ; (; ). private . Estimate the median cluster size for the TTree. ; This value provides e.g. a reasonable cache size default if other heuristics fail. Clusters with size 0 and the very last cluster range, that might not have been committed to fClusterSize yet, are ignored for the purposes of the calculation. ; Definition at line 8292 of file TTree.cxx. ◆ GetMinimum(). Double_t TTree::GetMinimum ; (; const char * ; columname). virtual . Return minimum of column with name columname. ; if the Tree has an associated TEventList or TEntryList, the minimum is computed for the entries in this list. ; Reimplemented in TChain.; Definition at line 6275 of file TTree.cxx. ◆ GetNbranches(). virtual Int_t TTree::GetNbranches ; (; ). inlinevirtual . Reimplemented in TChain.; Definition at line 502 of file TTree.h. ◆ GetNewlineValue(). char TTree::GetNewlineValue ; (; std::istream & ; inputStream). protected . Determine which newline this file is using. ; Return '\r' for Windows '\r\n' as that already terminates. ; Definition at line 7588 of file TTree.cxx. ◆ GetNotify(). TObject * TTree::GetNotify ; (; ); const. inline",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:162061,cache,cache,162061,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['cache'],['cache']
Performance,"const. inline . Definition at line 535 of file TTree.h. ◆ GetMaxEntryLoop(). virtual Long64_t TTree::GetMaxEntryLoop ; (; ); const. inlinevirtual . Definition at line 537 of file TTree.h. ◆ GetMaximum(). Double_t TTree::GetMaximum ; (; const char * ; columname). virtual . Return maximum of column with name columname. ; if the Tree has an associated TEventList or TEntryList, the maximum is computed for the entries in this list. ; Reimplemented in TChain.; Definition at line 6235 of file TTree.cxx. ◆ GetMaxTreeSize(). Long64_t TTree::GetMaxTreeSize ; (; ). static . Static function which returns the tree file size limit in bytes. ; Definition at line 6265 of file TTree.cxx. ◆ GetMaxVirtualSize(). virtual Long64_t TTree::GetMaxVirtualSize ; (; ); const. inlinevirtual . Definition at line 540 of file TTree.h. ◆ GetMedianClusterSize(). Long64_t TTree::GetMedianClusterSize ; (; ). private . Estimate the median cluster size for the TTree. ; This value provides e.g. a reasonable cache size default if other heuristics fail. Clusters with size 0 and the very last cluster range, that might not have been committed to fClusterSize yet, are ignored for the purposes of the calculation. ; Definition at line 8297 of file TTree.cxx. ◆ GetMinimum(). Double_t TTree::GetMinimum ; (; const char * ; columname). virtual . Return minimum of column with name columname. ; if the Tree has an associated TEventList or TEntryList, the minimum is computed for the entries in this list. ; Reimplemented in TChain.; Definition at line 6275 of file TTree.cxx. ◆ GetNbranches(). virtual Int_t TTree::GetNbranches ; (; ). inlinevirtual . Reimplemented in TChain.; Definition at line 542 of file TTree.h. ◆ GetNewlineValue(). char TTree::GetNewlineValue ; (; std::istream & ; inputStream). protected . Determine which newline this file is using. ; Return '\r' for Windows '\r\n' as that already terminates. ; Definition at line 7588 of file TTree.cxx. ◆ GetNotify(). TObject * TTree::GetNotify ; (; ); const. inline",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:164249,cache,cache,164249,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['cache'],['cache']
Performance,const. overridevirtual . return expected distance reached from the minimum (re-implement if minimizer provides it ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 367 of file GeneticMinimizer.cxx. ◆ Errors(). const double * ROOT::Math::GeneticMinimizer::Errors ; (; ); const. overridevirtual . return errors at the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 366 of file GeneticMinimizer.cxx. ◆ GetGeneticOptions(). void ROOT::Math::GeneticMinimizer::GetGeneticOptions ; (; ROOT::Math::MinimizerOptions & ; opt); const. protected . Definition at line 191 of file GeneticMinimizer.cxx. ◆ MinGradient(). const double * ROOT::Math::GeneticMinimizer::MinGradient ; (; ); const. overridevirtual . return pointer to gradient values at the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 364 of file GeneticMinimizer.cxx. ◆ Minimize(). bool ROOT::Math::GeneticMinimizer::Minimize ; (; ). overridevirtual . method to perform the minimization ; Implements ROOT::Math::Minimizer.; Definition at line 252 of file GeneticMinimizer.cxx. ◆ MinimizerParameters(). const GeneticMinimizerParameters & ROOT::Math::GeneticMinimizer::MinimizerParameters ; (; ); const. inline . Definition at line 96 of file GeneticMinimizer.h. ◆ MinValue(). double ROOT::Math::GeneticMinimizer::MinValue ; (; ); const. overridevirtual . return minimum function value ; Implements ROOT::Math::Minimizer.; Definition at line 331 of file GeneticMinimizer.cxx. ◆ NCalls(). unsigned int ROOT::Math::GeneticMinimizer::NCalls ; (; ); const. overridevirtual . number of function calls to reach the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 340 of file GeneticMinimizer.cxx. ◆ NDim(). unsigned int ROOT::Math::GeneticMinimizer::NDim ; (; ); const. overridevirtual . this is <= Function().NDim() which is the total number of variables (free+ constrained ones) ; Implements ROOT::Math::Minimizer.; Definition at line 348 of file GeneticMinimizer.cxx. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GeneticMinimizer.html:13043,perform,perform,13043,doc/master/classROOT_1_1Math_1_1GeneticMinimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GeneticMinimizer.html,1,['perform'],['perform']
Performance,"const; -- Return pointer to TRealData element with name ""name"". Name can be a data member in the class itself,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TFunctionTemplate * GetFunctionTemplate(const char* name). const char * GetSharedLibs(); Get the list of shared libraries containing the code for class cls.; The first library in the list is the one containing the class, the; others are the libraries the first one depends on. Returns 0; in case the library is not found. TList * GetListOfBases(); Return list containing the TBaseClass(es) of a class. TList * GetListOfEnums(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfDataMembers(Bool_t load = kTRUE); Return list containing the TDataMembers of a class. TList * GetListOfFunctionTemplates(Bool_t load = kTRUE); Return list containing the TEnums of a class. TList * GetListOfMethods(Bool_t load = kTRUE); Return list containing the TMethods of a class.; If load is true, the list is populated with all the defined function; and currently instantiated function template. TCollection * GetListOfMethodOverloads(const char* name) const; Return the collection of functions named ""name"". const TList * GetListOfAllPublicMethods(Bool_t load = kTRUE); Returns a list of all public methods of this class and its base classes.; Refers to a subset of the methods in GetListOfMethods() so don't do; GetListOfAllPublicMethods()->Delete().; Algorithm used to get the list is:; - put all methods of the class in the list (also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:37892,load,load,37892,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['load'],['load']
Performance,"const; Create thread private data for all geometry objects. void ClearThreadsMap(); Clear the current map of threads. This will be filled again by the calling; threads via ThreadId calls. Int_t ThreadId(); Translates the current thread id to an ordinal number. This can be used to; manage data which is pspecific for a given thread.; static __thread Int_t tid = -1;; if (tid > -1) return tid;. void Browse(TBrowser* b); Describe how to browse this object. void Edit(Option_t* option = """"); Append a pad for this geometry. void SetVisibility(TObject* obj, Bool_t vis); Set visibility for a volume. void BombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'bombed' translation vector according current exploded view mode. void UnbombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'unbombed' translation vector according current exploded view mode. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. void RegisterMatrix(const TGeoMatrix* matrix); Register a matrix to the list of matrices. It will be cleaned-up at the; destruction TGeoManager. Int_t ReplaceVolume(TGeoVolume* vorig, TGeoVolume* vnew); Replaces all occurences of VORIG with VNEW in the geometry tree. The volume VORIG; is not replaced from the list of volumes, but all node referencing it will reference; VNEW instead. Returns number of occurences changed. Int_t TransformVolumeToAssembly(const char* vname); Transform all volumes named VNAME to assemblies. The volumes must be virtual. TGeoVolume * Division(const char* name, const char* mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); Create a new volume by dividing an existing one (GEANT3 like). Divides MOTHER into NDIV divisions called NAME; along axis IAXIS starting at coordinate value START; and having size STEP. The created volumes will have tracking; media ID=NUMED (if N",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoManager.html:40184,cache,cache,40184,root/html534/TGeoManager.html,https://root.cern,https://root.cern/root/html534/TGeoManager.html,3,['cache'],['cache']
Performance,"const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Thu Sep 23 19:58:06 2010 » Last generated: 2010-09-23 19:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedPdf.html:44031,cache,cache,44031,root/html528/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedPdf.html,3,['cache'],['cache']
Performance,"const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Tue Mar 10 17:13:53 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedPdf.html:47354,cache,cache,47354,root/html534/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedPdf.html,3,['cache'],['cache']
Performance,"const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char* ). Bool_t GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes). DictFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. DictFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:35679,load,load,35679,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['load'],['load']
Performance,"const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); voidsetCallWarning(Int_t threshold = 2000); voidsetConvolutionWindow(RooAbsReal& centerParam, RooAbsReal& widthParam, Double_t widthScaleFactor = 1); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumConvPdf.html:29931,cache,cache,29931,root/html530/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html530/RooNumConvPdf.html,1,['cache'],['cache']
Performance,"const; return the function derivatives w.r.t. x. double DoParameterDerivative(double x, const double* p, unsigned int ipar) const; evaluate the derivative of the function with respect to the parameters; IMPORTANT NOTE: TF1::GradientPar returns 0 for fixed parameters to avoid computing useless derivatives; BUT the TLinearFitter wants to have the derivatives also for fixed parameters.; so in case of fLinear (or fPolynomial) a non-zero value will be returned for fixed parameters. void SetDerivPrecision(double eps); { fgEps = eps; }. double GetDerivPrecision(); { return fgEps; }. virtual ~WrappedTF1(). Destructor (no operations). TF1 Function pointer is not owned. {}. ROOT::Math::IGenFunction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cachen inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values; need to call also SetParameters in TF1 in ace some other operations (re-normalizations) are needed. unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter name (this is stored in TF1). void FdF(double x, double& f, double& deriv) const; calculate function and derivative at same time (required by IGradient interface). double DoEvalPar(double x, const double* p) const; evaluate function passing coordinates x and vector of parameters. double DoEval(double x) const; evaluate function using the cached parameter values (of TF1); re-implement for better efficiency. » Author: L. Moneta Wed Sep 6 09:52:26 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__WrappedTF1.html:5752,cache,cached,5752,root/html604/ROOT__Math__WrappedTF1.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__WrappedTF1.html,1,['cache'],['cached']
Performance,"const; static Int_tnumEvalErrorItems(); static Int_tnumEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_toffset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Double_t value) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:18725,optimiz,optimizeCacheMode,18725,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,1,['optimiz'],['optimizeCacheMode']
Performance,"const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidDrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEvePolygonSetProjectedGL.html:1921,cache,cached,1921,root/html534/TEvePolygonSetProjectedGL.html,https://root.cern,https://root.cern/root/html534/TEvePolygonSetProjectedGL.html,1,['cache'],['cached']
Performance,"const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidoperModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual const char*payloadUniqueSuffix() const; virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; voidRooAbsReal::plotOnCompSelect(RooArgSet* selNodes) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedReal.html:30388,optimiz,optimizeDirtyHook,30388,root/html534/RooCachedReal.html,https://root.cern,https://root.cern/root/html534/RooCachedReal.html,3,['optimiz'],['optimizeDirtyHook']
Performance,"const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; RooNumIntConfig&binIntegratorConfig(); const RooNumIntConfig&binIntegratorConfig() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsOptTestStatistic::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooXYChi2Var.html:2866,cache,cacheUniqueSuffix,2866,root/html528/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html528/RooXYChi2Var.html,1,['cache'],['cacheUniqueSuffix']
Performance,"const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; RooNumIntConfig&binIntegratorConfig(); const RooNumIntConfig&binIntegratorConfig() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsOptTestStatistic::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooXYChi2Var.html:2866,cache,cacheUniqueSuffix,2866,root/html530/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html530/RooXYChi2Var.html,2,['cache'],['cacheUniqueSuffix']
Performance,"const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsOptTestStatistic::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChi2Var.html:2211,cache,cacheUniqueSuffix,2211,root/html602/RooChi2Var.html,https://root.cern,https://root.cern/root/html602/RooChi2Var.html,4,['cache'],['cacheUniqueSuffix']
Performance,"const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDimIGradientOneDim(); ROOT::Math::IGradientOneDimIGradientOneDim(const ROOT::Math::IGradientOneDim&); ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x) const. Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IGradientOneDim.html:2368,perform,performances,2368,root/html602/ROOT__Math__IGradientOneDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IGradientOneDim.html,2,['perform'],['performances']
Performance,"const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDimIGradientOneDim(); ROOT::Math::IGradientOneDimIGradientOneDim(const ROOT::Math::IGradientOneDim&); ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x) const. Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__IGradientOneDim.html:2368,perform,performances,2368,root/html604/ROOT__Math__IGradientOneDim.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__IGradientOneDim.html,2,['perform'],['performances']
Performance,"const;  ; Int_t GetActionParam (Int_t code) const;  ; Int_t GetActionParamOptimized (Int_t code) const;  ; Int_t * GetOper () const;  ; Int_t * GetOperOptimized () const;  ; virtual Bool_t IsString (Int_t oper) const;  Return true if the expression at the index 'oper' has to be treated as a string. ;  ; void MakePrimitive (const char *expr, Int_t pos);  MakePrimitive find TFormulaPrimitive replacement for some operands. ;  ; Int_t PreCompile ();  pointer to optimal function ;  ; void SetAction (Int_t code, Int_t value, Int_t param=0);  ; void SetActionOptimized (Int_t code, Int_t value, Int_t param=0);  ; virtual Bool_t StringToNumber (Int_t code);  Try to 'demote' a string into an array bytes. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from ROOT::v5::TFormula; TBits fAlreadyFound;  ; Double_t * fConst;  ; TString * fExpr;  ; TString * fExprOptimized;  Number of operators after optimization. ;  ; TObjArray fFunctions;  ; TObjArray fLinearParts;  ; TString * fNames;  ; Int_t fNconst;  ; Int_t fNdim;  ; Int_t fNoper;  ; Int_t fNOperOptimized;  cache for information ;  ; Int_t fNpar;  ; Int_t fNstring;  ; Int_t fNumber;  ; Int_t fNval;  ; TOperOffset * fOperOffset;  [fNOperOptimized] List of operators. (See documentation for changes made at version 7) ;  ; Int_t * fOperOptimized;  [fNOperOptimized] List of expressions ;  ; TFuncG fOptimal;  [fNPar] predefined function ;  ; Double_t * fParams;  ; TFormulaPrimitive ** fPredefined;  [fNOperOptimized] Offsets of operrands ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from TAttLine; Color_t fLineColor;  Line color. ;  ; Style_t fLineStyle;  Line style. ;  ; Width_t fLineWidth;  Line width. ;  ;  Protected Attributes inherited from TAttFill; Color_t fF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:25622,optimiz,optimization,25622,doc/master/structROOT_1_1v5_1_1TF1Data.html,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html,1,['optimiz'],['optimization']
Performance,"const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:39148,cache,cacheUniqueSuffix,39148,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,8,['cache'],"['cache', 'cacheUniqueSuffix']"
Performance,"constReturn path name of obj somewhere in the //root/... path.Definition TROOT.cxx:1473; TROOT::ConvertVersionInt2Codestatic Int_t ConvertVersionInt2Code(Int_t v)Convert version as an integer to version code as used in RVersion.h.Definition TROOT.cxx:2930; TROOT::ResetClassSavedvoid ResetClassSaved()Reset the ClassSaved status of all classes.Definition TROOT.cxx:1096; TROOT::GetTTFFontDirstatic const TString & GetTTFFontDir()Get the fonts directory in the installation. Static utility function.Definition TROOT.cxx:3189; TROOT::fForceStyleBool_t fForceStyleForce setting of current style when reading objects.Definition TROOT.h:133; TROOT::MakeDefCanvasTCanvas * MakeDefCanvas() constReturn a default canvas.Definition TROOT.cxx:1554; TROOT::fTypesTCollection * fTypesList of data types definition.Definition TROOT.h:141; TROOT::GetColorTColor * GetColor(Int_t color) constReturn address of color with index color.Definition TROOT.cxx:1536; TROOT::GetGlobalTGlobal * GetGlobal(const char *name, Bool_t load=kFALSE) constReturn pointer to global variable by name.Definition TROOT.cxx:1631; TROOT::FindSTLClassTClass * FindSTLClass(const char *name, Bool_t load, Bool_t silent=kFALSE) constreturn a TClass object corresponding to 'name' assuming it is an STL container.Definition TROOT.cxx:1484; TROOT::fStreamerInfoTSeqCollection * fStreamerInfoList of active StreamerInfo classes.Definition TROOT.h:159; TROOT::Appendvoid Append(TObject *obj, Bool_t replace=kFALSE) overrideAppend object to this directory.Definition TROOT.cxx:1047; TROOT::GetIconPathstatic const TString & GetIconPath()Get the icon path in the installation. Static utility function.Definition TROOT.cxx:3168; TROOT::GetListOfGlobalFunctionsTCollection * GetListOfGlobalFunctions(Bool_t load=kFALSE)Return list containing the TFunctions currently defined.Definition TROOT.cxx:1826; TROOT::fGitDateTString fGitDateDate and time when make was run.Definition TROOT.h:122; TROOT::fSpecialsTSeqCollection * fSpecialsList of special obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:150133,load,load,150133,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['load'],['load']
Performance,"constReturn path name of obj somewhere in the //root/... path.Definition TROOT.cxx:1473; TROOT::ConvertVersionInt2Codestatic Int_t ConvertVersionInt2Code(Int_t v)Convert version as an integer to version code as used in RVersion.h.Definition TROOT.cxx:2934; TROOT::ResetClassSavedvoid ResetClassSaved()Reset the ClassSaved status of all classes.Definition TROOT.cxx:1096; TROOT::GetTTFFontDirstatic const TString & GetTTFFontDir()Get the fonts directory in the installation. Static utility function.Definition TROOT.cxx:3193; TROOT::fForceStyleBool_t fForceStyleForce setting of current style when reading objects.Definition TROOT.h:133; TROOT::MakeDefCanvasTCanvas * MakeDefCanvas() constReturn a default canvas.Definition TROOT.cxx:1554; TROOT::fTypesTCollection * fTypesList of data types definition.Definition TROOT.h:141; TROOT::GetColorTColor * GetColor(Int_t color) constReturn address of color with index color.Definition TROOT.cxx:1536; TROOT::GetGlobalTGlobal * GetGlobal(const char *name, Bool_t load=kFALSE) constReturn pointer to global variable by name.Definition TROOT.cxx:1631; TROOT::FindSTLClassTClass * FindSTLClass(const char *name, Bool_t load, Bool_t silent=kFALSE) constreturn a TClass object corresponding to 'name' assuming it is an STL container.Definition TROOT.cxx:1484; TROOT::fStreamerInfoTSeqCollection * fStreamerInfoList of active StreamerInfo classes.Definition TROOT.h:159; TROOT::Appendvoid Append(TObject *obj, Bool_t replace=kFALSE) overrideAppend object to this directory.Definition TROOT.cxx:1047; TROOT::GetIconPathstatic const TString & GetIconPath()Get the icon path in the installation. Static utility function.Definition TROOT.cxx:3172; TROOT::GetListOfGlobalFunctionsTCollection * GetListOfGlobalFunctions(Bool_t load=kFALSE)Return list containing the TFunctions currently defined.Definition TROOT.cxx:1826; TROOT::fGitDateTString fGitDateDate and time when make was run.Definition TROOT.h:122; TROOT::fSpecialsTSeqCollection * fSpecialsList of special obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:150309,load,load,150309,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['load'],['load']
Performance,"constTClass; GetDict(const char *cname)TClassstatic; GetDict(const std::type_info &info)TClassstatic; GetDictionary(const char *name)TDictionarystatic; GetDictionary(const std::type_info &typeinfo)TDictionarystatic; GetDirectoryAutoAdd() constTClass; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetFunctionTemplate(const char *name)TClass; GetHeapInstanceCount() constTClassinline; GetIconName() constTObjectvirtual; GetIdMap()TClassprivatestatic; GetImplFileLine() constTClassinline; GetImplFileName() constTClassinline; GetInstanceCount() constTClassinline; GetIsAProxy() constTClass; GetLastReadInfo() constTClassinline; GetListOfAllPublicDataMembers(Bool_t load=kTRUE)TClass; GetListOfAllPublicMethods(Bool_t load=kTRUE)TClass; GetListOfBases()TClass; GetListOfDataMembers(Bool_t load=kTRUE)TClass; GetListOfEnums(Bool_t load=kTRUE)TClass; GetListOfFunctionTemplates(Bool_t load=kTRUE)TClass; GetListOfMethodOverloads(const char *name) constTClass; GetListOfMethods(Bool_t load=kTRUE)TClass; GetListOfRealData() constTClassinline; GetListOfUsingDataMembers(Bool_t load=kTRUE)TClass; GetMenuItems(TList *listitems)TClass; GetMenuList() constTClass; GetMerge() constTClass; GetMethod(const char *method, const char *params, Bool_t objectIsConst=kFALSE)TClass; GetMethodAllAny(const char *method)TClass; GetMethodAny(const char *method)TClass; GetMethodList()TClassprivate; GetMethodWithPrototype(const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch)TClass; GetMissingDictionaries(THashTable &result, bool recurse=false)TClass; GetMissingDictionariesForBaseClasses(TCollection &result, TCollection &visited, bool recurse)TClassprotected; GetMissingDictionariesForMembers(TCollection &result, TCollection &visited, bool recurse)TClassprotected; GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)TClassprotected; GetMissingDictionariesWithRecursionCheck(TCollection &re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass-members.html:9622,load,load,9622,doc/master/classTClass-members.html,https://root.cern,https://root.cern/doc/master/classTClass-members.html,1,['load'],['load']
Performance,"constexpr Version_t RooCachedPdf::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 51 of file RooCachedPdf.h. ◆ clone(). TObject * RooCachedPdf::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 26 of file RooCachedPdf.h. ◆ DeclFileName(). static const char * RooCachedPdf::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 51 of file RooCachedPdf.h. ◆ evaluate(). double RooCachedPdf::evaluate ; (; ); const. inlineoverrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 39 of file RooCachedPdf.h. ◆ fillCacheObject(). void RooCachedPdf::fillCacheObject ; (; RooAbsCachedPdf::PdfCacheElem & ; cache); const. overrideprotectedvirtual . Update contents of cache histogram by resampling the input p.d.f. ; Note that the cache is filled with normalized p.d.f values so that the RooHistPdf that represents the cache contents can be explicitly declared as self normalized eliminating the need for superfluous numeric calculations of unit normalization.s ; Implements RooAbsCachedPdf.; Definition at line 92 of file RooCachedPdf.cxx. ◆ inputBaseName(). const char * RooCachedPdf::inputBaseName ; (; ); const. inlineoverrideprotectedvirtual . Return the base name for cache objects, in this case the name of the cached p.d.f. ; Implements RooAbsCachedPdf.; Definition at line 33 of file RooCachedPdf.h. ◆ IsA(). TClass * RooCachedPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsCachedPdf.; Definition at line 51 of file RooCachedPdf.h. ◆ payloadUniqueSuffix(). const char * RooCachedPdf::payloadUniqueSuffix ; (; ); const. inlineoverrideprotectedvirtual . Reimplemented from RooAbsCachedPdf.; Definition at line 44 of file RooCachedPdf.h. ◆ preferredObservableScanOrd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:81216,cache,cache,81216,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,1,['cache'],['cache']
Performance,"constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToVStore(RooVectorDataStore& vstore). void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and UInt_t; branch in that order. If any of these are found the buffer for; that branch is set to a correctly typed conversion buffer in this; RooRealVar. A flag is set that will cause copyCache to copy the; object value from the appropriate conversion buffer instead of; the _value buffer. void fillTreeBranch(TTree& t); Fill the tree branch that associated with this object with its curre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsReal.html:57144,cache,cached,57144,root/html532/RooAbsReal.html,https://root.cern,https://root.cern/root/html532/RooAbsReal.html,8,['cache'],"['cache', 'cached']"
Performance,"continuous and discrete) ;  Probability Density Functions (PDF)Probability density functions of various statistical distributions (continuous and discrete) ;  Cumulative Distribution Functions (CDF)Cumulative distribution functions of various distributions ;  Statistical functions from truncated distributionsStatistical functions for the truncated distributions ;  Quantile FunctionsInverse functions of the cumulative distribution functions and the inverse of the complement of the cumulative distribution functions for various distributions ;  Special functionsSpecial mathematical functions ;  QuasiRandom number generators and distributionsClasses for generating QuasiRandom numbers and based on GSL ;  Matrix Linear AlgebraThe ROOT Matrix Linear Algebra classes ;  TMinuitThe Minuit Minimization package ;  Minuit2 Minimization LibraryNew Object-oriented implementation of the MINUIT minimization package ;  Physics VectorsThe Physics Vectors classes ;  ►SMatrixSMatrix Package for high performance vector and matrix computations ;  Expression Template Classes;  Generic Template FunctionsThese functions apply for any type T, such as a scalar, a vector or a matrix ;  Vector Template FunctionsThese functions apply to SVector types (and also to Vector expressions) and can return a vector expression or a scalar, like in the Dot product, or a matrix, like in the Tensor product ;  Matrix Template FunctionsThese function apply to matrices (and also Matrix expression) and can return a matrix expression of a particular defined type, like in the matrix multiplication or a vector, like in the matrix-vector product or a scalar like in the Similarity vector-matrix product ;  SMatrix Storage Representation;  Matrix and Vector classesClasses representing Matrices and Vectors of arbitrary type and dimension ;  Unuran;  VecOps;  ▼Monte CarloThe Monte Carlo related packages ;  EGParticle Data Group interface ;  Pythia6The Pythia6 interface ;  Pythia8The Pythia8 interface ;  VMCVirtual Monte C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/modules.html:7062,perform,performance,7062,doc/v614/modules.html,https://root.cern,https://root.cern/doc/v614/modules.html,2,['perform'],['performance']
Performance,"continuous and discrete) ;  Probability Density Functions (PDF)Probability density functions of various statistical distributions (continuous and discrete) ;  Cumulative Distribution Functions (CDF)Cumulative distribution functions of various distributions ;  Statistical functions from truncated distributionsStatistical functions for the truncated distributions ;  Quantile FunctionsInverse functions of the cumulative distribution functions and the inverse of the complement of the cumulative distribution functions for various distributions ;  Special functionsSpecial mathematical functions ;  QuasiRandom number generators and distributionsClasses for generating QuasiRandom numbers and based on GSL ;  Matrix Linear AlgebraThe ROOT Matrix Linear Algebra classes ;  TMinuitThe Minuit Minimization package ;  Minuit2 Minimization LibraryNew Object-oriented implementation of the MINUIT minimization package ;  Physics VectorsThe Physics Vectors classes ;  ►SMatrixSMatrix Package for high performance vector and matrix computations ;  Expression Template Classes;  Generic Template FunctionsThese functions apply for any type T, such as a scalar, a vector or a matrix ;  Vector Template FunctionsThese functions apply to SVector types (and also to Vector expressions) and can return a vector expression or a scalar, like in the Dot product, or a matrix, like in the Tensor product ;  Matrix Template FunctionsThese function apply to matrices (and also Matrix expression) and can return a matrix expression of a particular defined type, like in the matrix multiplication or a vector, like in the matrix-vector product or a scalar like in the Similarity vector-matrix product ;  SMatrix Storage Representation;  Matrix and Vector classesClasses representing Matrices and Vectors of arbitrary type and dimension ;  Unuran;  ▼Monte CarloThe Monte Carlo related packages ;  EGParticle Data Group interface ;  Pythia6The Pythia6 interface ;  Pythia8The Pythia8 interface ;  VMCVirtual Monte Carlo ;  ▼",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/modules.html:6795,perform,performance,6795,doc/v608/modules.html,https://root.cern,https://root.cern/doc/v608/modules.html,3,['perform'],['performance']
Performance,controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooCategoryProxy_indexCatIndex category; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; Int_t_numPdfNumber of registered PDFs; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooObjCacheManager_partIntMgrComponent normalization manager; TList_pdfProxyListList of PDF proxies (named after applicable category state); Int_tRooAbsReal::_plotBinsNumber of plot bins; const TNamed*_plotCoefNormRange; RooSetProxy_plotCoefNormSet; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tR,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimultaneous.html:38486,cache,cache,38486,root/html526/RooSimultaneous.html,https://root.cern,https://root.cern/root/html526/RooSimultaneous.html,1,['cache'],['cache']
Performance,controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooCategoryProxy_indexCatIndex category; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; Int_t_numPdfNumber of registered PDFs; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooObjCacheManager_partIntMgrComponent normalization manager; TList_pdfProxyListList of PDF proxies (named after applicable category state); Int_tRooAbsReal::_plotBinsNumber of plot bins; const TNamed*_plotCoefNormRange; RooSetProxy_plotCoefNormSet; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag f,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooSimultaneous.html:39060,cache,cache,39060,root/html528/RooSimultaneous.html,https://root.cern,https://root.cern/root/html528/RooSimultaneous.html,1,['cache'],['cache']
Performance,controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooCategoryProxy_indexCatIndex category; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; Int_t_numPdfNumber of registered PDFs; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooObjCacheManager_partIntMgrComponent normalization manager; TList_pdfProxyListList of PDF proxies (named after applicable category state); Int_tRooAbsReal::_plotBinsNumber of plot bins; const TNamed*_plotCoefNormRange; RooSetProxy_plotCoefNormSet; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selectio,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooSimultaneous.html:39326,cache,cache,39326,root/html530/RooSimultaneous.html,https://root.cern,https://root.cern/root/html530/RooSimultaneous.html,1,['cache'],['cache']
Performance,controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooRealProxy_nNumber of expected events; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigN,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooExtendedTerm.html:37461,cache,cache,37461,root/html526/RooExtendedTerm.html,https://root.cern,https://root.cern/root/html526/RooExtendedTerm.html,1,['cache'],['cache']
Performance,controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooRealProxy_nNumber of expected events; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC genera,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooExtendedTerm.html:37843,cache,cache,37843,root/html528/RooExtendedTerm.html,https://root.cern,https://root.cern/root/html528/RooExtendedTerm.html,1,['cache'],['cache']
Performance,controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooRealProxy_nNumber of expected events; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculatin,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooExtendedTerm.html:38312,cache,cache,38312,root/html530/RooExtendedTerm.html,https://root.cern,https://root.cern/root/html530/RooExtendedTerm.html,1,['cache'],['cache']
Performance,controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooRealProxy_nNumber of expected events; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalcul,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooExtendedTerm.html:38715,cache,cache,38715,root/html532/RooExtendedTerm.html,https://root.cern,https://root.cern/root/html532/RooExtendedTerm.html,1,['cache'],['cache']
Performance,"controlling global inhibit of dirty state propagation; static Int_tRooPrintable::_nameLength; RooAbsArg::OperMode_operModeDirty state propagation mode; RooArgSet*_ownedComponents! Set of owned component; Bool_t_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TList_proxyListlist of proxies; RooRefCountList_serverListlist of server objects; Bool_t_shapeDirtyFlag set if value needs recalculating because input shapes modified; map<std::string,std::string>_stringAttribString attributes; Bool_t_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_t_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsArg(); Destructor. void setDirtyInhibit(Bool_t flag); Control global dirty inhibit mode. When set to true no value or shape dirty; flags are propagated and cache is always considered to be dirty. void setACleanADirty(Bool_t flag); This global switch changes the cache mode of all objects marked as 'always clean'; to 'always dirty'. For internal use in RooRealIntegral. void verboseDirty(Bool_t flag); Activate verbose messaging related to dirty flag propagation. Bool_t isCloneOf(const RooAbsArg& other) const; Check if this object was created as a clone of 'other'. void setAttribute(const Text_t* name, Bool_t value = kTRUE); Set (default) or clear a named boolean attribute of this object. Bool_t getAttribute(const Text_t* name) const; Check if a named attribute is set. By default, all attributes are unset. void setStringAttribute(const Text_t* key, const Text_t* value); Associate string 'value' to this object under key 'key'. const Text_t* getStringAttribute(const Text_t* key) const; Get string attribute mapped under key 'key'. Returns null pointer; if no attribute exists under that key. void setTransientAttribute(const Text_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:17601,cache,cache,17601,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,3,['cache'],['cache']
Performance,"convVar, RooAbsPdf &pdf1, RooAbsPdf &pdf2, Int_t ipOrder=2);  Constructor for numerical (FFT) convolution of PDFs. ;  ;  RooFFTConvPdf (const char *name, const char *title, RooRealVar &convVar, RooAbsPdf &pdf1, RooAbsPdf &pdf2, Int_t ipOrder=2);  Constructor for numerical (FFT) convolution of PDFs. ;  ;  RooFFTConvPdf (const RooFFTConvPdf &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooFFTConvPdf () override;  Destructor. ;  ; double bufferFraction () const;  Return value of buffer fraction applied in FFT calculation array beyond either end of the observable domain to reduce cyclical effects. ;  ; BufStrat bufferStrategy () const;  Return the strategy currently used to fill the buffer: 'Extend' means is that the input p.d.f convolution observable range is widened to include the buffer range 'Flat' means that the buffer is filled with the p.d.f. ;  ; const RooArgSet & cacheObservables () const;  ; TObject * clone (const char *newname) const override;  ; Int_t getMaxVal (const RooArgSet &vars) const override;  Advertise capability to determine maximum value of function for given set of observables. ;  ; TClass * IsA () const override;  ; double maxVal (Int_t code) const override;  Return maximum value for set of observables identified by code assigned in getMaxVal. ;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooNumConvPdf to more intuitively reflect the contents of the product operator construction. ;  ; void setBufferFraction (double frac);  Change the size of the buffer on either side of the observable range to frac times the size of the range of the convolution observable. ;  ; void setBufferStrategy (BufStrat bs);  Change strategy to fill the overflow buffer on either side of the convolution observable range. ;  ; void setCacheObservables (const RooArgSet &obs);  ; void setShift (double val1, double val2);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void Stream",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:8042,cache,cacheObservables,8042,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cacheObservables']
Performance,"copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooNumConvolution*_conv! Actual convolution calculation; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init! do not persist; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumConvPdf.html:44454,cache,cache,44454,root/html602/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html602/RooNumConvPdf.html,4,['cache'],['cache']
Performance,"copy it in gProgName.Definition TSystem.cxx:226; TSystem::GetBuildArchvirtual const char * GetBuildArch() constReturn the build architecture.Definition TSystem.cxx:3875; TSystem::Abortvirtual void Abort(int code=0)Abort the application.Definition TSystem.cxx:725; TSystem::RemoveTimervirtual TTimer * RemoveTimer(TTimer *t)Remove timer from list of system timers.Definition TSystem.cxx:481; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::Resetvoid Reset()Reset the timer.Definition TTimer.cxx:159; TUrlThis class represents a WWW compatible URL.Definition TUrl.h:33; TUrl::GetUrlconst char * GetUrl(Bool_t withDeflt=kFALSE) constReturn full URL.Definition TUrl.cxx:390; TUrl::GetFileAndOptionsconst char * GetFileAndOptions() constReturn the file and its options (the string specified behind the ?).Definition TUrl.cxx:504; TUrl::GetFileconst char * GetFile() constDefinition TUrl.h:69; TUrl::GetProtocolconst char * GetProtocol() constDefinition TUrl.h:64; TVirtualXSemi-Abstract base class defining a generic interface to the underlying, low level,...Definition TVirtualX.h:46; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::EnableThreadSafetyvoid EnableThreadSafety()Enable support for multi-threading within the ROOT code in particular, enables the global mutex to ma...Definition TROOT.cxx:501; TClassEdit::GetUnqualifiedNameconst char * GetUnqualifiedName(const char *name)Return the start of the unqualified name include in 'original'.Definition TClassEdit.cxx:942. corebasesrcTApplication.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:04 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:108264,multi-thread,multi-threading,108264,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,2,['multi-thread'],['multi-threading']
Performance,"cord a TFriendElement that we need to warn when the chain switches to a new file (typically this is because this chain is a friend of another TChain) ;  ; virtual void RemoveExternalFriend (TFriendElement *);  Removes external friend. ;  ; virtual bool SetAlias (const char *aliasName, const char *aliasFormula);  Set a tree variable alias. ;  ; virtual void SetAutoFlush (Long64_t autof=-30000000);  This function may be called at the start of a program to change the default value for fAutoFlush. ;  ; virtual void SetAutoSave (Long64_t autos=-300000000);  In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSave point. ;  ; virtual void SetBasketSize (const char *bname, Int_t buffsize=16000);  Set a branch's basket size. ;  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T **add, TBranch **ptr=nullptr);  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T *add, TBranch **ptr=nullptr);  ; virtual Int_t SetCacheEntryRange (Long64_t first, Long64_t last);  interface to TTreeCache to set the cache entry range ;  ; virtual void SetCacheLearnEntries (Int_t n=10);  Interface to TTreeCache to set the number of entries for the learning phase. ;  ; virtual void SetChainOffset (Long64_t offset=0);  ; virtual void SetCircular (Long64_t maxEntries);  Enable/Disable circularity for this tree. ;  ; virtual void SetClusterPrefetch (bool enabled);  ; virtual void SetDebug (Int_t level=1, Long64_t min=0, Long64_t max=9999999);  Set the debug level and the debug range. ;  ; virtual void SetDefaultEntryOffsetLen (Int_t newdefault, bool updateExisting=false);  Update the default value for the branch's fEntryOffsetLen. ;  ; virtual Long64_t SetEntries (Long64_t n=-1);  Change number of entries in the tree. ;  ; virtual void SetEstimate (Long64_t nentries=1000000);  Set number of entries to estimate variable limits. ;  ; virtual void SetFileNumber (Int_t number=0);  Set fFileNumber to number. ;  ; virtual void Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:25695,cache,cache,25695,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,2,['cache'],['cache']
Performance,"cord a TFriendElement that we need to warn when the chain switches to a new file (typically this is because this chain is a friend of another TChain) ;  ; virtual void RemoveExternalFriend (TFriendElement *);  Removes external friend. ;  ; virtual bool SetAlias (const char *aliasName, const char *aliasFormula);  Set a tree variable alias. ;  ; virtual void SetAutoFlush (Long64_t autof=-30000000);  This function may be called at the start of a program to change the default value for fAutoFlush. ;  ; virtual void SetAutoSave (Long64_t autos=-300000000);  In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSave point. ;  ; virtual void SetBasketSize (const char *bname, Int_t buffsize=16000);  Set a branch's basket size. ;  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T **add, TBranch **ptr=nullptr);  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T *add, TBranch **ptr=nullptr);  ; virtual Int_t SetCacheEntryRange (Long64_t first, Long64_t last);  interface to TTreeCache to set the cache entry range ;  ; virtual void SetCacheLearnEntries (Int_t n=10);  Interface to TTreeCache to set the number of entries for the learning phase. ;  ; virtual void SetChainOffset (Long64_t offset=0);  ; virtual void SetCircular (Long64_t maxEntries);  Enable/Disable circularity for this tree. ;  ; virtual void SetClusterPrefetch (bool enabled);  ; virtual void SetDefaultEntryOffsetLen (Int_t newdefault, bool updateExisting=false);  Update the default value for the branch's fEntryOffsetLen. ;  ; virtual Long64_t SetEntries (Long64_t n=-1);  Change number of entries in the tree. ;  ; virtual void SetEstimate (Long64_t nentries=1000000);  Set number of entries to estimate variable limits. ;  ; virtual void SetFileNumber (Int_t number=0);  Set fFileNumber to number. ;  ; virtual void SetImplicitMT (bool enabled);  ; ROOT::TIOFeatures SetIOFeatures (const ROOT::TIOFeatures &);  Provide the end-user with the ab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofChain.html:26634,cache,cache,26634,doc/master/classTProofChain.html,https://root.cern,https://root.cern/doc/master/classTProofChain.html,1,['cache'],['cache']
Performance,"corresponding algorithm. For example ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS""); will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization The current defaults are (""Minuit"",""Migrad""). See the documentation of the ROOT::Math::MinimizerOptions for the available minimizers in ROOT and their corresponding algorithms.; ROOT::Math::MinimizerOptions::SetDefaultTolerance for setting a different tolerance value for the minimization.; ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls for setting the maximum number of function calls.; ROOT::Math::MinimizerOptions::SetDefaultPrintLevel for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing. Other options are possible depending on the Minimizer used, see the corresponding documentation. The default minimizer can be also set in the resource file in etc/system.rootrc. For example; Root.Fitter: Minuit2. Chi-square Fits; By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method is used where the residual for each bin is computed using as error the observed value (the bin error) returned by TH1::GetBinError. \[; Chi2 = \sum_{i}{ \left(\frac{y(i) - f(x(i) | p )}{e(i)} \right)^2 }; \]. where y(i) is the bin content for each bin i, x(i) is the bin center and e(i) is the bin error (sqrt(y(i) for an un-weighted histogram). Bins with zero errors are excluded from the fit. See also later the note on the treatment of empty bins. When using option ""I"" the residual is computed not using the function value at the bin center, f(x(i)|p), but the integral of the function in the bin, Integral{ f(x|p)dx }, divided by the bin volume. When using option P (Pearson chi2), the expected error computed as e(i) = sqrt(f(x(i)|p)) is used. In this case empty bins are considered in the fit. Both chi-square methods should not be used when the bin content represent counts, especially in case of low bi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:131227,perform,performed,131227,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['perform'],['performed']
Performance,"cover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); Bool_tRollback(); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t, TFile::ERelativeTo = kBeg); voidSetArrayLimit(Int_t limit = 20); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSQLFile.html:18569,cache,cacheDir,18569,root/html532/TSQLFile.html,https://root.cern,https://root.cern/root/html532/TSQLFile.html,1,['cache'],['cacheDir']
Performance,"cover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); Bool_tRollback(); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t, TFile::ERelativeTo = kBeg); voidSetArrayLimit(Int_t limit = 20); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSQLFile.html:18648,cache,cacheDir,18648,root/html534/TSQLFile.html,https://root.cern,https://root.cern/root/html534/TSQLFile.html,3,['cache'],['cacheDir']
Performance,"created in the $ROOTSYS/lib($ROOTSYS/bin on Windows) directory and a top Python module, ROOT.py, will be copied into the same place. The final step is to setup the shell environment, which is similar to what is described in the chapter ‘Environment Settings’. Note that the $ROOTSYS entries are probably already there if you followed the standard instructions, and that the PYTHONDIR entries should be replaced as appropriate by your choice at configuration time, or be left out if you had the configuration script pick up them up from a default location.; 19.1.5 Using PyROOT; Since it is an extension module, the usage of PyROOT probably comes naturally if you’re used to Python. In general, PyROOT attempts to allow working in both Python and ROOT style, and although it is succeeding, it isn’t perfect: there are edges. The following sections explain in some detail what you can expect, and what you need to watch out for.; 19.1.5.1 Access to ROOT Classes; Before a ROOT class can be used from Python, its dictionary needs to be loaded into the current process. Starting with ROOT version 4.00/06, this happens automatically for all classes that are declared to the auto-loading mechanism through so-called rootmap files. Effectively, this means that all classes in the ROOT distributions are directly available for import. For example:; from ROOT import TCanvas # available at startup; c = TCanvas(). from ROOT import TLorentzVector # triggers auto-load of libPhysics; l = TLorentzVector(); Although it is not recommended, a simple way of working with PyROOT is doing a global import:; from ROOT import *. c = TCanvas(); l = TLorentzVector(); Keeping the ROOT namespace (“import ROOT”), or only importing from ROOT those classes that you will actually use (see above), however, will always be cleaner and clearer:; import ROOT. c = ROOT.TCanvas(); l = ROOT.TLorentzVector(); Since it is foreseen that most people will use the simple approach anyway, the request to copy all from module ROOT will",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1050370,load,loaded,1050370,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loaded']
Performance,"creenShiftRange, Bool_t mod1, Bool_t mod2) const;  Adjust a passed REFERENCE value 'val', based on screenShift delta. ;  ; Double_t AdjustDelta (Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const;  Adjust a passed screen value and apply modifiers. ;  ; virtual void Apply (const TGLBoundingBox &sceneBox, const TGLRect *pickRect=nullptr) const =0;  ; virtual void Configure (Double_t zoom, Double_t dolly, Double_t center[3], Double_t hRotate, Double_t vRotate)=0;  ; virtual Bool_t Dolly (Int_t delta, Bool_t mod1, Bool_t mod2);  Dolly the camera - 'move camera along eye line, retaining lens focal length'. ;  ; void DrawDebugAids () const;  Draw out some debugging aids for the camera: ;  ; TGLVector3 EyeDirection () const;  Extract the camera eye direction (vector), running from EyePoint() Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; TGLVertex3 EyePoint () const;  Return the camera eye point (vertex) in world space Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; TGLVertex3 FrustumCenter () const;  Find the center of the camera frustum from intersection of planes This method will work even with parallel left/right & top/bottom and infinite eye point of ortho cameras Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; Rgl::EOverlap FrustumOverlap (const TGLBoundingBox &box) const;  Calculate overlap (kInside, kOutside, kPartial) of box with camera frustum Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; const TGLPlane & FrustumPlane (EFrustumPlane plane) const;  ; const TGLMatrix & GetCamBase () const;  ; const TGLMatrix & GetCamTrans () const;  ; Double_t * GetCenterVec ();  ; Bool_t GetExternalCenter ();  ; Double_t GetFarClip () const;  ; Double_t * GetFixDefCenterVec ();  ; Double_t GetNearClip () const;  ; Double_t GetTheta () const;  Get angle between camer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLCamera.html:3284,cache,cache,3284,doc/master/classTGLCamera.html,https://root.cern,https://root.cern/doc/master/classTGLCamera.html,1,['cache'],['cache']
Performance,"cribing current object ; Reimplemented from TTreeCache.; Definition at line 159 of file TTreeCacheUnzip.h. ◆ IsParallelUnzip(). bool TTreeCacheUnzip::IsParallelUnzip ; (; ). static . Static function that tells wether the multithreading unzipping is activated. ; Definition at line 415 of file TTreeCacheUnzip.cxx. ◆ operator=(). TTreeCacheUnzip & TTreeCacheUnzip::operator= ; (; const TTreeCacheUnzip & ; ). privatedelete . ◆ Print(). void TTreeCacheUnzip::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; Like:; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:32658,cache,cache,32658,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,1,['cache'],['cache']
Performance,"cribing current object ; Reimplemented from TTreeCache.; Definition at line 159 of file TTreeCacheUnzip.h. ◆ IsParallelUnzip(). bool TTreeCacheUnzip::IsParallelUnzip ; (; ). static . Static function that tells wether the multithreading unzipping is activated. ; Definition at line 416 of file TTreeCacheUnzip.cxx. ◆ operator=(). TTreeCacheUnzip & TTreeCacheUnzip::operator= ; (; const TTreeCacheUnzip & ; ). privatedelete . ◆ Print(). void TTreeCacheUnzip::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print cache statistics. ; Like:; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCacheUnzip.html:32662,cache,cache,32662,doc/master/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/master/classTTreeCacheUnzip.html,1,['cache'],['cache']
Performance,"cript if it exists on the client.; If opt == 0, both the preparation and building phases are run.; If opt == 1, only the preparation phase (asserting and, eventually, downloading; of the package) is done; '*path' contains the full path to the; package to be passed in the next call; If opt == 2, only the building phase is run using *path .; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kBuildPackage; case). Keep in sync in case of changes. Int_t LoadPackage(const char* package, Bool_t notOnClient = kFALSE, TList* loadopts = 0, TList* workers = 0); Load specified package. Executes the PROOF-INF/SETUP.C script; on all active nodes. If notOnClient = true, don't load package; on the client. The default is to load the package also on the client.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t LoadPackageOnClient(const char* package, TList* loadopts = 0); Load specified package in the client. Executes the PROOF-INF/SETUP.C; script on the client. Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kLoadPackage; case). Keep in sync in case of changes.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackage(const char* package); Unload specified package.; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackageOnClient(const char* package); Unload a specific package on the client.; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::UnloadPackage; case). Keep in sync",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:72743,load,loadopts,72743,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,3,['load'],['loadopts']
Performance,"cript.C++; To build, load, and execute the function with the same name as the file you can use the .x command. This is the same as executing a named script; you can also provide parameters. The only difference is you need to append a + or a ++.; root[] .x MyScript.C+(4000); Creating shared library /home/./MyScript_C.so; You can select whether the script in compiled with debug symbol or with optimization by appending the letter ‘g’ or ‘O’ after the ‘+’ or ‘++’. Without the specification, the script is compiled with the same level of debugging symbol and optimization as the currently running ROOT executable. For example:; root[] .L MyScript.C++g; will compile MyScript.C with debug symbols; usually this means giving the -g option to compiler.; root[] .L MyScript.C++O; will compile MyScript.C with optimizations; usually this means giving the -O option to compiler. The syntax:; root[] .L MyScript.C++; is using the default optimization level. The initial default is to compile with the same level of optimization as the root executable itself. The default can be changed by:; root[] gSystem->SetAclicMode(TSystem::kDebug);; root[] gSystem->SetAclicMode(TSystem::kOpt);; Note that the commands:; root[] .L MyScript.C+g; root[] .L MyScript.C+O; respectively compile MyScript.C with debug and optimization if the library does not exist yet; they will not change the debug and the optimization level if the library already exist and it is up to date. To use ACLiC from compiled code or from inside another macro, we recommend using gROOT->ProcessLine(). For example, in one script you can use ACLiC to compile and load another script.; gROOT->ProcessLine("".L MyScript.C+""); gROOT->ProcessLine("".L MyScript.C++""); 7.4.2 Setting the Include Path; You can get the include path by typing:; root[] .include; You can append to the include path by typing:; root[] .include $HOME/mypackage/include; In a script you can append to the include path:; gSystem->AddIncludePath("" -I$HOME/mypackage/include ""); Y",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:270857,optimiz,optimization,270857,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['optimiz'],['optimization']
Performance,"cription::IssueSignal ; (; const void * ; handler, . const std::string & ; kind . ). Issue signal, which distributed on all handlers - excluding source handler. ; Definition at line 293 of file RGeomData.cxx. ◆ MakeDrawingJson(). std::string RGeomDescription::MakeDrawingJson ; (; RGeomDrawing & ; drawing, . bool ; has_shapes = false . ). private . Produce JSON for the drawing If TGeoShape appears in the drawing, one has to keep typeinfo But in this case one can exclude several classes which are not interesting, but appears very often. ; Definition at line 1826 of file RGeomData.cxx. ◆ MakeIdsByStack(). std::vector< int > RGeomDescription::MakeIdsByStack ; (; const std::vector< int > & ; stack). Produce list of node ids for given stack If found nodes preselected - use their ids. ; Definition at line 1683 of file RGeomData.cxx. ◆ MakeNodeInfo(). std::unique_ptr< RGeomNodeInfo > RGeomDescription::MakeNodeInfo ; (; const std::vector< int > & ; stack). Change visibility for specified element Returns true if changes was performed. ; Definition at line 1899 of file RGeomData.cxx. ◆ MakePathByStack(). std::vector< std::string > RGeomDescription::MakePathByStack ; (; const std::vector< int > & ; stack). Returns path string for provided stack. ; Definition at line 1716 of file RGeomData.cxx. ◆ MakeShapeDescr(). RGeomDescription::ShapeDescr & RGeomDescription::MakeShapeDescr ; (; TGeoShape * ; shape). private . Find description object and create render information. ; Definition at line 1070 of file RGeomData.cxx. ◆ MakeStackByIds(). std::vector< int > RGeomDescription::MakeStackByIds ; (; const std::vector< int > & ; ids). Creates stack for given array of ids, first element always should be 0. ; Definition at line 1621 of file RGeomData.cxx. ◆ MakeStackByPath(). std::vector< int > RGeomDescription::MakeStackByPath ; (; const std::vector< std::string > & ; path). Produce stack based on string path Used to highlight geo volumes by browser hover event. ; Definition at line 1665 of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html:19775,perform,performed,19775,doc/v632/classROOT_1_1RGeomDescription.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html,2,['perform'],['performed']
Performance,"cription; This class acts as a file cache, registering automatically the baskets from the branches being processed via direct manipulation of TTrees or with tools such as TTree::Draw, TTree::Process, TSelector, TTreeReader and RDataFrame when in the learning phase. The learning phase is by default 100 entries. It can be changed via TTreeCache::SetLearnEntries.; The usage of a TTreeCache can considerably improve the runtime performance at the price of a modest investment in memory, in particular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:3230,cache,cache,3230,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cache']
Performance,"ct ; Reimplemented from TObject.; Definition at line 77 of file TStatistic.h. ◆ ls(). void TStatistic::ls ; (; Option_t * ; option = """"); const. inlineoverridevirtual . The ls function lists the contents of a class on stdout. ; Ls output is typically much less verbose then Dump(). ; Reimplemented from TObject.; Definition at line 75 of file TStatistic.h. ◆ Merge(). Int_t TStatistic::Merge ; (; TCollection * ; in). Merge implementation of TStatistic. ; Parameters. [in]inOther TStatistic objects to be added to the current one. The function merges the statistics of all objects together to form a new one. Merging quantities is done via simple addition for the following class data members:; number of entries fN; the sum of weights fW; the sum of squared weights fW2; the sum of (value*weight) fM. The sum of squared (value*weight) pairs fM2 is updated using the same formula as in TStatistic::Fill() function.; The minimum(maximum) is updated by checking that the minimum(maximum) of the next TStatistic object in the queue is either less(greater) than the current minimum(maximum). ; Definition at line 137 of file TStatistic.cxx. ◆ Print(). void TStatistic::Print ; (; Option_t * ; = """"); const. overridevirtual . Print the content of the object. ; Prints the statistics held by the object in one line. These include the mean, mean error, RMS, the total number of values, the minimum and the maximum. ; Reimplemented from TObject.; Definition at line 115 of file TStatistic.cxx. ◆ Streamer(). void TStatistic::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TStatistic::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 77 of file TStatistic.h. Member Data Documentation. ◆ fM. Double_t TStatistic::fM. private . Sum of elements (i.e. sum of (val * weight) pairs. ; Definition at line 40 of file TStatistic.h. ◆ fM2. Double_t TStatistic::fM2. private . Seco",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStatistic.html:17481,queue,queue,17481,doc/master/classTStatistic.html,https://root.cern,https://root.cern/doc/master/classTStatistic.html,1,['queue'],['queue']
Performance,"ct and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Protected Attributes; TString fName;  ; Bool_t fNewDelete;  ; Int_t fNRargs;  ; Int_t fNUargs;  ; void * fObject;  ; TQConnection * fRedo;  ; Long_t * fRedoArgs;  ; Int_t fState;  ; Int_t fStatus;  ; TString fTitle;  ; TQConnection * fUndo;  ; Long_t * fUndoArgs;  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in linked list ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  . Private Member Functions; TQCommand & operator= (const TQCommand &);  . Friends; class TQUndoManager;  . Additional Inherited Members;  Public Types inherited from TList; typedef TListIter Iterator_t;  ;  Public Types inherited from TCollection; enum  { kInitCapacity = 16; , kInitHashTableCapacity = 17; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:28690,cache,cache,28690,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['cache'],['cache']
Performance,"ct base class for objects that represent a real value and implements functionality common to all real-valued objects such as the ability to plot them, to construct integrals of them, the ability to advertise (partial) analytical integrals etc ;  CEvalError;  CPlotOpt;  CRooAbsRealLValueRooAbsRealLValue is the common abstract base class for objects that represent a real value that may appear on the left hand side of an equation ('lvalue') Each implementation must provide a setVal() member to allow direct modification of the value ;  CRooAbsRootFinderRooAbsRootFinder is the abstract interface for finding roots of real-valued 1-dimensional function that implements the RooAbsFunc interface ;  CRooAbsSelfCachedPdfRooAbsSelfCachedPdf is an abstract base class for probability density functions whose output is cached in terms of a histogram in all observables between getVal() and evaluate() ;  CRooAbsSelfCachedRealRooAbsSelfCachedReal is an abstract base class for functions whose output is cached in terms of a histogram in all observables between getVal() and evaluate() ;  CRooAbsStringRooAbsString is the common abstract base class for objects that represent a string value ;  CRooAbsStudyRooAbsStudy is an abstract base class for RooStudyManager modules ;  CRooAbsTestStatisticRooAbsTestStatistic is the abstract base class for all test statistics ;  CRooAcceptRejectClass RooAcceptReject is a generic toy monte carlo generator implement the accept/reject sampling technique on any positively valued function ;  CRooAdaptiveGaussKronrodIntegrator1DRooAdaptiveGaussKronrodIntegrator1D implements the Gauss-Kronrod integration algorithm ;  CRooAdaptiveIntegratorNDRooAdaptiveIntegratorND implements an adaptive one-dimensional numerical integration algorithm ;  CRooAddGenContextRooAddGenContext is an efficient implementation of the generator context specific for RooAddPdf PDFs ;  ►CRooAdditionRooAddition calculates the sum of a set of RooAbsReal terms, or when constructed with two sets, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:79530,cache,cached,79530,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,4,['cache'],['cached']
Performance,"ct identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to functions whose running integral is calculated; RooRealProxyxIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* binningName = ""cache""); Construct running integral of function '_func' over x_print from; the lower bound on _x to the present value of _x using a numeric; sampling technique. The sampling frequency is controlled by the; binning named 'bname' and a default second order interpolation; is applied to smooth the histogram-based c.d.f. RooNumRunningInt(const RooNumRunningInt& other, const char* name = 0); Copy constructor. ~RooNumRunningInt(); Destructor. const char* inputBaseName() const; Return unique name for RooAbsCachedPdf cache components; constructed from input function name. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill the cache object by calling its calculate() method. RooArgSet* actualObservables(const RooArgSet& nset) const; Return observable in nset to be cached by RooAbsCachedPdf; this is always the x observable that is integrated. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters of the cache created by RooAbsCachedPdf.; These are always the input functions parameter, but never the; integrated variable x. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Create custom cache element for running integral calculations. Double_t evaluate() const; Dummy function that is never called. TObject* clone(const char* newname) const; { return new RooNumRunningInt(*this,newname); }. const char* binningName() const; { return _binningName.c_str() ; }. const char* payloadUniqueSuffix() const; { return func.arg().aggregateCacheUniqueSuffix() ; }. » Last changed: Mon Jul 4 15:23:36 2011 » Last generated: 2011-07-04 15:23; This page has been autom",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumRunningInt.html:35616,cache,cacheFunc,35616,root/html530/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html530/RooNumRunningInt.html,2,['cache'],"['cache', 'cacheFunc']"
Performance,"ct identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to functions whose running integral is calculated; RooRealProxyxIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* binningName = ""cache""); Construct running integral of function '_func' over x_print from; the lower bound on _x to the present value of _x using a numeric; sampling technique. The sampling frequency is controlled by the; binning named 'bname' and a default second order interpolation; is applied to smooth the histogram-based c.d.f. RooNumRunningInt(const RooNumRunningInt& other, const char* name = 0); Copy constructor. ~RooNumRunningInt(); Destructor. const char* inputBaseName() const; Return unique name for RooAbsCachedPdf cache components; constructed from input function name. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill the cache object by calling its calculate() method. RooArgSet* actualObservables(const RooArgSet& nset) const; Return observable in nset to be cached by RooAbsCachedPdf; this is always the x observable that is integrated. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters of the cache created by RooAbsCachedPdf.; These are always the input functions parameter, but never the; integrated variable x. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Create custom cache element for running integral calculations. Double_t evaluate() const; Dummy function that is never called. TObject* clone(const char* newname) const; { return new RooNumRunningInt(*this,newname); }. const char* binningName() const; { return _binningName.c_str() ; }. const char* payloadUniqueSuffix() const; { return func.arg().aggregateCacheUniqueSuffix() ; }. » Last changed: Thu Nov 3 20:08:53 2011 » Last generated: 2011-11-03 20:08; This page has been autom",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumRunningInt.html:35995,cache,cacheFunc,35995,root/html532/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html532/RooNumRunningInt.html,2,['cache'],"['cache', 'cacheFunc']"
Performance,"ct identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to functions whose running integral is calculated; RooRealProxyxIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* binningName = ""cache""); Construct running integral of function '_func' over x_print from; the lower bound on _x to the present value of _x using a numeric; sampling technique. The sampling frequency is controlled by the; binning named 'bname' and a default second order interpolation; is applied to smooth the histogram-based c.d.f. RooNumRunningInt(const RooNumRunningInt& other, const char* name = 0); Copy constructor. ~RooNumRunningInt(); Destructor. const char* inputBaseName() const; Return unique name for RooAbsCachedPdf cache components; constructed from input function name. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill the cache object by calling its calculate() method. RooArgSet* actualObservables(const RooArgSet& nset) const; Return observable in nset to be cached by RooAbsCachedPdf; this is always the x observable that is integrated. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters of the cache created by RooAbsCachedPdf.; These are always the input functions parameter, but never the; integrated variable x. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Create custom cache element for running integral calculations. Double_t evaluate() const; Dummy function that is never called. TObject* clone(const char* newname) const; { return new RooNumRunningInt(*this,newname); }. const char* binningName() const; { return _binningName.c_str() ; }. const char* payloadUniqueSuffix() const; { return func.arg().aggregateCacheUniqueSuffix() ; }. » Last changed: Thu Sep 23 20:00:25 2010 » Last generated: 2010-09-23 20:00; This page has been auto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNumRunningInt.html:35099,cache,cacheFunc,35099,root/html528/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html528/RooNumRunningInt.html,2,['cache'],"['cache', 'cacheFunc']"
Performance,"ct identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to functions whose running integral is calculated; RooRealProxyxIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* binningName = ""cache""); Construct running integral of function '_func' over x_print from; the lower bound on _x to the present value of _x using a numeric; sampling technique. The sampling frequency is controlled by the; binning named 'bname' and a default second order interpolation; is applied to smooth the histogram-based c.d.f. RooNumRunningInt(const RooNumRunningInt& other, const char* name = 0); Copy constructor. ~RooNumRunningInt(); Destructor. const char* inputBaseName() const; Return unique name for RooAbsCachedPdf cache components; constructed from input function name. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill the cache object by calling its calculate() method. RooArgSet* actualObservables(const RooArgSet& nset) const; Return observable in nset to be cached by RooAbsCachedPdf; this is always the x observable that is integrated. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters of the cache created by RooAbsCachedPdf.; These are always the input functions parameter, but never the; integrated variable x. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Create custom cache element for running integral calculations. Double_t evaluate() const; Dummy function that is never called. TObject* clone(const char* newname) const; { return new RooNumRunningInt(*this,newname); }. const char* binningName() const; { return _binningName.c_str() ; }. const char* payloadUniqueSuffix() const; { return func.arg().aggregateCacheUniqueSuffix() ; }. » Last changed: Tue Jun 2 15:32:47 2015 » Last generated: 2015-06-02 15:32; This page has been autom",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooNumRunningInt.html:39730,cache,cacheFunc,39730,root/html604/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html604/RooNumRunningInt.html,2,['cache'],"['cache', 'cacheFunc']"
Performance,"ct identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to functions whose running integral is calculated; RooRealProxyxIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* binningName = ""cache""); Construct running integral of function '_func' over x_print from; the lower bound on _x to the present value of _x using a numeric; sampling technique. The sampling frequency is controlled by the; binning named 'bname' and a default second order interpolation; is applied to smooth the histogram-based c.d.f. RooNumRunningInt(const RooNumRunningInt& other, const char* name = 0); Copy constructor. ~RooNumRunningInt(); Destructor. const char* inputBaseName() const; Return unique name for RooAbsCachedPdf cache components; constructed from input function name. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill the cache object by calling its calculate() method. RooArgSet* actualObservables(const RooArgSet& nset) const; Return observable in nset to be cached by RooAbsCachedPdf; this is always the x observable that is integrated. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters of the cache created by RooAbsCachedPdf.; These are always the input functions parameter, but never the; integrated variable x. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Create custom cache element for running integral calculations. Double_t evaluate() const; Dummy function that is never called. TObject* clone(const char* newname) const; { return new RooNumRunningInt(*this,newname); }. const char* binningName() const; { return _binningName.c_str() ; }. const char* payloadUniqueSuffix() const; { return func.arg().aggregateCacheUniqueSuffix() ; }. » Last changed: Tue Jun 30 14:34:41 2015 » Last generated: 2015-06-30 14:34; This page has been auto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumRunningInt.html:39730,cache,cacheFunc,39730,root/html602/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html602/RooNumRunningInt.html,2,['cache'],"['cache', 'cacheFunc']"
Performance,"ct identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to functions whose running integral is calculated; RooRealProxyxIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* binningName = ""cache""); Construct running integral of function '_func' over x_print from; the lower bound on _x to the present value of _x using a numeric; sampling technique. The sampling frequency is controlled by the; binning named 'bname' and a default second order interpolation; is applied to smooth the histogram-based c.d.f. RooNumRunningInt(const RooNumRunningInt& other, const char* name = 0); Copy constructor. ~RooNumRunningInt(); Destructor. const char* inputBaseName() const; Return unique name for RooAbsCachedPdf cache components; constructed from input function name. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill the cache object by calling its calculate() method. RooArgSet* actualObservables(const RooArgSet& nset) const; Return observable in nset to be cached by RooAbsCachedPdf; this is always the x observable that is integrated. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters of the cache created by RooAbsCachedPdf.; These are always the input functions parameter, but never the; integrated variable x. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Create custom cache element for running integral calculations. Double_t evaluate() const; Dummy function that is never called. TObject* clone(const char* newname) const; { return new RooNumRunningInt(*this,newname); }. const char* binningName() const; { return _binningName.c_str() ; }. const char* payloadUniqueSuffix() const; { return func.arg().aggregateCacheUniqueSuffix() ; }. » Last changed: Tue Mar 10 17:18:18 2015 » Last generated: 2015-03-10 17:18; This page has been auto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumRunningInt.html:38226,cache,cacheFunc,38226,root/html534/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html534/RooNumRunningInt.html,2,['cache'],"['cache', 'cacheFunc']"
Performance,"ct identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to functions whose running integral is calculated; RooRealProxyxIntergrated observable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* binningName = ""cache""); Construct running integral of function '_func' over x_print from; the lower bound on _x to the present value of _x using a numeric; sampling technique. The sampling frequency is controlled by the; binning named 'bname' and a default second order interpolation; is applied to smooth the histogram-based c.d.f. RooNumRunningInt(const RooNumRunningInt& other, const char* name = 0); Copy constructor. ~RooNumRunningInt(); Destructor. const char* inputBaseName() const; Return unique name for RooAbsCachedPdf cache components; constructed from input function name. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Fill the cache object by calling its calculate() method. RooArgSet* actualObservables(const RooArgSet& nset) const; Return observable in nset to be cached by RooAbsCachedPdf; this is always the x observable that is integrated. RooArgSet* actualParameters(const RooArgSet& nset) const; Return the parameters of the cache created by RooAbsCachedPdf.; These are always the input functions parameter, but never the; integrated variable x. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Create custom cache element for running integral calculations. Double_t evaluate() const; Dummy function that is never called. TObject* clone(const char* newname) const; { return new RooNumRunningInt(*this,newname); }. const char* binningName() const; { return _binningName.c_str() ; }. » Last changed: Mon Dec 7 13:48:34 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumRunningInt.html:34810,cache,cacheFunc,34810,root/html526/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html526/RooNumRunningInt.html,2,['cache'],"['cache', 'cacheFunc']"
Performance,"ct is essentially a //; 24// container of several lists pointing to the main ROOT objects. //; 25// //; 26//////////////////////////////////////////////////////////////////////////; 27 ; 28#include ""TDirectory.h""; 29// #include ""TList.h"" // included in TDirectory.h; 30// #include ""RConfigure.h"" // included via Rtypes.h; 31 ; 32#include <atomic>; 33#include <string>; 34#include <vector>; 35#include <utility>; 36 ; 37class TClass;; 38class TCanvas;; 39class TColor;; 40class TDataType;; 41class TFile;; 42class TStyle;; 43class TVirtualPad;; 44class TApplication;; 45class TInterpreter;; 46class TBrowser;; 47class TGlobal;; 48class TFunction;; 49class TFolder;; 50class TPluginManager;; 51class TProcessUUID;; 52class TClassGenerator;; 53class TVirtualMutex;; 54class TROOT;; 55class TListOfDataMembers;; 56class TListOfEnums;; 57class TListOfFunctions;; 58class TListOfFunctionTemplates;; 59class TSeqCollection;; 60class TFunctionTemplate;; 61class TGlobalMappedFunction;; 62 ; 63R__EXTERN TVirtualMutex *gROOTMutex;; 64 ; 65namespace ROOT {; 66namespace Internal {; 67 class TROOTAllocator;; 68 ; 69 TROOT *GetROOT2();; 70 ; 71 // Manage parallel branch processing; 72 void EnableParBranchProcessing();; 73 void DisableParBranchProcessing();; 74 Bool_t IsParBranchProcessingEnabled();; 75 class TParBranchProcessingRAII {; 76 public:; 77 TParBranchProcessingRAII() { EnableParBranchProcessing(); }; 78 ~TParBranchProcessingRAII() { DisableParBranchProcessing(); }; 79 };; 80} } // End ROOT::Internal; 81 ; 82namespace ROOT {; 83 /// \brief Enable support for multi-threading within the ROOT code; 84 /// in particular, enables the global mutex to make ROOT thread safe/aware.; 85 void EnableThreadSafety();; 86 /// \brief Enable ROOT's implicit multi-threading for all objects and methods that provide an internal; 87 /// parallelisation mechanism.; 88 void EnableImplicitMT(UInt_t numthreads = 0);; 89 void DisableImplicitMT();; 90 Bool_t IsImplicitMTEnabled();; 91 UInt_t GetThreadPoolSize();",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:2598,multi-thread,multi-threading,2598,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,2,['multi-thread'],['multi-threading']
Performance,"ct is read, that does not contain the list of files. This is much faster. ; Definition at line 1015 of file TDataSetManagerFile.cxx. ◆ GetDataSet() [2/2]. TFileCollection * TDataSetManagerFile::GetDataSet ; (; const char * ; uri, . const char * ; srv = 0 . ). overridevirtual . Utility function used in various methods for user dataset upload. ; Reimplemented from TDataSetManager.; Definition at line 1874 of file TDataSetManagerFile.cxx. ◆ GetDataSetPath() [1/2]. const char * TDataSetManagerFile::GetDataSetPath ; (; const char * ; group, . const char * ; user, . const char * ; dsName . ). protected . ◆ GetDataSetPath() [2/2]. const char * TDataSetManagerFile::GetDataSetPath ; (; const char * ; group, . const char * ; user, . const char * ; dsName, . TString & ; md5path, . Bool_t ; local = kFALSE . ). protected . Returns path of the indicated dataset. ; The extension is '.root' for all files except for 'dsName==ls' which have extension '.txt'. If 'local' is kTRUE the local cache path is returned instead in the form <cachedir>/<group>.<user>.<dsName>.<ext>. NB: contains a static TString for result, so copy result before using twice. ; Definition at line 351 of file TDataSetManagerFile.cxx. ◆ GetDataSets() [1/2]. TMap * TDataSetManagerFile::GetDataSets ; (; const char * ; group, . const char * ; user, . const char * ; dsName = 0, . UInt_t ; option = 0 . ). General purpose call to go through the existing datasets. ; If <user> is 0 or ""*"", act on all datasets for the given <group>. If <group> is 0 or ""*"", act on all datasets. If <dsName> is defined, only the information about the specified dataset is processed. Action depends on option; available options:; kExport Return a TMap object containing all the information about datasets in the form: { <group>, <map of users> } | { <map of datasets>, <dataset>} (<dataset> are TFileCollection objects) kShowDefault as kExport with in addition a default selection including the datasets from the current user, the ones from the group an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManagerFile.html:26652,cache,cache,26652,doc/master/classTDataSetManagerFile.html,https://root.cern,https://root.cern/doc/master/classTDataSetManagerFile.html,2,['cache'],"['cache', 'cachedir']"
Performance,"ct that represents the expected number of events for a given normalization set, similar to how createIntegral() returns an object that returns the integral. ;  ; double expectedEvents (const RooArgSet *nset) const override;  Return expected number of events for extended likelihood calculation, which is the sum of all coefficients. ;  ; ExtendMode extendMode () const override;  Returns ability of PDF to provide extended likelihood terms. ;  ; void fixCoefNormalization (const RooArgSet &refCoefNorm);  By default the interpretation of the fraction coefficients is performed in the contextual choice of observables. ;  ; void fixCoefRange (const char *rangeName);  By default, fraction coefficients are assumed to refer to the default fit range. ;  ; bool forceAnalyticalInt (const RooAbsArg &) const override;  Force RooRealIntegral to offer all observables for internal integration. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &numVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Determine which part (if any) of given integral can be performed analytically. ;  ; const RooArgSet & getCoefNormalization () const;  ; const char * getCoefRange () const;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  If all components that depend on obs are binned, so is their sum. ;  ; const RooArgList & pdfList () const;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const override;  Loop over components for plot sampling hints and merge them if there are multiple. ;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooAddPdf to more intuitively reflect the contents of the product operator construction. ;  ; void resetErrorCounters (Int_t resetValue=10) override;  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; bool selfNormalized () co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:5181,perform,performed,5181,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,2,['perform'],['performed']
Performance,"ct to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:18929,cache,cache,18929,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,1,['cache'],['cache']
Performance,"ct to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCache.html:20795,cache,cache,20795,root/html530/TTreeCache.html,https://root.cern,https://root.cern/root/html530/TTreeCache.html,1,['cache'],['cache']
Performance,"ct to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:21637,cache,cache,21637,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,1,['cache'],['cache']
Performance,"ct { Int_t fMyInt1; Int_t fMyInt2; Int_t fMyInt3; Char_t fMyCode[4]; };"" );. from ROOT import MyStruct; mystruct = MyStruct(); f = TFile('mytree.root','RECREATE'); tree = TTree('T','Just A Tree'); tree.Branch('myints',mystruct,'MyInt1/I:MyInt2:MyInt3'); tree.Branch('mycode',AddressOf(mystruct,'fMyCode'),'MyCode/C'); for i in range(0,10):; mystruct.fMyInt1 = i; mystruct.fMyInt2 = i*i; mystruct.fMyInt3 = i*i*i; mystruct.fMyCode = ""%03d"" % i # note string assignment. tree.Fill(). f.Write(); f.Close(); The C++ class is defined through the gROOT.ProcessLine() call, and note how the AddressOf() function is used for data members of built-in type. Most of the above is for ROOT version 5.02 and later only. For older releases, and without further support, here is an example as to how you can get hold of a pointer-to-pointer to a ROOT object:; h = TH1F(); addressofobject = array('i',[h.IsA().DynamicCast(h.IsA(),h)]); 19.1.10 Using Your Own Classes; A user’s own classes can be accessed after loading, either directly or indirectly, the library that contains the dictionary. One easy way of obtaining such a library, is by using ACLiC:; $ cat MyClass.C; class MyClass {; public:. MyClass(int value = 0) {; m_value = value;; }. void SetValue(int value) {; m_value = value;; }. int GetValue() {; return m_value;; }. private:; int m_value;; };. $ echo .L MyClass.C+ | root.exe -b; [...]; Info in <TUnixSystem::ACLiC>: creating shared library [..]/./MyClass_C.so; $; Then you can use it, for example, like so:; from ROOT import gSystem. # load library with MyClass dictionary; gSystem.Load('MyClass_C'). # get MyClass from ROOT; from ROOT import MyClass; # use MyClass; m = MyClass(42); print(m.GetValue()); You can also load a macro directly, but if you do not use ACLiC, you will be restricted to use the default constructor of your class, which is otherwise fully functional. For example:; from ROOT import gROOT. # load MyClass definition macro (append '+' to use ACLiC); gROOT.LoadMacro('MyClass.C'",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1072634,load,loading,1072634,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loading']
Performance,"ct() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLPolyLine.html:1860,cache,cached,1860,root/html534/TGLPolyLine.html,https://root.cern,https://root.cern/root/html534/TGLPolyLine.html,1,['cache'],['cached']
Performance,"ct(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); static voidSetOnError(TDCacheFile::OnErrorAction = kOnErrorDefault); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static voidSetOpenTimeout(UInt_t secs); vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TDCacheFile.html:11632,cache,cacheDir,11632,root/html526/TDCacheFile.html,https://root.cern,https://root.cern/root/html526/TDCacheFile.html,1,['cache'],['cacheDir']
Performance,"ct(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tTFile::ReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static voidSetOnError(TDCacheFile::OnErrorAction = kOnErrorDefault); static Bool_tTFile",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDCacheFile.html:11690,cache,cacheDir,11690,root/html528/TDCacheFile.html,https://root.cern,https://root.cern/root/html528/TDCacheFile.html,1,['cache'],['cacheDir']
Performance,"ct(const TObject *obj, UInt_t offset=1)=0; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::IsUsingRWLockR__ALWAYS_INLINE Bool_t IsUsingRWLock() constDefinition TCollection.h:212; TDirectory::TContextTDirectory::TContext keeps track and restore the current directory.Definition TDirectory.h:89; TDirectory::TContext::fDirectoryWaitstd::atomic< bool > fDirectoryWaitSet to true during the destructor execution.Definition TDirectory.h:93; TDirectory::TContext::RegisterCurrentDirectoryvoid RegisterCurrentDirectory()Definition TDirectory.cxx:1344; TDirectory::TContext::CdNullvoid CdNull()Set the current directory to null.Definition TDirectory.cxx:133; TDirectory::TContext::~TContext~TContext()Destructor.Definition TDirectory.cxx:143; TDirectory::TCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8cxx_source.html:57356,load,load,57356,doc/master/TDirectory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html,1,['load'],['load']
Performance,"ct* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TVirtualPerfStats&TVirtualPerfStats::operator=(const TVirtualPerfStats&); virtual voidPacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidRateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBytesRead(Long64_t num); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidSetMemValues(); virtual voidSetNumEvents(Long64_t num); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); static voidSetup",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPerfStats.html:4122,latency,latency,4122,root/html530/TPerfStats.html,https://root.cern,https://root.cern/root/html530/TPerfStats.html,3,['latency'],['latency']
Performance,"ct* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tCollect(TProof::ESlaves list = kActive, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tGetFileInCmd(const char* cmd, TString& fn); static Int_tGetInputData(TList* input, const char* cachedir, TString& emsg); TList*GetListOfActiveSlaves() const; TVirtualProofPlayer*GetPlayer() const; TPluginHandler*GetProgressDialog() const; Int_tGetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidHandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidInitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); voidPrepareInputDataFile(TString& dataFile); Int_tRemoveWorkers(TList* wrks); static Int_tSaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidSaveWorkerInfo(); Int_tSendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tSendInputData(TQueryResult* qr, TProof* p, TString& emsg); virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProof.html:18378,cache,cachedir,18378,root/html530/TProof.html,https://root.cern,https://root.cern/root/html530/TProof.html,2,['cache'],['cachedir']
Performance,"ct* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tCollect(TProof::ESlaves list = kActive, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tGetFileInCmd(const char* cmd, TString& fn); static Int_tGetInputData(TList* input, const char* cachedir, TString& emsg); TList*GetListOfActiveSlaves() const; TVirtualProofPlayer*GetPlayer() const; TPluginHandler*GetProgressDialog() const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidHandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidInitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); voidPrepareInputDataFile(TString& dataFile); Int_tRemoveWorkers(TList* wrks); static Int_tSaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidSaveWorkerInfo(); Int_tSendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tSendInputData(TQueryResult* qr, TProof* p, TString& emsg); virtual voidSendInputDataFile(); voidSetDSet(TDSet* dset); voidSetPlayer(TVirtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:18307,cache,cachedir,18307,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,1,['cache'],['cachedir']
Performance,"ct::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooMultiCategory&operator=(const RooMultiCategory&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiCategory.html:11483,optimiz,optimizeCacheMode,11483,root/html602/RooMultiCategory.html,https://root.cern,https://root.cern/root/html602/RooMultiCategory.html,2,['optimiz'],['optimizeCacheMode']
Performance,"ct::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooSuperCategory&operator=(const RooSuperCategory&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSuperCategory.html:12271,optimiz,optimizeCacheMode,12271,root/html602/RooSuperCategory.html,https://root.cern,https://root.cern/root/html602/RooSuperCategory.html,2,['optimiz'],['optimizeCacheMode']
Performance,"ct::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTWebFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3WebFile.html:14048,cache,cache,14048,root/html534/TS3WebFile.html,https://root.cern,https://root.cern/root/html534/TS3WebFile.html,3,['cache'],['cache']
Performance,"ct::ResetBit(UInt_t f); virtual voidTMemFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TParallelMergingFile.html:12613,cache,cache,12613,root/html534/TParallelMergingFile.html,https://root.cern,https://root.cern/root/html534/TParallelMergingFile.html,3,['cache'],['cache']
Performance,"ct::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidsetEps(Double_t e); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp); Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDerivative.html:23157,cache,cache,23157,root/html532/RooDerivative.html,https://root.cern,https://root.cern/root/html532/RooDerivative.html,1,['cache'],['cache']
Performance,"ct::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBoostedMethodName(TString methodName); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodBoost.html:12994,tune,tuneParameters,12994,root/html602/TMVA__MethodBoost.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodBoost.html,2,['tune'],['tuneParameters']
Performance,"ct::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBoostedMethodName(TString methodName); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodBoost.html:11828,tune,tuneParameters,11828,root/html534/TMVA__MethodBoost.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodBoost.html,1,['tune'],['tuneParameters']
Performance,"ct::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetHiddenLayer(TString hiddenlayer = """"); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::W",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodTMlpANN.html:12480,tune,tuneParameters,12480,root/html602/TMVA__MethodTMlpANN.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodTMlpANN.html,2,['tune'],['tuneParameters']
Performance,"ct::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetHiddenLayer(TString hiddenlayer = """"); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetSignalReferenceCutOrientation(Double_t cutOrientation); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodTMlpANN.html:11844,tune,tuneParameters,11844,root/html534/TMVA__MethodTMlpANN.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodTMlpANN.html,1,['tune'],['tuneParameters']
Performance,"ct::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGenCategory.html:15704,cache,cache,15704,root/html528/RooGenCategory.html,https://root.cern,https://root.cern/root/html528/RooGenCategory.html,8,['cache'],['cache']
Performance,"ct::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddModel.html:33034,cache,cache,33034,root/html602/RooAddModel.html,https://root.cern,https://root.cern/root/html602/RooAddModel.html,10,['cache'],['cache']
Performance,"ct::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*specialGeneratorConfig() const; RooNumGenConfig*specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_ttraceEvalHook(Double_t value) const; Bool_ttraceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intverboseEval(); static voidverboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:35176,cache,cache,35176,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,1,['cache'],['cache']
Performance,"ct::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. static THLimitsFinder*fgLimitsFinder!Pointer to hist limits finder. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THLimitsFinder(). ~THLimitsFinder(). Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax); compute the best axis limits for the X axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters; example:; With the input parameters xmin=-1.467 and xmax=2.344, the function; will compute better limits -1.8 and 2.7 and store them in the axis. Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax); compute the best axis limits for the X and Y axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters. Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); compute the best axis limits for the X, Y and Z axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters. THLimitsFinder * GetLimitsFinder(); Return pointer to the current finder.; Create one if none exists; Use SetLimitsFinder to set a user defined finder. void SetLimitsFinder(THLimitsFinder* finder); This static function can be used to specify a finder derived from THLimitsFinder.; The finder may redefine the functions FindGoodLimits.; Note that the redefined functions may call THLimitsFinder::FindGoodLimits. void Optimize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BWID, Option_t* option = """"); static function to compute reasonable axis limits. Input parameters:. A1,A2 : Original axis limits; Bin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THLimitsFinder.html:7288,optimiz,optimized,7288,root/html602/THLimitsFinder.html,https://root.cern,https://root.cern/root/html602/THLimitsFinder.html,2,['optimiz'],['optimized']
Performance,"ct::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TList*TVirtualMonitoringWriter::fTmpOpenPhasesTo store open phases when there is not yet an object. private:. TSQLServer*fDBSQL database where to write; Long64_tfMaxBulkSizeMax packet size for insertions; TStringfTableSQL table name; Bool_tfVerboseVerbosity toggle. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLMonitoringWriter(const char* serv, const char* user, const char* pass, const char* table); Constructor. ~TSQLMonitoringWriter(); Destructor. Bool_t SendParameters(TList* values, const char* ); Register query log using the information in the list which is in the form; TParameter(<par>,<value>) or TNamed(<name>,<string>). For bulk sending,; the first entry in the list is an TObjString defining the variable names; in the format; VARname1,VARname2,...; while the other entries are TObjStrings with the multiplets to be sent; VARvalue1,VARvalue2,... The string 'opt' allows the following additional control:; table=[<db>.]<table> allows to insert to a different table from the; one defined at construction (change is not; persistent); if <db> is not specified, the same; db defined at cinstruction is used.; bulk Do a bulk insert; More options can be given concurrently, comma-separated .; The specified table must already have been created in the DB. TSQLMonitoringWriter(const TSQLMonitoringWriter& ). TSQLMonitoringWriter& operator=(const TSQLMonitoringWriter& ). void Verbose(Bool_t onoff); { fVerbose = onoff; }. » Author: J.F. Grosse-Oetringhaus, G.Ganis » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TSQLMonitoringWriter.html:8303,concurren,concurrently,8303,root/html604/TSQLMonitoringWriter.html,https://root.cern,https://root.cern/root/html604/TSQLMonitoringWriter.html,1,['concurren'],['concurrently']
Performance,"ct::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }. » Author: Rene Brun 19/05/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-06-02 15:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TFileCacheWrite.html:7419,cache,cache,7419,root/html604/TFileCacheWrite.html,https://root.cern,https://root.cern/root/html604/TFileCacheWrite.html,2,['cache'],['cache']
Performance,"ct::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }. » Author: Rene Brun 19/05/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-06-30 14:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFileCacheWrite.html:7419,cache,cache,7419,root/html602/TFileCacheWrite.html,https://root.cern,https://root.cern/root/html602/TFileCacheWrite.html,2,['cache'],['cache']
Performance,"ctCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCFunction3Binding_double_unsigned_int_double_double_.html:33782,cache,cache,33782,root/html532/RooCFunction3Binding_double_unsigned_int_double_double_.html,https://root.cern,https://root.cern/root/html532/RooCFunction3Binding_double_unsigned_int_double_double_.html,1,['cache'],['cache']
Performance,"ctName(DepMod);; 4461 // We might deserialize.; 4462 cling::Interpreter::PushTransactionRAII RAII(&interp);; 4463 if (!interp.loadModule(DepMod.str(), /*complain*/false)) {; 4464 ROOT::TMetaUtils::Error(nullptr, ""Module '%s' failed to load.\n"",; 4465 DepMod.data());; 4466 }; 4467 }; 4468 }; 4469 ; 4470 if (!isGenreflex) { // rootcling; 4471 // ROOTCINT uses to define a few header implicitly, we need to do it explicitly.; 4472 if (interp.declare(""#include <assert.h>\n""; 4473 ""#include \""Rtypes.h\""\n""; 4474 ""#include \""TObject.h\"""") != cling::Interpreter::kSuccess; 4475 ) {; 4476 // There was an error.; 4477 ROOT::TMetaUtils::Error(nullptr, ""Error loading the default rootcling header files.\n"");; 4478 return 1;; 4479 }; 4480 }; 4481 ; 4482 if (interp.declare(""#include <string>\n"" // For the list of 'opaque' typedef to also include string.; 4483 ""#include <RtypesCore.h>\n"" // For initializing TNormalizedCtxt.; 4484 ""namespace std {} using namespace std;"") != cling::Interpreter::kSuccess) {; 4485 ROOT::TMetaUtils::Error(nullptr, ""Error loading the default header files.\n"");; 4486 return 1;; 4487 }; 4488 ; 4489 // We are now ready (enough is loaded) to init the list of opaque typedefs.; 4490 ROOT::TMetaUtils::TNormalizedCtxt normCtxt(interp.getLookupHelper());; 4491 ROOT::TMetaUtils::TClingLookupHelper helper(interp, normCtxt, nullptr, nullptr, nullptr);; 4492 TClassEdit::Init(&helper);; 4493 ; 4494 // flags used only for the pragma parser:; 4495 clingArgs.push_back(""-D__CINT__"");; 4496 clingArgs.push_back(""-D__MAKECINT__"");; 4497 ; 4498 AddPlatformDefines(clingArgs);; 4499 ; 4500 std::string currentDirectory = ROOT::FoundationUtils::GetCurrentDir();; 4501 ; 4502 std::string interpPragmaSource;; 4503 std::string includeForSource;; 4504 std::string interpreterDeclarations;; 4505 std::string linkdef;; 4506 ; 4507 for (size_t i = 0, e = gOptDictionaryHeaderFiles.size(); i < e; ++i) {; 4508 const std::string& optHeaderFileName = gOptDictionaryHeaderFiles[i];; 4509 bool isSel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:184148,load,loading,184148,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['load'],['loading']
Performance,"ctTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; bool allClientsCached (RooAbsArg *, const RooArgSet &);  Utility function that determines if all clients of object 'var' appear in given list of cached nodes. ;  ; virtual void attachCache (const RooAbsArg *newOwner, const RooArgSet &cachedVars);  Internal method – Attach dataset copied with cache contents to copied instances of functions. ;  ; virtual void cacheArgs (const RooAbsArg *owner, RooArgSet &varSet, const RooArgSet *nset=nullptr, bool skipZeroWeights=false);  Internal method – Cache given set of functions with data. ;  ; double corrcov (const RooRealVar &x, const RooRealVar &y, const char *cutSpec, const char *cutRange, bool corr) const;  Internal method to calculate single correlation and covariance elements. ;  ; RooFit::OwningPtr< TMatrixDSym > corrcovMatrix (const RooArgList &vars, const char *cutSpec, const char *cutRange, bool corr) const;  Return covariance matrix from data for given list of observables. ;  ; RooRealVar * dataRealVar (const char *methodname, const RooRealVar &extVar) const;  Internal method to check if given RooRealVar maps to a RooRealVar in this dataset. ;  ; void initializeVars (RooArgSet const &vars);  ; virtual void optimizeReadingWithCaching (RooAbsArg &arg, const RooArgSet &cacheList, const RooArgSet &keepObsList);  Prepare dataset for use with cached constant terms listed in 'cacheList' of expression 'arg'. ;  ; virtual RooPlot * plotAsymOn (RooPlot *frame, const RooAbsCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:28364,cache,cacheArgs,28364,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['cache'],['cacheArgs']
Performance,"cted . Allows to check if the ml method is a Cuts method. ; Returnsboolen true if the method is a Cuts method. ; Definition at line 957 of file Classification.cxx. ◆ MergeFiles(). void TMVA::Experimental::Classification::MergeFiles ; (; ). protected . Definition at line 1130 of file Classification.cxx. ◆ Streamer(). virtual void TMVA::Experimental::Classification::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TMVA::Envelope. ◆ StreamerNVirtual(). void TMVA::Experimental::Classification::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 202 of file Classification.h. ◆ Test(). void TMVA::Experimental::Classification::Test ; (; ). virtual . Perform test evaluation in all booked methods. ; Definition at line 513 of file Classification.cxx. ◆ TestMethod() [1/2]. void TMVA::Experimental::Classification::TestMethod ; (; TString ; methodname, . TString ; methodtitle . ). virtual . Lets perform test an specific ml method. ; Parameters. methodnamename of the method. ; methodtitlemethod title. . Definition at line 526 of file Classification.cxx. ◆ TestMethod() [2/2]. void TMVA::Experimental::Classification::TestMethod ; (; Types::EMVA ; method, . TString ; methodtitle . ). virtual . Lets perform test an specific ml method given the method type in enum TMVA::Types::EMVA. ; Parameters. methodTMVA::Types::EMVA type. ; methodtitlemethod title. . Definition at line 935 of file Classification.cxx. ◆ Train(). void TMVA::Experimental::Classification::Train ; (; ). virtual . Method to train all booked ml methods. ; Definition at line 324 of file Classification.cxx. ◆ TrainMethod() [1/2]. void TMVA::Experimental::Classification::TrainMethod ; (; TString ; methodname, . TString ; methodtitle . ). virtual . Lets train an specific ml method. ; Parameters. methodnamename of the method. ; methodtitlemethod title. . Definition at line 337 of file Classification.cxx. ◆ TrainMethod() [2/2]. void TMVA::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Experimental_1_1Classification.html:26602,perform,perform,26602,doc/master/classTMVA_1_1Experimental_1_1Classification.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Experimental_1_1Classification.html,1,['perform'],['perform']
Performance,"cted . Send a file to master or slave servers. ; Returns number of slaves the file was sent to, maybe 0 in case master and slaves have the same file system image, -1 in case of error. If defined, send to worker 'wrk' only. If defined, the full path of the remote path will be rfile. If rfile = ""cache"" the file is copied to the remote cache instead of the sandbox (to copy to the cache on a different name use rfile = ""cache:newname""). The mask 'opt' is an or of ESendFileOpt: kAscii (0x0) if set true ascii file transfer is used; kBinary (0x1) if set true binary file transfer is used; kForce (0x2) if not set an attempt is done to find out; whether the file really needs to be downloaded; (a valid copy may already exist in the cache; from a previous run); the bit is set by; UploadPackage, since the check is done elsewhere.; kForward (0x4) if set, ask server to forward the file to slave; or submaster (meaningless for slave servers).; kCpBin (0x8) Retrieve from the cache the binaries associated; with the file; kCp (0x10) Retrieve the files from the cache. Definition at line 6894 of file TProof.cxx. ◆ SendGroupView(). Int_t TProof::SendGroupView ; (; ). private . Send to all active slaves servers the current slave group size and their unique id. ; Returns number of active slaves. Returns -1 in case of error. ; Definition at line 6460 of file TProof.cxx. ◆ SendingLogToWindow(). Bool_t TProof::SendingLogToWindow ; (; ); const. inline . Definition at line 1016 of file TProof.h. ◆ SendInitialState(). Int_t TProof::SendInitialState ; (; ). private . Transfer the initial (i.e. ; current) state of the master to all slave servers. Currently the initial state includes: log level. Returns the number of active slaves. Returns -1 in case of error. ; Definition at line 6774 of file TProof.cxx. ◆ SendInputData(). Int_t TProof::SendInputData ; (; TQueryResult * ; qr, . TProof * ; p, . TString & ; emsg . ). staticprotected . Send the input data file to the workers. ; Definition at line 12380",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:139071,cache,cache,139071,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,2,['cache'],['cache']
Performance,"cted Attributes inherited from TTimer; TTime fAbsTime;  ; TString fCommand;  ; Bool_t fIntSyscalls;  ; TObject * fObject;  ; Bool_t fSync;  ; TTime fTime;  ; UInt_t fTimeID;  ; Bool_t fTimeout;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . Inheritance diagram for TGuiBldDragManagerRepeatTimer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGuiBldDragManagerRepeatTimer(). TGuiBldDragManagerRepeatTimer::TGuiBldDragManagerRepeatTimer ; (; TGuiBldDragManager * ; m, . Long_t ; ms . ). inline . Definition at line 675 of file TGuiBldDragManager.cxx. Member Function Documentation. ◆ Notify(). Bool_t TGuiBldDragManagerRepeatTimer::Notify ; (; ). inlineoverridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Implements TSysEvtHandler.; Definition at line 677 of file TGuiBldDragManager.cxx. Member Data Documentation. ◆ fManager. TGuiBldDragManager* TGuiBldDragManagerRepeatTimer::fManager. private . Definition at line 672 of file TGuiBldDragManager.cxx. gui/guibuilder/src/TGuiBldDragManager.cxx. TGuiBldDragManagerRepeatTimer. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:39 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGuiBldDragManagerRepeatTimer.html:18031,load,load,18031,doc/master/classTGuiBldDragManagerRepeatTimer.html,https://root.cern,https://root.cern/doc/master/classTGuiBldDragManagerRepeatTimer.html,2,['load'],['load']
Performance,"cted Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TEveElement; static const char * ToString (Bool_t b);  Convert Bool_t to string - kTRUE or kFALSE. ;  . #include <TEveCalo.h>. Inheritance diagram for TEveCaloViz:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TEveCaloViz() [1/2]. TEveCaloViz::TEveCaloViz ; (; const TEveCaloViz & ; ). privatedelete . ◆ TEveCaloViz() [2/2]. TEveCaloViz::TEveCaloViz ; (; TEveCaloData * ; data = nullptr, . const char * ; n = ""TEveCaloViz"", . const char * ; t = """" . ). Definition at line 39 of file TEveCalo.cxx. ◆ ~TEveCaloViz(). TEveCaloViz::~TEveCaloViz ; (; ). override . Destructor. ; Definition at line 78 of file TEveCalo.cxx. Member Function Documentation. ◆ AssertCellIdCache(). Bool_t TEveCaloViz::AssertCellIdCache ; (; ); const. Assert cell id cache is ok. ; Returns true if the cache has been updated. ; Definition at line 293 of file TEveCalo.cxx. ◆ AssertPalette(). TEveRGBAPalette * TEveCaloViz::AssertPalette ; (; ). Make sure the TEveRGBAPalette pointer is not null. ; If it is not set, a new one is instantiated and the range is set to current min/max signal values. ; Definition at line 378 of file TEveCalo.cxx. ◆ AssignCaloVizParameters(). void TEveCaloViz::AssignCaloVizParameters ; (; TEveCaloViz * ; cv). protected . Assign parameters from given model. ; Definition at line 321 of file TEveCalo.cxx. ◆ BuildCellIdCache(). virtual void TEveCaloViz::BuildCellIdCache ; (; ). protectedpure virtual . Implemented in TEveCalo3D, TEveCalo2D, and TEveCaloLego. ◆ CellInEtaPhiRng(). Bool_t TEveCaloViz::CellInEtaPhiRng ; (; TEveCaloData::CellData_t & ; cellData); const. Returns true if given cell is in the ceta phi range. ; Definition at line 307 of file TEveCalo.cxx. ◆ CellSelectionChanged(). virtual void TEveCaloViz::CellSelectionChanged ; (; ). inlinevirtual . Reimpl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCaloViz.html:38631,cache,cache,38631,doc/master/classTEveCaloViz.html,https://root.cern,https://root.cern/doc/master/classTEveCaloViz.html,1,['cache'],['cache']
Performance,"cted:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; vector<double>_high; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; vector<double>_low; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Point",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__LinInterpVar.html:34082,cache,cache,34082,root/html602/RooStats__HistFactory__LinInterpVar.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__LinInterpVar.html,12,['cache'],"['cache', 'caches']"
Performance,"ction dataset to entries with "" << cutString << std::endl ;; 2035 }; 2036 projDataSelOwned = std::unique_ptr<RooAbsData>{const_cast<RooAbsData*>(o.projData)->reduce(*projDataNeededVars, cutString.IsNull() ? nullptr : cutString)};; 2037 projDataSel = projDataSelOwned.get();; 2038 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName(); 2039 << "") only the following components of the projection data will be used: "" << *projDataNeededVars << std::endl ;; 2040 }; 2041 ; 2042 // Request binning of unbinned projection dataset that consists exclusively of category observables; 2043 if (!o.binProjData && dynamic_cast<RooDataSet*>(projDataSel)!=nullptr) {; 2044 ; 2045 // Determine if dataset contains only categories; 2046 bool allCat(true) ;; 2047 for(RooAbsArg * arg2 : *projDataSel->get()) {; 2048 if (!dynamic_cast<RooCategory*>(arg2)) allCat = false ;; 2049 }; 2050 if (allCat) {; 2051 o.binProjData = true ;; 2052 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") unbinned projection dataset consist only of discrete variables,""; 2053 << "" performing projection with binned copy for optimization."" << std::endl ;; 2054 ; 2055 }; 2056 }; 2057 ; 2058 // Bin projection dataset if requested; 2059 if (o.binProjData) {; 2060 projDataSelOwned = std::make_unique<RooDataHist>(std::string(projDataSel->GetName()) + ""_binned"",""Binned projection data"",*projDataSel->get(),*projDataSel);; 2061 projDataSel = projDataSelOwned.get();; 2062 }; 2063 ; 2064 // Construct scaled data weighted average; 2065 ScaledDataWeightedAverage scaleBind{*projection, *projDataSel, o.scaleFactor, *plotVar};; 2066 ; 2067 // Set default range, if not specified; 2068 if (o.rangeLo==0 && o.rangeHi==0) {; 2069 o.rangeLo = frame->GetXaxis()->GetXmin() ;; 2070 o.rangeHi = frame->GetXaxis()->GetXmax() ;; 2071 }; 2072 ; 2073 // Construct name of curve for data weighed average; 2074 std::string curveName(projection->GetName()) ;; 2075 curveName.append(""_DataAvg["" + projDataSel->get()->contentsString() + ""]"");; 2076 /",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:90662,perform,performing,90662,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,2,"['optimiz', 'perform']","['optimization', 'performing']"
Performance,"ction members; data members; class charts. ROOT; » IO; » XML; » TXMLFile. class TXMLFile: public TFile, public TXMLSetup. The main motivation for the XML format is to facilitate the; communication with other non ROOT applications. Currently; writing and reading XML files is limited to ROOT applications.; It is our intention to develop a simple reader independent; of the ROOT libraries that could be used as an example for; real applications. One of possible approach with code generation; is implemented in TXMLPlayer class. The XML format should be used only for small data volumes,; typically histogram files, pictures, geometries, calibrations.; The XML file is built in memory before being dumped to disk. Like for normal ROOT files, XML files use the same I/O mechanism; exploiting the ROOT/CINT dictionary. Any class having a dictionary; can be saved in XML format. This first implementation does not support subdirectories; or Trees. The shared library libRXML.so may be loaded dynamically; via gSystem->Load(""libRXML""). This library is automatically; loaded by the plugin manager as soon as a XML file is created; via, eg; TFile::Open(""file.xml"",""recreate"");; TFile::Open returns a TXMLFile object. When a XML file is open in write mode,; one can use the normal TObject::Write to write an object in the file.; Alternatively one can use the new functions TDirectoryFile::WriteObject and; TDirectoryFile::WriteObjectAny to write a TObject* or any class not deriving; from TObject. example of a session saving a histogram to a XML file. TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2);; h->FillRandom(""gaus"");; h->Write();; delete f;. example of a session reading the histogram from the file. TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*)f->Get(""h"");; h->Draw();. A new option in the canvas ""File"" menu is available to save; a TCanvas as a XML file. One can also do; canvas->Print(""Example.xml"");. Configuring ROOT with the option ""xml"".",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLFile.html:1157,load,loaded,1157,root/html528/TXMLFile.html,https://root.cern,https://root.cern/root/html528/TXMLFile.html,6,['load'],['loaded']
Performance,"ction must only be called if the definition is (about); 4194 // to be unloaded.; 4195 ; 4196 ResetCaches();; 4197 ; 4198 // We got here because the definition Decl is about to be unloaded.; 4199 if (fState != TClass::kHasTClassInit) {; 4200 if (fStreamerInfo->GetEntries() != 0) {; 4201 fState = TClass::kEmulated;; 4202 } else {; 4203 fState = TClass::kForwardDeclared;; 4204 }; 4205 } else {; 4206 // if the ClassInfo was loaded for a class with a TClass Init and it; 4207 // gets unloaded, should we guess it can be reloaded?; 4208 fCanLoadClassInfo = kTRUE;; 4209 }; 4210}; 4211 ; 4212////////////////////////////////////////////////////////////////////////////////; 4213/// To clean out all caches.; 4214 ; 4215void TClass::ResetCaches(); 4216{; 4217 R__ASSERT(!TestBit(kLoading) && ""Resetting the caches does not make sense during loading!"" );; 4218 ; 4219 // Not owning lists, don't call Delete(), but unload; 4220 if (fData.load()); 4221 (*fData).Unload();; 4222 if (fUsingData.load()); 4223 (*fUsingData).Unload();; 4224 if (fEnums.load()); 4225 (*fEnums).Unload();; 4226 if (fMethod.load()); 4227 (*fMethod).Unload();; 4228 ; 4229 delete fAllPubData; fAllPubData = nullptr;; 4230 ; 4231 if (fBase.load()); 4232 (*fBase).Delete();; 4233 delete fBase.load(); fBase = nullptr;; 4234 ; 4235 if (fRealData); 4236 fRealData->Delete();; 4237 delete fRealData; fRealData=nullptr;; 4238}; 4239 ; 4240////////////////////////////////////////////////////////////////////////////////; 4241/// Resets the menu list to it's standard value.; 4242 ; 4243void TClass::ResetMenuList(); 4244{; 4245 if (fClassMenuList); 4246 fClassMenuList->Delete();; 4247 else; 4248 fClassMenuList = new TList();; 4249 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, this));; 4250}; 4251 ; 4252////////////////////////////////////////////////////////////////////////////////; 4253/// The ls function lists the contents of a class on stdout. Ls output; 4254/// is typically much less verbose then D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:159743,load,load,159743,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"ction must only be called if the definition is (about); 4261 // to be unloaded.; 4262 ; 4263 ResetCaches();; 4264 ; 4265 // We got here because the definition Decl is about to be unloaded.; 4266 if (fState != TClass::kHasTClassInit) {; 4267 if (fStreamerInfo->GetEntries() != 0) {; 4268 fState = TClass::kEmulated;; 4269 } else {; 4270 fState = TClass::kForwardDeclared;; 4271 }; 4272 } else {; 4273 // if the ClassInfo was loaded for a class with a TClass Init and it; 4274 // gets unloaded, should we guess it can be reloaded?; 4275 fCanLoadClassInfo = kTRUE;; 4276 }; 4277}; 4278 ; 4279////////////////////////////////////////////////////////////////////////////////; 4280/// To clean out all caches.; 4281 ; 4282void TClass::ResetCaches(); 4283{; 4284 R__ASSERT(!TestBit(kLoading) && ""Resetting the caches does not make sense during loading!"" );; 4285 ; 4286 // Not owning lists, don't call Delete(), but unload; 4287 if (fData.load()); 4288 (*fData).Unload();; 4289 if (fUsingData.load()); 4290 (*fUsingData).Unload();; 4291 if (fEnums.load()); 4292 (*fEnums).Unload();; 4293 if (fMethod.load()); 4294 (*fMethod).Unload();; 4295 ; 4296 delete fAllPubData; fAllPubData = nullptr;; 4297 ; 4298 if (fBase.load()); 4299 (*fBase).Delete();; 4300 delete fBase.load(); fBase = nullptr;; 4301 ; 4302 if (fRealData); 4303 fRealData->Delete();; 4304 delete fRealData; fRealData=nullptr;; 4305}; 4306 ; 4307////////////////////////////////////////////////////////////////////////////////; 4308/// Resets the menu list to it's standard value.; 4309 ; 4310void TClass::ResetMenuList(); 4311{; 4312 if (fClassMenuList); 4313 fClassMenuList->Delete();; 4314 else; 4315 fClassMenuList = new TList();; 4316 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, this));; 4317}; 4318 ; 4319////////////////////////////////////////////////////////////////////////////////; 4320/// The ls function lists the contents of a class on stdout. Ls output; 4321/// is typically much less verbose then D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:162494,load,load,162494,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"ction of TEntryList(s) for the TTree(s) that constitute this TChain. Such “sub-lists” can be extracted by calling the function; TEntryList::GetEntryList(const char *treename, const char *filename); and then be used to construct a new TEntryList for a new TChain, or processed independently as normal TEntryList(s) for TTree(s). This modularity makes TEntryList much better suited for PROOF processing than the TEventList.; 12.20.10.2 Using an Event List; A TEventList or a TEntryList can be used to limit the TTree to the events in the list. The methods SetEventList and SetEntryList tell the tree to use the list and hence limit all subsequent calls to Draw, Scan, Process, Query, Principal and CopyTree methods to the entries in the list. In general, it affects the GetEntryNumber method and all functions using it for looping over the tree entries. The GetEntry and GetEntries methods are not affected. Note, that in the SetEventList method, the TEventList argument is internally transformed into a TEntryList, and this operation, in case of a TChain, requires loading of all the tree headers. In this example, we create a list with all entries with more than 600 tracks and then set it so that the tree will use this list. To reset the TTree to use all events use SetEventList(0) or SetEntryList(0). Let’s look at an example. First, open the file and draw the fNtrack. root[] TFile *f = new TFile(""Event.root"");; root[] TTree *T = (TTree*)f->Get(""T"");; root[] T->Draw(""fNtrack"");. Now, put the entries with over 600 tracks into a TEntryList called myList. We get the list from the current directory and assign it to a variable list. root[] T->Draw("">>myList"",""fNtrack > 600"",""entrylist"");; root[] TEntryList *list=(TEntryList*)gDirectory->Get(""myList"");. Instruct the tree T to use the new list and draw it again. Note that this is exactly the same Draw command. The list limits the entries. root[] T->SetEntryList(list);; root[] T->Draw(""fNtrack"");; You should now see a canvas similar to this on",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:624589,load,loading,624589,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['load'],['loading']
Performance,"ction will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getValV(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; this call will automatically recreated the server process. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTracking = kTRUE); Intercept call to optimize constant term in test statistics; and forward it to object on server side. void setVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); Control verbose messaging related to inter process communication; on both client and server side. void applyNLLWeightSquared(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. void doApplyNLLW2(Bool_t flag). void enableOffsetting(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. TObject* clone(const char* newname) const; { return new RooRealMPFE(*this,newname); }. void followAsSlave(RooRealMPFE& master); { _updateMaster = &master ; }. » Last changed: Tue Jun 30 14:35:20 2015 » Last generated: 2015-06-30 14:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealMPFE.html:41275,optimiz,optimize,41275,root/html602/RooRealMPFE.html,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html,1,['optimiz'],['optimize']
Performance,"ction will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getValV(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; this call will automatically recreated the server process. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTracking = kTRUE); Intercept call to optimize constant term in test statistics; and forward it to object on server side. void setVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); Control verbose messaging related to inter process communication; on both client and server side. void applyNLLWeightSquared(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. void doApplyNLLW2(Bool_t flag). void enableOffsetting(Bool_t flag); Control verbose messaging related to inter process communication; on both client and server side. TObject* clone(const char* newname) const; { return new RooRealMPFE(*this,newname); }. void followAsSlave(RooRealMPFE& master); { _updateMaster = &master ; }. » Last changed: Tue Mar 10 17:18:47 2015 » Last generated: 2015-03-10 17:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealMPFE.html:39387,optimiz,optimize,39387,root/html534/RooRealMPFE.html,https://root.cern,https://root.cern/root/html534/RooRealMPFE.html,1,['optimiz'],['optimize']
Performance,"ction& func); set a function to minimize using gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). return SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int , double ); set the value of an existing variable. { return false; }. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of the existing parameters). bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. double Edm() const; return expected distance reached from the minimum. const double * X() const; return pointer to X values at the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. bool ProvidesError() const; minimizer provides error and error matrix. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. bool GetCovMatrix(double* ) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__Minimizer.html:5834,perform,perform,5834,root/html530/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__Minimizer.html,2,['perform'],['perform']
Performance,"ction& func); set a function to minimize using gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). return SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int , double ); set the value of an existing variable. { return false; }. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of the existing parameters). bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. double Edm() const; return expected distance reached from the minimum. const double * X() const; return pointer to X values at the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. bool ProvidesError() const; minimizer provides error and error matrix. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__Minimizer.html:5746,perform,perform,5746,root/html528/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__Minimizer.html,1,['perform'],['perform']
Performance,"ction->GetName() == std::string(l->GetName())); 632 {; 633 collection->ClearItems();; 634 ; 635 for (int i = 0; i <= l->GetLast(); ++i); 636 {; 637 std::string cname = collection->GetName();; 638 auto len = cname.size();; 639 char end = cname[len-1];; 640 if (end == 's') {; 641 cname = cname.substr(0, len-1);; 642 }; 643 TString pname(Form(""%s %2d"", cname.c_str(), i));; 644 collection->AddItem(l->At(i), pname.Data(), """");; 645 }; 646 }; 647 collection->ApplyFilter();; 648 }; 649 }; 650 ; 651 void LoadEvent(); 652 {; 653 m_inEventLoading = true;; 654 ; 655 for (auto &el: m_collections->RefChildren()); 656 {; 657 auto c = dynamic_cast<REveDataCollection *>(el);; 658 SetDataItemsFromEvent(c);; 659 }; 660 ; 661 for (auto proxy : m_builders); 662 {; 663 proxy->Build();; 664 }; 665 ; 666 fEvent->fCaloData->DataChanged();; 667 m_inEventLoading = false;; 668 }; 669 ; 670 void addCollection(REveDataCollection* collection, REveDataProxyBuilderBase* glBuilder, bool showInTable = false); 671 {; 672 m_collections->AddElement(collection);; 673 ; 674 // load data; 675 SetDataItemsFromEvent(collection);; 676 glBuilder->SetCollection(collection);; 677 glBuilder->SetHaveAWindow(true);; 678 for (auto scene : m_scenes); 679 {; 680 if (strncmp(scene->GetCName(), ""Tables"", 5) == 0) continue;; 681 ; 682 REveElement *product = glBuilder->CreateProduct(scene->GetTitle(), m_viewContext);; 683 ; 684 if (!strncmp(scene->GetCTitle(), ""Projected"", 8)); 685 {; 686 g_projMng->ImportElements(product, scene);; 687 }; 688 else; 689 {; 690 scene->AddElement(product);; 691 }; 692 }; 693 m_builders.push_back(glBuilder);; 694 glBuilder->Build();; 695 ; 696 // Tables; 697 auto tableBuilder = new REveTableProxyBuilder();; 698 tableBuilder->SetHaveAWindow(true);; 699 tableBuilder->SetCollection(collection);; 700 REveElement* tablep = tableBuilder->CreateProduct(""table-type"", m_viewContext);; 701 auto tableMng = m_viewContext->GetTableViewInfo();; 702 if (showInTable); 703 {; 704 tableMng->SetDisplayedCollect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/collection__proxies_8C_source.html:21967,load,load,21967,doc/master/collection__proxies_8C_source.html,https://root.cern,https://root.cern/doc/master/collection__proxies_8C_source.html,1,['load'],['load']
Performance,"ction. ;  . Public Attributes; std::unique_ptr< ROOT::TThreadExecutor > fMTExecImpl;  ; std::unique_ptr< ROOT::TSequentialExecutor > fSeqExecImpl;  . Private Types; template<typename F , typename... Args> ; using InvokeResult_t = ROOT::TypeTraits::InvokeResult_t< F, Args... >;  . #include <TMVA/Executor.h>; Member Typedef Documentation. ◆ InvokeResult_t. template<typename F , typename... Args> . using TMVA::Executor::InvokeResult_t = ROOT::TypeTraits::InvokeResult_t<F, Args...>. private . Definition at line 39 of file Executor.h. ◆ noReferenceCond. template<class F , class... T> . using TMVA::Executor::noReferenceCond = typename std::enable_if_t<""Function can't return a reference"" && !(std::is_reference<InvokeResult_t<F, T...> >::value)>. Definition at line 43 of file Executor.h. Constructor & Destructor Documentation. ◆ Executor() [1/2]. TMVA::Executor::Executor ; (; ). inline . Default constructor of TMVA Executor class if ROOT::EnableImplicitMT has not been called then by default a serial executor will be created A user can create a thread pool and enable multi-thread excution by calling. ; TMVA::Config::Instance()::%EnableMT(int nthreads);; TMVA::Config::Instancestatic Config & Instance()static function: returns TMVA instanceDefinition Config.cxx:98; int; For releasing the thread pool used by TMVA one can do it by calling TMVA::Config::Instance()::%DisableMT();. Definition at line 59 of file Executor.h. ◆ Executor() [2/2]. TMVA::Executor::Executor ; (; int ; nthreads). inlineexplicit . Constructor of TMVA Executor class Explicit specify the number of threads. ; In this case if nthreads is > 1 a multi-threaded executor will be created and TMVA will run in MT. If nthreads = 1 instead TMVA will run in sequential mode If nthreads = 0 TMVA will use the default thread pool size ; Definition at line 80 of file Executor.h. Member Function Documentation. ◆ Foreach() [1/3]. template<class Function , class INTEGER > . void TMVA::Executor::Foreach ; (; Function ; func, . RO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Executor.html:3351,multi-thread,multi-thread,3351,doc/master/classTMVA_1_1Executor.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Executor.html,1,['multi-thread'],['multi-thread']
Performance,"ction. It receives an accumulator (acc) and a column value (x). The variable acc is shared among the; // calls, so the function has to specify how the value has to be aggregated in the accumulator.; auto aggregator = [](double acc, double x) { return acc * x; };; ; // If multithread is enabled, the aggregator function will be called by more threads and will produce a vector of; // partial accumulators. The merger function performs the final aggregation of these partial results.; auto merger = [](std::vector<double> &accumulators) {; auto size = accumulators.size();; for (int i = 1; i < size; ++i) {; accumulators[0] *= accumulators[i];; }; };; ; // The accumulator is initialized at this value by every thread.; double initValue = 1.;; ; // Multiplies all elements of the column ""x""; auto result = d.Aggregate(aggregator, merger, columnName, initValue);; ; std::cout << *result << std::endl;; }; d#define d(i)Definition RSha256.hxx:102; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; xDouble_t x[n]Definition legend1.C:17; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ; 120; DateJuly 2018 ; AuthorsEnrico Guiraud, Danilo Piparo (CERN), Massimo Tumolo (Politecnico di Torino) ; Definition in file df023_aggregate.C. tutorialsdataframedf023_aggregate.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df023__aggregate_8C.html:2352,multi-thread,multi-threading,2352,doc/master/df023__aggregate_8C.html,https://root.cern,https://root.cern/doc/master/df023__aggregate_8C.html,1,['multi-thread'],['multi-threading']
Performance,"ction. RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedReal(const RooCachedReal& other, const char* name = 0); Copy constructor. ~RooCachedReal(); Destructor. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Interface function to create an internal cache object that represent; each cached function configuration. This interface allows to create and; return a class derived from RooAbsCachedReal::FuncCacheElem so that; a derived class fillCacheObject implementation can utilize extra functionality; defined in such a derived cache class. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the external input p.d.f that are not one of; the cache observables. If thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooCachedReal.html:40027,cache,cache,40027,root/html604/RooCachedReal.html,https://root.cern,https://root.cern/root/html604/RooCachedReal.html,2,['cache'],"['cache', 'cached']"
Performance,"ction. RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedReal(const RooCachedReal& other, const char* name = 0); Copy constructor. ~RooCachedReal(); Destructor. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Interface function to create an internal cache object that represent; each cached function configuration. This interface allows to create and; return a class derived from RooAbsCachedReal::FuncCacheElem so that; a derived class fillCacheObject implementation can utilize extra functionality; defined in such a derived cache class. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Update contents of cache histogram by resampling the input function. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the ex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedReal.html:38529,cache,cache,38529,root/html534/RooCachedReal.html,https://root.cern,https://root.cern/root/html534/RooCachedReal.html,4,['cache'],"['cache', 'cached']"
Performance,"ction4Binding<double,double,double,double,double> RooAbsReal binding to external C functions; RooCFunction4Binding<double,double,double,double,int> RooAbsReal binding to external C functions; RooCFunction4PdfBinding<double,double,double,double,bool> RooAbsReal binding to external C functions; RooCFunction4PdfBinding<double,double,double,double,double> RooAbsReal binding to external C functions; RooCFunction4PdfBinding<double,double,double,double,int> RooAbsReal binding to external C functions; RooCFunction4Ref<double,double,double,double,bool> Persistable reference to C function pointer; RooCFunction4Ref<double,double,double,double,double> Persistable reference to C function pointer; RooCFunction4Ref<double,double,double,double,int> Persistable reference to C function pointer; RooCacheManager<RooAbsCacheElement> Cache Manager class generic objects; RooCacheManager<vector<double> > Cache Manager class generic objects; RooCachedPdf P.d.f class that wraps another p.d.f and caches its output ; RooCachedReal P.d.f class that wraps another p.d.f and caches its output ; RooCatType Category state, (name,index) pair; RooCategory Discrete valued variable type; RooCategoryProxy Proxy for a RooAbsCategory object; RooCategorySharedProperties Shared properties of a RooCategory clone set; RooChangeTracker Meta object that tracks changes in set of other arguments; RooChebychev Chebychev polynomial PDF; RooChi2MCSModule MCStudy module to calculate chi2 between binned data and fit ; RooChi2Var Chi^2 function of p.d.f w.r.t a binned dataset; RooChiSquarePdf Chi Square distribution (eg. the PDF ); RooCintUtils ; RooClassFactory RooFit class code and instance factory ; RooCmdArg Generic named argument container; RooCmdConfig Configurable parse of RooCmdArg objects; RooComplex a non-persistent bare-bones complex class; RooCompositeDataStore Composite Data Storage class; RooConstVar Constant RooAbsReal value object; RooConstraintSum sum of -log of set of RooAbsPdf representing parameter c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:31945,cache,caches,31945,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,4,['cache'],['caches']
Performance,"ctions rather than histograms. ; The interpolation method, in short, works as follows. Given a p.d.f f1(x) with c.d.f F1(x) and p.d.f f2(x) with c.d.f F2(x); One finds takes a value 'y' of both c.d.fs and determines the corresponding x values x(1,2) at which F(1,2)(x)==y.; The value of the interpolated p.d.f fbar(x) is then calculated as fbar(alpha*x1+(1-alpha)*x2) = f1(x1)*f2(x2) / ( alpha*f2(x2) + (1-alpha)*f1(x1) ) ;. From a technical point of view class RooIntegralMorph is a p.d.f that takes two input p.d.fs f1(x,p) an f2(x,q) and an interpolation parameter to make a p.d.f fbar(x,p,q,alpha). The shapes f1 and f2 are always taken to be end the end-points of the parameter alpha, regardless of what the those numeric values are.; Since the value of fbar(x) cannot be easily calculated for a given value of x, class RooIntegralMorph is an implementation of RooAbsCachedPdf and calculates the shape of the interpolated p.d.f. fbar(x) for all values of x for a given value of alpha,p,q and caches these values in a histogram (as implemented by RooAbsCachedPdf). The binning granularity of the cache can be controlled by the binning named ""cache"" on the RooRealVar representing the observable x. The fbar sampling algorithm is based on a recursive division mechanism with a built-in precision cutoff: First an initial sampling in 64 equally spaced bins is made. Then the value of fbar is calculated in the center of each gap. If the calculated value deviates too much from the value obtained by linear interpolation from the edge bins, gap is recursively divided. This strategy makes it possible to define a very fine cache sampling (e.g. 1000 or 10000) bins without incurring a corresponding CPU penalty.; Note on numeric stability of the algorithm. Since the algorithm relies on a numeric inversion of cumulative distributions functions, some precision may be lost at the 'edges' of the same (i.e. at regions in x where the c.d.f. value is close to zero or one). The general sampling strategy ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooIntegralMorph.html:1545,cache,caches,1545,doc/master/classRooIntegralMorph.html,https://root.cern,https://root.cern/doc/master/classRooIntegralMorph.html,1,['cache'],['caches']
Performance,"ctions(set<std::pair<RooAbsArg*,RooAbsArg*> >&); voidgroupProductTerms(RooLinkedList& groupedTerms, RooArgSet& outerIntDeps, const RooLinkedList& terms, const RooLinkedList& norms, const RooLinkedList& imps, const RooLinkedList& ints, const RooLinkedList& cross) const; static Bool_tRooAbsArg::inhibitDirty(); voidinitializeFromCmdArgList(const RooArgSet& fullPdfSet, const RooLinkedList& l); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; const char*makeRGPPName(const char* pfx, const RooArgSet& term, const RooArgSet& iset, const RooArgSet& nset, const char* isetRangeName) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProdPdf.html:34906,optimiz,optimizeDirtyHook,34906,root/html526/RooProdPdf.html,https://root.cern,https://root.cern/root/html526/RooProdPdf.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"ctions; and filled with repetitions of the lowest bin value and highest bin value; respectively. The buffer bins are stripped again when the FFT output values; are transferred to the p.d.f cache. The default buffer size is 10% of the; observable domain size and can be changed with setBufferFraction() member function. This class is a caching p.d.f inheriting from RooAbsCachedPdf. If this p.d.f; is evaluated for a particular value of x, the FFT calculate the values for the; p.d.f at all points in observables space for the given choice of parameters,; which are stored in the cache. Subsequent evaluations of RooFFTConvPdf with; identical parameters will retrieve results from the cache. If one or more; of the parameters change, the cache will be updated. The sampling density of the cache is controlled by the binning of the; the convolution observable, which can be changed from RooRealVar::setBins(N); For good results N should be large (>1000). Additional interpolation of; cache values may improve the result if courser binning are chosen. These can be; set in the constructor or through the setInterpolationOrder() member function.; For N>1000 interpolation will not substantially improve the performance. Additionial information on caching activities can be displayed by monitoring; the message stream with topic ""Caching"" at the INFO level, i.e.; do RooMsgService::instance().addStream(RooMsgService::INFO,Topic(""Caching"")); to see these message on stdout. Multi-dimensional convolutions are not supported yet, but will be in the future; as FFTW can calculate them. Installing a copy of FFTW on Linux and compiling ROOT to use it. 1) Go to www.fftw.org and download the latest stable version (a .tar.gz file). If you have root access to your machine and want to make a system installation of FFTW. 2) Untar fftw-XXX.tar.gz in /tmp, cd into the untarred directory; and type './configure' followed by 'make install'.; This will install fftw in /usr/local/bin,lib etc... 3) Start from a sour",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:2585,cache,cache,2585,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,7,['cache'],['cache']
Performance,"ctionsValid(TBuffer3D::kBoundingBox);; }; 9.13.4.7 Logical and Physical Objects; Some viewers can support two types of object placement:. Add object as a single independent entity in the world reference frame - e.g. a sphere, radius r, at x, y, z.; Repeated placement (copying) in world frame of this locally unique piece of geometry (described in local reference frame) e.g. define a sphere S (radius r), place copy at x1, y1, z1, another copy at x2, y2, z2 etc. The second case is very typical in geometry packages, e.g. ROOT’s TGeo package, GEANT4 etc, where we have very large number repeated placements of relatively few unique “shapes”.; Some viewers (GL Viewer only at present) are able to take advantage of this by identifying unique logical shapes from the fID logical ID member of TBuffer3D. If repeated addition of the same fID is found, the shape is cached already - and the costly tessellation does not need to be sent again. The viewer can also perform internal GL specific caching (display lists) with considerable performance gains in these cases. For this to work correctly the logical object in must be described in TBuffer3D in the local reference frame, complete with the local/master translation. In some cases you will not have a real object you can reasonably set TBuffer3D::fID to, or the object is recycled or temporary. To suppress internal caching in the GL Viewer in these cases, set TBuffer3D::fID to 0 (null).; The viewer indicates it can support local frame objects through the TVirtualViewer3D interface method: PreferLocalFrame(). If this returns kTRUE you can make repeated calls to AddObject(), with TBuffer3D containing the same fID, and different fLocalMaster placements.; For viewers supporting logical/physical objects, the TBuffer3D content refers to the properties of the logical object, with the exception of:. fLocalMaster transform; fColor; fTransparency. attributes, which can be varied for each physical object.; As a minimum requirement all clients must ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:414122,perform,perform,414122,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['perform'],"['perform', 'performance']"
Performance,"ctives given to SetMakeSharedLib() and SetMakeExe(), e.g.:; 4182/// ~~~ {.cpp}; 4183/// gSystem->SetInclude(""-I$ROOTSYS/include -Imydirectory/include"");; 4184/// ~~~; 4185/// the default value of IncludePath on Unix is:; 4186/// ~~~ {.cpp}; 4187/// ""-I$ROOTSYS/include ""; 4188/// ~~~; 4189/// and on Windows:; 4190/// ~~~ {.cpp}; 4191/// ""/I%ROOTSYS%/include ""; 4192/// ~~~; 4193 ; 4194void TSystem::SetIncludePath(const char *includePath); 4195{; 4196 fIncludePath = includePath;; 4197}; 4198 ; 4199////////////////////////////////////////////////////////////////////////////////; 4200/// LinkedLibs should contain the library directory and list of libraries; 4201/// needed to recreate the current executable. It is used to expand $LinkedLibs; 4202/// in the directives given to SetMakeSharedLib() and SetMakeExe(); 4203/// The default value on Unix is: `root-config --glibs`; 4204 ; 4205void TSystem::SetLinkedLibs(const char *linkedLibs); 4206{; 4207 fLinkedLibs = linkedLibs;; 4208}; 4209 ; 4210////////////////////////////////////////////////////////////////////////////////; 4211/// The 'suffix' will be appended to the name of a script loaded by ACLiC; 4212/// and used to locate any eventual additional linkdef information that; 4213/// ACLiC should used to produce the dictionary.; 4214///; 4215/// So by default, when doing .L MyScript.cxx, ACLiC will look; 4216/// for a file name MyScript_linkdef and having one of the .h (.hpp,; 4217/// etc.) extensions. If such a file exist, it will be added to; 4218/// the end of the linkdef file used to created the ACLiC dictionary.; 4219/// This effectively enable the full customization of the creation; 4220/// of the dictionary. It should be noted that the file is intended; 4221/// as a linkdef `fragment`, so usually you would not list the; 4222/// typical:; 4223/// ~~~ {.cpp}; 4224/// #pragma link off ....; 4225/// ~~~; 4226 ; 4227void TSystem::SetLinkdefSuffix(const char *suffix); 4228{; 4229 fLinkdefSuffix = suffix;; 4230}; 4231 ; 4232",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:144637,load,loaded,144637,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['loaded']
Performance,"ctly to test client code without running C++ server ; Definition at line 1355 of file RWebWindow.cxx. ◆ RemoveConnection(). std::shared_ptr< RWebWindow::WebConn > RWebWindow::RemoveConnection ; (; unsigned ; wsid). private . Remove connection with given websocket id. ; Definition at line 279 of file RWebWindow.cxx. ◆ RemoveEmbedWindow(). void RWebWindow::RemoveEmbedWindow ; (; unsigned ; connid, . int ; channel . ). private . Remove RWebWindow associated with the channelfEmbed. ; Definition at line 1867 of file RWebWindow.cxx. ◆ RemoveKey(). void RWebWindow::RemoveKey ; (; const std::string & ; key). private . Removes all connections with the key. ; Definition at line 583 of file RWebWindow.cxx. ◆ RemoveMasterConnection(). void RWebWindow::RemoveMasterConnection ; (; unsigned ; connid = 0). private . Remove master connection - if any. ; Definition at line 343 of file RWebWindow.cxx. ◆ Run(). void RWebWindow::Run ; (; double ; tm = 0.). Run window functionality for specified time If no action can be performed - just sleep specified time. ; Definition at line 1827 of file RWebWindow.cxx. ◆ Send(). void RWebWindow::Send ; (; unsigned ; connid, . const std::string & ; data . ). Sends data to specified connection. ; Parameters. connidconnection id, when 0 - data will be send to all connections ; datadata to be copied to SubmitData function . Definition at line 1609 of file RWebWindow.cxx. ◆ SendBinary() [1/2]. void RWebWindow::SendBinary ; (; unsigned ; connid, . const void * ; data, . std::size_t ; len . ). Send binary data to specified connection. ; Parameters. connidconnection id, when 0 - data will be send to all connections ; datapointer to binary data ; lennumber of bytes in data . Definition at line 1630 of file RWebWindow.cxx. ◆ SendBinary() [2/2]. void RWebWindow::SendBinary ; (; unsigned ; connid, . std::string && ; data . ). Send binary data to specified connection. ; Parameters. connidconnection id, when 0 - data will be send to all connections ; datadata to b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:41070,perform,performed,41070,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['perform'],['performed']
Performance,"ctly to test client code without running C++ server ; Definition at line 1397 of file RWebWindow.cxx. ◆ RemoveConnection(). std::shared_ptr< RWebWindow::WebConn > RWebWindow::RemoveConnection ; (; unsigned ; wsid). private . Remove connection with given websocket id. ; Definition at line 279 of file RWebWindow.cxx. ◆ RemoveEmbedWindow(). void RWebWindow::RemoveEmbedWindow ; (; unsigned ; connid, . int ; channel . ). private . Remove RWebWindow associated with the channelfEmbed. ; Definition at line 1909 of file RWebWindow.cxx. ◆ RemoveKey(). void RWebWindow::RemoveKey ; (; const std::string & ; key). private . Removes all connections with the key. ; Definition at line 584 of file RWebWindow.cxx. ◆ RemoveMasterConnection(). void RWebWindow::RemoveMasterConnection ; (; unsigned ; connid = 0). private . Remove master connection - if any. ; Definition at line 344 of file RWebWindow.cxx. ◆ Run(). void RWebWindow::Run ; (; double ; tm = 0.). Run window functionality for specified time If no action can be performed - just sleep specified time. ; Definition at line 1869 of file RWebWindow.cxx. ◆ Send(). void RWebWindow::Send ; (; unsigned ; connid, . const std::string & ; data . ). Sends data to specified connection. ; Parameters. connidconnection id, when 0 - data will be send to all connections ; datadata to be copied to SubmitData function . Definition at line 1651 of file RWebWindow.cxx. ◆ SendBinary() [1/2]. void RWebWindow::SendBinary ; (; unsigned ; connid, . const void * ; data, . std::size_t ; len . ). Send binary data to specified connection. ; Parameters. connidconnection id, when 0 - data will be send to all connections ; datapointer to binary data ; lennumber of bytes in data . Definition at line 1672 of file RWebWindow.cxx. ◆ SendBinary() [2/2]. void RWebWindow::SendBinary ; (; unsigned ; connid, . std::string && ; data . ). Send binary data to specified connection. ; Parameters. connidconnection id, when 0 - data will be send to all connections ; datadata to b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:39954,perform,performed,39954,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['perform'],['performed']
Performance,"ctly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Additions/modifications by Fabrizio Furano 10/04/2008; - The implementation of TFile throughput and info sending was; just sending 'regular' samples about the activity of the single TFile; instance that happened to trigger an activity in the right moment.; - Now TMonaLisaWriter keeps internally track of every activity; and regularly sends summaries valid for all the files which had; activity in the last time interval.; - Additionally, it's now finalized the infrastructure able to measure; and keep track of the file Open latency. A packet is sent for each; successful Open, sending the measures of the latencies for the; various phases of the open. Currently exploited fully by TAlienFile; and TXNetFile. Easy to report from other TFiles too.; - Now, the hook for the Close() func triggers sending of a packet; containing various information about the performance related to that; file only.; - Added support also for performance monitoring when writing. Function Members (Methods); public:. TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """"); virtual~TMonaLisaWriter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMonaLisaWriter.html:1939,perform,performance,1939,root/html530/TMonaLisaWriter.html,https://root.cern,https://root.cern/root/html530/TMonaLisaWriter.html,2,['perform'],['performance']
Performance,"ctor is; via TFile::Open(). ~TDCacheFile(); Close and cleanup dCache file. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t Stage(const char* path, UInt_t secs, const char* location = 0); Stage() returns kTRUE on success and kFALSE on failure. Bool_t CheckFile(const char* path, const char* location = 0); CheckFile() returns kTRUE on success and kFALSE on failure. In; case the file exists but is not cached, CheckFile() returns; kFALSE and errno is set to EAGAIN. void SetOpenTimeout(UInt_t secs); Set file open timeout. void SetOnError(TDCacheFile::OnErrorAction = kOnErrorDefault); Set on error handler. void SetReplyHostName(const char* host_name); Set reply host name. const char * GetDcapVersion(); Return dCache version string. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Interface to system open. All arguments like in POSIX open. Int_t SysClose(Int_t fd); Interface to system close. All arguments like in POSIX close. Int_t SysRead(Int_t fd, void* buf, Int_t len); Interface to system read. All arguments like in POSIX read. Int_t SysWrite(Int_t fd, const void* buf, Int_t len); Interface to system write. All arguments like in POSIX write. Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence); Interface to system seek. All arguments like in POSIX lseek. Int_t SysSync(Int_t fd); Interface to system sync. All arguments like in POSIX fsync.; dCache always keep it's files sync'ed,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TDCacheFile.html:23822,cache,cached,23822,root/html526/TDCacheFile.html,https://root.cern,https://root.cern/root/html526/TDCacheFile.html,1,['cache'],['cached']
Performance,"ctor. ; Definition at line 280 of file RooAbsData.cxx. Member Function Documentation. ◆ add(). virtual void RooAbsData::add ; (; const RooArgSet & ; row, . double ; weight = 1 . ). pure virtual . Implemented in RooDataSet, and RooDataHist. ◆ addOwnedComponent(). void RooAbsData::addOwnedComponent ; (; const char * ; idxlabel, . RooAbsData & ; data . ). Definition at line 2366 of file RooAbsData.cxx. ◆ allClientsCached(). bool RooAbsData::allClientsCached ; (; RooAbsArg * ; var, . const RooArgSet & ; cacheList . ). protected . Utility function that determines if all clients of object 'var' appear in given list of cached nodes. ; Definition at line 2319 of file RooAbsData.cxx. ◆ attachBuffers(). void RooAbsData::attachBuffers ; (; const RooArgSet & ; extObs). Definition at line 2337 of file RooAbsData.cxx. ◆ attachCache(). void RooAbsData::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). protectedvirtual . Internal method – Attach dataset copied with cache contents to copied instances of functions. ; Definition at line 363 of file RooAbsData.cxx. ◆ cacheArgs(). void RooAbsData::cacheArgs ; (; const RooAbsArg * ; owner, . RooArgSet & ; varSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = false . ). protectedvirtual . Internal method – Cache given set of functions with data. ; Definition at line 346 of file RooAbsData.cxx. ◆ canSplitFast(). bool RooAbsData::canSplitFast ; (; ); const. Definition at line 2351 of file RooAbsData.cxx. ◆ changeObservableName(). bool RooAbsData::changeObservableName ; (; const char * ; from, . const char * ; to . ). virtual . Definition at line 303 of file RooAbsData.cxx. ◆ checkInit(). void RooAbsData::checkInit ; (; ); const. Definition at line 2392 of file RooAbsData.cxx. ◆ Class(). static TClass * RooAbsData::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsData::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Ver",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:34574,cache,cache,34574,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['cache'],['cache']
Performance,"ctor. TGeoNavigator(const TGeoNavigator& ); Copy constructor. TGeoNavigator& operator=(const TGeoNavigator& ); assignment operator. ~TGeoNavigator(); Destructor. void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Builds the cache for physical nodes and global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdDown(TGeoNode* node); Make a daughter of current node current. Can be called only with a valid; daughter node (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdNext(); Do a cd to the node found next by FindNextBoundary. void GetBranchNames(Int_t* names) const; Fill volume names of current branch into an array. void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill node copy numbers of current branch into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundary(Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoNavigator.html:13928,cache,cache,13928,root/html602/TGeoNavigator.html,https://root.cern,https://root.cern/root/html602/TGeoNavigator.html,1,['cache'],['cache']
Performance,"ctor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:35460,cache,cache,35460,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,1,['cache'],['cache']
Performance,"ctor3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; 	 but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:28048,perform,perform,28048,root/html526/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,4,['perform'],['perform']
Performance,"ctor3D<CoordSystem, Tag>& SetTheta (Scalar ang) { fCoordinates.SetTheta(ang); return *this;}; 377 ; 378 /**; 379 Change Phi - Polar3D or CylindricalEta3D coordinates; 380 */; 381 DisplacementVector3D<CoordSystem, Tag>& SetPhi (Scalar ang) { fCoordinates.SetPhi(ang); return *this;}; 382 ; 383 /**; 384 Change Rho - CylindricalEta3D coordinates only; 385 */; 386 DisplacementVector3D<CoordSystem, Tag>& SetRho (Scalar rr) { fCoordinates.SetRho(rr); return *this;}; 387 ; 388 /**; 389 Change Eta - CylindricalEta3D coordinates only; 390 */; 391 DisplacementVector3D<CoordSystem, Tag>& SetEta (Scalar etaval) { fCoordinates.SetEta(etaval); return *this;}; 392 ; 393 ; 394 // ------ Operations combining two vectors ------; 395 // -- need to have the specialized version in order to avoid; 396 ; 397 /**; 398 Return the scalar (dot) product of two displacement vectors.; 399 It is possible to perform the product for any type of vector coordinates,; 400 but they must have the same coordinate system tag; 401 */; 402 template< class OtherCoords >; 403 Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v) const {; 404 return X()*v.X() + Y()*v.Y() + Z()*v.Z();; 405 }; 406 /**; 407 Return the scalar (dot) product of two vectors.; 408 It is possible to perform the product for any classes; 409 implementing x(), y() and z() member functions; 410 */; 411 template< class OtherVector >; 412 Scalar Dot( const OtherVector & v) const {; 413 return X()*v.x() + Y()*v.y() + Z()*v.z();; 414 }; 415 ; 416 /**; 417 Return vector (cross) product of two displacement vectors,; 418 as a vector in the coordinate system of this class.; 419 It is possible to perform the product for any type of vector coordinates,; 420 but they must have the same coordinate system tag; 421 */; 422 template <class OtherCoords>; 423 DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v) const {; 424 DisplacementVector3D result;; 425 result.SetXYZ ( Y()*v.Z() - v.Y()*Z(),; 426 Z()*v.X() - v.Z()*X(),; 42",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html:12661,perform,perform,12661,doc/master/GenVector_2DisplacementVector3D_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html,1,['perform'],['perform']
Performance,ctory : Test method: BDT for Classification performance; : ; BDT : [dataset] : Evaluation of BDT on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.0456 sec ; Factory : Test method: DNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : m_jj: 0.017919 1.0069 [ -3.3498 3.4247 ]; : m_jjj: 0.020352 1.0044 [ -3.2831 3.3699 ]; : m_lv: 0.016356 0.99266 [ -3.2339 3.3958 ]; : m_jlv: -0.018431 0.98242 [ -3.0632 5.7307 ]; : m_bb: 0.0069564 0.98851 [ -2.9734 3.3513 ]; : m_wbb: -0.010633 0.99340 [ -3.2442 3.2244 ]; : m_wwbb: -0.012669 0.99259 [ -3.1871 5.7307 ]; : -----------------------------------------------------------; DNN_CPU : [dataset] : Evaluation of DNN_CPU on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.101 sec ; Factory : Test method: PyKeras for Classification performance; : ; : Setting up tf.keras; : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: Higgs_trained_model.h5; PyKeras : [dataset] : Evaluation of PyKeras on testing sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.168 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: Likelihood; : ; Likelihood : [dataset] : Loop over test events and fill histograms with classifier response...; : ; TFHandler_Likelihood : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : m_jj: 1.0447 0.66216 [ 0.14661 10.222 ]; : m_jjj: 1.0275 0.37015 [ 0.34201 5.6016 ]; : m_lv: 1.0500 0.15582 [ 0.29757 2.8989 ]; : m_jlv: 1.0053 0.39478 [ 0.41660 5.8799 ]; : m_bb: 0.97464 0.52138 [ 0.10941 5.5163 ]; : m_wbb: 1.0296 0.35719 [ 0.38,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:51170,perform,performance,51170,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['perform'],['performance']
Performance,"ctory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TNetFile.html:13472,cache,cache,13472,root/html530/TNetFile.html,https://root.cern,https://root.cern/root/html530/TNetFile.html,2,['cache'],['cache']
Performance,"ctoryName/TreeName. TLeaf* GetLeaf(const char* name); Return pointer to the 1st Leaf named name in any Branch of this; Tree or any branch in the list of friend trees. aname may be of the form branchname/leafname. Double_t GetMaximum(const char* columname); Return maximum of column with name columname.; if the Tree has an associated TEventList or TEntryList, the maximum; is computed for the entries in this list. Long64_t GetMaxTreeSize(); Static function which returns the tree file size limit in bytes. Double_t GetMinimum(const char* columname); Return minimum of column with name columname.; if the Tree has an associated TEventList or TEntryList, the minimum; is computed for the entries in this list. TVirtualTreePlayer* GetPlayer(); Load the TTreePlayer (if not already done). TTreeCache * GetReadCache(TFile* file, Bool_t create = kFALSE); Find and return the TTreeCache registered with the file and which may; contain branches for us. If create is true and there is no cache:; Create a new cache according to the autocache setting and return it. TList* GetUserInfo(); Return a pointer to the list containing user objects associated to this tree. The list is automatically created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:103455,cache,cache,103455,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,4,['cache'],['cache']
Performance,"cts from the buffer using the StreamerInfoLoopAction. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t h). void WriteUShort(UShort_t h). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t ll). void WriteULong64(ULong64_t ll). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* c). void ReadBool(Bool_t& b). void ReadChar(Char_t& c). void ReadUChar(UChar_t& c). void ReadShort(Short_t& h). void ReadUShort(UShort_t& h). void ReadInt(Int_t& i). void ReadUInt(UInt_t& i). void ReadULong(ULong_t& ll). void ReadLong64(Long64_t& ll). void ReadULong64(ULong64_t& ll). void ReadFloat(Float_t& f). void ReadDouble(Double_t& d). void ReadCharP(Char_t* c). Int_t ReadArray(UChar_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBufferFile.html:46970,perform,performance,46970,root/html528/TBufferFile.html,https://root.cern,https://root.cern/root/html528/TBufferFile.html,4,['perform'],['performance']
Performance,"cts from the buffer using the StreamerInfoLoopAction. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t s). void WriteUShort(UShort_t s). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t l). void WriteULong64(ULong64_t l). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* c). void ReadBool(Bool_t& b). void ReadChar(Char_t& c). void ReadUChar(UChar_t& c). void ReadShort(Short_t& s). void ReadUShort(UShort_t& s). void ReadInt(Int_t& i). void ReadUInt(UInt_t& i). void ReadULong(ULong_t& l). void ReadLong64(Long64_t& l). void ReadULong64(ULong64_t& l). void ReadFloat(Float_t& f). void ReadDouble(Double_t& d). void ReadCharP(Char_t* c). Int_t ReadArray(UChar_t*& c)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBufferFile.html:49781,perform,performance,49781,root/html602/TBufferFile.html,https://root.cern,https://root.cern/root/html602/TBufferFile.html,2,['perform'],['performance']
Performance,"cts written to this file. ;  ; Int_t GetVersion () const;  ; virtual void IncrementProcessIDs ();  ; virtual Bool_t IsArchive () const;  ; Bool_t IsBinary () const;  ; Bool_t IsRaw () const;  ; void ls (Option_t *option="""") const override;  List file contents. ;  ; virtual Bool_t Matches (const char *name);  Return kTRUE if 'url' matches the coordinates of this file. ;  ; virtual Bool_t MustFlush () const;  ; virtual Bool_t ReadBufferAsync (Long64_t offs, Int_t len);  ; virtual Bool_t ReadBuffers (char *buf, Long64_t *pos, Int_t *len, Int_t nbuf);  Read the nbuf blocks described in arrays pos and len. ;  ; virtual TProcessID * ReadProcessID (UShort_t pidf);  The TProcessID with number pidf is read from this file. ;  ; virtual void ReadStreamerInfo ();  Read the list of StreamerInfo from this file. ;  ; virtual void SetCacheRead (TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect);  Set a pointer to the read cache. ;  ; virtual void SetCacheWrite (TFileCacheWrite *cache);  Set a pointer to the write cache. ;  ; virtual void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Used to specify the compression level and algorithm. ;  ; virtual void SetOffset (Long64_t offset, ERelativeTo pos=kBeg);  Set position from where to start reading. ;  ; virtual void SetOption (Option_t *option="">"");  ; virtual void SetReadCalls (Int_t readcalls=0);  ; virtual void ShowStreamerInfo ();  Show the StreamerInfo of all classes written to this file. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void SumBuffer (Int_t bufsize);  Increment statistics for buffer sizes of objects in this fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:9162,cache,cache,9162,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,4,['cache'],['cache']
Performance,"ctualParameters(const RooArgSet& nset) const; virtual voidRooAbsReal::attachToTree(TTree& t, Int_t bufSize = 32000); virtual const char*RooAbsCachedPdf::binningName() const; TStringRooAbsCachedPdf::cacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidRooAbsCachedPdf::clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); virtual RooAbsCachedPdf::PdfCacheElem*createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; voidRooAbsCachedPdf::disableCache(Bool_t flag); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tevaluate() const; virtual voidfillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; static Bool_tRooAbsArg::flipAClean(); virtual RooAbsGenContext*RooAbsPdf::genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; RooAbsCachedPdf::PdfCacheElem*RooAbsCachedPdf::getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnection",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooIntegralMorph.html:34882,cache,cache,34882,root/html526/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html526/RooIntegralMorph.html,3,['cache'],['cache']
Performance,"cular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:3777,cache,cache,3777,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cache']
Performance,"culated on the subset of the data which pass the C++ cut specification expression 'cutSpec' and/or are inside the range named 'cutRange' ; Definition at line 860 of file RooAbsData.cxx. ◆ namePtr(). const TNamed * RooAbsData::namePtr ; (; ); const. inline . De-duplicated pointer to this object's name. ; This can be used for fast name comparisons. like if (namePtr() == other.namePtr()). NoteTNamed::GetName() will return a pointer that's different for each object, but namePtr() always points to a unique instance. ; Definition at line 297 of file RooAbsData.h. ◆ numEntries(). Int_t RooAbsData::numEntries ; (; ); const. virtual . Return number of entries in dataset, i.e., count unweighted entries. ; Definition at line 323 of file RooAbsData.cxx. ◆ operator=(). RooAbsData & RooAbsData::operator= ; (; const RooAbsData & ; other). Definition at line 255 of file RooAbsData.cxx. ◆ optimizeReadingWithCaching(). void RooAbsData::optimizeReadingWithCaching ; (; RooAbsArg & ; arg, . const RooArgSet & ; cacheList, . const RooArgSet & ; keepObsList . ). protectedvirtual . Prepare dataset for use with cached constant terms listed in 'cacheList' of expression 'arg'. ; Deactivate tree branches for any dataset observable that is either not used at all, or is used exclusively by cached branch nodes. ; Definition at line 2262 of file RooAbsData.cxx. ◆ plotAsymOn(). RooPlot * RooAbsData::plotAsymOn ; (; RooPlot * ; frame, . const RooAbsCategoryLValue & ; asymCat, . PlotOpt ; o . ); const. protectedvirtual . Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ), where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1 as function of the frames variable. ; The asymmetry category 'asymCat' must have exactly 2 (or 3) states defined with index values +1,-1 (and 0); The plot range and the number of plot bins is determined by the parameters of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()); The optional cut string exp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:52720,cache,cacheList,52720,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['cache'],['cacheList']
Performance,"culated using Eq. (2) where the covariance matrix is taken from Minuit. Histograms of  are filled by weighting the events with . Error bars per bin are given by Eq. (6). The ; reproduce the true distributions of the species in the control variable , within the above defined statistical uncertainties. Illustrations. To illustrate the technique, one considers an example derived from the analysis where . have been first used (charmless B decays). One is dealing with a data; sample in which two species are present: the first is termed signal and; the second background. A maximum Likelihood fit is performed to obtain; the two yields and . The fit relies on two discriminating variables collectively denoted  which are chosen within three possible variables denoted , and .; The variable which is not incorporated in  is used as the control variable . The six distributions of the three variables are assumed to be the ones depicted in Fig. 1. Figure 1:; Distributions of the three discriminating variables available to perform the Likelihood fit:; , , .; Among the three variables, two are used to perform the fit while one is; kept out of the fit to serve the purpose of a control variable. The; three distributions on the top (resp. bottom) of the figure correspond; to the signal (resp. background). The unit of the vertical axis is; chosen such that it indicates the number of entries per bin, if one; slices the histograms in 25 bins. A data sample being built through a Monte Carlo simulation based on the distributions shown in Fig. 1, one obtains the three distributions of Fig. 2. Whereas the distribution of  clearly indicates the presence of the signal, the distribution of and are less obviously populated by signal. Figure 2:; Distributions of the three discriminating variables for signal plus; background. The three distributions are the ones obtained from a data; sample obtained through a Monte Carlo simulation based on the; distributions shown in Fig. 1. The data sample consists",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSPlot.html:5646,perform,perform,5646,root/html602/TSPlot.html,https://root.cern,https://root.cern/root/html602/TSPlot.html,2,['perform'],['perform']
Performance,"culating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useCdfBoundariesAre c.d.f boundary conditions used by the RooHistFuncs?; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to function being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedReal(const char* name, const char* title, RooAbsReal& _func); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedReal.html:38845,cache,cached,38845,root/html602/RooCachedReal.html,https://root.cern,https://root.cern/root/html602/RooCachedReal.html,2,['cache'],['cached']
Performance,"current checked surface; Int_t*fOverlapClusters! internal array for overlaps; Int_tfOverlapMark! current recursive position in fOverlapClusters; Int_tfOverlapSize! current size of fOverlapClusters; TStringfPath! path to current node; Double_tfPoint[3]! current point; Double_tfSafety! safety radius from current point; Bool_tfSearchOverlaps! flag set when an overlapping cluster is searched; Bool_tfStartSafe! flag a safe start for point classification; Double_tfStep! step to be done from current point and direction; Int_tfThreadId! thread id for this navigator; TGeoNode*fTopNode! top physical node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNavigator(); dummy constructor. TGeoNavigator(TGeoManager* geom); Default constructor. TGeoNavigator(const TGeoNavigator& ); Copy constructor. TGeoNavigator& operator=(const TGeoNavigator& ); assignment operator. ~TGeoNavigator(); Destructor. void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Builds the cache for physical nodes and global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdDown(TGeoNode* node); Make a daughter of current node current. Can be called only with a valid; daughter node (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Dete",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoNavigator.html:13169,cache,cache,13169,root/html602/TGeoNavigator.html,https://root.cern,https://root.cern/root/html602/TGeoNavigator.html,1,['cache'],['cache']
Performance,"current checked surface; Int_t*fOverlapClusters! internal array for overlaps; Int_tfOverlapMark! current recursive position in fOverlapClusters; Int_tfOverlapSize! current size of fOverlapClusters; TStringfPath! path to current node; Double_tfPoint[3]! current point; Double_tfSafety! safety radius from current point; Bool_tfSearchOverlaps! flag set when an overlapping cluster is searched; Bool_tfStartSafe! flag a safe start for point classification; Double_tfStep! step to be done from current point and direction; Int_tfThreadId! thread id for this navigator; TGeoNode*fTopNode! top physical node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNavigator(); dummy constructor. TGeoNavigator(TGeoManager* geom); Default constructor. TGeoNavigator(const TGeoNavigator& ); Copy constructor. TGeoNavigator& operator=(const TGeoNavigator& ); assignment operator. ~TGeoNavigator(); Destructor. void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Builds the cache for physical nodes and global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdNext(); Do a cd to the node found next by FindNextBoundary. void GetBranchNames(Int_t* names) const; Fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoNavigator.html:12589,cache,cache,12589,root/html532/TGeoNavigator.html,https://root.cern,https://root.cern/root/html532/TGeoNavigator.html,1,['cache'],['cache']
Performance,"current checked surface; Int_t*fOverlapClusters! internal array for overlaps; Int_tfOverlapMark! current recursive position in fOverlapClusters; Int_tfOverlapSize! current size of fOverlapClusters; TStringfPath! path to current node; Double_tfPoint[3]! current point; Double_tfSafety! safety radius from current point; Bool_tfSearchOverlaps! flag set when an overlapping cluster is searched; Bool_tfStartSafe! flag a safe start for point classification; Double_tfStep! step to be done from current point and direction; Int_tfThreadId! thread id for this navigator; TGeoNode*fTopNode! top physical node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNavigator(); dummy constructor. TGeoNavigator(TGeoManager* geom); Default constructor. TGeoNavigator(const TGeoNavigator& ); Copy constructor. TGeoNavigator& operator=(const TGeoNavigator& ); assignment operator. ~TGeoNavigator(); Destructor. void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Builds the cache for physical nodes and global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. The path is changed to point to the top node; in case of failure. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdDown(TGeoNode* node); Make a daughter of current node current. Can be called only with a valid; daughter node (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoNavigator.html:12709,cache,cache,12709,root/html534/TGeoNavigator.html,https://root.cern,https://root.cern/root/html534/TGeoNavigator.html,2,['cache'],['cache']
Performance,"current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source file which will be included in by the generated skeletong.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' class that are not split. 'unrolling' a class; will allow direct access to its data members a class (this; emulates the behavior of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:43947,load,loading,43947,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,1,['load'],['loading']
Performance,"current overlapping node (number of levels; up having the same tracking media. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void InspectState() const; Inspects path and all flags for the current state. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE); Checks if point (x,y,z) is still in the current node.; check if this is an overlapping node. Bool_t IsSafeStep(Double_t proposed, Double_t& newsafety) const; In case a previous safety value was computed, check if the safety region is; still safe for the current point and proposed step. Return value changed only; if proposed distance is safe. Bool_t IsSamePoint(Double_t x, Double_t y, Double_t z) const; Check if a new point with given coordinates is the same as the last located one. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. TGeoHMatrix * GetHMatrix(); Return stored current matrix (global matrix of the next touched node). const char * GetPath() const; Get path to the current node in the form /node0/node1/... void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. void ResetAll(); Reset the navigator. Int_t GetNmany() const; --- geometry queries. {return fNmany;}. const Double_t * GetLastPoint() const; {return fLastPoint;}. Double_t GetSafeDistance() const; {return fSafety;}. Double_t GetLastSafety() const; {return fLastSafety;}. Double_t GetStep() const; {return fStep;}. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE). Bool_t IsStartSafe() const; {return fStartSafe;}. void SetStartSafe(Bool_t flag = kTRUE); {fStartSafe=flag;}. void SetStep(Double_t step); {f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNavigator.html:18860,cache,cache,18860,root/html528/TGeoNavigator.html,https://root.cern,https://root.cern/root/html528/TGeoNavigator.html,2,['cache'],['cache']
Performance,"current overlapping node (number of levels; up having the same tracking media. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void InspectState() const; Inspects path and all flags for the current state. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE); Checks if point (x,y,z) is still in the current node.; check if this is an overlapping node. Bool_t IsSafeStep(Double_t proposed, Double_t& newsafety) const; In case a previous safety value was computed, check if the safety region is; still safe for the current point and proposed step. Return value changed only; if proposed distance is safe. Bool_t IsSamePoint(Double_t x, Double_t y, Double_t z) const; Check if a new point with given coordinates is the same as the last located one. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. TGeoHMatrix * GetHMatrix(); Return stored current matrix (global matrix of the next touched node). const char * GetPath() const; Get path to the current node in the form /node0/node1/... void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. void ResetAll(); Reset the navigator. Int_t GetNmany() const; --- geometry queries. {return fNmany;}. const Double_t * GetLastPoint() const; {return fLastPoint;}. Double_t GetSafeDistance() const; {return fSafety;}. Double_t GetLastSafety() const; {return fLastSafety;}. Double_t GetStep() const; {return fStep;}. Int_t GetThreadId() const; {return fThreadId;}. Bool_t IsSameLocation(Double_t x, Double_t y, Double_t z, Bool_t change = kFALSE). Bool_t IsStartSafe() const; {return fStartSafe;}. void SetStartSafe(Bool_t flag = kTRUE); {fS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoNavigator.html:19211,cache,cache,19211,root/html532/TGeoNavigator.html,https://root.cern,https://root.cern/root/html532/TGeoNavigator.html,4,['cache'],['cache']
Performance,"cursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* modestr); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo position = kBeg); virtual voidSetAsyncOpenStatus(TFile::EAsyncOpenStatus status); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetXNGFile.html:12037,cache,cacheDir,12037,root/html534/TNetXNGFile.html,https://root.cern,https://root.cern/root/html534/TNetXNGFile.html,3,['cache'],['cacheDir']
Performance,"cutRange = 0) const; { return moment(var,1,0,cutSpec,cutRange) ; }. Double_t sigma(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return sqrt(moment(var,2,cutSpec,cutRange)) ; }. Double_t skewness(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,3,cutSpec,cutRange) ; }. Double_t kurtosis(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,4,cutSpec,cutRange) ; }. Double_t covariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kFALSE) ; }. Double_t correlation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kTRUE) ; }. TMatrixDSym* covarianceMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return covarianceMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return correlationMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* covarianceMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kFALSE) ; }. TMatrixDSym* correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kTRUE) ; }. StorageType getDefaultStorageType(). RooAbsData* cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0). RooAbsData* reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE). » Last changed: Tue Jun 30 14:30:05 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsData.html:40612,cache,cacheClone,40612,root/html602/RooAbsData.html,https://root.cern,https://root.cern/root/html602/RooAbsData.html,1,['cache'],['cacheClone']
Performance,"cuted to extract the data from the basket. ;  ; Int_t fSTLtype;  ! STL container type ;  ; Int_t fStreamerType;  branch streamer type ;  ; TClassRef fTargetClass;  ! Reference to the target in-memory class ;  ; Int_t fType;  Branch type. ;  ; TVirtualCollectionIterators * fWriteIterators;  ! holds the read (non-staging) iterators when the branch is of fType==4 and associative containers. ;  ;  Protected Attributes inherited from TBranch; char * fAddress;  ! Address of 1st leaf (variable or object) ;  ; Int_t * fBasketBytes;  [fMaxBaskets] Length of baskets on file ;  ; Long64_t * fBasketEntry;  [fMaxBaskets] Table of first entry in each basket ;  ; TObjArray fBaskets;  -> List of baskets of this branch ;  ; Long64_t * fBasketSeek;  [fMaxBaskets] Addresses of baskets on file ;  ; Int_t fBasketSize;  Initial Size of Basket Buffer. ;  ; TObjArray fBranches;  -> List of Branches of this branch ;  ; TList * fBrowsables;  ! List of TVirtualBranchBrowsables used for Browse() ;  ; BulkObj fBulk;  ! Helper for performing bulk IO ;  ; CacheInfo_t fCacheInfo;  ! Hold info about which basket are in the cache and if they have been retrieved from the cache. ;  ; Int_t fCompress;  Compression level and algorithm. ;  ; TBasket * fCurrentBasket;  ! Pointer to the current basket. ;  ; TDirectory * fDirectory;  ! Pointer to directory where this branch buffers are stored ;  ; Long64_t fEntries;  Number of entries. ;  ; TBuffer * fEntryBuffer;  ! Buffer used to directly pass the content without streaming ;  ; Long64_t fEntryNumber;  Current entry number (last one filled in this branch) ;  ; Int_t fEntryOffsetLen;  Initial Length of fEntryOffset table in the basket buffers. ;  ; TBasket * fExtraBasket;  ! Allocated basket not currently holding any data. ;  ; TString fFileName;  Name of file where buffers are stored ("""" if in same file as Tree header) ;  ; FillLeaves_t fFillLeaves;  ! Pointer to the FillLeaves implementation to use. ;  ; Long64_t fFirstBasketEntry;  ! First entry in the cu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:36343,perform,performing,36343,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,3,"['cache', 'perform']","['cache', 'performing']"
Performance,"cxx. ◆ EyeDirection(). TGLVector3 TGLCamera::EyeDirection ; (; ); const. Extract the camera eye direction (vector), running from EyePoint() Camera must have valid frustum cache - call Apply() after last modification, before using. ; Definition at line 236 of file TGLCamera.cxx. ◆ EyePoint(). TGLVertex3 TGLCamera::EyePoint ; (; ); const. Return the camera eye point (vertex) in world space Camera must have valid frustum cache - call Apply() after last modification, before using. ; Definition at line 219 of file TGLCamera.cxx. ◆ Frustum(). TGLBoundingBox TGLCamera::Frustum ; (; Bool_t ; asBox = kTRUE); const. private . expansion c.f. aligned current frustum box ; Return the current camera frustum.; If asBox == kFALSE return a true frustum (truncated square based pyramid). If asBox == kTRUE return a true box, using the far clipping plane intersection projected back to the near plane.; Camera must have valid frustum cache - call Apply() after last modification, before using; Note: TGLBoundingBox is not really valid when filled with truncated pyramid; this is used as a visual debug aid only so ok. . Definition at line 171 of file TGLCamera.cxx. ◆ FrustumCenter(). TGLVertex3 TGLCamera::FrustumCenter ; (; ); const. Find the center of the camera frustum from intersection of planes This method will work even with parallel left/right & top/bottom and infinite eye point of ortho cameras Camera must have valid frustum cache - call Apply() after last modification, before using. ; Definition at line 251 of file TGLCamera.cxx. ◆ FrustumOverlap(). Rgl::EOverlap TGLCamera::FrustumOverlap ; (; const TGLBoundingBox & ; box); const. Calculate overlap (kInside, kOutside, kPartial) of box with camera frustum Camera must have valid frustum cache - call Apply() after last modification, before using. ; Definition at line 275 of file TGLCamera.cxx. ◆ FrustumPlane(). const TGLPlane & TGLCamera::FrustumPlane ; (; EFrustumPlane ; plane); const. inline . Definition at line 219 of file TGLCamera.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLCamera.html:24433,cache,cache,24433,doc/master/classTGLCamera.html,https://root.cern,https://root.cern/doc/master/classTGLCamera.html,1,['cache'],['cache']
Performance,"cxx. ◆ NDim(). unsigned int ROOT::Math::MinimTransformFunction::NDim ; (; ); const. inlineoverridevirtual . Retrieve the dimension of the function. ; Reimplemented from ROOT::Math::IGradientFunctionMultiDimTempl< T >.; Definition at line 66 of file MinimTransformFunction.h. ◆ NTot(). unsigned int ROOT::Math::MinimTransformFunction::NTot ; (; ); const. inline . Definition at line 68 of file MinimTransformFunction.h. ◆ operator=(). MinimTransformFunction & ROOT::Math::MinimTransformFunction::operator= ; (; const MinimTransformFunction & ; ). inlineprivate . Definition at line 132 of file MinimTransformFunction.h. ◆ OriginalFunction(). const IMultiGradFunction * ROOT::Math::MinimTransformFunction::OriginalFunction ; (; ); const. inline . Definition at line 101 of file MinimTransformFunction.h. ◆ Transformation() [1/2]. const double * ROOT::Math::MinimTransformFunction::Transformation ; (; const double * ; x); const. inline . transform from internal to external result is cached also inside the class ; Definition at line 78 of file MinimTransformFunction.h. ◆ Transformation() [2/2]. void ROOT::Math::MinimTransformFunction::Transformation ; (; const double * ; xint, . double * ; xext . ); const. transform from internal to external ; Definition at line 63 of file MinimTransformFunction.cxx. Member Data Documentation. ◆ fFunc. const IMultiGradFunction* ROOT::Math::MinimTransformFunction::fFunc. private . user function ; Definition at line 143 of file MinimTransformFunction.h. ◆ fIndex. std::vector<unsigned int> ROOT::Math::MinimTransformFunction::fIndex. private . vector with external indices for internal variables ; Definition at line 142 of file MinimTransformFunction.h. ◆ fVariables. std::vector<MinimTransformVariable> ROOT::Math::MinimTransformFunction::fVariables. private . vector of variable settings and transformation function ; Definition at line 141 of file MinimTransformFunction.h. ◆ fX. std::vector<double> ROOT::Math::MinimTransformFunction::fX. mutableprivate . i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1MinimTransformFunction.html:9513,cache,cached,9513,doc/master/classROOT_1_1Math_1_1MinimTransformFunction.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1MinimTransformFunction.html,1,['cache'],['cached']
Performance,"cxx. ◆ ProcessMiss(). bool TTreeCache::ProcessMiss ; (; Long64_t ; pos, . int ; len . ). private . ! Given a file read not in the miss cache, handle (possibly) loading the data. ; Process a cache miss; (pos, len) isn't in the buffer.; The first time we have a miss, we buffer as many baskets we can (up to the maximum size of the TTreeCache) in memory from all branches that are not in the prefetch list.; Subsequent times, we fetch all the buffers corresponding to branches that had previously seen misses. If it turns out the (pos, len) isn't in the list of branches, we treat this as if it was the first miss.; Returns true if we were able to pull the data into the miss cache. ; Definition at line 863 of file TTreeCache.cxx. ◆ ReadBuffer(). Int_t TTreeCache::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). overridevirtual . Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ; Otherwise try to fill the cache from the list of selected branches, and recheck if pos is now in the list. Returns:; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache. This function overloads TFileCacheRead::ReadBuffer. . Reimplemented from TFileCacheRead.; Definition at line 2027 of file TTreeCache.cxx. ◆ ReadBufferNormal(). Int_t TTreeCache::ReadBufferNormal ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Old method ReadBuffer before the addition of the prefetch mechanism. ; Definition at line 1927 of file TTreeCache.cxx. ◆ ReadBufferPrefetch(). Int_t TTreeCache::ReadBufferPrefetch ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Used to read a chunk from a block previously fetched. ; It will call FillBuffer even if the cache lookup succeeds, because it will try to prefetch the next block as soon as we start reading from the current block. ; Definition at line 1986 of file TTreeCache.cxx. ◆ ResetCache(). void TTreeCache::ResetCache ; (; ). virtual . This will simply clea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:46658,cache,cache,46658,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cache']
Performance,"cxx. ◆ importCacheObjects(). void RooExpensiveObjectCache::importCacheObjects ; (; RooExpensiveObjectCache & ; other, . const char * ; ownerName, . bool ; verbose = false . ). Definition at line 296 of file RooExpensiveObjectCache.cxx. ◆ instance(). RooExpensiveObjectCache & RooExpensiveObjectCache::instance ; (; ). static . Return reference to singleton instance. ; Definition at line 58 of file RooExpensiveObjectCache.cxx. ◆ IsA(). TClass * RooExpensiveObjectCache::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 81 of file RooExpensiveObjectCache.h. ◆ print(). void RooExpensiveObjectCache::print ; (; ); const. Definition at line 259 of file RooExpensiveObjectCache.cxx. ◆ registerObject(). bool RooExpensiveObjectCache::registerObject ; (; const char * ; ownerName, . const char * ; objectName, . TObject & ; cacheObject, . const RooArgSet & ; params . ). Register object associated with given name and given associated parameters with given values in cache. ; The cache will take ownership_of_object and is indexed under the given name (which does not need to be the name of cacheObject and with given set of dependent parameters with validity for the current values of those parameters. It can be retrieved later by callin retrieveObject() ; Definition at line 71 of file RooExpensiveObjectCache.cxx. ◆ retrieveObject(). const TObject * RooExpensiveObjectCache::retrieveObject ; (; const char * ; name, . TClass * ; tc, . const RooArgSet & ; params . ). Retrieve object from cache that was registered under given name with given parameters, if current parameter values match those that were stored in the registry for this object. ; The return object is owned by the cache instance. ; Definition at line 93 of file RooExpensiveObjectCache.cxx. ◆ setObj(). bool RooExpensiveObjectCache::setObj ; (; Int_t ; uid, . TObject * ; obj . ). Place new payload object in cache element with given unique ID. ; Cache",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExpensiveObjectCache.html:14777,cache,cache,14777,doc/master/classRooExpensiveObjectCache.html,https://root.cern,https://root.cern/doc/master/classRooExpensiveObjectCache.html,1,['cache'],['cache']
Performance,"cxx. ◆ ~RooFFTConvPdf(). RooFFTConvPdf::~RooFFTConvPdf ; (; ). override . Destructor. ; Definition at line 292 of file RooFFTConvPdf.cxx. Member Function Documentation. ◆ actualObservables(). RooFit::OwningPtr< RooArgSet > RooFFTConvPdf::actualObservables ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . Return the observables to be cached given the normalization set nset. ; If the cache observable is in nset then this is; the convolution observable plus; any member of nset that is either a RooCategory,; or was previously specified through setCacheObservables(). In case the cache observable is not in nset, then it is; the convolution observable plus; all member of nset that are observables of this p.d.f. . Implements RooAbsCachedPdf.; Definition at line 778 of file RooFFTConvPdf.cxx. ◆ actualParameters(). RooFit::OwningPtr< RooArgSet > RooFFTConvPdf::actualParameters ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . Return the parameters on which the cache depends given normalization set nset. ; For this p.d.f these are the parameters of the input p.d.f. but never the convolution variable, in case it is not part of nset. ; Implements RooAbsCachedPdf.; Definition at line 833 of file RooFFTConvPdf.cxx. ◆ bufferFraction(). double RooFFTConvPdf::bufferFraction ; (; ); const. inline . Return value of buffer fraction applied in FFT calculation array beyond either end of the observable domain to reduce cyclical effects. ; Definition at line 43 of file RooFFTConvPdf.h. ◆ bufferStrategy(). BufStrat RooFFTConvPdf::bufferStrategy ; (; ); const. inline . Return the strategy currently used to fill the buffer: 'Extend' means is that the input p.d.f convolution observable range is widened to include the buffer range 'Flat' means that the buffer is filled with the p.d.f. ; value at the boundary of the observable range 'Mirror' means that the buffer is filled with a mirror image of the p.d.f. around the convolution observable boundary ; Definition at l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:87688,cache,cache,87688,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cache']
Performance,cyRel(). Double_t TTreeCache::GetEfficiencyRel ; (; ); const. This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ; Definition at line 1849 of file TTreeCache.cxx. ◆ GetEntryMax(). virtual Int_t TTreeCache::GetEntryMax ; (; ); const. inlinevirtual . Definition at line 144 of file TTreeCache.h. ◆ GetEntryMin(). virtual Int_t TTreeCache::GetEntryMin ; (; ); const. inlinevirtual . Definition at line 143 of file TTreeCache.h. ◆ GetLearnEntries(). Int_t TTreeCache::GetLearnEntries ; (; ). static . Static function returning the number of entries used to train the cache see SetLearnEntries. ; Definition at line 1874 of file TTreeCache.cxx. ◆ GetLearnPrefill(). virtual EPrefillType TTreeCache::GetLearnPrefill ; (; ); const. inlinevirtual . Definition at line 146 of file TTreeCache.h. ◆ GetMissEfficiency(). Double_t TTreeCache::GetMissEfficiency ; (; ); const. The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ; Definition at line 1837 of file TTreeCache.cxx. ◆ GetMissEfficiencyRel(). Double_t TTreeCache::GetMissEfficiencyRel ; (; ); const. Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far. ; Definition at line 1861 of file TTreeCache.cxx. ◆ GetOptimizeMisses(). bool TTreeCache::GetOptimizeMisses ; (; ); const. inline . Definition at line 138 of file TTreeCache.h. ◆ GetTree(). TTree * TTreeCache::GetTree ; (; ); const. inline . Definition at line 149 of file TTreeCache.h. ◆ IsA(). TClass * TTreeCache::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 175 of file TTreeCache.h. ◆ IsAutoCreated(). bool TTreeCache::IsAutoCreated ; (; ); const. inline . Definition at line 150 of file TTreeCache.h. ◆ IsEnabled(). virtual bool TTreeCache::IsEnabled ; (; ),MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:41798,cache,cache,41798,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,4,['cache'],['cache']
Performance,"d *addr, bool);  ; void SetSkipZip (bool skip=true);  ; Int_t WriteBasket (TBasket *basket, Int_t where);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TRefTable * fRefTable;  pointer to the TRefTable ;  ;  Protected Attributes inherited from TBranch; char * fAddress;  ! Address of 1st leaf (variable or object) ;  ; Int_t * fBasketBytes;  [fMaxBaskets] Length of baskets on file ;  ; Long64_t * fBasketEntry;  [fMaxBaskets] Table of first entry in each basket ;  ; TObjArray fBaskets;  -> List of baskets of this branch ;  ; Long64_t * fBasketSeek;  [fMaxBaskets] Addresses of baskets on file ;  ; Int_t fBasketSize;  Initial Size of Basket Buffer. ;  ; TObjArray fBranches;  -> List of Branches of this branch ;  ; TList * fBrowsables;  ! List of TVirtualBranchBrowsables used for Browse() ;  ; BulkObj fBulk;  ! Helper for performing bulk IO ;  ; CacheInfo_t fCacheInfo;  ! Hold info about which basket are in the cache and if they have been retrieved from the cache. ;  ; Int_t fCompress;  Compression level and algorithm. ;  ; TBasket * fCurrentBasket;  ! Pointer to the current basket. ;  ; TDirectory * fDirectory;  ! Pointer to directory where this branch buffers are stored ;  ; Long64_t fEntries;  Number of entries. ;  ; TBuffer * fEntryBuffer;  ! Buffer used to directly pass the content without streaming ;  ; Long64_t fEntryNumber;  Current entry number (last one filled in this branch) ;  ; Int_t fEntryOffsetLen;  Initial Length of fEntryOffset table in the basket buffers. ;  ; TBasket * fExtraBasket;  ! Allocated basket not currently holding any data. ;  ; TString fFileName;  Name of file where buffers are stored ("""" if in same file as Tree header) ;  ; FillLeaves_t fFillLeaves;  ! Pointer to the FillLeaves implementation to use. ;  ; Long64_t fFirstBasketEntry;  ! First entry in the cu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchRef.html:23978,perform,performing,23978,doc/master/classTBranchRef.html,https://root.cern,https://root.cern/doc/master/classTBranchRef.html,3,"['cache', 'perform']","['cache', 'performing']"
Performance,"d *ary=nullptr) overrideAn array of emulated objects is created at address ary, if ary is null, we allocate memory for the ar...Definition TStreamerInfo.cxx:4918; TStreamerInfo::GetStreamerElementTStreamerElement * GetStreamerElement(const char *datamember, Int_t &offset) const overrideReturn the StreamerElement of ""datamember"" inside our class or any of its base classes.Definition TStreamerInfo.cxx:4212; TStreamerInfo::GetCheckSumUInt_t GetCheckSum() const overrideDefinition TStreamerInfo.h:159; TStreamerInfo::Compilevoid Compile() overrideloop on the TStreamerElement list regroup members with same type Store predigested information into l...Definition TStreamerInfoActions.cxx:2972; TStreamerInfo::WriteBufferClonesInt_t WriteBufferClones(TBuffer &b, TClonesArray *clones, Int_t nc, Int_t first, Int_t eoffset)Write for ClonesArray ('first' is an id between -1 and fNfulldata).Definition TStreamerInfoWriteBuffer.cxx:872; TStreamerInfo::BuildCheckvoid BuildCheck(TFile *file=nullptr, Bool_t load=kTRUE) overrideCheck if built and consistent with the class dictionary.Definition TStreamerInfo.cxx:729; TStreamerInfo::GetWriteObjectWiseActionsTStreamerInfoActions::TActionSequence * GetWriteObjectWiseActions()Definition TStreamerInfo.h:171; TStreamerInfo::CompareContentBool_t CompareContent(TClass *cl, TVirtualStreamerInfo *info, Bool_t warn, Bool_t complete, TFile *file) overrideReturn True if the current StreamerInfo in cl or info is equivalent to this TStreamerInfo.Definition TStreamerInfo.cxx:2854; TStreamerInfo::ReadBufferSkipInt_t ReadBufferSkip(TBuffer &b, const T &arrptr, const TCompInfo *compinfo, Int_t kase, TStreamerElement *aElement, Int_t narr, Int_t eoffset)Skip an element.Definition TStreamerInfoReadBuffer.cxx:182; TStreamerInfo::fWriteMemberWiseTStreamerInfoActions::TActionSequence * fWriteMemberWise! List of write action resulting from the compilation for use in member wise streaming.Definition TStreamerInfo.h:109; TStreamerInfo::fNslotsInt_t fNslots!total num",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8h_source.html:39950,load,load,39950,doc/master/TStreamerInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html,1,['load'],['load']
Performance,"d -1 in case of error. Int_t BuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0, Int_t chkveropt = kCheckROOT); Build specified package on the client. Executes the PROOF-INF/BUILD.sh; script if it exists on the client.; If opt == 0, both the preparation and building phases are run.; If opt == 1, only the preparation phase (asserting and, eventually, downloading; of the package) is done; '*path' contains the full path to the; package to be passed in the next call; If opt == 2, only the building phase is run using *path .; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kBuildPackage; case). Keep in sync in case of changes. Int_t LoadPackage(const char* package, Bool_t notOnClient = kFALSE, TList* loadopts = 0, TList* workers = 0); Load specified package. Executes the PROOF-INF/SETUP.C script; on all active nodes. If notOnClient = true, don't load package; on the client. The default is to load the package also on the client.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t LoadPackageOnClient(const char* package, TList* loadopts = 0); Load specified package in the client. Executes the PROOF-INF/SETUP.C; script on the client. Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kLoadPackage; case). Keep in sync in case of changes.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackage(const char* package); Unload specified package.; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackageOnClient(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:74686,load,load,74686,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,2,['load'],['load']
Performance,"d . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool Solve(Function &f, Derivative &d, double start, int maxIter, double absTol, double relTol). RootFinder(RootFinder::EType type = RootFinder::kBRENT). Construct a Root-Finder algorithm. virtual ~RootFinder(). RootFinder(const RootFinder & ); usually copying is non trivial, so we make this unaccessible. {}. bool SetMethod(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT). bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). Provide to the solver the function and the initial search interval [xlow, xup]; for algorithms not using derivatives (bracketing algorithms); The templated function f must be of a type implementing the \a operator() method,; <em> double operator() ( double x ) </em>; Returns non zero if interval is not valid (i.e. does not contains a root). return fSolver-> SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). int Iterations() const. Return the number of iteration performed to find the Root. int Iterate(). Perform a single iteration and return the Status. double Root() const. Return the current and latest estimate of the Root. int Status() const. Return the status of the last estimate of the Root; = 0 OK, not zero failure. const char * Name() const. Return the current and latest estimate of the lower value of the Root-finding interval (for bracketing algorithms). double XLower() const {; return fSolver->XLower();; }. Return the current and latest estimate of the upper value of the Root-finding interval (for bracketing algorithms). double XUpper() const {; return fSolver->XUpper();; }. Get Name of the Root-finding solver algorithm. » Last changed: root/mathmore:$Id: RootFinder.h 33942 2010-06-16 13:12:17Z moneta $ » Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__RootFinder.html:2912,perform,performed,2912,root/html528/ROOT__Math__RootFinder.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__RootFinder.html,1,['perform'],['performed']
Performance,"d . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool Solve(Function &f, Derivative &d, double start, int maxIter, double absTol, double relTol). RootFinder(RootFinder::EType type = RootFinder::kBRENT). Construct a Root-Finder algorithm. virtual ~RootFinder(). RootFinder(const RootFinder & ); usually copying is non trivial, so we make this unaccessible. {}. bool SetMethod(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT). bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). Provide to the solver the function and the initial search interval [xlow, xup]; for algorithms not using derivatives (bracketing algorithms); The templated function f must be of a type implementing the \a operator() method,; <em> double operator() ( double x ) </em>; Returns non zero if interval is not valid (i.e. does not contains a root). return fSolver-> SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). int Iterations() const. Return the number of iteration performed to find the Root. int Iterate(). Perform a single iteration and return the Status. double Root() const. Return the current and latest estimate of the Root. int Status() const. Return the status of the last estimate of the Root; = 0 OK, not zero failure. const char * Name() const. Return the current and latest estimate of the lower value of the Root-finding interval (for bracketing algorithms). double XLower() const {; return fSolver->XLower();; }. Return the current and latest estimate of the upper value of the Root-finding interval (for bracketing algorithms). double XUpper() const {; return fSolver->XUpper();; }. Get Name of the Root-finding solver algorithm. » Last changed: root/mathmore:$Id: RootFinder.h 33942 2010-06-16 13:12:17Z moneta $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__RootFinder.html:2914,perform,performed,2914,root/html530/ROOT__Math__RootFinder.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__RootFinder.html,1,['perform'],['performed']
Performance,"d . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool Solve(Function &f, Derivative &d, double start, int maxIter, double absTol, double relTol). RootFinder(RootFinder::EType type = RootFinder::kBRENT). Construct a Root-Finder algorithm. virtual ~RootFinder(). RootFinder(const RootFinder & ); usually copying is non trivial, so we make this unaccessible. {}. bool SetMethod(ROOT::Math::RootFinder::EType type = RootFinder::kBRENT). bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). Provide to the solver the function and the initial search interval [xlow, xup]; for algorithms not using derivatives (bracketing algorithms); The templated function f must be of a type implementing the \a operator() method,; <em> double operator() ( double x ) </em>; Returns non zero if interval is not valid (i.e. does not contains a root). return fSolver-> SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). int Iterations() const. Return the number of iteration performed to find the Root. int Iterate(). Perform a single iteration and return the Status. double Root() const. Return the current and latest estimate of the Root. int Status() const. Return the status of the last estimate of the Root; = 0 OK, not zero failure. const char * Name() const. Return the current and latest estimate of the lower value of the Root-finding interval (for bracketing algorithms). double XLower() const {; return fSolver->XLower();; }. Return the current and latest estimate of the upper value of the Root-finding interval (for bracketing algorithms). double XUpper() const {; return fSolver->XUpper();; }. Get Name of the Root-finding solver algorithm. » Last changed: root/mathmore:$Id: RootFinder.h 33942 2010-06-16 13:12:17Z moneta $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__RootFinder.html:2914,perform,performed,2914,root/html532/ROOT__Math__RootFinder.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__RootFinder.html,1,['perform'],['performed']
Performance,"d . Definition at line 215 of file RooGaussModel.cxx. ◆ generateEvent(). void RooGaussModel::generateEvent ; (; Int_t ; code). overridevirtual . Interface for generation of an event using the algorithm corresponding to the specified code. ; The meaning of each code is defined by the getGenerator() implementation. The default implementation does nothing. ; Reimplemented from RooAbsPdf.; Definition at line 541 of file RooGaussModel.cxx. ◆ getAnalyticalIntegral(). Int_t RooGaussModel::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 310 of file RooGaussModel.cxx. ◆ getGenerator(). Int_t RooGaussModel::getGenerator ; (; const RooArgSet & ; directVars, . RooArgSet & ; generateVars, . bool ; staticInitOK = true . ); const. overridevirtual . Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ; A code of zero indicates that we cannot generate any of the directVars (in this case, nothing should be added to generatedVars). Any non-zero codes will be passed to our generateEvent() implementation, but otherwise its value is arbitrary. The default implementation of this method returns zero. Subclasses will usually implement this method using the matchArgs() methods to advertise the algorithms they provide. ; Reimplemented from RooAbsPdf.; Definition at line 534 of file RooGaussModel.cxx. ◆ IsA(). TClass * RooGaussModel::IsA ; (; ); const. inli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGaussModel.html:81115,perform,performed,81115,doc/master/classRooGaussModel.html,https://root.cern,https://root.cern/doc/master/classRooGaussModel.html,1,['perform'],['performed']
Performance,"d . Definition at line 268 of file THttpWSHandler.cxx. ◆ SendCharStarWS(). Int_t THttpWSHandler::SendCharStarWS ; (; UInt_t ; wsid, . const char * ; str . ). Send string via given websocket id. ; Returns:. -1 - in case of error,; 0 - when operation was executed immediately,; 1 - when send operation will be performed in different thread, . Definition at line 476 of file THttpWSHandler.cxx. ◆ SendHeaderWS(). Int_t THttpWSHandler::SendHeaderWS ; (; UInt_t ; wsid, . const char * ; hdr, . const void * ; buf, . int ; len . ). Send binary data with text header via given websocket id. ; Returns:. -1 - in case of error,; 0 - when operation was executed immediately,; 1 - when send operation will be performed in different thread, . Definition at line 431 of file THttpWSHandler.cxx. ◆ SendWS(). Int_t THttpWSHandler::SendWS ; (; UInt_t ; wsid, . const void * ; buf, . int ; len . ). Send binary data via given websocket id. ; Returns:. -1 - in case of error; 0 - when operation was executed immediately; 1 - when send operation will be performed in different thread . Definition at line 386 of file THttpWSHandler.cxx. ◆ SetDisabled(). void THttpWSHandler::SetDisabled ; (; ). inline . Disable all processing of websockets, normally called shortly before destructor. ; Definition at line 94 of file THttpWSHandler.h. ◆ Streamer(). void THttpWSHandler::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void THttpWSHandler::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 114 of file THttpWSHandler.h. ◆ VerifyDefaultPageContent(). virtual void THttpWSHandler::VerifyDefaultPageContent ; (; std::shared_ptr< THttpCallArg > & ; arg). inlineprotectedvirtual . Method called when default page content is prepared for use By default no-cache header is provided. ; Reimplemented in ROOT::RWebWindowWSHandler.; Definition at line 60 of file THttpWSHandler.h. Friends And Relat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpWSHandler.html:24229,perform,performed,24229,doc/master/classTHttpWSHandler.html,https://root.cern,https://root.cern/doc/master/classTHttpWSHandler.html,1,['perform'],['performed']
Performance,"d = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IBaseFunctionMultiDimROOT::Math::IBaseFunctionMultiDim::IBaseFunctionMultiDim(); ROOT::Math::IBaseFunctionMultiDimROOT::Math::IBaseFunctionMultiDim::IBaseFunctionMultiDim(const ROOT::Math::IBaseFunctionMultiDim&); ROOT::Math::IGradientFunctionMultiDimIGradientFunctionMultiDim(); ROOT::Math::IGradientFunctionMultiDimIGradientFunctionMultiDim(const ROOT::Math::IGradientFunctionMultiDim&); ROOT::Math::IGradientMultiDimROOT::Math::IGradientMultiDim::IGradientMultiDim(); ROOT::Math::IGradientMultiDimROOT::Math::IGradientMultiDim::IGradientMultiDim(const ROOT::Math::IGradientMultiDim&); virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionMultiDim&operator=(const ROOT::Math::IGradientFunctionMultiDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionMultiDim(). Virtual Destructor (no operations). {}. » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IGradientFunctionMultiDim.html:2990,perform,performances,2990,root/html602/ROOT__Math__IGradientFunctionMultiDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IGradientFunctionMultiDim.html,1,['perform'],['performances']
Performance,"d = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IBaseFunctionMultiDimROOT::Math::IBaseFunctionMultiDim::IBaseFunctionMultiDim(); ROOT::Math::IBaseFunctionMultiDimROOT::Math::IBaseFunctionMultiDim::IBaseFunctionMultiDim(const ROOT::Math::IBaseFunctionMultiDim&); ROOT::Math::IGradientFunctionMultiDimIGradientFunctionMultiDim(); ROOT::Math::IGradientFunctionMultiDimIGradientFunctionMultiDim(const ROOT::Math::IGradientFunctionMultiDim&); ROOT::Math::IGradientMultiDimROOT::Math::IGradientMultiDim::IGradientMultiDim(); ROOT::Math::IGradientMultiDimROOT::Math::IGradientMultiDim::IGradientMultiDim(const ROOT::Math::IGradientMultiDim&); virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionMultiDim&operator=(const ROOT::Math::IGradientFunctionMultiDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionMultiDim(). Virtual Destructor (no operations). {}. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__IGradientFunctionMultiDim.html:2990,perform,performances,2990,root/html604/ROOT__Math__IGradientFunctionMultiDim.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__IGradientFunctionMultiDim.html,1,['perform'],['performances']
Performance,"d = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TArrayD; Double_t * fArray;  ;  Public Attributes inherited from TArray; Int_t fN;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TH3; static TH1D * DoProject1D (const TH3 &h, const char *name, const char *title, const TAxis *projX, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 1D histogram ;  ; static TH2D * DoProject2D (const TH3 &h, const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 2D histogram ;  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3D.html:57040,perform,performing,57040,doc/master/classTH3D.html,https://root.cern,https://root.cern/doc/master/classTH3D.html,4,['perform'],['performing']
Performance,"d = kTRUE, Bool_t silent = kFALSE) const; TSeqCollection*GetClipboard() const; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const; static const char**&GetExtraInterpreterArgs(); virtual TFile*GetFile() const; TFile*GetFile(const char* name) const; Bool_tGetForceStyle() const; TObject*GetFunction(const char* name) const; TFunctionTemplate*GetFunctionTemplate(const char* name); TObject*GetGeometry(const char* name) const; const char*GetGitBranch() const; const char*GetGitCommit() const; const char*GetGitDate(); TGlobal*GetGlobal(const char* name, Bool_t load = kFALSE) const; TGlobal*GetGlobal(const TObject* obj, Bool_t load = kFALSE) const; TFunction*GetGlobalFunction(const char* name, const char* params = 0, Bool_t load = kFALSE); TFunction*GetGlobalFunctionWithPrototype(const char* name, const char* proto = 0, Bool_t load = kFALSE); virtual const char*TObject::GetIconName() const; TInterpreter*GetInterpreter() const; virtual TKey*TDirectory::GetKey(const char*, Short_t = 9999) const; virtual TList*TDirectory::GetList() const; TList*GetListOfBrowsables() const; TSeqCollection*GetListOfBrowsers() const; TSeqCollection*GetListOfCanvases() const; TCollection*GetListOfClasses() const; TCollection*GetListOfClassGenerators() const; TSeqCollection*GetListOfCleanups() const; TSeqCollection*GetListOfClosedObjects() const; TSeqCollection*GetListOfColors() const; TSeqCollection*GetListOfDataSets() const; TCollection*GetListOfEnums(Bool_t load = kFALSE); TSeqCollection*GetListOfFiles() const; TCollection*GetListOfFunctionOverloads(const char* name)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:6138,load,load,6138,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,2,['load'],['load']
Performance,"d == nullptr); 511 return nullptr;; 512 ; 513 if (method->GetMethodType() == Types::kCategory) {; 514 Log() << kERROR << ""Cannot handle category methods for now."" << Endl;; 515 }; 516 ; 517 TString fileDir;; 518 if (fModelPersistence) {; 519 // find prefix in fWeightFileDir;; 520 TString prefix = gConfig().GetIONames().fWeightFileDirPrefix;; 521 fileDir = prefix;; 522 if (!prefix.IsNull()); 523 if (fileDir[fileDir.Length() - 1] != '/'); 524 fileDir += ""/"";; 525 fileDir = loader->GetName();; 526 fileDir += ""/"" + gConfig().GetIONames().fWeightFileDir;; 527 }; 528 ; 529 if (fModelPersistence); 530 method->SetWeightFileDir(fileDir);; 531 method->SetModelPersistence(fModelPersistence);; 532 method->SetAnalysisType(fAnalysisType);; 533 method->SetupMethod();; 534 method->SetFile(fgTargetFile);; 535 method->SetSilentFile(IsSilentFile());; 536 ; 537 method->DeclareCompatibilityOptions();; 538 ; 539 // read weight file; 540 method->ReadStateFromFile();; 541 ; 542 // method->CheckSetup();; 543 ; 544 TString methodTitle = method->GetName();; 545 if (HasMethod(datasetname, methodTitle) != 0) {; 546 Log() << kFATAL << ""Booking failed since method with title <"" << methodTitle << ""> already exists ""; 547 << ""in with DataSet Name <"" << loader->GetName() << ""> "" << Endl;; 548 }; 549 ; 550 Log() << kINFO << ""Booked classifier \"""" << method->GetMethodName() << ""\"" of type: \""""; 551 << method->GetMethodTypeName() << ""\"""" << Endl;; 552 ; 553 if (fMethodsMap.count(datasetname) == 0) {; 554 MVector *mvector = new MVector;; 555 fMethodsMap[datasetname] = mvector;; 556 }; 557 ; 558 fMethodsMap[datasetname]->push_back(method);; 559 ; 560 return method;; 561}; 562 ; 563////////////////////////////////////////////////////////////////////////////////; 564/// Returns pointer to MVA that corresponds to given method title.; 565 ; 566TMVA::IMethod *TMVA::Factory::GetMethod(const TString &datasetname, const TString &methodTitle) const; 567{; 568 if (fMethodsMap.find(datasetname) == fMethodsMap.end())",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:22358,load,loader,22358,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance,"d HandleLibIncPath(TMessage* mess); Handle lib, inc search paths modification request. void HandleCheckFile(TMessage* mess, TString* slb = 0); Handle file checking request. Int_t HandleCache(TMessage* mess, TString* slb = 0); Handle here all cache and package requests. void HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The PROOF error handler function. It prints the message on fgErrorHandlerFile and; if abort is set it aborts the application. Int_t CopyFromCache(const char* name, Bool_t cpbin); Retrieve any files related to 'macro' from the cache directory.; If 'cpbin' is true, the associated binaries are retrieved as well.; Returns 0 on success, -1 otherwise. Int_t CopyToCache(const char* name, Int_t opt = 0); Copy files related to 'macro' to the cache directory.; Action depends on 'opt':. opt = 0 copy 'macro' to cache and delete from cache any binary; related to name; e.g. if macro = bla.C, the binaries are; bla_C.so, bla_C.rootmap, ...; opt = 1 copy the binaries related to macro to the cache. Returns 0 on success, -1 otherwise. void MakePlayer(); Make player instance. void DeletePlayer(); Delete player instance. Int_t GetPriority(); Get the processing priority for the group the user belongs too. This; prioroty is a number (0 - 100) determined by a scheduler (third; party process) based on some basic priority the group has, e.g.; we might want to give users in a specific group (e.g. promptana); a higher priority than users in other groups, and on the analysis; of historical logging data (i.e. usage of CPU by the group in a; previous time slot, as recorded in TPerfStats::WriteQueryLog()). Currently the group priority is obtained by a query in a SQL DB; table proofpriority, which has the form",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:27065,cache,cache,27065,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,1,['cache'],['cache']
Performance,"d ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); Open a connection to another host. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service. int AnnounceUdpService(int port, int backlog); Announce UDP service. int AnnounceUnixService(int port, int backlog); Announce unix domain service. int AnnounceUnixService(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSystem.html:35290,load,loaded,35290,root/html534/TSystem.html,https://root.cern,https://root.cern/root/html534/TSystem.html,3,['load'],['loaded']
Performance,"d Member Functions inherited from RooAbsPdf;  RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr);  Copy constructor. ;  ; virtual std::unique_ptr< RooAbsReal > createNLLImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the NLL creation routine. ;  ; virtual std::unique_ptr< RooFitResult > fitToImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the likelihood fitting routine. ;  ; bool isActiveNormSet (RooArgSet const *normSet) const;  Checks if normSet is the currently active normalization set of this PDF, meaning is exactly the same object as the one the _normSet member points to (or both are nullptr). ;  ; double normalizeWithNaNPacking (double rawVal, double normVal) const;  ; Int_t * randomizeProtoOrder (Int_t nProto, Int_t nGen, bool resample=false) const;  Return lookup table with randomized order for nProto prototype events. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  The cache manager. ;  ; virtual bool syncNormalization (const RooArgSet *dset, bool adjustProxies=true) const;  Verify that the normalization integral cached with this PDF is valid for given set of normalization observables. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimultaneous.html:64931,cache,cache,64931,doc/master/classRooSimultaneous.html,https://root.cern,https://root.cern/doc/master/classRooSimultaneous.html,1,['cache'],['cache']
Performance,"d Roo2DKeysPdf::PrintInfo ; (; std::ostream & ; out); const. Prints out _p[_nPoints][_nPoints] indicating the domain limits. ; Parameters. [out]outOutput stream where to print . Definition at line 610 of file Roo2DKeysPdf.cxx. ◆ setOptions(). void Roo2DKeysPdf::setOptions ; (; TString ; options). Definition at line 226 of file Roo2DKeysPdf.cxx. ◆ setWidthScaleFactor(). void Roo2DKeysPdf::setWidthScaleFactor ; (; double ; widthScaleFactor). inline . Definition at line 124 of file Roo2DKeysPdf.h. ◆ Streamer(). void Roo2DKeysPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void Roo2DKeysPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 121 of file Roo2DKeysPdf.h. ◆ writeHistToFile(). void Roo2DKeysPdf::writeHistToFile ; (; char * ; outputFile, . const char * ; histName . ); const. Plots the PDF as a histogram and saves it to a file, so that it can be loaded in as a Roo2DHist PDF in the future to save on calculation time. ; Parameters. [in]outputFileName of the file where to store the PDF ; [in]histNamePDF histogram name . Definition at line 525 of file Roo2DKeysPdf.cxx. ◆ writeNTupleToFile(). void Roo2DKeysPdf::writeNTupleToFile ; (; char * ; outputFile, . const char * ; name . ); const. Saves the data and calculated bandwidths to a file, as a record of what produced the PDF and to give a reduced data set in order to facilitate re-calculation in the future. ; Parameters. [in]outputFileName of the file where to store the data ; [in]nameName of the tree which will contain the data . Definition at line 559 of file Roo2DKeysPdf.cxx. ◆ writeToFile(). void Roo2DKeysPdf::writeToFile ; (; char * ; outputFile, . const char * ; name . ); const. Definition at line 508 of file Roo2DKeysPdf.cxx. Member Data Documentation. ◆ _2pi. double Roo2DKeysPdf::_2pi. private . Definition at line 107 of file Roo2DKeysPdf.h. ◆ _BandWidthType. Int_t Roo2DKey",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRoo2DKeysPdf.html:81946,load,loaded,81946,doc/master/classRoo2DKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRoo2DKeysPdf.html,1,['load'],['loaded']
Performance,"d RooProfileLL::initializeMinimizer ; (; ); const. protected . Definition at line 122 of file RooProfileLL.cxx. ◆ IsA(). TClass * RooProfileLL::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsReal.; Definition at line 70 of file RooProfileLL.h. ◆ minimizer(). RooMinimizer * RooProfileLL::minimizer ; (; ). inline . Definition at line 33 of file RooProfileLL.h. ◆ nll(). RooAbsReal & RooProfileLL::nll ; (; ). inline . Definition at line 34 of file RooProfileLL.h. ◆ numEval(). Int_t RooProfileLL::numEval ; (; ); const. inline . Definition at line 44 of file RooProfileLL.h. ◆ redirectServersHook(). bool RooProfileLL::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursiveStep . ). overridevirtual . Function that is called at the end of redirectServers(). ; Can be overloaded to inject some class-dependent behavior after server redirection, e.g. resetting of caches. The return value is meant to be an error flag, so in case something goes wrong the function should return true. If you overload this function, don't forget to also call the function of the base class.; See alsoredirectServers() For a detailed explanation of the function parameters. ; Reimplemented from RooAbsReal.; Definition at line 269 of file RooProfileLL.cxx. ◆ setAlwaysStartFromMin(). void RooProfileLL::setAlwaysStartFromMin ; (; bool ; flag). inline . Definition at line 30 of file RooProfileLL.h. ◆ Streamer(). void RooProfileLL::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooProfileLL::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 70 of file RooProfileLL.h. ◆ validateAbsMin(). void RooProfileLL::validateAbsMin ; (; ); const. protected . Check that parameters and likelihood value for 'best fit' are still valid. ; If not, bec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProfileLL.html:65220,cache,caches,65220,doc/master/classRooProfileLL.html,https://root.cern,https://root.cern/doc/master/classRooProfileLL.html,1,['cache'],['caches']
Performance,"d SetAxisColor(Color_t color = 1); Set color of the line axis and tick marks. void SetLabelColor(Color_t color = 1); Set color of labels. void SetLabelFont(Style_t font = 62); Set labels' font. void SetLabelOffset(Float_t offset = 0.005); Set distance between the axis and the labels; The distance is expressed in per cent of the pad width. void SetLabelSize(Float_t size = 0.04); Set size of axis labels; The size is expressed in per cent of the pad width. void SetNdivisions(Int_t n = 510, Bool_t optim = kTRUE); Set the number of divisions for this axis. if optim = kTRUE (default), the number of divisions will be; optimized around the specified value.; if optim = kFALSE, or n < 0, the axis will be forced to use; exactly n divisions. n = n1 + 100*n2 + 10000*n3. Where n1 is the number of primary divisions,; n2 is the number of second order divisions and; n3 is the number of third order divisions. e.g. 512 means 12 primary and 5 secondary divisions. If the number of divisions is ""optimized"" (see above) n1, n2, n3 are; maximum values. void SetNdivisions(Int_t n1, Int_t n2, Int_t n3, Bool_t optim = kTRUE); see function above. void SetTickLength(Float_t length = 0.03); Set tick mark length; The length is expressed in per cent of the pad width. void SetTitleOffset(Float_t offset = 1); Set distance between the axis and the axis title; Offset is a correction factor with respect to the ""standard"" value.; offset = 1 uses the default position that is computed in function; of the label offset and size.; offset = 1.2 will add 20 per cent more to the default offset. void SetTitleSize(Float_t size = 0.04); Set size of axis title; The size is expressed in per cent of the pad width. void SetTitleColor(Color_t color = 1); Set color of axis title. void SetTitleFont(Style_t font = 62); Set the title font. void Streamer(TBuffer& b); Stream an object of class TAttAxis. TAttAxis(). Int_t GetNdivisions() const; {return fNdivisions;}. Color_t GetAxisColor() const; {return fAxisColor;}. Color_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAttAxis.html:3719,optimiz,optimized,3719,root/html526/TAttAxis.html,https://root.cern,https://root.cern/root/html526/TAttAxis.html,4,['optimiz'],['optimized']
Performance,"d SetFCN(void fcn); this for CINT (interactive functions). void SetFCN(void* ). void SetMinuitFCN(ROOT::Minuit2::FCNBase* f); set FCN using Minuit interface; you pass to the class ownership of FCNBase pointer. const ROOT::Minuit2::FCNBase * GetMinuitFCN() const; { return fMinuitFCN; }. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; { return fMinimizer; }. int Minimize(int nfcn = 0, double edmval = 0.1); additional abstract methods to be implemented by derived classes. int GetStrategy(); { return fStrategy; }. int PrintLevel(); { return fDebug; }. void SetStrategy(int stra); { fStrategy = stra; }. void SetPrintLevel(int level); { fDebug = level; }. void SetMinimumTolerance(double mintol); set minimum tolerance to avoid having clients (as TGraf::Fit) setting tolerances too small. { fMinTolerance = mintol; }. double MinimumTolerance() const; { return fMinTolerance; }. void CreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); create the minimizer type (Migard or Simplex); can be re-implemented in the derived classes. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void CreateChi2FCN(); functions to create FCN - re-implemented in derived class (GFumili). void CreateChi2ExtendedFCN(). void CreateBinLikelihoodFCN(). void CreateUnbinLikelihoodFCN(); {}. ROOT::Minuit2::FunctionMinimum DoMinimization(int nfcn = 0, double edmval = 0.1); internal function to perform the actual minimization (could be implemented by derived classes). int ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& ); internal funcition to study Function minimum results; return 0 if function minimum is OK or an error code. void Initialize(). » Author: L. Moneta 10/2005 » Copyright (c) 2005 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFitterMinuit.html:14363,perform,perform,14363,root/html534/TFitterMinuit.html,https://root.cern,https://root.cern/root/html534/TFitterMinuit.html,1,['perform'],['perform']
Performance,"d SkipVersion(const TClass* cl = 0); Skip class version from I/O buffer. Version_t ReadVersion(UInt_t* start = 0, UInt_t* bcnt = 0, const TClass* cl = 0); read version value from buffer. UInt_t WriteVersion(const TClass* cl, Bool_t useBcnt = kFALSE); Ignored in TBufferJSON. void * ReadObjectAny(const TClass* clCast); Read object from buffer. Only used from TBuffer. void SkipObjectAny(); Skip any kind of object from buffer. void WriteObjectClass(const void* actualObjStart, const TClass* actualClass); Write object to buffer. Only used from TBuffer. void ReadFloat16(Float_t* f, TStreamerElement* ele = 0); read a Float16_t from the buffer. void ReadDouble32(Double_t* d, TStreamerElement* ele = 0); read a Double32_t from the buffer. void ReadWithFactor(Float_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have; been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void ReadWithNbits(Float_t* ptr, Int_t nbits); Read a Float16_t from the buffer when the number of bits is specified; (explicitly or not); see comments about Float16_t encoding at TBufferFile::WriteFloat16().; Currently TBufferJSON does not optimize space in this case. void ReadWithFactor(Double_t* ptr, Double_t factor, Double_t minvalue); Read a Double32_t from the buffer when the factor and minimun value have; been specified; see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void ReadWithNbits(Double_t* ptr, Int_t nbits); Read a Double32_t from the buffer when the number of bits is specified; (explicitly or not); see comments about Double32_t encoding at TBufferFile::WriteDouble32().; Currently TBufferJSON does not optimize space in this case. void WriteFloat16(Float_t* f, TStreamerElement* ele = 0); write a Float16_t to the buffer. void WriteDouble32(Double_t* d, TStream",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferJSON.html:27495,optimiz,optimize,27495,root/html534/TBufferJSON.html,https://root.cern,https://root.cern/root/html534/TBufferJSON.html,3,['optimiz'],['optimize']
Performance,"d TFPBlock) to prefetch in advance a block of tree entries. ; There is a thread which takes care of actually transferring the blocks and making them available to the main requesting thread. Therefore, the time spent by the main thread waiting for the data before processing considerably decreases. Besides the prefetching mechanisms there is also a local caching option which can be enabled by the user. Both capabilities are disabled by default and must be explicitly enabled by the user. ; Definition at line 33 of file TFilePrefetch.h. Public Member Functions;  TFilePrefetch (TFile *);  Constructor. ;  ;  ~TFilePrefetch () override;  Destructor. ;  ; void AddPendingBlock (TFPBlock *);  Safe method to add a block to the pendingList. ;  ; void AddReadBlock (TFPBlock *);  Safe method to add a block to the readList. ;  ; Bool_t BinarySearchReadList (TFPBlock *, Long64_t, Int_t, Int_t *);  Search for a requested element in a block and return the index. ;  ; Bool_t CheckBlockInCache (char *&, TFPBlock *);  Test if the block is in cache. ;  ; TFPBlock * CreateBlockObj (Long64_t *, Int_t *, Int_t);  Create a new block or recycle an old one. ;  ; char * GetBlockFromCache (const char *, Int_t);  Return a buffer from cache. ;  ; std::condition_variable & GetCondNewBlock ();  ; TFPBlock * GetPendingBlock ();  Safe method to remove a block from the pendingList. ;  ; TThread * GetThread () const;  Return reference to the consumer thread. ;  ; Long64_t GetWaitTime ();  Return the time spent wating for buffer to be read in microseconds. ;  ; TClass * IsA () const override;  ; Bool_t IsPrefetchFinished () const;  ; void ReadAsync (TFPBlock *, Bool_t &);  Read one block and insert it in prefetchBuffers list. ;  ; void ReadBlock (Long64_t *, Int_t *, Int_t);  Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. ;  ; Bool_t ReadBuffer (char *, Long64_t, Int_t);  Return a prefetched element. ;  ; void ReadListOfBlocks ();  Get blocks specified in prefetchBlocks. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFilePrefetch.html:1433,cache,cache,1433,doc/master/classTFilePrefetch.html,https://root.cern,https://root.cern/doc/master/classTFilePrefetch.html,1,['cache'],['cache']
Performance,"d TMVA::Experimental::Classification::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TMVA::Envelope. ◆ StreamerNVirtual(). void TMVA::Experimental::Classification::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 202 of file Classification.h. ◆ Test(). void TMVA::Experimental::Classification::Test ; (; ). virtual . Perform test evaluation in all booked methods. ; Definition at line 513 of file Classification.cxx. ◆ TestMethod() [1/2]. void TMVA::Experimental::Classification::TestMethod ; (; TString ; methodname, . TString ; methodtitle . ). virtual . Lets perform test an specific ml method. ; Parameters. methodnamename of the method. ; methodtitlemethod title. . Definition at line 526 of file Classification.cxx. ◆ TestMethod() [2/2]. void TMVA::Experimental::Classification::TestMethod ; (; Types::EMVA ; method, . TString ; methodtitle . ). virtual . Lets perform test an specific ml method given the method type in enum TMVA::Types::EMVA. ; Parameters. methodTMVA::Types::EMVA type. ; methodtitlemethod title. . Definition at line 935 of file Classification.cxx. ◆ Train(). void TMVA::Experimental::Classification::Train ; (; ). virtual . Method to train all booked ml methods. ; Definition at line 324 of file Classification.cxx. ◆ TrainMethod() [1/2]. void TMVA::Experimental::Classification::TrainMethod ; (; TString ; methodname, . TString ; methodtitle . ). virtual . Lets train an specific ml method. ; Parameters. methodnamename of the method. ; methodtitlemethod title. . Definition at line 337 of file Classification.cxx. ◆ TrainMethod() [2/2]. void TMVA::Experimental::Classification::TrainMethod ; (; Types::EMVA ; method, . TString ; methodtitle . ). virtual . Lets train an specific ml method given the method type in enum TMVA::Types::EMVA. ; Parameters. methodTMVA::Types::EMVA type. ; methodtitlemethod title. . Definition at line 373 of file Classification.cxx. Member Data Doc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Experimental_1_1Classification.html:26907,perform,perform,26907,doc/master/classTMVA_1_1Experimental_1_1Classification.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Experimental_1_1Classification.html,1,['perform'],['perform']
Performance,"d TNetXNGFile.; Definition at line 1720 of file TFile.cxx. ◆ ReadBufferAsync(). Bool_t TFile::ReadBufferAsync ; (; Long64_t ; offs, . Int_t ; len . ). virtual . Reimplemented in TDavixFile, and TXNetFile.; Definition at line 5208 of file TFile.cxx. ◆ ReadBuffers(). Bool_t TFile::ReadBuffers ; (; char * ; buf, . Long64_t * ; pos, . Int_t * ; len, . Int_t ; nbuf . ). virtual . Read the nbuf blocks described in arrays pos and len. ; The value pos[i] is the seek position of block i of length len[i]. Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer. This function is overloaded by TNetFile, TWebFile, etc. Returns kTRUE in case of failure. ; Reimplemented in TDavixFile, TXNetFile, TDCacheFile, TNetFile, TS3WebFile, TWebFile, and TNetXNGFile.; Definition at line 1821 of file TFile.cxx. ◆ ReadBufferViaCache(). Int_t TFile::ReadBufferViaCache ; (; char * ; buf, . Int_t ; len . ). protected . Read buffer via cache. ; Returns 0 if the requested block is not in the cache, 1 in case read via cache was successful, 2 in case read via cache failed. ; Definition at line 1889 of file TFile.cxx. ◆ ReadFree(). void TFile::ReadFree ; (; ). virtual . Read the FREE linked list. ; Every file has a linked list (fFree) of free segments. This linked list has been written on the file via WriteFree as a single data record. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 1925 of file TFile.cxx. ◆ ReadProcessID(). TProcessID * TFile::ReadProcessID ; (; UShort_t ; pidf). virtual . The TProcessID with number pidf is read from this file. ; If the object is not already entered in the gROOT list, it is added. ; Definition at line 1951 of file TFile.cxx. ◆ ReadStreamerInfo(). void TFile::ReadStreamerInfo ; (; ). virtual . Read the list of StreamerInfo from this file. ; The key with name holding the list of TStreamerInfo objects is read. The corresponding TClass objects are updated. Note that this function is not called if the static member fgReadInfo is false. (see TFile",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:87626,cache,cache,87626,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,3,['cache'],['cache']
Performance,"d after the event loop is finished; c#define c(i)Definition RSha256.hxx:101; h#define h(i)Definition RSha256.hxx:106; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; A value of 0 for everyNEvents indicates the callback must be executed only once, before running the event loop. A conveniece definition kOnce is provided to make this fact more expressive in user code (see snippet below). Multiple callbacks can be registered with the same RResultPtr (i.e. results of RDataFrame actions) and will be executed sequentially. Callbacks are executed in the order they were registered. The type of the value contained in a RResultPtr is also available as RResultPtr<T>::Value_t, e.g. auto h = tdf.Histo1D(""x"");; // h.kOnce is 0; // decltype(h)::Value_t is TH1D; When implicit multi-threading is enabled, the callback:; will never be executed by multiple threads concurrently: it needs not be thread-safe. For example the snippet above that draws the partial histogram on a canvas works seamlessly in multi-thread event loops.; will always be executed ""everyNEvents"": partial results will ""contain"" that number of events more from one call to the next; might be executed by a different worker thread at different times: the value of std::this_thread::get_id() might change between calls. To register a callback that is called by each worker thread (concurrently) every N events one can use OnPartialResultSlot(). ; Definition at line 318 of file RResultPtr.hxx. ◆ OnPartialResultSlot(). template<typename T > . RResultPtr< T > & ROOT::RDF::RResultPtr< T >::OnPartialResultSlot ; (; ULong64_t ; everyNEvents, . std::function< void(unsigned int, T &)> ; callback . ). inline . Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's partial result. ; Parameters. [in]ev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html:11045,multi-thread,multi-threading,11045,doc/master/classROOT_1_1RDF_1_1RResultPtr.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html,2,"['concurren', 'multi-thread']","['concurrently', 'multi-threading']"
Performance,"d after the fitting step. Any summary output variables declared in the RooDataSet exported through summaryData() is merged with the 'master' summary dataset in RooMCStudy.; Look at RooDLLSignificanceMCSModule for an example of an implementation. ; Definition at line 30 of file RooAbsMCStudyModule.h. Public Member Functions;  RooAbsMCStudyModule (const char *name, const char *title);  Constructor. ;  ;  RooAbsMCStudyModule (const RooAbsMCStudyModule &other);  Copy constructor. ;  ; bool doInitializeInstance (RooMCStudy &);  Initializer method called upon attachment to given RooMCStudy object. ;  ; virtual RooDataSet * finalizeRun ();  Method called at the end of each RooMCStudy run. ;  ; virtual bool initializeInstance ();  Initializer called immediately after attachment to RooMCStudy object and initialization of module base class. ;  ; virtual bool initializeRun (Int_t);  Method called at the beginning of each RooMCStudy run. ;  ; TClass * IsA () const override;  ; virtual bool processAfterFit (Int_t);  Method called after fit has been performed. ;  ; virtual bool processBeforeGen (Int_t);  Method called after resetting of generator parameters to initial values and before call to generator context Any modifications to generator parameters will affect next generation operation (only) ;  ; virtual bool processBetweenGenAndFit (Int_t);  Method called after generation of toy data sample and resetting of fit parameters to initial values and before actual fit is performed. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsMCStudyModule.html:1645,perform,performed,1645,doc/master/classRooAbsMCStudyModule.html,https://root.cern,https://root.cern/doc/master/classRooAbsMCStudyModule.html,1,['perform'],['performed']
Performance,"d as a Long_t value.Definition TClass.cxx:6153; TClass::ReadRulesstatic Int_t ReadRules()Read the class.rules files from the default location:.Definition TClass.cxx:1887; TClass::kInterpreted@ kInterpretedDefinition TClass.h:126; TClass::kHasTClassInit@ kHasTClassInitDefinition TClass.h:127; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::kForwardDeclared@ kForwardDeclaredDefinition TClass.h:124; TClass::kNamespaceForMeta@ kNamespaceForMetaDefinition TClass.h:131; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::fHasRootPcmInfostd::atomic< Bool_t > fHasRootPcmInfoC++ Property of the class (is abstract, has virtual table, etc.)Definition TClass.h:259; TClass::GetDeclFileNameconst char * GetDeclFileName() constReturn name of the file containing the declaration of this class.Definition TClass.cxx:3530; TClass::kIsTObject@ kIsTObjectDefinition TClass.h:100; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClingBaseClassInfoEmulation of the CINT BaseClassInfo class.Definition TClingBaseClassInfo.h:43; TClingBaseClassInfo::TmpltNameconst char * TmpltName() constDefinition TClingBaseClassInfo.cxx:578; TClingBaseClassInfo::Nameconst char * Name() constDefinition TClingBaseClassInfo.cxx:570; TClingBaseClassInfo::Offsetptrdiff_t Offset(void *address=0, bool isDerivedObject=true) constDefinition TClingBaseClassInfo.cxx:411; TClingBaseClassInfo::IsValidbool IsValid() constDefinition TClingBaseClassInfo.cxx:244; TClingBaseClassInfo::Nextint Next()Definition TClingBaseClassInfo.cxx:353; TClingBaseClassInfo::Tagnumlong Tagnum() constDefinition TClingBaseClassInfo.cxx:553; TClingBaseClassInfo::Propertylong Property() constDefinition TClingBaseClassInfo.cxx:488; TClingBaseClassInfo::FullNamevoid FullName(std::string &output, const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt) constDefi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:402286,load,load,402286,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['load']
Performance,"d below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is automatically used by TTree::Draw. The method knows which branches are used in the query and it puts automatically these branches in the cache. The entry range is also inferred automatically. TTree::Process and TSelectors Examples; The user must enable the cache and tell the system which branches to cache and also specify the entry range. It is important to specify the entry range in case only a subset of the events is processed to avoid wasteful caching.; Reading all branches; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"", true); //<<< add all branches to the cache; T->Process(""myselector.C+"");; // In the TSelector::Process function we read all branches; T->GetEntry(i);; // ... Here the entry is processed; f#define f(i)Definition RSha256.hxx:104; nentriesint nentriesDefinition THbookFile.cxx:91; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Reading a subset of all branches; In the Process function we read a subset of the branc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:6593,cache,cache,6593,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cache']
Performance,"d blocks. ;  ; Long64_t * fPos;  [fNb] start of long buffers ;  ; TFilePrefetch * fPrefetch;  ! Object that does the asynchronous reading in another thread ;  ; Long64_t fPrefetchedBlocks;  Number of blocks prefetched. ;  ; Int_t fReadCalls;  Number of read calls for this cache. ;  ; Long64_t * fSeek;  [fNseek] Position on file of buffers to be prefetched ;  ; Int_t * fSeekIndex;  [fNseek] sorted index table of fSeek ;  ; Int_t * fSeekLen;  [fNseek] Length of buffers to be prefetched ;  ; Int_t * fSeekPos;  [fNseek] Position of sorted blocks in fBuffer ;  ; Int_t fSeekSize;  Allocated size of fSeek. ;  ; Long64_t * fSeekSort;  [fNseek] Position on file of buffers to be prefetched (sorted) ;  ; Int_t * fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorted) ;  . Static Protected Attributes; static Int_t fgLearnEntries = 100;  number of entries used for learning mode ;  . Private Member Functions;  TTreeCache (const TTreeCache &)=delete;  this class cannot be copied ;  ; bool CalculateMissCache ();  Calculate the appropriate miss cache to fetch; helper function for FillMissCache. ;  ; TBranch * CalculateMissEntries (Long64_t, int, bool);  Given an file read, try to determine the corresponding branch. ;  ; bool CheckMissCache (char *buf, Long64_t pos, int len);  Check the miss cache for a particular buffer, fetching if deemed necessary. ;  ; bool FillMissCache ();  Fill the miss cache from the current set of active branches. ;  ; IOPos FindBranchBasketPos (TBranch &, Long64_t entry);  Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ;  ; TTreeCache & operator= (const TTreeCache &)=delete;  ; bool ProcessMiss (Long64_t pos, int len);  ! Given a file read not in the miss cache, handle (possibly) loading the data. ;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TFileCacheRead; void SetEnableP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:32345,cache,cache,32345,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cache']
Performance,"d bounding box, calculated as an expanded container round the frustum. It is used to test if if object bounding boxes are of interest (should be accepted into viewer scene) for a camera - see TGLCamera::OfInterest(); The interest box is updated if the frustum is no longer contained in the existing one, or a new one calculated on the current frustum differs significantly in volume (camera has been zoomed/dollyed sizable amount).; If the interest box is updated we return kTRUE - kFALSE otherwise. ; Definition at line 643 of file TGLCamera.cxx. ◆ ViewportDeltaToWorld(). TGLVector3 TGLCamera::ViewportDeltaToWorld ; (; const TGLVertex3 & ; worldRef, . Double_t ; viewportXDelta, . Double_t ; viewportYDelta, . TGLMatrix * ; modviewMat = nullptr . ); const. Apply a 2D viewport delta (shift) to the projection of worldRef onto viewport, returning the resultant world vector which equates to it. ; Useful for making 3D world objects track mouse moves.; Camera must have valid frustum cache - call Apply() ; Definition at line 546 of file TGLCamera.cxx. ◆ ViewportOverlap(). Rgl::EOverlap TGLCamera::ViewportOverlap ; (; const TGLBoundingBox & ; box); const. Calculate overlap (kInside, kOutside, kPartial) of box projection onto viewport (as rect) against the viewport rect. ; Camera must have valid frustum cache - call Apply() after last modification, before using. ; Definition at line 319 of file TGLCamera.cxx. ◆ ViewportPlaneIntersection() [1/2]. std::pair< Bool_t, TGLVertex3 > TGLCamera::ViewportPlaneIntersection ; (; const TPoint & ; viewport, . const TGLPlane & ; worldPlane . ); const. Find the intersection of projection of supplied viewport TPoint (a 3D world line - see ViewportToWorld) with supplied world plane. ; Returns std::pair of bool and vertex. If line intersects; Camera must have valid frustum cache - call Apply() after last modification, before using ; Definition at line 533 of file TGLCamera.cxx. ◆ ViewportPlaneIntersection() [2/2]. std::pair< Bool_t, TGLVertex3 > TGLC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLCamera.html:34401,cache,cache,34401,doc/master/classTGLCamera.html,https://root.cern,https://root.cern/doc/master/classTGLCamera.html,1,['cache'],['cache']
Performance,"d box to frame; 2386 frame->addObject(box) ;; 2387 ; 2388 return frame ;; 2389}; 2390 ; 2391 ; 2392 ; 2393 ; 2394////////////////////////////////////////////////////////////////////////////////; 2395/// Return expected number of events from this p.d.f for use in extended; 2396/// likelihood calculations. This default implementation returns zero; 2397 ; 2398double RooAbsPdf::expectedEvents(const RooArgSet*) const; 2399{; 2400 return 0 ;; 2401}; 2402 ; 2403 ; 2404 ; 2405////////////////////////////////////////////////////////////////////////////////; 2406/// Change global level of verbosity for p.d.f. evaluations; 2407 ; 2408void RooAbsPdf::verboseEval(Int_t stat); 2409{; 2410 _verboseEval = stat ;; 2411}; 2412 ; 2413 ; 2414 ; 2415////////////////////////////////////////////////////////////////////////////////; 2416/// Return global level of verbosity for p.d.f. evaluations; 2417 ; 2418Int_t RooAbsPdf::verboseEval(); 2419{; 2420 return _verboseEval ;; 2421}; 2422 ; 2423 ; 2424 ; 2425////////////////////////////////////////////////////////////////////////////////; 2426/// Destructor of normalization cache element. If this element; 2427/// provides the 'current' normalization stored in RooAbsPdf::_norm; 2428/// zero _norm pointer here before object pointed to is deleted here; 2429 ; 2430RooAbsPdf::CacheElem::~CacheElem(); 2431{; 2432 // Zero _norm pointer in RooAbsPdf if it is points to our cache payload; 2433 if (_owner) {; 2434 RooAbsPdf* pdfOwner = static_cast<RooAbsPdf*>(_owner) ;; 2435 if (pdfOwner->_norm == _norm.get()) {; 2436 pdfOwner->_norm = nullptr ;; 2437 }; 2438 }; 2439}; 2440 ; 2441 ; 2442 ; 2443////////////////////////////////////////////////////////////////////////////////; 2444/// Return a p.d.f that represent a projection of this p.d.f integrated over given observables; 2445 ; 2446RooAbsPdf* RooAbsPdf::createProjection(const RooArgSet& iset); 2447{; 2448 // Construct name for new object; 2449 std::string name = std::string{GetName()} + ""_Proj["" + RooHe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:116587,cache,cache,116587,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['cache'],['cache']
Performance,"d but not operator; 73// delete, we can still use it to detect the cases where the destructor was called.; 74 ; 75ATTRIBUTE_NO_SANITIZE_ADDRESS; 76bool DeleteChangesMemoryImpl(); 77{; 78 static constexpr UInt_t kGoldenUUID = 0x00000021;; 79 static constexpr UInt_t kGoldenbits = 0x03000000;; 80 ; 81 TObject *o = new TObject;; 82 o->SetUniqueID(kGoldenUUID);; 83 UInt_t *o_fuid = &(o->fUniqueID);; 84 UInt_t *o_fbits = &(o->fBits);; 85 ; 86 if (*o_fuid != kGoldenUUID) {; 87 Error(""CheckingDeleteSideEffects"",; 88 ""fUniqueID is not as expected, we got 0x%.8x instead of 0x%.8x"",; 89 *o_fuid, kGoldenUUID);; 90 }; 91 if (*o_fbits != kGoldenbits) {; 92 Error(""CheckingDeleteSideEffects"",; 93 ""fBits is not as expected, we got 0x%.8x instead of 0x%.8x"",; 94 *o_fbits, kGoldenbits);; 95 }; 96 if (gDebug >= 9) {; 97 unsigned char *oc = reinterpret_cast<unsigned char *>(o); // for address calculations; 98 unsigned char references[sizeof(TObject)];; 99 memcpy(references, oc, sizeof(TObject));; 100 ; 101 // The effective part of this code (the else statement is just that without; 102 // any of the debug statement); 103 delete o;; 104 ; 105 // Not using the error logger, as there routine is meant to be called; 106 // during library initialization/loading.; 107 fprintf(stderr,; 108 ""DEBUG: Checking before and after delete the content of a TObject with uniqueID 0x21\n"");; 109 for(size_t i = 0; i < sizeof(TObject); i += 4) {; 110 fprintf(stderr, ""DEBUG: 0x%.8x vs 0x%.8x\n"", *(int*)(references +i), *(int*)(oc + i));; 111 }; 112 } else; 113 delete o; // the 'if' part is that surrounded by the debug code.; 114 ; 115 // Intentionally accessing the deleted memory to check whether it has been changed as; 116 // a consequence (side effect) of executing operator delete. If there no change, we; 117 // can guess this is always the case and we can rely on the changes to fBits made; 118 // by ~TObject to detect use-after-delete error (and print a message rather than; 119 // stop the program with a seg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8cxx_source.html:3729,load,loading,3729,doc/master/TObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html,1,['load'],['loading']
Performance,"d by "";;"" to let execute several methods at once. ;  ; TPad * ProcessObjectOptions (TWebObjectOptions &item, TPad *pad, int idcnt=1);  Process data for single primitive Returns object pad if object was modified. ;  ; void SetWindowGeometry (const std::vector< int > &arr);  Set window geometry as array with coordinates and dimensions. ;  ; void ShowCmd (const std::string &arg, Bool_t show);  Function used to send command to browser to toggle menu, toolbar, editors, ... ;  ; void Unlock () override;  ; Bool_t WaitWhenCanvasPainted (Long64_t ver);  Wait when specified version of canvas was painted and confirmed by browser. ;  ;  Protected Member Functions inherited from TCanvasImp;  TCanvasImp (const TCanvasImp &ci);  ; TCanvasImp & operator= (const TCanvasImp &ci);  . Static Protected Member Functions; static bool FlushBatchImages ();  Flush batch images. ;  ; static std::string ProcessCustomScripts (bool batch);  For batch mode special handling of scripts are required Headless browser not able to load modules from the file system Therefore custom web-canvas modules and scripts has to be loaded in advance and processed. ;  . Protected Attributes; PadSignal_t fActivePadChangedSignal;  ! signal emitted when active pad changed in the canvas ;  ; std::vector< TPad * > fAllPads;  ! list of all pads recognized during streaming ;  ; Bool_t fAsyncMode {kFALSE};  ! when true, methods like TCanvas::Update will never block ;  ; Bool_t fCanCreateObjects {kTRUE};  ! indicates if canvas allowed to create extra objects for interactive painting ;  ; Long64_t fCanvVersion {1};  ! actual canvas version, changed with every new Modified() call ;  ; UInt_t fClientBits {0};  ! latest status bits from client like editor visible or not ;  ; UInt_t fColorsHash {0};  ! last hash of colors/palette ;  ; Long64_t fColorsVersion {0};  ! current colors/palette version, checked every time when new snapshot created ;  ; Bool_t fFixedSize {kFALSE};  ! is canvas size fixed ;  ; std::vector< std::unique",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebCanvas.html:13442,load,load,13442,doc/master/classTWebCanvas.html,https://root.cern,https://root.cern/doc/master/classTWebCanvas.html,2,['load'],"['load', 'loaded']"
Performance,"d by TBranch::GetBasket Returns: ;  ; Int_t CreateTasks ();  We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ;  ; bool FillBuffer () override;  Fill the cache buffer with the branches in the cache. ;  ; Int_t GetNFound ();  ; Int_t GetNMissed ();  ; Int_t GetNUnzip ();  ; Int_t GetRecordHeader (char *buf, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header from the buffer buf. ;  ; Int_t GetUnzipBuffer (char **buf, Long64_t pos, Int_t len, bool *free) override;  We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ;  ; Int_t GetUnzipGroupSize ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBufferExt (char *buf, Long64_t pos, Int_t len, Int_t &loc) override;  ; void ResetCache () override;  This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ;  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; void SetEntryRange (Long64_t emin, Long64_t emax) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ;  ; void SetUnzipGroupSize (Int_t groupSize);  ; void StopLearningPhase () override;  It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:3077,cache,cache,3077,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,2,['cache'],['cache']
Performance,"d by TBranch::GetBasket Returns: ;  ; Int_t CreateTasks ();  We create a TTaskGroup and asynchronously maps each group of baskets(> 100 kB in total) to a task. ;  ; bool FillBuffer () override;  Fill the cache buffer with the branches in the cache. ;  ; Int_t GetNFound ();  ; Int_t GetNMissed ();  ; Int_t GetNUnzip ();  ; Int_t GetRecordHeader (char *buf, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header from the buffer buf. ;  ; Int_t GetUnzipBuffer (char **buf, Long64_t pos, Int_t len, bool *free) override;  We try to read a buffer that has already been unzipped Returns -1 in case of read failure, 0 in case it's not in the cache and n>0 in case read from cache (number of bytes copied). ;  ; Int_t GetUnzipGroupSize ();  ; TClass * IsA () const override;  ; void Print (Option_t *option="""") const override;  Print cache statistics. ;  ; Int_t ReadBufferExt (char *buf, Long64_t pos, Int_t len, Int_t &loc) override;  ; void ResetCache () override;  This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ;  ; Int_t SetBufferSize (Long64_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; void SetEntryRange (Long64_t emin, Long64_t emax) override;  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetUnzipBufferSize (Long64_t bufferSize);  Sets the size for the unzipping cache... by default it should be two times the size of the prefetching cache. ;  ; void SetUnzipGroupSize (Int_t groupSize);  ; void StopLearningPhase () override;  It's the same as TTreeCache::StopLearningPhase but we guarantee that we start the unzipping just after getting the buffers. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t UnzipBuffer (char **dest, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCacheUnzip.html:3078,cache,cache,3078,doc/master/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/master/classTTreeCacheUnzip.html,2,['cache'],['cache']
Performance,"d by user via TFumili::SetData. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TVirtualFitter;  TVirtualFitter ();  Default constructor. ;  ;  ~TVirtualFitter () override;  Cleanup virtual fitter. ;  ; virtual void GetConfidenceIntervals (Int_t n, Int_t ndim, const Double_t *x, Double_t *ci, Double_t cl=0.95);  return confidence intervals in array x of dimension ndim implemented in TFitter and TLinearFitter ;  ; virtual void GetConfidenceIntervals (TObject *obj, Double_t cl=0.95);  return confidence intervals in TObject obj implemented in TFitter and TLinearFitter ;  ; virtual FCNFunc_t GetFCN ();  ; virtual Foption_t GetFitOption () const;  ; TMethodCall * GetMethodCall () const;  ; virtual TObject * GetObjectFit () const;  ; virtual TObject * GetUserFunc () const;  ; virtual Int_t GetXfirst () const;  ; virtual Int_t GetXlast () const;  ; virtual Int_t GetYfirst () const;  ; virtual Int_t GetYlast () const;  ; virtual Int_t GetZfirst () const;  ; virtual Int_t GetZlast () const;  ; TClass * IsA () const override;  ; virtual Double_t * SetCache (Int_t npoints, Int_t psize);  Initialize the cache array npoints is the number of points to be stored (or already stored) in the cache psize is the number of elements per point. ;  ; virtual void SetFCN (void(*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t));  To set the address of the minimization objective function called by the native compiler (see function below when called by CINT) ;  ; virtual void SetFitOption (Foption_t option);  ; virtual void SetObjectFit (TObject *obj);  ; virtual void SetUserFunc (TObject *userfunc);  ; virtual void SetXfirst (Int_t first);  ; virtual void SetXlast (Int_t last);  ; virtual void SetYfirst (Int_t first);  ; virtual void SetYlast (Int_t last);  ; virtual void SetZfirst (Int_t first);  ; virtual void SetZlast (Int_t last);  ; void Strea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFumili.html:8911,cache,cache,8911,doc/master/classTFumili.html,https://root.cern,https://root.cern/doc/master/classTFumili.html,2,['cache'],['cache']
Performance,"d canvas (if exist); TClassMenuItem*fSelectedMenuItemselected class menu item; TFunction*fSelectedMethodselected method; TObject*fSelectedObjectselected object; TVirtualPad*fSelectedPadselected pad (if exist); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TContextMenu(const char* name, const char* title = ""Context sensitive popup menu""); Create a context menu. ~TContextMenu(); Destroy a context menu. void Action(TObject *object, TMethod *method); Action to be performed when this menu item is selected.; If the selected method requires arguments we popup an; automatically generated dialog, otherwise the method is; directly executed. void Action(TClassMenuItem *menuitem); Action to be performed when this menu item is selected.; If the selected method requires arguments we popup an; automatically generated dialog, otherwise the method is; directly executed. void Action(TObject *object, TToggle *toggle); Action to be performed when this toggle menu item is selected. const char * CreateArgumentTitle(TMethodArg* argument); Create string describing argument (for use in dialog box). const char * CreateDialogTitle(TObject* object, TFunction* method); Create title for dialog box retrieving argument values. const char * CreatePopupTitle(TObject* object); Create title for popup menu. void Execute(TObject *object, TFunction *method, const char *params); Execute method with specified arguments for specified object. void Execute(TObject *object, TFunction *method, TObjArray *params); Execute method with specified arguments for specified object. void Popup(Int_t x, Int_t y, TObject* obj, TVirtualPad* c = 0, TVirtualPad* p = 0); Popup context menu at given location in canvas c and pad p for selected; object. void Popup(Int_t x, Int_t y, TObject* obj, TBrowser* b); Popup context menu at given location in browser b for selected object. TContextMenu(const TContextMenu& ). TContextMenu& operator=(const TConte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TContextMenu.html:8553,perform,performed,8553,root/html526/TContextMenu.html,https://root.cern,https://root.cern/root/html526/TContextMenu.html,1,['perform'],['performed']
Performance,"d classes or in the typedef.; 5775 ; 5776 DictFuncPtr_t dict = TClassTable::GetDictNorm(requestedname);; 5777 ; 5778 if (!dict) {; 5779 if (gInterpreter->AutoLoad(requestedname,kTRUE)) {; 5780 dict = TClassTable::GetDictNorm(requestedname);; 5781 }; 5782 }; 5783 ; 5784 if (dict) {; 5785 TClass *ncl = (dict)();; 5786 if (ncl) ncl->PostLoadCheck();; 5787 return ncl;; 5788 }; 5789 return nullptr;; 5790}; 5791 ; 5792////////////////////////////////////////////////////////////////////////////////; 5793/// Helper function used by TClass::GetClass().; 5794/// This function attempts to load the dictionary for 'classname'; 5795/// from the list of generator.; 5796/// If silent is 'true', do not warn about missing dictionary for the class.; 5797/// (typically used for class that are used only for transient members); 5798///; 5799/// The 'requestedname' is expected to be already normalized.; 5800 ; 5801TClass *TClass::LoadClassCustom(const char *requestedname, Bool_t silent); 5802{; 5803 // This function does not (and should not) attempt to check in the; 5804 // list of loaded classes or in the typedef.; 5805 ; 5806 TIter next(gROOT->GetListOfClassGenerators());; 5807 TClassGenerator *gen;; 5808 while ((gen = (TClassGenerator*) next())) {; 5809 TClass *cl = gen->GetClass(requestedname, kTRUE, silent);; 5810 if (cl) {; 5811 cl->PostLoadCheck();; 5812 return cl;; 5813 }; 5814 }; 5815 return nullptr;; 5816}; 5817 ; 5818////////////////////////////////////////////////////////////////////////////////; 5819/// Try to load the ClassInfo if available. This function may require parsing; 5820/// the header file and/or loading data from the clang pcm. If further calls to; 5821/// this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set; 5822/// to false.; 5823 ; 5824void TClass::LoadClassInfo() const; 5825{; 5826 R__LOCKGUARD(gInterpreterMutex);; 5827 ; 5828 // Return if another thread already loaded the info; 5829 // while we were waiting for the lock; 5830 if (!fCan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:222426,load,loaded,222426,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"d classes or in the typedef.; 5842 ; 5843 DictFuncPtr_t dict = TClassTable::GetDictNorm(requestedname);; 5844 ; 5845 if (!dict) {; 5846 if (gInterpreter->AutoLoad(requestedname,kTRUE)) {; 5847 dict = TClassTable::GetDictNorm(requestedname);; 5848 }; 5849 }; 5850 ; 5851 if (dict) {; 5852 TClass *ncl = (dict)();; 5853 if (ncl) ncl->PostLoadCheck();; 5854 return ncl;; 5855 }; 5856 return nullptr;; 5857}; 5858 ; 5859////////////////////////////////////////////////////////////////////////////////; 5860/// Helper function used by TClass::GetClass().; 5861/// This function attempts to load the dictionary for 'classname'; 5862/// from the list of generator.; 5863/// If silent is 'true', do not warn about missing dictionary for the class.; 5864/// (typically used for class that are used only for transient members); 5865///; 5866/// The 'requestedname' is expected to be already normalized.; 5867 ; 5868TClass *TClass::LoadClassCustom(const char *requestedname, Bool_t silent); 5869{; 5870 // This function does not (and should not) attempt to check in the; 5871 // list of loaded classes or in the typedef.; 5872 ; 5873 TIter next(gROOT->GetListOfClassGenerators());; 5874 TClassGenerator *gen;; 5875 while ((gen = (TClassGenerator*) next())) {; 5876 TClass *cl = gen->GetClass(requestedname, kTRUE, silent);; 5877 if (cl) {; 5878 cl->PostLoadCheck();; 5879 return cl;; 5880 }; 5881 }; 5882 return nullptr;; 5883}; 5884 ; 5885////////////////////////////////////////////////////////////////////////////////; 5886/// Try to load the ClassInfo if available. This function may require parsing; 5887/// the header file and/or loading data from the clang pcm. If further calls to; 5888/// this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set; 5889/// to false.; 5890 ; 5891void TClass::LoadClassInfo() const; 5892{; 5893 R__LOCKGUARD(gInterpreterMutex);; 5894 ; 5895 // Return if another thread already loaded the info; 5896 // while we were waiting for the lock; 5897 if (!fCan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:225177,load,loaded,225177,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"d compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (bytes 1->fBEGIN). Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0) const; One can not save a const TDirectory object. Bool_t WriteBuffer(const char* buf, Int_t len); Write a buffer to the file. This is the basic low level write operation.; Returns kTRUE in case of failure. Int_t WriteBufferViaCache(const char* buf, Int_t len); Write buffer via cache. Returns 0 if cache is not active, 1 in case; write via cache was successful, 2 in case write via cache failed. void WriteFree(); Write FREE linked list on the file.; The linked list of FREE segments (fFree) is written as a single data; record. void WriteHeader(); Write File Header. void MakeProject(const char* dirname, const char* classes = ""*"", Option_t* option = ""new""); Generate code in directory dirname for all classes specified in; argument classes If classes = ""*"" (default and currently the; only supported value), the function generates an include file; for each class in the StreamerInfo list for which a TClass; object does not exist. The code generated includes:; dirnameProjectHeaders.h // contains one #include statement per generated header file; dirnameProjectSource.cxx // contains all the constructors and destructors implementation.; and one header per class that is not nested inside another class.; The header file name is the fully qual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:38988,cache,cache,38988,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,4,['cache'],['cache']
Performance,"d cut range ;  ; Double_t * fCutRangeMin;  minimum of allowed cut range ;  ; TH1 * fEffBvsSLocal;  intermediate eff. background versus eff signal histo ;  ; EEffMethod fEffMethod;  chosen efficiency calculation method ;  ; TString fEffMethodS;  chosen efficiency calculation method (string) ;  ; Double_t fEffRef;  reference efficiency ;  ; Double_t fEffSMax;  used to test optimized signal efficiency ;  ; Double_t fEffSMin;  used to test optimized signal efficiency ;  ; EFitMethodType fFitMethod;  chosen fit method ;  ; TString fFitMethodS;  chosen fit method (string) ;  ; std::vector< EFitParameters > * fFitParams;  vector for series of fit methods ;  ; std::vector< Double_t > * fMeanB;  means of variables (background) ;  ; std::vector< Double_t > * fMeanS;  means of variables (signal) ;  ; Bool_t fNegEffWarning;  flag risen in case of negative efficiency warning ;  ; Int_t fNpar;  number of parameters in fit (default: 2*Nvar) ;  ; TRandom * fRandom;  random generator for MC optimisation method ;  ; std::vector< Int_t > * fRangeSign;  used to match cuts to fit parameters (and vice versa) ;  ; std::vector< Double_t > * fRmsB;  RMSs of variables (background) ;  ; std::vector< Double_t > * fRmsS;  RMSs of variables (signal) ;  ; Double_t fTestSignalEff;  used to test optimized signal efficiency ;  ; Double_t * fTmpCutMax;  temporary maximum requirement ;  ; Double_t * fTmpCutMin;  temporary minimum requirement ;  ; std::vector< TH1 * > * fVarHistB;  reference histograms (background) ;  ; std::vector< TH1 * > * fVarHistB_smooth;  smoothed reference histograms (background) ;  ; std::vector< TH1 * > * fVarHistS;  reference histograms (signal) ;  ; std::vector< TH1 * > * fVarHistS_smooth;  smoothed reference histograms (signal) ;  ; std::vector< PDF * > * fVarPdfB;  reference PDFs (background) ;  ; std::vector< PDF * > * fVarPdfS;  reference PDFs (signal) ;  . Additional Inherited Members;  Public Types inherited from TMVA::MethodBase; enum  EWeightFileType { kROOT =0; , kT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html:31309,optimiz,optimized,31309,doc/master/classTMVA_1_1MethodCuts.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html,3,['optimiz'],['optimized']
Performance,"d evaluated at the data point; . We have to normalise ; to for this to; succeed [5]; (TMultiDimFit::MakeNormalized). We then define a; matrix ; of which the columns ; are given by; . (4). (5). and ; is the component of ; orthogonal; to ; . Hence we obtain; [3],; .    if. (6). We now take as a new model ; . We thus want to; minimize; . (7). where ; is a vector of the; dependent quantity in the sample. Differentiation with respect to; gives, using (6),; . (8). or; . (9). Let be the sum of squares of residuals when taking functions; into account. Then; . (10). Using (9), we see that; .  ;  .  ;  . (11). So for each new function included in the model, we get a; reduction of the sum of squares of residuals of ; ,; where ; is given by (4) and by; (9). Thus, using the Gram-Schmidt orthogonalisation, we; can decide if we want to include this function in the final model,; before the matrix inversion.; . Function Selection Based on Residual; . Supposing that steps of the procedure have been performed, the; problem now is to consider the ; function.; ; The sum of squares of residuals can be written as; . (12). where the relation (9) have been taken into account. The; contribution of the ; function to the reduction of S, is; given by; . (13). Two test are now applied to decide whether this . function is to be included in the final expression, or not.; . Test 1; . Denoting by the subspace spanned by; ; the function ; is; by construction (see (4)) the projection of the function; onto the direction perpendicular to . Now, if the; length of ; (given by ; ); is very small compared to the length of ; this new; function can not contribute much to the reduction of the sum of; squares of residuals. The test consists then in calculating the angle; between the two vectors ; and . (see also figure 1) and requiring that it's; greater then a threshold value which the user must set; (TMultiDimFit::SetMinAngle).; . Figure 1:; (a) Angle between ; and; ; , (b) angle between ; and; . ; Test 2; . L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiDimFit.html:6656,perform,performed,6656,root/html534/TMultiDimFit.html,https://root.cern,https://root.cern/root/html534/TMultiDimFit.html,3,['perform'],['performed']
Performance,"d from the payloadCode; 2241 if (payloadCode == *classesHeader_inner ){; 2242 fPayloads.insert(theHash);; 2243 if (addTemplate) fPayloads.insert(theTemplateHash);; 2244 }; 2245 if (gDebug > 2); 2246 Info(""TCling::RegisterModule"",; 2247 ""Adding a header for %s"", temp.c_str());; 2248 fClassesHeadersMap[theHash].push_back(*classesHeader_inner);; 2249 if (addTemplate) {; 2250 if (fClassesHeadersMap.find(theTemplateHash) == fClassesHeadersMap.end()) {; 2251 fClassesHeadersMap[theTemplateHash].push_back(*classesHeader_inner);; 2252 }; 2253 addTemplate = false;; 2254 }; 2255 }; 2256 }; 2257 }; 2258 ; 2259 clang::Sema &TheSema = fInterpreter->getSema();; 2260 ; 2261 bool ModuleWasSuccessfullyLoaded = false;; 2262 if (hasCxxModule) {; 2263 std::string ModuleName = modulename;; 2264 if (llvm::StringRef(modulename).startswith(""lib"")); 2265 ModuleName = llvm::StringRef(modulename).substr(3).str();; 2266 ; 2267 // In case we are directly loading the library via gSystem->Load() without; 2268 // specifying the relevant include paths we should try loading the; 2269 // modulemap next to the library location.; 2270 clang::Preprocessor &PP = TheSema.getPreprocessor();; 2271 std::string ModuleMapName;; 2272 if (isACLiC); 2273 ModuleMapName = ModuleName + "".modulemap"";; 2274 else; 2275 ModuleMapName = ""module.modulemap"";; 2276 RegisterPrebuiltModulePath(llvm::sys::path::parent_path(dyLibName).str(),; 2277 ModuleMapName);; 2278 ; 2279 // FIXME: We should only complain for modules which we know to exist. For example, we should not complain about; 2280 // modules such as GenVector32 because it needs to fall back to GenVector.; 2281 cling::Interpreter::PushTransactionRAII deserRAII(GetInterpreterImpl());; 2282 ModuleWasSuccessfullyLoaded = LoadModule(ModuleName, *fInterpreter);; 2283 if (!ModuleWasSuccessfullyLoaded) {; 2284 // Only report if we found the module in the modulemap.; 2285 clang::HeaderSearch &headerSearch = PP.getHeaderSearchInfo();; 2286 clang::ModuleMap &moduleMap = headerSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:87436,load,loading,87436,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,['load'],['loading']
Performance,"d if no observables other than the convolution observable are requested for generation, use the specialized convolution generator context which implements a smearing strategy in the convolution observable. If not return the regular accept/reject generator context ; Reimplemented from RooAbsPdf.; Definition at line 864 of file RooFFTConvPdf.cxx. ◆ getMaxVal(). Int_t RooFFTConvPdf::getMaxVal ; (; const RooArgSet & ; vars); const. inlineoverridevirtual . Advertise capability to determine maximum value of function for given set of observables. ; If no direct generator method is provided, this information will assist the accept/reject generator to operate more efficiently as it can skip the initial trial sampling phase to empirically find the function maximum ; Reimplemented from RooAbsReal.; Definition at line 61 of file RooFFTConvPdf.h. ◆ histNameSuffix(). TString RooFFTConvPdf::histNameSuffix ; (; ); const. overrideprotectedvirtual . Suffix for cache histogram (added in addition to suffix for cache name) ; Reimplemented from RooAbsCachedPdf.; Definition at line 448 of file RooFFTConvPdf.cxx. ◆ inputBaseName(). const char * RooFFTConvPdf::inputBaseName ; (; ); const. overrideprotectedvirtual . Return base name component for cache components in this case 'PDF1_CONV_PDF2'. ; Implements RooAbsCachedPdf.; Definition at line 327 of file RooFFTConvPdf.cxx. ◆ IsA(). TClass * RooFFTConvPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsCachedPdf.; Definition at line 124 of file RooFFTConvPdf.h. ◆ maxVal(). double RooFFTConvPdf::maxVal ; (; Int_t ; code); const. inlineoverridevirtual . Return maximum value for set of observables identified by code assigned in getMaxVal. ; Reimplemented from RooAbsReal.; Definition at line 62 of file RooFFTConvPdf.h. ◆ pdfObservable(). RooAbsArg & RooFFTConvPdf::pdfObservable ; (; RooAbsArg & ; histObservable); const. overrideprotectedvirtual . Return p.d.f. ; observable (which can ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:92230,cache,cache,92230,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,2,['cache'],['cache']
Performance,"d in TBuffer3D derived classes, allowing a more abstract shape description (“a sphere of inner radius x, outer radius y”). This enables a viewer, which knows how to draw (tessellate) the shape itself to do so, while providing a generic fallback suitable for all viewers. The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use TBuffer3D.; Complete the mandatory kCore section.; Complete the kShapeSpecific section if applicable.; Complete the kBoundingBox if you can.; Pass this buffer to the viewer using one of the TBuffer3D::AddObject() methods. If the viewer requires more sections to be completed (kRaw/kRawSizes) TBuffer3D::AddObject() will return flags indicating which ones, otherwise it returns kNone. If requested, you must fill the buffer, mark these sections valid, and call TBuffer3D::AddObject again, to complete adding the object. For example, in out TGeo geometry package, in TGeoPainter::PaintShape, we perform the negotiation with viewer:; TVirtualViewer3D * viewer = gPad->GetViewer3D();; if (shape.IsA() != TGeoCompositeShape::Class()) {; // Does viewer prefer local frame positions?; Bool_t localFrame = viewer->PreferLocalFrame();; // Perform first fetch of buffer from the shape and adding; // it to the viewer; const TBuffer3D &buffer = shape.GetBuffer3D(TBuffer3D::kCore |; TBuffer3D::kBoundingBox |; TBuffer3D::kShapeSpecific, localFrame);; Int_t reqSections = viewer->AddObject(buffer, &addDaughters);; // If the viewer requires additional sections fetch from the; // shape (if possible) and add again; if (reqSections != TBuffer3D::kNone) {; shape.GetBuffer3D(reqSections, localFrame);; viewer->AddObject(buffer, &addDaughters);; }; }; The buffer is supplied/filled by the appropriate TShape::GetBuffer3D() and TShape::FillBuffer3D overloads e.g. for a sphere in TGeoSphere.; const TBuffer3D &TGeoSphere::GetBuffer3D(Int_t reqSections,; Bool_t localFrame) const {; // Fills a static 3D buffer and returns",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:408137,perform,perform,408137,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['perform'],['perform']
Performance,"d in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooRealProxyRooAbsMoment::_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooRealProxy_ifInt(F(x))dx ;; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooRealProxy_ixfInt((X-offset)*F(X))dx ;; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsMoment::_meanMean (if calculated for central moment); static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSecondMoment.html:35103,cache,cache,35103,root/html602/RooSecondMoment.html,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html,4,['cache'],['cache']
Performance,"d in ctor); map<Int_t,Bool_t>_bpsIdcs; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TMatrixDSym*_corrMat; TMatrixDSym*_covMat; Double_t_d; RooDataSet&_data; vector<vector<Double_t> >_dataPts; vector<TVectorD>_dataPtsR; RooArgSet_dataVars; Bool_t_debug; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; TVectorD*_dx; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_t_fixedShape; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooNDKeysPdf::BoxInfo_fullBoxInfo; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; vector<Int_t>_idx; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Double_t_maxWeight; vector<Double_t>_mean; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNDKeysPdf.html:38537,cache,cache,38537,root/html526/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html526/RooNDKeysPdf.html,4,['cache'],['cache']
Performance,"d in the URL does not exist, is not accessable; or can not be created the kZombie bit will be set in the TNetFile; object. Use IsZombie() to see if the file is accessable.; If the remote daemon thinks the file is still connected, while you are; sure this is not the case you can force open the file by preceding the; option argument with an ""-"", e.g.: ""-recreate"". Do this only; in cases when you are very sure nobody else is using the file.; To bypass the writelock on a file, to allow the reading of a file; that is being written by another process, explicitely specify the; ""+read"" option (""read"" being the default option).; The netopt argument can be used to specify the size of the tcp window in; bytes (for more info see: http://www.psc.edu/networking/perf_tune.html).; The default and minimum tcp window size is 65535 bytes.; If netopt < -1 then |netopt| is the number of parallel sockets that will; be used to connect to rootd. This option should be used on fat pipes; (i.e. high bandwidth, high latency links). The ideal number of parallel; sockets depends on the bandwidth*delay product. Generally 5-7 is a good; number.; For a description of the option and other arguments see the TFile ctor.; The preferred interface to this constructor is via TFile::Open(). void Create(TSocket* s, Option_t* option, Int_t netopt); Create a NetFile object using an existing connection (socket s).; Provided for use in TXNetFile.; See:; TNetFile::Create(const char *url, Option_t *option, Int_t netopt); for details about the arguments. Bool_t Matches(const char* url); Return kTRUE if 'url' matches the coordinates of this file.; Check the full URL, including port and FQDN. TNetFile(const TNetFile& ). TNetFile& operator=(const TNetFile& ). TNetFile(const char* url, const char* ftitle, Int_t comp, Bool_t ). Int_t GetErrorCode() const; { return fErrorCode; }. const TUrl * GetEndpointUrl() const; { return &fEndpointUrl; }. » Author: Fons Rademakers 14/08/97 » Copyright (C) 1995-2000, Rene Brun and Fon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetFile.html:28286,latency,latency,28286,root/html528/TNetFile.html,https://root.cern,https://root.cern/root/html528/TNetFile.html,3,['latency'],['latency']
Performance,"d instantiate object for a; RooAbsReal implementation with class name 'name', taking all; elements of 'vars' as constructor arguments. The initial value; expression is taken to be 'expression' which can be any one-line; C++ expression in terms of variables that occur in 'vars'. The returned object is an instance of the object you just defined; connected to the variables listed in 'vars'. The name of the; object is 'name', its class name Roo<name>Class. This function is an effective compiled replacement of RooFormulaVar. You can add optional expressions for analytical integrals to be; advertised by your class in the syntax; ""<intObsName>:<CPPAnaIntExpression>;<intObsName,intObsName>:<CPPAnaIntExpression>""; where <intObsName> a name of the observable integrated over and; <CPPAnaIntExpression> is the C++ expression that calculates that; integral. RooAbsPdf* makePdfInstance(const char* name, const char* expression, const RooArgList& vars, const char* intExpression = 0); Write, compile and load code and instantiate object for a; RooAbsPdf implementation with class name 'name', taking all; elements of 'vars' as constructor arguments. The initial value; expression is taken to be 'expression' which can be any one-line; C++ expression in terms of variables that occur in 'vars'. The returned object is an instance of the object you just defined; connected to the variables listed in 'vars'. The name of the; object is 'name', its class name Roo<name>Class. This function is an effective compiled replacement of RooGenericPdf. You can add optional expressions for analytical integrals to be; advertised by your class in the syntax; ""<intObsName>:<CPPAnaIntExpression>;<intObsName,intObsName>:<CPPAnaIntExpression>""; where <intObsName> a name of the observable integrated over and; <CPPAnaIntExpression> is the C++ expression that calculates that; integral. RooAbsPdf* makePdfInstance(const char* className, const char* name, const char* expression, const RooArgList& vars, const char* intEx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooClassFactory.html:11691,load,load,11691,root/html526/RooClassFactory.html,https://root.cern,https://root.cern/root/html526/RooClassFactory.html,7,['load'],['load']
Performance,"d is a pdf). If rangename is specified the integral is performed over the named range, otherwise it is performed over the domain of each integrated observable. If cfg is specified it will be used to configure any numeric integration aspect of the integral. It will not force the integral to be performed numerically, which is decided automatically by RooRealIntegral. ; Reimplemented in RooAbsRealLValue, RooBinSamplingPdf, and RooRealIntegral.; Definition at line 551 of file RooAbsReal.cxx. ◆ createIntegral() [5/6]. RooAbsReal::createIntegral ; (; const RooArgSet & ; iset, . const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ); const. Create an object that represents the integral of the function over one or more observables listed in iset. ; The actual integration calculation is only performed when the returned object is evaluated. The name of the integral object is automatically constructed from the name of the input function, the variables it integrates and the range integrates over.; NoteThe integral over a PDF is usually not normalised (i.e., it is usually not 1 when integrating the PDF over the full range). In fact, this integral is used to compute the normalisation of each PDF. See the rf110 tutorial for details on PDF normalisation.; The following named arguments are accepted . Effect on integral creation . NormSet(const RooArgSet&) Specify normalization set, mostly useful when working with PDFs . NumIntConfig(const RooNumIntConfig&) Use given configuration for any numeric integration, if necessary . Range(const char* name) Integrate only over given range. Multiple ranges may be specified by passing multiple Range() arguments . PyROOT; The RooAbsReal::createIntegral() function is pythonized with the command argument pythonization. The keywords must correspond",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:89608,perform,performed,89608,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['perform'],['performed']
Performance,"d is a pdf). If rangename is specified the integral is performed over the named range, otherwise it is performed over the domain of each integrated observable. If cfg is specified it will be used to configure any numeric integration aspect of the integral. It will not force the integral to be performed numerically, which is decided automatically by RooRealIntegral. ; Reimplemented in RooAbsRealLValue, RooBinSamplingPdf, and RooRealIntegral.; Definition at line 553 of file RooAbsReal.cxx. ◆ createIntegral() [5/6]. RooAbsReal::createIntegral ; (; const RooArgSet & ; iset, . const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ); const. Create an object that represents the integral of the function over one or more observables listed in iset. ; The actual integration calculation is only performed when the returned object is evaluated. The name of the integral object is automatically constructed from the name of the input function, the variables it integrates and the range integrates over.; NoteThe integral over a PDF is usually not normalised (i.e., it is usually not 1 when integrating the PDF over the full range). In fact, this integral is used to compute the normalisation of each PDF. See the rf110 tutorial for details on PDF normalisation.; The following named arguments are accepted . Effect on integral creation . NormSet(const RooArgSet&) Specify normalization set, mostly useful when working with PDFs . NumIntConfig(const RooNumIntConfig&) Use given configuration for any numeric integration, if necessary . Range(const char* name) Integrate only over given range. Multiple ranges may be specified by passing multiple Range() arguments . PyROOT; The RooAbsReal::createIntegral() function is pythonized with the command argument pythonization. The keywords must correspond",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:88340,perform,performed,88340,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['perform'],['performed']
Performance,"d lib demo.so to the executable; If only the option ""+"" had been specified, one can still link the; shared lib to the current executable module with:; gSystem->load(""demo/demo.so"");. The following feature is not yet enabled:; One can restrict the list of classes to be generated by using expressions like:; classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only. void ReadStreamerInfo(); Read the list of StreamerInfo from this file.; The key with name holding the list of TStreamerInfo objects is read.; The corresponding TClass objects are updated.; Note that this function is not called if the static member fgReadInfo is falsse.; (see TFile::SetReadStreamerInfo). void SetReadStreamerInfo(Bool_t readinfo = kTRUE); static function to set fgReadInfo.; If fgReadInfo is true (default) TFile::ReadStreamerInfo is called; when opening the file.; It may be interesting to set fgReadInfo to false to speedup the file; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();. void ShowStreamerInfo(); Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:43281,load,loaded,43281,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,2,['load'],['loaded']
Performance,"d libTMVA is done in TMVAlogon.C, defined in .rootrc; 53 // if you use your private .rootrc, or run from a different directory, please copy the; 54 // corresponding lines from .rootrc; 55 ; 56 // methods to be processed can be given as an argument; use format:; 57 //; 58 // mylinux~> root -l TMVARegression.C\‍(\""myMethod1,myMethod2,myMethod3\""\‍); 59 //; 60 ; 61 //---------------------------------------------------------------; 62 // This loads the library; 63 TMVA::Tools::Instance();; 64 ; 65 ; 66 ; 67 // Default MVA methods to be trained + tested; 68 std::map<std::string,int> Use;; 69 ; 70 // Mutidimensional likelihood and Nearest-Neighbour methods; 71 Use[""PDERS""] = 0;; 72 Use[""PDEFoam""] = 1;; 73 Use[""KNN""] = 1;; 74 //; 75 // Linear Discriminant Analysis; 76 Use[""LD""] = 1;; 77 //; 78 // Function Discriminant analysis; 79 Use[""FDA_GA""] = 0;; 80 Use[""FDA_MC""] = 0;; 81 Use[""FDA_MT""] = 0;; 82 Use[""FDA_GAMT""] = 0;; 83 //; 84 // Neural Network; 85 Use[""MLP""] = 0;; 86 // Deep neural network (with CPU or GPU); 87#ifdef R__HAS_TMVAGPU; 88 Use[""DNN_GPU""] = 1;; 89 Use[""DNN_CPU""] = 0;; 90#else; 91 Use[""DNN_GPU""] = 0;; 92#ifdef R__HAS_TMVACPU; 93 Use[""DNN_CPU""] = 1;; 94#else; 95 Use[""DNN_CPU""] = 0;; 96#endif; 97#endif; 98 //; 99 // Support Vector Machine; 100 Use[""SVM""] = 0;; 101 //; 102 // Boosted Decision Trees; 103 Use[""BDT""] = 0;; 104 Use[""BDTG""] = 1;; 105 // ---------------------------------------------------------------; 106 ; 107 std::cout << std::endl;; 108 std::cout << ""==> Start TMVARegression"" << std::endl;; 109 ; 110 // Select methods (don't look at this code - not of interest); 111 if (myMethodList != """") {; 112 for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) it->second = 0;; 113 ; 114 std::vector<TString> mlist = gTools().SplitString( myMethodList, ',' );; 115 for (UInt_t i=0; i<mlist.size(); i++) {; 116 std::string regMethod(mlist[i].Data());; 117 ; 118 if (Use.find(regMethod) == Use.end()) {; 119 std::cout << ""Method \"""" << reg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C_source.html:2206,load,loads,2206,doc/master/TMVARegression_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C_source.html,1,['load'],['loads']
Performance,"d list for each object. The list of keys is then saved on the file (via WriteKeys) as a single data record. For values of opt see TObject::Write(). The directory header info is rewritten on the directory header record. The linked list of FREE segments is written. The file header is written (bytes 1->fBEGIN). ; Reimplemented from TDirectoryFile.; Reimplemented in TSQLFile, TXMLFile, and TParallelMergingFile.; Definition at line 2436 of file TFile.cxx. ◆ WriteBuffer(). Bool_t TFile::WriteBuffer ; (; const char * ; buf, . Int_t ; len . ). virtual . Write a buffer to the file. ; This is the basic low level write operation. Returns kTRUE in case of failure. ; Reimplemented in TSQLFile, TXMLFile, TDCacheFile, TNetFile, TDavixFile, TXNetFile, and TNetXNGFile.; Definition at line 2476 of file TFile.cxx. ◆ WriteBufferViaCache(). Int_t TFile::WriteBufferViaCache ; (; const char * ; buf, . Int_t ; len . ). protected . Write buffer via cache. ; Returns 0 if cache is not active, 1 in case write via cache was successful, 2 in case write via cache failed. ; Definition at line 2519 of file TFile.cxx. ◆ WriteFree(). void TFile::WriteFree ; (; ). virtual . Write FREE linked list on the file. ; The linked list of FREE segments (fFree) is written as a single data record. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 2543 of file TFile.cxx. ◆ WriteHeader(). void TFile::WriteHeader ; (; ). virtual . Write File Header. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 2615 of file TFile.cxx. ◆ WriteProcessID(). UShort_t TFile::WriteProcessID ; (; TProcessID * ; pid). virtual . Check if the ProcessID pidd is already in the file, if not, add it and return the index number in the local file list. ; Definition at line 3763 of file TFile.cxx. ◆ WriteStreamerInfo(). void TFile::WriteStreamerInfo ; (; ). virtual . Write the list of TStreamerInfo as a single object in this file The class Streamer description for all classes written to this file is saved. ; See class ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:101348,cache,cache,101348,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,3,['cache'],['cache']
Performance,"d name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooAbsRealLValue.h>. Inheritance diagram for RooAbsRealLValue:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooAbsRealLValue() [1/3]. RooAbsRealLValue::RooAbsRealLValue ; (; ). inline . Definition at line 34 of file RooAbsRealLValue.h. ◆ RooAbsRealLValue() [2/3]. RooAbsRealLValue::RooAbsRealLValue ; (; const char * ; name, . const char * ; title, . const char * ; unit = """" . ). Constructor. ; Definition at line 65 of file RooAbsRealLValue.cxx. ◆ RooAbsRealLValue() [3/3]. RooAbsRealLValue::RooAbsRealLValue ; (; const RooAbsRealLValue & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 75 of file RooAbsRealLValue.cxx. Member Function Documentation. ◆ Class(). static ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsRealLValue.html:67710,cache,cache,67710,doc/master/classRooAbsRealLValue.html,https://root.cern,https://root.cern/doc/master/classRooAbsRealLValue.html,1,['cache'],['cache']
Performance,"d name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooBinWidthFunction.h>. Inheritance diagram for RooBinWidthFunction:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooBinWidthFunction() [1/3]. RooBinWidthFunction::RooBinWidthFunction ; (; ). inline . Create an empty instance. ; Definition at line 34 of file RooBinWidthFunction.h. ◆ RooBinWidthFunction() [2/3]. RooBinWidthFunction::RooBinWidthFunction ; (; const char * ; name, . const char * ; title, . const RooHistFunc & ; histFunc, . bool ; divideByBinWidth . ). Create an instance. ; Parameters. nameName to identify the object. ; titleTitle for e.g. plotting. ; histFuncRooHistFunc object whose bin widths should be returned. ; divideByBinWidthIf true, return inverse bin width. . Definition at line ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinWidthFunction.html:60265,cache,cache,60265,doc/master/classRooBinWidthFunction.html,https://root.cern,https://root.cern/doc/master/classRooBinWidthFunction.html,1,['cache'],['cache']
Performance,"d name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooConstVar.h>. Inheritance diagram for RooConstVar:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooConstVar() [1/3]. RooConstVar::RooConstVar ; (; ). inline . Definition at line 26 of file RooConstVar.h. ◆ RooConstVar() [2/3]. RooConstVar::RooConstVar ; (; const char * ; name, . const char * ; title, . double ; value . ). Constructor with value. ; Definition at line 33 of file RooConstVar.cxx. ◆ RooConstVar() [3/3]. RooConstVar::RooConstVar ; (; const RooConstVar & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 45 of file RooConstVar.cxx. Member Function Documentation. ◆ changeVal(). void RooConstVar::changeVal ; (; double ; value). inline . Change the value o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooConstVar.html:59408,cache,cache,59408,doc/master/classRooConstVar.html,https://root.cern,https://root.cern/doc/master/classRooConstVar.html,1,['cache'],['cache']
Performance,"d name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooFit/TestStatistics/RooRealL.h>. Inheritance diagram for RooFit::TestStatistics::RooRealL:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooRealL() [1/2]. RooFit::TestStatistics::RooRealL::RooRealL ; (; const char * ; name, . const char * ; title, . std::shared_ptr< RooAbsL > ; likelihood . ). Definition at line 32 of file RooRealL.cxx. ◆ RooRealL() [2/2]. RooFit::TestStatistics::RooRealL::RooRealL ; (; const RooRealL & ; other, . const char * ; name = nullptr . ). Definition at line 42 of file RooRealL.cxx. Member Function Documentation. ◆ Class(). static TClass * RooFit::TestStatistics::RooRealL::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFit_1_1TestStatistics_1_1RooRealL.html:60081,cache,cache,60081,doc/master/classRooFit_1_1TestStatistics_1_1RooRealL.html,https://root.cern,https://root.cern/doc/master/classRooFit_1_1TestStatistics_1_1RooRealL.html,1,['cache'],['cache']
Performance,"d name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooFormulaVar.h>. Inheritance diagram for RooFormulaVar:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooFormulaVar() [1/4]. RooFormulaVar::RooFormulaVar ; (; ). Definition at line 65 of file RooFormulaVar.cxx. ◆ ~RooFormulaVar(). RooFormulaVar::~RooFormulaVar ; (; ). override . Definition at line 67 of file RooFormulaVar.cxx. ◆ RooFormulaVar() [2/4]. RooFormulaVar::RooFormulaVar ; (; const char * ; name, . const char * ; title, . const char * ; inFormula, . const RooArgList & ; dependents, . bool ; checkVariables = true . ). Constructor with formula expression and list of input variables. ; Parameters. [in]nameName of the formula. ; [in]titleTitle of the formula. ; [in]inFormulaExpression to be eva",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFormulaVar.html:62264,cache,cache,62264,doc/master/classRooFormulaVar.html,https://root.cern,https://root.cern/doc/master/classRooFormulaVar.html,1,['cache'],['cache']
Performance,"d name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooLagrangianMorphFunc.h>. Inheritance diagram for RooLagrangianMorphFunc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ FlagMap. typedef std::map<const std::string, FlagSet> RooLagrangianMorphFunc::FlagMap. Definition at line 83 of file RooLagrangianMorphFunc.h. ◆ FlagSet. typedef std::map<const std::string, int> RooLagrangianMorphFunc::FlagSet. Definition at line 81 of file RooLagrangianMorphFunc.h. ◆ ParamMap. typedef std::map<const std::string, ParamSet> RooLagrangianMorphFunc::ParamMap. Definition at line 82 of file RooLagrangianMorphFunc.h. ◆ ParamSet. typedef std::map<const std::string, double> RooLagrangianMorphFunc::ParamSet. Definition at line 80 of file RooLagrangianMorphFunc.h. Constructor & Destru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLagrangianMorphFunc.html:70384,cache,cache,70384,doc/master/classRooLagrangianMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooLagrangianMorphFunc.html,1,['cache'],['cache']
Performance,"d name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooLinearCombination.h>. Inheritance diagram for RooLinearCombination:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooLinearCombination() [1/3]. RooLinearCombination::RooLinearCombination ; (; ). Definition at line 38 of file RooLinearCombination.cxx. ◆ RooLinearCombination() [2/3]. RooLinearCombination::RooLinearCombination ; (; const char * ; name). Definition at line 44 of file RooLinearCombination.cxx. ◆ RooLinearCombination() [3/3]. RooLinearCombination::RooLinearCombination ; (; const RooLinearCombination & ; other, . const char * ; name . ). Definition at line 51 of file RooLinearCombination.cxx. ◆ ~RooLinearCombination(). RooLinearCombination::~RooLinearCombination ; (; ). override . Defini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLinearCombination.html:59688,cache,cache,59688,doc/master/classRooLinearCombination.html,https://root.cern,https://root.cern/doc/master/classRooLinearCombination.html,1,['cache'],['cache']
Performance,"d name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooMultiBinomial.h>. Inheritance diagram for RooMultiBinomial:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooMultiBinomial() [1/3]. RooMultiBinomial::RooMultiBinomial ; (; ). inline . Definition at line 27 of file RooMultiBinomial.h. ◆ RooMultiBinomial() [2/3]. RooMultiBinomial::RooMultiBinomial ; (; const char * ; name, . const char * ; title, . const RooArgList & ; effFuncList, . const RooArgList & ; catList, . bool ; ignoreNonVisible . ). Construct the efficiency functions from a list of efficiency functions and a list of categories cat with two states (0,1) that indicate if a given event should be counted as rejected or accepted respectively. ; Definition at line 47 of file RooMultiBinomial.cx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMultiBinomial.html:60333,cache,cache,60333,doc/master/classRooMultiBinomial.html,https://root.cern,https://root.cern/doc/master/classRooMultiBinomial.html,1,['cache'],['cache']
Performance,"d name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooNumCdf.h>. Inheritance diagram for RooNumCdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooNumCdf() [1/2]. RooNumCdf::RooNumCdf ; (; const char * ; name, . const char * ; title, . RooAbsPdf & ; _pdf, . RooRealVar & ; _x, . const char * ; bname = ""cache"" . ). Construct a cumulative distribution function from given input p.d.f over observable x. ; using a numeric sampling algorithm. Use binning named 'bname' to control sampling granularity ; Definition at line 44 of file RooNumCdf.cxx. ◆ RooNumCdf() [2/2]. RooNumCdf::RooNumCdf ; (; const RooNumCdf & ; other, . const char * ; name = nullptr . ). inline . Definition at line 20 of file RooNumCdf.h. Member Function Documentation. ◆ Class(). static T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumCdf.html:63576,cache,cache,63576,doc/master/classRooNumCdf.html,https://root.cern,https://root.cern/doc/master/classRooNumCdf.html,1,['cache'],['cache']
Performance,"d name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooSpHarmonic.h>. Inheritance diagram for RooSpHarmonic:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooSpHarmonic() [1/4]. RooSpHarmonic::RooSpHarmonic ; (; ). Definition at line 69 of file RooSpHarmonic.cxx. ◆ RooSpHarmonic() [2/4]. RooSpHarmonic::RooSpHarmonic ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; ctheta, . RooAbsReal & ; phi, . int ; l, . int ; m . ). Definition at line 78 of file RooSpHarmonic.cxx. ◆ RooSpHarmonic() [3/4]. RooSpHarmonic::RooSpHarmonic ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; ctheta, . RooAbsReal & ; phi, . int ; l1, . int ; m1, . int ; l2, . int ; m2 . ). Definition at line 89 of file RooSpHarmonic.cxx. ◆ RooSpHarmonic() [",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSpHarmonic.html:61651,cache,cache,61651,doc/master/classRooSpHarmonic.html,https://root.cern,https://root.cern/doc/master/classRooSpHarmonic.html,1,['cache'],['cache']
Performance,"d name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooSpline.h>. Inheritance diagram for RooSpline:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooSpline() [1/4]. RooSpline::RooSpline ; (; ). default . ◆ RooSpline() [2/4]. RooSpline::RooSpline ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; x, . std::span< const double > ; x0, . std::span< const double > ; y0, . int ; order = 3, . bool ; logx = false, . bool ; logy = false . ). Constructor for creating a spline from raw data. ; Parameters. [in]nameThe name of the spline. ; [in]titleThe title of the spline. ; [in]xThe independent variable. ; [in]x0The array of x values for the spline points. ; [in]y0The array of y values for the spline points. ; [in]orderThe order of the spline (3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSpline.html:61266,cache,cache,61266,doc/master/classRooSpline.html,https://root.cern,https://root.cern/doc/master/classRooSpline.html,1,['cache'],['cache']
Performance,"d name pointer. This will be equal for all objects with the same name. ;  ; bool _localNoInhibitDirty = false;  Cached isConstant status. ;  ; RooWorkspace * _myws = nullptr;  Prevent 'AlwaysDirty' mode for this node. ;  ; const TNamed * _namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooStepFunction.h>. Inheritance diagram for RooStepFunction:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooStepFunction() [1/3]. RooStepFunction::RooStepFunction ; (; ). inline . Definition at line 29 of file RooStepFunction.h. ◆ RooStepFunction() [2/3]. RooStepFunction::RooStepFunction ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; x, . const RooArgList & ; coefList, . const RooArgList & ; limits, . bool ; interpolate = false . ). Constructor. ; Definition at line 44 of file RooStepFunction.cxx. ◆ RooStepFunction() [3/3]. RooStepFunction::RooStepFunction ; (; const RooStepFunction & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 65 of file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStepFunction.html:60021,cache,cache,60021,doc/master/classRooStepFunction.html,https://root.cern,https://root.cern/doc/master/classRooStepFunction.html,1,['cache'],['cache']
Performance,"d object at the beginning of the list and also store option. ;  ; void AddLast (TObject *obj) override;  Add object at the end of the list. ;  ; void AddLast (TObject *obj, Option_t *opt) override;  Add object at the end of the list and also store option. ;  ; void Clear (Option_t *option) override;  Remove all objects from the list. ;  ; void Delete (Option_t *option="""") override;  Delete all TDataMember object files. ;  ; TEnum * Find (DeclId_t id) const;  Return the TEnum corresponding to the Decl 'id' or NULL if it does not exist. ;  ; TObject * FindObject (const char *) const override;  Specialize FindObject to do search for the a enum just by name or create it if its not already in the list. ;  ; TObject * FindObject (const char *name) const override;  Find object using its name. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object using its hash value (returned by its Hash() member). ;  ; virtual TEnum * GetObject (const char *) const;  Return an object from the list of enums if and only if is has already been loaded in the list. ;  ; TClass * IsA () const override;  ; Bool_t IsLoaded () const;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; TObject * Remove (TObject *obj) override;  Remove object from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compatibility only. Use other ctor. ;  ; virtual ~THashList ();  Delete a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnums.html:3289,load,loaded,3289,doc/master/classTListOfEnums.html,https://root.cern,https://root.cern/doc/master/classTListOfEnums.html,1,['load'],['loaded']
Performance,"d object mode (also known as MakeClass mode). ;  ; virtual void SetPacketSize (Int_t size=100);  Set number of entries per packet for parallel root. ;  ; virtual void SetProof (bool on=true, bool refresh=false, bool gettreeheader=false);  Enable/Disable PROOF processing on the current default Proof (gProof). ;  ; void SetWeight (Double_t w=1, Option_t *option="""") override;  Set chain weight. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UseCache (Int_t maxCacheSize=10, Int_t pageSize=0);  Dummy function kept for back compatibility. ;  ;  Public Member Functions inherited from TTree;  TTree ();  Default constructor and I/O constructor. ;  ;  TTree (const char *name, const char *title, Int_t splitlevel=99, TDirectory *dir=(::ROOT::Internal::TDirectoryAtomicAdapter{}));  Normal tree constructor. ;  ;  TTree (const TTree &tt)=delete;  ;  ~TTree () override;  Destructor. ;  ; void AddAllocationCount (UInt_t count);  ; virtual Int_t AddBranchToCache (const char *bname, bool subbranches=false);  Add branch with name bname to the Tree cache. ;  ; virtual Int_t AddBranchToCache (TBranch *branch, bool subbranches=false);  Add branch b to the Tree cache. ;  ; void AddClone (TTree *);  Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ;  ; virtual void AddTotBytes (Int_t tot);  ; virtual void AddZipBytes (Int_t zip);  ; virtual Long64_t AutoSave (Option_t *option="""");  AutoSave tree header every fAutoSave bytes. ;  ; virtual Int_t Branch (const char *folder, Int_t bufsize=32000, Int_t splitlevel=99);  Create one branch for each element in the folder. ;  ; TBranch * Branch (const char *name, char *address, const char *leaflist, Int_t bufsize=32000);  ; template<class T > ; TBranch * Branch (const char *name, const char *classname, T **addobj, Int_t bufsize=32000, Int_t splitlevel=99);  ; template<class T > ; TBranch * Branch (const char *name, const char *classname, T *obj, In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofChain.html:13942,cache,cache,13942,doc/master/classTProofChain.html,https://root.cern,https://root.cern/doc/master/classTProofChain.html,1,['cache'],['cache']
Performance,"d of the dataset.; 1587 /// \return a node of the computation graph for which the range is defined.; 1588 ///; 1589 /// See the other Range overload for a detailed description.; 1590 // clang-format on; 1591 RInterface<RDFDetail::RRange<Proxied>, DS_t> Range(unsigned int end) { return Range(0, end, 1); }; 1592 ; 1593 // clang-format off; 1594 ////////////////////////////////////////////////////////////////////////////; 1595 /// \brief Execute a user-defined function on each entry (*instant action*).; 1596 /// \param[in] f Function, lambda expression, functor class or any other callable object performing user defined calculations.; 1597 /// \param[in] columns Names of the columns/branches in input to the user function.; 1598 ///; 1599 /// The callable `f` is invoked once per entry. This is an *instant action*:; 1600 /// upon invocation, an event loop as well as execution of all scheduled actions; 1601 /// is triggered.; 1602 /// Users are responsible for the thread-safety of this callable when executing; 1603 /// with implicit multi-threading enabled (i.e. ROOT::EnableImplicitMT).; 1604 ///; 1605 /// ### Example usage:; 1606 /// ~~~{.cpp}; 1607 /// myDf.Foreach([](int i){ std::cout << i << std::endl;}, {""myIntColumn""});; 1608 /// ~~~; 1609 // clang-format on; 1610 template <typename F>; 1611 void Foreach(F f, const ColumnNames_t &columns = {}); 1612 {; 1613 using arg_types = typename TTraits::CallableTraits<decltype(f)>::arg_types_nodecay;; 1614 using ret_type = typename TTraits::CallableTraits<decltype(f)>::ret_type;; 1615 ForeachSlot(RDFInternal::AddSlotParameter<ret_type>(f, arg_types()), columns);; 1616 }; 1617 ; 1618 // clang-format off; 1619 ////////////////////////////////////////////////////////////////////////////; 1620 /// \brief Execute a user-defined function requiring a processing slot index on each entry (*instant action*).; 1621 /// \param[in] f Function, lambda expression, functor class or any other callable object performing user defined calculations",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:89919,multi-thread,multi-threading,89919,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['multi-thread'],['multi-threading']
Performance,"d on expression templates to achieve an high level optimization. Physics Vectors: classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:. Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. Unuran: package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions. ; Foam: multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW: library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of (FFTW).; MLP: library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp: optimization library with linear and quadratic programming methods. It is based on the Matrix package.; Statistic classes for computing limits and confidence levels.; More detailed is provided here. Some of these classes are currently provided by libPhysics. Further information is available at the following links:. ROOT Mathematical Library Web page; ROOT Math doxygen class documentation; The Math chapter in the user guide; The Linear Algebra chapter in the user guide; The Physics Vector chapter in the user guide; Inventory of Math functions and algorithms. Last modified: Thu Mar 5 16:03:07 CET 2009 . ; MATH Modules; FFTW; FOAM; FUMILI; GENVECTOR; MATHCORE; MATHMORE; MATRIX; MINUIT; MINUIT2; MLP; PHYSICS; QUADP; SMATRIX; SPLOT; UNURAN. » Last changed: 2009-12-14 18:22 » Last generated: 2009-12-14 18:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/MATH_Index.html:3932,optimiz,optimization,3932,root/html526/MATH_Index.html,https://root.cern,https://root.cern/root/html526/MATH_Index.html,1,['optimiz'],['optimization']
Performance,"d on the client).; Returns 0 in case of success and -1 in case of error. Int_t BuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0); Build specified package on the client. Executes the PROOF-INF/BUILD.sh; script if it exists on the client.; If opt == 0, both the preparation and building phases are run.; If opt == 1, only the preparation phase (asserting and, eventually, downloading; of the package) is done; '*path' contains the full path to the; package to be passed in the next call; If opt == 2, only the building phase is run using *path .; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kBuildPackage; case). Keep in sync in case of changes. Int_t LoadPackage(const char* package, Bool_t notOnClient = kFALSE, TList* loadopts = 0); Load specified package. Executes the PROOF-INF/SETUP.C script; on all active nodes. If notOnClient = true, don't load package; on the client. The default is to load the package also on the client.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t LoadPackageOnClient(const char* package, TList* loadopts = 0); Load specified package in the client. Executes the PROOF-INF/SETUP.C; script on the client. Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kLoadPackage; case). Keep in sync in case of changes.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackage(const char* package); Unload specified package.; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackageOnClient(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:62647,load,load,62647,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,3,['load'],['load']
Performance,"d per output element in order to eliminate shared write access. ; Definition at line 1002 of file Kernels.cuh. ◆ Dropout(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::Dropout ; (; AFloat * ; A, . int ; m, . int ; n, . AFloat ; dropoutProbability, . curandState_t * ; state . ). Definition at line 964 of file Kernels.cuh. ◆ Flatten(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::Flatten ; (; AFloat * ; A, . const AFloat * ; B, . int ; size, . int ; nRows, . int ; nCols . ). Flatten an array of 2D-arrays into a single 2D-array. ; Parameters. [out]AOutput 2D-array saved in column major order. ; [in]BInput array of 2D-arrays. Each element is a matrix to be concatenated. ; [in]sizeNumber of 2D-arrays in the input. ; [in]nRowsNumber of rows in each matrix of the input. ; [in]nColsNumber of columns on each matrix of the input. B is a pointer to size raw TCudaMatrix pointers. Each of those contains elements saved on column major order. However the concatenation is performed row wise. Each thread writes a single output element by locating the appropriate input index. ; Definition at line 1171 of file Kernels.cuh. ◆ FlattenRM(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::FlattenRM ; (; AFloat * ; A, . const AFloat * ; B, . int ; size, . int ; nRows, . int ; nCols . ). Definition at line 1191 of file Kernels.cuh. ◆ Gauss(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::Gauss ; (; AFloat * ; A, . int ; m, . int ; n . ). Definition at line 650 of file Kernels.cuh. ◆ GaussDerivative(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::GaussDerivative ; (; AFloat * ; B, . const AFloat * ; A, . int ; m, . int ; n . ). Definition at line 665 of file Kernels.cuh. ◆ Hadamard(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::Hadamard ; (; AFloat * ; B, . const AFloat * ; A, . int ; m, . int ; n . ). Definition at line 321 of file Kernels.cuh. ◆ IdentityDerivative(). template<typename AFloat ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMVA_1_1DNN_1_1Cuda.html:14850,perform,performed,14850,doc/master/namespaceTMVA_1_1DNN_1_1Cuda.html,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1DNN_1_1Cuda.html,1,['perform'],['performed']
Performance,"d reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const override;  Return the observables to be cached given the normalization set nset. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  Return the parameters on which the cache depends given normalization set nset. ;  ; void calcParams ();  (Re)calculate effective parameters of this p.d.f. ;  ; PdfCacheElem * createCache (const RooArgSet *nset) const override;  Return specialized cache subclass for FFT calculations. ;  ; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; void fillCacheObject (PdfCacheElem &cache) const override;  Fill the contents of the cache the FFT convolution output. ;  ; void fillCacheSlice (FFTCacheElem &cache, const RooArgSet &slicePosition) const;  Fill a slice of cachePdf with the output of the FFT convolution calculation. ;  ; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false) const override;  Create appropriate generator context for this convolution. ;  ; TString histNameSuffix () const override;  Suffix for cache histogram (added in addition to suffix for cache name) ;  ; const char * inputBaseName () const override;  Return base name component for cache components in this case 'PDF1_CONV_PDF2'. ;  ; RooAbsArg & pdfObservable (RooAbsArg &histObservable) const override;  Return p.d.f. ;  ; std::vector< double > scanPdf (RooRealVar &obs, RooAbsPdf &pdf, const RooDataHist &hist, const RooArgSet &slicePos, Int_t &N, Int_t &N2, Int_t &zeroBin, double shift) const;  Scan the values of 'pdf' in observable 'obs' using the bin values stored in 'hist' at slice position 'slicePos' N is filled with the number of bins defined in hist, N2 i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:68920,cache,cache,68920,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,2,['cache'],"['cache', 'cachePdf']"
Performance,"d return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 1105 of file RooNDKeysPdf.cxx. ◆ getWeights(). TMatrixD RooNDKeysPdf::getWeights ; (; const int & ; k); const. Return evaluated weights. ; Definition at line 1291 of file RooNDKeysPdf.cxx. ◆ initialize(). void RooNDKeysPdf::initialize ; (; RooDataSet const & ; data). protected . initialization ; Definition at line 406 of file RooNDKeysPdf.cxx. ◆ IsA(). TClass * RooNDKeysPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 198 of file RooNDKeysPdf.h. ◆ loadDataSet(). void RooNDKeysPdf::loadDataSet ; (; bool ; firstCall, . RooDataSet const & ; data . ). protected . copy the dataset and calculate some useful variables ; Definition at line 476 of file RooNDKeysPdf.cxx. ◆ loadWeightSet(). void RooNDKeysPdf::loadWeightSet ; (; RooDataSet const & ; data). protected . Definition at line 696 of file RooNDKeysPdf.cxx. ◆ loopRange(). void RooNDKeysPdf::loopRange ; (; std::vector< double > & ; x, . std::vector< Int_t > & ; indices . ); const. protected . determine closest points to x, to loop over in evaluate() ; Definition at line 974 of file RooNDKeysPdf.cxx. ◆ mirrorDataSet(). void RooNDKeysPdf::mirrorDataSet ; (; ). protected . determine mirror dataset. ; mirror points are added around the physical boundaries of the dataset Two steps:; For each entry, determine if it should be mirrored (the mirror configuration).; For each mirror configuration, make the mirror points. . Definition at line 607 of file RooNDKeysPdf.cxx. ◆ setOptions(). void RooNDKeysPdf::setOptions ; (; ). protected . set the configuration ; Definition at line 369 of file RooNDKeysPdf.cxx. ◆ sortDataIndices(). void RooNDKeysPdf::sortDataIndices ; (; BoxInfo * ; bi = nullptr). protected . sort entries, as needed for loopRange() ; Definition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNDKeysPdf.html:88258,load,loadWeightSet,88258,doc/master/classRooNDKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRooNDKeysPdf.html,1,['load'],['loadWeightSet']
Performance,"d selector will also call methods named macrofilename_methodname in each of 6 main selector methods if the method macrofilename_methodname exist (Where macrofilename is stripped of its extension).; Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> bool h1analysisProxy_Notify();; Process -> bool h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist it is included before the declaration of the proxy class. This can be used in particular to insure that the include files needed by the macro file are properly loaded.; The default histogram is accessible via the variable named 'htemp'.; If the library of the classes describing the data in the branch is loaded, the skeleton will add the needed include statements and give the ability to access the object stored in the branches.; To draw px using the file `hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx:; double hsimple() {; return px;; }; hsimpleDefinition hsimple.py:1; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; Drawth1 Draw(); A more complete example is available in the tutorials directory: h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C ; Implements TVirtualTreePlayer.; Definition at line 1925 of file TTreePlayer.cxx. ◆ MakeReader(). Int_t TTreePlayer::MakeReader ; (; const char * ; classname, . Option_t * ; option . ). overridevirtual . Generate skeleton selector class for this tree. ; The following files are produced: classname.h and classname.C. If classname is 0, the selector will be called ""nameoftree"". The opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePlayer.html:35786,load,loaded,35786,doc/master/classTTreePlayer.html,https://root.cern,https://root.cern/doc/master/classTTreePlayer.html,1,['load'],['loaded']
Performance,"d selector will also call methods named macrofilename_methodname in each of 6 main selector methods if the method macrofilename_methodname exist (Where macrofilename is stripped of its extension).; Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> bool h1analysisProxy_Notify();; Process -> bool h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist it is included before the declaration of the proxy class. This can be used in particular to insure that the include files needed by the macro file are properly loaded.; The default histogram is accessible via the variable named 'htemp'.; If the library of the classes describing the data in the branch is loaded, the skeleton will add the needed include statements and give the ability to access the object stored in the branches.; To draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: double hsimple() {; return px;; }; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; A more complete example is available in the tutorials directory: h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C ; Definition at line 6768 of file TTree.cxx. ◆ MakeSelector(). Int_t TTree::MakeSelector ; (; const char * ; selector = nullptr, . Option_t * ; option = """" . ). virtual . Generate skeleton selector class for this tree. ; The following files are produced: selector.h and selector.C. If selector is 0, the selector will be called ""nameoftree"". The option can be used to specify the branches that will have a data member.; If option is ""=le",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:178501,load,loaded,178501,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['load'],['loaded']
Performance,"d shared libraries.; 2127/// Regexp is a wildcard expression, see TRegexp::MakeWildcard.; 2128/// This list is of a format suitable for a linker, i.e it may contain; 2129/// -Lpathname and/or -lNameOfLib.; 2130/// Option can be any of:; 2131/// - S: shared libraries loaded at the start of the executable, because; 2132/// they were specified on the link line.; 2133/// - D: shared libraries dynamically loaded after the start of the program.; 2134/// - L: this option is ignored, and available for backward compatibility.; 2135 ; 2136const char *TSystem::GetLibraries(const char *regexp, const char *options,; 2137 Bool_t isRegexp); 2138{; 2139 fListLibs.Clear();; 2140 ; 2141 TString libs;; 2142 TString opt(options);; 2143 Bool_t so2dylib = (opt.First('L') != kNPOS);; 2144 if (so2dylib); 2145 opt.ReplaceAll(""L"", """");; 2146 ; 2147 if (opt.IsNull() || opt.First('D') != kNPOS); 2148 libs += gInterpreter->GetSharedLibs();; 2149 ; 2150 // Cint currently register all libraries that; 2151 // are loaded and have a dictionary in them, this; 2152 // includes all the libraries that are included; 2153 // in the list of (hard) linked libraries.; 2154 ; 2155 TString slinked;; 2156 const char *linked;; 2157 if ((linked = GetLinkedLibraries())) {; 2158 if (fLinkedLibs != LINKEDLIBS) {; 2159 // This is not the default value, we need to keep the custom part.; 2160 TString custom = fLinkedLibs;; 2161 custom.ReplaceAll(LINKEDLIBS,linked);; 2162 if (custom == fLinkedLibs) {; 2163 // no replacement done, let's append linked; 2164 slinked.Append(linked);; 2165 slinked.Append("" "");; 2166 }; 2167 slinked.Append(custom);; 2168 } else {; 2169 slinked.Append(linked);; 2170 }; 2171 } else {; 2172 slinked.Append(fLinkedLibs);; 2173 }; 2174 ; 2175 if (opt.IsNull() || opt.First('S') != kNPOS) {; 2176 // We are done, the statically linked libraries are already included.; 2177 if (libs.Length() == 0) {; 2178 libs = slinked;; 2179 } else {; 2180 // We need to add the missing linked library; 2181 ; 2182 stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:69928,load,loaded,69928,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['loaded']
Performance,"d signal and background trees; ; **/; ; std::unique_ptr<TFile> inputFile{TFile::Open(inputFileName)};; if (!inputFile) {; Error(""TMVA_CNN_Classification"", ""Error opening input file %s - exit"", inputFileName.Data());; return;; }; ; // --- Register the training and test trees; ; auto signalTree = inputFile->Get<TTree>(""sig_tree"");; auto backgroundTree = inputFile->Get<TTree>(""bkg_tree"");; ; if (!signalTree) {; Error(""TMVA_CNN_Classification"", ""Could not find signal tree in file '%s'"", inputFileName.Data());; return;; }; if (!backgroundTree) {; Error(""TMVA_CNN_Classification"", ""Could not find background tree in file '%s'"", inputFileName.Data());; return;; }; ; int nEventsSig = signalTree->GetEntries();; int nEventsBkg = backgroundTree->GetEntries();; ; // global event weights per tree (see below for setting event-wise weights); Double_t signalWeight = 1.0;; Double_t backgroundWeight = 1.0;; ; // You can add an arbitrary number of signal or background trees; loader.AddSignalTree(signalTree, signalWeight);; loader.AddBackgroundTree(backgroundTree, backgroundWeight);; ; /// add event variables (image); /// use new method (from ROOT 6.20 to add a variable array for all image data); loader.AddVariablesArray(""vars"", imgSize);; ; // Set individual event weights (the variables must exist in the original TTree); // for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; // for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; // loader.SetBackgroundWeightExpression( ""weight"" );; ; // Apply additional cuts on the signal and background samples (can be different); TCut mycuts = """"; // for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; TCut mycutb = """"; // for example: TCut mycutb = ""abs(var1)<0.5"";; ; // Tell the factory how to use the training and testing events; //; // If no numbers of events are given, half of the events in the tree are used; // for training, and the other half for testing:; // loader.PrepareTrainingAndTestTree( m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:51780,load,loader,51780,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['load'],['loader']
Performance,d size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase ; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:19091,cache,cache,19091,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,1,['cache'],['cache']
Performance,"d specify no for following parameter (default yes): WebGui.WSOnly: yes; In some applications one may need to force longpoll websocket emulations from the beginning, for instance when clients connected via proxys. Although JSROOT should automatically fallback to longpoll engine, one can configure this directly (default no) WebGui.WSLongpoll: no; Following parameter controls browser max-age caching parameter for files (default 3600) When 0 is specified, browser cache will be disabled WebGui.HttpMaxAge: 3600; Also one can provide extra URL options for, see TCivetweb::Create for list of supported options WebGui.HttpExtraArgs: winsymlinks=no; One also can configure usage of FastCGI server for web windows: WebGui.FastCgiPort: 4000; WebGui.FastCgiThreads: 10; To be able start web browser for such windows, one can provide real URL of the web server which will connect with that FastCGI instance: WebGui.FastCgiServer: https://your_apache_server.com/root_cgi_path; For some custom applications one requires to load JavaScript modules or other files. For such applications one may require to load files from other locations which can be configured with AddServerLocation() method or directly via: WebGui.ServerLocations: location1:/file/path/to/location1;location2:/file/path/to/location2 . Definition at line 430 of file RWebWindowsManager.cxx. ◆ CreateWindow(). std::shared_ptr< RWebWindow > RWebWindowsManager::CreateWindow ; (; ). Creates new window To show window, RWebWindow::Show() have to be called. ; Definition at line 619 of file RWebWindowsManager.cxx. ◆ GenerateKey(). std::string RWebWindowsManager::GenerateKey ; (; int ; keylen = 32). staticprivate . Static method to generate cryptographic key Parameter keylen defines length of cryptographic key in bytes Output string will be hex formatted and includes ""-"" separator after every 4 bytes Example for 16 bytes: ""fca45856-41bee066-ff74cc96-9154d405"". ; Definition at line 250 of file RWebWindowsManager.cxx. ◆ GetLaunchTmout(). float",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html:11912,load,load,11912,doc/master/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html,1,['load'],['load']
Performance,"d the -noIncludePaths and –noIncludePaths to rootcling and genereflex respectively to avoid storing in the dictionaries the include paths passed with the “-I” switch. ROOT will rely on ROOT_INCLUDE_PATH only at runtime to find headers. I/O. Resolve an issue when space is freed in a large ROOT file and a TDirectory is updated and stored the lower (less than 2GB) freed portion of the file [ROOT-8055]. TTree. Do not automatically setup read cache during TTree::Fill(). This fixes [ROOT-8031]. Fast Cloning. Added a cache specifically for the fast option of the TTreeCloner to significantly reduce the run-time when fast-cloning remote files to address [ROOT-5078].; The new cache can be controlled from the TTreeCloner, TTree::CopyEntries or hadd interfaces.; The new cache is enabled by default.; To update the size of the cache or disable it:; From TTreeCloner use: TTreeCloner::SetCacheSize; From TTree::CopyEntries add to the option string ""cachesize=SIZE""; From hadd, use the command line option -cachesize SIZE; SIZE should be given in number bytes and can be expressed in ‘human readable form’ (number followed by size unit like MB, MiB, GB or GiB, etc. or SIZE can be set zero to disable the cache. Release 6.04/18; Published on 2016-06-22.; Core. Fix the validity of TRef after the first ProcessID is full. TTree. Properly handle the last element of arrays in the TTreeFormula functions MinIf and MaxIf ROOT-7258. Bugs and issues fixed. [ROOT-6923] - Memory leak with circular TTree; [ROOT-7258] - MinIf and MaxIf TTreeFormula functions ignore last element; [ROOT-7867] - memprobe script is broken when using CMake; [ROOT-8066] - problems creating dictionaries in pyROOT; [ROOT-8068] - Fix file flags for bin/setxrd.* bin/thisroot.*; [ROOT-8096] - genreflex crash with gcc6 build; [ROOT-8148] - Memory leak in TStorage::ObjectAlloc; [ROOT-8221] - Enum value kKey_Shift not accessible from python with ROOT 6. HEAD of the v6-04-00-patches branch; Changes will be part of the future 6.04/20. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:39366,cache,cache,39366,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['cache'],['cache']
Performance,"d the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* base); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describinb the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. THashTable * GetClassShortTypedefHash(); Return the class' names massaged with TClassEdit::ShortType with kDropStlDefault. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. VoidFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. VoidFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClass.html:26750,load,load,26750,root/html528/TClass.html,https://root.cern,https://root.cern/root/html528/TClass.html,8,['load'],"['load', 'loading']"
Performance,"d to statistically subtract background events using the sPlot formalism. It is however well known that the inverse Hessian matrix does not yield parameter uncertainties with correct coverage in the presence of event weights. Three approaches to the determination of parameter uncertainties are compared in this example:. Using the inverse weighted Hessian matrix [SumW2Error(false)]; Using the expression [SumW2Error(true)] ; \[; V_{ij} = H_{ik}^{-1} C_{kl} H_{lj}^{-1}; \]. where H is the weighted Hessian matrix and C is the Hessian matrix with squared weights; The asymptotically correct approach (for details please see https://arxiv.org/abs/1911.01303) [Asymptotic(true)] ; \[; V_{ij} = H_{ik}^{-1} D_{kl} H_{lj}^{-1}; \]. where H is the weighted Hessian matrix and D is given by ; \[; D_{kl} = \sum_{e=1}^{N} w_e^2 \frac{\partial \log(P)}{\partial \lambda_k}\frac{\partial \log(P)}{\partial; \lambda_l}; \]. with the event weight \(w_e\). The example performs the fit of a second order polynomial in the angle cos(theta) [-1,1] to a weighted data set. The polynomial is given by ; \[; P = \frac{ 1 + c_0 \cdot \cos(\theta) + c_1 \cdot \cos(\theta) \cdot \cos(\theta) }{\mathrm{Norm}}; \]. The two coefficients \( c_0 \) and \( c_1 \) and their uncertainties are to be determined in the fit.; The per-event weight is used to correct for an acceptance effect, two different acceptance models can be studied:; acceptancemodel==1: eff = \( 0.3 + 0.7 \cdot \cos(\theta) \cdot \cos(\theta) \); acceptancemodel==2: eff = \( 1.0 - 0.7 \cdot \cos(\theta) \cdot \cos(\theta) \) The data is generated to be flat before the acceptance effect. The performance of the different approaches to determine parameter uncertainties is compared using the pull distributions from a large number of pseudoexperiments. The pull is defined as \( (\lambda_i -; \lambda_{gen})/\sigma(\lambda_i) \), where \( \lambda_i \) is the fitted parameter and \( \sigma(\lambda_i) \) its uncertainty for pseudoexperiment number i. If",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf611__weightedfits_8C.html:1616,perform,performs,1616,doc/master/rf611__weightedfits_8C.html,https://root.cern,https://root.cern/doc/master/rf611__weightedfits_8C.html,1,['perform'],['performs']
Performance,"d to store a sub-set of the track objects. In the destructor of the class, the method Delete is called for the owning collection to delete correctly its entire track objects. To delete the objects in the container use fTrack->Delete(). To delete the container itself, do ’delete fTracks'.; class TEvent : public TObject {; private:; TList *fTracks; //list of all tracks; TList *fVertex1; //subset of tracks part of vertex1; TList *fVertex2; //subset of tracks part of vertex2; };; TEvent::~TEvent(); {; fTracks->Delete();; delete fTracks;; delete fVertex1;; delete fVertex2;; }; The TIterator class defines the minimum set of member functions that all iterators must support. These include:. Next Returns the next member of the collection or 0 if no more members.; Reset Resets the iterator so that Next returns the first object. 16.4 A Collectable Class; By default, all objects of TObject derived classes can be stored in ROOT containers. However, the TObject class provides some member functions that allow you to tune the behavior of objects in containers. For example, by default two objects are considered equal if their pointers point to the same address. This might be too strict for some classes where equality is already achieved if some or all of the data members are equal. By overriding the following TObject member functions, you can change the behavior of objects in collections:. IsEqual()is used by the FindObject()collection method. By default, IsEqual() compares the two object pointers.; Compare()returns -1, 0 or 1 depending if the object is smaller, equal or larger than the other object. By default, a TObject has not a valid Compare() method.; IsSortable()returns true if the class is sort able (i.e. if it has a valid Compare() method). By default, a TObject is not sort able.; Hash()returns a hash value. It needs to be implemented if an object has to be stored in a collection using a hashing technique, like THashTable, THashList and TMap. By default, Hash() returns the a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:846981,tune,tune,846981,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['tune'],['tune']
Performance,"d vertical distance to the minimum (EDM) is"");; 3597 Printf("" less than 0.001*[tolerance]*UP (see [SET ERRordef])."");; 3598 goto L99;; 3599 }; 3600//______________________________________________________________________________; 3601//; 3602// Command MINIMIZE; 3603//; 3604 if( !strncmp(comd.Data(),""MINI"",4) ) {; 3605 Printf("" ***>MINImize [maxcalls] [tolerance]"");; 3606 Printf("" Causes minimization of the function by the method of Migrad,"");; 3607 Printf("" as does the MIGrad command, but switches to the SIMplex method"");; 3608 Printf("" if Migrad fails to converge. Arguments are as for MIGrad."");; 3609 Printf("" Note that command requires four characters to be unambiguous."");; 3610 goto L99;; 3611 }; 3612//______________________________________________________________________________; 3613//; 3614// Command MINOS; 3615//; 3616 if( !strncmp(comd.Data(),""MIN0"",4) ) {; 3617 Printf("" ***>MINOs [maxcalls] [parno] [parno] ..."");; 3618 Printf("" Causes a Minos error analysis to be performed on the parameters"");; 3619 Printf("" whose numbers [parno] are specified. If none are specified,"");; 3620 Printf("" Minos errors are calculated for all variable parameters."");; 3621 Printf("" Minos errors may be expensive to calculate, but are very"");; 3622 Printf("" reliable since they take account of non-linearities in the"");; 3623 Printf("" problem as well as parameter correlations, and are in general"");; 3624 Printf("" asymmetric."");; 3625 Printf("" The optional argument [maxcalls] specifies the (approximate)"");; 3626 Printf("" maximum number of function calls per parameter requested,"");; 3627 Printf("" after which the calculation will stop for that parameter."");; 3628 goto L99;; 3629 }; 3630//______________________________________________________________________________; 3631//; 3632// Command MNCONTOUR; 3633//; 3634 if( !strncmp(comd.Data(),""MNC"",3) ) {; 3635 Printf("" ***>MNContour <par1> <par2> [npts]"");; 3636 Printf("" Calculates one function contour of FCN with respect to"");; 3637 Printf("" ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:116857,perform,performed,116857,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['perform'],['performed']
Performance,"d with the x dimension varying along z ;  CTTRD2A trapezoid with both x and y dimensions varying along z ;  ►CTTreeA TTree object has a header with a name and a title ;  CTClusterIteratorHelper class to iterate over cluster of baskets ;  CTFriendLockHelper class to prevent infinite recursion in the usage of TTree Friends ;  ►CTTreeCache;  CIOPos;  ►CMissCache;  CEntry;  ►CTTreeCacheUnzipSpecialization of TTreeCache for parallel Unzipping ;  CUnzipState;  ►CTTreeClonerClass implementing or helping the various TTree cloning method ;  CCompareEntry;  CCompareSeek;  CTTreeDrawArgsParserA class that parses all parameters for TTree::Draw() ;  ►CTTreeFormulaUsed to pass a selection expression to the Tree drawing routine ;  CRealInstanceCache;  CTTreeFormulaManagerUsed to coordinate one or more TTreeFormula objects ;  CTTreeFriendLeafIterIterator on all the leaves in a TTree and its friend ;  CTTreeIndexA Tree Index with majorname and minorname ;  CTTreeInput;  ►CTTreePerfStatsTTree I/O performance measurement ;  CBasketInfo;  CTTreePlayerImplement some of the functionality of the class TTree requiring access to extra libraries (Histogram, display, etc) ;  ►CTTreeReaderA simple, robust and fast interface to read values from ROOT colmnar datasets such as TTree, TChain or TNtuple ;  CIterator_tIterate through the entries of a TTree ;  ►CTTreeReaderArrayAn interface for reading collections stored in ROOT columnar datasets ;  CIterator_tRandom access iterator to the elements of a TTreeReaderArray ;  CTTreeReaderValueAn interface for reading values stored in ROOT columnar datasets ;  CTTreeResultClass defining interface to a TTree query result with the same interface as for SQL databases ;  CTTreeRowClass defining interface to a row of a TTree query result ;  CTTreeSQLImplement TTree for a SQL backend ;  CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ;  CTTreeViewA helper class that encapsulates a file and a tree ;  CTTreeViewerA g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:217225,perform,performance,217225,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['perform'],['performance']
Performance,"d() [2/3]. template<> . __device__ double TMVA::DNN::Cuda::AtomicAdd ; (; double * ; address, . double ; val . ). Definition at line 34 of file Kernels.cuh. ◆ AtomicAdd() [3/3]. template<> . __device__ float TMVA::DNN::Cuda::AtomicAdd ; (; float * ; address, . float ; val . ). Definition at line 48 of file Kernels.cuh. ◆ calculateDimension(). __device__ int TMVA::DNN::Cuda::calculateDimension ; (; int ; imgDim, . int ; fltDim, . int ; padding, . int ; stride . ). Calculate the dimension of an output volume, given the sliding parameters and the input shape. ; Parameters. [in]imgDimThe size of the input tensor in a spatial dimension. ; [in]fltDimThe size of the sliding filter in the same dimension. ; [in]paddingNumber of zeroes to pad the input with. ; [in]strideNumber of pixels the kernel is sliding in each iteration. . ReturnsThe output dimension.; Note that no checks are performed to assert validity of the input parameters. We are allowed to assume them valid because those checks have already been performed prior to the invocation of the kernel. ; Definition at line 226 of file Kernels.cuh. ◆ ConstAdd(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::ConstAdd ; (; AFloat * ; A, . AFloat ; beta, . int ; m, . int ; n . ). Definition at line 335 of file Kernels.cuh. ◆ ConstMult(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::ConstMult ; (; AFloat * ; A, . AFloat ; beta, . int ; m, . int ; n . ). Definition at line 349 of file Kernels.cuh. ◆ CrossEntropy(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::CrossEntropy ; (; AFloat * ; result, . const AFloat * ; Y, . const AFloat * ; output, . const AFloat * ; weights, . int ; m, . int ; n . ). Definition at line 800 of file Kernels.cuh. ◆ CrossEntropyGradients(). template<typename AFloat > . __global__ void TMVA::DNN::Cuda::CrossEntropyGradients ; (; AFloat * ; dY, . const AFloat * ; Y, . const AFloat * ; output, . const AFloat * ; weights, . int ; m, . int ; n . ). Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMVA_1_1DNN_1_1Cuda.html:10808,perform,performed,10808,doc/master/namespaceTMVA_1_1DNN_1_1Cuda.html,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1DNN_1_1Cuda.html,1,['perform'],['performed']
Performance,"d)DeepAutoLoadImpl(membertypename.c_str(), visited, true /*normalized*/);; 6253 }; 6254 }; 6255 gInterpreter->DataMemberInfo_Delete(memberinfo);; 6256 }; 6257 gInterpreter->ClassInfo_Delete(classinfo);; 6258 return 1;; 6259}; 6260 ; 6261////////////////////////////////////////////////////////////////////////////////; 6262/// Load library containing the specified class. Returns 0 in case of error; 6263/// and 1 in case if success.; 6264 ; 6265Int_t TCling::AutoLoad(const char *cls, Bool_t knowDictNotLoaded /* = kFALSE */); 6266{; 6267 // Prevent update to IsClassAutoloading between our check and our actions.; 6268 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 6269 ; 6270 // TClass::GetClass explicitly calls gInterpreter->AutoLoad. When called from; 6271 // rootcling (in *_rdict.pcm file generation) it is a no op.; 6272 // FIXME: We should avoid calling autoload when we know we are not supposed; 6273 // to and transform this check into an assert.; 6274 if (!IsClassAutoLoadingEnabled()) {; 6275 // Never load any library from rootcling/genreflex.; 6276 if (gDebug > 2) {; 6277 Info(""TCling::AutoLoad"", ""Explicitly disabled (the class name is %s)"", cls);; 6278 }; 6279 return 0;; 6280 }; 6281 ; 6282 assert(IsClassAutoLoadingEnabled() && ""Calling when AutoLoading is off!"");; 6283 ; 6284 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 6285 ; 6286 if (!knowDictNotLoaded && gClassTable->GetDictNorm(cls)) {; 6287 // The library is already loaded as the class's dictionary is known.; 6288 // Return success.; 6289 // Note: the name (cls) is expected to be normalized as it comes either; 6290 // from a callbacks (that can/should calculate the normalized name from the; 6291 // decl) or from TClass::GetClass (which does also calculate the normalized; 6292 // name).; 6293 return 1;; 6294 }; 6295 ; 6296 if (gDebug > 2) {; 6297 Info(""TCling::AutoLoad"",; 6298 ""Trying to autoload for %s"", cls);; 6299 }; 6300 ; 6301 if (!gROOT || !gInterpreter || gROOT->TestBit(TObject::kInvalidObject)) {; 6302 if (gDebug > ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:243684,load,load,243684,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['load']
Performance,"d* info, TClass* cls); Constructor for TEnum class.; It take the name of the TEnum type, specification if it is global; and interpreter info.; Constant List is owner if enum not on global scope (thus constants not; in TROOT::GetListOfGlobals). ~TEnum(); Destructor. void AddConstant(TEnumConstant* constant); Add a EnumConstant to the list of constants of the Enum Type. Bool_t IsValid(); Return true if this enum object is pointing to a currently; loaded enum. If a enum is unloaded after the TEnum; is created, the TEnum will be set to be invalid. Long_t Property() const; Get property description word. For meaning of bits see EProperty. void Update(TDictionary::DeclId_t id). TEnum * GetEnum(const std::type_info &ti, ESearchAction sa). TEnum * GetEnum(const char* enumName, TEnum::ESearchAction sa = kALoadAndInterpLookup); Static function to retrieve enumerator from the ROOT's typesystem.; It has no side effect, except when the load flag is true. In this case,; the load of the library containing the scope of the enumerator is attempted.; There are two top level code paths: the enumerator is scoped or isn't.; If it is not, a lookup in the list of global enums is performed.; If it is, two lookups are carried out for its scope: one in the list of; classes and one in the list of protoclasses. If a scope with the desired name; is found, the enum is searched. If the scope is not found, and the load flag is; true, the aforementioned two steps are performed again after an autoload attempt; with the name of the scope as key is tried out.; If the interpreter lookup flag is false, the ListOfEnums objects are not treated; as such, but rather as THashList objects. This prevents any flow of information; from the interpreter into the ROOT's typesystem: a snapshot of the typesystem; status is taken. TEnum(); {}. TEnum(const char* name, void* info, TClass* cls). TClass * GetClass() const. const TSeqCollection * GetConstants() const. const TEnumConstant * GetConstant(const char* name) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEnum.html:8653,load,load,8653,root/html602/TEnum.html,https://root.cern,https://root.cern/root/html602/TEnum.html,2,['load'],['load']
Performance,"d-cutflow-reports; 513#### Named filters and cutflow reports; 514An optional string parameter `name` can be passed to the Filter() method to create a **named filter**. Named filters; 515work as usual, but also keep track of how many entries they accept and reject.; 516 ; 517Statistics are retrieved through a call to the Report() method:; 518 ; 519- when Report() is called on the main RDataFrame object, it returns a ROOT::RDF::RResultPtr<RCutFlowReport> relative to all; 520named filters declared up to that point; 521- when called on a specific node (e.g. the result of a Define() or Filter()), it returns a ROOT::RDF::RResultPtr<RCutFlowReport>; 522relative all named filters in the section of the chain between the main RDataFrame and that node (included).; 523 ; 524Stats are stored in the same order as named filters have been added to the graph, and *refer to the latest event-loop*; 525that has been run using the relevant RDataFrame.; 526 ; 527\anchor ranges; 528### Ranges; 529When RDataFrame is not being used in a multi-thread environment (i.e. no call to EnableImplicitMT() was made),; 530Range() transformations are available. These act very much like filters but instead of basing their decision on; 531a filter expression, they rely on `begin`,`end` and `stride` parameters.; 532 ; 533- `begin`: initial entry number considered for this range.; 534- `end`: final entry number (excluded) considered for this range. 0 means that the range goes until the end of the dataset.; 535- `stride`: process one entry of the [begin, end) range every `stride` entries. Must be strictly greater than 0.; 536 ; 537The actual number of entries processed downstream of a Range() node will be `(end - begin)/stride` (or less if less; 538entries than that are available).; 539 ; 540Note that ranges act ""locally"", not based on the global entry count: `Range(10,50)` means ""skip the first 10 entries; 541*that reach this node*, let the next 40 entries pass, then stop processing"". If a range node hangs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:32284,multi-thread,multi-thread,32284,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['multi-thread'],['multi-thread']
Performance,"d-cutflow-reports; 553#### Named filters and cutflow reports; 554An optional string parameter `name` can be passed to the Filter() method to create a **named filter**. Named filters; 555work as usual, but also keep track of how many entries they accept and reject.; 556 ; 557Statistics are retrieved through a call to the Report() method:; 558 ; 559- when Report() is called on the main RDataFrame object, it returns a ROOT::RDF::RResultPtr<RCutFlowReport> relative to all; 560named filters declared up to that point; 561- when called on a specific node (e.g. the result of a Define() or Filter()), it returns a ROOT::RDF::RResultPtr<RCutFlowReport>; 562relative all named filters in the section of the chain between the main RDataFrame and that node (included).; 563 ; 564Stats are stored in the same order as named filters have been added to the graph, and *refer to the latest event-loop*; 565that has been run using the relevant RDataFrame.; 566 ; 567\anchor ranges; 568### Ranges; 569When RDataFrame is not being used in a multi-thread environment (i.e. no call to EnableImplicitMT() was made),; 570Range() transformations are available. These act very much like filters but instead of basing their decision on; 571a filter expression, they rely on `begin`,`end` and `stride` parameters.; 572 ; 573- `begin`: initial entry number considered for this range.; 574- `end`: final entry number (excluded) considered for this range. 0 means that the range goes until the end of the dataset.; 575- `stride`: process one entry of the [begin, end) range every `stride` entries. Must be strictly greater than 0.; 576 ; 577The actual number of entries processed downstream of a Range() node will be `(end - begin)/stride` (or less if less; 578entries than that are available).; 579 ; 580Note that ranges act ""locally"", not based on the global entry count: `Range(10,50)` means ""skip the first 10 entries; 581*that reach this node*, let the next 40 entries pass, then stop processing"". If a range node hangs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:33924,multi-thread,multi-thread,33924,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['multi-thread'],['multi-thread']
Performance,"d. . Define() Create a new column in the dataset. Example usages include adding a column that contains the invariant mass of a particle, or a selection of elements of an array (e.g. only the pts of ""good"" muons). . DefinePerSample() Define a new column that is updated when the input sample changes, e.g. when switching tree being processed in a chain. . DefineSlot() Same as Define(), but the user-defined function must take an extra unsigned int slot as its first parameter. slot will take a different value, 0 to nThreads - 1, for each thread of execution. This is meant as a helper in writing thread-safe Define() transformation when using RDataFrame after ROOT::EnableImplicitMT(). DefineSlot() works just as well with single-thread execution: in that case slot will always be 0. . DefineSlotEntry() Same as DefineSlot(), but the entry number is passed in addition to the slot number. This is meant as a helper in case the expression depends on the entry number. For details about entry numbers in multi-threaded runs, see here. . Filter() Filter rows based on user-defined conditions. . FilterAvailable() Specialized Filter. If the value of the input column is available, keep the entry, otherwise discard it. . FilterMissing() Specialized Filter. If the value of the input column is missing, keep the entry, otherwise discard it. . Range() Filter rows based on entry number (single-thread only). . Redefine() Overwrite the value and/or type of an existing column. See Define() for more information. . RedefineSlot() Overwrite the value and/or type of an existing column. See DefineSlot() for more information. . RedefineSlotEntry() Overwrite the value and/or type of an existing column. See DefineSlotEntry() for more information. . Vary() Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). . Actions; Actions aggregate data into a result. Each one is described in more detail in the reference guide.; In the following, whenever we sa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:4003,multi-thread,multi-threaded,4003,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['multi-thread'],['multi-threaded']
Performance,"d. . Returnsthe minimum value of the selected column wrapped in a RResultPtr.; If T is not specified, RDataFrame will infer it from the data and just-in-time compile the correct template specialization of this method. If the type of the column is inferred, the return type is double, the type of the column otherwise.; This action is lazy: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr. Example usage:; // Deduce column type (this invocation needs jitting internally); auto minVal0 = myDf.Min(""values"");; // Explicit column type; auto minVal1 = myDf.Min<double>(""values"");. Definition at line 2640 of file RInterface.hxx. ◆ operator RNode(). template<typename Proxied , typename DataSource = void> . ROOT::RDF::RInterface< Proxied, DataSource >::operator RNode ; (; ); const. inline . Cast any RDataFrame node to a common type ROOT::RDF::RNode. ; Different RDataFrame methods return different C++ types. All nodes, however, can be cast to this common type at the cost of a small performance penalty. This allows, for example, storing RDataFrame nodes in a vector, or passing them around via (non-template, C++11) helper functions. Example usage: // a function that conditionally adds a Range to a RDataFrame node.; RNode MaybeAddRange(RNode df, bool mustAddRange); {; return mustAddRange ? df.Range(1) : df;; }; // use as :; ROOT::RDataFrame df(10);; auto maybeRanged = MaybeAddRange(df, true);; ROOT::RDF::RInterfaceThe public interface to the RDataFrame federation of classes.Definition RInterface.hxx:113; ROOT::RDF::RInterface::RangeRInterface< RDFDetail::RRange< Proxied >, DS_t > Range(unsigned int begin, unsigned int end, unsigned int stride=1)Creates a node that filters entries based on range: [begin, end).Definition RInterface.hxx:1570; Note that it is not a problem to pass RNode's by value. ; Definition at line 173 of file RInterface.hxx. ◆ operator=() [1/2]. template<typename Proxied , typename DataSource = void> . RInterface & ROOT:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:103515,perform,performance,103515,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['perform'],['performance']
Performance,d. ; Definition at line 131 of file TTree.h. ◆ fFileNumber. Int_t TTree::fFileNumber. protected . ! current file number (if file extensions) ; Definition at line 116 of file TTree.h. ◆ fFlushedBytes. Long64_t TTree::fFlushedBytes. protected . Number of auto-flushed bytes. ; Definition at line 89 of file TTree.h. ◆ fFriendLockStatus. UInt_t TTree::fFriendLockStatus. protected . ! Record which method is locking the friend recursion ; Definition at line 137 of file TTree.h. ◆ fFriends. TList* TTree::fFriends. protected . pointer to list of friend elements ; Definition at line 130 of file TTree.h. ◆ fgBranchStyle. Int_t TTree::fgBranchStyle = 1. staticprotected . Old/New branch style. ; Definition at line 154 of file TTree.h. ◆ fgMaxTreeSize. Long64_t TTree::fgMaxTreeSize = 100000000000LL. staticprotected . Maximum size of a file containing a Tree. ; Definition at line 155 of file TTree.h. ◆ fIMTEnabled. bool TTree::fIMTEnabled. protected . ! true if implicit multi-threading is enabled for this tree ; Definition at line 142 of file TTree.h. ◆ fIMTFlush. bool TTree::fIMTFlush {false}. mutableprivate . ! True if we are doing a multithreaded flush. ; Definition at line 159 of file TTree.h. ◆ fIMTTotBytes. std::atomic<Long64_t> TTree::fIMTTotBytes. mutableprivate . ! Total bytes for the IMT flush baskets ; Definition at line 160 of file TTree.h. ◆ fIMTZipBytes. std::atomic<Long64_t> TTree::fIMTZipBytes. mutableprivate . ! Zip bytes for the IMT flush baskets. ; Definition at line 161 of file TTree.h. ◆ fIndex. TArrayI TTree::fIndex. protected . Index of sorted values. ; Definition at line 128 of file TTree.h. ◆ fIndexValues. TArrayD TTree::fIndexValues. protected . Sorted index values. ; Definition at line 127 of file TTree.h. ◆ fIOFeatures. TIOFeatures TTree::fIOFeatures {0}. protected . IO features to define for newly-written baskets and branches. ; Definition at line 114 of file TTree.h. ◆ fLeaves. TObjArray TTree::fLeaves. protected . Direct pointers to individual branch,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:228276,multi-thread,multi-threading,228276,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['multi-thread'],['multi-threading']
Performance,"d. Bool_t IsTrackAlive() const; Return true if the current particle is alive and will continue to be; transported. Int_t NSecondaries() const. get methods - secondaries. Return the number of secondary particles generated in the current step. void GetSecondary(Int_t isec, Int_t& particleId, TLorentzVector& position, TLorentzVector& momentum); Return the parameters of the secondary track number isec produced; in the current step. Int_t StepProcesses(TArrayI& proc) const; Return the VMC code of the process that has produced the secondary; particles in the current step; Return the array of the VMC code of the processes active in the current; step. Bool_t SecondariesAreOrdered() const; Return the information about the transport order needed by the stack. void Init(). Control methods. Initialize MC. void BuildPhysics(); Initialize MC physics. void ProcessEvent(); Process one event; Deprecated. Bool_t ProcessRun(Int_t nevent); Process one run and return true if run has finished successfully,; return false in other cases (run aborted by user). void InitLego(); Set switches for lego transport. void SetCollectTracks(Bool_t collectTracks); (In)Activate collecting TGeo tracks. Bool_t IsCollectTracks() const; Return the info if collecting tracks is activated. Bool_t IsMT() const; Return the info if multi-threading is supported/activated. { return kFALSE; }. TVirtualMCStack* GetStack() const. Get methods. Return the particle stack. { return fStack; }. TVirtualMCDecayer* GetDecayer() const; Return the external decayer. { return fDecayer; }. TRandom* GetRandom() const; Return the random number generator. { return fRandom; }. TVirtualMagField* GetMagField() const; Return the magnetic field. { return fMagField; }. TVirtualMC & operator=(const TVirtualMC& ). » Last changed: root/vmc:$Name: $:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualMC.html:35414,multi-thread,multi-threading,35414,root/html534/TVirtualMC.html,https://root.cern,https://root.cern/root/html534/TVirtualMC.html,1,['multi-thread'],['multi-threading']
Performance,"d. Bool_t IsTrackAlive() const; Return true if the current particle is alive and will continue to be; transported. Int_t NSecondaries() const. get methods - secondaries. Return the number of secondary particles generated in the current step. void GetSecondary(Int_t isec, Int_t& particleId, TLorentzVector& position, TLorentzVector& momentum); Return the parameters of the secondary track number isec produced; in the current step. Int_t StepProcesses(TArrayI& proc) const; Return the VMC code of the process that has produced the secondary; particles in the current step; Return the array of the VMC code of the processes active in the current; step. Bool_t SecondariesAreOrdered() const; Return the information about the transport order needed by the stack. void Init(). Control methods. Initialize MC. void BuildPhysics(); Initialize MC physics. void ProcessEvent(); Process one event; Deprecated. Bool_t ProcessRun(Int_t nevent); Process one run and return true if run has finished successfully,; return false in other cases (run aborted by user). void InitLego(); Set switches for lego transport. void SetCollectTracks(Bool_t collectTracks); (In)Activate collecting TGeo tracks. Bool_t IsCollectTracks() const; Return the info if collecting tracks is activated. Bool_t IsMT() const; Return the info if multi-threading is supported/activated. { return kFALSE; }. TVirtualMCStack* GetStack() const. Get methods. Return the particle stack. { return fStack; }. TVirtualMCDecayer* GetDecayer() const; Return the external decayer. { return fDecayer; }. TRandom* GetRandom() const; Return the random number generator. { return fRandom; }. TVirtualMagField* GetMagField() const; Return the magnetic field. { return fMagField; }. TVirtualMC & operator=(const TVirtualMC& ). » Last changed: root/vmc:$Name: $:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualMC.html:36403,multi-thread,multi-threading,36403,root/html604/TVirtualMC.html,https://root.cern,https://root.cern/root/html604/TVirtualMC.html,1,['multi-thread'],['multi-threading']
Performance,"d. Bool_t IsTrackAlive() const; Return true if the current particle is alive and will continue to be; transported. Int_t NSecondaries() const. get methods - secondaries. Return the number of secondary particles generated in the current step. void GetSecondary(Int_t isec, Int_t& particleId, TLorentzVector& position, TLorentzVector& momentum); Return the parameters of the secondary track number isec produced; in the current step. Int_t StepProcesses(TArrayI& proc) const; Return the VMC code of the process that has produced the secondary; particles in the current step; Return the array of the VMC code of the processes active in the current; step. Bool_t SecondariesAreOrdered() const; Return the information about the transport order needed by the stack. void Init(). Control methods. Initialize MC. void BuildPhysics(); Initialize MC physics. void ProcessEvent(); Process one event; Deprecated. Bool_t ProcessRun(Int_t nevent); Process one run and return true if run has finished successfully,; return false in other cases (run aborted by user). void InitLego(); Set switches for lego transport. void SetCollectTracks(Bool_t collectTracks); (In)Activate collecting TGeo tracks. Bool_t IsCollectTracks() const; Return the info if collecting tracks is activated. Bool_t IsMT() const; Return the info if multi-threading is supported/activated. { return kFALSE; }. TVirtualMCStack* GetStack() const. Get methods. Return the particle stack. { return fStack; }. TVirtualMCDecayer* GetDecayer() const; Return the external decayer. { return fDecayer; }. TRandom* GetRandom() const; Return the random number generator. { return fRandom; }. TVirtualMagField* GetMagField() const; Return the magnetic field. { return fMagField; }. TVirtualMC & operator=(const TVirtualMC& ). » Last changed: root/vmc:$Name: $:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualMC.html:36403,multi-thread,multi-threading,36403,root/html602/TVirtualMC.html,https://root.cern,https://root.cern/root/html602/TVirtualMC.html,1,['multi-thread'],['multi-threading']
Performance,"d. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsPdf.html:53798,optimiz,optimization,53798,root/html532/RooAbsPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsPdf.html,1,['optimiz'],['optimization']
Performance,"d.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); ; c.SaveAs(""rf210_angularconv.png""); [#1] INFO:Caching -- Changing internal binning of variable 'psi' in FFT 'Mf' from 100 to 930 to improve the precision of the numerical FFT. This can be done manually by setting an additional binning named 'cache'.; [#1] INFO:Eval -- RooRealVar::setRange(psi) new range named 'refrange_fft_Mf' created with bounds [0,3.14159]; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x77ddb60 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7953590 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7b5fca0 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(Mf_over_Mf_Int[psi]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_Mf_over_Mf_Int[psi]_MfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7caf5a0 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi] for nset () with code 1 from preexisting content.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf210__angularconv_8py.html:4624,cache,cache,4624,doc/master/rf210__angularconv_8py.html,https://root.cern,https://root.cern/doc/master/rf210__angularconv_8py.html,1,['cache'],['cache']
Performance,"d.f F2(x). - One finds takes a value 'y' of both c.d.fs and determines the corresponding x; values x(1,2) at which F(1,2)(x)==y. - The value of the interpolated p.d.f fbar(x) is then calculated as; fbar(alpha*x1+(1-alpha)*x2) = f1(x1)*f2(x2) / ( alpha*f2(x2) + (1-alpha)*f1(x1) ) ;. From a technical point of view class RooIntegralMorph is a p.d.f that takes; two input p.d.fs f1(x,p) an f2(x,q) and an interpolation parameter to; make a p.d.f fbar(x,p,q,alpha). The shapes f1 and f2 are always taken; to be end the end-points of the parameter alpha, regardless of what; the those numeric values are. Since the value of fbar(x) cannot be easily calculated for a given value; of x, class RooIntegralMorph is an implementation of RooAbsCachedPdf and; calculates the shape of the interpolated p.d.f. fbar(x) for all values; of x for a given value of alpha,p,q and caches these values in a histogram; (as implemented by RooAbsCachedPdf). The binning granularity of the cache; can be controlled by the binning named ""cache"" on the RooRealVar representing; the observable x. The fbar sampling algorithm is based on a recursive division; mechanism with a built-in precision cutoff: First an initial sampling in; 64 equally spaced bins is made. Then the value of fbar is calculated in; the center of each gap. If the calculated value deviates too much from; the value obtained by linear interpolation from the edge bins, gap; is recursively divided. This strategy makes it possible to define a very; fine cache sampling (e.g. 1000 or 10000) bins without incurring a; corresponding CPU penalty. Note on numeric stability of the algorithm. Since the algorithm relies; on a numeric inversion of cumulative distributions functions, some precision; may be lost at the 'edges' of the same (i.e. at regions in x where the; c.d.f. value is close to zero or one). The general sampling strategy is; to start with 64 equally spaces samples in the range y=(0.01-0.99).; Then the y ranges are pushed outward by reducing y ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooIntegralMorph.html:1628,cache,cache,1628,root/html526/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html526/RooIntegralMorph.html,14,['cache'],['cache']
Performance,"d1, Bool_t mod2) const;  Adjust a passed REFERENCE value 'val', based on screenShift delta. ;  ; Double_t AdjustDelta (Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const;  Adjust a passed screen value and apply modifiers. ;  ; virtual Bool_t Dolly (Int_t delta, Bool_t mod1, Bool_t mod2);  Dolly the camera - 'move camera along eye line, retaining lens focal length'. ;  ; void DrawDebugAids () const;  Draw out some debugging aids for the camera: ;  ; TGLVector3 EyeDirection () const;  Extract the camera eye direction (vector), running from EyePoint() Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; TGLVertex3 EyePoint () const;  Return the camera eye point (vertex) in world space Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; TGLVertex3 FrustumCenter () const;  Find the center of the camera frustum from intersection of planes This method will work even with parallel left/right & top/bottom and infinite eye point of ortho cameras Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; Rgl::EOverlap FrustumOverlap (const TGLBoundingBox &box) const;  Calculate overlap (kInside, kOutside, kPartial) of box with camera frustum Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; const TGLPlane & FrustumPlane (EFrustumPlane plane) const;  ; const TGLMatrix & GetCamBase () const;  ; const TGLMatrix & GetCamTrans () const;  ; Double_t * GetCenterVec ();  ; Bool_t GetExternalCenter ();  ; Double_t GetFarClip () const;  ; Double_t * GetFixDefCenterVec ();  ; Double_t GetNearClip () const;  ; Double_t GetTheta () const;  Get angle between camera up axis. ;  ; Float_t GetVAxisMinAngle ();  ; void IncTimeStamp ();  ; Bool_t IsCacheDirty () const;  ; virtual Bool_t IsOrthographic () const;  ; Bool_t OfInterest (const TGLBoundingBox &box, Bool_t ignoreSize) const;  Calculate if the an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLPerspectiveCamera.html:3661,cache,cache,3661,doc/master/classTGLPerspectiveCamera.html,https://root.cern,https://root.cern/doc/master/classTGLPerspectiveCamera.html,1,['cache'],['cache']
Performance,"d::cout << ""--- Variable Importance Results (Short)"" << std::endl;; 2468 return GetImportance(nbits, importances, varNames);; 2469}; 2470 ; 2471////////////////////////////////////////////////////////////////////////////////; 2472 ; 2473TH1F *TMVA::Factory::EvaluateImportanceRandom(DataLoader *loader, UInt_t nseeds, Types::EMVA theMethod,; 2474 TString methodTitle, const char *theOption); 2475{; 2476 TRandom3 *rangen = new TRandom3(0); // Random Gen.; 2477 ; 2478 uint64_t x = 0;; 2479 uint64_t y = 0;; 2480 ; 2481 // getting number of variables and variable names from loader; 2482 const int nbits = loader->GetDataSetInfo().GetNVariables();; 2483 std::vector<TString> varNames = loader->GetDataSetInfo().GetListOfVariables();; 2484 ; 2485 long int range = pow(2, nbits);; 2486 ; 2487 // vector to save importances; 2488 std::vector<Double_t> importances(nbits);; 2489 for (int i = 0; i < nbits; i++); 2490 importances[i] = 0;; 2491 ; 2492 Double_t SROC, SSROC; // computed ROC value; 2493 for (UInt_t n = 0; n < nseeds; n++) {; 2494 x = rangen->Integer(range);; 2495 ; 2496 std::bitset<32> xbitset(x);; 2497 if (x == 0); 2498 continue; // data loader need at least one variable; 2499 ; 2500 // creating loader for seed; 2501 TMVA::DataLoader *seedloader = new TMVA::DataLoader(xbitset.to_string());; 2502 ; 2503 // adding variables from seed; 2504 for (int index = 0; index < nbits; index++) {; 2505 if (xbitset[index]); 2506 seedloader->AddVariable(varNames[index], 'F');; 2507 }; 2508 ; 2509 // Loading Dataset; 2510 DataLoaderCopy(seedloader, loader);; 2511 ; 2512 // Booking Seed; 2513 BookMethod(seedloader, theMethod, methodTitle, theOption);; 2514 ; 2515 // Train/Test/Evaluation; 2516 TrainAllMethods();; 2517 TestAllMethods();; 2518 EvaluateAllMethods();; 2519 ; 2520 // getting ROC; 2521 SROC = GetROCIntegral(xbitset.to_string(), methodTitle);; 2522 // std::cout << ""Seed: n "" << n << "" x "" << x << "" xbitset:"" << xbitset << "" ROC "" << SROC << std::endl;; 2523 ; 2524 // cleaning info",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:103666,load,loader,103666,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,2,['load'],['loader']
Performance,"d::enable_if_t<""Function can't return a reference"" && !(std::is_reference<InvokeResult_t<F, T...> >::value)>. Definition at line 43 of file Executor.h. Constructor & Destructor Documentation. ◆ Executor() [1/2]. TMVA::Executor::Executor ; (; ). inline . Default constructor of TMVA Executor class if ROOT::EnableImplicitMT has not been called then by default a serial executor will be created A user can create a thread pool and enable multi-thread excution by calling. ; TMVA::Config::Instance()::%EnableMT(int nthreads);; TMVA::Config::Instancestatic Config & Instance()static function: returns TMVA instanceDefinition Config.cxx:98; int; For releasing the thread pool used by TMVA one can do it by calling TMVA::Config::Instance()::%DisableMT();. Definition at line 59 of file Executor.h. ◆ Executor() [2/2]. TMVA::Executor::Executor ; (; int ; nthreads). inlineexplicit . Constructor of TMVA Executor class Explicit specify the number of threads. ; In this case if nthreads is > 1 a multi-threaded executor will be created and TMVA will run in MT. If nthreads = 1 instead TMVA will run in sequential mode If nthreads = 0 TMVA will use the default thread pool size ; Definition at line 80 of file Executor.h. Member Function Documentation. ◆ Foreach() [1/3]. template<class Function , class INTEGER > . void TMVA::Executor::Foreach ; (; Function ; func, . ROOT::TSeq< INTEGER > ; args, . unsigned ; nChunks = 0 . ). inline . Definition at line 128 of file Executor.h. ◆ Foreach() [2/3]. template<class Function , class T > . void TMVA::Executor::Foreach ; (; Function ; func, . std::vector< T > & ; args, . unsigned ; nChunks = 0 . ). inline . Definition at line 122 of file Executor.h. ◆ Foreach() [3/3]. template<class Function > . void TMVA::Executor::Foreach ; (; Function ; func, . unsigned int ; nTimes, . unsigned ; nChunks = 0 . ). inline . wrap TExecutor::Foreach ; Definition at line 117 of file Executor.h. ◆ GetMultiThreadExecutor(). ROOT::TThreadExecutor * TMVA::Executor::GetMultiThre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Executor.html:3902,multi-thread,multi-threaded,3902,doc/master/classTMVA_1_1Executor.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Executor.html,1,['multi-thread'],['multi-threaded']
Performance,"d::endl; // computations run here, upon first access to the result; The filter string (which must contain a valid C++ expression) is applied to the specified columns for each event; the name and types of the columns are inferred automatically. The string expression is required to return a bool which signals whether the event passes the filter (true) or not (false).; You can think of your data as ""flowing"" through the chain of calls, being transformed, filtered and finally used to perform actions. Multiple Filter() calls can be chained one after another.; Using string filters is nice for simple things, but they are limited to specifying the equivalent of a single return statement or the body of a lambda, so it's cumbersome to use strings with more complex filters. They also add a small runtime overhead, as ROOT needs to just-in-time compile the string into C++ code. When more freedom is required or runtime performance is very important, a C++ callable can be specified instead (a lambda in the following snippet, but it can be any kind of function or even a functor class), together with a list of column names. This snippet is analogous to the one above: RDataFrame d(""myTree"", ""file.root"");; auto metCut = [](double x) { return x > 4.; }; // a C++11 lambda function checking ""x > 4""; auto c = d.Filter(metCut, {""MET""}).Count();; std::cout << *c << std::endl;; ROOT::RDF::RInterface< RDFDetail::RLoopManager >::CountRResultPtr< ULong64_t > Count()Return the number of entries processed (lazy action).Definition RInterface.hxx:1560; xDouble_t x[n]Definition legend1.C:17; An example of a more complex filter expressed as a string containing C++ code is shown below; RDataFrame d(""myTree"", ""file.root"");; auto df = d.Define(""p"", ""std::array<double, 4> p{px, py, pz}; return p;""); .Filter(""double p2 = 0.0; for (auto&& x : p) p2 += x*x; return sqrt(p2) < 10.0;"");; The code snippet above defines a column p that is a fixed-size array using the component column names and then filters on its",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:18547,perform,performance,18547,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['perform'],['performance']
Performance,"d::endl; // computations run here, upon first access to the result; The filter string (which must contain a valid C++ expression) is applied to the specified columns for each event; the name and types of the columns are inferred automatically. The string expression is required to return a bool which signals whether the event passes the filter (true) or not (false).; You can think of your data as ""flowing"" through the chain of calls, being transformed, filtered and finally used to perform actions. Multiple Filter() calls can be chained one after another.; Using string filters is nice for simple things, but they are limited to specifying the equivalent of a single return statement or the body of a lambda, so it's cumbersome to use strings with more complex filters. They also add a small runtime overhead, as ROOT needs to just-in-time compile the string into C++ code. When more freedom is required or runtime performance is very important, a C++ callable can be specified instead (a lambda in the following snippet, but it can be any kind of function or even a functor class), together with a list of column names. This snippet is analogous to the one above: RDataFrame d(""myTree"", ""file.root"");; auto metCut = [](double x) { return x > 4.; }; // a C++11 lambda function checking ""x > 4""; auto c = d.Filter(metCut, {""MET""}).Count();; std::cout << *c << std::endl;; ROOT::RDF::RInterface< RDFDetail::RLoopManager >::CountRResultPtr< ULong64_t > Count()Return the number of entries processed (lazy action).Definition RInterface.hxx:1729; xDouble_t x[n]Definition legend1.C:17; An example of a more complex filter expressed as a string containing C++ code is shown below; RDataFrame d(""myTree"", ""file.root"");; auto df = d.Define(""p"", ""std::array<double, 4> p{px, py, pz}; return p;""); .Filter(""double p2 = 0.0; for (auto&& x : p) p2 += x*x; return sqrt(p2) < 10.0;"");; The code snippet above defines a column p that is a fixed-size array using the component column names and then filters on its",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:18936,perform,performance,18936,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['perform'],['performance']
Performance,d::fBIsTransferred; Int_t*TFileCacheRead::fBLen; Int_tTFileCacheRead::fBNb; Int_tTFileCacheRead::fBNseek; Int_tTFileCacheRead::fBNtot; Long64_t*TFileCacheRead::fBPos; Long64_t*TFileCacheRead::fBSeek; Int_t*TFileCacheRead::fBSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cach,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCache.html:16715,cache,cache,16715,root/html530/TTreeCache.html,https://root.cern,https://root.cern/root/html530/TTreeCache.html,2,['cache'],['cache']
Performance,d::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:18693,cache,cache,18693,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,1,['cache'],['cache']
Performance,"d::fTitleobject title. private:. Double_t_2pi= M_PI*2; Int_t_BandWidthType; Int_t_MirrorAtBoundary; Int_t_debug; Double_t_hix; Double_t_hiy; Double_t*_hx; Double_t*_hy; Double_t_lox; Double_t_loy; Double_t_ncoefficient of the kernel estimation sum; Double_t_n16pow(_nEvents, -1/6); Int_t_nEvents; Double_t_norm; Double_t_sqrt2pi; Int_t_verbosedebug; Int_t_vverbosedebug; Double_t_widthScaleFactorallow manipulation of the bandwidth by a scale factor; Double_t*_x; Double_t_xMeanthe (x,y) mean and sigma are properties of the data, not of the PDF; Double_t_xSigma; Double_t_xoffset; Double_t*_y; Double_t_yMean; Double_t_ySigma; Double_t_yoffset. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Roo2DKeysPdf(const char* name, const char* title, RooAbsReal& xx, RooAbsReal& yy, RooDataSet& data, TString options = ""a"", Double_t widthScaleFactor = 1.0). Roo2DKeysPdf(const Roo2DKeysPdf& other, const char* name = 0). ~Roo2DKeysPdf(). Int_t loadDataSet(RooDataSet& data, TString options). void setOptions(TString options). void getOptions(void). Int_t calculateBandWidth(Int_t kernel = -999). Double_t evaluate() const; use the cacheing intrinsic in RFC to bypass the grid and remove; the grid and extrapolation approximation in the kernel estimation method; implementation - cheers Wouter :). Double_t evaluateFull(Double_t thisX, Double_t thisY) const. Double_t highBoundaryCorrection(Double_t thisVar, Double_t thisH, Double_t high, Double_t tVar) const. Double_t lowBoundaryCorrection(Double_t thisVar, Double_t thisH, Double_t low, Double_t tVar) const. Double_t g(Double_t var1, Double_t* _var1, Double_t sigma1, Double_t var2, Double_t* _var2, Double_t sigma2) const. Int_t getBandWidthType() const. Double_t getMean(const char* axis) const. Double_t getSigma(const char* axis) const. void writeToFile(char* outputFile, const char* name) const. void writeHistToFile(char* outputFile, const char* histName) const. void writeNTupleToFile(char* outputFile, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/Roo2DKeysPdf.html:41205,load,loadDataSet,41205,root/html526/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html526/Roo2DKeysPdf.html,5,['load'],['loadDataSet']
Performance,"d::move(innerIntegral));; 640 }; 641 ; 642 // Remove already integrated observables from to-do list; 643 iset.remove(innerSet) ;; 644 ; 645 // Send info message on recursion if needed; 646 if (integrand == this && !iset.empty()) {; 647 coutI(Integration) << GetName() << "" : multidimensional integration over observables with parameterized ranges in terms of other integrated observables detected, using recursive integration strategy to construct final integral"" << std::endl ;; 648 }; 649 ; 650 // Prepare for recursion, next integral should integrate last integrand; 651 integrand = integral.get();; 652 ; 653 ; 654 // Only need normalization set in innermost integration; 655 nset = nullptr;; 656 }; 657 ; 658 if (error) {; 659 coutE(Integration) << GetName() << "" : ERROR while defining recursive integral over observables with parameterized integration ranges, please check that integration rangs specify uniquely defined integral "" << std::endl;; 660 return nullptr;; 661 }; 662 ; 663 ; 664 // After-burner: apply interpolating cache on (numeric) integral if requested by user; 665 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 666 if (cacheParamsStr && strlen(cacheParamsStr)) {; 667 ; 668 std::unique_ptr<RooArgSet> intParams{integral->getVariables()};; 669 ; 670 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 671 ; 672 if (!cacheParams.empty()) {; 673 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 674 << ""-dim value cache for integral over "" << iset2 << "" as a function of "" << cacheParams << "" in range "" << (rangeName?rangeName:""<none>"") << std::endl ;; 675 std::string name = Form(""%s_CACHE_[%s]"",integral->GetName(),cacheParams.contentsString().c_str()) ;; 676 auto cachedIntegral = std::make_unique<RooCachedReal>(name.c_str(),name.c_str(),*integral,cacheParams);; 677 cachedIntegral->setInterpolationOrder(2) ;; 678 cachedIntegral->addOwnedComponents(std::mov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:25384,cache,cache,25384,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,7,['cache'],"['cache', 'cacheParams', 'cacheParamsStr']"
Performance,"d::string_view storage,; 159 const RNTupleReadOptions &options = RNTupleReadOptions());; 160 static std::unique_ptr<RNTupleReader> Open(std::unique_ptr<RNTupleModel> model, const RNTuple &ntuple,; 161 const RNTupleReadOptions &options = RNTupleReadOptions());; 162 /// Open RNTuples as one virtual, horizontally combined ntuple. The underlying RNTuples must; 163 /// have an identical number of entries. Fields in the combined RNTuple are named with the ntuple name; 164 /// as a prefix, e.g. myNTuple1.px and myNTuple2.pt (see tutorial ntpl006_friends); 165 static std::unique_ptr<RNTupleReader>; 166 OpenFriends(std::span<RNTupleOpenSpec> ntuples, const RNTupleReadOptions &options = RNTupleReadOptions());; 167 std::unique_ptr<RNTupleReader> Clone(); 168 {; 169 auto options = RNTupleReadOptions{};; 170 options.SetMetricsEnabled(fMetrics.IsEnabled());; 171 return std::unique_ptr<RNTupleReader>(new RNTupleReader(fSource->Clone(), options));; 172 }; 173 ~RNTupleReader();; 174 ; 175 NTupleSize_t GetNEntries() const { return fSource->GetNEntries(); }; 176 const RNTupleModel &GetModel();; 177 ; 178 /// Returns a cached copy of the page source descriptor. The returned pointer remains valid until the next call; 179 /// to LoadEntry or to any of the views returned from the reader.; 180 const RNTupleDescriptor &GetDescriptor();; 181 ; 182 /// Prints a detailed summary of the ntuple, including a list of fields.; 183 ///; 184 /// **Example: print summary information to stdout**; 185 /// ~~~ {.cpp}; 186 /// #include <ROOT/RNTupleReader.hxx>; 187 /// using ROOT::Experimental::ENTupleInfo;; 188 /// using ROOT::Experimental::RNTupleReader;; 189 ///; 190 /// #include <iostream>; 191 ///; 192 /// auto ntuple = RNTupleReader::Open(""myNTuple"", ""some/file.root"");; 193 /// ntuple->PrintInfo();; 194 /// // or, equivalently:; 195 /// ntuple->PrintInfo(ENTupleInfo::kSummary, std::cout);; 196 /// ~~~; 197 /// **Example: print detailed column storage data to stderr**; 198 /// ~~~ {.cpp}; 199 /// #inc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleReader_8hxx_source.html:7762,cache,cached,7762,doc/master/RNTupleReader_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleReader_8hxx_source.html,1,['cache'],['cached']
Performance,"d::vector< Event * > * ; events, . Types::ETreeType ; type, . Bool_t ; deleteEvents = true . ). Sets the event collection (by DataSetFactory) ; Definition at line 250 of file DataSet.cxx. ◆ SetVerbose(). void TMVA::DataSet::SetVerbose ; (; Bool_t ; ). inline . Definition at line 112 of file DataSet.h. ◆ Streamer(). virtual void TMVA::DataSet::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TMVA::DataSet::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 175 of file DataSet.h. ◆ TreeIndex(). UInt_t TMVA::DataSet::TreeIndex ; (; Types::ETreeType ; type); const. inline . Definition at line 181 of file DataSet.h. Member Data Documentation. ◆ fBlockBelongToTraining. std::vector<Char_t> TMVA::DataSet::fBlockBelongToTraining. private . when dividing the dataset to blocks, sets whether the certain block is in the Training set or else in the validation set boolean are stored, taken std::vector<Char_t> for performance reasons (instead of std::vector<Bool_t>) ; Definition at line 165 of file DataSet.h. ◆ fClassEvents. std::vector< std::vector<Long64_t> > TMVA::DataSet::fClassEvents. private . number of events of class 0,1,2,... in training[0] and testing[1] (+validation, trainingoriginal) ; Definition at line 158 of file DataSet.h. ◆ fCurrentEventIdx. Long64_t TMVA::DataSet::fCurrentEventIdx. mutableprivate . Definition at line 146 of file DataSet.h. ◆ fCurrentTreeIdx. UInt_t TMVA::DataSet::fCurrentTreeIdx. mutableprivate . Definition at line 145 of file DataSet.h. ◆ fdsi. const DataSetInfo* TMVA::DataSet::fdsi. private . -> datasetinfo that created this dataset ; Definition at line 139 of file DataSet.h. ◆ fEventCollection. std::vector< std::vector<Event*> > TMVA::DataSet::fEventCollection. private . list of events for training/testing/... ; Definition at line 141 of file DataSet.h. ◆ fHasNegativeEventWeights. Bool_t TMVA::DataSet::fHasNegativeEvent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataSet.html:25280,perform,performance,25280,doc/master/classTMVA_1_1DataSet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataSet.html,1,['perform'],['performance']
Performance,"d; fgAddDirectoryTDirectoryprotectedstatic; fGDirectoriesTDirectoryprotected; fgDirLevelTROOTprivatestatic; fgDtorOnlyTObjectprivatestatic; fGeometriesTROOTprotected; fGitBranchTROOTprotected; fGitCommitTROOTprotected; fGitDateTROOTprotected; fGlobalFunctionsTROOTprotected; fGlobalsTROOTprotected; fgObjectStatTObjectprivatestatic; fgRootInitTROOTprivatestatic; FillBuffer(char *&buffer)TNamedvirtual; FillFullPath(TString &buf) constTDirectoryprotected; FindKey(const char *) constTDirectoryinlinevirtual; FindKeyAny(const char *) constTDirectoryinlinevirtual; FindObject(const char *name) const overrideTROOTvirtual; FindObject(const TObject *obj) const overrideTROOTvirtual; FindObjectAny(const char *name) const overrideTROOTvirtual; FindObjectAnyFile(const char *name) const overrideTROOTvirtual; FindObjectClassName(const char *name) constTROOT; FindObjectPathName(const TObject *obj) constTROOT; FindSpecialObject(const char *name, void *&where)TROOT; FindSTLClass(const char *name, Bool_t load, Bool_t silent=kFALSE) constTROOT; fInterpreterTROOTprotected; fInterruptTROOTprotected; fIsWebDisplayTROOTprotected; fIsWebDisplayBatchTROOTprotected; fLineIsProcessingTROOTprivate; fListTDirectoryprotected; fMappedFilesTROOTprotected; fMessageHandlersTROOTprotected; fMotherTDirectoryprotected; fMustCleanTROOTprotected; fNameTNamedprotected; ForceStyle(Bool_t force=kTRUE)TROOTinline; fPathBufferTDirectorymutableprotected; fPluginManagerTROOTprotected; fPrimitiveTROOTprotected; fProofsTROOTprotected; FromPopUp() constTROOTinline; fRootFolderTROOTprotected; fSecContextsTROOTprotected; fSelectPadTROOTprotected; fSocketsTROOTprotected; fSpecialsTROOTprotected; fSpinLockTDirectorymutableprotected; fStreamerInfoTROOTprotected; fStylesTROOTprotected; fTasksTROOTprotected; fTimerTROOTprotected; fTitleTNamedprotected; fTypesTROOTprotected; fUniqueIDTObjectprivate; fUUIDTDirectoryprotected; fUUIDsTROOTprotected; fVersionTROOTprotected; fVersionCodeTROOTprotected; fVersionDateTROOTprotected; f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTROOT-members.html:4823,load,load,4823,doc/master/classTROOT-members.html,https://root.cern,https://root.cern/doc/master/classTROOT-members.html,1,['load'],['load']
Performance,d; kSetBranchStatus; };; enum ESetBranchAddressStatus { kMissingBranch; kInternalError; kMissingCompiledCollectionProxy; kMismatch; kClassMismatch; kMatch; kMatchConversion; kMatchConversionCollection; kMakeClass; kVoidPtr; kNoCheck; };; enum { kForceRead; kCircular; kSplitCollectionOfPointers; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*fAliasesList of aliases for expressions based on the tree branches.; Long64_tfAutoFlushAutoflush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced; Long64_tfAutoSaveAutosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced; TBranchRef*fBranchRefBranch supporting the TRefTable (if any); TObjArrayfBranchesList of Branches; Bool_tfCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tfCacheSize! Maximum size of file buffers; Bool_tfCacheUserSet! true if the cache setting was explicitly given by user; Long64_tfChainOffset! Offset of 1st entry of this Tree in a TChain; TList*fClones! List of cloned trees which share our addresses; Long64_t*fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tfDebug! Debug level; Long64_tfDebugMax! Last entry number to debug; Long64_tfDebugMin! First entry number to debug; Int_tfDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*fDirectory! Pointer to directory holding this tree; Long64_tfEntriesNumber of entries; TEntryList*fEntryList! Pointer to event selection list (if one); Long64_tfEstimateNumber of entries to estimate histogram limits; TEventList*fEventList! Pointer to event selection list (if one); Int_tfFileNumber! current file number (if f,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:32042,cache,cache,32042,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,2,['cache'],['cache']
Performance,d; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooCatType*_defCat; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooRealProxy_inputVar; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooThresholdCategory.html:21923,cache,cache,21923,root/html602/RooThresholdCategory.html,https://root.cern,https://root.cern/root/html602/RooThresholdCategory.html,6,['cache'],"['cache', 'caches']"
Performance,"d; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFileCacheWrite.html:6956,cache,cache,6956,root/html602/TFileCacheWrite.html,https://root.cern,https://root.cern/root/html602/TFileCacheWrite.html,2,['cache'],['cache']
Performance,"dBDT( void ); destructor; Note: fEventSample and ValidationSample are already deleted at the end of TRAIN; When they are not used anymore; for (UInt_t i=0; i<fEventSample.size(); i++) delete fEventSample[i];; for (UInt_t i=0; i<fValidationSample.size(); i++) delete fValidationSample[i];. void InitEventSample( void ); initialize the event sample (i.e. reset the boost-weights... etc). void PreProcessNegativeEventWeights(); o.k. you know there are events with negative event weights. This routine will remove; them by pairing them with the closest event(s) of the same event class with positive; weights; A first attempt is ""brute force"", I dont' try to be clever using search trees etc,; just quick and dirty to see if the result is any good. std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameters); set the tuning parameters accoding to the argument. void Train(); BDT training. Double_t GetGradBoostMVA(const TMVA::Event* e, UInt_t nTrees); returns MVA value: -1 for background, 1 for signal. void UpdateTargets(vector<const TMVA::Event*>& , UInt_t cls = 0); Calculate residua for all events;. void UpdateTargetsRegression(vector<const TMVA::Event*>& , Bool_t first = kFALSE); Calculate current residuals for all events and update targets for next iteration. Double_t GetWeightedQuantile(vector<pair<Double_t,Double_t> > vec, const Double_t quantile, const Double_t SumOfWeights = 0.); calculates the quantile of the distribution of the first pair entries weighted with the values in the second pair entries. Double_t GradBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt, UInt_t cls = 0); Calculate the desired response value for each region. Double_t GradBoostRegression(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); Implementation of M_TreeBoost using a Huber loss functi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodBDT.html:31317,tune,tuneParameters,31317,root/html602/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodBDT.html,2,['tune'],['tuneParameters']
Performance,"dBDT( void ); destructor; Note: fEventSample and ValidationSample are already deleted at the end of TRAIN; When they are not used anymore; for (UInt_t i=0; i<fEventSample.size(); i++) delete fEventSample[i];; for (UInt_t i=0; i<fValidationSample.size(); i++) delete fValidationSample[i];. void InitEventSample( void ); initialize the event sample (i.e. reset the boost-weights... etc). void PreProcessNegativeEventWeights(); o.k. you know there are events with negative event weights. This routine will remove; them by pairing them with the closest event(s) of the same event class with positive; weights; A first attempt is ""brute force"", I dont' try to be clever using search trees etc,; just quick and dirty to see if the result is any good. std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameters); set the tuning parameters accoding to the argument. void Train(); BDT training. Double_t GetGradBoostMVA(const TMVA::Event* e, UInt_t nTrees); returns MVA value: -1 for background, 1 for signal. void UpdateTargets(vector<const TMVA::Event*>& , UInt_t cls = 0); Calculate residua for all events;. void UpdateTargetsRegression(vector<const TMVA::Event*>& , Bool_t first = kFALSE); Calculate current residuals for all events and update targets for next iteration. Double_t GetWeightedQuantile(vector<std::pair<Double_t,Double_t> > vec, const Double_t quantile, const Double_t SumOfWeights = 0.0); calculates the quantile of the distribution of the first pair entries weighted with the values in the second pair entries. Double_t GradBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt, UInt_t cls = 0); Calculate the desired response value for each region. Double_t GradBoostRegression(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); Implementation of M_TreeBoost using a Huber loss ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodBDT.html:30199,tune,tuneParameters,30199,root/html534/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodBDT.html,1,['tune'],['tuneParameters']
Performance,"dBufferPrefetch ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Used to read a chunk from a block previously fetched. ; It will call FillBuffer even if the cache lookup succeeds, because it will try to prefetch the next block as soon as we start reading from the current block. ; Definition at line 1986 of file TTreeCache.cxx. ◆ ResetCache(). void TTreeCache::ResetCache ; (; ). virtual . This will simply clear the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2040 of file TTreeCache.cxx. ◆ ResetMissCache(). void TTreeCache::ResetMissCache ; (; ). Reset all the miss cache training. ; The contents of the miss cache will be emptied as well as the list of branches used. ; Definition at line 697 of file TTreeCache.cxx. ◆ SetAutoCreated(). void TTreeCache::SetAutoCreated ; (; bool ; val). inline . Definition at line 164 of file TTreeCache.h. ◆ SetBufferSize(). Int_t TTreeCache::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2072 of file TTreeCache.cxx. ◆ SetEntryRange(). void TTreeCache::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2105 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:48273,cache,cache,48273,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['cache'],['cache']
Performance,"dCallsstatic std::atomic< Int_t > fgReadCallsNumber of bytes read from all TFile objects.Definition TFile.h:133; TFile::Recovervirtual Int_t Recover()Attempt to recover file if not correctly closed.Definition TFile.cxx:2048; TFile::GetStreamerInfoListvirtual TList * GetStreamerInfoList() finalRead the list of TStreamerInfo objects written to this file.Definition TFile.cxx:1445; TFile::WriteHeadervirtual void WriteHeader()Write File Header.Definition TFile.cxx:2615; TFile::kRecovered@ kRecoveredDefinition TFile.h:191; TFile::kReproducible@ kReproducibleDefinition TFile.h:197; TFile::kDevNull@ kDevNullDefinition TFile.h:193; TFile::kHasReferences@ kHasReferencesDefinition TFile.h:192; TFile::k630forwardCompatibility@ k630forwardCompatibilityDefinition TFile.h:190; TFile::kWriteError@ kWriteErrorDefinition TFile.h:194; TFile::kBinaryFile@ kBinaryFileDefinition TFile.h:195; TFile::OpenFromCachestatic TFile * OpenFromCache(const char *name, Option_t *="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Open a file for reading through the file cache.Definition TFile.cxx:3874; TFile::fNProcessIDsInt_t fNProcessIDsNumber of TProcessID written to this file.Definition TFile.h:88; TFile::fWrittenInt_t fWrittenNumber of objects written so far.Definition TFile.h:87; TFile::GetRecordHeaderInt_t GetRecordHeader(char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen)Read the logical record header starting at a certain postion.Definition TFile.cxx:1301; TFile::ReadBuffervirtual Bool_t ReadBuffer(char *buf, Int_t len)Read a buffer from the file.Definition TFile.cxx:1770; TFile::GetCompressionFactorFloat_t GetCompressionFactor()Return the file compression factor.Definition TFile.cxx:1202; TFile::SysWritevirtual Int_t SysWrite(Int_t fd, const void *buf, Int_t len)Interface to system write. All arguments like in POSIX write().Definition TFile.cxx:4514; TFile::GetFileReadCallsstatic Int_t GetF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:230159,cache,cache,230159,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cache']
Performance,"dColumn (RooAbsArg &var, bool adjustRange=true) override;  Add a new column to the data set which holds the pre-calculated values of 'newVar'. ;  ; void append (RooAbsDataStore &other) override;  ; void attachBuffers (const RooArgSet &extObs) override;  ; void attachCache (const RooAbsArg *newOwner, const RooArgSet &cachedVars) override;  Initialize cache of dataset: attach variables of cache ArgSet to the corresponding TTree branches. ;  ; const RooVectorDataStore * cache () const;  ; void cacheArgs (const RooAbsArg *owner, RooArgSet &varSet, const RooArgSet *nset=nullptr, bool skipZeroWeights=true) override;  Cache given RooAbsArgs: The tree is given direct write access of the args internal cache the args values is pre-calculated for all data points in this data collection. ;  ; const RooAbsArg * cacheOwner () override;  ; std::vector< CatVector * > & catStoreList ();  ; bool changeObservableName (const char *from, const char *to) override;  ; RooAbsDataStore * clone (const char *newname=nullptr) const override;  ; RooAbsDataStore * clone (const RooArgSet &vars, const char *newname=nullptr) const override;  ; void dump () override;  ; Int_t fill () override;  Interface function to TTree::Fill. ;  ; virtual const RooArgSet * get () const;  ; const RooArgSet * get (Int_t index) const override;  Load the n-th data point (n='index') into the variables of this dataset, and return a pointer to the RooArgSet that holds them. ;  ; virtual const RooArgSet * get (Int_t index) const=0;  ; RooAbsData::RealSpans getBatches (std::size_t first, std::size_t len) const override;  Return batches of the data columns for the requested events. ;  ; RooAbsData::CategorySpans getCategoryBatches (std::size_t, std::size_t len) const override;  ; std::span< const double > getWeightBatch (std::size_t first, std::size_t len) const override;  Return the weights of all events in the range [first, first+len). ;  ; TClass * IsA () const override;  ; bool isWeighted () const override;  ; void loa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVectorDataStore.html:2969,cache,cacheOwner,2969,doc/master/classRooVectorDataStore.html,https://root.cern,https://root.cern/doc/master/classRooVectorDataStore.html,1,['cache'],['cacheOwner']
Performance,"dDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, const Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TEveTextGL(); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveTextGL.html:1872,cache,cached,1872,root/html602/TEveTextGL.html,https://root.cern,https://root.cern/root/html602/TEveTextGL.html,2,['cache'],['cached']
Performance,"dEngine; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooCategory*RooAbsHiddenReal::_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooUnblindCPAsymVar.html:30957,cache,cache,30957,root/html526/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html526/RooUnblindCPAsymVar.html,12,['cache'],['cache']
Performance,"dFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHtml(const TGWindow* p, int w, int h, int id = -1); HTML Widget constructor. ~TGHtml(); HTML widget destructor. void UpdateBackgroundStart(); Start background update. void FreeColor(ColorStruct_t* color); Free system color. ColorStruct_t * AllocColor(const char* name); Allocate system color by name. ColorStruct_t * AllocColorByValue(ColorStruct_t* color); Allocate system color by value. void Clear(Option_t* = """"); Erase all HTML from this widget and clear the screen. This is; typically done before loading a new document. int ParseText(char* text, const char* index = 0); Appends (or insert at the specified position) the given HTML text to the; end of any HTML text that may have been inserted by prior calls to this; command. Then it runs the tokenizer, parser and layout engine as far as; possible with the text that is available. The display is updated; appropriately. void SetTableRelief(int relief); Sets relief mode of html table. void SetRuleRelief(int relief); Sets relief mode of html rule. void UnderlineLinks(int onoff); Set/reset html links underline. void SetBaseUri(const char* uri); Sets base URI. int GotoAnchor(const char* name); Go to anchor position. const char * GetUid(const char* string); Given a string, this procedure returns a unique identifier for the; string. This procedure returns a pointer to a new char string corresponding to; the ""string"" argument. The new string has a value identical to string; (strcmp will return 0), but it's guaranteed that any other call",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGHtml.html:33271,load,loading,33271,root/html602/TGHtml.html,https://root.cern,https://root.cern/root/html602/TGHtml.html,2,['load'],['loading']
Performance,"dFunctionOneDim;  ~IParametricGradFunctionOneDim () override;  Virtual Destructor (no operations) ;  ; double ParameterDerivative (const double *x, const double *p, unsigned int ipar=0) const;  Partial derivative with respect a parameter Compatibility interface with multi-dimensional functions. ;  ; double ParameterDerivative (const double *x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values (multi-dim like interface) ;  ; double ParameterDerivative (double x, const double *p, unsigned int ipar=0) const;  Partial derivative with respect a parameter. ;  ; double ParameterDerivative (double x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values. ;  ; void ParameterGradient (const double *x, const double *p, double *grad) const;  Compatibility interface with multi-dimensional functions. ;  ; void ParameterGradient (const double *x, double *grad) const;  Evaluate all derivatives using cached parameter values (multi-dim like interface) ;  ; void ParameterGradient (double x, double *grad) const;  Evaluate all derivatives using cached parameter values. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricFunctionOneDim; double operator() (const double *x, const double *p) const;  multidim-like interface ;  ; double operator() (double x, const double *p) const;  Evaluate function at a point x and for given parameters p. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionOneDim; virtual ~IBaseFunctionOneDim ()=default;  ; double operator() (const double *x) const;  Evaluate the function at a point x[]. ;  ; double operator() (double x) const;  Evaluate the function at a point x. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseParam; virtual ~IBaseParam ();  Virtual Destructor (no operations) ;  ;  Public Member Functions inherited from ROOT::Math::IGradientFunctionOneDim; double Derivative (const double *x) const;  Compatibility method with multi-dimensiona",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedTF1.html:2982,cache,cached,2982,doc/master/classROOT_1_1Math_1_1WrappedTF1.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedTF1.html,2,['cache'],['cached']
Performance,"dIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Bool_t_showProgressShow progress indication during evaluation if true; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<string,string>RooAbsArg::_stringAttribString attributes; Double_t_sumWeightGlobal sum of weights needed for normalization; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooDataWeightedAverage(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t showProgress = kFALSE, Bool_t verbose = kTRUE); Constructor of data weighted average of given p.d.f over given data. If nCPU>1 the calculation is parallelized; over multuple processes. If showProgress is true a progress indicator printing ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataWeightedAverage.html:43187,cache,cache,43187,root/html602/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html602/RooDataWeightedAverage.html,2,['cache'],['cache']
Performance,"dLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsString&operator=(const RooAbsString&); Bool_toperator==(const char*) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsString.html:10364,optimiz,optimizeCacheMode,10364,root/html602/RooAbsString.html,https://root.cern,https://root.cern/root/html602/RooAbsString.html,2,['optimiz'],['optimizeCacheMode']
Performance,"dLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); RooAbsReal&pdf() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* dra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvolution.html:19961,optimiz,optimizeCacheMode,19961,root/html526/RooNumConvolution.html,https://root.cern,https://root.cern/root/html526/RooNumConvolution.html,2,['optimiz'],['optimizeCacheMode']
Performance,"dLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); RooArgSetparameters() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChangeTracker.html:18216,optimiz,optimizeCacheMode,18216,root/html526/RooChangeTracker.html,https://root.cern,https://root.cern/root/html526/RooChangeTracker.html,2,['optimiz'],['optimizeCacheMode']
Performance,"dLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); const RooArgList&paramList() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/PiecewiseInterpolation.html:18216,optimiz,optimizeCacheMode,18216,root/html528/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html528/PiecewiseInterpolation.html,1,['optimiz'],['optimizeCacheMode']
Performance,"dLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedReal.html:18225,optimiz,optimizeCacheMode,18225,root/html526/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedReal.html,89,['optimiz'],['optimizeCacheMode']
Performance,"dLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHistFunc.html:17889,optimiz,optimizeCacheMode,17889,root/html526/RooHistFunc.html,https://root.cern,https://root.cern/root/html526/RooHistFunc.html,3,['optimiz'],['optimizeCacheMode']
Performance,"dLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOpt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDerivative.html:17938,optimiz,optimizeCacheMode,17938,root/html526/RooDerivative.html,https://root.cern,https://root.cern/root/html526/RooDerivative.html,4,['optimiz'],['optimizeCacheMode']
Performance,"dLink (const TObject *obj, Int_t &idx) const;  Returns the TObjLink object that contains object obj. ;  ; void InsertAfter (const TObjLinkPtr_t &newlink, const TObjLinkPtr_t &prev);  Insert a new link in the chain. ;  ; TObjLink * LinkAt (Int_t idx) const;  sorting order (when calling Sort() or for TSortedList) ;  ; Bool_t LnkCompare (const TObjLinkPtr_t &l1, const TObjLinkPtr_t &l2);  Compares the objects stored in the TObjLink objects. ;  ; TObjLinkPtr_t NewLink (TObject *obj, const TObjLinkPtr_t &prev=nullptr);  Return a new TObjLink. ;  ; TObjLinkPtr_t NewLink (TObject *obj, TObjLink *prev);  ; TObjLinkPtr_t NewOptLink (TObject *obj, Option_t *opt, const TObjLinkPtr_t &prev=nullptr);  Return a new TObjOptLink (a TObjLink that also stores the option). ;  ; TObjLinkPtr_t NewOptLink (TObject *obj, Option_t *opt, TObjLink *prev);  ;  Protected Member Functions inherited from TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TGridJobStatusList.h>. Inheritance diagram for TGridJobStatusList:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGridJobStatusList(). TGridJobStatusList::TGridJobStatusList ; (; ). inline . Definition at line 36 of file TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGridJobStatusList.html:19220,perform,perform,19220,doc/master/classTGridJobStatusList.html,https://root.cern,https://root.cern/doc/master/classTGridJobStatusList.html,1,['perform'],['perform']
Performance,"dLink (const TObject *obj, Int_t &idx) const;  Returns the TObjLink object that contains object obj. ;  ; void InsertAfter (const TObjLinkPtr_t &newlink, const TObjLinkPtr_t &prev);  Insert a new link in the chain. ;  ; TObjLink * LinkAt (Int_t idx) const;  sorting order (when calling Sort() or for TSortedList) ;  ; Bool_t LnkCompare (const TObjLinkPtr_t &l1, const TObjLinkPtr_t &l2);  Compares the objects stored in the TObjLink objects. ;  ; TObjLinkPtr_t NewLink (TObject *obj, const TObjLinkPtr_t &prev=nullptr);  Return a new TObjLink. ;  ; TObjLinkPtr_t NewLink (TObject *obj, TObjLink *prev);  ; TObjLinkPtr_t NewOptLink (TObject *obj, Option_t *opt, const TObjLinkPtr_t &prev=nullptr);  Return a new TObjOptLink (a TObjLink that also stores the option). ;  ; TObjLinkPtr_t NewOptLink (TObject *obj, Option_t *opt, TObjLink *prev);  ;  Protected Member Functions inherited from TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <THashList.h>. Inheritance diagram for THashList:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ THashList() [1/3]. THashList::THashList ; (; const THashList & ; ). privatedelete . ◆ THashList() [2/3]. THashList::THashList ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:21635,perform,perform,21635,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,1,['perform'],['perform']
Performance,"dLink (const TObject *obj, Int_t &idx) const;  Returns the TObjLink object that contains object obj. ;  ; void InsertAfter (const TObjLinkPtr_t &newlink, const TObjLinkPtr_t &prev);  Insert a new link in the chain. ;  ; TObjLink * LinkAt (Int_t idx) const;  sorting order (when calling Sort() or for TSortedList) ;  ; Bool_t LnkCompare (const TObjLinkPtr_t &l1, const TObjLinkPtr_t &l2);  Compares the objects stored in the TObjLink objects. ;  ; TObjLinkPtr_t NewLink (TObject *obj, const TObjLinkPtr_t &prev=nullptr);  Return a new TObjLink. ;  ; TObjLinkPtr_t NewLink (TObject *obj, TObjLink *prev);  ; TObjLinkPtr_t NewOptLink (TObject *obj, Option_t *opt, const TObjLinkPtr_t &prev=nullptr);  Return a new TObjOptLink (a TObjLink that also stores the option). ;  ; TObjLinkPtr_t NewOptLink (TObject *obj, Option_t *opt, TObjLink *prev);  ;  Protected Member Functions inherited from TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions;  TListOfEnums (const TListOfEnums &)=delete;  Represent interpreter state when we last did a full load. ;  ; void Load ();  Load all the DataMembers known to the interpreter for the scope 'fClass' into this collection. ;  ; void MapObject (TObject *obj);  Add pair<id, object> to the map of functions",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnums.html:20283,perform,perform,20283,doc/master/classTListOfEnums.html,https://root.cern,https://root.cern/doc/master/classTListOfEnums.html,1,['perform'],['perform']
Performance,"dLink (const TObject *obj, Int_t &idx) const;  Returns the TObjLink object that contains object obj. ;  ; void InsertAfter (const TObjLinkPtr_t &newlink, const TObjLinkPtr_t &prev);  Insert a new link in the chain. ;  ; TObjLink * LinkAt (Int_t idx) const;  sorting order (when calling Sort() or for TSortedList) ;  ; Bool_t LnkCompare (const TObjLinkPtr_t &l1, const TObjLinkPtr_t &l2);  Compares the objects stored in the TObjLink objects. ;  ; TObjLinkPtr_t NewLink (TObject *obj, const TObjLinkPtr_t &prev=nullptr);  Return a new TObjLink. ;  ; TObjLinkPtr_t NewLink (TObject *obj, TObjLink *prev);  ; TObjLinkPtr_t NewOptLink (TObject *obj, Option_t *opt, const TObjLinkPtr_t &prev=nullptr);  Return a new TObjOptLink (a TObjLink that also stores the option). ;  ; TObjLinkPtr_t NewOptLink (TObject *obj, Option_t *opt, TObjLink *prev);  ;  Protected Member Functions inherited from TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in linked list ;  ;  Protected Attributes inherited from TSeqCollectio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTList.html:20932,perform,perform,20932,doc/master/classTList.html,https://root.cern,https://root.cern/doc/master/classTList.html,1,['perform'],['perform']
Performance,"dLink (const TObject *obj, Int_t &idx) const;  Returns the TObjLink object that contains object obj. ;  ; void InsertAfter (const TObjLinkPtr_t &newlink, const TObjLinkPtr_t &prev);  Insert a new link in the chain. ;  ; TObjLink * LinkAt (Int_t idx) const;  sorting order (when calling Sort() or for TSortedList) ;  ; Bool_t LnkCompare (const TObjLinkPtr_t &l1, const TObjLinkPtr_t &l2);  Compares the objects stored in the TObjLink objects. ;  ; TObjLinkPtr_t NewLink (TObject *obj, const TObjLinkPtr_t &prev=nullptr);  Return a new TObjLink. ;  ; TObjLinkPtr_t NewLink (TObject *obj, TObjLink *prev);  ; TObjLinkPtr_t NewOptLink (TObject *obj, Option_t *opt, const TObjLinkPtr_t &prev=nullptr);  Return a new TObjOptLink (a TObjLink that also stores the option). ;  ; TObjLinkPtr_t NewOptLink (TObject *obj, Option_t *opt, TObjLink *prev);  ;  Protected Member Functions inherited from TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TList fClasses;  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in link",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTViewPubDataMembers.html:15659,perform,perform,15659,doc/master/classTViewPubDataMembers.html,https://root.cern,https://root.cern/doc/master/classTViewPubDataMembers.html,2,['perform'],['perform']
Performance,"dLink (const TObject *obj, Int_t &idx) const;  Returns the TObjLink object that contains object obj. ;  ; void InsertAfter (const TObjLinkPtr_t &newlink, const TObjLinkPtr_t &prev);  Insert a new link in the chain. ;  ; TObjLink * LinkAt (Int_t idx) const;  sorting order (when calling Sort() or for TSortedList) ;  ; Bool_t LnkCompare (const TObjLinkPtr_t &l1, const TObjLinkPtr_t &l2);  Compares the objects stored in the TObjLink objects. ;  ; TObjLinkPtr_t NewLink (TObject *obj, const TObjLinkPtr_t &prev=nullptr);  Return a new TObjLink. ;  ; TObjLinkPtr_t NewLink (TObject *obj, TObjLink *prev);  ; TObjLinkPtr_t NewOptLink (TObject *obj, Option_t *opt, const TObjLinkPtr_t &prev=nullptr);  Return a new TObjOptLink (a TObjLink that also stores the option). ;  ; TObjLinkPtr_t NewOptLink (TObject *obj, Option_t *opt, TObjLink *prev);  ;  Protected Member Functions inherited from TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from THashList; THashTable * fTable;  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfDataMembers.html:22228,perform,perform,22228,doc/master/classTListOfDataMembers.html,https://root.cern,https://root.cern/doc/master/classTListOfDataMembers.html,5,['perform'],['perform']
Performance,"dLink (const TObject *obj, Int_t &idx) const;  Returns the TObjLink object that contains object obj. ;  ; void InsertAfter (const TObjLinkPtr_t &newlink, const TObjLinkPtr_t &prev);  Insert a new link in the chain. ;  ; TObjLink * LinkAt (Int_t idx) const;  sorting order (when calling Sort() or for TSortedList) ;  ; Bool_t LnkCompare (const TObjLinkPtr_t &l1, const TObjLinkPtr_t &l2);  Compares the objects stored in the TObjLink objects. ;  ; TObjLinkPtr_t NewLink (TObject *obj, const TObjLinkPtr_t &prev=nullptr);  Return a new TObjLink. ;  ; TObjLinkPtr_t NewLink (TObject *obj, TObjLink *prev);  ; TObjLinkPtr_t NewOptLink (TObject *obj, Option_t *opt, const TObjLinkPtr_t &prev=nullptr);  Return a new TObjOptLink (a TObjLink that also stores the option). ;  ; TObjLinkPtr_t NewOptLink (TObject *obj, Option_t *opt, TObjLink *prev);  ;  Protected Member Functions inherited from TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ; virtual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in linked list ;  ;  Protected Attributes inheri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextEditHist.html:18254,perform,perform,18254,doc/master/classTGTextEditHist.html,https://root.cern,https://root.cern/doc/master/classTGTextEditHist.html,7,['perform'],['perform']
Performance,"dLink (const TObject *obj, Int_t &idx) const;  Returns the TObjLink object that contains object obj. ;  ; void InsertAfter (const TObjLinkPtr_t &newlink, const TObjLinkPtr_t &prev);  Insert a new link in the chain. ;  ; TObjLink * LinkAt (Int_t idx) const;  sorting order (when calling Sort() or for TSortedList) ;  ; Bool_t LnkCompare (const TObjLinkPtr_t &l1, const TObjLinkPtr_t &l2);  Compares the objects stored in the TObjLink objects. ;  ; TObjLinkPtr_t NewLink (TObject *obj, const TObjLinkPtr_t &prev=nullptr);  Return a new TObjLink. ;  ; TObjLinkPtr_t NewLink (TObject *obj, TObjLink *prev);  ; TObjLinkPtr_t NewOptLink (TObject *obj, Option_t *opt, const TObjLinkPtr_t &prev=nullptr);  Return a new TObjOptLink (a TObjLink that also stores the option). ;  ; TObjLinkPtr_t NewOptLink (TObject *obj, Option_t *opt, TObjLink *prev);  ;  Protected Member Functions inherited from TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Protected Attributes; TString fClassName;  ; void * fReceiver = nullptr;  ; TQSlot * fSlot = nullptr;  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to la",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQConnection.html:24036,perform,perform,24036,doc/master/classTQConnection.html,https://root.cern,https://root.cern/doc/master/classTQConnection.html,1,['perform'],['perform']
Performance,"dLink (const TObject *obj, Int_t &idx) const;  Returns the TObjLink object that contains object obj. ;  ; void InsertAfter (const TObjLinkPtr_t &newlink, const TObjLinkPtr_t &prev);  Insert a new link in the chain. ;  ; TObjLink * LinkAt (Int_t idx) const;  sorting order (when calling Sort() or for TSortedList) ;  ; Bool_t LnkCompare (const TObjLinkPtr_t &l1, const TObjLinkPtr_t &l2);  Compares the objects stored in the TObjLink objects. ;  ; TObjLinkPtr_t NewLink (TObject *obj, const TObjLinkPtr_t &prev=nullptr);  Return a new TObjLink. ;  ; TObjLinkPtr_t NewLink (TObject *obj, TObjLink *prev);  ; TObjLinkPtr_t NewOptLink (TObject *obj, Option_t *opt, const TObjLinkPtr_t &prev=nullptr);  Return a new TObjOptLink (a TObjLink that also stores the option). ;  ; TObjLinkPtr_t NewOptLink (TObject *obj, Option_t *opt, TObjLink *prev);  ;  Protected Member Functions inherited from TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ; virtual void PrintCollectionEntry (TObject *entry, Option_t *option, Int_t recurse) const;  Print the collection entry. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Protected Attributes; TString fName;  ; Bool_t fNewDelete;  ; Int_t fNRargs;  ; Int_t fNUargs;  ; void * fObject;  ; TQConnection * fRedo;  ; Long_t * fRedoArgs;  ; Int_t fState;  ; Int_t fStatus;  ; TString fTitle;  ; TQConnection * fUndo;  ; Long_t * fUndoArgs;  ;  Protected Attrib",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:27842,perform,perform,27842,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['perform'],['perform']
Performance,"dLink (const TObject *obj, Int_t &idx) const;  Returns the TObjLink object that contains object obj. ;  ; void InsertAfter (const TObjLinkPtr_t &newlink, const TObjLinkPtr_t &prev);  Insert a new link in the chain. ;  ; TObjLink * LinkAt (Int_t idx) const;  sorting order (when calling Sort() or for TSortedList) ;  ; Bool_t LnkCompare (const TObjLinkPtr_t &l1, const TObjLinkPtr_t &l2);  Compares the objects stored in the TObjLink objects. ;  ; TObjLinkPtr_t NewLink (TObject *obj, const TObjLinkPtr_t &prev=nullptr);  Return a new TObjLink. ;  ; TObjLinkPtr_t NewLink (TObject *obj, TObjLink *prev);  ; TObjLinkPtr_t NewOptLink (TObject *obj, Option_t *opt, const TObjLinkPtr_t &prev=nullptr);  Return a new TObjOptLink (a TObjLink that also stores the option). ;  ; TObjLinkPtr_t NewOptLink (TObject *obj, Option_t *opt, TObjLink *prev);  ;  Protected Member Functions inherited from TSeqCollection;  TSeqCollection ();  ; virtual void Changed ();  ;  Protected Member Functions inherited from TCollection;  TCollection ();  ; virtual const char * GetCollectionEntryName (TObject *entry) const;  For given collection entry return the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Protected Attributes; TQCommand * fCurrent;  ; TObjLink * fCursor;  ; UInt_t fLimit;  ; TList * fLogBook;  ; Bool_t fLogging;  ;  Protected Attributes inherited from TQCommand; TString fName;  ; Bool_t fNewDelete;  ; Int_t fNRargs;  ; Int_t fNUargs;  ; void * fObject;  ; TQConnection * fRedo;  ; Long_t * fRedoArgs;  ; Int_t fState;  ; Int_t fStatus;  ; TString fTitle;  ; TQConnection * fUndo;  ; Long_t * f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQUndoManager.html:24743,perform,perform,24743,doc/master/classTQUndoManager.html,https://root.cern,https://root.cern/doc/master/classTQUndoManager.html,1,['perform'],['perform']
Performance,"dList & ;  . ). inlinevirtual . Interface for processing of cache mode optimization calls. ; Reimplemented in RooObjCacheManager.; Definition at line 49 of file RooAbsCache.h. ◆ printCompactTreeHook(). virtual void RooAbsCache::printCompactTreeHook ; (; std::ostream & ; , . const char * ;  . ). inlinevirtual . Interface for printing of cache guts in tree mode printing. ; Reimplemented in RooCacheManager< T >, RooCacheManager< RooAbsCacheElement >, and RooObjCacheManager.; Definition at line 55 of file RooAbsCache.h. ◆ redirectServersHook(). virtual bool RooAbsCache::redirectServersHook ; (; const RooAbsCollection & ; , . bool ; , . bool ; , . bool ;  . ). inlinevirtual . Interface for server redirect calls. ; Reimplemented in RooCacheManager< T >, RooCacheManager< RooAbsCacheElement >, RooObjCacheManager, and RooMappedCategoryCache.; Definition at line 40 of file RooAbsCache.h. ◆ setOwner(). void RooAbsCache::setOwner ; (; RooAbsArg * ; owner). Reset the owner, triggering the owner to register this cache in its list of caches. ; Definition at line 71 of file RooAbsCache.cxx. ◆ Streamer(). virtual void RooAbsCache::Streamer ; (; TBuffer & ; ). virtual . Reimplemented in RooCacheManager< T >, RooCacheManager< RooAbsCacheElement >, and RooObjCacheManager. ◆ StreamerNVirtual(). void RooAbsCache::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 63 of file RooAbsCache.h. ◆ wireCache(). virtual void RooAbsCache::wireCache ; (; ). inlinevirtual . Reimplemented in RooCacheManager< T >, RooCacheManager< RooAbsCacheElement >, and RooMappedCategoryCache.; Definition at line 57 of file RooAbsCache.h. Member Data Documentation. ◆ _owner. RooAbsArg* RooAbsCache::_owner. protected . Pointer to owning RooAbsArg. ; Definition at line 61 of file RooAbsCache.h. Libraries for RooAbsCache:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooAbsCache.h; roofit/roofitcore/src/RooAbsCache.cx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCache.html:5544,cache,cache,5544,doc/master/classRooAbsCache.html,https://root.cern,https://root.cern/doc/master/classRooAbsCache.html,2,['cache'],"['cache', 'caches']"
Performance,"dMultiTF1Templ< T > &rhs);  Copy constructor. ;  ;  WrappedMultiTF1Templ (TF1 &f, unsigned int dim=0);  constructor from a function pointer to a TF1 If dim = 0 dimension is taken from TF1::GetNdim(). ;  ;  ~WrappedMultiTF1Templ () override;  Destructor (no operations). ;  ; WrappedMultiTF1Templ & operator= (const WrappedMultiTF1Templ< T > &rhs);  Assignment operator. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricGradFunctionMultiDimTempl< T >;  ~IParametricGradFunctionMultiDimTempl () override;  Virtual Destructor (no operations) ;  ; T operator() (const T *x) const;  ; T operator() (const T *x, const double *p) const;  ; T ParameterDerivative (const T *x, const double *p, unsigned int ipar=0) const;  Evaluate the partial derivative w.r.t a parameter ipar from values and parameters. ;  ; T ParameterDerivative (const T *x, unsigned int ipar=0) const;  Evaluate partial derivative using cached parameter values. ;  ; void ParameterGradient (const T *x, T *grad) const;  Evaluate all derivatives using cached parameter values. ;  ;  Public Member Functions inherited from ROOT::Math::IParametricFunctionMultiDimTempl< T >; T operator() (const T *x) const;  ; T operator() (const T *x, const double *p) const;  Evaluate function at a point x and for given parameters p. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseFunctionMultiDimTempl< T >; virtual ~IBaseFunctionMultiDimTempl ()=default;  ; virtual bool HasGradient () const;  ; T operator() (const T *x) const;  Evaluate the function at a point x[]. ;  ;  Public Member Functions inherited from ROOT::Math::IBaseParam; virtual ~IBaseParam ();  Virtual Destructor (no operations) ;  . interface inherited from IParamFunction; bool fLinear;  ; bool fPolynomial;  ; bool fOwnFunc;  ; TF1 * fFunc;  ; unsigned int fDim;  ; IMultiGenFunctionTempl< T > * Clone () const override;  Clone the wrapper but not the original function. ;  ; unsigned int NDim () const override;  Retrieve the dimension of the fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedMultiTF1Templ.html:2748,cache,cached,2748,doc/master/classROOT_1_1Math_1_1WrappedMultiTF1Templ.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1WrappedMultiTF1Templ.html,1,['cache'],['cached']
Performance,"dNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase ; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypefPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tfReadDirectionSet! read direction established; Bool_tfReverseRead! reading in reverse mode ; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:20343,cache,cache,20343,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,1,['cache'],['cache']
Performance,"dOptions"" is done in an independent call, since it may be overr...Definition MethodBase.cxx:423; TMVA::MethodBase::GetTrainingEfficiencyvirtual Double_t GetTrainingEfficiency(const TString &)Definition MethodBase.cxx:2528; TMVA::MethodBase::DataInfoDataSetInfo & DataInfo() constDefinition MethodBase.h:410; TMVA::MethodBase::MakeClassvirtual void MakeClass(const TString &classFileName=TString("""")) constcreate reader class for method (classification only at present)Definition MethodBase.cxx:3003; TMVA::MethodBase::TestClassificationvirtual void TestClassification()initializationDefinition MethodBase.cxx:1127; TMVA::MethodBase::AddOutputvoid AddOutput(Types::ETreeType type, Types::EAnalysisType analysisType)Definition MethodBase.cxx:1315; TMVA::MethodBase::ReadStateFromFilevoid ReadStateFromFile()Function to write options and weights to file.Definition MethodBase.cxx:1426; TMVA::MethodBase::OptimizeTuningParametersvirtual std::map< TString, Double_t > OptimizeTuningParameters(TString fomType=""ROCIntegral"", TString fitType=""FitGA"")call the Optimizer with the set of parameters and ranges that are meant to be tuned.Definition MethodBase.cxx:623; TMVA::MethodBase::fDataSetInfoDataSetInfo & fDataSetInfoDefinition MethodBase.h:607; TMVA::MethodBase::GetMethodTypeTypes::EMVA GetMethodType() constDefinition MethodBase.h:333; TMVA::MethodBase::SetFilevoid SetFile(TFile *file)Definition MethodBase.h:375; TMVA::MethodBase::DataDataSet * Data() constDefinition MethodBase.h:409; TMVA::MethodBase::SetModelPersistencevoid SetModelPersistence(Bool_t status)Definition MethodBase.h:382; TMVA::MethodBase::GetROCIntegralvirtual Double_t GetROCIntegral(TH1D *histS, TH1D *histB) constcalculate the area (integral) under the ROC curve as a overall quality measure of the classificationDefinition MethodBase.cxx:2822; TMVA::MethodBase::CheckSetupvirtual void CheckSetup()check may be overridden by derived class (sometimes, eg, fitters are used which can only be implement...Definition MethodBase.c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:130205,tune,tuned,130205,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['tune'],['tuned']
Performance,"dOwned(RooAbsArg &var, bool silent=false)Add an argument and transfer the ownership to the collection.Definition RooAbsCollection.cxx:367; RooAbsCollection::addClonevirtual RooAbsArg * addClone(const RooAbsArg &var, bool silent=false)Add a clone of the specified argument to list.Definition RooAbsCollection.cxx:416; RooAbsCollection::contentsStringstd::string contentsString() constReturn comma separated list of contained object names as STL string.Definition RooAbsCollection.cxx:1148; RooAbsCollection::findRooAbsArg * find(const char *name) constFind object with given name in list.Definition RooAbsCollection.cxx:922; RooAbsDataAbstract base class for binned and unbinned datasets.Definition RooAbsData.h:57; RooAbsData::getvirtual const RooArgSet * get() constDefinition RooAbsData.h:101; RooAbsData::numEntriesvirtual Int_t numEntries() constReturn number of entries in dataset, i.e., count unweighted entries.Definition RooAbsData.cxx:323; RooAbsFuncAbstract interface for evaluating a real-valued function of one real variable and performing numerica...Definition RooAbsFunc.h:27; RooAbsFunc::getMaxLimitvirtual double getMaxLimit(UInt_t dimension) const =0; RooAbsFunc::operator()virtual double operator()(const double xvector[]) const =0; RooAbsFunc::getMinLimitvirtual double getMinLimit(UInt_t dimension) const =0; RooAbsLValueAbstract base class for objects that are lvalues, i.e.Definition RooAbsLValue.h:26; RooAbsMomentDefinition RooAbsMoment.h:27; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::expectedEventsvirtual double expectedEvents(const RooArgSet *nset) constReturn expected number of events to be used in calculation of extended likelihood.Definition RooAbsPdf.cxx:2398; RooAbsPdf::Classstatic TClass * Class(); RooAbsPdf::CanNotBeExtended@ CanNotBeExtendedDefinition RooAbsPdf.h:212; RooAbsPdf::normRangeconst char * normRange() constDefinition RooAbsPdf.h:250; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:212556,perform,performing,212556,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['perform'],['performing']
Performance,dPCA on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0197 sec ; Factory : Test method: PDERS for Classification performance; : ; PDERS : [dataset] : Evaluation of PDERS on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.937 sec ; Factory : Test method: PDEFoam for Classification performance; : ; PDEFoam : [dataset] : Evaluation of PDEFoam on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.072 sec ; Factory : Test method: KNN for Classification performance; : ; KNN : [dataset] : Evaluation of KNN on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.2 sec ; Factory : Test method: LD for Classification performance; : ; LD : [dataset] : Evaluation of LD on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00474 sec ; : Dataset[dataset] : Evaluation of LD on testing sample; Factory : Test method: FDA_GA for Classification performance; : ; FDA_GA : [dataset] : Evaluation of FDA_GA on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00327 sec ; Factory : Test method: MLPBNN for Classification performance; : ; MLPBNN : [dataset] : Evaluation of MLPBNN on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0193 sec ; Factory : Test method: DNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.12216 0.20255 [ -1.0614 1.0246 ]; : myvar2: -0.12333 0.30492 [ -1.2280 0.99911 ]; : var3: 0.097148 0.21347 [ -1.0158 0.99984 ]; : var4: 0.17495 0.23851 [ -1.2661 1.0694 ]; : -----------------------------------------------------------; DNN_CPU : [dataset] : Evaluation of DNN_CPU on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.333 sec ; Factory : Test me,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:66992,perform,performance,66992,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['perform'],['performance']
Performance,"dPdf. class RooAddPdf: public RooAbsPdf. RooAddPdf is an efficient implementation of a sum of PDFs of the form. c_1*PDF_1 + c_2*PDF_2 + ... c_n*PDF_n. or. c_1*PDF_1 + c_2*PDF_2 + ... (1-sum(c_1...c_n-1))*PDF_n. The first form is for extended likelihood fits, where the; expected number of events is Sum(i) c_i. The coefficients c_i; can either be explicitly provided, or, if all components support; extended likelihood fits, they can be calculated the contribution; of each PDF to the total number of expected events. In the second form, the sum of the coefficients is enforced to be one,; and the coefficient of the last PDF is calculated from that condition. It is also possible to parameterize the coefficients recursively. c1*PDF_1 + (1-c1)(c2*PDF_2 + (1-c2)*(c3*PDF_3 + ....)). In this form the sum of the coefficients is always less than 1.0; for all possible values of the individual coefficients between 0 and 1. RooAddPdf relies on each component PDF to be normalized and will perform; no normalization other than calculating the proper last coefficient c_n, if requested.; An (enforced) condition for this assuption is that each PDF_i is independent; of each coefficient_i. Function Members (Methods); public:. RooAddPdf(); RooAddPdf(const char* name, const char* title = 0); RooAddPdf(const RooAddPdf& other, const char* name = 0); RooAddPdf(const char* name, const char* title, const RooArgList& pdfList); RooAddPdf(const char* name, const char* title, RooAbsPdf& pdf1, RooAbsPdf& pdf2, RooAbsReal& coef1); RooAddPdf(const char* name, const char* title, const RooArgList& pdfList, const RooArgList& coefList, Bool_t recursiveFraction = kFALSE); virtual~RooAddPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddPdf.html:1243,perform,perform,1243,root/html526/RooAddPdf.html,https://root.cern,https://root.cern/root/html526/RooAddPdf.html,5,['perform'],['perform']
Performance,"dPdf. class RooAddPdf: public RooAbsPdf. RooAddPdf is an efficient implementation of a sum of PDFs of the form. c_1*PDF_1 + c_2*PDF_2 + ... c_n*PDF_n. or. c_1*PDF_1 + c_2*PDF_2 + ... (1-sum(c_1...c_n-1))*PDF_n. The first form is for extended likelihood fits, where the; expected number of events is Sum(i) c_i. The coefficients c_i; can either be explicitly provided, or, if all components support; extended likelihood fits, they can be calculated the contribution; of each PDF to the total number of expected events. In the second form, the sum of the coefficients is enforced to be one,; and the coefficient of the last PDF is calculated from that condition. It is also possible to parameterize the coefficients recursively. c1*PDF_1 + (1-c1)(c2*PDF_2 + (1-c2)*(c3*PDF_3 + ....)). In this form the sum of the coefficients is always less than 1.0; for all possible values of the individual coefficients between 0 and 1. RooAddPdf relies on each component PDF to be normalized and will perform; no normalization other than calculating the proper last coefficient c_n, if requested.; An (enforced) condition for this assuption is that each PDF_i is independent; of each coefficient_i. Function Members (Methods); public:. virtual~RooAddPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddPdf.html:1243,perform,perform,1243,root/html602/RooAddPdf.html,https://root.cern,https://root.cern/root/html602/RooAddPdf.html,2,['perform'],['perform']
