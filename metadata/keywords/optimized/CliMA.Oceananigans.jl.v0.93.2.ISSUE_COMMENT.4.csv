quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,wiki,url,total_similar,target_keywords,target_matched_words
Modifiability,"th gravity tilted at 45 degrees; >; > [image: tilted_gravity_plume]; > <https://user-images.githubusercontent.com/20099589/100940093-5ab5d600-34c5-11eb-918e-f574f284f024.gif>; >; > This is an experimental feature since it needs more rigorous testing and; > because full support for tilted gravity may require more work, e.g.; >; > 1. Should AMD use z_dot_g_b now?; > 2. Should ∂x_b return a vector or should it be split up into x_dot_∂x_b,; > etc.? The Leith closure uses ∂x_b.; > 3. We may want to clean up and refactor the implementation, taking; > some suggestions from #1151; > <https://github.com/CliMA/Oceananigans.jl/issues/1151>.; >; > cc @tomchor <https://github.com/tomchor>; >; > Resolves #1151 <https://github.com/CliMA/Oceananigans.jl/issues/1151>; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/CliMA/Oceananigans.jl/pull/1242; > Commit Summary; >; > - Make room for tuple gravity; > - Some `{x,y,z}_dot_g_b`; > - Tilted gravity plume sandbox; >; > File Changes; >; > - *A* sandbox/tilted_gravity_plume.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-9f5abd06fd694cf6f0d35019ea409e07e100a801fbfcd9a2a8d3737801a341b0>; > (53); > - *M* src/Buoyancy/Buoyancy.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-55d14f16043b022b6a286fd9881d334208e6b6251d122555d3ede4014ea59e55>; > (10); > - *A* src/Buoyancy/gravitational_acceleration.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-bb73385a8b574af8f9b259bd480acf1bdd913e8969bb440833342c0fba3f1150>; > (7); > - *M* src/Buoyancy/linear_equation_of_state.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-f3c384915af5bdd55a7a9cb929dee20fcca1682630706def515ed65b5a3cb490>; > (42); > - *M* src/Buoyancy/seawater_buoyancy.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-17b154b6d4fa0d986ee4ef99715cced4bc7eac3c93690c52239d83745090c334>; > (56); > - *M* src/Models/Incom",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819:1604,sandbox,sandbox,1604,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819,2,['sandbox'],['sandbox']
Modifiability,"thanks for the explanation. On Mon, Oct 12, 2020 at 8:25 PM Gregory L. Wagner <notifications@github.com>; wrote:. > Greg, Doesn't Ali have a version of immersed boundary layers going?; >; > @johncmarshall54 <https://github.com/johncmarshall54>, Ali experimented; > with a simple immersed boundary implemented via Oceananigans's user-defined; > forcing functions. The code is these 9 lines:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/a921fc3edbf795bf4a2193cca84cad41ebdd5625/verification/flow_around_cylinder/flow_around_cylinder.jl#L18-L27; >; > This implementation damps the velocity field to zero on a very fast; > time-scale (specified by the parameter K) within the immersed boundary.; > This is certainly a nice, simple immersed boundary implementation for; > Dirichlet / Value boundary conditions and could a good starting point.; > However, I also think there's some good reasons to pursue an alternate; > immersed boundary implementation to what @ali-ramadhan; > <https://github.com/ali-ramadhan> has done for the following reasons:; >; > 1. @ali-ramadhan <https://github.com/ali-ramadhan>'s implementation; > doesn't obviously extend to other boundary conditions, like prescribed; > gradients or fluxes (the latter being crucial for the geophysical problems; > we're interested in). So, even if we use a continuous forcing method; > similar to @ali-ramadhan <https://github.com/ali-ramadhan>'s; > implementation, we need to figure out how to enforce boundary conditions; > other than Dirichlet boundary conditions.; > 2. @ali-ramadhan <https://github.com/ali-ramadhan>'s implementation; > conforms exactly to the grid; however we would like to be able to model; > smoothly-varying boundaries.; > 3. As noted by @whitleyv <https://github.com/whitleyv>, @ali-ramadhan; > <https://github.com/ali-ramadhan>'s ""continuous forcing method""; > implementation introduces a time-step restriction due to the need to; > explicitly resolve the damping time-scale in the forcing function. It se",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707413052:170,layers,layers,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707413052,1,['layers'],['layers']
Modifiability,"the Redi tensor and GM for TwoDimensionalLeith so GM-Redi might; > not need too much extra work:; > https://github.com/CliMA/Oceananigans.jl/blob/master/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl; > Questions/proposal; >; > 1. Do we make the small-angle approximation? I would say yes.; >; > In Oceananigans.jl right now each component of the tensor diffusivity is; > calculated on-the-fly so the unapproximated tensor could end up being 2-4x; > more expensive to compute. We cannot compute the full tensor in one go; > (reusing the isopycnal slopes) and we may not want to since it takes up a; > lot of memory (9 extra field?). But maybe there's a good reason to not make; > the small-angle approximation? We could eventually support both; > (unapproximated and small-angle approximation).; >; > See; > https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#redi-scheme-isopycnal-diffusion; > for a comparison of the two.; >; > 1. Is GM-Redi the main parameterization of interest? Would people use; > the fully symmetric or the fully anti-symmetric diffusivity tensor by; > themselves?; >; > If not then maybe we can save some time by just implementing one new; > closure, GMRedi or GentMcWilliamsRedi. If we take the isopycnal; > diffusivity to be the same for both the symmetric and anti-symmetric tensor; > then we the resulting tensor is quite cheap to compute (only 3 components); > if performance is important:; >; > From; > https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#griffies-skew-flux; > [image: image]; > <https://user-images.githubusercontent.com/20099589/111556957-1abbeb80-8762-11eb-9fb3-870d447efa5f.png>; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1492>, or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQT2T2NK46W7G7ZS5ULTEFFH5ANCNFSM4ZLUCVJQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1492#issuecomment-801541587:1871,parameteriz,parameterization,1871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1492#issuecomment-801541587,1,['parameteriz'],['parameterization']
Modifiability,"these are if we want to make the particle velocity depend on other _eulerian_ fields (like forcing for our prognostic variables). An example can be the buoyancy field for buoyant particles. If we decide that that role can be undertaken by the `dynamics` kernel, we can remove the `i, j, k` from the signature. We should probably come up with a couple of examples to include in this PR that show the implementation of different particle dynamics. ; I would include:; - buoyant particles (sinking or rising with a density-dependent vertical velocity); - particles with drag",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852745078:118,variab,variables,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852745078,1,['variab'],['variables']
Modifiability,"this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace it with the ""real"" closure after constructing model by writing `model.closure = real_closure`. It could be fun to try that and see if the code is simpler. I suspect it might not be but it's worth a shot (you might learn something). . > Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. I guess that's sort of what we're doing here. The main issue is reducing boilerplate / making this as easy as possible. It'd be nice to write parameterizations with more abstract syntax rather than having to write a low-level kernel function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:2950,parameteriz,parameterizations,2950,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513,4,['parameteriz'],['parameterizations']
Modifiability,"thub.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593. There may be other problems that we haven't uncovered. An important additional case that doesn't work right now is operations that have embedded `AveragedField`. I think this is some kind of type inference issue. For `Field` on the GPU we ""throw away"" the wrapper and expose the underlying `OffsetArray` to GPU kernels. So compilation of functions of `Field` is ""no more difficult"" than compilation of functions with `OffsetArray`. This idealization is successful because indexing into the underlying `field.data` is identical indexing into the field itself, and because we don't require field locations _inside_ the kernel (we build expression trees for AbstractOperations on the CPU, prior to launching the kernel). But this idealization doesn't hold for `AveragedField` or any `ReducedField`. In particular, abstract operations index into these objects at all `i, j, k`. However, they don't vary on one or more of these directions; the indexing operation needs to be ""collapsed"" so that reduced indices are translated correctly. Thus when we adapt `AveragedField` for the GPU, we hold onto the wrapper:. https://github.com/CliMA/Oceananigans.jl/blob/98cd4f7a56aa581defc721a01d6e1ab89b534d26/src/Fields/averaged_field.jl#L94-L96. Peeking at the broadcasting code used by julia Base gives a hint. Broadcasting has to solve the same problem: we have to be able to make computations between arrays of size (Nx, Ny, 1) and (Nx, Ny, Nz), for example. In this case, the indices of the first array are ""extruded"" into the third dimension. There are [some shenanigans in `Base.Broadcast`](https://github.com/JuliaLang/julia/blob/e467661f080a1b14ca1a9cf6681a8c713a3ae20c/base/broadcast.jl#L572-L630) that look like they are solving some type instability problem (which would doom GPU compilation for us if it were occurring). So we might be able to learn / borrow code from `Base.Broadcast`. All speculation from a naive julia programmer...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550:2531,adapt,adapt,2531,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550,2,['adapt'],['adapt']
Modifiability,"time-stepping loop in our wind mixing and convection example:. https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/examples/ocean_wind_mixing_and_convection.jl#L199. This printing produces a stream of messages during the simulation:. ```julia; julia> include(""ocean_wind_mixing_and_convection.jl""); i: 0010, t: 11.000 s, Δt: 1.100 s, wmax = 7.8e-04 ms⁻¹, wall time: 594.383 ms; i: 0020, t: 23.100 s, Δt: 1.210 s, wmax = 1.5e-03 ms⁻¹, wall time: 581.628 ms; i: 0030, t: 36.410 s, Δt: 1.331 s, wmax = 2.3e-03 ms⁻¹, wall time: 567.346 ms; i: 0040, t: 51.051 s, Δt: 1.464 s, wmax = 3.2e-03 ms⁻¹, wall time: 562.455 ms; i: 0050, t: 1.119 min, Δt: 1.611 s, wmax = 4.2e-03 ms⁻¹, wall time: 576.511 ms; i: 0060, t: 1.415 min, Δt: 1.772 s, wmax = 5.2e-03 ms⁻¹, wall time: 571.096 ms; ```. In this case, the information we decide to print is:. * iteration number `i`; * the simulation time `t`; * the time-step (because we are using adaptive time-stepping); * the maximum vertical velocity; * the elapsed wall time for time stepping *only* (not including plotting) between print messages. I think this issue is about a better way to achieve the printing of simulation progress. Two ideas are:. 1. Somehow use a logging package (though I'm not 100% what this would look like --- perhaps this means adding lines to our [time-stepping loop](https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/src/time_steppers.jl#L28)?; 2. Create some types that allow the user to more easily manage the printing of progress messages, expanding on the pattern used in our example. I've thought a bit about 2: I think a generic progress messenger would be both configurable but also include some comforting defaults. A simple way to start could be something like. ```julia; struct ProgressPrinter{DT, M, D}; Δt :: DT; model :: M; diagnostics :: D; end; ```. with some kind of print function, something like. ```julia; pretty_Δt(Δt::Number) =",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221:1200,adapt,adaptive,1200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221,1,['adapt'],['adaptive']
Modifiability,"tl;dr. 1. Should we change the flux convention in Oceananigans so that `FluxBoundaryCondition` specifies the flux along the _inward pointing normal_? This reverses the convention we use on ""right"" boundaries (west, north, top). For example, a negative buoyancy flux would cause cooling at the surface with this convention. This is a huge change, but I think is necessary to do things like specifying a drag boundary condition on vertical velocity (I can discuss further why this is the case if needed.). 2. How do we feel about wrapping boundary conditions for immersed boundaries in `FieldBoundaryConditions` (this requires refactoring `FieldBoundaryConditions` under the hood, but does not change the API). We can do 2. without 1. In that case we'll be able to support a lot of common cases, including ordinary oceanic cases (where boundaries do not overhang, and we only specify drag on tangential components). It's really LES cases that become tricky because we can't specify drag on vertical velocity components, or on tangential components when the boundary overhangs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-867684689:625,refactor,refactoring,625,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-867684689,1,['refactor'],['refactoring']
Modifiability,"ts closer than a; chosen distance from the upper boundary. John. On Mon, Nov 23, 2020, 8:35 PM Ali Ramadhan <notifications@github.com> wrote:. > Some pretty promising Lagrangian particle tracking benchmarks!; >; > Couple of takeaways (all assuming a model with 128^3 grid points and QAB2; > time stepping):; >; > 1. *Low overhead*: You can advect up to ~100,000 particles on the CPU; > and up to ~10,000,000 particles on a (Titan V) GPU before the model slows; > down by more than 30%.; > 2. *Great on GPUs*: Seems that the GPU is great for advecting millions; > of particles. You can advect ~100,000,000 particles and your model only; > slows down by a factor of 4x. In this scenario, the GPU is ~620x faster; > than a single CPU core.; > 3. Calculated using (t_100000000 - t_0) / 100000000, advecting a; > single particle on the CPU takes ~110 ns while on the GPU it only takes; > ~0.127 ns. This seems a little too good to be true but I'll double check; > this.; >; > I'll start refactoring this PR using @glwagner; > <https://github.com/glwagner>'s and @zhenwu0728; > <https://github.com/zhenwu0728>'s feedback, but I think it would be; > really great if we can keep this performance.; > Benchmarks; >; > Oceananigans v0.44.1; > Julia Version 1.5.2; > Commit 539f3ce943 (2020-09-23 23:17 UTC); > Platform Info:; > OS: Linux (x86_64-pc-linux-gnu); > CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; > WORD_SIZE: 64; > LIBM: libopenlibm; > LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); > GPU: TITAN V; >; > Lagrangian particle tracking benchmarks; > ┌───────────────┬─────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; > │ Architectures │ N_particles │ min │ median │ mean │ max │ memory │ allocs │; > ├───────────────┼─────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; > │ CPU │ 0 │ 361.749 ms │ 364.041 ms │ 364.293 ms │ 368.854 ms │ 293.44 KiB │ 1876 │; > │ CPU │ 1 │ 375.030 ms │ 376.591 ms │ 377.959 ms │ 385.248 ms │ 29",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982:1181,refactor,refactoring,1181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982,1,['refactor'],['refactoring']
Modifiability,"uildkite-agent/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:1705; [17] (::Pkg.Operations.var""#115#120""{Dict{String, Any}, Bool, Bool, Bool, Pkg.Operations.var""#130#134""{Bool, Cmd, Cmd, Nothing, Pkg.Types.Context, Vector{Tuple{String, Base.Process}}, String, Pkg.Types.PackageSpec}, Pkg.Types.Context, Pkg.Types.PackageSpec, String, Pkg.Types.Project, String})(tmp::String); @ Pkg.Operations /storage5/buildkite-agent/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:1794; [18] mktempdir(fn::Pkg.Operations.var""#115#120""{Dict{String, Any}, Bool, Bool, Bool, Pkg.Operations.var""#130#134""{Bool, Cmd, Cmd, Nothing, Pkg.Types.Context, Vector{Tuple{String, Base.Process}}, String, Pkg.Types.PackageSpec}, Pkg.Types.Context, Pkg.Types.PackageSpec, String, Pkg.Types.Project, String}, parent::String; prefix::String); @ Base.Filesystem ./file.jl:766; [19] mktempdir(fn::Function, parent::String); @ Base.Filesystem ./file.jl:762; [20] mktempdir; @ ./file.jl:762 [inlined]; [21] sandbox(fn::Function, ctx::Pkg.Types.Context, target::Pkg.Types.PackageSpec, target_path::String, sandbox_path::String, sandbox_project_override::Pkg.Types.Project; preferences::Dict{String, Any}, force_latest_compatible_version::Bool, allow_earlier_backwards_compatible_versions::Bool, allow_reresolve::Bool); @ Pkg.Operations /storage5/buildkite-agent/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:1752; [22] test(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing, force_latest_compatible_version::Bool, allow_earlier_backwards_compatible_versions::Bool, allow_reresolve::Bool); @ Pkg.Operations /storage5/buildkite-agent/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:1955; [23] test; @ /storage5/buildkite-agent/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:1899 [inlined]; [24] test(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; coverage::Bool, test_fn::Nothing, jul",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1988500458:5965,sandbox,sandbox,5965,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1988500458,1,['sandbox'],['sandbox']
Modifiability,"underlying issue. I think the issue here is that ""entrainment"" should not occur across low stratification regions. Thus this model for ""entrainment"" assumes the stratification is ""strong"". More generally, we are dividing the boundary layer into a convecting region and an entraining region. We identify the convecting region by `N² < 0`. However, in reality the convecting region should extend further down into regions of stable, but still weak stratification below the unstable region. The ""entraining"" layer is more properly where stratification significantly increases over the weakly stratified lower part of the convecting region. (This analysis is based on LES.) `RiBasedVerticalDiffusivity`'s formulation --- apart from being overly simple --- simply cannot cope with the complexity of real boundary layer structure because it is not truly non-local. Really addressing this issue (eg implementing a more physically accurate model of boundary layer structure) might require using a vertical integral instead of a 3D kernel. (We decided that because CATKE seems like a decent parameterization, it's not worth it to pursue those accuracy improvements). One way to fix the issue but retaining a 3D kernel is to change the way we estimate ""convecting"" and ""entraining"" regions. Those criteria are. https://github.com/CliMA/Oceananigans.jl/blob/94e99e1d5fb3d121a6d801a931987bb6ff59f20e/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_diffusivity.jl#L247-L248. If we introduce a new parameter, say `minimum_entrainment_buoyancy_frequency`, then we can modify this criteria to read. ```julia; convecting = N² < 0 # applies regardless of Qᵇ . N²_entrainment = minimum_entrainment_buoyancy_frequency; entraining = (N²_above < 0) & (N² > N²_entrainment) (Qᵇ > 0); ```. Now the user can determine `minimum_entrainment_buoyancy_frequency` to stabilize their model. Probably some default like `minimum_entrainment_buoyancy_frequency = 1e-7` would work for Earth-like situations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718:1618,parameteriz,parameterization,1618,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718,2,['parameteriz'],['parameterization']
Modifiability,"utflow speed may have caused some confusion here as it is neither the specified outflowing velocity, the outflowing velocity at the boundary point, or the outflowing velocity in the interior, but an approximation of bulk velocity advecting the interior solution to the boundary point (and its approximation is case specific).**. The next problem is that if the interior solution is outflowing and then switches to inflow it may have deviated from the external solution causing oscillations near the boundary. This is why we might want relaxation rather than specifying as described before. . What I have been calling the ""inflow_speed"" is $1/\tau$ because I don't see why the ""relaxation"" should be fixed and the user might want to change it. For example it seems to me it would be reasonable to pretend that the specified external velocity is a further halo point and upwind it into the actual boundary point. I believe sponge layers are both a different solution to over-specifying at the boundary, and a way to dampen the residual reflection/oscillation from the unwinding approximation. In the first case, the sponge has to be large enough to fully restore the interior solution to the external solution before the boundary, but in the latter, it can be smaller (so having a complicated boundary saves computational expense). . > 2. Constant or idealized inflows and outflows. I think the only real difference for these idealised cases is that you normally know that information will only travel away from one of the boundaries and so can specify the halo point with `Open`. With both of the cases shown above we also know that the mean outflowing velocity will be the same as the inflow so can approximate the ""bulk velocity"" as a constant instead of having to compute it (but we still can't specify the boundary points of the outflow because otherwise, perturbations generated in the interior wouldn't be able to escape). The other difference in this case is that we don't know the external sol",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1980880295:2076,layers,layers,2076,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1980880295,1,['layers'],['layers']
Modifiability,"ution using Oceananigans, and then illustrate embedding a high resolution domain inside that solution. A two-dimensional turbulent case would be sufficient. > To resolve this PR I could tidy up a simple matching scheme where we compute the mean outflow on the boundary and do a 1D advection for the boundary point, or relax to the external state if there is inflow. I think this shows how to use all parts of the new infrastructure, and is a satisfactory boundary condition for some cases. Would this be okay?. A simple matching scheme is a great place to start to justify changing the `Open` classification. > For example, in a nested case, this would prevent higher resolution eddies from exiting the domain without un-physically modifying the upstream solution. I apologize if this is just a problem with communication style, but I don't think this statement can possibly be correct. The above example seems to demonstrate, for example, that the cylinder wake can be represented well by _either_ making the domain large enough (with sponge layers), _or_ by using a better numerical method with a smaller domain. Basically this allows us to exclude statements like ""we can't model X flow"". The question is not whether or not we can represent the physics of a flow. The question is rather about representing the flow in a domain that is as small as possible / with optimal computational expense. We're pursuing performance optimization. Our language has to take the form ""this scheme allows us to reduce the sponge layer thickness by XX%"", or ""this scheme reduces the width of the near-boundary region where the interior physics are modified"". The statement ""this scheme does not unphysically modify the solution"" makes no sense to me. The presence of the open boundary is unphysical by definition... I personally don't need much convincing that a matching scheme of some kind is needed. I'm just confused about how all of the different pieces that seem to enter into nesting interact with one anoth",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2033120291:1300,layers,layers,1300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2033120291,2,['layers'],['layers']
Modifiability,"uts are constructed appropriately now, but the outputs still can't be written to NetCDF because the writer creates the variables with a different size:. ```julia; ERROR: LoadError: NetCDF error: size mismatch for variable 'op_sliced2' in file './sliced.nc'. Trying to write (2, 1, 6) elements while [2, 1, 4, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:943; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:954; [3] setindex!; @ ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:457 [inlined]; [4] setindex!(::NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:490; [5] setindex!(::NCDatasets.CFVariable{Float32, 4, NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/cfvariable.jl:732; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:1083,variab,variable,1083,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655,1,['variab'],['variable']
Modifiability,"veUtils]]; deps = [""Markdown""]; uuid = ""b77e0a4c-d291-57a0-90e8-8db25a27a240"". [[IteratorInterfaceExtensions]]; git-tree-sha1 = ""a3f24677c21f5bbe9d2a714f95dcd58337fb2856""; uuid = ""82899510-4779-5014-852e-03e436cf321d""; version = ""1.0.0"". [[JLD2]]; deps = [""DataStructures"", ""FileIO"", ""MacroTools"", ""Mmap"", ""Pkg"", ""Printf"", ""Reexport"", ""Requires"", ""TranscodingStreams"", ""UUIDs""]; git-tree-sha1 = ""d4962712594ec5d39e0b10745e44e3a06abec0d2""; uuid = ""033835bb-8acc-5ee8-8aae-3f567f8a3819""; version = ""0.4.4"". [[JLLWrappers]]; deps = [""Preferences""]; git-tree-sha1 = ""642a199af8b68253517b80bd3bfd17eb4e84df6e""; uuid = ""692b3bcd-3c85-4b1f-b108-f13ce0eb3210""; version = ""1.3.0"". [[JSON3]]; deps = [""Dates"", ""Mmap"", ""Parsers"", ""StructTypes"", ""UUIDs""]; git-tree-sha1 = ""65798ad6ddb0d7068f2b1885e0b0d876efca16f5""; uuid = ""0f8b85d8-7281-11e9-16c2-39a750bddbf1""; version = ""1.8.1"". [[KernelAbstractions]]; deps = [""Adapt"", ""CUDA"", ""Cassette"", ""InteractiveUtils"", ""MacroTools"", ""SpecialFunctions"", ""StaticArrays"", ""UUIDs""]; git-tree-sha1 = ""f16c8dfdd75ae4fa927fcf3aa71e1dbbd195befb""; uuid = ""63c18a36-062a-441e-b654-da1e3ab1ce7c""; version = ""0.5.5"". [[LLVM]]; deps = [""CEnum"", ""Libdl"", ""Printf"", ""Unicode""]; git-tree-sha1 = ""b616937c31337576360cb9fb872ec7633af7b194""; uuid = ""929cbde3-209d-540e-8aea-75f648917ca0""; version = ""3.6.0"". [[LazyArtifacts]]; deps = [""Pkg""]; git-tree-sha1 = ""4bb5499a1fc437342ea9ab7e319ede5a457c0968""; uuid = ""4af54fe1-eca0-43a8-85a7-787d91b784e3""; version = ""1.3.0"". [[LibCURL_jll]]; deps = [""LibSSH2_jll"", ""Libdl"", ""MbedTLS_jll"", ""Pkg"", ""Zlib_jll"", ""nghttp2_jll""]; git-tree-sha1 = ""897d962c20031e6012bba7b3dcb7a667170dad17""; uuid = ""deac9b47-8bc7-5906-a0fe-35ac56dc84c0""; version = ""7.70.0+2"". [[LibGit2]]; deps = [""Printf""]; uuid = ""76f85450-5226-5b5a-8eaa-529ad045b433"". [[LibSSH2_jll]]; deps = [""Libdl"", ""MbedTLS_jll"", ""Pkg""]; git-tree-sha1 = ""717705533148132e5466f2924b9a3657b16158e8""; uuid = ""29816b5a-b9ab-546f-933c-edad1886dfa8""; version = ""1.9.0+3"". [[Libdl]]; uuid = ""8f399da",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:7453,Adapt,Adapt,7453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Modifiability,"verdub.jl:0; # I truncated the huge error message here; ```. However, the nested calculation appears to work!:. ```julia; julia> dwpdz_nested = nested_calc(); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); │ └── domain: x ∈ [0.0, 150.0], y ∈ [0.0, 6000.0], z ∈ [-80.0, 0.0]; └── tree: ; * at (Center, Center, Center) via identity;    ├── 0.0009765625;    └── ∂zᵃᵃᶜ at (Center, Center, Center) via identity;       └── ComputedField located at (Center, Center, Face) of BinaryOperation at (Center, Center, Face); ComputedField located at (Center, Center, Center) of BinaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 514, 10); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); ├── operand: BinaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(dwpdz_nested). julia> using Adapt. julia> adapt(Array, interior(dwpdz_nested)); 1×512×8 view(OffsetArray(::Array{Float64,3}, 0:2, 0:513, 0:9), [1], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10 … 503, 504, 505, 506, 507, 508, 509, 510, 511, 512], [1, 2, 3, 4, 5, 6, 7, 8]) with eltype Float64:; [:, :, 1] =; 0.0262775 0.014948 0.00902569 0.00559831 0.00351427 0.00221792 0.00140318 0.000888719 … 0.000263472 0.000420913 0.000674128 0.00108572 0.00177041 0.00296775 0.00528696. [:, :, 2] =; 0.0156731 0.0110235 0.00720451 0.00461103 0.00293129 0.00185902 0.00117792 0.00074609 … 0.000915116 0.00144732 0.00229007 0.00362638 0.0057484 0.00911035 0.0143023. [:, :, 3] =; 0.00844536 0.00652392 0.00451369 0.00297425 0.00191676 0.00122263 0.000776137 0.000491594 … 0.00126331 0.00199147 0.00313408 0.00491472 0.00764863 0.0117137 0.0173591. [:, :, 4] =; 0.00263363 0.0021138 0.00150181 0.00100316 0.000649705 0.000414395 0.000262323 0.00016544 … 0.00117766 0.00185426 0.00291374 0.00455993 0.00707827 0.0108175 0.0160812. [:, :, 5] =; -0.002765",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:6088,Adapt,Adapt,6088,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011,1,['Adapt'],['Adapt']
Modifiability,"y=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced with min(Δz)=0.0106134, max(Δz)=0.12559. julia> . julia> . julia> const H_deep = H = underlying_grid.Lz; 2.9999999999999996. julia> const H_shelf = h = 0.5; 0.5. julia> const width_shelf = 100; 100. julia> . julia> shelf(x, y) = -(H + h)/2 - (H - h)/2 * tanh(y / width_shelf); shelf (generic function with 1 method). julia> bathymetry(x, y) = shelf(x, y); bathymetry (generic function with 1 method). julia> . julia> grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=-2.99e+00, max(h)=0.00e+00); ├── underlying_grid: 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0) regularly spaced with Δx=3.90625; ├── Bounded y ∈ [-300.0, 300.0] regularly spaced with Δy=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced with min(Δz)=0.0106134, max(Δz)=0.12559. julia> u = XFaceField(grid); 128×128×64 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0. julia> u = Field((Face, Center, Center), grid); 128×128×64 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152:1435,variab,variably,1435,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152,1,['variab'],['variably']
Modifiability,"you need to extend the same functions specifically for `scheme::AbstractUpwindBiasedAdvectionScheme` because of. https://github.com/CliMA/Oceananigans.jl/blob/74ce7d2248792560ea0c9286a3274c2dbacfabea/src/Advection/upwind_biased_reconstruction.jl#L92-L98. ```suggestion; @inline symmetric_interpolate_xᶠᵃᵃ(i, j, k, grid::XFlatGrid, scheme::AbstractUpwindBiasedAdvectionScheme, c) = @inbounds c[i, j, k]; @inline symmetric_interpolate_yᵃᶠᵃ(i, j, k, grid::YFlatGrid, scheme::AbstractUpwindBiasedAdvectionScheme, c) = @inbounds c[i, j, k]; @inline symmetric_interpolate_zᵃᵃᶠ(i, j, k, grid::ZFlatGrid, scheme::AbstractUpwindBiasedAdvectionScheme, c) = @inbounds c[i, j, k]. @inline symmetric_interpolate_xᶜᵃᵃ(i, j, k, grid::XFlatGrid, scheme::AbstractUpwindBiasedAdvectionScheme, u) = @inbounds c[i, j, k]; @inline symmetric_interpolate_yᵃᶜᵃ(i, j, k, grid::YFlatGrid, scheme::AbstractUpwindBiasedAdvectionScheme, v) = @inbounds c[i, j, k]; @inline symmetric_interpolate_zᵃᵃᶜ(i, j, k, grid::ZFlatGrid, scheme::AbstractUpwindBiasedAdvectionScheme, w) = @inbounds c[i, j, k]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2757#issuecomment-1279818970:12,extend,extend,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2757#issuecomment-1279818970,1,['extend'],['extend']
Modifiability,"y}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels ~/.julia/packages/CUDA/Tl08O/src/CUDAKernels.jl:103; [23] (::KernelAbstractions.Kernel{CUDA.CUDAKernels.CUDABackend, KernelAbstractions.NDIteration.StaticSize{…}, KernelAbstractions.NDIteration.StaticSize{…}, typeof(Oceananigans.BoundaryConditions.gpu__no_fill!)})(::OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{…}}, ::Vararg{Any}); @ CUDA.CUDAKernels ~/.j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2426,adapt,adapt,2426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,1,['adapt'],['adapt']
Modifiability,"~I've been getting the following error right at the end of docs on buildkite that I can't reproduce locally (and therefore have not been able to solve):~. ```julia; ┌ Error: 4 docstrings not included in the manual:; │ ; │ Oceananigans.TurbulenceClosures.Smagorinskys.DynamicCoefficient :: Union{Tuple{}, Tuple{Any}}; │ Oceananigans.TurbulenceClosures.Smagorinskys.SmagorinskyLilly :: Union{Tuple{}, Tuple{Any}, Tuple{Any, Any}}; │ Oceananigans.TurbulenceClosures.Smagorinskys.LillyCoefficient :: Union{Tuple{}, Tuple{Any}}; │ Oceananigans.TurbulenceClosures.Smagorinskys.Smagorinsky :: Union{Tuple{}, Tuple{TD}, Tuple{TD, Any}} where TD; │ ; │ These are docstrings in the checked modules (configured with the modules keyword); │ that are not included in canonical @docs or @autodocs blocks.; └ @ Documenter /storage5/buildkite-agent/.julia-18496/packages/Documenter/C1XEF/src/utilities/utilities.jl:44; ```. ~Anyone know what that's about? Those are the 4 new docstrings that I added, all in the `Smagorinskys` module.~. Nevermind, it appears I have solved it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2449552734:689,config,configured,689,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2449552734,1,['config'],['configured']
Modifiability,🕵️ https://github.com/JuliaGPU/Adapt.jl/pull/88,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445743138:31,Adapt,Adapt,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445743138,1,['Adapt'],['Adapt']
Performance," ######################################################################## 100.0%; &nbsp; | Building MPI ─→ `/storage7/buildkite-agent/.julia-2581/packages/MPI/b7MVG/deps/build.log`; &nbsp; | [ Info: using default MPI jll; &nbsp; | Building FFTW → `/storage7/buildkite-agent/.julia-2581/packages/FFTW/G3lSO/deps/build.log`; &nbsp; | Precompiling project...; &nbsp; | WARNING: Error during initialization of module GMP:; &nbsp; | ErrorException(""could not load library ""libgmp""; &nbsp; | libgmp.so: ELF load command past end of file""); &nbsp; | WARNING: Error during initialization of module LinearAlgebra:; &nbsp; | ErrorException(""could not load library ""libopenblas64_""; &nbsp; | libopenblas64_.so: ELF load command past end of file""); &nbsp; | ┌ Error: Error during initialization of module CHOLMOD; &nbsp; | │ exception =; &nbsp; | │ could not load library ""libcholmod""; &nbsp; | │ libopenblas64_.so.0: ELF load command past end of file; &nbsp; | │ Stacktrace:; &nbsp; | │ [1] dlopen(::String, ::UInt32; throw_error::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109; &nbsp; | │ [2] dlopen at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109 [inlined] (repeats 2 times); &nbsp; | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: LoadError: IOError: write: broken pipe (EPIPE); &nbsp; | Stacktrace:; &nbsp; | [1] uv_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:951; &nbsp; | [2] unsafe_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:1005; &nbsp; | [3] write(::Base.PipeEndpoint, ::",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:2785,load,load,2785,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['load'],['load']
Performance," ./Base.jl:386; [2] include(x::String); @ Oceananigans.Models.ShallowWaterModels ~/software/Oceananigans.jl/src/Models/ShallowWaterModels/ShallowWaterModels.jl:1; [3] top-level scope; @ ~/software/Oceananigans.jl/src/Models/ShallowWaterModels/ShallowWaterModels.jl:15; [4] include(mod::Module, _path::String); @ Base ./Base.jl:386; [5] include(x::String); @ Oceananigans.Models ~/software/Oceananigans.jl/src/Models/Models.jl:1; [6] top-level scope; @ ~/software/Oceananigans.jl/src/Models/Models.jl:20; [7] include(mod::Module, _path::String); @ Base ./Base.jl:386; [8] include(x::String); @ Oceananigans ~/software/Oceananigans.jl/src/Oceananigans.jl:1; [9] top-level scope; @ ~/software/Oceananigans.jl/src/Oceananigans.jl:179; [10] include; @ ./Base.jl:386 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:16; in expression starting at /home/fpoulin/software/Oceananigans.jl/src/Models/ShallowWaterModels/ShallowWaterModels.jl:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/src/Models/Models.jl:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /home/fpoulin/.julia/compiled/v1.6/Oceananigans/jl_cnHalv.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _r",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-843316815:1568,load,loading,1568,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-843316815,1,['load'],['loading']
Performance," ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_zRopeZ"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/o",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:2933,Load,LoadError,2933,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['Load'],['LoadError']
Performance," 35.4428 │ 450.0 │ 224.5 │; │ 256 │ (Bounded, Periodic, Bounded) │ 36.8697 │ 368.4 │ 320.5 │; │ 256 │ (Periodic, Bounded, Bounded) │ 37.0953 │ 369.6 │ 323.5 │; │ 256 │ (Periodic, Periodic, Bounded) │ 53.4034 │ 179.0 │ 146.0 │; └─────┴───────────────────────────────┴─────────┴────────┴────────┘; ```. ### CPU relative performance. ```; FFT-based Poisson solver relative performance (CPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.61224 │ 1.2 │ 2.0 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.34917 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.35141 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴────────┴────────┘; ```. ### GPU relative performance. ```; FFT-based Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 2.42923 │ 3.01676 │ 3.07534 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.95419 │ 2.0581 │ 2.19521 │; │ GPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.94553 │ 2.0648 │ 2.21575 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴─────────┴─────────┘; ```. ---. ## System info. ```; Oceananigans v0.50.0; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23:17 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); GPU: TITAN V; `",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:12412,perform,performance,12412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050,1,['perform'],['performance']
Performance, : 3; Device Max : 3; Host Max : 3; Link Width; Max : 16x; Current : 16x; Bridge Chip; Type : N/A; Firmware : N/A; Replays Since Reset : 0; Replay Number Rollovers : 0; Tx Throughput : 0 KB/s; Rx Throughput : 0 KB/s; Atomic Caps Inbound : N/A; Atomic Caps Outbound : N/A; Fan Speed : N/A; Performance State : P0; Clocks Throttle Reasons; Idle : Active; Applications Clocks Setting : Not Active; SW Power Cap : Not Active; HW Slowdown : Not Active; HW Thermal Slowdown : Not Active; HW Power Brake Slowdown : Not Active; Sync Boost : Not Active; SW Thermal Slowdown : Not Active; Display Clock Setting : Not Active; FB Memory Usage; Total : 32768 MiB; Reserved : 267 MiB; Used : 0 MiB; Free : 32500 MiB; BAR1 Memory Usage; Total : 32768 MiB; Used : 2 MiB; Free : 32766 MiB; Compute Mode : Default; Utilization; Gpu : 0 %; Memory : 0 %; Encoder : 0 %; Decoder : 0 %; Encoder Stats; Active Sessions : 0; Average FPS : 0; Average Latency : 0; FBC Stats; Active Sessions : 0; Average FPS : 0; Average Latency : 0; Ecc Mode; Current : Enabled; Pending : Enabled; ECC Errors; Volatile; Single Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : N/A; Total : 0; Double Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : 0; Total : 0; Aggregate; Single Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : N/A; Total : 0; Double Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : 0; Total : 0; Retired Pages; Single Bit ECC : 0; Double Bit ECC : 0; Pending Page Blacklist : No; Remapped Rows : N/A; Temperature; GPU Current Temp : 41 C; GPU Shutdown Temp : 90 C; GPU Slowdown Temp : 87 C; GPU Max Operating Temp : 83 C; GPU Target Temperature : N/A; Memory Current Temp : 44 C; Memory Max Operating Temp : 85 C; Power Readings; Powe,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:21269,Latency,Latency,21269,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Latency'],['Latency']
Performance," ; > > ; > > But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us).; > ; > I agree. If we try using whatever closure here that is used in the hydrostatic model, I would think that it should yield a similar result. But that's maybe better saved for a future PR?. Let me clarify. We've never run the hydrostatic model with a single layer on the sphere, but this is a good idea. Most of our runs have been with 50 vertical levels. In the 3D configuration with 50 vertical levels, we smooth results with 1) WENO5 vector invariant advection and 2) biharmonic ""divergence damping"" of the divergence component of the flow. If we are going to compare the shallow water on a sphere to they hydrostatic model, we will have to produce additional runs with just 1 vertical level. In other words, there are no results to compare with right now. When we perform additional runs, we may choose to include divergence damping, or another kind of closure, if we want to. The results presented in #2317 also use a single layer hydrostatic model, and these did not require any explicit dissipation. Therefore, there is reason to believe that divergence damping is only required for 3D simulations. An additional point is that in the shallow water equations we can introduce a WENO reconstruction of the mass flux. This reconstruction may provide divergence damping (whether or not we need it!). In summary, if we would like to perform a comparison, we can choose to either 1) produce a comparison between the shallow water model and one layer hydrostatic model with no explicit closure on the sphere or 2) run new 1 layer hydrostatic simulations with some closure (of our choosing) and then _also_ implement that closure in the shallow water model. My opinion is that with these nice WENO5 numerics there may not be a need for using explicit dissipation right now, so we might as well do the easy thing and avoid it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226:1624,perform,perform,1624,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226,2,['perform'],['perform']
Performance," AMDGPU.Compiler.HIPCompilerParams}})(); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:139; [5] lock(f::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}, l::ReentrantLock); @ Base ./lock.jl:229; [6] macro expansion; @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:86 [inlined]; [11] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:129; [12] codegen; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:110 [inlined]; [13] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:106; [14] compile; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:98 [inlined]; [15] #40; @ ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:140 [inlined]; [16] JuliaContext(f::AMDGPU.Compiler.var""#40#41""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:47; [17] hipcompile(job::GPUCompiler.CompilerJob); @ AMDGPU.Compiler ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:139; [18] actual_compilation(cache::Dict{Any, AMDGPU.H",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273:1827,optimiz,optimize,1827,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273,2,['optimiz'],['optimize']
Performance," D] + \delta_j V}^i \right)\frac{\boldsymbol{i}}{b_u} +v\left( \overline{ \delta_i U + [\delta_j V; D] }^j \right)\frac{\boldsymbol{j}}{b_v}$; - kinetic energy gradient: $\left(\overline{[\delta_i u^2; u]}^i + \delta_i \overline{v^2}^j \right)\frac{\boldsymbol{i}}{\Delta x_u} + \left(\delta_j \overline{u^2}^i + \overline{[\delta_j v^2; v]}^j\right) \frac{\boldsymbol{j}}{\Delta y_v}$. #### `CrossAndSelfUpwinding`. - divergence flux: $u \overline{[D; D]}^i \frac{\boldsymbol{i}}{b_u}+ v \overline{ [D; D] }^j\frac{\boldsymbol{j}}{b_v}$; - kinetic energy gradient: $\left(\overline{[\delta_i u^2; u]}^i + \delta_i \overline{v^2}^j\right) \frac{\boldsymbol{i}}{\Delta x_u} + \left(\delta_j \overline{u^2}^i + \overline{[\delta_j v^2; v]}^j\right) \frac{\boldsymbol{j}}{\Delta y_v}$. #### `VelocityUpwinding`. - divergence flux: $u \left( \delta_i \overline{[U; U]}^i + \overline{\delta_j V}^i \right)\frac{\boldsymbol{i}}{b_u}+ v\left( \overline{ \delta_i U} + \delta_j\overline{[V; V] }^j \right) \frac{\boldsymbol{j}}{b_v}$; - kinetic energy gradient: $\left(\delta_i \overline{[u^2; u^2]}^i + \delta_i \overline{v^2}^j\right)\frac{\boldsymbol{i}}{\Delta x_u}+ \left(\delta_j \overline{u^2}^i + \delta_j \overline{[v^2; v^2]}^j\right) \frac{\boldsymbol{j}}{\Delta y_v}$. #### For all three formulations; - vertical advection: $\delta_k \left(\overline{W}^i \overline{[u; u]}^k \right)\frac{\boldsymbol{i}}{b_u} + \delta_k \left( \overline{W}^j \overline{[v; v]}^k\right) \frac{\boldsymbol{j}}{b_v}$. where $D = \delta_i U + \delta_j V$, $U = Ax \cdot u$, $V = Ay \cdot v$, $W = Az \cdot w$ and $b = \Delta x \cdot \Delta y \cdot \Delta z$. $[u; v]$ refers to a WENO biased reconstruction of $u$ using $v$ as a smoothness measure. Upwinding is always performed with respect to the velocity corresponding to the reconstruction direction. ; i.e.: reconstructions in $i$ upwind with respect to $u$, reconstructions in $j$ upwind with respect to $v$ and reconstructions in $k$ upwind with respect to $w$",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1577285777:1925,perform,performed,1925,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1577285777,1,['perform'],['performed']
Performance," PDE in a user's model, and there's no way to pull out intermediate steps in that calculation to use elsewhere. It's important to note when considering optimization strategies that our computations are probably memory-limited, rather than compute-limited. In other words, we think the process of transferring data from global memory to local thread memory is a bottleneck for our computations (we can really only know this through profiling a particular application, however, since all models are different...) Storing intermediate components of the tendency terms would probably create more memory accesses overall (since rather than immediately using intermediate results for subsequent calculations, we would have to send them to global memory, and then back, to complete the evaluation of a tendency) --- and thus could slow down tendency evaluations that are performed 1-3 times per time-step. For example, our best idea for speeding up tendency evaluations is to better manage memory movement using GPU shared memory (unfortunately, we haven't had the time to explore such optimization strategies...). I think there may be other ways to optimize diagnostics calculations, however. # Fusing `ComputedField` kernels. One possibility to speed up diagnostics is to ""fuse"" kernels for different `ComputedField` diagnostics. The kernel for a `ComputedField` is. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/Fields/computed_field.jl#L112-L115. where `operand` is an `AbstractOperation`. But different `ComputedField`s may somehow depend on the same underlying data in memory. Thus if the kernels for differnet `ComputedField`s are fused into one, we overlap memory accesses for different computations. Our computations are usually memory-limited... so its possible this strategy could produce significant speed ups. For example, for two `ComputedField`s we might have something like. ```julia; function compute!(field1, field2); # calls _compute_two(field1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837:1411,optimiz,optimization,1411,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837,1,['optimiz'],['optimization']
Performance," Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: LoadError: LoadError: UndefVarError: NFBC not defined; Stacktrace:; [1] top-level scope; @ ~/Research/OC/src/BoundaryConditions/apply_flux_bcs.jl:23; [2] include(mod::Module, _path::String); @ Base ./Base.jl:386; [3] include(x::String); @ Oceananigans.BoundaryConditions ~/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:1; [4] top-level scope; @ ~/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:45; [5] include(mod::Module, _path::String); @ Base ./Base.jl:386; [6] include(x::String); @ Oceananigans ~/Research/OC/src/Oceananigans.jl:1; [7] top-level scope; @ ~/Research/OC/src/Oceananigans.jl:173; [8] include; @ ./Base.jl:386 [inlined]; [9] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1213; [10] top-level scope; @ none:1; [11] eval; @ ./boot.jl:360 [inlined]; [12] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [13] top-level scope; @ none:1; in expression starting at /Users/navid/Research/OC/src/BoundaryConditions/apply_flux_bcs.jl:23; in expression starting at /Users/navid/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:1; in expression starting at /Users/navid/Research/OC/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_fSB7qw.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-877746334:1840,load,loading,1840,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-877746334,5,['load'],['loading']
Performance," [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/src/Solvers/Solvers.jl:48; [11] include(mod::Module, _path::String); @ Base ./Base.jl:384; [12] include(x::String); @ Oceananigans ~/Research/OC.jl/src/Oceananigans.jl:5; [13] top-level scope; @ ~/Research/OC.jl/src/Oceananigans.jl:195; [14] include; @ ./Base.jl:384 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1235; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:360 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [19] top-level scope; @ none:1; during initialization of module AMGX; in expression starting at /Users/navid/Research/OC.jl/src/Solvers/multigrid_so",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:2433,load,loading,2433,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987,1,['load'],['loading']
Performance," [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/src/Solvers/Solvers.jl:48; [11] include(mod::Module, _path::String); @ Base ./Base.jl:384; [12] include(x::String); @ Oceananigans ~/Research/OC.jl/src/Oceananigans.jl:5; [13] top-level scope; @ ~/Research/OC.jl/src/Oceananigans.jl:195; [14] include; @ ./Base.jl:384 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1235; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:360 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [19] top-level scope; @",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:2308,load,loading,2308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987,1,['load'],['loading']
Performance," [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/Oceananigans/jl_k7YOZN"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:5530,Load,LoadError,5530,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['Load'],['LoadError']
Performance," `] status -m`?. Was there anything more printed above the message that precompilation; failed?. One thing you might want to try is using Julia 1.10, instead of 1.9, but; right now I don't have information to pinpoint what is causing the; segmentation fault. On Wed, Jul 17, 2024, 12:23 Logan Knudsen ***@***.***> wrote:. > Update: I have been able to reduce the error to be a procompiling error in; > oceananigans.jl:; >; > ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); > @ Base ./loading.jl:2300; > [3] compilecache; > @ ./loading.jl:2167 [inlined]; > [4] _require(pkg::Base.PkgId, env::String); > @ Base ./loading.jl:1805; > [5] _require_prelocked(uuidkey::Base.PkgId, env::String); > @ Base ./loading.jl:1660; > [6] macro expansion; > @ ./loading.jl:1648 [inlined]; > [7] macro expansion; > @ ./lock.jl:267 [inlined]; > [8] require(into::Module, mod::Symbol); > @ Base ./loading.jl:1611; > in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; >; > I have been trying to make sure that everything is up to date, and I am; > running on Julia version 1.9.2. My code is just; >; > using Oceananingans; >; > as I have been trying to get the library to loas properly. Does anyone; > have any experience with this error or does it make things any clearer?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XAIMUIHCDCBIJA4NLZM2K75AVCNFSM6AAAAABK643UJWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDEMZTG4YTAMZXGI>; > .; > You are receiving this because you commented.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098:1085,load,loading,1085,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098,6,['load'],['loading']
Performance," ```; ERROR: LoadError: Enzyme cannot deduce type; Current scope:; ; Function Attrs: mustprogress nofree readonly willreturn; define ""enzyme_type""=""{[0]:Integer, [1]:Integer, [2]:Integer, [3]:Integer, [4]:Integer, [5]:Integer, [6]:Integer, [7]:Integer, [8]:Integer, [9]:Integer, [10]:Integer, [11]:Integer, [12]:Integer, [13]:Integer, [14]:Integer, [15]:Integer, [16]:Integer, [17]:Integer, [18]:Integer, [19]:Integer, [20]:Integer, [21]:Integer, [22]:Integer, [23]:Integer, [24]:Integer, [25]:Integer, [26]:Integer, [27]:Integer, [28]:Integer, [29]:Integer, [30]:Integer, [31]:Integer, [32]:Integer, [33]:Integer, [34]:Integer, [35]:Integer, [36]:Integer, [37]:Integer, [38]:Integer, [39]:Integer, [40]:Integer, [41]:Integer, [42]:Integer, [43]:Integer, [44]:Integer, [45]:Integer, [46]:Integer, [47]:Integer, [48]:Float@double, [56]:Float@double, [64]:Float@double, [72]:Float@double, [80]:Float@double, [88]:Float@double, [96]:Float@double, [104]:Float@double, [112]:Float@double, [120]:Integer, [121]:Integer, [122]:Integer, [123]:Integer, [124]:Integer, [125]:Integer, [126]:Integer, [127]:Integer, [128]:Integer, [129]:Integer, [130]:Integer, [131]:Integer, [132]:Integer, [133]:Integer, [134]:Integer, [135]:Integer, [136]:Integer, [137]:Integer, [138]:Integer, [139]:Integer, [140]:Integer, [141]:Integer, [142]:Integer, [143]:Integer, [144]:Float@double, [152]:Float@double, [160]:Float@double, [168]:Float@double, [176]:Integer, [177]:Integer, [178]:Integer, [179]:Integer, [180]:Integer, [181]:Integer, [182]:Integer, [183]:Integer, [184]:Integer, [185]:Integer, [186]:Integer, [187]:Integer, [188]:Integer, [189]:Integer, [190]:Integer, [191]:Integer, [192]:Integer, [193]:Integer, [194]:Integer, [195]:Integer, [196]:Integer, [197]:Integer, [198]:Integer, [199]:Integer, [200]:Float@double, [208]:Float@double, [216]:Float@double, [224]:Float@double, [232]:Float@double, [240]:Float@double, [248]:Integer, [249]:Integer, [2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436402140:78,Load,LoadError,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436402140,1,['Load'],['LoadError']
Performance," allocs │; ├───────────────┼─────┼────────────────────────────────┼──────────┼─────────┼─────────┤; │ CPU │ 192 │ (Bounded, Bounded, Bounded) │ 1.34309 │ 1.46266 │ 1.48014 │; │ CPU │ 192 │ (Bounded, Bounded, Periodic) │ 1.25281 │ 1.30927 │ 1.30084 │; │ CPU │ 192 │ (Bounded, Periodic, Bounded) │ 1.05249 │ 1.30927 │ 1.30084 │; │ CPU │ 192 │ (Bounded, Periodic, Periodic) │ 1.07645 │ 1.14247 │ 1.08664 │; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 1.0409 │ 1.30927 │ 1.30084 │; │ CPU │ 192 │ (Periodic, Bounded, Periodic) │ 0.938853 │ 1.14247 │ 1.08664 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 1.17749 │ 1.14247 │ 1.08664 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. ## GPU slowdown (vs. triply-periodic). ```; Topologies relative performance (GPU); ┌───────────────┬─────┬────────────────────────────────┬──────────┬──────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼──────────┼──────────┼─────────┤; │ GPU │ 192 │ (Bounded, Bounded, Bounded) │ 2.22277 │ 0.965821 │ 1.70133 │; │ GPU │ 192 │ (Bounded, Bounded, Periodic) │ 1.82308 │ 0.980729 │ 1.496 │; │ GPU │ 192 │ (Bounded, Periodic, Bounded) │ 1.82349 │ 0.984497 │ 1.4736 │; │ GPU │ 192 │ (Bounded, Periodic, Periodic) │ 2.26462 │ 0.989389 │ 1.24018 │; │ GPU │ 192 │ (Periodic, Bounded, Bounded) │ 1.82237 │ 0.984695 │ 1.47467 │; │ GPU │ 192 │ (Periodic, Bounded, Periodic) │ 1.54676 │ 0.992331 │ 1.25653 │; │ GPU │ 192 │ (Periodic, Periodic, Bounded) │ 1.30183 │ 0.99405 │ 1.22631 │; │ GPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴──────────┴─────────┘; ```. # Performance vs. main branch. ## Main branch. ```; Topologies benchmarks; ┌───────────────┬─────┬────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬─",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:9976,perform,performance,9976,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296,2,['perform'],['performance']
Performance," based on latitude easily.; > ; > Questions:; > ; > * Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); > * I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?. For API this is what I suggest:. Three ""modes"":. 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south). The code might look something like. ```julia; zero_if_nothing(f) = f; zero_if_nothing(::Nothing) = 0. function ConstantBackgroundRotation(FT=Float64; fx=nothing, fy=nothing, fz=nothing, rotation_rate=Ω_Earth, rotation_axis=nothing, latitude=nothing). if latitude !=nothing; isnothing(rotation_axis) && throw(ArgumentError(""Cannot specify latitude and rotation axis."")); all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify latitude and (fx, fy, fz)."")); # calculate rotation axis; end. if rotation_axis != nothing; all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify rotation_axis and (fx, fy, fz)."")); # calculate fx, fy, fz; end. fx, fy, fz = zero_if_nothing.((fx, fy, fz)) # set default fx, fy, fz. return ConstantBackgroundRotation(FT(fx), FT(fy), FT(fz)); end; ```. There's also the possibility of a somewhat minor optimization by keeping the possibility that `fx, fy, fz` might be `nothing`, and eliding the associated Coriolis operations in kernel functions for that case. This requires the struct to accomodate different types for each of them. I think `GeneralFPlane` is ambiguous, so I propose using a more specific name.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990:2335,optimiz,optimization,2335,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990,2,['optimiz'],['optimization']
Performance," example:. ```julia; julia> a, b, c = (CenterField(GPU(), grid) for i = 1:3); Base.Generator{UnitRange{Int64}, var""#5#6""}(var""#5#6""(), 1:3). julia> @time a .= b + c; 0.929868 seconds (180.70 k allocations: 11.424 MiB, 99.79% compilation time). julia> @time a .= b + c; 0.924904 seconds (159.14 k allocations: 10.031 MiB, 99.79% compilation time); ```. Note that if we avoid constructing an `AbstractOperation` we get. ```julia; julia> @time a .= b .+ c; 1.339598 seconds (2.24 M allocations: 127.662 MiB, 2.91% gc time, 47.98% compilation time). julia> @time a .= b .+ c; 0.000280 seconds (180 allocations: 41.109 KiB); ```. Then I noticed this:. ```julia; julia> a_plus_1 = a + 1; BinaryOperation at (Center, Center, Center); ├── grid: RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded}; domain: longitude λ ∈ [-10.0, 10.0], latitude ∈ [0.0, 45.0], z ∈ [-1000.0, 0.0]; topology: (Bounded, Bounded, Bounded); size (Nx, Ny, Nz): (512, 512, 32); halo (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δλ, Δφ, Δz): (0.0390625, 0.087890625, 31.25); │ └── domain: longitude λ ∈ [-10.0, 10.0], latitude ∈ [0.0, 45.0], z ∈ [-1000.0, 0.0]; └── tree: ; + at (Center, Center, Center);    ├── Field located at (Center, Center, Center);    └── 1. julia> a .= a_plus_1. julia> @time a .= a_plus_1; 1.674752 seconds (2.22 M allocations: 127.371 MiB, 2.18% gc time, 56.65% compilation time). julia> @time a .= a_plus_1; 0.280226 seconds (17.11 k allocations: 1.104 MiB, 99.87% compilation time). julia> @time a .= a_plus_1; 1.525796 seconds (2.22 M allocations: 127.356 MiB, 2.15% gc time, 51.88% compilation time). julia> @time a .= a_plus_1; 0.294972 seconds (17.11 k allocations: 1.104 MiB, 99.88% compilation time). julia> @time a .= a_plus_1; 0.000274 seconds (170 allocations: 35.438 KiB). julia> @time a .= a_plus_1; 0.000274 seconds (170 allocations: 35.438 KiB); ```. Basically the compiler is ""stubborn"" and only caches our method after many tries... might be worth an issue on `KernelAbstractions.jl`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958603853:2060,cache,caches,2060,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958603853,1,['cache'],['caches']
Performance," functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells.; > ; > I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. Quick question: Have you checked the performance here? I ask because the model was running pretty slowly when I was testing https://github.com/CliMA/Oceananigans.jl/pull/2275...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847:2247,perform,performance,2247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847,2,['perform'],['performance']
Performance," important changes:. * I removed the `BackgroundField` v-velocity, which had no effect on the solution because the domain is `Flat` in y. The only effect of the background flow is through the bottom drag boundary condition.; * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Minor changes:. * Update style to be consistent with other examples / source code (commas, spaces, etc); * Reorganized the script to read like the other examples / tutorials (like a paper, parameters are introduced when they are used rather than at the top); * Reorganized a few other misc stuff for pedagogical reasons, like building buoyancy + coriolis together; * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; * Change tilting angle to 3 degrees rather than 0.05 radians; * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated); * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity; * Plotting fewer contours makes the animation faster (the most expensive part of this example); * We don't need to form `Field`s any more for the output writers any more. Idle thoughts:. * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?; * Can we tilt the visualization? It's disorienting to be looking at the flow at an angle of 3 ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449:1201,perform,perform,1201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449,1,['perform'],['perform']
Performance," infrastructure, and is a satisfactory boundary condition for some cases. Would this be okay?. A simple matching scheme is a great place to start to justify changing the `Open` classification. > For example, in a nested case, this would prevent higher resolution eddies from exiting the domain without un-physically modifying the upstream solution. I apologize if this is just a problem with communication style, but I don't think this statement can possibly be correct. The above example seems to demonstrate, for example, that the cylinder wake can be represented well by _either_ making the domain large enough (with sponge layers), _or_ by using a better numerical method with a smaller domain. Basically this allows us to exclude statements like ""we can't model X flow"". The question is not whether or not we can represent the physics of a flow. The question is rather about representing the flow in a domain that is as small as possible / with optimal computational expense. We're pursuing performance optimization. Our language has to take the form ""this scheme allows us to reduce the sponge layer thickness by XX%"", or ""this scheme reduces the width of the near-boundary region where the interior physics are modified"". The statement ""this scheme does not unphysically modify the solution"" makes no sense to me. The presence of the open boundary is unphysical by definition... I personally don't need much convincing that a matching scheme of some kind is needed. I'm just confused about how all of the different pieces that seem to enter into nesting interact with one another --- sponge layers, matching scheme, and also the particular physics of the flow in question (idealized in and outflows vs true nesting). With so many degrees of freedom and complexity I think a systematic approach is absolutely essential. I really hope that the outcome of this work are a set of solid recommendations for nesting (better yet, a recipe that does not have to be changed --- a recommended matching sc",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2033120291:1669,perform,performance,1669,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2033120291,4,"['optimiz', 'perform']","['optimization', 'performance']"
Performance," makes some significant source code changes for what I think is a rather narrow application, which is disproportional compared to most of the other features we have I think. > If for some reason we cannot use a forcing function approach, we'll have to think carefully about how to design a flexible user API for ""particle-induced tracer forcing"". I think if we are going to add this then it should be more general than just a source/sink calculation --- ie, we should attempt to have a small source code addition that makes a wide range of new behavior possible, if we can. I've reconsidered this now and think we may not even need any source code change to properly implement this behaviour and integrate some particle induced tracer forcing. If we have a model with some tracers `(:A, :B)` which we want to force with some particles, we can define an auxiliary field `G\_p=TracerFields((:A, :B), grid)`. We can then have a particle dynamics function that modifies `model.auxiliary_fields.G\_p`, for example sets the points surrounding the particles to `-A[i, j, k]` for `A`, and `+A[i, j, k]` for `B` like in my example above. You can then define a discrete forcing function for each of the tracers like `a_forcing(i, j, k, grid, clock, model_fields) = model_fields.G\_p.A[i, j, k]` etc. (this would only work with my other PR #2733 added so that the `auxiliary_fields` are available). > It seems the memory requirement of the forcing function approach is proportional to the number of tracers, not the number of particles --- right? We would nee an ""auxiliary tendency"" for every tracer; the memory requirement doesn't change based on the number of particles. My reservation with this was that if there's e.g. 1 particle effecting loads of tracers you have to store lots more fields, but I see now that this is much less of an issue. Sorry about making this much more complicated than it should have been!. Edit: updated the gist example with how this can be implemented (requires PR #2733 branch)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312:1958,load,loads,1958,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312,1,['load'],['loads']
Performance," mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_zRopeZ"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_ag",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:3260,load,loading,3260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance," mostly a matter of choice (if the reconstruction is performed correctly for all stencils!). The general way to do this is to make them functions of a ""local smoothness indicator"" <img src=""https://render.githubusercontent.com/render/math?math=\beta_r""> which is calculated as such; <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r} = \sum_{l=1}^k \int_{x_{i-1/2}}^{x_{i %2B 1/2}} \Delta x^{2l -1} \left( \frac{\partial^l p_r(x)}{\partial x^l} \right)^2 dx""> . These <img src=""https://render.githubusercontent.com/render/math?math=\beta_r""> simplify quite nicely for uniform grids. the `streched_smoothness=true` option calculates the coefficients of these smoothness indicators for a stretched grid, by assuming that (<img src=""https://render.githubusercontent.com/render/math?math=k = 2"">). Then the weights are calculated as such; <img src=""https://render.githubusercontent.com/render/math?math=w_{r} = \frac{\alpha_r}{\alpha_0 %2B \alpha_1 %2B \alpha_2}""> . where <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r""> depends on the scheme used and differs between JS-WENO and Z-WENO. In the former; <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r = \frac{d_r}{(\beta_r %2B \varepsilon)^2}"">; In the latter ; <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r = d_r \left[ 1 %2B \left( \frac{ \left |\beta_2 - \beta_0 \right|}{\beta_r %2B \varepsilon} \right)^2 \right] "">; <img src=""https://render.githubusercontent.com/render/math?math=d_r""> are optimized constants equal in both the schemes. the `zweno = true` flag just switches between these two formulations. Now, I believe that `stretched_smoothness` does not have a such big impact because if you assure that the reconstruction is correct, then all stencil correctly interpolate to the face and weights will still be between 0 and 1. This might be more impactful for grids that are much more non-uniform (or ""irregular"") than what we usually use.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397:3530,optimiz,optimized,3530,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397,2,['optimiz'],['optimized']
Performance," of file""); &nbsp; | ┌ Error: Error during initialization of module CHOLMOD; &nbsp; | │ exception =; &nbsp; | │ could not load library ""libcholmod""; &nbsp; | │ libopenblas64_.so.0: ELF load command past end of file; &nbsp; | │ Stacktrace:; &nbsp; | │ [1] dlopen(::String, ::UInt32; throw_error::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109; &nbsp; | │ [2] dlopen at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109 [inlined] (repeats 2 times); &nbsp; | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: LoadError: IOError: write: broken pipe (EPIPE); &nbsp; | Stacktrace:; &nbsp; | [1] uv_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:951; &nbsp; | [2] unsafe_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:1005; &nbsp; | [3] write(::Base.PipeEndpoint, ::String) at ./strings/io.jl:183; &nbsp; | [4] create_expr_cache(::String, ::String, ::Array{Pair{Base.PkgId,UInt64},1}, ::Base.UUID) at ./loading.jl:1194; &nbsp; | [5] compilecache(::Base.PkgId, ::String) at ./loading.jl:1286; &nbsp; | [6] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [7] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [8] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [9] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [10] include at ./Base.jl:368 [inlined]; &nbsp; | [11] include(::String) at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:1; &nbsp; | [12] top-level scope at /storage7/buildkite-agent/.julia-2581/packages",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:3526,load,load,3526,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,3,"['Load', 'load']","['LoadError', 'load']"
Performance," runtime_module(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/interface.jl:173; [3] build_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:101; [4] (::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}})(); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:139; [5] lock(f::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}, l::ReentrantLock); @ Base ./lock.jl:229; [6] macro expansion; @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:86 [inlined]; [11] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:129; [12] codegen; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:110 [inlined]; [13] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:106; [14] compile; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:98 [inlined]; [15] #40; @ ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:140 [inlined]; [16] JuliaContext(f::AMDGPU.Compiler.var""#40#41""{GPUCompiler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273:1521,optimiz,optimize,1521,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273,2,['optimiz'],['optimize']
Performance," search: plan_fft plan_fft! plan_rfft plan_ifft plan_bfft plan_ifft! plan_bfft! plan_irfft plan_brfft. plan_fft(A [, dims]; flags=FFTW.ESTIMATE, timelimit=Inf). Pre-plan an optimized FFT along given dimensions (dims) of arrays matching the shape and type of A. (The first two arguments have the same meaning as for fft.) Returns an object P which; represents the linear operator computed by the FFT, and which contains all of the information needed to compute fft(A, dims) quickly. To apply P to an array A, use P * A; in general, the syntax for applying plans is much like that of matrices. (A plan can only be applied to arrays of the same size as the A for which; the plan was created.) You can also apply a plan with a preallocated output array Â by calling mul!(Â, plan, A). (For mul!, however, the input array A must be a complex floating-point; array like the output Â.) You can compute the inverse-transform plan by inv(P) and apply the inverse plan with P \ Â (the inverse plan is cached and reused for subsequent calls to inv or; \), and apply the inverse plan to a pre-allocated output array A with ldiv!(A, P, Â). The flags argument is a bitwise-or of FFTW planner flags, defaulting to FFTW.ESTIMATE. e.g. passing FFTW.MEASURE or FFTW.PATIENT will instead spend several seconds (or more) benchmarking; different possible FFT algorithms and picking the fastest one; see the FFTW manual for more information on planner flags. The optional timelimit argument specifies a rough upper bound on; the allowed planning time, in seconds. Passing FFTW.MEASURE or FFTW.PATIENT may cause the input array A to be overwritten with zeros during plan creation. plan_fft! is the same as plan_fft but creates a plan that operates in-place on its argument (which must be an array of complex floating-point numbers). plan_ifft and so on are similar; but produce plans that perform the equivalent of the inverse transforms ifft and so on. help?> plan_fft!; search: plan_fft! plan_ifft! plan_bfft! plan_fft plan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471179127:1066,cache,cached,1066,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471179127,1,['cache'],['cached']
Performance," second _branch_ isn't executed at all. On the other hand. ```julia; julia> g(a, first) = ifelse(first, a[1], a[2]); g (generic function with 1 method). julia> g(a, true); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If we use short-circuiting logic, then I guess many optimizations are not possible, because execution on one branch or another must be completely excluded. Some of this is discussed here: https://discourse.julialang.org/t/multiplying-by-booleans-faster-than-if-else/64117. > What about @inline?. This a little hazier. The compiler decides based on a heuristic whether or not to ""inline"" a function (meaning, rather than compiling code for a function independently and jumping to that code at the right moment, it combines the function code with the code that calls the function). We want to inline everything basically, so that every tendency evaluation involves evaluating one giant function. Inlining lets LLVM magic optimize our code to the highest degree (at least that's my impression). For whatever reason the compiler often decides _not_ to inline our functions unless we spec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:1866,optimiz,optimize,1866,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583,1,['optimiz'],['optimize']
Performance," slowdown │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼──────────┼──────────┼────────┤; │ CPU │ 192 │ (Bounded, Bounded, Bounded) │ 2.76522 │ 1.0 │ 1.0 │; │ CPU │ 192 │ (Bounded, Bounded, Periodic) │ 2.14077 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Bounded, Periodic, Bounded) │ 2.32425 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Bounded, Periodic, Periodic) │ 1.64349 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 2.44462 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Periodic, Bounded, Periodic) │ 1.79278 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 1.72073 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴──────────┴────────┘; ```. ## GPU slowdown (vs. triply-periodic). ```; FFT-based Poisson solver relative performance (GPU); ┌───────────────┬─────┬────────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 192 │ (Bounded, Bounded, Bounded) │ 4.83605 │ 76.8 │ 29.1613 │; │ GPU │ 192 │ (Bounded, Bounded, Periodic) │ 3.90501 │ 52.5714 │ 21.0 │; │ GPU │ 192 │ (Bounded, Periodic, Bounded) │ 3.91006 │ 52.4 │ 20.8065 │; │ GPU │ 192 │ (Bounded, Periodic, Periodic) │ 5.59024 │ 25.4571 │ 9.48387 │; │ GPU │ 192 │ (Periodic, Bounded, Bounded) │ 3.88581 │ 52.5714 │ 21.0 │; │ GPU │ 192 │ (Periodic, Bounded, Periodic) │ 2.96267 │ 28.0 │ 12.4516 │; │ GPU │ 192 │ (Periodic, Periodic, Bounded) │ 2.03389 │ 25.4571 │ 9.48387 │; │ GPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. # Static ocean benchmarks for all topologies. ## Raw numbers. ```; Topologies benchmarks; ┌───────────────┬─────┬────────────────────────────────┬───────────┬───────────┬───────────┬───────────",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:4731,perform,performance,4731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296,2,['perform'],['performance']
Performance," than `min_change` from the previous `Δt`, and to be no greater in absolute magnitude; # than `max_Δt` and no less than `min_Δt`. # wmax = FieldMaximum(abs, model.velocities.w) ##not working due to update, It has been renamed into other func. start_time = time_ns() ; # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model, Δt=wizard, stop_time= stop_time_info, iteration_interval = iteration_interval_info,; progress=progress_message). simulation.output_writers[:fields] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers),; prefix = Name_of_simulation,; schedule = TimeInterval(0.2minute),; force = true). run!(simulation). using JLD2. using Plots. # load(""modified_open_ocean_convection_Fplane_GPU.jld2""). file = jldopen(""ocean_convection_Fplane_Vertical_strecthed_grid.jld2""). # Coordinate arrays; xC, yC, zC = file[""grid/xC""][1:256],file[""grid/yC""][1:256],file[""grid/zC""][1:65]; Lx, Ly, Lz = file[""grid/Lx""],file[""grid/Ly""],file[""grid/Lz""]. # Extract a vector of iterations; iterations = parse.(Int, keys(file[""timeseries/t""])). @info ""Making a neat movie of verticle velocity and Temperature..."". anim = @animate for (i, iteration) in enumerate(iterations). @info ""Plotting frame $i from iteration $iteration..."". t = file[""timeseries/t/$iteration""]; u_snapshot = file[""timeseries/u/$iteration""][:, :, 60]; v_snapshot = file[""timeseries/v/$iteration""][:, :, 60]; w_snapshot = file[""timeseries/w/$iteration""][:, 128, :]; speed_snapshot = sqrt.(u_snapshot.*u_snapshot + v_snapshot.*v_snapshot); # T_snapshot = file[""timeseries/T/$iteration""][:, 128, :]; . ulims = 0.0025; ; ulevels = range(-ulims, stop=ulims, length=50); ; slims = 0.025; ; slevels = range(0, stop=slims, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-819158999:5903,load,load,5903,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-819158999,1,['load'],['load']
Performance," this might be useful to people if its more visible. > Why you need to define f², wouldn't work simply using ∂zᶠᶜᶠ and squaring the operation?. Because we need to interpolate `∂zᶠᶜᶠ` using `ℑxzᶜᵃᶜ`. Note that Oceananigans operators (derivatives, interpolation, differences) are _composable_. The function `f²` is used in this composition --- it squares a _function_, rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:1322,optimiz,optimized,1322,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513,2,['optimiz'],['optimized']
Performance," tridiagonal solver in the pure FFT solver. You might argue that we just put nothing if we don't need it, but then we have more ""ambiguous"" fields like eigenvalues that are not needed in the tridiagonal solver and source_term that is not needed in the FFT. I am not convinced that a single solver would lead to less (or cleaner) code. Mostly because the underlying code (constructor and `solve!` functions) is compact and slender enough to justify writing individual functions for different grids (the number of lines in the docstring for the `DistributedFourierTridiagonalPoissonSolver` is comparable to the code related to the solver). I think this improves the interpretability of the algorithm. Maybe an improvement would be writing a unified constructor that would spit out the different solvers. > 2. It might make sense to split the constructor into two parts, so that we can build a tridiagonal solver even when all three directions are regular. That could be useful for testing, for example. . I have added this capability by passing the `stretched_direction` kwarg. > Also note that in terms of operation count the tridiagonal solve is cheaper than FFT... I think, all things considered, the mixed FFT / tridiagonal solve will have basically the same computational cost as the pure FFT solve only for a stretched x direction. The additional transposes required for a y or stretched z direction will completely dominate the cost of the actual operations. As an example, this is a slab decomposition with a fairly big grid (512 x 256^2) split on 2 GPUs on Tartarus; ![311333172-43dba752-a91f-4b33-8ade-5a6ec57c982b](https://github.com/user-attachments/assets/1a376c1e-9912-4e00-8dca-91deb46338f8); The AlltoAllv is the dominant cost, while the FFT (in between the two transposes) is quite irrelevant. In the near future, I'll perform scaling tests on Perlmutter, which has a much better network, so it might be that (even if I think it's unlikely) the cost is not all communication after all.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3689#issuecomment-2276030073:2336,perform,perform,2336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3689#issuecomment-2276030073,1,['perform'],['perform']
Performance," using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: LoadError: LoadError: UndefVarError: NFBC not defined; Stacktrace:; [1] top-level scope; @ ~/Research/OC/src/BoundaryConditions/apply_flux_bcs.jl:23; [2] include(mod::Module, _path::String); @ Base ./Base.jl:386; [3] include(x::String); @ Oceananigans.BoundaryConditions ~/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:1; [4] top-level scope; @ ~/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:45; [5] include(mod::Module, _path::String); @ Base ./Base.jl:386; [6] include(x::String); @ Oceananigans ~/Research/OC/src/Oceananigans.jl:1; [7] top-level scope; @ ~/Research/OC/src/Oceananigans.jl:173; [8] include; @ ./Base.jl:386 [inlined]; [9] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1213; [10] top-level scope; @ none:1; [11] eval; @ ./boot.jl:360 [inlined]; [12] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [13] top-level scope; @ none:1; in expression starting at /Users/navid/Research/OC/src/BoundaryConditions/apply_flux_bcs.jl:23; in expression starting at /Users/navid/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:1; in expression starting at /Users/navid/Research/OC/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_fSB7qw.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-877746334:1085,load,loading,1085,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-877746334,1,['load'],['loading']
Performance," using `ℑxzᶜᵃᶜ`. Note that Oceananigans operators (derivatives, interpolation, differences) are _composable_. The function `f²` is used in this composition --- it squares a _function_, rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:1419,perform,performance,1419,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513,2,['perform'],['performance']
Performance,"""Done"" isn't very precise since the cubed sphere will never be ""done"". But perhaps we can put a number on performance for the first milestone, which will allow us to conclude whether we need this optimization or not. Can you explain where the gut feeling comes from? Will filling halos be so expensive even on just one GPU, or is this a distributed problem? Currently, 1/4 degree is performant on one GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718744032:106,perform,performance,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718744032,3,"['optimiz', 'perform']","['optimization', 'performance', 'performant']"
Performance,"################# 100.0%; &nbsp; | Downloading artifact: MPICH; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibCURL; &nbsp; | ######################################################################## 100.0%; &nbsp; | Building MPI ─→ `/storage7/buildkite-agent/.julia-2581/packages/MPI/b7MVG/deps/build.log`; &nbsp; | [ Info: using default MPI jll; &nbsp; | Building FFTW → `/storage7/buildkite-agent/.julia-2581/packages/FFTW/G3lSO/deps/build.log`; &nbsp; | Precompiling project...; &nbsp; | WARNING: Error during initialization of module GMP:; &nbsp; | ErrorException(""could not load library ""libgmp""; &nbsp; | libgmp.so: ELF load command past end of file""); &nbsp; | WARNING: Error during initialization of module LinearAlgebra:; &nbsp; | ErrorException(""could not load library ""libopenblas64_""; &nbsp; | libopenblas64_.so: ELF load command past end of file""); &nbsp; | ┌ Error: Error during initialization of module CHOLMOD; &nbsp; | │ exception =; &nbsp; | │ could not load library ""libcholmod""; &nbsp; | │ libopenblas64_.so.0: ELF load command past end of file; &nbsp; | │ Stacktrace:; &nbsp; | │ [1] dlopen(::String, ::UInt32; throw_error::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109; &nbsp; | │ [2] dlopen at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109 [inlined] (repeats 2 times); &nbsp; | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: LoadError: IOError: write: broken pipe (EPIPE); &nbsp; | Stacktrace:; &nbsp; | [1] uv_wri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:2579,load,load,2579,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,2,['load'],['load']
Performance,"&nbsp; | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: LoadError: IOError: write: broken pipe (EPIPE); &nbsp; | Stacktrace:; &nbsp; | [1] uv_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:951; &nbsp; | [2] unsafe_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:1005; &nbsp; | [3] write(::Base.PipeEndpoint, ::String) at ./strings/io.jl:183; &nbsp; | [4] create_expr_cache(::String, ::String, ::Array{Pair{Base.PkgId,UInt64},1}, ::Base.UUID) at ./loading.jl:1194; &nbsp; | [5] compilecache(::Base.PkgId, ::String) at ./loading.jl:1286; &nbsp; | [6] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [7] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [8] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [9] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [10] include at ./Base.jl:368 [inlined]; &nbsp; | [11] include(::String) at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:1; &nbsp; | [12] top-level scope at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | [13] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [14] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [15] top-level scope at none:2; &nbsp; | [16] eval at ./boot.jl:347 [inlined]; &nbsp; | [17] eval(::Expr) at ./client.jl:467; &nbsp; | [18] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/Pencils/Pencils.jl:7; &nbsp; | in expression starting at /storage7/buildkite-agent/.ju",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:4142,load,loading,4142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['load'],['loading']
Performance,(fyi I stopped the tests because everything was clogged... all tests in PRs have been running for 6-7 hrs... so perhaps restart when there is less load),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2890#issuecomment-1416674470:147,load,load,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2890#issuecomment-1416674470,3,['load'],['load']
Performance,", Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, SubArray{Float64, 1, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Tuple{UnitRange{Int64}}, true}}}}}); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/driver.jl:76; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:346; [10] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/cache.jl:90; [11] cufunction(f::typeof(Oceananigans.Fields.gpu__regrid!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Nothing, Nothing}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRange",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:6644,cache,cache,6644,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574,1,['cache'],['cache']
Performance,", Bounded) │ 23.479 ms │ 23.727 ms │ 23.792 ms │ 24.619 ms │ 771.44 KiB │ 1115 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Periodic) │ 30.863 ms │ 30.990 ms │ 31.205 ms │ 31.858 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Periodic) │ 31.041 ms │ 31.521 ms │ 31.982 ms │ 33.815 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Bounded) │ 25.631 ms │ 26.845 ms │ 26.749 ms │ 28.206 ms │ 837.97 KiB │ 1154 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Periodic) │ 31.354 ms │ 31.398 ms │ 31.477 ms │ 32.215 ms │ 771.44 KiB │ 1115 │ 10 │; └───────────────┴───────────────┴────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴────────────┴────────┴─────────┘; [2022/05/03 00:56:15.050] INFO Writing Topologies_benchmarks.html...; Topologies relative performance (CPU); ┌───────────────┬───────────────┬────────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼───────────────┼────────────────────────────────┼──────────┼─────────┼─────────┤; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Bounded) │ 0.865858 │ 1.45702 │ 1.14257 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Periodic) │ 1.01269 │ 1.34134 │ 1.10396 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Bounded) │ 0.760326 │ 1.34134 │ 1.10396 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Periodic) │ 0.999539 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Bounded) │ 0.765277 │ 1.34134 │ 1.10396 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Periodic) │ 1.01667 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Bounded) │ 0.756078 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴───────────────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. # This PR. ## Modest 3D model (128x128x128). ```; Topologies benchmarks; ┌───────────────┬",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728:5129,perform,performance,5129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728,1,['perform'],['performance']
Performance,", Nothing, Nothing, Nothing}}:; ERROR: KernelException: exception thrown during kernel execution on device Tesla V100-SXM2-32GB; Stacktrace:; [1] check_exceptions(); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/src/compiler/exceptions.jl:34; [2] nonblocking_synchronize; @ /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/context.jl:331 [inlined]; [3] device_synchronize(); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/context.jl:319; [4] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/module.jl:41; [5] CuModule; @ /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/module.jl:23 [inlined]; [6] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/src/compiler/execution.jl:479; [7] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/XyxTy/src/cache.jl:95; [8] cufunction(f::typeof(CUDA.partial_mapreduce_grid), tt::Type{Tuple{typeof(identity), typeof(max), Nothing, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, Val{true}, CUDA.CuDeviceArray{Float64, 4, 1}, Oceananigans.AbstractOperations.ConditionalOperation{Face, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, typeof(identity), ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871:5688,cache,cache,5688,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871,1,['cache'],['cache']
Performance,", Periodic, Bounded) │ 23.208 ms │ 23.282 ms │ 23.646 ms │ 24.667 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Bounded) │ 23.736 ms │ 24.691 ms │ 24.854 ms │ 26.482 ms │ 771.44 KiB │ 1115 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Periodic) │ 31.277 ms │ 32.486 ms │ 32.212 ms │ 32.999 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Periodic) │ 30.844 ms │ 30.903 ms │ 31.003 ms │ 31.769 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Bounded) │ 23.704 ms │ 23.832 ms │ 24.042 ms │ 25.055 ms │ 837.97 KiB │ 1154 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Periodic) │ 31.354 ms │ 31.632 ms │ 31.816 ms │ 32.916 ms │ 772.19 KiB │ 1131 │ 10 │; └───────────────┴───────────────┴────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴────────────┴────────┴─────────┘; [2022/05/03 00:42:25.915] INFO Writing Topologies_benchmarks.html...; Topologies relative performance (CPU); ┌───────────────┬───────────────┬────────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼───────────────┼────────────────────────────────┼──────────┼─────────┼─────────┤; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Bounded) │ 0.669516 │ 1.45702 │ 1.14257 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Periodic) │ 0.888622 │ 1.34264 │ 1.1198 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Bounded) │ 0.665425 │ 1.34264 │ 1.1198 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Periodic) │ 0.912619 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Bounded) │ 0.693639 │ 1.34134 │ 1.10396 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Periodic) │ 0.868158 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Bounded) │ 0.654046 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; ```. The fastest is fully bounded for whatever reason.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728:10798,perform,performance,10798,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728,1,['perform'],['performance']
Performance,"-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; │ [6] #mkpidlock#6; │ @ ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; │ [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; │ [8] #invokelatest#2; │ @ ./essentials.jl:894 [inlined]; │ [9] invokelatest; │ @ ./essentials.jl:889 [inlined]; │ [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); │ @ Base ./loading.jl:2983; │ [11] maybe_cachefile_lock; │ @ ./loading.jl:2980 [inlined]; │ [12] _require(pkg::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1970; │ [13] __require_prelocked(uuidkey::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1812; │ [14] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [15] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [16] _require_prelocked; │ @ ./loading.jl:1803 [inlined]; │ [17] _require_prelocked; │ @ ./loading.jl:1802 [inlined]; │ [18] run_extension_callbacks(extid::Base.ExtensionId); │ @ Base ./loading.jl:1295; │ [19] run_extension_callbacks(pkgid::Base.PkgId); │ @ Base ./loading.jl:1330; │ [20] run_package_callbacks(modkey::Base.PkgId); │ @ Base ./loading.jl:1164; │ [21] _tryrequire_from_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.jl:1574; │ [23] _require(pkg::Base.PkgId, env::String); │ @ Base ./loading.jl:1938; │ [24] __require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1812; │ [25] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [26] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [27] _require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1803; │ [28] macro exp",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:2586,load,loading,2586,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,".PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); │ @ Base ./loading.jl:2468; │ [3] compilecache; │ @ ./loading.jl:2340 [inlined]; │ [4] (::Base.var""#968#969""{Base.PkgId})(); │ @ Base ./loading.jl:1974; │ [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; │ [6] #mkpidlock#6; │ @ ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; │ [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; │ [8] #invokelatest#2; │ @ ./essentials.jl:894 [inlined]; │ [9] invokelatest; │ @ ./essentials.jl:889 [inlined]; │ [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); │ @ Base ./loading.jl:2983; │ [11] maybe_cachefile_lock; │ @ ./loading.jl:2980 [inlined]; │ [12] _require(pkg::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1970; │ [13] __require_prelocked(uuidkey::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1812; │ [14] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [15] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [16] _require_prelocked; │ @ ./loading.jl:1803 [inlined]; │ [17] _require_prelocked; │ @ ./loading.jl:1802 [inlined]; │ [18] run_extension_callbacks(extid::Base.ExtensionId); │ @ Base ./loading.jl:1295; │ [19] run_extension_callbacks(pkgid::Base.PkgId); │ @ Base ./loading.jl:1330; │ [20] run_package_callbacks(modkey::Base.PkgId); │ @ Base ./loading.jl:1164; │ [21] _tryrequire_from_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:2186,load,loading,2186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,".jl:923; &nbsp; | [9] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [10] include at ./Base.jl:368 [inlined]; &nbsp; | [11] include(::String) at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:1; &nbsp; | [12] top-level scope at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | [13] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [14] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [15] top-level scope at none:2; &nbsp; | [16] eval at ./boot.jl:347 [inlined]; &nbsp; | [17] eval(::Expr) at ./client.jl:467; &nbsp; | [18] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/Pencils/Pencils.jl:7; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | ERROR: LoadError: Failed to precompile PencilArrays [0e08944d-e94e-41b1-9406-dcf66b6a9d2e] to /storage7/buildkite-agent/.julia-2581/compiled/v1.5/PencilArrays/yKKUy_zV1Ut.ji.; &nbsp; | Stacktrace:; &nbsp; | [1] error(::String) at ./error.jl:33; &nbsp; | [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1305; &nbsp; | [3] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [4] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [5] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [6] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [7] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [8] top-level scope at none:2; &nbsp; | [9] eval at ./boot.jl:347 [inlined]; &nbsp; | [10] eval(::Expr) at ./client.jl:467; &nbsp; | [11] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilFFTs/Xwxei/src/PencilFFTs.jl:11; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:5223,Load,LoadError,5223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['Load'],['LoadError']
Performance,"/3VnCC/src/device/intrinsics.jl:22; [7] include(mod::Module, _path::String); @ Base ./Base.jl:386; [8] include(x::String); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; [9] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:46; [10] include; @ ./Base.jl:386 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics/math.jl:5; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /home/tomas/.julia/compiled/v1.6/CUDA/jl_q4lPlx.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; [7] include; @ ./Base.jl:386 [inlined]; [8] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [9] top-level scope; @ none:1; [10] eval; @ ./boot.jl:360 [inlined]; [11] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [12] top-level scope; @ none:1; in expression starting at /home/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371:1804,Load,LoadError,1804,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371,1,['Load'],['LoadError']
Performance,"/DTEhf/src/PencilArrays.jl:12; &nbsp; | ERROR: LoadError: Failed to precompile PencilArrays [0e08944d-e94e-41b1-9406-dcf66b6a9d2e] to /storage7/buildkite-agent/.julia-2581/compiled/v1.5/PencilArrays/yKKUy_zV1Ut.ji.; &nbsp; | Stacktrace:; &nbsp; | [1] error(::String) at ./error.jl:33; &nbsp; | [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1305; &nbsp; | [3] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [4] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [5] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [6] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [7] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [8] top-level scope at none:2; &nbsp; | [9] eval at ./boot.jl:347 [inlined]; &nbsp; | [10] eval(::Expr) at ./client.jl:467; &nbsp; | [11] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilFFTs/Xwxei/src/PencilFFTs.jl:11; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | 🚨 Error: The command exited with status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:6302,load,load,6302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,9,['load'],['load']
Performance,"/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:86 [inlined]; [11] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:129; [12] codegen; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:110 [inlined]; [13] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:106; [14] compile; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:98 [inlined]; [15] #40; @ ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:140 [inlined]; [16] JuliaContext(f::AMDGPU.Compiler.var""#40#41""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:47; [17] hipcompile(job::GPUCompiler.CompilerJob); @ AMDGPU.Compiler ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:139; [18] actual_compilation(cache::Dict{Any, AMDGPU.HIP.HIPFunction}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}, compiler::typeof(AMDGPU.Compiler.hipcompile), linker::typeof(AMDGPU.Compiler.hiplink)); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/execution.jl:125; [19] cached_co",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273:2169,optimiz,optimize,2169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273,2,['optimiz'],['optimize']
Performance,"/loading.jl:2983; │ [11] maybe_cachefile_lock; │ @ ./loading.jl:2980 [inlined]; │ [12] _require(pkg::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1970; │ [13] __require_prelocked(uuidkey::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1812; │ [14] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [15] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [16] _require_prelocked; │ @ ./loading.jl:1803 [inlined]; │ [17] _require_prelocked; │ @ ./loading.jl:1802 [inlined]; │ [18] run_extension_callbacks(extid::Base.ExtensionId); │ @ Base ./loading.jl:1295; │ [19] run_extension_callbacks(pkgid::Base.PkgId); │ @ Base ./loading.jl:1330; │ [20] run_package_callbacks(modkey::Base.PkgId); │ @ Base ./loading.jl:1164; │ [21] _tryrequire_from_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.jl:1574; │ [23] _require(pkg::Base.PkgId, env::String); │ @ Base ./loading.jl:1938; │ [24] __require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1812; │ [25] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [26] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [27] _require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1803; │ [28] macro expansion; │ @ ./loading.jl:1790 [inlined]; │ [29] macro expansion; │ @ ./lock.jl:267 [inlined]; │ [30] __require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1753; │ [31] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [32] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [33] require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1746; │ [34] eval; │ @ ./boot.jl:385 [inlined]; │ [35] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; │ [36] repl_backend_loop(backend::REPL.REPLBacke",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:3182,load,loading,3182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing); throw_api_error at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; check at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; cuStreamDestroy_v2 at /home/js2430/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; #834 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:86 [inlined]; #context!#887 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170; unknown function (ip: 0x7f08bc0a0880); context! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; unsafe_destroy! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:85; unknown function (ip: 0x7f08bc0a0622); _jl_invoke at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2758 [inlined]; ijl_apply_generic at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2940; run_finalizer at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:417; jl_gc_run_finalizers_in_list at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:507; run_finalizers at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:553; ijl_atexit_hook at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/init.c:299; jl_repl_entrypoint at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/jlapi.c:718; main at julia (unknown line); __libc_start_main at /lib64/libc.so.6 (unknown line); unknown function (ip: 0x401098); ```; </details>; </summary>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:4390,cache,cache,4390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129,7,['cache'],['cache']
Performance,"/v1.5/Libdl/src/Libdl.jl:109 [inlined] (repeats 2 times); &nbsp; | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: LoadError: IOError: write: broken pipe (EPIPE); &nbsp; | Stacktrace:; &nbsp; | [1] uv_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:951; &nbsp; | [2] unsafe_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:1005; &nbsp; | [3] write(::Base.PipeEndpoint, ::String) at ./strings/io.jl:183; &nbsp; | [4] create_expr_cache(::String, ::String, ::Array{Pair{Base.PkgId,UInt64},1}, ::Base.UUID) at ./loading.jl:1194; &nbsp; | [5] compilecache(::Base.PkgId, ::String) at ./loading.jl:1286; &nbsp; | [6] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [7] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [8] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [9] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [10] include at ./Base.jl:368 [inlined]; &nbsp; | [11] include(::String) at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:1; &nbsp; | [12] top-level scope at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | [13] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [14] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [15] top-level scope at none:2; &nbsp; | [16] eval at ./boot.jl:347 [inlined]; &nbsp; | [17] eval(::Expr) at ./client.jl:467; &nbsp; | [18] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/Pencils/Pencils.jl:7; &nbsp;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:4084,load,loading,4084,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['load'],['loading']
Performance,0 │; │ CPU │ TEOS10EquationOfState │ 2.270 s │ 2.401 s │ 2.378 s │ 2.464 s │ 372.53 KiB │ 2090 │; │ GPU │ LinearEquationOfState │ 10.058 ms │ 13.161 ms │ 12.856 ms │ 13.215 ms │ 1022.19 KiB │ 7154 │; │ GPU │ RoquetEquationOfState │ 10.688 ms │ 13.236 ms │ 12.991 ms │ 13.322 ms │ 1.00 MiB │ 7054 │; │ GPU │ TEOS10EquationOfState │ 10.204 ms │ 13.463 ms │ 13.145 ms │ 13.504 ms │ 1017.58 KiB │ 7154 │; └───────────────┴───────────────────────┴───────────┴───────────┴───────────┴───────────┴─────────────┴────────┘; ```. ```; Equation of state CPU -> GPU speedup; ┌───────────────────────┬─────────┬─────────┬─────────┐; │ EquationsOfState │ speedup │ memory │ allocs │; ├───────────────────────┼─────────┼─────────┼─────────┤; │ LinearEquationOfState │ 154.965 │ 2.74298 │ 3.42297 │; │ RoquetEquationOfState │ 133.062 │ 2.74052 │ 3.37512 │; │ TEOS10EquationOfState │ 178.317 │ 2.73152 │ 3.42297 │; └───────────────────────┴─────────┴─────────┴─────────┘; ```. ```; Equation of state relative performance (CPU); ┌───────────────┬───────────────────────┬──────────┬──────────┬────────┐; │ Architectures │ EquationsOfState │ slowdown │ memory │ allocs │; ├───────────────┼───────────────────────┼──────────┼──────────┼────────┤; │ CPU │ LinearEquationOfState │ 1.0 │ 1.0 │ 1.0 │; │ CPU │ RoquetEquationOfState │ 0.863549 │ 1.00298 │ 1.0 │; │ CPU │ TEOS10EquationOfState │ 1.17707 │ 0.999665 │ 1.0 │; └───────────────┴───────────────────────┴──────────┴──────────┴────────┘; ```. ```; Equation of state relative performance (GPU); ┌───────────────┬───────────────────────┬──────────┬──────────┬──────────┐; │ Architectures │ EquationsOfState │ slowdown │ memory │ allocs │; ├───────────────┼───────────────────────┼──────────┼──────────┼──────────┤; │ GPU │ LinearEquationOfState │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ RoquetEquationOfState │ 1.00569 │ 1.00208 │ 0.986022 │; │ GPU │ TEOS10EquationOfState │ 1.02292 │ 0.995491 │ 1.0 │; └───────────────┴───────────────────────┴──────────┴──────────┴──────────┘. ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800720099:1965,perform,performance,1965,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800720099,2,['perform'],['performance']
Performance,"00; [3] compilecache; @ ./loading.jl:2167 [inlined]; [4] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1805; [5] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1660; [6] macro expansion; @ ./loading.jl:1648 [inlined]; [7] macro expansion; @ ./lock.jl:267 [inlined]; [8] require(into::Module, mod::Symbol); @ Base ./loading.jl:1611; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; ```; The versioninfo gave me the following as output:; ```; Julia Version 1.9.2; Commit e4ee485e90 (2023-07-05 09:39 UTC); Platform Info:; OS: Linux (x86_64-suse-linux); ""openSUSE Leap 15.4""; uname: Linux 5.14.21-150400.24.46-default #1 SMP PREEMPT_DYNAMIC Thu Feb 9 08:38:18 UTC 2023 (2d95137) x86_64 x86_64; CPU: Intel(R) Xeon(R) Gold 6240 CPU @ 2.60GHz: ; speed user nice sys idle irq; #1-72 2600 MHz 922553194 s 727867 s 363212152 s 5414020342 s 0 s; Memory: 370.290340423584 GB (301775.56640625 MB free); Uptime: 9.37897786e6 sec; Load Avg: 13.61 25.96 27.94; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-14.0.6 (ORCJIT, cascadelake); Threads: 1 on 72 virtual cores; Environment:; LD_LIBRARY_PATH = /glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1/dgcv/lib:/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64:/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/nvvm/lib64:/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/extras/CUPTI/lib64:/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/extras/Debugger/lib64:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/lib:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/lib/x64:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/lib/oclfpga/host/linux64/lib:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/compiler/lib/intel64_lin:/glade",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:1635,Load,Load,1635,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['Load'],['Load']
Performance,"110 ms │ 57.56 KiB │ 641 │; │ GPU │ 256 │ (Periodic, Bounded, Bounded) │ 13.975 ms │ 30.948 ms │ 29.250 ms │ 30.985 ms │ 57.75 KiB │ 647 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 7.257 ms │ 15.907 ms │ 15.044 ms │ 15.927 ms │ 27.97 KiB │ 292 │; └───────────────┴─────┴───────────────────────────────┴────────────┴────────────┴────────────┴────────────┴───────────┴────────┘; ```. ### CPU to GPU speedup. ```; FFT-based Poisson solver CPU -> GPU speedup; ┌─────┬───────────────────────────────┬─────────┬────────┬────────┐; │ Ns │ Topologies │ speedup │ memory │ allocs │; ├─────┼───────────────────────────────┼─────────┼────────┼────────┤; │ 256 │ (Bounded, Bounded, Bounded) │ 35.4428 │ 450.0 │ 224.5 │; │ 256 │ (Bounded, Periodic, Bounded) │ 36.8697 │ 368.4 │ 320.5 │; │ 256 │ (Periodic, Bounded, Bounded) │ 37.0953 │ 369.6 │ 323.5 │; │ 256 │ (Periodic, Periodic, Bounded) │ 53.4034 │ 179.0 │ 146.0 │; └─────┴───────────────────────────────┴─────────┴────────┴────────┘; ```. ### CPU relative performance. ```; FFT-based Poisson solver relative performance (CPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.61224 │ 1.2 │ 2.0 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.34917 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.35141 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴────────┴────────┘; ```. ### GPU relative performance. ```; FFT-based Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:11727,perform,performance,11727,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050,1,['perform'],['performance']
Performance,"111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_zRopeZ"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwop",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:2467,load,loading,2467,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/Oceananigans/jl_k7YOZN"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgI",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:5048,load,loading,5048,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"1; &nbsp; | [12] top-level scope at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | [13] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [14] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [15] top-level scope at none:2; &nbsp; | [16] eval at ./boot.jl:347 [inlined]; &nbsp; | [17] eval(::Expr) at ./client.jl:467; &nbsp; | [18] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/Pencils/Pencils.jl:7; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | ERROR: LoadError: Failed to precompile PencilArrays [0e08944d-e94e-41b1-9406-dcf66b6a9d2e] to /storage7/buildkite-agent/.julia-2581/compiled/v1.5/PencilArrays/yKKUy_zV1Ut.ji.; &nbsp; | Stacktrace:; &nbsp; | [1] error(::String) at ./error.jl:33; &nbsp; | [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1305; &nbsp; | [3] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [4] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [5] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [6] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [7] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [8] top-level scope at none:2; &nbsp; | [9] eval at ./boot.jl:347 [inlined]; &nbsp; | [10] eval(::Expr) at ./client.jl:467; &nbsp; | [11] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilFFTs/Xwxei/src/PencilFFTs.jl:11; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:5516,load,loading,5516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['load'],['loading']
Performance,"213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics/math.jl:5; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /home/tomas/.julia/compiled/v1.6/CUDA/jl_q4lPlx.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; [7] include; @ ./Base.jl:386 [inlined]; [8] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [9] top-level scope; @ none:1; [10] eval; @ ./boot.jl:360 [inlined]; [11] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [12] top-level scope; @ none:1; in expression starting at /home/tomas/repos/Oceananigans.jl/src/Oceananigans.jl:1; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /home/tomas/.julia/compiled/v1.6/Oceananigans/jl_psrPk0.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371:2359,load,loading,2359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371,1,['load'],['loading']
Performance,"5.4428 │ 450.0 │ 224.5 │; │ 256 │ (Bounded, Periodic, Bounded) │ 36.8697 │ 368.4 │ 320.5 │; │ 256 │ (Periodic, Bounded, Bounded) │ 37.0953 │ 369.6 │ 323.5 │; │ 256 │ (Periodic, Periodic, Bounded) │ 53.4034 │ 179.0 │ 146.0 │; └─────┴───────────────────────────────┴─────────┴────────┴────────┘; ```. ### CPU relative performance. ```; FFT-based Poisson solver relative performance (CPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.61224 │ 1.2 │ 2.0 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.34917 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.35141 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴────────┴────────┘; ```. ### GPU relative performance. ```; FFT-based Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 2.42923 │ 3.01676 │ 3.07534 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.95419 │ 2.0581 │ 2.19521 │; │ GPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.94553 │ 2.0648 │ 2.21575 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴─────────┴─────────┘; ```. ---. ## System info. ```; Oceananigans v0.50.0; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23:17 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); GPU: TITAN V; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:12464,perform,performance,12464,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050,1,['perform'],['performance']
Performance,"558 │; > │ 100000000 │ 618.565 │ 3.01714 │ 6.04355 │; > └─────────────┴─────────┴─────────┴─────────┘; >; > Lagrangian particle tracking relative performance (CPU); > ┌───────────────┬─────────────┬──────────┬─────────┬─────────┐; > │ Architectures │ N_particles │ slowdown │ memory │ allocs │; > ├───────────────┼─────────────┼──────────┼─────────┼─────────┤; > │ CPU │ 0 │ 1.0 │ 1.0 │ 1.0 │; > │ CPU │ 1 │ 1.03447 │ 1.01267 │ 1.01599 │; > │ CPU │ 10 │ 1.04601 │ 1.01267 │ 1.01599 │; > │ CPU │ 100 │ 1.04712 │ 1.01267 │ 1.01599 │; > │ CPU │ 1000 │ 1.05514 │ 1.01267 │ 1.01599 │; > │ CPU │ 10000 │ 1.05397 │ 1.01267 │ 1.01599 │; > │ CPU │ 100000 │ 1.07213 │ 1.01267 │ 1.01599 │; > │ CPU │ 1000000 │ 1.34006 │ 1.01267 │ 1.01599 │; > │ CPU │ 10000000 │ 4.09045 │ 1.01267 │ 1.01599 │; > │ CPU │ 100000000 │ 31.6534 │ 1.01267 │ 1.01599 │; > └───────────────┴─────────────┴──────────┴─────────┴─────────┘; >; > Lagrangian particle tracking relative performance (GPU); > ┌───────────────┬─────────────┬──────────┬─────────┬─────────┐; > │ Architectures │ N_particles │ slowdown │ memory │ allocs │; > ├───────────────┼─────────────┼──────────┼─────────┼─────────┤; > │ GPU │ 0 │ 1.0 │ 1.0 │ 1.0 │; > │ GPU │ 1 │ 1.02262 │ 1.01395 │ 1.0135 │; > │ GPU │ 10 │ 1.02786 │ 1.01314 │ 1.00947 │; > │ GPU │ 100 │ 1.02347 │ 1.01314 │ 1.00947 │; > │ GPU │ 1000 │ 1.02548 │ 1.01395 │ 1.0135 │; > │ GPU │ 10000 │ 1.0309 │ 1.01314 │ 1.00947 │; > │ GPU │ 100000 │ 1.02327 │ 1.01314 │ 1.00947 │; > │ GPU │ 1000000 │ 1.03536 │ 1.01395 │ 1.0135 │; > │ GPU │ 10000000 │ 1.31966 │ 1.01391 │ 1.01332 │; > │ GPU │ 100000000 │ 4.20799 │ 1.01317 │ 1.00964 │; > └───────────────┴─────────────┴──────────┴─────────┴─────────┘; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732529975>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQS3WD4CLJSVF23H433SRME",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982:5392,perform,performance,5392,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982,1,['perform'],['performance']
Performance,7.22 KiB │ 11561 │; > │ GPU │ 100000000 │ 4.910 ms │ 18.629 ms │ 17.245 ms │ 18.757 ms │ 896.56 KiB │ 11519 │; > └───────────────┴─────────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; >; > Lagrangian particle tracking CPU -> GPU; > speedup; > ┌─────────────┬─────────┬─────────┬─────────┐; > │ N_particles │ speedup │ memory │ allocs │; > ├─────────────┼─────────┼─────────┼─────────┤; > │ 0 │ 82.2319 │ 3.01565 │ 6.08156 │; > │ 1 │ 83.1848 │ 3.01946 │ 6.06663 │; > │ 10 │ 83.6845 │ 3.01704 │ 6.0425 │; > │ 100 │ 84.1322 │ 3.01704 │ 6.0425 │; > │ 1000 │ 84.6106 │ 3.01946 │ 6.06663 │; > │ 10000 │ 84.072 │ 3.01704 │ 6.0425 │; > │ 100000 │ 86.1581 │ 3.01704 │ 6.0425 │; > │ 1000000 │ 106.432 │ 3.01946 │ 6.06663 │; > │ 10000000 │ 254.889 │ 3.01935 │ 6.06558 │; > │ 100000000 │ 618.565 │ 3.01714 │ 6.04355 │; > └─────────────┴─────────┴─────────┴─────────┘; >; > Lagrangian particle tracking relative performance (CPU); > ┌───────────────┬─────────────┬──────────┬─────────┬─────────┐; > │ Architectures │ N_particles │ slowdown │ memory │ allocs │; > ├───────────────┼─────────────┼──────────┼─────────┼─────────┤; > │ CPU │ 0 │ 1.0 │ 1.0 │ 1.0 │; > │ CPU │ 1 │ 1.03447 │ 1.01267 │ 1.01599 │; > │ CPU │ 10 │ 1.04601 │ 1.01267 │ 1.01599 │; > │ CPU │ 100 │ 1.04712 │ 1.01267 │ 1.01599 │; > │ CPU │ 1000 │ 1.05514 │ 1.01267 │ 1.01599 │; > │ CPU │ 10000 │ 1.05397 │ 1.01267 │ 1.01599 │; > │ CPU │ 100000 │ 1.07213 │ 1.01267 │ 1.01599 │; > │ CPU │ 1000000 │ 1.34006 │ 1.01267 │ 1.01599 │; > │ CPU │ 10000000 │ 4.09045 │ 1.01267 │ 1.01599 │; > │ CPU │ 100000000 │ 31.6534 │ 1.01267 │ 1.01599 │; > └───────────────┴─────────────┴──────────┴─────────┴─────────┘; >; > Lagrangian particle tracking relative performance (GPU); > ┌───────────────┬─────────────┬──────────┬─────────┬─────────┐; > │ Architectures │ N_particles │ slowdown │ memory │ allocs │; > ├───────────────┼─────────────┼──────────┼─────────┼─────────┤; > │ GPU │ 0 │ 1.0 │ 1.0 │ 1.0 │; > │ GPU │ 1 │ 1.022,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982:4594,perform,performance,4594,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982,1,['perform'],['performance']
Performance,7.22 KiB │ 11561 │; │ GPU │ 100000000 │ 4.910 ms │ 18.629 ms │ 17.245 ms │ 18.757 ms │ 896.56 KiB │ 11519 │; └───────────────┴─────────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ```; Lagrangian particle tracking CPU -> GPU; speedup; ┌─────────────┬─────────┬─────────┬─────────┐; │ N_particles │ speedup │ memory │ allocs │; ├─────────────┼─────────┼─────────┼─────────┤; │ 0 │ 82.2319 │ 3.01565 │ 6.08156 │; │ 1 │ 83.1848 │ 3.01946 │ 6.06663 │; │ 10 │ 83.6845 │ 3.01704 │ 6.0425 │; │ 100 │ 84.1322 │ 3.01704 │ 6.0425 │; │ 1000 │ 84.6106 │ 3.01946 │ 6.06663 │; │ 10000 │ 84.072 │ 3.01704 │ 6.0425 │; │ 100000 │ 86.1581 │ 3.01704 │ 6.0425 │; │ 1000000 │ 106.432 │ 3.01946 │ 6.06663 │; │ 10000000 │ 254.889 │ 3.01935 │ 6.06558 │; │ 100000000 │ 618.565 │ 3.01714 │ 6.04355 │; └─────────────┴─────────┴─────────┴─────────┘; ```. ```; Lagrangian particle tracking relative performance (CPU); ┌───────────────┬─────────────┬──────────┬─────────┬─────────┐; │ Architectures │ N_particles │ slowdown │ memory │ allocs │; ├───────────────┼─────────────┼──────────┼─────────┼─────────┤; │ CPU │ 0 │ 1.0 │ 1.0 │ 1.0 │; │ CPU │ 1 │ 1.03447 │ 1.01267 │ 1.01599 │; │ CPU │ 10 │ 1.04601 │ 1.01267 │ 1.01599 │; │ CPU │ 100 │ 1.04712 │ 1.01267 │ 1.01599 │; │ CPU │ 1000 │ 1.05514 │ 1.01267 │ 1.01599 │; │ CPU │ 10000 │ 1.05397 │ 1.01267 │ 1.01599 │; │ CPU │ 100000 │ 1.07213 │ 1.01267 │ 1.01599 │; │ CPU │ 1000000 │ 1.34006 │ 1.01267 │ 1.01599 │; │ CPU │ 10000000 │ 4.09045 │ 1.01267 │ 1.01599 │; │ CPU │ 100000000 │ 31.6534 │ 1.01267 │ 1.01599 │; └───────────────┴─────────────┴──────────┴─────────┴─────────┘; ```. ```; Lagrangian particle tracking relative performance (GPU); ┌───────────────┬─────────────┬──────────┬─────────┬─────────┐; │ Architectures │ N_particles │ slowdown │ memory │ allocs │; ├───────────────┼─────────────┼──────────┼─────────┼─────────┤; │ GPU │ 0 │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ 1 │ 1.02262 │ 1.01395 │ 1.0135 │; │ GPU │ 10 │ 1.02786 │ 1.01314 │ ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732529975:4056,perform,performance,4056,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732529975,1,['perform'],['performance']
Performance,"7.257 ms │ 15.907 ms │ 15.044 ms │ 15.927 ms │ 27.97 KiB │ 292 │; └───────────────┴─────┴───────────────────────────────┴────────────┴────────────┴────────────┴────────────┴───────────┴────────┘; ```. ### CPU to GPU speedup. ```; FFT-based Poisson solver CPU -> GPU speedup; ┌─────┬───────────────────────────────┬─────────┬────────┬────────┐; │ Ns │ Topologies │ speedup │ memory │ allocs │; ├─────┼───────────────────────────────┼─────────┼────────┼────────┤; │ 256 │ (Bounded, Bounded, Bounded) │ 35.4428 │ 450.0 │ 224.5 │; │ 256 │ (Bounded, Periodic, Bounded) │ 36.8697 │ 368.4 │ 320.5 │; │ 256 │ (Periodic, Bounded, Bounded) │ 37.0953 │ 369.6 │ 323.5 │; │ 256 │ (Periodic, Periodic, Bounded) │ 53.4034 │ 179.0 │ 146.0 │; └─────┴───────────────────────────────┴─────────┴────────┴────────┘; ```. ### CPU relative performance. ```; FFT-based Poisson solver relative performance (CPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.61224 │ 1.2 │ 2.0 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.34917 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.35141 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴────────┴────────┘; ```. ### GPU relative performance. ```; FFT-based Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 2.42923 │ 3.01676 │ 3.07534 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.95419 │ 2.0581 │ 2.19521 │; │ GPU │ 256 │ (Periodic, Bounded, Bo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:11779,perform,performance,11779,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050,1,['perform'],['performance']
Performance,"90% sure, but if it's not there it's in `centered_reconstruction.jl` or `upwind_biased_reconstruction.jl`; I haven't gotten around to test performance for non-weno schemes but I should do it.... I ll guess I ll dedicate today to searching the issue, so we can merge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185584632:139,perform,performance,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185584632,1,['perform'],['performance']
Performance,"::String); │ @ Base ./loading.jl:1812; │ [25] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [26] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [27] _require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1803; │ [28] macro expansion; │ @ ./loading.jl:1790 [inlined]; │ [29] macro expansion; │ @ ./lock.jl:267 [inlined]; │ [30] __require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1753; │ [31] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [32] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [33] require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1746; │ [34] eval; │ @ ./boot.jl:385 [inlined]; │ [35] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; │ [36] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; │ [37] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; │ [38] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; │ [39] run_repl(repl::REPL.AbstractREPL, consumer::Any); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; │ [40] (::Base.var""#1013#1015""{Bool, Bool, Bool})(REPL::Module); │ @ Base ./client.jl:432; │ [41] #invokelatest#2; │ @ ./essentials.jl:892 [inlined]; │ [42] invokelatest; │ @ ./essentials.jl:889 [inlined]; │ [43] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); │ @ Base ./client.jl:416; │ [44] exec_options(opts::Base.JLOptions); │ @ Base ./client.jl:333; │ [45] _start(); │ @ Base ./client.jl:552; └ @ Base loading.jl:1301; ```. perhaps some compat entry is needed? I get this w GLMakie v0.10.5 in my main Julia env....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:5213,load,loading,5213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics/math.jl:5; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /home/tomas/.julia/compiled/v1.6/CUDA/jl_q4lPlx.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; [7] include; @ ./Base.jl:386 [inlined]; [8] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [9] top-level scope; @ none:1; [10] eval; @ ./boot.jl:360 [inlined]; [11] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [12] top-level scope; @ none:1; in expression starting at /home/tomas/repos/Oceananigans.jl/src/Oceananigans.jl:1; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /home/tomas/.julia/compiled/v1.6/Oceananigans/jl_psrPk0.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, in",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371:2177,load,loading,2177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371,1,['load'],['loading']
Performance,"; > > ; > > ; > > But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us).; > ; > I agree. If we try using whatever closure here that is used in the hydrostatic model, I would think that it should yield a similar result. But that's maybe better saved for a future PR?. Let me clarify. We've never run the hydrostatic model with a single layer on the sphere, but this is a good idea. Most of our runs have been with 50 vertical levels. In the 3D configuration with 50 vertical levels, we smooth results with 1) WENO5 vector invariant advection and 2) biharmonic ""divergence damping"" of the divergence component of the flow. If we are going to compare the shallow water on a sphere to they hydrostatic model, we will have to produce additional runs with just 1 vertical level. In other words, there are no results to compare with right now. When we perform additional runs, we may choose to include divergence damping, or another kind of closure, if we want to. The results presented in #2317 also use a single layer hydrostatic model, and these did not require any explicit dissipation. Therefore, there is reason to believe that divergence damping is only required for 3D simulations. An additional point is that in the shallow water equations we can introduce a WENO reconstruction of the mass flux. This reconstruction may provide divergence damping (whether or not we need it!). In summary, if we would like to perform a comparison, we can choose to either 1) produce a comparison between the shallow water model and one layer hydrostatic model with no explicit closure on the sphere or 2) run new 1 layer hydrostatic simulations with some closure (of our choosing) and then _also_ implement that closure in the shallow water model. My opinion is that with these nice WENO5 numerics there may not be a need for using explicit dissipation right now, so we might as well do the easy thing and avoid",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226:1057,perform,perform,1057,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226,2,['perform'],['perform']
Performance,; GPU Link Info; PCIe Generation; Max : 3; Current : 3; Device Current : 3; Device Max : 3; Host Max : 3; Link Width; Max : 16x; Current : 16x; Bridge Chip; Type : N/A; Firmware : N/A; Replays Since Reset : 0; Replay Number Rollovers : 0; Tx Throughput : 0 KB/s; Rx Throughput : 0 KB/s; Atomic Caps Inbound : N/A; Atomic Caps Outbound : N/A; Fan Speed : N/A; Performance State : P0; Clocks Throttle Reasons; Idle : Active; Applications Clocks Setting : Not Active; SW Power Cap : Not Active; HW Slowdown : Not Active; HW Thermal Slowdown : Not Active; HW Power Brake Slowdown : Not Active; Sync Boost : Not Active; SW Thermal Slowdown : Not Active; Display Clock Setting : Not Active; FB Memory Usage; Total : 32768 MiB; Reserved : 267 MiB; Used : 0 MiB; Free : 32500 MiB; BAR1 Memory Usage; Total : 32768 MiB; Used : 2 MiB; Free : 32766 MiB; Compute Mode : Default; Utilization; Gpu : 0 %; Memory : 0 %; Encoder : 0 %; Decoder : 0 %; Encoder Stats; Active Sessions : 0; Average FPS : 0; Average Latency : 0; FBC Stats; Active Sessions : 0; Average FPS : 0; Average Latency : 0; Ecc Mode; Current : Enabled; Pending : Enabled; ECC Errors; Volatile; Single Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : N/A; Total : 0; Double Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : 0; Total : 0; Aggregate; Single Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : N/A; Total : 0; Double Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : 0; Total : 0; Retired Pages; Single Bit ECC : 0; Double Bit ECC : 0; Pending Page Blacklist : No; Remapped Rows : N/A; Temperature; GPU Current Temp : 41 C; GPU Shutdown Temp : 90 C; GPU Slowdown Temp : 87 C; GPU Max Operating Temp : 83 C; GPU Target Temperature : N/A; Memory Curre,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:21199,Latency,Latency,21199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Latency'],['Latency']
Performance,"; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_zRopeZ"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:3299,load,loading,3299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"; | ErrorException(""could not load library ""libopenblas64_""; &nbsp; | libopenblas64_.so: ELF load command past end of file""); &nbsp; | ┌ Error: Error during initialization of module CHOLMOD; &nbsp; | │ exception =; &nbsp; | │ could not load library ""libcholmod""; &nbsp; | │ libopenblas64_.so.0: ELF load command past end of file; &nbsp; | │ Stacktrace:; &nbsp; | │ [1] dlopen(::String, ::UInt32; throw_error::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109; &nbsp; | │ [2] dlopen at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109 [inlined] (repeats 2 times); &nbsp; | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: LoadError: IOError: write: broken pipe (EPIPE); &nbsp; | Stacktrace:; &nbsp; | [1] uv_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:951; &nbsp; | [2] unsafe_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:1005; &nbsp; | [3] write(::Base.PipeEndpoint, ::String) at ./strings/io.jl:183; &nbsp; | [4] create_expr_cache(::String, ::String, ::Array{Pair{Base.PkgId,UInt64},1}, ::Base.UUID) at ./loading.jl:1194; &nbsp; | [5] compilecache(::Base.PkgId, ::String) at ./loading.jl:1286; &nbsp; | [6] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [7] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [8] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [9] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [10] include at ./Base.jl:368 [inlined]; &nbsp; | [11] include(::String) at /storage7/buildkite-agent/.julia-2581/packages/PencilA",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:3480,load,loading,3480,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['load'],['loading']
Performance,"; │ @ ./loading.jl:2340 [inlined]; │ [4] (::Base.var""#968#969""{Base.PkgId})(); │ @ Base ./loading.jl:1974; │ [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; │ [6] #mkpidlock#6; │ @ ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; │ [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; │ [8] #invokelatest#2; │ @ ./essentials.jl:894 [inlined]; │ [9] invokelatest; │ @ ./essentials.jl:889 [inlined]; │ [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); │ @ Base ./loading.jl:2983; │ [11] maybe_cachefile_lock; │ @ ./loading.jl:2980 [inlined]; │ [12] _require(pkg::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1970; │ [13] __require_prelocked(uuidkey::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1812; │ [14] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [15] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [16] _require_prelocked; │ @ ./loading.jl:1803 [inlined]; │ [17] _require_prelocked; │ @ ./loading.jl:1802 [inlined]; │ [18] run_extension_callbacks(extid::Base.ExtensionId); │ @ Base ./loading.jl:1295; │ [19] run_extension_callbacks(pkgid::Base.PkgId); │ @ Base ./loading.jl:1330; │ [20] run_package_callbacks(modkey::Base.PkgId); │ @ Base ./loading.jl:1164; │ [21] _tryrequire_from_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.jl:1574; │ [23] _require(pkg::Base.PkgId, env::String); │ @ Base ./loading.jl:1938; │ [24] __require_prelocked(uuidkey::Base.PkgId, env::S",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:2324,load,loading,2324,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"> ""Done"" isn't very precise since the cubed sphere will never be ""done"". But perhaps we can put a number on performance for the first milestone, which will allow us to conclude whether we need this optimization or not. True. Ideally we want to be close to the scalings/performance we got with lat-lon grid? That’s perhaps not feasible..? I don’t know how close is good enough tho. . > Can you explain where the gut feeling comes from? Will filling halos be so expensive even on just one GPU, or is this a distributed problem? Currently, 1/4 degree is performant on one GPU. Well at least some gut feeling comes from that am pretty sure that it can be reduced in half by getting done in a single pass. But you are on point, I don’t have a gut feeling regarding how much impact the two passes have on performance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718757478:108,perform,performance,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718757478,5,"['optimiz', 'perform']","['optimization', 'performance', 'performant']"
Performance,"> * I removed the `BackgroundField` v-velocity, which had no effect on the solution because the domain is `Flat` in y. The only effect of the background flow is through the bottom drag boundary condition. The docs preview hasn't updated yet, so I can't see the video, but I suspect removing `v` as a background creates oscillations. @glwagner have you checked? If not, let's wait for the video to see what happens... > * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Good move :+1: . > * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; > * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated). I tried to make it 100% GPU friendly actually (although I didn't test it). You already pointed out one flaw, which is the use of an array instead of a tuple for the unit vertical vector. > * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity. This only happens with me when the NetCDF file is open by another program (generally python in my case) while Julia is trying to write to it. Was that the case? If so, that's the usual behavior afaik and I don't think we can do anything on our end except inform users about it. > * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?. If we can get away with t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138:865,perform,perform,865,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138,1,['perform'],['perform']
Performance,"> 90% sure, but if it's not there it's in `centered_reconstruction.jl` or `upwind_biased_reconstruction.jl` I haven't gotten around to test performance for non-weno schemes but I should do it....; > ; > I ll guess I ll dedicate today to searching the issue, so we can merge. `@inbounds` in . https://github.com/CliMA/Oceananigans.jl/blob/91dfb119917f33514dbf8cd833778c44f6cea9b3/src/Advection/weno_interpolants.jl#L45-L46",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185611545:140,perform,performance,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185611545,1,['perform'],['performance']
Performance,"> === means that ""no program can distinguish"" between the objects. For arrays this basically means they point to the same space in memory; changes to one imply changes in another. == is a weaker statement, usually about numerical equality. What's counter intuitive?. Oh yeah I know about `===`. What I mean is that you test two grids with `==`, but Julia then tests each property with `===`. So the user is actually performing a much stricter operation than what it seems at first sight. That's the un-intuitive part to me. Although I may be missing something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945862255:416,perform,performing,416,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945862255,2,['perform'],['performing']
Performance,"> > 90% sure, but if it's not there it's in `centered_reconstruction.jl` or `upwind_biased_reconstruction.jl` I haven't gotten around to test performance for non-weno schemes but I should do it....; > > I ll guess I ll dedicate today to searching the issue, so we can merge; > ; > `@inbounds` in; > ; > https://github.com/CliMA/Oceananigans.jl/blob/91dfb119917f33514dbf8cd833778c44f6cea9b3/src/Advection/weno_interpolants.jl#L45-L46. I'm not sure that this is the deal breaker... I should have phrased is as a ""perhaps add @inbounds in.... ???""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185612738:142,perform,performance,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185612738,1,['perform'],['performance']
Performance,"> > > > @glwagner any idea why `gpu-simulations-tests` fail?; > > > ; > > > ; > > > Which grid points are specifically failing in the test?; > > ; > > ; > > How does one go about and answers this question? The log is not informative... Shall I run the tests myself online and then printout the two arrays?; > ; > Yeah, that's what you have to do to determine it... not urgent though... I tried to do that but the HPC at ANU when I use a queue with GPU access it does not have internet access. So it stops at `include(""data_dependencies.jl"")` line...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928225330:437,queue,queue,437,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928225330,1,['queue'],['queue']
Performance,"> > > The preview isn't showing for me. But we can fix any issues later, so I say merge away.; > > ; > > ; > > Yeah, It's also not loading for me. It feels like whenever I try to check PR previews it's kinda hit or miss. I wonder if this is an issue with Documenter.; > > But if you're okay with it, I'll merge it and we can fix any problems later.; > ; > It looks like it works for PRs that I submit, but not others. It may have to do with repo privileges. I think, for some reason whatsoever, the preview is not pushed just from the first commit. I think it's because there is a test whether that was a commit on a PR. And unless you first open the PR and then made the first commit that test returns false...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963656757:131,load,loading,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963656757,1,['load'],['loading']
Performance,> > @TZTsai thanks for this! I'm wondering whether this worths your time and effort since after we [removed](https://github.com/CliMA/Oceananigans.jl/pull/3052) the multigrid pressure solver from the code perhaps this is not so much needed.; > ; > Alright. But is `compute_matrix_for_linear_operation` still used in this project? If so it may still provide some optimization. @navidcy can you answer @TZTsai's question?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3229#issuecomment-1708642106:362,optimiz,optimization,362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3229#issuecomment-1708642106,1,['optimiz'],['optimization']
Performance,> > @TZTsai thanks for this! I'm wondering whether this worths your time and effort since after we [removed](https://github.com/CliMA/Oceananigans.jl/pull/3052) the multigrid pressure solver from the code perhaps this is not so much needed.; > ; > Alright. But is `compute_matrix_for_linear_operation` still used in this project? If so it may still provide some optimization. Sorry I missed the question!. I think in principle it could be used for the construction of the Heptadiagonal solver matrix (cc @simone-silvestri) but even for that the matrix is actually hardcoded for the particular free-surface problem. Right @simone-silvestri?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3229#issuecomment-1711066770:362,optimiz,optimization,362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3229#issuecomment-1711066770,1,['optimiz'],['optimization']
Performance,"> > @siddharthabishnu, `CUDA.@allowscalar` introduced by [3cdd470](https://github.com/CliMA/Oceananigans.jl/pull/3488/commits/3cdd4705fedf3238d8858bb0f56e9b27b01ba34a) is detrimental for performance. Like it induces O(10-100x) slowdown I think....; > > Is this a temporary solution?; > > cc @glwagner, @simone-silvestri; > ; > I think it is. We can try to see if this works on one GPU. If it does we can keep the allowscalar for the moment otherwise we can remove them. In the end all this will have to live in a kernel. Note that this will still not work on multiple GPUs as you cannot explicitly access one region from another one on a different GPU without switching to the device that holds the data. @simone-silvestri and @navidcy, I totally agree. I only introduced CUDA.@allowscalar under the impression it was necessary for certain GPU tests to pass. However, now understanding that isn’t the case, I've removed it in commit [7f54c3c](https://github.com/CliMA/Oceananigans.jl/pull/3488/commits/7f54c3c451c9753524056d45c6578a9cf865be68).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2035930379:187,perform,performance,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2035930379,1,['perform'],['performance']
Performance,"> > @siddharthabishnu, how do we know that now the metrics are filled correctly? you were comparing with a grid from MITgcm?; > ; > Yes. Consider the following sources for the grid metrics:; > ; > 1. the `cs32` grid with one halo layer, used by:; > ; > * Ali for the Rossby-Haurwitz test case in Oceananigans v0.82.0; and; > * yourself to check the interior coordinates and grid metrics of the Oceananigans `cc32` grid;; > 2. the `cs32` grid with 4 halo layers created by @jm-c using MITgcm;; > 3. the `cc32` grid created by Oceananigans.; > ; > In the validation scripts for solid body rotation and the Rossby-Haurwitz wave within the `ncc-glw/cubed-sphere-dynamics` branch associated with PR #3306, I compared the metrics of grid (3) against both (1) and (2), and plotted their absolute and relative differences. With the latest modifications, these differences have been minimized though not entirely eliminated. OK, so the benchmark is the `cs32` grid by MITgcm. Can we do the comparison in this PR? I'd like to see a test ideally because otherwise how do we assess that the changes we are suggesting here are correct. I can also do that, just give me a code snippet that loads the two grids?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1978039025:1176,load,loads,1176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1978039025,1,['load'],['loads']
Performance,"> > @simone-silvestri will the changes here impact CATKE on [CliMA/ClimaOcean.jl#17](https://github.com/CliMA/ClimaOcean.jl/pull/17) ?; > ; > not on the GPU, this PR affects only CPU performance. sorry, I was not clear... I was asking whether any syntax for adding parametrization with additional tracers changed. (But I think, no, right?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1487536293:183,perform,performance,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1487536293,2,['perform'],['performance']
Performance,"> > As an aside, I think this issue illustrates that users are indeed interested in being able to evaluate gradients across boundaries. This is important because @simone-silvestri proposed a change that would make this impossible (eg it has been proposed we do not fill halos for `Value` and `Gradient` boundary conditions, and instead evaluate the associated fluxes in the same way we do for immersed boundaries --- because this has performance advantages for very large models).; > ; > I agree, but this patch-up will not work for immersed boundaries anyway. What do you mean? What patch-up?. > I still advocate for (maybe not now but later down the line) a general line of thought that ensures consistency between immersed boundaries and ""regular"" boundaries (a la MITgcm) treating them always the same way. I agree I think that would be nice. It means that operators need to know about boundary conditions though, which is a major refactor... > As an example, this issue could have been brought up for immersed boundaries, which would have required a (definitely more lengthy) rework of boundaries in abstract operations but would have solved the issue in both boundaries and immersed boundaries. We support values and gradients on non-immersed boundaries, but we do _not_ support evaluating them across immersed boundaries. We have to support what we claim / say that we support, that is the only issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690226786:434,perform,performance,434,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690226786,1,['perform'],['performance']
Performance,"> > Average reduction with conditional expressions, e.g., like; > > https://github.com/CliMA/Oceananigans.jl/blob/748feab10a55fa65a46455620203252a6fc0646e/test/test_field_reductions.jl#L107; > > ; > > induce scalar operations on the GPU. I guess it's not a surprise. I just had to add, e.g,; > > ```julia; > > @compute Txyz = CUDA.@allowscalar Field(Average(T, condition=T.>3)); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > Only mentioning this here in case it might something in the source code that could be affecting code performance.; > ; > The condition should be a function of `f(i, j, k, grid, args...)` returning a boolean, or an `AbstractArray` of booleans.; > ; > We should implement boolean operations with fields to return boolean fields, so we will be able to pass an `AbstractOperation`; > ; > ```; > condition = T > 3 # This should be a boolean AbstractOperation; > @compute Txyz = Field(Average(T; condition)) ; > ```; > ; > at the moment the best way to specify a condition is through a function; > ; > ```; > @inline condition(i, j, k, grid, T) = T[i, j, k] > 3; > @compute Txyz = Field(Average(T; condition)) ; > ```. Agree with this. What is `T .> 3`? Is that a field? Either way, what we really want is to pass `T > 3` as @simone-silvestri says.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1239601022:559,perform,performance,559,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1239601022,1,['perform'],['performance']
Performance,"> > Average reduction with conditional expressions, e.g., like; > > https://github.com/CliMA/Oceananigans.jl/blob/748feab10a55fa65a46455620203252a6fc0646e/test/test_field_reductions.jl#L107; > > ; > > induce scalar operations on the GPU. I guess it's not a surprise. I just had to add, e.g,; > > ```julia; > > @compute Txyz = CUDA.@allowscalar Field(Average(T, condition=T.>3)); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > Only mentioning this here in case it might something in the source code that could be affecting code performance.; > ; > The condition should be a function of `f(i, j, k, grid, args...)` returning a boolean, or an `AbstractArray` of booleans.; > ; > We should implement boolean operations with fields to return boolean fields, so we will be able to pass an `AbstractOperation`; > ; > ```; > condition = T > 3 # This should be a boolean AbstractOperation; > @compute Txyz = Field(Average(T; condition)) ; > ```; > ; > at the moment the best way to specify a condition is through a function; > ; > ```; > @inline condition(i, j, k, grid, T) = T[i, j, k] > 3; > @compute Txyz = Field(Average(T; condition)) ; > ```. I get an error... ```Julia; navidcy@tartarus:~/Oceananigans.jl$ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.1 (2022-09-06); _/ |\__'_|_|_|\__'_| |; |__/ |. julia> using Oceananigans; [ Info: Oceananigans will use 4 threads. julia> using Oceananigans.Fields: CenterField, @compute. julia> trilinear(x, y, z) = x + y + z; trilinear (generic function with 1 method). julia> arch = GPU(); GPU(). julia> grid = RectilinearGrid(arch, size = (2, 2, 2),; x = (0, 2), y = (0, 2), z = (0, 2),; topology = (Periodic, Periodic, Bounded)); 2×2×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 2.0) regularly spaced with Δx=1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568:559,perform,performance,559,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568,1,['perform'],['performance']
Performance,"> > Can't we just plot a fixed-color shape on top on the mount on all panels? [`Makie.poly`](https://docs.makie.org/stable/reference/plots/poly/) seems to be able to do that.; > ; > We can.; > ; > We can also mask the output after we load it, e.g, via; > ; > using something like; > ; > ```julia; > using Oceananigans.ImmersedBoundaries: mask_immersed_field!; > ; > function mask_and_get_interior(φ_t, n; value=NaN); > mask_immersed_field!(φ_t[n], value); > return interior(φ_t[n], :, 1, :); > end; > ; > u′ₙ = @lift mask_and_get_interior(u′_t, $n); > ```; > ; > which gives; > ; > internal_tide.mp4 ; > But either of these solutions complicate the example a bit. Ideally, `mask_immersed_field!` should not be user-facing. And plotting a mountain on top of the mountain is a bit of a hack and would require a bit of explaining and justifying why we do that. I think we should mask the solution during visualization in the script. This is actually what users will need to do currently to make decent visualizations, so it is good to illustrate how to do it --- even if, hopefully, we will eventually have a better solution. As for plotting a shape on top, I'm inclined to encourage visualization that directly represents the domain / data for the purposes of an Oceananigans example. I think its ok if people want to incorporate visualizations like that in their own work but we may not want to promote it as ""the best"" way to visualize complex domains in this example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986381358:234,load,load,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986381358,1,['load'],['load']
Performance,"> > I think something like you're proposing would have added to my confusion.; > ; > Isn't the confusion a problem with the output writers API? I think it sounds like a great idea to support `AbstractOperation` output. It's kind of logical. Doing this even allows us to do some clever stuff behind the scenes, like using one underlying array to store the results of multiple computations performed serial (thus saving memory). The confusion is that I wasn't aware that that a `Field` has `data`, and therefore takes up memory, which allows it to store values. While an `AbstractOperation` is just instructions on how to compute things. This extended to the output writers, but I wouldn't say output writers were the source of confusion. If we make it so that users don't have to know what a `Field` is and we can use abstract operations everywhere, then my comment is moot.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036795591:388,perform,performed,388,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036795591,1,['perform'],['performed']
Performance,"> > I think to preserve the work in this PR, we should add a `Float32` test which will fail if a spurious promotion undermines performance; > ; > Agreed. I'll revisit this PR later to see if I can find where the conversion happens. The test I added only checks to see if we can take a time step. But I should be able to also add a test to ensure no spurious promotion occurred. Ah, that will work as a test if we remove the `convert`. The `convert` is a good sanity check to find where the problem is, but its not a solution since it merely allows the code to run without error --- it doesn't actually allow us to realize the benefits of using `Float32`. Arguably with this it is actually worse to use `Float32`, since the numerics are degraded bbut the perfrmance benefit is not fully realized",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445330720:127,perform,performance,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445330720,1,['perform'],['performance']
Performance,"> > I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors.; > ; > That's a good point. Although I think we could avoid creating another page and put that information in the [""Using GPUs""](https://clima.github.io/OceananigansDocumentation/stable/using_gpus/) page, so that things are more condensed. 🤦 there's already Using GPUs of course, silly me...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818368200:118,perform,performance,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818368200,2,"['optimiz', 'perform']","['optimizations', 'performance']"
Performance,"> > If our objective purely regards broadcasting, then we could probably generalize broadcasting so that `Fields` with singleton indices and/or `Nothing` location act more like reduced-dimensionality arrays. Is that what you would like to see?; > ; > Yes, it would be nice to have that feature. Do you want to have a crack at it? I don't use broadcasting with fields so much personally. It's a bit slow for some reason, which we have never quite figured out. Convenient for some things but not to be relied on unless we can solve the performance issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038969357:534,perform,performance,534,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038969357,1,['perform'],['performance']
Performance,"> > The preview isn't showing for me. But we can fix any issues later, so I say merge away.; > ; > Yeah, It's also not loading for me. It feels like whenever I try to check PR previews it's kinda hit or miss. I wonder if this is an issue with Documenter.; > ; > But if you're okay with it, I'll merge it and we can fix any problems later. It looks like it works for PRs that I submit, but not others. It may have to do with repo privileges.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963592320:119,load,loading,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963592320,1,['load'],['loading']
Performance,"> > To use python, we'd have to invoke `PyCall` right? Running python directly in the CI is possible but a bit of work and might be a pain to maintain.; > > I think its ""good"" to illustrate python usage, but also building and maintaining that example requires work that might be put to better use elsewhere... I'd shy away from doing this until there's either a more compelling need, or we have more resources for code development / maintenance...; > ; > Yes I think we'd need to use `Pycall`. I agree that's hard to maintain so let's not pursue that now.; > ; > I still think it'd be good to show one example with `NetCDF` writer though. Here's a question: is post-processing results directly in julia (making animations, plots, etc.) using the `NetCDF` output as easy as with the `jld2` output?. There's currently one example with NetCDF: https://clima.github.io/OceananigansDocumentation/stable/generated/shallow_water_Bickley_jet/. I'm not totally sure what's meant by easy. If plotting arrays, then the tasks are identical. If using `FieldTimeSeries` (to perform non-trivial finite volume calculations in post-processing for example) then that isn't supported with `NetCDFOutputWriter` (this is possible, but requires someone passionate about NetCDF to put in the effort there).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-954122449:1060,perform,perform,1060,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-954122449,1,['perform'],['perform']
Performance,"> > Very nice work @glwagner , and thanks for making this. Lots of good stuff here.; > > In your calculations, you find that there is saturation at 16 threads. I might guess that you have 16 cores on one node? I would think that this should be node dependent.; > > Also, in the table, might it be possible to compute the efficiency as well? I think that's more standard than speed up.; > ; > Ah, this machine has 48 cores. Since threading has an overhead cost, we expect saturation at some point. It's surprising that this happens at just 16 cores for such a large problem (512^3) though.; > ; > We can calculate more metrics for sure.; > ; > I think it would be worthwhile to investigate whether other threading paradigms scale differently for the same problem. Numba + parallel accelerator might be a good test case. @hennyg888 would you be interested in that?; > ; > Here are some docs:; > ; > https://numba.pydata.org/numba-doc/latest/user/parallel.html. You run out of memory bandwidth at some point - usually before you get to saturate all the cores for something; like diffusion. So some of 16 thread drop off could be that. . I guess we could get even more minimalist and check a multi-threaded stream benchmark to see that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886090304:1188,multi-thread,multi-threaded,1188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886090304,1,['multi-thread'],['multi-threaded']
Performance,"> > When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; > > ```julia; > > ERROR: LoadError: UndefVarError: `settings` not defined; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; > > ```julia; > > ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; > > ```; > ; > Do you need help fixing these?. @glwagner thanks for your help on Zoom yesterday. @navidcy thanks for creating a new PR #3305 to fix the second issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747159712:220,Load,LoadError,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747159712,2,['Load'],['LoadError']
Performance,"> > Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?; > ; > I was planning was to implement the tridiagonal solve similarly to what we do for single GPU as such:; > ; > ```julia; > transpose_z_to_y!(storage) # copy data from storage.zfield to storage.yfield; > solver.plan.forward.y!(parent(storage.yfield), buffer.y) ; > transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; > solver.plan.forward.x!(parent(storage.xfield), buffer.x); > transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; > transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; > ; > # Perform the implicit vertical solve here on storage.zfield...; > ; > transpose_z_to_y!(storage); > solver.plan.backward.y!(parent(storage.yfield), buffer.y); > transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; > solver.plan.backward.y!(parent(storage.xfield), buffer.x); > transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; > transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; > ```; > ; > This is not super great because it requires eight transposes, but I think it's the same thing that was happening in #2538. Can you just say, you are planning to implement the algorithm in #2538? The way you describe it, I can't figure out if you are coming up with something new or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197393925:837,Perform,Perform,837,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197393925,1,['Perform'],['Perform']
Performance,"> > Yeah this is pretty worrying... I'm pretty sure this is the cause of #1420 which has been open for a while so this slowdown must have been around for a while (and just flew under the radar). [Profiling](https://docs.julialang.org/en/v1/manual/profile/) might help pinpoint the bottleneck.; > ; > It looks like there are some extra temporary arrays being created for the cases with non-trivial (although still pretty trivial) indexing patterns. Profiling could be good - also just turning off as much as possible and then building up from the FFT alone, simple stencil etc... - if that is possible?. I did try with a different advection scheme (and `halo_size=(1, 1, 1)`) and the allocations were mitigated. This and @tomchor's result suggests that halo filling for periodic directions is a likely culprit. Profiling is a good idea. I also had the thought of commenting out much of the time-stepping loop and building up to try to pinpoint which functions trigger allocations as @christophernhill suggests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891521065:281,bottleneck,bottleneck,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891521065,2,['bottleneck'],['bottleneck']
Performance,"> > the time integral when we use variable time stepping that is a feature we use quite often; > ; > What do you mean by this?. Actually, I should probably say that I use the wizard quite often to change the time step. In my opinion, AB2 is a good compromise between accuracy, stability, and performance. RK3 is better only when you can achieve a CFL 3 times larger. We should fix the variable AB2 time stepper or discourage the use of frequent updates of the time step when using AB2. The first option is probably better in my opinion. I ll look into fixing AB2 and what it entails",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313376167:292,perform,performance,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313376167,1,['perform'],['performance']
Performance,> @TZTsai thanks for this! I'm wondering whether this worths your time and effort since after we [removed](https://github.com/CliMA/Oceananigans.jl/pull/3052) the multigrid pressure solver from the code perhaps this is not so much needed. Alright. But is `compute_matrix_for_linear_operation` still used in this project? If so it may still provide some optimization.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3229#issuecomment-1703878093:353,optimiz,optimization,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3229#issuecomment-1703878093,1,['optimiz'],['optimization']
Performance,"> @glwagner : I agree that the major savings would be the lack of vertical grid points, but having a full free-surface will likely force a smaller time step because of CFL. There would be two ways to reduce this constraint (in the future).; > ; > 1. Rigid lid (solve for the surface pressure); > 2. Implicit free-surface (treat the free-surface implicitly in the time-stepping); > ; > Both of these would borrow from the hydrostatic model, but the ingrediants are there, and would make it a lot faster. I would vote for implementing a rigid lid / vertically-`Flat` mode for the hydrostatic model instead, in order to keep the shallow water model as simple as possible (generalizing to multiple layers as an alternative direction would be nice I think). Have you benchmarked this? It is true that vertically `Flat` avoids a few vertical operations in the vertical advection term but since the kernel sizes are the same I'd be surprised if the performance differences are huge in terms of cost per time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736:942,perform,performance,942,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736,2,['perform'],['performance']
Performance,"> @glwagner CUDA aware MPI is supported for 11.2 but it is only built against OpenMPI 4.1.0 and 4.1.1, I think we had previously 4.0.4. Also julia 1.6.2 is available. good beta, I'll upgrade, thanks!. > looks like maybe some more race conditions on different hardware?. Heh yeah, pretty interesting. sverdrup is running on Quadro P6000 with CUDA 11; tartarus (where we sometimes run tests for development) has a Titan V, also I think with CUDA 11. These are running on a P100? With this new CI I'll need to make sure I can log in to central to debug.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906751484:230,race condition,race conditions,230,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906751484,1,['race condition'],['race conditions']
Performance,"> @glwagner I also ran into some problems using `StatProfilerHTML.jl` to make flame graphs for CPU profiles. This is from the same script used to obtain the results above and shown in #1914 and it's a 128^3 nonhydrostatic model. The flame graphs don't display the function names, and all I can see is ""overdub"". By hovering my mouse over the slabs and going up each flame stack I can usually find a function name that makes sense somewhere but that prevents us from making at-a-glance analysis of the profile flame graph.; > ![image](https://user-images.githubusercontent.com/45054739/128443657-7b18d4f9-0168-4bee-b85b-2ade021165d3.png); > I thought that this might have something to do with profiling `run(simulation, 10)` instead of a for loop of `time_step!(model,1)` but apparently the result is the same for both cases. I believe this is inevitable, because all our kernels are compiled through `Cassette.jl`, which ""overdubs"" the julia compiler when compiling functions tagged with `@kernel` (the majority of our expensive kernels). This is part of the design of `KernelAbstractions.jl`... Really great work @hennyg888. Perhaps the complexity of our function calls via `KernelAbstractions.jl` argues for a better profiling approach? Is there a way to ""filter"" the profiled output to remove data? . I think the next step towards improving performance is to figure out how to optimize the tendency calculations for CPU or GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894239292:1344,perform,performance,1344,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894239292,2,"['optimiz', 'perform']","['optimize', 'performance']"
Performance,"> @glwagner I'm not sure whats causing these tests to fail now?. @jagoosw afaik sometimes we get errors of the kind. `ERROR: LoadError: SystemError: opening file ""/data5/glwagner/.julia-10703/compiled/v1.8/Oceananigans/hU93i_Y0P9A.ji"": No such file or directory`. on the gpu tests. Which is what's hapenning now. It's now clear to me at least what the cause is, but restarting the tests generally makes them pass. I just restarted them so it be fine. I should note that we got an error of the kind. `Expression: all(test_fields.v .≈ truth_fields.v)`. in the GPU shallow water tests, which I thought were corrected. Is this something we need to worry about?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1481364658:125,Load,LoadError,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1481364658,1,['Load'],['LoadError']
Performance,"> @glwagner, regarding the; > ; > ```julia; > ERROR: LoadError: UndefVarError: bc not defined; > ```; > ; > in the Docs, is it related to; > [JuliaDocs/Documenter.jl#228](https://github.com/JuliaDocs/Documenter.jl/issues/228); > perhaps?. Nice find!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1843#issuecomment-879849296:53,Load,LoadError,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1843#issuecomment-879849296,1,['Load'],['LoadError']
Performance,"> @matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. For the moment those two elements are part of this PR.; > ; > This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft, the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult. Nice, thanks for that explanation. Why are we following 2decomp? PencilArrays has some benchmarking that shows it can compete with the fastest codes out there. I don't see anything similar for 2decomp, so I can't figure out what the motivation for following that strategy would be. I'm not sure if they are different, either. Something we do not previously support (but which is implemented in https://github.com/CliMA/Oceananigans.jl/pull/2538) was an algorithm that could support any topology with vertically-stretched grids. What is the relationship between this PR and https://github.com/CliMA/Oceananigans.jl/pull/2538, and does this PR support vertically stretched grids?. One of the main limitations of PencilArrays from our perspective is that it could not distribute an array along the first dimension. Since we almost always would like to use vertically stretched grids (and for various reasons, we may want to also compute the hydrostatic pressure with a vertical integral), ocean LES are typically distributed in x and y. Therefore, in order to support 2D domain decompositions, we were faced with somehow ch",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859:49,perform,performant,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859,2,['perform'],['performant']
Performance,"> @navidcy thanks for the commits. I am now testing the script against a free-explicit free surface and a MultiRegionGrid. @navidcy, as you may have anticipated, a MultiRegionGrid does not result in this error. Code Modification:; ```julia; #=; grid = ConformalCubedSphereGrid(; panel_size = (Nx, Ny, Nz),; z = (-1, 0),; radius = R,; horizontal_direction_halo = 6,; partition = CubedSpherePartition(; R = 1)); =#. latlongrid = LatitudeLongitudeGrid(size=(Nx, Ny, Nz),; longitude = (-90, 90),; latitude = (-45, 45),; z = (-1, 0)); grid = MultiRegionGrid(latlongrid, partition = XPartition(2)); ```; Terminal Output:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); ┌ Warning: MultiRegion functionalities are experimental: help the development by reporting bugs or non-implemented features!; └ @ Oceananigans.MultiRegion /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/MultiRegion/multi_region_grid.jl:102; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 7.722 days, wall time: 0 seconds; [ Info: ... simulation initialization complete (111.288 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (994.424 ms).; [ Info: Simulation is stopping after running for 0 seconds.; [ Info: Simulation time 628.319 ms equals or exceeds stop time 628.319 ms.; [ Info: Making an animation from the saved data...; ```; When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; ```julia; ERROR: LoadError: UndefVarError: `settings` not defined; ```; When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; ```julia; ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155:1675,Load,LoadError,1675,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155,2,['Load'],['LoadError']
Performance,> @sandreza might be a good idea to code up the case we were using the diagnose the race condition as a test and see if we can catch the race condition in CI @ali-ramadhan. Perhaps a regression test would work for this... and it'd be nice to have a regression test for the hydrostatic model too.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926695971:84,race condition,race condition,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926695971,2,['race condition'],['race condition']
Performance,"> @sangeethasankar01 are you trying to get this to run on the GPU for some specific purpose? Or is this merely an educational exercise?. I am a research scholar at IIT Madras, working under the supervision of Dr. Arjun Jagannathan. Currently, I'm exploring various problems related to flow instabilities. However, my current focus on this Kelvin-Helmholtz instability problem is purely for educational practice. I aim to understand the architecture of the code and optimize it for GPU execution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2029214744:465,optimiz,optimize,465,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2029214744,1,['optimiz'],['optimize']
Performance,"> @siddharthabishnu, `CUDA.@allowscalar` introduced by [3cdd470](https://github.com/CliMA/Oceananigans.jl/pull/3488/commits/3cdd4705fedf3238d8858bb0f56e9b27b01ba34a) is detrimental for performance. Like it induces O(10-100x) slowdown I think....; > ; > Is this a temporary solution?; > ; > cc @glwagner, @simone-silvestri. I think it is. We can try to see if this works on one GPU. If it does we can keep the allowscalar for the moment otherwise we can remove them.; In the end all this will have to live in a kernel.; Note that this will still not work on multiple GPUs as you cannot explicitly access one region from another one on a different GPU without switching to the device that holds the data.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2034043615:185,perform,performance,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2034043615,1,['perform'],['performance']
Performance,"> @simone-silvestri will the changes here impact CATKE on [CliMA/ClimaOcean.jl#17](https://github.com/CliMA/ClimaOcean.jl/pull/17) ?. not on the GPU, this PR affects only CPU performance",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1486715558:175,perform,performance,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1486715558,1,['perform'],['performance']
Performance,"> @xkykai do you think you could run some immersed boundary tests with this branch to make sure this change doesn’t affect your work? I think we’re interested in both performance and making sure the solution is high quality. Do you mean using the immersed pressure solver in this branch, and comparing the solution this produces with the one before this change?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1582859937:167,perform,performance,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1582859937,1,['perform'],['performance']
Performance,"> A more hierarchical organization of the docs is; > ; > 1. Introduction; > ; > * What's Oceananigans?; > * Installation; > * Writing your first script; > 2. Examples; > 3. Model setup; > ; > * Fields, BoundaryCondition, and AbstractOperations; > * IncompressibleModel; > * HydrostaticFreeSurfaceModel; > * ShallowWaterModel; > * Setting initial conditions; > * Diffusion, viscosity, and TurbulenceClosures; > * Forcing functions; > * Coriolis forces; > * Buoyancy forces; > 4. Simulations and post processing; > ; > * Simulation; > * OutputWriters; > * OutputReaders, post-processing, and plotting; > 5. Useful tips; > ; > * Using Graphics Processing Units (GPUs); > * Common errors and performance pitfalls; > 6. Contributor's guide; > 7. Gallery (this should be way higher eventually, but we need more recent content to motivate that...); > 8. Physics and numerical implementation; > 9. Appendix. I wholeheartedly agree with this structure :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879265116:688,perform,performance,688,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879265116,2,['perform'],['performance']
Performance,"> Ah interesting. Does this work because broadcasting over GPU subarray views is a little rough around the edges?; > ; > Also, is it worth adding the MWE from [#1767 (comment)](https://github.com/CliMA/Oceananigans.jl/issues/1767#issuecomment-868793917) as a test?. Certainly _something_ is rough... I think it's ""broadcasting over ReducedField"" that's the issue here. Prior to this PR, `mean!` used a broadcast over `R::AbstractReducedField` to compute the normalization. For some reason this has data synchronicity issues on the GPU (I'm at a loss to explain why). This PR just changes that broadcast operation to compute over all members of `R`. The halo regions of `R` (presumably) aren't touched during `sum!`, so doing some extra normalization in the halos doesn't really matter, I guess... (if we want halos to be right we should probably fill them after executing `mean!` in `compute!`, or something). But the _reason_ why this change fixes the issue isn't at all obvious to me. Maybe there's a bad interaction between `KernelAbstractions` (which gets used for the broadcast) and `sum!`? Not sure. Maybe another solution would wrap `sum!` in `CUDA.@sync` (eg the solution here could _implicitly_ synchronize in order to perform the broadcast correctly; otherwise CUDA wouldn't work generally... ?!?). Might be worth testing that, though I don't know which solution we should prefer (if any). In fact, it seems better to avoid using custom broadcasting machinery if possible (which is the current solution)...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-868839671:1228,perform,perform,1228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-868839671,1,['perform'],['perform']
Performance,> Also I found it quite cumbersome in scripts when I wanted to load these constants I had to load one from `Grids` and one from `Coriolis` and one from `BuoyancyModels`.... That's a bit counterintuitive from a user's perspective. Shouldn't you be defining and setting constants in the scripts if you are doing that?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492624226:63,load,load,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492624226,2,['load'],['load']
Performance,"> Another thought for @christophernhill; > ; > At the talk today on `ImplicitGlobalGrid.jl`, they were using `@view` in the simplest code but they dropped it as soon as they started to optimize the code. I believe they started using `LazyArrays.jl`. I don't know what it is but I suspect it doesn't have the problems that `@view` might have. @francispoulin thanks. I think we probably just want to do some buffer. I looked at LazyArrays.jl and I could imagine how that could maybe also be included, but I suspect the main thing is having a buffer (which https://github.com/eth-cscs/ImplicitGlobalGrid.jl has). I don't see any sign of LazyArrays in https://github.com/eth-cscs/ImplicitGlobalGrid.jl code! We can check with Ludovic though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885972875:185,optimiz,optimize,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885972875,2,['optimiz'],['optimize']
Performance,"> Another thought for @christophernhill; > ; > At the talk today on `ImplicitGlobalGrid.jl`, they were using `@view` in the simplest code but they dropped it as soon as they started to optimize the code. I believe they started using `LazyArrays.jl`. I don't know what it is but I suspect it doesn't have the problems that `@view` might have. We think that we cannot send non-contiguous data over MPI between GPUs (only CPUs). Thus certain `view`s will not work. Possibly in this case the data is transferred to CPU, sent over MPI, and then copied back to the GPU (slow).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885935875:185,optimiz,optimize,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885935875,2,['optimiz'],['optimize']
Performance,"> Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?; > ; > ```julia; > wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; > ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; > └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; > ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); > Stacktrace:; > [1] check; > @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; > [2] nc_create(path::String, cmode::UInt16); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; > [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; > [4] NCDataset; > @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; > [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Per",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839:601,Load,LoadError,601,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839,1,['Load'],['LoadError']
Performance,"> Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... The CUDA.jl implementation is such an implementation: https://github.com/JuliaGPU/CUDA.jl/blob/2310b88738c11449867e6f37c5acbfcd453dc2c8/src/mapreduce.jl#L60-L69. It probably needs to be profiled and optimized if you really want to squeeze out performance, but it isn't a naive implementation either. It's exposed via `Base.mapreducedim` and friends.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152:13,optimiz,optimizing,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152,4,"['optimiz', 'perform']","['optimized', 'optimizing', 'performance']"
Performance,> Are we making AMDGPU an extension?. I was asked to keep the PR minimal. I have a good deal of follow up work related to performance coming. You'll need to make AMDGPU a package extension after.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936969288:122,perform,performance,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936969288,1,['perform'],['performance']
Performance,"> As an aside, I think this issue illustrates that users are indeed interested in being able to evaluate gradients across boundaries. This is important because @simone-silvestri proposed a change that would make this impossible (eg it has been proposed we do not fill halos for `Value` and `Gradient` boundary conditions, and instead evaluate the associated fluxes in the same way we do for immersed boundaries --- because this has performance advantages for very large models). I agree, but this patch-up will not work for immersed boundaries anyway. I still advocate for (maybe not now but later down the line) a general line of thought that ensures consistency between immersed boundaries and ""regular"" boundaries (a la MITgcm) treating them always the same way. As an example, this issue could have been brought up for immersed boundaries, which would have required a (definitely more lengthy) rework of boundaries in abstract operations but would have solved the issue in both boundaries and immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689967113:432,perform,performance,432,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689967113,1,['perform'],['performance']
Performance,"> Average reduction with conditional expressions, e.g., like; > ; > https://github.com/CliMA/Oceananigans.jl/blob/748feab10a55fa65a46455620203252a6fc0646e/test/test_field_reductions.jl#L107; > ; > induce scalar operations on the GPU. I guess it's not a surprise. I just had to add, e.g,; > ; > ```julia; > @compute Txyz = CUDA.@allowscalar Field(Average(T, condition=T.>3)); > ```; > ; > Only mentioning this here in case it might something in the source code that could be affecting code performance. The condition should be a function of `f(i, j, k, grid, args...)` returning a boolean, or an `AbstractArray` of booleans. . We should implement boolean operations with fields to return boolean fields, so we will be able to pass an `AbstractOperation`; ```; condition = T > 3 # This should be a boolean AbstractOperation; @compute Txyz = Field(Average(T; condition)) ; ```. at the moment the best way to specify a condition is through a function; ```; @inline condition(i, j, k, grid, T) = T[i, j, k] > 3; @compute Txyz = Field(Average(T; condition)) ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1224162912:489,perform,performance,489,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1224162912,1,['perform'],['performance']
Performance,"> Billy mentioned it in some other comments but while we do splat args for some of the function calls, the function definitions use Varargs instead. This should avoid the catastrophic slowdown we saw with splatting earlier, but I agree that it should be tested. Do you have any good CPU performance tests set up @glwagner ?. Any simple test will do, for example one of the examples",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2150416681:287,perform,performance,287,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2150416681,2,['perform'],['performance']
Performance,"> Bonus, also the `mask_immersed_field` was missing. I don't expect it will be ever used (why using an immersed boundary grid in a single column?), however I have added a test for it. We can remove it if not needed. Good to have because it might be useful for testing and also, its definitely best if the single column mode is identical (except for performance) to 3D mode.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3756#issuecomment-2326759623:349,perform,performance,349,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3756#issuecomment-2326759623,1,['perform'],['performance']
Performance,"> By the way @tomchor, is this also the ratio that you find in your simulations (maybe with the latest commit)? If yes, I ll give up trying to inbound and only try to speed up the advection. I just tried with the latest commit and got this error:. ```julia; ERROR: LoadError: TaskFailedException. nested task error: UndefVarError: coeff_β_2_0 not defined; Stacktrace:; [1] left_biased_β(::Tuple{Float64, Float64}, ::WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}}, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, ::Val{0}); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:115 [inlined]; [2] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:115 [inlined]; [3] beta_loop(::WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}}, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, ::Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}, ::typeof(Oceananigans.Advection.left_biased_β)); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:163 [inlined]; [4] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:163 [inlined]; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:265,Load,LoadError,265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132,1,['Load'],['LoadError']
Performance,"> By the way, i didn't use the scheme described in #1704 because it didn't give great results when implemented. I have implemented the ENO coefficients as derived before the assumption of uniform grid to the stencil interpolation (tomorrow I'll go back and check the report which describes them) . The smoothness functions are kept the same. That's interesting. Does that mean you were not able to reproduce the results reported in ""[A simple algorithm to improve the performance of the WENO scheme on non-uniform grids](https://link.springer.com/article/10.1007/s10409-017-0715-2)""?. > > By the way, it would be quite easy to modify the type to include the order of the WENO scheme which we could change at will. What do you think? Would it be usefull to do that?; > ; > If it's easy, then I definitely vote that we do that! A lower order, faster WENO scheme may be a good compromise between computational cost and accuracy. If that's true, we could use it as the default scheme for models. I think a higher order WENO scheme is more important than lower-order scheme. However, a low-order WENO method is proposed [here](https://link.springer.com/article/10.1007/s10915-020-01164-6). I think the 3rd order scheme may be quite diffusive and runs the risk of limiting to 1st order (?!). #995 attempts to implement nth order WENO but I think failed to achieve good CPU performance / compilation on the GPU. But @simone-silvestri perhaps you're able to achieve this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969290093:468,perform,performance,468,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969290093,4,['perform'],['performance']
Performance,"> Can you put @inline in front of sponge_u_disc, etc?. Done. Same result. I also tried `ContinuousForcing` with `bottom_mask(x, y, z) = 1` and it's slower than its discrete counterpart. Apparently `DiscreteForcing` is a bit faster than `ContinuousForcing`, everything else being the same. > Again unsure if it affects performance but since rate is referenced as global it needs to be const; eg const rate = 1/10. Yes! That makes a big difference! I feel silly that I forgot that. With `const rate=1/10` and `DiscreteForcing` things are as fast as with no forcing. Using the same ""trick"" with `ContinuousForcing` doesn't change things though. So it does seem like the source of the issue is `ContinuousForcing`. I should say though, I'm having some trouble securing a GPU right now, so I haven't been able to run these tests on a GPU. Would a MWE help here?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875702050:318,perform,performance,318,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875702050,1,['perform'],['performance']
Performance,"> Can you try this branch and see if it goes better? `ss/fix-memory-issue`. It seems to solve the memory issue! But I do get an error when writing to disk:. ```; ERROR: LoadError: NetCDF error: size mismatch for variable 'dbdz' in file './data/out.PPN-R02F02A01.nc'. Trying to write (1022, 1022, 106) elements while [1014, 1014, 98, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:973; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:984; [3] setindex!; @ /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:460 [inlined]; [4] setindex!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:493; [5] setindex!(::NCDatasets.CFVariable{Float64, 4, NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/cfvariable.jl:765; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Fl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:169,Load,LoadError,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165,1,['Load'],['LoadError']
Performance,"> Can't we just plot a fixed-color shape on top on the mount on all panels? [`Makie.poly`](https://docs.makie.org/stable/reference/plots/poly/) seems to be able to do that. We can. We can also mask the output after we load it, e.g, via. using something like. ```Julia; using Oceananigans.ImmersedBoundaries: mask_immersed_field!. function mask_and_get_interior(φ_t, n; value=NaN); mask_immersed_field!(φ_t[n], value); return interior(φ_t[n], :, 1, :); end. u′ₙ = @lift mask_and_get_interior(u′_t, $n); ```. which gives. https://github.com/CliMA/Oceananigans.jl/assets/7112768/a402bfcd-ef72-42d8-bbb9-97fb98be4fe3. But either of these solutions complicate the example a bit. Ideally, `mask_immersed_field!` should not be user-facing. And plotting a mountain on top of the mountain is a bit of a hack and would require a bit of explaining and justifying why we do that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1983782339:218,load,load,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1983782339,1,['load'],['load']
Performance,"> Copied below.; > ; > ```; > ERROR: LoadError: `makedocs` encountered an error. Terminating build; > --; >   | Stacktrace:; >   | [1] error(s::String); >   | @ Base ./error.jl:33; >   | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document); >   | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255; >   | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document); >   | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170; >   | [4] #2; >   | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined]; >   | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String); >   | @ Base.Filesystem ./file.jl:106; >   | [6] #makedocs#1; >   | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined]; >   | [7] top-level scope; >   | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >   | 🚨 Error: The command exited with status 1; >   | user command error: exit status 1; > ```. This is only the top of the error. Farther down, we see. ```; ┌ Warning: failed to run `@example` block in src/generated/shallow_water_Bickley_jet.md:70-77; --;   | │ ```@example shallow_water_Bickley_jet;   | │ model = ShallowWaterModel(architecture = GPU(),;   | │ timestepper = :RungeKutta3,;   | │ advection = WENO5(),;   | │ grid = grid,;   | │ gravitational_acceleration = g,;   | │ coriolis = FPlane(f=f));   | │ ```;   | │ c.value = CUDA error (code 100, CUDA_ERROR_NO_DEVICE);   | └ @ Documenter.Expanders /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Expanders.jl:563; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390:37,Load,LoadError,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390,1,['Load'],['LoadError']
Performance,"> Could you explain why using ifelse has better performance?; Is this because the ternary ? : is an alias for ifelse?. No, the ternary operator `a ? b : c` is shorthand for . ```julia; if a; b; else; c; end; ```. This `if`-statement (as well as the logicals `&&` and `||`) are _short-circuiting_. That is, `c` is guaranteed _not_ to run if `a === true`. For example. ```; julia> f(a, first) = first ? a[1] : a[2]; f (generic function with 1 method). julia> a = rand(1); 1-element Vector{Float64}:; 0.6018054291910822. julia> f(a, true); 0.6018054291910822. julia> f(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] f(a::Vector{Float64}, first::Bool); @ Main ./REPL[7]:1; [3] top-level scope; @ REPL[10]:1; ```. The first call to `f(a, true)` executes without problems, because the second _branch_ isn't executed at all. On the other hand. ```julia; julia> g(a, first) = ifelse(first, a[1], a[2]); g (generic function with 1 method). julia> g(a, true); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If w",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:48,perform,performance,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583,1,['perform'],['performance']
Performance,"> Distributed IO is not supported yet and will require a lot of work and refactor so for the time being we have to do with the rank in the output writers. Distributed IO is not necessary to solve this problem. We can introduce a convention for filenames whereby the rank number is automatically inserted into the filename for distributed simulations. Similarly the convention can be reversed for `FieldTimeSeries` to make the process seamless for users. There are probably plenty of other possible solutions. The first step is recognizing that a problem or deficiency exists, and having the desire to fix it. Then we can do the fun part, which is to design solutions to an important problem. Note that distributed IO is unlikely to ever be supported for JLD2. So to provide a seamless experience with JLD2, we really do require a filename convention to solve the problem. (For NetCDF, we could envision providing a choice between file splitting or distributed IO.). Filename conventions also seem preferred to me for many cases in a world of GPUs where each rank likely needs to hold a substantial portion of the computation for performance. Splitting files by rank will limit the filesize, which makes it easier to transfer data when the simulations are very large --- which will probably often be the case when doing distributed simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895891029:1129,perform,performance,1129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895891029,1,['perform'],['performance']
Performance,"> For non local directions, if `storage` and `plan` are `unified_array`s, the non local FFT can be performed by permuting the partitioning of the `MultiRegionGrid` without having to transpose memory (that will happen under the hood thanks to unified memory). Just `storage` is an array; `plan` is a `CUFFT` object, not an array. If we use `cufftxt` would this happen be default?. ie with `cufftxt` we have to build a unified `storage` (and maybe unified eigenvalues). Then provided we can fill up storage correctly, and empty it correctly at the end, the thing that's left is to ""just do"" the fft (transposes etc handled under the hood). Does broadcasting work with unified memory arrays?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119868092:99,perform,performed,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119868092,1,['perform'],['performed']
Performance,"> Hello, @amontoison. Nice work. Do you see a performance improvement when switching to this package? There should be some benchmarks in the `benchmark` folder that we can test (probably we need to update that folder a bit, let me know if you have problems with it). Hi @simone-silvestri, `cg` is not too hard to implement, so I don't think we will see a significant performance improvement on CPU. ; However, for other methods like `gmres`, `Krylov.jl` easily outperforms `IterativeSolvers.jl`.; On GPU, though, we might see a difference because I try to dispatch to the BLAS/LAPACK routines of the GPU vendors as much as possible, whereas `IterativeSolvers.jl` relies on some broadcast. Also, to the best of my knowledge, only `cg` works on (NVIDIA) GPUs for `IterativeSolvers.jl`, while all solvers in `Krylov.jl` work on the GPUs of any vendor. I'll try to run some benchmarks before the end of the week.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3778#issuecomment-2373076041:46,perform,performance,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3778#issuecomment-2373076041,2,['perform'],['performance']
Performance,"> Hmm. I believe that scalar operations are (or were) _specifically_ allowed globally in our `runtests.jl`, overriding any default. I was considering deprecating that option though, so that scalar iteration would be disabled by default and can only be allowed for a limited number of statements using `@allowscalar` or `allowscalar() do ... end`, because it's such a performance trap. Is there so much scalar iteration being triggered by the Oceananigans tests?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-863772729:367,perform,performance,367,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-863772729,1,['perform'],['performance']
Performance,"> I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators. At least that is what @siddharthabishnu told me, I am not sure about the timings, can you confirm @siddharthabishnu?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353979984:99,perform,performance,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353979984,1,['perform'],['performance']
Performance,"> I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators. For example, if the boundary is fixed and not dependent on the interior variables, it might be possible just to fix the BC once before the sub stepping and just iterate without needing to use any update",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319:99,perform,performance,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319,1,['perform'],['performance']
Performance,"> I believe in this case that the function d.▶ from the above is identity, which could fail because it's also called in the calculation of the binary operation w * v?. I gotta be honest that whole discussion went right over my head, haha. I think mostly because I don't really understand what's the exact use of `identities` and what the functions `d.▶` actually do. . Am I correct in assuming that if I specify where each calculation is performed (by using `@at`) I can decrease the computational complexity and maybe make `ComputedField`s easier to compile on GPUs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786854048:438,perform,performed,438,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786854048,1,['perform'],['performed']
Performance,"> I don't know exactly what to do, so we'll need help. I've started with a post to the julia slack: https://julialang.slack.com/archives/C67910KEH/p1635909337281400; > ; > On the other hand, it may not be a huge issue if it only affects diagnostics that are evaluated fewer than 5 times. For long running simulations, our methods do eventually get cached? Do you have an example of a method that doesn't get cached after 5 evaluations?. ~When I was running an actual simulation this issue seemed to persist after many evaluations (i.e. writings to disk), and not just the first few times. So it may be that doing it 5 times consecutively on the REPL is different from the simulation behavior. That said, I didn't pay a ton a attention to that, so I may have been wrong.~. ~I'll try to investigate this further tomorrow on my end if I have time.~",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958632710:348,cache,cached,348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958632710,2,['cache'],['cached']
Performance,"> I don't think we ever used `power_by_squaring`, because the ""pre 1.6"" Oceananigans kernels were defined via`KernelAbstractions`, which in turn translated `^(a, b)` to `CUDA.pow(a, b)`:. I know, I was thinking about what would be a good ""new"" default behavior. CUDA.jl used to truncate Int64 exponents to Int32, resulting in `powi` use, but although that was good for Oceananigans it's a bad default. Using `pow` after casting the exponent to Float64 seemed like a good idea, but is apparently slow in your use case. `Base.power_by_squaring` is slow in microbenchmarks, but may perform better in a realistic application? If that's the case, I could change the implementation of `^` in CUDA.jl. But I also realize now that exponentation by a small constant, which you seem to be doing here, should probably be handled differently. Base has `literal_pow`, not sure why that isn't kicking in here. Feel free to file an issue about that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870021086:579,perform,perform,579,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870021086,1,['perform'],['perform']
Performance,"> I guess I also see timers as a debugging tool for users. Totally agree since simulation performance can depend entirely on performance of forcing functions, boundary conditions, and diagnostics; not just code that ships in src.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888341027:90,perform,performance,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888341027,2,['perform'],['performance']
Performance,"> I just pushed changes for the geostrophic adjustment case. The code seems alright, but it returns the following warning:; > ; > `warning: ~/.julia/packages/KernelAbstractions/GCOhX/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering`; > ; > Then it returns the following error:; > ; > Error output:; > Any idea what it could be, @simone-silvestri ?. That's related with #3374 and the warning comes from Julia v1.10 (wasn't there with Julia v1.9).; The PR #3403 will deal with these warnings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895005561:235,optimiz,optimizer,235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895005561,2,"['optimiz', 'perform']","['optimizer', 'perform']"
Performance,"> I never understood why a `CFL` object had to be pre-constructed, but I always assumed there was a good (probably GPU-related) reason for that. I guess it's helpful if we have competing functions for computing time-scales (for performance reasons). But if we have just one fast function then it doesn't seem like there's a good reason.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958584552:228,perform,performance,228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958584552,1,['perform'],['performance']
Performance,"> I over-simplified. FFTs are efficient when there are a small number of prime divisors --- 2, 3, 5, 7 --- of the length of the sample. 100 may actually be ok because it is 2*2*5*5. I don't feel strongly, but you will find that most people running simulations are using powers of 2 and 3 (128, 192, 256, 384, 512, 768, 1024) --- even when their code has no FFTs! Perhaps the purpose of this convention is so people who _do_ use codes that rely _heavily_ on FFTs are able to run code comparisons. I find the convention to be an appropriate best practice. An 1D FFT of length 257, for example, is 4 times slower than an FFT of length 256 on my machine. For tests, of course, using small numbers of prime divisors is completely irrelevant; I just want to encourage best practices and promote awareness of them, and also implicitly emphasize to users that this code uses FFTs, and don't want random person X to read the tests and scratch their head and ask ""doesn't this code rely on FFTs?"" (like I did when I saw the examples). I don't disagree with anything here. I just think users should be able to run using whatever resolution they want and know that the code has been tested and works with weird inefficient resolutions. To encourage users maybe we can print a ""performance warning"" if the grid resolution is not the product of a small number of prime divisors?. > I certainly prefer that. It may be academic because the architecture should probably be a parameter of `Model`. That makes sense. I think we should just be wary of having too many parametric types but architecture probably warrants being one as we'll dispatching on it so frequently.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468537451:1265,perform,performance,1265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468537451,1,['perform'],['performance']
Performance,"> I see that one of the errors is `UndefVarError: device_event not defined`, which I suppose means we need to load it?. Indeed, I'll fix that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1913#issuecomment-890028428:110,load,load,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1913#issuecomment-890028428,1,['load'],['load']
Performance,"> I share here a double drake experiment that makes full use of this PR; > ; > #### Grid setup; > * latitude longitude grid from 75 S to 75 N; > * 1/3 of a degree in the horizontal (1080 points in longitude, 450 in latitude); > * 150 exponentially stretched vertical levels for a 3km deep ocean; > * double drake bathymetry (https://doi.org/10.1175/2009JCLI3197.1); > ; > #### Top BC:; > * temperature: restoring to reference profile (cosine shape); > * salinity: prescribed latitudinally dependent surface flux; > * zonal velocity: prescribed latitudinally dependent wind stress; > ; > #### Bottom BC:; > * velocities: linear bottom drag with a drag coefficient of 0.003 ms⁻¹; > ; > #### Initial conditions; > * zero velocities; > * exponentially stratified temperature with SST equal to the reference temperature; > * constant salinity; > ; > #### Model setup; > * linear equation of state; > * Richardson-based diffusivity for BL mixing; > * vertical background viscosity and diffusivity of 5e-4 and 3e-5, respectively; > * vector invariant momentum advection with WENO for vorticity and divergence flux as well as vertical transport (no horizontal viscosity); > * WENO for tracer advection (no horizontal diffusivity); > * Split explicit free surface using an averaging shape function and a CFL of 0.7 (23 substeps per time step); > ; > #### Simulation setup; > * time step of 10 minutes; > * ran on 2 MPI processes with CUDA-aware MPI; > * performs about 10 simulated years per day; > ; > On the left, there is the free surface evolution, on the right the surface vertical vorticity (evolved for 9 years). This would be a good setup to add to `ClimaOcean.jl`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431581342:1445,perform,performs,1445,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431581342,1,['perform'],['performs']
Performance,"> I think prior to the changes we grouped into our ""upgrade to julia 1.6"" we were using the function `CUDA.pow` (from an ancient `CUDA.jl` version). Ah, in that case we were doing something pretty bad: https://github.com/JuliaGPU/CUDAnative.jl/blob/199f9b8ebb1f2fc9d7c14547efa9bcc14f4130c3/src/device/cuda/math.jl#L209. The new default, converting Int64 exponents to Float64, seems better. Unless `power_by_squaring` performs better in realistic applications?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869833684:417,perform,performs,417,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869833684,1,['perform'],['performs']
Performance,"> I think something like you're proposing would have added to my confusion. Isn't the confusion a problem with the output writers API? I think it sounds like a great idea to support `AbstractOperation` output. It's kind of logical. Doing this even allows us to do some clever stuff behind the scenes, like using one underlying array to store the results of multiple computations performed serial (thus saving memory).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036767779:379,perform,performed,379,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036767779,1,['perform'],['performed']
Performance,"> I think that should be revisited when we decide to take on the more challenging issue of checkpointing partially-accumulated time-averages so that windowed_time_average always works as intended when picking up from checkpoints. good point!. There is a possibility that it is not very hard. It will require reshuffling code (which I can do), but with Julia we can serialize objects to disk and then load them back seamlessly in a single line... which might be all we need. The only limitation of serialization is that we haven't yet figured out how to serialize _methods_ (eg functions) which prevents us from serializing entire models. When functions are not involved things can be pretty simple.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379890956:400,load,load,400,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379890956,2,['load'],['load']
Performance,> I think the new diffusion/cosine tests? Can't think of something else... Ah indeed. It's also possible that some PRs caused a compile-time regression. Hopefully not a performance regression though. We should test that.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2324#issuecomment-1062527828:169,perform,performance,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2324#issuecomment-1062527828,1,['perform'],['performance']
Performance,"> I think this makes things more intuitive, no? Are there any downsides besides a slightly longer building time for `model`?. There's no downside. `update_state!` has to be efficient for the model to run so I don't think there's a performance issue. I think it's more ""correct"", since without that call the auxiliary state may be wrong initially.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885340708:231,perform,performance,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885340708,2,['perform'],['performance']
Performance,> I think to do this cleanly we might want to follow up with what @vchuravy was doing here #3042. I tried experimenting with this on the OceanBioME tests and it seems to be preventing it from segfaultinig https://github.com/OceanBioME/OceanBioME.jl/pull/190 (and testing running them both at the same time here https://github.com/OceanBioME/OceanBioME.jl/pull/196). But it does also seem to run quite a bit slower so I'm going to see how much I can get it to cache without it causing problems. And then I can copy the implementation over to here.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3662#issuecomment-2265916968:459,cache,cache,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3662#issuecomment-2265916968,1,['cache'],['cache']
Performance,"> I think to preserve the work in this PR, we should add a `Float32` test which will fail if a spurious promotion undermines performance. Agreed. I'll revisit this PR later to see if I can find where the conversion happens. The test I added only checks to see if we can take a time step. But I should be able to also add a test to ensure no spurious promotion occurred.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445251168:125,perform,performance,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445251168,1,['perform'],['performance']
Performance,"> I think we should distinguish between output we need when we run the model, and output we may eventually provide to the broader community. Ideally, formats for both would be the same, but this may not be the best solution. E.g., netCDF has obvious disadvantages but is still widely used. That does not mean it should be the output format we use by default (although we may want to provide model statistics in netCDF in the end, if a few years from now this is still what everyone uses). So: separate the discussion of what is best for us now from what we should provide (e.g., in any CMIPx archive down the line). Zarr and HDF both seem worth discussing.; > ; > Also important to keep in mind in this discussion: Our workflow will be different from most standard models, which write out instantaneous output that then is post-processed to get statistics etc. We will have to accumulate statistics on the fly, and we can (and should) forgo most instantaneous output, at least for the atmosphere. The model will learn from the accumulated statistics. Otherwise, with instantaneous output, the data volume, especially with embedded LES, will create an I/O and data transfer bottleneck that will limit us, and, e.g., will limit our ability to use distributed computing platforms. I agree. Ideally we'd support different formats (e.g. NetCDF, JLD2, HDF, Zarr, etc.) and have the option to use the best format for your application. We can already switch between output writers and choose which field(s)/diagnostics to output but we only do binary, NetCDF, and JLD for now. We were just focusing on NetCDF for our short-term needs, but this will definitely be a challenge for large problems.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476303978:1173,bottleneck,bottleneck,1173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476303978,1,['bottleneck'],['bottleneck']
Performance,"> I think you may need @inline in front of most of those functions (only matters for CPU). ~That was my first attempt, but I get an error saying `ERROR: LoadError: LoadError: -(grid.Lz) + grid.Δz * (k - 1 / 2) is not a function expression`. I guess I need to choose between `@inline` or `@inbounds`?~. Nevermind, I was doing something very dumb. Inlining gives me exact same performance as not inlining (0.20% of the simulation). I guess the compiler is getting smarter about inlining. > If the slow down is the same for DiscreteForcing then the problem may really just be evaluating exp, sadly... You could try @inline bottom_mask(k) = 1 to test... I'll try that. Although I have tried non-exponential masks in the past with a similar slowdown, so I'm not sure if that's the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875673783:153,Load,LoadError,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875673783,3,"['Load', 'perform']","['LoadError', 'performance']"
Performance,"> I would advocate again for moving both CUDA and AMDGPU support into package extensions (see #3066 for an outdated start); > ; > Having the user install both AMDGPU and CUDA unconditionally is both space and time consuming, loading them both should be unnecessary on most systems and they may at times be incompatible with each other since both are developed independently from each other. That's a good idea. Maybe we can start by developing AMD support (this PR) in an extension, and then move CUDA after that (just to relieve some pressure on @fluidnumerics-joe).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935396471:225,load,loading,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935396471,1,['load'],['loading']
Performance,"> I'll explain quickly what is happening to document it. In this new PR I added a new way to check boundary stencils for advection so that the correct reconstruction method is always used.; > ; > This entails checking differently for `Face` reconstructions (where we have to ensure that `Center` locations are active) and vice versa for `Center` reconstructions where `Face` locations have to be active.; > ; > The problem occurs when checking the last cell for `Center` reconstructions (on a `Periodic` direction) let's say the advection is centered order 4 so hypothetically it requires two halo points. We then need to ensure that the nodes at `N + 1` and `N + 2` are active. A `Face` node (i) is active if either centered cell (i) or (i+1) is active, which means that the check will be performed on cells `N+1`, `N+2` and `N+3` (one more than the required halo size = 2!).; > ; > This is not a problem for a underlying grid where the `inactive_node` function can check out-of-bounds locations and will just return a `true`. On the other hand, it is a problem for an `ImmersedBoundary` where a conditional has to be evaluated against an AbstractArray.; > ; > My first solution was to increase by one the halo under the hood in the `ImmersedBoundaryGrid` constructor. This bug with `set!` demonstrated that this is probably not the best solution as this can have a lot of unwanted repercussions. The way I implemented it now is that, when performing the halo checking in the model constructor, if the grid is an `ImmersedBoundaryGrid`, the `required_halo` is incremented by one, and an appropriate warning message is displayed. This was the problem. So in the end I decided to just require one additional halo for the immersed boundary grid",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181806144:790,perform,performed,790,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181806144,2,['perform'],"['performed', 'performing']"
Performance,"> I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling. I didn't know this was a KA.jl-based GPU workload when commenting on Slack. The dependency/event model of KernelAbstractions.jl also uses stream queries (i.e. `cuStreamQuery`) when selecting a new stream. Maybe that's the source of these calls. It'd be good to figure out where they come from: if it's from CUDA.jl, and thus presumably because of calling the `synchronize` function, (1) why are you synchronizing that much [1], and if it's for good reasons (2) does it hurt performance and should we tweak our `synchronize` implementation to perform fewer stream queries?. [1]: some synchronization happens implicitly, e.g. when copying memory to or from the CPU (https://github.com/JuliaGPU/CUDA.jl/blob/6758fcab7ae0d72659a1ca0d56ad2c86d3b451f1/src/array.jl#L385-L399). One way to avoid some of those synchronizations, is by using pinned memory, but that's up to the application.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869:637,perform,performance,637,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869,2,['perform'],"['perform', 'performance']"
Performance,> I'm not sure if we've tested but I've assumed there is a performance benefit to the simpler version for regularly spaced grids rather than using the binary search. @simone-silvestri have you ever benchmarked this?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775545546:59,perform,performance,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775545546,2,['perform'],['performance']
Performance,"> I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors. That's a good point. Although I think we could avoid creating another page and put that information in the [""Using GPUs""](https://clima.github.io/OceananigansDocumentation/stable/using_gpus/) page, so that things are more condensed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818364275:116,perform,performance,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818364275,2,"['optimiz', 'perform']","['optimizations', 'performance']"
Performance,"> If I understand correctly this would make the `field_slicer` argument for output writers obsolete, no?. I missed this! Yes, that's correct. We _could_ keep it, however I think it's nicer to remove because it's one of the best ways to ensure that the ""windowing infrastructure"" implemented in this PR is performant and easy to use. In place of `field_slicer`, we will add some convenience arguments (`indices` and `with_halos`) that allow output fields to be ""constructed"" from what's given to `OutputWriter`. This will also allow us to close #2242 (but I haven't implemented that yet here).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2246#issuecomment-1044762888:305,perform,performant,305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2246#issuecomment-1044762888,1,['perform'],['performant']
Performance,"> If forcing functions are expensive there may be simpler ways to do performance optimization though. For example, we can recommend piecewise linear masking functions for sponge layers instead of tanh or exp. From my tests I think this optimization can shave off 10% of time on the CPU and 25% on the GPU. This isn't bad, but I anticipate launching `Forcing` only where necessary would shave of much more in the situations I mentioned. Although when I originally posted the issue I thought it could be directly implemented in `Forcing`, but you make a good point that it can't, so it might not be worth the effort (at least not right now). I'll close this for now but feel free to re-open it if you think it's worth discussing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2033489092:69,perform,performance,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2033489092,6,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"> If we assume that reduced fields ""lives"" nowhere in the reduced direction, then we can remove the k index and just perform an ""immersed-boundary-unaware"" derivative. > On the other hand, if the reduced field lives on the whole reduced column (like for example an integral) then we need to be aware of the ""immersed column"", because if the whole column is immersed then the derivative should return a zero. What is the difference between ""living nowhere"" and ""living on the whole column""?. I think the point of reduced fields is that they are derived from a reduction over one or more dimensions. Since they are derived from a reduction, they invoke values from every element in the column / reduced direction. I don't understand what it means to ""live nowhere"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2099199410:117,perform,perform,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2099199410,1,['perform'],['perform']
Performance,"> Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the Distributed module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). I think (but am not 100% sure) that PencilArrays is tied to MPI. So I guess for 1 we are either ""borrowing"" (but not using directly) the transpose algorithm from PencilArrays, or we are extending the code so that it works ""without MPI"" -- and also with GPUs, which is work in progress: https://github.com/jipolanco/PencilFFTs.jl/pull/37. Another reason to focus on 2 is that we can use PencilFFTs for _distributed_ (but _not_ `MultiRegion`) nonhydrostatic model. So even if PencilFFTs had support for CuArray now (and if `Distributed` were performant for multi GPU --- both of which may not be too close), using cufftxt could still _potentially_ be motivated by performance reasons. In other words, if we develop a capability with cufftxt, then in the future we can also support multi GPU via PencilFFT and `Distributed`, and we have two options (one perhaps performant on single node, multi GPU, and another to use when you need GPUs spread across multiple nodes).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852:124,perform,perform,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852,6,['perform'],"['perform', 'performance', 'performant']"
Performance,"> In particular, this PR introduces the async keyword argument to fill_halo_regions! that allows launching MPI operations without waiting for the communication to complete. Would `blocking=true/false` be a better word to describe how we are controlling `fill_halo_regions!`?. I think ""async"" isn't quite the right word. ""async"" describes the overall algorithm (eg performing some computation while the communication is taking place), but does not describe what is happening specifically within `fill_halo_regions`. It's possible to write `async=true` without overlapping communication and computation. https://github.com/CliMA/Oceananigans.jl/pull/2881 introduces the kwarg `blocking` for `mask_immersed_field!`, which means the same thing:. https://github.com/CliMA/Oceananigans.jl/blob/4a71c834cbc057fcc27061a1d22b4a7cc3eb38fe/src/ImmersedBoundaries/mask_immersed_field.jl#L13. so either way let's use one word.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2953#issuecomment-1452252842:364,perform,performing,364,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2953#issuecomment-1452252842,1,['perform'],['performing']
Performance,"> Instead of saying that trig functions should be avoided on gpus, which seems very strong, I suggest pointing out that there have been some examples where trig functions have performed much slower, and include this example.; > ; > This clearly problem needs further exploration but I don't want people to be scared to use sin and cos because sometimes they just make a lot of sense. My two cents worth. I think there may be a bug in the setup that produces 100x slowdown. (@tomchor if you supply the whole script, we can investigate.) We've run many successful problems with trig functions. Some recent work by @simone-silvestri suggests we can get 2x speed up for _some_ problems by precomputing grid metrics for the `RegularLatitudeLongitudeGrid` rather than computing them on the fly:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/Operators/spacings_and_areas_and_volumes.jl#L178-L179. But I don't think we've definitely shown that we _always_ will get 2x speed up. Thus we are going to retain the option to compute metrics on the fly in #2025 so we can continue to investigate it. 2x is a long way from 100x though. If used in a boundary conditions, its basically irrelevant whether one uses a trig function or not. Even a forcing function is only evaluated once per grid point compared to 15x (or more?) for a `BackgroundField` velocity component with high-order advection. Some of these thoughts might be distilled into useful advice in this section of the docs. But we should definitely focus on _approaches_ to performance optimization rather than advice for specific scenarios.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951555050:176,perform,performed,176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951555050,6,"['optimiz', 'perform']","['optimization', 'performance', 'performed']"
Performance,"> Interesting idea @christophernhill . For the last results that @hennyg888 posted in #1722, I did some calculations and found the following.; > ; > ```; > GPU; > N=256 3.0e9; > N=128 2.6e9; > N=64 6.6e8; > ; > CPU; > N=256 8.6e6; > N=128 9.1e6; > N=64 9.0e6; > ```; > ; > In an article that @ali-ramadhan referenced on the slack channel recently, a paper using a shallow water model in python, Roullet and Gaillard (2021), said they were getting 2 TFlops per second using a thousand cores. We are getting 3 GigaFlops on GPU and 9 MegaFlops.; > ; > Certainly very good speedup since we have O(400) with `WENO5`, but this makes me wonder whether we could do better?; > ; > But to answer your question, when @hennyg888 has the data, we can certainly produce these plots easily enough (unless there is a problem that I'm missing). We have to do more work to compare with Roullet and Gaillard (2021). First of all, there are typos in the paper: sometimes the performance is listed as 2 GFlops, other times as 2 TFlops. Second --- if I understand the situation correctly --- I don't think we've ever measured floating point operations per second. The numbers you've calculated are grid points per second; however we do many floating point operations per grid point. Roullet and Gaillard (2021) estimate their code performs something like 700-800 Flops per grid point. ![image](https://user-images.githubusercontent.com/15271942/126053492-345154c2-22e2-4af8-a898-ac68e889733d.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881986070:955,perform,performance,955,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881986070,2,['perform'],"['performance', 'performs']"
Performance,"> Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?; ; Maybe this indicates that the changes are due to changes in the dependencies when upgrading to 1.8?. > I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?. That's interesting. I'm actually also performing a significant amount of 3D averages, as you picked up on. The reason for that is because I want them at a higher frequency than the 3D snapshots that I'm outputting. I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800:617,perform,performed,617,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800,4,['perform'],"['performed', 'performing']"
Performance,"> Is that what you recommend?. That wouldn't solve your problem here. KA gives you reasonable performance on the CPU, but since KA 0.8 it is execution story on the CPU much closer to the rest of Julia and it doesn't play special tricks.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481565094:94,perform,performance,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481565094,1,['perform'],['performance']
Performance,"> It is what the right panel shows, if I am not mistaken. But the simulation crashed after thousands of iterations. I heard that the PCG solver in Oceananigans has not been widely tested, so that is why I turned to the HeptadiagonalIterativeSolver. Both of those solvers actually use the preconditioned conjugate gradient method. It's also not true --- the `PreconditionedConjugateGradientSolver` has been validated. I'm not even sure it's possible to use the FFT-based preconditioner with the heptadiagonal solver, they have different interfaces. Maybe you worked on that. It's not obvious how to generalize the `HeptadiagonalIterativeSolver` to support `Distributed` architecture, and its also likely more difficult to optimize for immersed boundary methods using an active cells map. We shouldn't waste our time with the `HeptadiagonalIterativeSolver`. If the `PreconditionedConjugateGradientSolver` has issues, we should fix them. It's a waste of energy to work on both.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071221835:721,optimiz,optimize,721,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071221835,1,['optimiz'],['optimize']
Performance,"> It returns a int with the value of the number of files or file divisions already performed and the file name. if files are file_part_1.nc, file_part_2.nc, file_part_3.nc, the output will be: `3 file_part_3.nc`. How about calling it `split_files` or `number_of_split_files`?. Could also improve clarity to split it into two functions. One to return the number of split files, and the other to return `current_split_filename`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2414761941:83,perform,performed,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2414761941,1,['perform'],['performed']
Performance,"> It seems very strange to me that evaluating trig functions is slow on GPUs. Is this we problem known to CUDA.jl?; > ; > The information you have here seems good to me. ""slow"" is ill-defined. We recently found that precomputing grid metrics for the latitude-longitude grid leads to a 2x speed up for simple 2D cases (less for more complex cases, probably). But it's all relative to other calculations that are being performed. For many ocean codes the limiting step is evaluating the nonlinear equation of state (a 55 term polynomial) at various locations on the grid. For these cases, the cost of trigonometric functions may not be noticeable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951425085:417,perform,performed,417,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951425085,2,['perform'],['performed']
Performance,"> It'd be nice to state in writing the justification for writing a separate CPU solver for certain problems. In general, I think that any algorithm that works on the GPU will also work on the CPU. Thus at least in principle the simplest choice is presumably to use the same solver on both architectures. Good point, I've been meaning to set up a script for benchmarking the different pressure solvers. We should use performance benchmarking results to make decisions. > Also, I'd encourage writing this code into as self-contained a submodule as possible. I think there are other codes in the julia ecosystem (not least FourierFlows.jl!) that would benefit from fast and multi-architecture Poisson solvers. We don't have to break this into a separate package just yet, but we do want to ensure this is easy to do in the future. Another good point. As you pointed out some of these solvers depend on the `grid` but if we take that out (which would be trivial) then I think the solvers in PR #589 would be pretty reusable by other packages. Although right now they're pretty specific to staggered grids (except for `BatchedTridiagonalSolver`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/586#issuecomment-572303204:416,perform,performance,416,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586#issuecomment-572303204,1,['perform'],['performance']
Performance,"> Just a quick update, zero-viscosity Bicklet jet test case for `VectorInvariant`, `WENOVectorInvariant` (smoothness calculated based on `ζ`), modified VectorInvariant WENO with smoothness based on 2D stencils of `u` and `v`, here called `WENOVectorInvariantZVEL`; > ; > `VectorInvariant` https://user-images.githubusercontent.com/33547697/157745561-a8e5f128-2f4e-42e3-9305-3f624498590b.mp4; > ; > `WENOVectorInvariant` https://user-images.githubusercontent.com/33547697/157745569-41c52e2d-c80b-4d43-b2bf-8a914e8856a2.mp4; > ; > `WENOVectorInvariantZVEL` https://user-images.githubusercontent.com/33547697/157745571-725ea604-8dec-44bd-bd08-dcd70d9ed4b1.mp4; > ; > `WENOVectorInvariantZVEL` seems to perform actually very well compared to a (somewhat) standard ""vorticity-reconstruction"" `WENOVectorInvariant` and compared to the very noisy standard `VectorInvariant` in lie of the fact that; > ; > * Noise is reduced significantly despite dissipation not being too high; > * Agreement between different resolutions is much higher. Both the WENO vector invariant forms look great, and much less noisy than the non-WENO version. Why do you say the third is better than the second? I don't doubt that it us but my eyes don't see much of a difference. . Out of curiosity, have you computed a time series of the energy?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064467000:699,perform,perform,699,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064467000,1,['perform'],['perform']
Performance,"> Nah…; > ; > Every preview is 200MB of load on the repo I then have to clean and it’s not that easy to clean up a repository’s history. I’d rather I make the PR twice or built the docs locally :). Oof, didn't know that. Sounds fair :). I'll approve it, although we probably have to restart the failed GPU tests",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2886#issuecomment-1409061309:40,load,load,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2886#issuecomment-1409061309,1,['load'],['load']
Performance,"> Naively, I would think that if one term is computed with WENO5 then 4 terms would be 4 times the cost. Okay, I understand what you're saying and I agree. Assuming that the advection term dominates the cost of a time-step, we could count the number of times the advection term is evaluated and calculate a multiplicative slowdown based on that assumption. One issue with that assumption is that the advection terms compile to different code when using a `BackgroundField`. With a `BackgroundField` the velocity field is stored as a `FunctionField` (with almost no additional memory allocation) rather than raw data. Calling `getindex` on a `FunctionField` resolves to calling a function, whereas calling `getindex` on a `Field` / `Array` fetches data from memory. So they are different. Naively I would expect that evaluating a complicated advection term involving `BackgroundField` would be cheaper than one that involved two concrete `Array`. But sometimes unexpected things happen (the compiler might decide to optimize the code differently...). Can you try running the code on the GPU? I think it would be enlightening to see if there's a slowdown in that case. We could potentially implement an interface whereby `Field`s can be used as `BackgroundField` rather than functions. That might give us some insight, because then the ""additional"" advection terms associated with `BackgroundField` would truly be identical to the ""original"" advection term. > because presumably the advection of the background state by the background state is zero. I would say that the background self-interaction terms are _neglected_ rather than presumed to be zero. Linear terms associated with the background fields are also neglected. The idea being that if there is a valid way to decompose a flow into background and perturbation components, then the equation that governs the background component is completely neglected (this includes both the nonlinear terms and any linear terms involving the background flo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623:1015,optimiz,optimize,1015,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623,1,['optimiz'],['optimize']
Performance,"> New log level should be enough if we just need flat per-iteration timings to time a few blocks for a few iterations. Are you thinking of just logging raw `@time` data?; > ; > I'm not sure if we need anything more than a new log level, but I imagine some of the benefits of using a package like TimerOutputs.jl would make the timer blocks much more useful for debugging and for users. It allows for nested timers and produces a very nice table summary at the end which includes number of calls and average time/memory allocations.; > ; > This could also be useful for users wishing to time their simulations to figure out how much time is being spent on I/O vs. in kernels vs. solvers vs. callbacks, etc. I guess I also see timers as a debugging tool for users. Could help be figure out cluster filesystem issues or figure out whether Oceananigans or my coupled model (via callback) is the bottleneck.; > ; > Otherwise if the timers are just a developer debugging tool that dumps timing information, that's useful but it might not be useful for timing real-world scripts/simulations since the log would fill up with a huge number of lines that can't be interpreted without further processing.; > ; > Here's an example of it in use: [JuliaGPU/CUDA.jl#149 (comment)](https://github.com/JuliaGPU/CUDA.jl/issues/149#issuecomment-461943376) (CUDA.jl has been using TimerOutputs.jl for a long time I think); > ; > TimerOutputs.jl is easy to use since you just add `@timeit` blocks but that does add some noise to the code (not sure if more or less than using a timing log level). @ali-ramadhan I was thinking timing would be useful for general use around figuring out where time is going in day-to-day modeling - so some summary table as in TimerOutputs.jl would be a great thing to aim for - I think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887967029:891,bottleneck,bottleneck,891,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887967029,1,['bottleneck'],['bottleneck']
Performance,> Nice one. Should we benchmark anything just to make sure this hasn't affected performance?. That's a good idea!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-971712282:80,perform,performance,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-971712282,1,['perform'],['performance']
Performance,"> No flux are the default for immersed boundary. It looks like you are explicitly setting an immersed boundary condition for a non-immersed field. What is `b`s grid?. The same as `model`s: a MultiRegion grid. I'm not yet using the IB grid since apparently `MultiRegionGrid` isn't working with IBs yet. When I use it, I get this error. ```julia; ERROR: LoadError: MethodError: no method matching PressureSolver(::CPU, ::MultiRegionGrid{Float64, Periodic, Periodic, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{ImmersedBoundaryGrid{Float64, FullyConnected, Periodic, Bounded, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, ImmersedBoundaryGrid{Float64, FullyConnected, Periodic, Bounded, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}}, Tuple{CPU, CPU}}, Tuple{CPU, CPU}, CPU}); Closest candidates are:; PressureSolver(::Any, ::ImmersedBoundaryGrid) at ~/.julia/packages/Oceananigans/Kq8xW/src/Models/NonhydrostaticModels/NonhydrostaticMod",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1309394728:352,Load,LoadError,352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1309394728,1,['Load'],['LoadError']
Performance,"> Okay finally tests passed!; > ; > @navidcy I tried restarting the tests over and over (honestly more than 10 times over the past few days) and they always failed. I could only make them pass this morning when I restarted them one at a time. That is, starting one, and only restarting the next failed test when the previous one had fully run.; > ; > So maybe the variability we see in tests has to do with different processes trying to access the same resources... ?. Yes it is a race condition",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2223710307:481,race condition,race condition,481,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2223710307,1,['race condition'],['race condition']
Performance,> On Satori using stupidly large meshes gives 85% - 89% efficiency going from 1 to 2 GPU for the `multi_region_turbulence.jl` benchmark (Note `1440×600×48` is the size of the 1/4 degree simulation) Unfortunately the efficiency decreases on a larger number of GPUs... we definitely have to fix the scaling; > ; > #### Strong Scaling; > Grid size	Grid	GPUs	wall time	efficiency; > `1024×1024×100`	`RectilinearGrid`	1	3.4 minutes	100%; > `1024×1024×100`	`MultiRegionGrid`	2	1.9 minutes	89.5%; > `1440×600×48`	`RectilinearGrid`	1	1.4 minutes	100%; > `1440×600×48`	`MultiRegionGrid`	2	49.2 seconds	85.4%; > `1440×600×48`	`MultiRegionGrid`	3	38.8 seconds	72.2%; > Going to smaller meshes than these hampers the efficiency incredibly. I think there might be a lot of low hanging fruits to optimize multi GPU. Nice results though! Is this for implicit or explicit free surface?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116681325:782,optimiz,optimize,782,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116681325,1,['optimiz'],['optimize']
Performance,"> One issue with that assumption is that the advection terms compile to different code when using a `BackgroundField`. With a `BackgroundField` the velocity field is stored as a `FunctionField` (with almost no additional memory allocation) rather than raw data. Calling `getindex` on a `FunctionField` resolves to calling a function, whereas calling `getindex` on a `Field` / `Array` fetches data from memory. So they are different. Good to know. Thanks for explaining. > Naively I would expect that evaluating a complicated advection term involving `BackgroundField` would be cheaper than one that involved two concrete `Array`. But sometimes unexpected things happen (the compiler might decide to optimize the code differently...). Agreed! Often unexpected things happen, which keeps us on our toes. > We could potentially implement an interface whereby `Field`s can be used as `BackgroundField` rather than functions. That might give us some insight, because then the ""additional"" advection terms associated with `BackgroundField` would truly be identical to the ""original"" advection term. I don't pretend to understand the details of this and don't know the potential pay off so not sure whether I think this will bear fruit or not. > I would say that the background self-interaction terms are _neglected_ rather than presumed to be zero. Linear terms associated with the background fields are also neglected. . Good. > _Side note:_ some nonlinear terms are additionally neglected in the case of nonlinear viscosity. Ah, I don't think I'm getting into that now but it's something to be aware of.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816780988:699,optimiz,optimize,699,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816780988,1,['optimiz'],['optimize']
Performance,"> One thing to note is that the current implementation appears to be very slow. While the simulation with the `SmagorinskyLilly` closure runs on my laptop in 10 seconds, it takes 4 minutes for the simulation with the `ScaleInvariantSmagorinsky`. I know the dynamic model will be slower given the extra computations, but such a difference seems large to me, so I'm hoping something can be changed here to improve performance:. Avoided recomputation of the strain rate at `ccc` and sped things up a bit more. Now it runs in 2.9 minutes. A lot more to go...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2241696460:412,perform,performance,412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2241696460,1,['perform'],['performance']
Performance,"> Perhaps we could convert to this: https://github.com/DTolm/VkFFT which supports hardware-accelerated FFT on CUDA, Metal and lots of others. It looks like that library is more performant than `cuFFT` as well. Why do we have to convert? Can we use that only for Metal?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734543134:177,perform,performant,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734543134,1,['perform'],['performant']
Performance,"> Point taken, but I think there are still Oceananigans-relevant applications where Value / Gradient boundary conditions on non-immersed boundaries are useful enough to be a ""core"" feature (e.g. imposing observed SST patterns rather than observed air-sea heat fluxes), but there is always the workaround of strongly restoring boundary-adjacent sponge regions. I think this is what many ocean modelers do to implement such boundary conditions anyway. True! I'm not aware that has ever been done, but since it's not difficult to support (notwithstanding @simone-silvestri's concerns about parallel performance) it's interesting to allow it --- agree. For future readers I want to point out that SST restoring (and similar models) are typically be implemented as a `FluxBoundaryCondition` using a piston velocity model, rather than using `ValueBoundaryCondition` (which implies a flux mediated by some diffusivity / viscosity, possibly derived from a parameterization). (`FluxBoundaryCondition` is mathematically identical to restoring in the surface grid point, though it would be a slightly different model to distribute the restoring over some depth). It could be an interesting project to explore using some parameterization-derived diffusivity together with `ValueBoundaryCondition` to predict surface fluxes, though, I'm not sure what the implications would be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452:596,perform,performance,596,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452,1,['perform'],['performance']
Performance,"> Possibly, we should start using a merge queue that would disallow PRs from being merged unless tests pass. Yeap. I added these in https://github.com/CliMA/Oceananigans.jl/settings/branches. <img width=""905"" alt=""Screenshot 2023-12-23 at 1 10 26 pm"" src=""https://github.com/CliMA/Oceananigans.jl/assets/7112768/3137d7ef-2f34-4f05-86fa-c759177ac164"">. How does this sound?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868271224:42,queue,queue,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868271224,1,['queue'],['queue']
Performance,"> Seems like we have to ensure that types are correct... I ll take a look. This is really a compiler issue... I guess we ""shouldn't"" have to enforce types, but maybe it helps with inlining (which we need for performant code and GPU compilation)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2558#issuecomment-1128949553:208,perform,performant,208,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2558#issuecomment-1128949553,1,['perform'],['performant']
Performance,"> Shoudn't we write a kernel? Presumably that explicit 3D loop is incredibly slow?. Indeed! Unfortunately it's not embarrassingly parallel so my kernel skills are no longer sophisticated enough :) I don't know how to gather `count`, `rowval` or `colval`. The conditional preseumably also leads to poor performance (but no where near as poor as it is now!).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2737#issuecomment-1248734171:302,perform,performance,302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2737#issuecomment-1248734171,1,['perform'],['performance']
Performance,"> Should we also try things like; > ; > ```julia; > node(i, j, k, grid, ::Nothing, ℓy, ℓz) = _node(i, j, k, grid, nothing, ℓy, ℓz)[1:2]; > ```; > ; > I think we determined there could be a tiny performance loss but it would make the code a little simpler and also easier to read since we don't have to define every combination of locations for `_node`. Hmm this is more annoying than I thought so I'll leave it for later.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1775509960:194,perform,performance,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1775509960,2,['perform'],['performance']
Performance,"> Since the aim is to work with abstract operations, FieldTimeSeries right now only work with JLD2 data that includes halos. Do we want to support loading data without halos?. We generally need to support `SlicedField` so I suggest we implement such support in that context. Until then, I think users need to be aware that they need `field_slicer=nothing` to use this experimental feature. Once this feature is mature, I think that `field_slicer=nothing` should be the default. Some of the most important calculations we do are on boundaries. The reason to omit halos that contain useful information about boundary conditions is only for ""convenience"" --- this feature eliminates that concern so that more science can be done.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1641#issuecomment-835434572:147,load,loading,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1641#issuecomment-835434572,1,['load'],['loading']
Performance,"> Since we need the performance provided by KA 0.7, and we need to use KA 0.8+ on GPU, does that mean that we should invest in developing our own CPU infrastructure (replicating what KA 0.7 offered) to achieve that performance?; > ; > Another possibility is that we re-write much of the code base to avoid the performance pitfalls we are currently facing in order to get back to the level of performance we have with current code + KA 0.7. I believe the issue is basically an interaction between some of the abstractions / indirection we have developed and the compiler, so possibly rolling back that abstraction / indirection will bring us back to where we were previously. To follow up with @vchuravy, it seems that rewriting just _some_ of the code was sufficient, so we are (probably) in the clear! The lesson learned is that we cannot slurp / splat `@kernel` function arguments, because it prevents the kernel code from being inlined.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1482198741:20,perform,performance,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1482198741,8,['perform'],['performance']
Performance,"> So it appears that there are two competing bug here, which kinda cancel out in the case where gravity aligned with the vertical direction. I also think that back in #1910 when we saw some weird effects when not separating the pressure, this might have been it. No, I don't think so. We reconstructed correctly previously when performing the hydrostatic pressure integral. The only bug was for tilted gravity, or not using the pressure integral.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518046160:328,perform,performing,328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518046160,1,['perform'],['performing']
Performance,"> So the first task is to extend the tridiagonal solver to support integrals in `x` and `y`.; > ; > This could be straightforwardly supported by adding some kind of tag to indicate the ""tridiagonal direction"" (ie `:x`, `:y`, or `:z`), and copy-pasting the functionality for each case. It's a bit of code duplication but pretty straightforward...; > ; > Alternatively we could introduce some kind of abstraction that permutes array dimensions. Then we just have one algorithm which assumes the tridiagonal index is `k`, and support `i` or `j` under the hood via an array wrapper that performs an index permutation.; > ; > I'm leaning towards copy/paste because it's a little easier to understand and it's not that much code in this case... I also prefer the copy/paste method (that's what I used in https://github.com/CliMA/Oceananigans.jl/pull/3111). If I understand correctly these two functions are the only ones that need to be generalized, no?: . https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L74-L83. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L88. if so, that's not too bad. Is duplicating one of the tests in [test_batched_tridiagonal_solver.jl](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_batched_tridiagonal_solver.jl) but rotating everything to two different directions enough to test this new functionality?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1560271584:583,perform,performs,583,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1560271584,1,['perform'],['performs']
Performance,"> Sorry I don't quite understand: Is this potentially affecting the calculations right now, or will it only be an issue if we upgrade to CUDA 3.5+?. CUDA 3.8 includes features that may allow us to decrease register pressure or implement performance optimizations that would otherwise be difficult or impossible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2202#issuecomment-1025963063:237,perform,performance,237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2202#issuecomment-1025963063,2,"['optimiz', 'perform']","['optimizations', 'performance']"
Performance,"> Sorry for not following, but I don't see what breaks here for the end user! Could someone give a quick example/explanation?. Apologies that my explanation was not clear. It's a breaking change because the same user input, such as. ```julia; tke = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2) / 2; ```. produces a different object after this update:. * Before this PR, `u - U` would be interpolated to `(Center, Center, Center)`, and then the binary operation `^(2, u - U)` would be calculated at `(Center, Center, Center)`.; * After this PR, both `u - U` and `^(2, u - U) = (u - U)^2` are calculated at `(Face, Center, Center)`. Interpolation is then performed to `(Center, Center, Center)` _after_ the exponentiation to form the three-part sum. Let me know if that makes sense or if another example would be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1599#issuecomment-823698116:667,perform,performed,667,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599#issuecomment-823698116,2,['perform'],['performed']
Performance,> Testing with validation/mesoscale/baroclinic_adjustment.jl seems to indicate that the race condition is eliminated from the changes to the fill_halo_region! function. Was there a race condition there?. Could you please point to the relevant issue describing the condition just for completeness?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920113136:88,race condition,race condition,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920113136,2,['race condition'],['race condition']
Performance,"> That probably shouldn't have changed, can you file an issue on CUDA.jl/GPUArrays.jl? I'll have a look next week. The only change to `@allowscalar` that comes to mind is task/thread-safety, which does come at a certain performance cost (it now does a TLS lookup instead of a simple pointer check, but the cost of that should be negligible compared to the subsequent memory transfer). Seems I can't reproduce the supposed error so, sorry, my bad... Something else must have been the issue. 😔",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817385393:220,perform,performance,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817385393,2,['perform'],['performance']
Performance,"> That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale. 3D averages require scratch space for accumulating the average; this is why they are memory intensive. It's possible to compute averages just on slices or windowed regions of the domain. If this works for your application, you can consider it to reduce memory allocation. > I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. . In principle, you can use a callback to accumulate an average on the CPU from data on disk, and then delete the data periodically as the simulation runs. You can also accumulate the time-average on the CPU. These methods may not be performant, however, depending on the balance between the cost of CPU-GPU data transfer, and other costs in your simulation. If you have to accumulate a 3D time-average for performance reasons, then you have no choice but to allocate a 3D field on the GPU for this purpose.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301417685:740,perform,performant,740,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301417685,2,['perform'],"['performance', 'performant']"
Performance,"> The Roquet’s approximation is perfectly sufficient for Oceananigans, because it will never be used for global calculations where local approximations are an issue. However I agree with everybody else that it would be best to use the same EOS in Ocenanigans and Climate_Ocean. in that case we should adopt TEOS-10. Be warned that it is quite inefficient through. So we may be hit performance-wise. Hard to tell without trying. Thanks for the feedback @rafferrari. I talked to @leios earlier today and we think it shouldn't be a problem on the GPU. It's just straight up number crunching so it might benefit from being run on a GPU. But we can make sure by doing a quick benchmark.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/692#issuecomment-596868076:381,perform,performance-wise,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/692#issuecomment-596868076,1,['perform'],['performance-wise']
Performance,"> The main issues are when the entirety of a heavy kernel (like one that calculates a tendency) may be promoted to higher precision. `fill(var, 0)` is cheap and unlikely to affect performance.; > ; > That said it's just more precise to write `fill(var, zero(eltype(var)))` (this is _exactly_ what you are trying to do) and therefore the preferred way to write it. You were meant to write `fill!` not `fill` right? For `fill!(::AbstractArray,0)` this is what happens. ```julia; julia> a = Float32[1,2,3]; 3-element Vector{Float32}:; 1.0; 2.0; 3.0. julia> @code_llvm fill!(a,0); ; @ array.jl:346 within `fill!`; define nonnull {}* @""julia_fill!_127""({}* noundef nonnull align 16 dereferenceable(40) %0, i64 signext %1) #0 {; top:; ; @ array.jl:347 within `fill!`; ; ┌ @ number.jl:7 within `convert`; ; │┌ @ float.jl:159 within `Float32`; %2 = sitofp i64 %1 to float; ; └└; ```. So the very first thing is that if `eltype` of the array and type of second argument aren't the same then it's converted (the `%2 ...` line); Using `fill!(var, zero(eltype(var)))` then can skip this conversion (it's compiled away) but the result is the same. You can make and educated guess of the type of the zero, but honestly, I wouldn't even bother. It has probably zero impact on performance for any larger than a few elements and I find `fill!(A,0)` very clear to read too, so that's what I now always try to write.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723777023:180,perform,performance,180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723777023,4,['perform'],['performance']
Performance,> The new commit follows the suggestion of overloading the compute! method to apply it on a tuple of ComputedField. Good point that we may not need an independent type (except for the very minor performance optimization of precomputing the compatibility between fields -- which probably doesn't matter),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1696117967:195,perform,performance,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1696117967,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"> The new default, converting Int64 exponents to Float64, seems better. Unless `power_by_squaring` performs better in realistic applications?. I don't think we ever used `power_by_squaring`, because the ""pre 1.6"" Oceananigans kernels were defined via`KernelAbstractions`, which in turn translated `^(a, b)` to `CUDA.pow(a, b)`:. https://github.com/JuliaGPU/KernelAbstractions.jl/blob/fdb7415b6f6083c23451cc526b0637144322b1cb/lib/CUDAKernels/src/CUDAKernels.jl#L289. This means that ""pre 1.6"" we were exponentiating with `nv_powi`... In ""current"" Oceanagnians (before this PR), changes to KernelAbstractions and CUDA seem to imply that we invoke `nv_pow` instead. And for some reason this can slow down our code by 10-15x (!!) as discussed on #1764 . Does CUDA C do special transformations for `powi(x, Int32(2))`? Eg, does it convert `powi(x, Int32(2))` to `x*x` (or something like that)? I've no idea but maybe there are some massive algebra reductions / expression eliminations that occur for our weird WENO5 code when we ask for `x*x` versus `x^2.0` ... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870014674:99,perform,performs,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870014674,1,['perform'],['performs']
Performance,"> The preview isn't showing for me. But we can fix any issues later, so I say merge away. Yeah, It's also not loading for me. It feels like whenever I try to check PR previews it's kinda hit or miss. I wonder if this is an issue with Documenter. But if you're okay with it, I'll merge it and we can fix any problems later.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963566951:110,load,loading,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963566951,1,['load'],['loading']
Performance,"> The problem is not only with the `Nothing`, it's that the reduced fields are effectively launched with a reduced grid size; > ; > for example the west boundary kernel launch for a `(Center, Center, Center)` field will be of size `Ny*Nz` for a `(Center, Center, Nothing)` it will be of size `Ny`; > ; > For the moment I just filter the reduced fields and do them individually. I don't think it will create too much problem. This is only an optimization for time-stepping where we do not have too many reduced fields (only free surface I think). Ah indeed, I see now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065529029:441,optimiz,optimization,441,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065529029,1,['optimiz'],['optimization']
Performance,"> The tests use a lot of scalar indexing that's why they fail on the GPU:; > ; > https://buildkite.com/clima/oceananigans/builds/15604#018f40ed-787d-4e74-a5f4-ae1656fa3043/18-724; > ; > I think if we are comparing single numbers it makes sense to use `@allowscalar`.; > ; > If we are comparing vectors it could be nice to figure out how to get the tests to run without `@allowscalar` since presumably this is possible. Given that we're comparing elements of vectors with a maximum length of 6, I opted to use `CUDA.@allowscalar`. The impact on performance in this situation is minimal when running on a GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2103388821:544,perform,performance,544,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2103388821,1,['perform'],['performance']
Performance,"> There was a bug in some recent updates to KernelAbstractions.jl that caused Enzyme to break on broadcasting arrays in Oceananigans. This PR includes a test to make sure this bug doesn't occur again. Interesting! I think it's ok to add a broadcasting test. But it will be confusing to future developers if the test is explained / written as somehow testing a bug in _another_ package. If there's a bug somewhere else, we need a test in that packge (presumably that has been added). . This test also seems a little complicated. Why not just write a simple function that does a broadcast, and then try to autodiff that? Why do we need initial conditions, models, etc?. For example. ```julia; function times_c!(a, b, c); a .= b .* c # c is a number; return sum(a) # or whatever we gotta return; end. grid = RectilinearGrid(arch, size=(1, 1, 1), extent=(1, 1, 1)); a = CenterField(grid); b = CenterField(grid); c = 2; @test try ; autodiff(times_c!, a, b, c... # or something); true; catch; false; end; ```. It's super important for tests to be as short and easy to understand as possible, because maintaining test code is one of the main bottlenecks on development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3598#issuecomment-2105014020:1135,bottleneck,bottlenecks,1135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3598#issuecomment-2105014020,2,['bottleneck'],['bottlenecks']
Performance,"> Thinking of revamping this, I think `T` is a good notation; we do not need to specify `U` and `C` since probably (in the future) we will need to refactor these a little to pass through boundary conditions. Hopefully we don't have to pass boundary conditions 🥺 . Not all complexity is justified by the performance gains...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2329666236:303,perform,performance,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2329666236,1,['perform'],['performance']
Performance,"> This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains. No stretched mesh is supported at the moment (that will come in a later PR); > ; > The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes; > ; > * the starting configuration is always a _z-free_ configuration.; > * the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; > * the y-direction is integer divisible by the number of ranks that divide the x-direction; > * the z-direction is integer divisible by the number of ranks that divide the y-direction; > ; > An additional assumption is that:; > ; > * if TY is Bounded, also TZ needs to be Bounded; > * if TX is Bounded, also TY needs to be Bounded; > ; > All these assumptions can be relaxed in following PRs. Are these statements still accurate?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850:303,perform,performed,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850,1,['perform'],['performed']
Performance,"> This is super exciting! Out of curiosity is there any/which Krylov solver is compatible on multiple GPUs? Seems to be an important bottleneck for our current `PreconditionedConjugateGradientSolver` approach. Also to be clear about what this can do --- with Krylov, we can still use the FFT preconditioner. When we do that the parallelism issues are identical to the issues with our current CG solver, it's just that tweaking the solver method might allow us to do fewer iterations. So there are two things going on in this discussion which are independent. First is whether conjugate gradient is optimal or whether we should use a different method. The second issue is the preconditioner, which is the more uncertain part but where we might have more gains.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387264231:133,bottleneck,bottleneck,133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387264231,2,['bottleneck'],['bottleneck']
Performance,"> This is the same benchmark performed with `ImplicitFreeSurface`, by imposing a divergent velocity `u(x, y, z) = x / 10` to make sure the implicit solver iterates. Looking at the results it seems like it doesn't iterate too much... (probably WENO cleans up?) And it is very weird that the `RectilinearGrid` version is not affected by the FreeSurface calculation? (I have double checked that the free surface solver is correct); > ; > #### Strong Scaling; > Grid size	Grid	GPUs	wall time	efficiency; > `1440×600×48`	`RectilinearGrid`	1	1.37 minutes	100%; > `1440×600×48`	`MultiRegionGrid`	2	1.05 minutes	65.2%. THATS CALLED A SPEED UP 🍻 . I think bathymetry interferes with the solver more. When the velocity field is _purely_ divergent + barotropic, it just produces waves that dissipate nearly instantly ?. It'd be good to come up with a reliable 3D initial condition for benchmarking iterative solver stuff....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116787626:29,perform,performed,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116787626,1,['perform'],['performed']
Performance,"> True. Ideally we want to be close to the scalings/performance we got with lat-lon grid? That’s perhaps not feasible..? I don’t know how close is good enough tho. We expect to be at lower performance. For that reason we have dedicated two independent milestones to the cubed sphere. The first milestone is rather susinct ""complete the cubed sphere implementation"". The second milestone pertain to performance: ""achieve 10 SYPD at 25 km resolution"". I think this is nice, because we want to separate tasks into ones that are _required_ for correct functionality, versus tasks that are oriented towards performance rather than correctness.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719389468:52,perform,performance,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719389468,4,['perform'],['performance']
Performance,"> We need some PlotRecipes for fields...; > ; > (In general, not for this PR!). We need that badly... I think we should take the approach in `ClimaCore.jl` which is to develop an ""external"" package that lives in `/lib`. Perhaps `Makinanigans.jl` or `Vizinanigans.jl`. Performing new releases is a little more arduous with that setup but its probably worth it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2238#issuecomment-1034179606:268,Perform,Performing,268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2238#issuecomment-1034179606,1,['Perform'],['Performing']
Performance,"> We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions).; > ; > Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`). Ah, I see. I hadn't noticed that. . > Either way we need both `east_bounded` _and_ `solid_interface` so the question is just how we shuffle logic between the two. We can consider changing `solid_interface`. If we change its behavior I would recommend calling it `fluid_solid_interface`. I think changing `solid_interface` to `fluid_solid_interface` (along with it's definition of course) is clearer. Especially because `solid_interface` confused me at first; I thought it effectively was supposed to test for the fluid-solid interface. But at this point I don't feel strongly about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281:115,perform,performance,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281,4,"['optimiz', 'perform']","['optimizations', 'performance']"
Performance,"> What if we get rid of `parameters` and `computed_dependencies`, and call `compute!` on all the arguments?. That'd work for me. Would that have the same performance or would it add some overhead?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1068561902:154,perform,performance,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1068561902,1,['perform'],['performance']
Performance,"> What if you edit the forcing functions into the discrete form, e.g. invoking `Forcing` with `discrete_form=true`?. It helps! But doesn't solve the problem. In particular the MWE above (with two tracer) in discrete form compiles for me. But when I add more tracers (I need at least 6 tracers for my simulations) it fails again. Sometimes with a different error:. ```; ERROR: LoadError: Failed to compile PTX code (ptxas exited with code 255); Invocation arguments: --generate-line-info --verbose --gpu-name sm_60 --output-file /glade/scratch/tomasc/jl_hs9AZo7IJq.cubin /glade/scratch/tomasc/jl_XSJ4P4z47a.ptx; ptxas /glade/scratch/tomasc/jl_XSJ4P4z47a.ptx, line 5136; error : Entry function '_Z23julia_gpu_calculate_Gu_7ContextI14__CUDACtx_Namevv14__PassType_312v12DisableHooksE18_gpu_calculate_Gu_16CompilerMetadataI10StaticSizeI9_8__8__6_E12DynamicCheckvv7NDRangeILi3ES5_I9_1__1__6_ES5_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE15RectilinearGridIS9_8PeriodicS12_7BoundedS9_S9_S8_IS9_Li1ES10_IS9_Li1ELi1EEES8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES15_IS9_E5Int64EES8_IS9_Li1ES14_IS9_S15_IS9_ES15_IS9_ES16_EES8_IS9_Li1ES10_IS9_Li1ELi1EEEvE4WENOILi3ES9_vv5TupleIS8_IS18_IS9_S9_S9_ELi1ES10_IS18_IS9_S9_S9_ELi1ELi1EEES8_IS18_IS9_S9_S9_ELi1ES10_IS18_IS9_S9_S9_ELi1ELi1EEES8_IS18_IS9_S9_S9_ELi1ES10_IS18_IS9_S9_S9_ELi1ELi1EEES8_IS18_IS9_S9_S9_ELi1ES10_IS18_IS9_S9_S9_ELi1ELi1EEEELitrueEvS17_ILi2ES9_vvS18_IS8_IS18_IS9_S9_ELi1ES10_IS18_IS9_S9_ELi1ELi1EEES8_IS18_IS9_S9_ELi1ES10_IS18_IS9_S9_ELi1ELi1EEES8_IS18_IS9_S9_ELi1ES10_IS18_IS9_S9_ELi1ELi1EEEELitrueEv12UpwindBiasedILi1ES9_vvvv8CenteredILi1ES9_vvvvEES20_ILi1ES9_vvvvEES20_ILi2ES9_vvvS20_ILi1ES9_vvvvEEEvv16SmagorinskyLillyI26ExplicitTimeDiscretizationS9_10NamedTupleI34__b____1____2____3____4____5____6_S18_IS9_S9_S9_S9_S9_S9_S9_EEE17BoundaryConditionI4FluxvEvS23_I23__velocities___tracers_S18_IS23_I12__u___v___w_S18_I9ZeroFieldIS16_Li3EES26_IS16_Li3EES26_IS16_Li3EEEES23_I34__b____1____2____3____4____5____6",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401133112:376,Load,LoadError,376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401133112,1,['Load'],['LoadError']
Performance,"> What parallelism strategy makes sense? One particle per thread?. I think that makes sense, and we just queue up a huge amount of blocks like we already do with 3D kernels. Although if we use DifferentialEquations.jl then maybe we won't have to worry about parallelism here?. > Do we use linear interpolation between velocity nodes or assume a constant velocity within each cell (nearest neighbor interpolation)?. Yeah I'm not super sure what's a good approach here. We're on a regular Cartesian grid right now so maybe the difference isn't huge?. The [Parcels v2.0 paper by Delandmeter & van Sebille (2019)](https://www.geosci-model-dev.net/12/3571/2019/) discusses interpolation schemes for curvilinear C-grids using mostly Lagrange polynomials. But on a rectilinear grid like ours, it seems that it just reduces down to linear interpolation [see Eq. (3)]. Maybe a good question for @jm-c. > Obtaining prognostic quantities within particles (like reacting chemical species with reaction rates that depend on ambient temperature) may be challenging and probably requires a careful design. Agreed. It may not even be clear what a good solution is. Apparently DARWIN has a similar problem I think where many plankton species may be uptaking nutrients so the question of what to do when a nutrient are depleted is hard to solve, especially as having nutrients go below zero can be bad for the model.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-547215399:105,queue,queue,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-547215399,1,['queue'],['queue']
Performance,> When I ran this locally I got a load of `@test_broken` passing for computed fields which is quite strange. We don't test those regularly --- it might be a new compiler etc. You can feel free to convert those to `@test` if you want to be a hero 💪,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2181261472:34,load,load,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2181261472,1,['load'],['load']
Performance,"> When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; > ; > ```julia; > ERROR: LoadError: UndefVarError: `settings` not defined; > ```; > ; > When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; > ; > ```julia; > ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; > ```. Do you need help fixing these?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1744978276:218,Load,LoadError,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1744978276,2,['Load'],['LoadError']
Performance,"> Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?. I was planning was to implement the tridiagonal solve similarly to what we do for single GPU as such:; ```julia; transpose_z_to_y!(storage) # copy data from storage.zfield to storage.yfield; solver.plan.forward.y!(parent(storage.yfield), buffer.y) ; transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; solver.plan.forward.x!(parent(storage.xfield), buffer.x); transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; ; # Perform the implicit vertical solve here on storage.zfield... transpose_z_to_y!(storage); solver.plan.backward.y!(parent(storage.yfield), buffer.y); transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; solver.plan.backward.y!(parent(storage.xfield), buffer.x); transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; ```. This is not super great because it requires eight transposes, but I think it's the same thing that was happening in #2538",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197384003:807,Perform,Perform,807,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197384003,1,['Perform'],['Perform']
Performance,"> Where in the model should we store the forcing array in this case?. The user would define an array in a script, declare it `const` to the compiler, and then write a function that indexes into it as a global:. ```julia; # define a; forcing(..., i, j, k) = a[i, j, k]; ```. We can also include a constructor for `Forcing` that allows the user to pass some function that defines a constant array, and set up the same functionality internally. > The main motivation being that we don't have to write extra functions that dispatch on the forcing, thus simplifying the time stepping code. As you point out we don't want to write 5! = 120 new functions. The update_source_terms! function is already 52 lines long so I'd rather avoid having to dispatch on this function. I think the problem is that our functions are trying to do too much at once. We need smaller functions that perform more atomic operations so we can dispatch on atomic operations. I don't think we need to re-invent multiple dispatch with macros. We just need to refactor the code so we can use multiple dispatch effectively.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470556414:873,perform,perform,873,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470556414,1,['perform'],['perform']
Performance,"> While we should try to use powers of 2 for performance, I think that overly restricts the model resolutions we can be running at. There are a LOT of choices between e.g. `512x512x128` and `1024x1024x128`. It might be that the largest model that fits in memory isn't nice powers of 2. Users may have various reasons for running resolutions that aren't powers of 2. I over-simplified. FFTs are efficient when there are a small number of prime divisors --- 2, 3, 5, 7 --- of the length of the sample. 100 may actually be ok because it is 2\*2\*5\*5. I don't feel strongly, but you will find that most people running simulations are using powers of 2 and 3 (128, 192, 256, 384, 512, 768, 1024) --- even when their code has no FFTs! Perhaps the purpose of this convention is so people who *do* use codes that rely *heavily* on FFTs are able to run code comparisons. I find the convention to be an appropriate best practice. An 1D FFT of length 257, for example, is 4 times slower than an FFT of length 256 on my machine. For tests, of course, using small numbers of prime divisors is completely irrelevant; I just want to encourage best practices and promote awareness of them, and also implicitly emphasize to users that this code uses FFTs, and don't want random person X to read the tests and scratch their head and ask ""doesn't this code rely on FFTs?"" (like I did when I saw the examples). > Just a note that if we want to reuse `model.metadata.arch` with GPUifyLoops.jl then the options should be `:CPU` and `:GPU` (instead of `:cpu:` and `:gpu` which is what `ModelMetadata` currently uses) as I believe GPUifyLoops.jl expects ""capitalized"" Symbols. I certainly prefer that. It may be academic because the architecture should probably be a parameter of `Model`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468533848:45,perform,performance,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468533848,1,['perform'],['performance']
Performance,"> Yeah sure, we can do it. ~~Is there a performance difference?~~. ~~The best solution might use dispatch to enable ""non-stretched WENO"" automatically when the grid has constant spacing.~~. After actually looking at the code, it seems this is what this PR does do, indeed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969063314:40,perform,performance,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969063314,1,['perform'],['performance']
Performance,"> Yeah this is pretty worrying... I'm pretty sure this is the cause of #1420 which has been open for a while so this slowdown must have been around for a while (and just flew under the radar). [Profiling](https://docs.julialang.org/en/v1/manual/profile/) might help pinpoint the bottleneck. It looks like there are some extra temporary arrays being created for the cases with non-trivial (although still pretty trivial) indexing patterns. Profiling could be good - also just turning off as much as possible and then building up from the FFT alone, simple stencil etc... - if that is possible?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891443627:279,bottleneck,bottleneck,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891443627,2,['bottleneck'],['bottleneck']
Performance,"> Yep, I would call it bulk velocity though, instead of phase speed, and change the name from `Orlanski` to something more descriptive like `AdvectiveOutflow`. But these are mathematically identical right? Orlanski called is a ""phase speed"", but ""outflow velocity"" is equally valid and refers to exactly the same mathematical object. The reference you posted says. > The test results also confirm that this type of boundary condition, which was originally designed by Orlanski primarily for equations which are hyperbolic in nature, also performs well for parabolic problems. I think we can keep the name ""Orlanski"" and provide a generic interface for specifying the outflow speed (whatever you want to call it). It can be user-specific, dynamically computed, etc. The code can be extensible, so if users want to experiment with different methods for computing the outflow speed, this is possible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1965488832:538,perform,performs,538,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1965488832,1,['perform'],['performs']
Performance,"> [AMGX.jl](https://github.com/JuliaGPU/AMGX.jl) only has prebuilt libraries for linux systems. That said, calling using AMGX will fail on, e.g., Mac OS X. What's the best way to optionally load AMGX.jl? Or is there another way around that?. @simone-silvestri any ideas for how to solve this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1242544194:190,load,load,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1242544194,1,['load'],['load']
Performance,"> `2)` is because I cannot think of a situation where you would want to output something different than Array? But please correct me if I'm wrong. I haven't found another example in this repository. We chose `array_type` to permit the flexibility of other array types. I don't know enough to say that we would _never_ want another array type. Better to be defensive than aggressively constraining user action?. `Float32` used to be the default. However, this produced a lot of pain in some testing situations where we wanted to show bitwise reproducability / accuracy in saving. I can't remember all the details, but after a few user issues (in addition to our own pain), we decided to switch to Float64. I agree that Float32 is better, but could be regarded as ""premature optimization"" in this case. Definitely open to discuss though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3214#issuecomment-1679415894:773,optimiz,optimization,773,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3214#issuecomment-1679415894,1,['optimiz'],['optimization']
Performance,"> ```julia; > [ Info: ... simulation initialization complete (1.471 minutes); > [ Info: Executing initial time step...; > ERROR: LoadError: TaskFailedException; > ; > nested task error: TaskFailedException; > ; > nested task error: type Tuple has no field surface_TKE_flux; > Stacktrace:; > [1] getproperty(x::Tuple{CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.MixingLength{Float64}, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.SurfaceTKEFlux{Float64}}, AnisotropicDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Float64, Float64, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}}}, f::Symbol); > @ Base ./Base.jl:33; > [2] call; > @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:456 [inlined]; > [3] fallback; > @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:454 [inlined]; > [4] overdub; > @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:279 [inlined]; > [5] overdub; > @ ~/.julia/packages/Oceananigans/H39qI/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/surface_TKE_flux.jl:39 [inlined]; > [6] getbc(::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.TKETopBoundaryConditionParameters{NamedTuple{(:b, :c, :e), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{NamedTuple{(:Ly, :Lz, :Qᵇ, :y_shutoff, :τ, :μ, :ΔB, :H, :h, :y_sponge, :λt), NTuple{11, Float64}}, typeof(buoyancy_flux)}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, NamedTuple{(:u, :v), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.Boun",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030744418:129,Load,LoadError,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030744418,1,['Load'],['LoadError']
Performance,"> and we'll only have to dispatch on one type instead of three. I guess the point of this design is to simplify more generalized dispatch by ""unfusing"" the three directions. The solution you're proposing is simply returning to what we were doing before, right?. Note one immediate advantage: the `nodes` function now works with *any* field (and the implementation is actually less code than before). We lose this feature and must return to dispatching on lots of different cases (as you say, unions), if we fuse the three directions into one type. . However, this becomes even more critical when we think about abstracting operators. When performing an `x` derivative, for example, we know that the field changes location from `{Cell, Y, Z}` to `{Face, Y, Z}`. If the directions were fused, we would have to code each 3D case manually, rather than the 1 (or 2) cases we need with this design. When writing an abstracted interpolation function from an arbitrary location `X1, Y1, Z1` to `X2, Y2, Z2`, it greatly simplifies the task if the directions are ""unfused"". I think it's also easier to reason about abstracted operators on fields this way.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/409#issuecomment-531763391:639,perform,performing,639,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/409#issuecomment-531763391,1,['perform'],['performing']
Performance,"> the constructors of a CuSparseMatrix are different from the ones for a SparseMatrix. Can the constructors for CuSparse be derived from Sparse? If so, we just build the sparse on CPU, and then implement `arch_array`. > It means that we will first have to create the full matrix (of size Nx * Ny x Nx * Ny!!) Or is this computationally/memory-wise restrictive?. I think you should avoid allocating the whole matrix and build the sparse representation on the fly. The sparse representation is like a graph --- we add nodes only when they exist. Once we've built the graph, we can convert it to a computationally efficient format for time-stepping on CPU or GPU. > Also it is kind of a brute force which would be quite computationally inefficient because it scales badly. I propose we get this up and running in 2D and see whether this is a feasible calculation to perform during model construction. There is the question of preconditioners / changing time-step. Do the sparse matrix implementations we work with have efficient implementations for operations like. ```julia; A += b * I; ```. where `I isa UniformScaling` and `b` is a scalar?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109680238:863,perform,perform,863,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109680238,1,['perform'],['perform']
Performance,> the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. What does this have to do with putting boundary conditions in operators?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2356567627:14,perform,performance,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2356567627,1,['perform'],['performance']
Performance,"> then we'd have to rewrite loads of stuff to make it so the user can specify whatever they want for the external state. I think see your point (I'm not sure I grasp the totality of it). Is your point that we are able to _re-use_ more existing code if we allow `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction` as `condition`? I didn't understand this previously so thank you for clarifying. To re-use that code with a new `condition`, we can use a nesting technique:. ```julia; function getbc(open_bc::OpenBoundaryCondition, ...); state_value = getbc(open_bc.condition.external_state, ...); # other stuff related to matching; end; ```. This means that we don't have to rewrite anything, we just add new functionality for open boundary conditions on top. You could make the point that we have less _new_ code to write though, if we implement a design that allows conditions to be the same. And for users, this could be clearer, so I see the advantage of that. On the flip side, the advantage of making a new `OpenCondition` is that `getbc` retains its meaning as ""the function that returns the boundary condition value"". When we have an external state + matching scheme, the boundary condition values are not exactly the external state and are modified by the matching scheme. So I see pros and cons to both, but the good news is that we can actually talk coherently about the pros and cons. And if there are other pros and cons please mention them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988781194:28,load,loads,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988781194,2,['load'],['loads']
Performance,"> why not replace `const ƞ = 2` with `const ƞ = 2.0`, i.e. with a Float64?. I believe that if we do this, then we have to live with WENO5 that's 20x slower than the other schemes. I believe its the exponentiation with `Float64` that is slow (since exponentiation is compute intensive in general in my understanding) --- not the conversion from Int64 to Float64 (type conversions between numeric types are basically instantaneous as far as I know). In other words, the function `pow` for exponentiation with `Float64`:. https://github.com/JuliaGPU/CUDA.jl/blob/5d6127dbbef495c94d3dd8de98162188062e11b1/src/device/intrinsics/math.jl#L218. creates a bottleneck in simulations that use WENO5, whereas using `powi`:. https://github.com/JuliaGPU/CUDA.jl/blob/5d6127dbbef495c94d3dd8de98162188062e11b1/src/device/intrinsics/math.jl#L221. is much faster. > My understanding is that replacing it with with Int32 can make us forfeit some precision, no?. Why is that?. I believe we only need `Int64` if we need to represent very large integers. `Int32` integers can range from +/- 2^32 - 1, whereas 64 bit integers can range from +/- 2^64 - 1. Since 2 is represented with `Int32` there's no need to express its value in `Int64`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869776360:647,bottleneck,bottleneck,647,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869776360,1,['bottleneck'],['bottleneck']
Performance,">Maybe I am misunderstanding you, but isn't that already what is done in the horizontal convection example?. No, you are understanding me! I think you're on to something. > Is the intended behavior that output writers automatically call fill_halo_region! before saving when with_halos=true?. Ah no this is not default. However, for prognostic fields, the halos are filled within `update_state!`:. https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl#L24C1-L24C1. However, halos are not filled for diagnostic fields. We probably don't want to make filling halos default, since filling halo regions is expensive and useful only for a subset of experiments. However, we could add a keyword argument to `JLD2OutputWriter`, something like `fill_halos = true`. (Thinking about this with a little more coffee, it probably doesn't make sense to add something like this, because generally speaking the halo values for diagnostic fields are not useful except for periodic boundary conditions; only prognostic fields can have specified / meaningful boundary conditions.). I wonder if this is a bug in `FieldTimeSeries`. Are you using `FieldTimeSeries` to compute the diagnostics offline? Perhaps the halo data is saved correctly, but is not loaded correctly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689838510:1333,load,loaded,1333,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689838510,1,['load'],['loaded']
Performance,">[AMGX.jl](https://github.com/JuliaGPU/AMGX.jl) only has prebuilt libraries for linux systems. That said, calling using AMGX will fail on, e.g., Mac OS X. What's the best way to optionally load AMGX.jl? Or is there another way around that?. We may be able to optionally call `using AMGX` + all the `AMGX`-related functionality by using:. [`@static` + `islinux()`]( https://docs.julialang.org/en/v1/manual/handling-operating-system-variation/) + [`CUDA.has_cuda_gpu()`](https://cuda.juliagpu.org/stable/api/essentials/#CUDA.has_cuda_gpu)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1244923054:189,load,load,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1244923054,1,['load'],['load']
Performance,"@Yixiao-Zhang do you want to open a PR?. Sensible errors on GPU are a persistent problem... this seems like one of the trickiest though... I think the best easy thing we can do in this case is to add an article in our Wiki about how to debug `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`, making @simone-silvestri 's points. For documentation the error being referred to is. ```julia; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuMemcpyHtoDAsync_v2; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] #unsafe_copyto!#9; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:397 [inlined]; [5] (::CUDA.var""#1012#1013""{ComplexF64, CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, Int64, Vector{ComplexF64}, Int64, Int64})(); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:464; [6] #context!#887; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [7] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [8] unsafe_copyto!(dest::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, doffs::Int64, src::Vector{ComplexF64}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:457; [9] copyto!; @ ~/.julia/packages/CUDA/35NC6/src/array.jl:415 [inlined]; [10] setindex!(::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, ::ComplexF64, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:20; [11] setindex!; @ ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:24 [inlined]; [12] macro expansion; @ ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:136 [inlined]; [13] solve!(ϕ::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Boun",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332:435,Load,LoadError,435,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332,1,['Load'],['LoadError']
Performance,"@ali-ramadhan , I tried running the example using the following `julia --project -p 4 mpi_shallow_water_turbulence.jl; `, and it seemed to fail because of error, see below. Any idea what I might have done wrong?. ```; ERROR: LoadError: ProcessExitedException(3). ...and 2 more exception(s). Stacktrace:; [1] sync_end(::Channel{Any}) at ./task.jl:314; [2] macro expansion at ./task.jl:333 [inlined]; [3] _require_callback(::Base.PkgId) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Distributed/src/Distributed.jl:75; [4] #invokelatest#1 at ./essentials.jl:710 [inlined]; [5] invokelatest at ./essentials.jl:709 [inlined]; [6] require(::Base.PkgId) at ./loading.jl:931; [7] require(::Module, ::Symbol) at ./loading.jl:923; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/examples/mpi_shallow_water_turbulence.jl:6; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-792895347:225,Load,LoadError,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-792895347,3,"['Load', 'load']","['LoadError', 'loading']"
Performance,"@ali-ramadhan ; Thanks for the suggestion. I tried running it on the CPU and got a different error message, which is shown below. Additionally, the error occurs when defining background fields in the model as such; ```julia ; background_fields = Oceananigans.BackgroundFields(; background_closure_fluxes=true, b=B̄_field); ```; But it runs fine like the usual way; ```julia; background_fields = (; b=B̄_field); ```. ```; [ Info: Initializing simulation...; ERROR: LoadError: type BackgroundFields has no field u; Stacktrace:; [1] getproperty; @ ./Base.jl:37 [inlined]; [2] assemble_closure_velocities; @ ~/.julia/packages/Oceananigans/xmqSH/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:35 [inlined]; [3] u_velocity_tendency; @ ~/.julia/packages/Oceananigans/xmqSH/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:92 [inlined]; [4] cpu_compute_Gu!; @ ~/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; [5] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; [6] __run(obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck, static_threads::Bool); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; [7] (::KernelAbstractions.Kernel{…})(::Field{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; [8] (::KernelAbstractions.Kernel{…})(::Field{…}, ::Vararg{…}); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; [9] launch!(::CPU, ::ImmersedBoundaryGrid{…}, ::Symbol, ::typeof(Oceananigans.Models.Nonhydros",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2432725343:464,Load,LoadError,464,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2432725343,1,['Load'],['LoadError']
Performance,"@ali-ramadhan I'm running on my desktop's GPU just to get a sense of the performance increase at the moment. According to `nvidia-smi` my card is a `NVS 310` (I apologize if I didn't get that right, I really have zero experience with GPUs). I'll create another issue to report this properly. Thanks for the feedback, though!. And I'm running our own group's LES model. Unfortunately I'm not allowed to share the code, but you can read about it [here](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/2018GL080296). @glwagner I'd be very willing to compare performances of our LES with Oceananigans. The caveats here being that; - our model of choice ([lagrangian-averaged scale-dynamic](https://aip.scitation.org/doi/10.1063/1.1839152)) takes relatively long to calculate compared to other models, but generally needs lower resolution to achieve the same results (so in this sense it might be similar to AMD) and that; - I'm not sure how relevant it would be to compare with us, being that I'm not allowed to share the source code. If you're still interested to make a comparison just let me know! I'd be happy to help. @ali-ramadhan @glwagner I'm not expecting at all to run their simulation at the resolution that they're running. My intent was to set-up the same case (but very coarse) and see how much I could increase the resolution (and how much activity I could see) until it became too slow or until I ran out of memory. This is basically a fun side-project, and not an actual research attempt if I'm being honest :). Thank you both for the helpful responses! I'm glad to help with whatever bugs or attempts at simulations that I can!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539785839:73,perform,performance,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539785839,2,['perform'],"['performance', 'performances']"
Performance,"@ali-ramadhan and @glwagner I tried the code below in some simple tests while waiting; for my car to be serviced. . ```; using Pkg; Pkg.add(""LinearAlgebra""); using LinearAlgebra. function solveLinearSystem(A,f); # Solve Aϕ=f; tol=1.e-12; E=eigen(A);; L=E.values;; V=E.vectors;; # Get amplitudes, F, of eigenvectors that give f; F=V'*f; # Get inverse eigenvalues (zeroing inverse for v. small ones); rL=map(x -> if (abs(x)>tol) 1.0/x; else 0. ; end , L);; # Get amplitudes, Φ, of eigenvectors that give ϕ; Φ=F.*rL; # Solve for ϕ given Φ; ϕ=V*Φ; println(A*ϕ,f,ϕ); return ϕ; end. Acyc=[-2. 1 1; 1 -2. 1; 1 1 -2.];; Aneu=[-1 1 0; 1. -2. 1; 0. 1. -1];; s=size(Acyc);; nx=s[1];; g=rand(nx+1,1);; divg=g[1:end-1]-g[2:end]; mdivg=sum(divg)./size(divg)[1]; divg=divg.-mdivg; solveLinearSystem(Acyc,divg); solveLinearSystem(Aneu,divg); ```. This is algorithm that underlies the FFT approach. The FFT just optimizes (and makes it more complicated) by utilizing the fact that the eigenvector/eigenvalue coefficients for the simple, constant spacing Poisson problem, are the cos and sin terms in an FFT. Code appears to work so I am going to try and hack together a ""_plugin_"" for ```solve_poisson_3d_mbc```. . The code won't be super high performance (or work for really big problems) but (fingers crossed) it should give something clean (and short) to get started and help with debugging/optimizing on GPU. Then we can work on various FFT approaches on CPU and GPU (3-d FFT, 2-d + cyclic reduction), Greg's thought on saving for gradients in continuous form. . In principle the eigenvectors and eigenvalues above should correspond with amplitudes that come out of FFTW - except that there are a bunch of 1/2 factors, N versus m numbers, complex versus split cos/sin notation bits that need to be carefully understood etc.... . Just going to learn a little about sparse matrices in Julia - I assume they must exist! Hopefully the car will take a little longer to be finished. . Chris",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-442521365:895,optimiz,optimizes,895,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-442521365,3,"['optimiz', 'perform']","['optimizes', 'optimizing', 'performance']"
Performance,"@ali-ramadhan currently waiting for the preview to load so that I can merge, but I don't think it'll do that with the GPU test failing. How do we fix that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819553284:51,load,load,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819553284,1,['load'],['load']
Performance,"@christophernhill : I wanted to confirm that I took your clever idea of using `select_device()` and added that into my code. When I ran it on 1, 2 and 4 GPUs I was able to get efficiences of 97 percent. So the code is performing very well, and the server can be efficent on multi GPUs. . The link to where the function is defined is copied below. Is this something that is done automatically in Oceananigans through `AbstractKernels.jl` or something else?. https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/src/select_device.jl. In chatting with the developers of `ImplicitGlobalGrid.jl` they mentioned that to get efficiency I should use something called `@hide_communication` in `ParallelKernel.jl`. Again, I don't pretend to understand what this does but wanted to share the information I was given. https://github.com/omlins/ParallelStencil.jl/blob/main/src/ParallelKernel/hide_communication.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885799405:218,perform,performing,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885799405,1,['perform'],['performing']
Performance,"@christophernhill I also took a look at the `GFlops.jl` package. As said on its homepage: ""GFlops.jl does not see what happens outside the realm of Julia code. It especially does not see operations performed in external libraries such as BLAS calls.""; It works similarly to the profile macro and it can count basic math operations performed by whatever follows the macro or benchmark it for its Flops metric. These doesn't seem to work with simulations but works fine for `time_step!(model, 1)` due to the benchmarking process performing many evaluations of the code.; For the nonhydrostatic model running on CPU, `@count_ops` did not produce any results for either the simulation run or the time_step!, and `@gflops` produced the results below for time step!:; ```; 0.02 GFlops, 0.04% peak (1.89e+07 flop, 1.01e+00 s); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898103351:198,perform,performed,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898103351,3,['perform'],"['performed', 'performing']"
Performance,"@francispoulin ! No worries about the question. I like questions. To answer your latest question --- our nonhydrostatic pressure solver is based on FFTs for regular grids and is therefore quite fast. In simple benchmarks long ago we found that other parts of the algorithm dominated the cost of a time-step. Because of that we aren't sure that having a hydrostatic-only solver would help. Of course, the story is different if we need to stretch the grid in horizontal directions. That said, it would still be interesting to be able to solve hydrostatic-only problems. This would complicate the algorithm a bit because you have to distinguish the barotropic mode, and perform a 2D pressure solve. We already have a function to integrate the buoyancy field to obtain the hydrostatic pressure. For ""things I want worked on"" my wish list falls into three categories: new physics features, new numerics / algorithms, and more boring software / UI work. Here's a couple... 1. Finishing the vertically-stretched grid implementation (numerics). We started work on this but its incomplete. This is a tricky and arduous task but would be quite nice to have... 2. Vertically-implicit time-stepping for diffusion terms (numerics). Ocean models typically use a time-stepping method that treats vertical diffusion terms implicitly. We haven't worried about this because we are focused on LES for the most part, or problems with very little diffusion. But ultimately we will need this, especially when we get around to implementing boundary layer closures. We have a tridiagonal solver that works on the GPU, so in some respects the hard work is already done for this problem. 3. Closures for LES and ocean modeling (Dynamic Smagorinsky, Deardorff, k-epsilon, Gent-McWilliams, convective adjustment (?) etc --- physics). We have a need to implement new turbulence closures new and old alike. Gent-McWilliams is probably easy since we already have a Leith closure implemented which calculates the tensor needed to rot",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281:667,perform,perform,667,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281,1,['perform'],['perform']
Performance,"@francispoulin @glwagner @ali-ramadhan @christophernhill ; I took a look at all the benchmarking scripts in our benchmarks folder and realized that many of them are very similar and can be unified. For example, the single script for shallow water model's strong and weak scaling differ only by one substring. ; The latest commit I pushed to this branch unifies all of the launcher and single scripts for shallow water model into three scripts. Now, at the top of the launcher script `distributed_shallow_water_model.jl`, there are two boolean variables that the user can toggle for strong vs weak scaling and mpi vs threaded parallel execution. Everything including output graphs, HTML tables, and info messages also change accordingly based on the two booleans. There are some other features that Francis and I have discussed but would like your approval first before adding them in.; Other possible additions to the script can include a for loop which wraps around the whole launcher script which loops through the strong/weak scaling and mpi/threaded parallelism options to allow for running 4 benchmarks at once. Another possible addition is to have what model is benchmarked also be an option. Granted, I could just copy and paste the shallow water model scripts and replace all instances of `shallow water` with `nonhydrostatic` or `hydrostatic` and tune some options a little bit, but then this would again cause avoidable clutter. Having what model is benchmarked as an easily changeable option can be achieved through a model setup function that dispatches what model is initialized based on a custom model type object that's passed to it. Everything else would be cosmetic formatting of outputs and info messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441:1356,tune,tune,1356,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441,1,['tune'],['tune']
Performance,@francispoulin I think it's always helpful to post the full error and stacktrace. From your original post. ```; ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!; ```. suggests that the error could be happening since `b̄` is being used in a `ComputedField`'s `compute!`: https://github.com/CliMA/Oceananigans.jl/blob/9eca5780658bb8f5c0debd34146a0ad5cb73c872/examples/inertially_unstable_jet.jl#L51,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815055237:119,Load,LoadError,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815055237,1,['Load'],['LoadError']
Performance,"@francispoulin sounds like a good plan! Then we can see how to proceed. Concerning the way forward with `WENOVectorInvariant`, it seems that it is very diffusive when compared to standard WENO. an example on a 256^2 periodic Bickley jet below, contours are of vertical vorticity (left) and zonal velocity (right). WENO5. https://user-images.githubusercontent.com/33547697/157509797-d61f45ba-8284-40f2-b9e9-4cafcba6db68.mp4. WENOVectorIvariant. https://user-images.githubusercontent.com/33547697/157533165-9281949b-1579-462d-ad16-e27b2f954969.mp4. Integrated Enstrophy (blue is 64^2, red is 128^2, green is 256^2, solid lines are WENO5, dashed are WENOVectorInvariant); ![enstrophy](https://user-images.githubusercontent.com/33547697/157510310-3acfaeaf-4d05-4fac-b332-e7b66563147e.png). @sandreza was pointing out that maybe the extra diffusivity comes from the fact that we are advecting vorticity which contains much thinner structures than velocity, then maybe the ""optimal WENO weight"" are not so optimal anymore. These weights are 3 constant parameters, which are quite empirical and ""free-to-choose"" (in our case just `1/10` for the downstream, `6/10` for the central and `3/10` for the upstream stencil). Dissipation can be reduced by increasing the ""central stencil weight"". The idea with @sandreza was to perform an easy calibration to try to ""reasonably"" preserve enstrophy in the Bickley jet (then maybe calibrate it also against the spherical bicklet jet or R-H waves where also Coriolis is involved). The objective is to completely eliminate explicit viscous dissipation in the horizontal direction (harmonic and/or biharmonic) for the global simulation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1063249741:1313,perform,perform,1313,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1063249741,1,['perform'],['perform']
Performance,"@glwagner ; After merging this PR and running it on the GPU, I encounter the following error. (I'm using Julia 1.10.2 and Oceananigans v0.92.0):. ```; [ Info: Initializing simulation...; ERROR: LoadError: InvalidIRError: compiling MethodInstance for Oceananigans.Models.NonhydrostaticModels.gpu_compute_Gu!(::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(10, 10, 10)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 10)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, ::OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, ::ImmersedBoundaryGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Periodic, Bounded, RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, Nothing, Nothing, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, Float64, Nothing, Nothing, Nothing}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, Nothing, Nothing}, ::Nothing, ::Tuple{WENO{3, Float64, Nothing, Nothing, Nothing, Nothing, WENO{2, Float64, Nothing, Nothing, Nothing, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, ConstantCartesia",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2428001700:194,Load,LoadError,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2428001700,1,['Load'],['LoadError']
Performance,"@glwagner @tomchor ; I have just tested the turbulent boundary layer with wall model using Oceananigans on Julia 1.6.7 and Julia 1.9.2. The performances of AMD in both versions are exactly the same. It turns to overestimate the velocity shear at the second node from the wall, therefore, turns to overestimate the velocity in the middle and upper parts of the boundary layers. I used to use the SGS model based on the Lagrangian-averaged scale-dependent dynamic model (LASD) (https://pubs.aip.org/aip/pof/article/17/2/025105/895722/A-scale-dependent-Lagrangian-dynamic-model-for). @tomchor is very familiar with this SGS model. The performance of the LASD close to the wall is usually good, as you can see here; ![025105_1_f2](https://github.com/CliMA/Oceananigans.jl/assets/20816949/e4aa1b73-d37e-4afa-b3ec-317d2edf7769). I guess the problem of AMD is partly solved in reference Yang et al. (2017). Now the problem is that if someone can implement this filtering in the code or not. I am stilling learning the Oceananigans and Julia. I hope that someday in the future, I am able to implement this technique.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426:140,perform,performances,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426,4,['perform'],"['performance', 'performances']"
Performance,"@glwagner [AMGX.jl](https://github.com/JuliaGPU/AMGX.jl) only has prebuilt libraries for linux systems. That said, calling `using AMGX` will fail on, e.g., Mac OS X. What's the best way to optionally load AMGX.jl? Or is there another way around that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241308749:200,load,load,200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241308749,1,['load'],['load']
Performance,"@glwagner please help here... I can't even say `using Oceananigans`.... ```julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: LoadError: LoadError: UndefVarError: NFBC not defined; Stacktrace:; [1] top-level scope; @ ~/Research/OC/src/BoundaryConditions/apply_flux_bcs.jl:23; [2] include(mod::Module, _path::String); @ Base ./Base.jl:386; [3] include(x::String); @ Oceananigans.BoundaryConditions ~/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:1; [4] top-level scope; @ ~/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:45; [5] include(mod::Module, _path::String); @ Base ./Base.jl:386; [6] include(x::String); @ Oceananigans ~/Research/OC/src/Oceananigans.jl:1; [7] top-level scope; @ ~/Research/OC/src/Oceananigans.jl:173; [8] include; @ ./Base.jl:386 [inlined]; [9] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1213; [10] top-level scope; @ none:1; [11] eval; @ ./boot.jl:360 [inlined]; [12] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [13] top-level scope; @ none:1; in expression starting at /Users/navid/Research/OC/src/BoundaryConditions/apply_flux_bcs.jl:23; in expression starting at /Users/navid/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:1; in expression starting at /Users/navid/Research/OC/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_fSB7qw.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-877746334:190,Load,LoadError,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-877746334,3,['Load'],['LoadError']
Performance,"@glwagner that sounds like a good strategy, ideally you would want to front-load the most useful tests for catching errors to the degree possible (the whole goal here is to reduce iteration time). If using Linux we can have up to 60 concurrent actions going so spawning as many as is useful for reducing the iteration time is the correct strategy (probably you could set this up as a job matrix for compactness). If spawning up a ton of github actions you can maximize concurrency by killing stale jobs (old push commits) as we do here: https://github.com/CliMA/ClimaCore.jl/blob/main/.github/workflows/Linux-UnitTests.yml#L24",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906584759:76,load,load,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906584759,3,"['concurren', 'load']","['concurrency', 'concurrent', 'load']"
Performance,"@glwagner the solution seems the same but two difference are that (1) `VectorInvariant` does not crash, (2) `WENOVectorInvariant` deviates from the pattern later. ; ; In this paper https://www.tandfonline.com/doi/pdf/10.3402/tellusa.v52i2.12258 they claim that : ""In the FV model, small departures from the flow pattern are triggered initially by grid related truncation errors but subsequently grow through the dynamical instability"" . I guess ""time-to-instability"" is itself a diagnostic of the performance of the scheme? . @francispoulin As implemented in (https://reader.elsevier.com/reader/sd/pii/S0021999105800166?token=A3A72AC493072CED8ECF098513A0BD1F822D2F2224207E533C86FB7D40361903E7AC0B4304841E64E089CBBFCEAFD08B&originRegion=us-east-1&originCreation=20220308154939) the cosine bell advection only tests the tracer advection, do you have any example of a test of that kind that tests momentum advection?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061931114:497,perform,performance,497,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061931114,1,['perform'],['performance']
Performance,"@glwagner, @navidcy ; Poll to decide where to put `η` in `z`. . The possibilities are:; - location `Face`, index `grid.Nz+1`. Pros: natural location of `η` field (same position of the `w` velocity).; - location `Center`, index `grid.Nz`. Pros: every calculation dealing with `η` is now performed at centers (ex `Az_∇h²ᶜᶜᶜ` and `linear_operation!`. . In case of the second option should we change all the metrics to reflect the fact that we are at faces?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1248631573:286,perform,performed,286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1248631573,1,['perform'],['performed']
Performance,"@glwagner, I think you're right that the error is coming from this line:; https://github.com/CliMA/Oceananigans.jl/blob/10a9479ec462f4f5f053e7447ff667fdfe20542d/src/Distributed/distributed_fft_based_poisson_solver.jl#L65; I checked the sizes of these variables, and here xc is sized on the global grid while lambda x is sized on the local grid. I'm not sure which grid this operation is intended to be performed on. The code here is impressively compact but not particularly easy to decipher (at least for me).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067340658:402,perform,performed,402,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067340658,1,['perform'],['performed']
Performance,"@glwagner, regarding the; ```Julia; ERROR: LoadError: UndefVarError: bc not defined; ```; in the Docs, is it related to; https://github.com/JuliaDocs/Documenter.jl/issues/228; perhaps?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1843#issuecomment-879623792:43,Load,LoadError,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1843#issuecomment-879623792,1,['Load'],['LoadError']
Performance,"@hennyg888 do you have the same problems using MPI instead of multi-threaded, and on the same CPU ( Intel(R) Xeon(R) Platinum 8260 CPU @ 2.40GHz ). ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880838040:62,multi-thread,multi-threaded,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880838040,1,['multi-thread'],['multi-threaded']
Performance,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:709,load,load,709,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444,1,['load'],['load']
Performance,"@matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. ; For the moment those two elements are part of this PR. This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft,; the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521:47,perform,performant,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521,2,['perform'],['performant']
Performance,"@navidcy I'm trying to add a drag flux to this example like we talked about in https://github.com/CliMA/Oceananigans.jl/issues/3148 but I'm getting an error that I can't figure out. Using `u` as an example, I'm trying to implement the BCs as . ```julia; @inline u_drag(x, y, t, u, v, w, p) = - p.cᵈ * u * √(u^2 + v^2 + w^2); @inline u_drag(x, y, z, t, u, v, w, cᵈ) = u_drag(x, y, t, u, v, w, cᵈ). u_drag_bc = FluxBoundaryCondition(u_drag, field_dependencies=(:u, :v, :w), parameters=(; cᵈ=1e-3)); boundary_conditions = (u = FieldBoundaryConditions(bottom=u_drag_bc),); ```. but when time-stepping the model I get. ```; ERROR: LoadError: MethodError: no method matching field_arguments(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, ::NamedTuple{(:u, :v, :w, :b, :η), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.Cent",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1667152069:626,Load,LoadError,626,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1667152069,1,['Load'],['LoadError']
Performance,"@navidcy In the context of Enzyme (a tool for automatically differentiating LLVM), to ""mark"" a function as non-differentiable means to use `inactive_noinl` to tell Enzyme that it should not try to apply the chain rule to that function. Marking functions as non-differentiable has various reasons but here the reason is given as ""performance"". The code changed is also quite short so I think the description is complete.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3799#issuecomment-2383154154:329,perform,performance,329,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3799#issuecomment-2383154154,1,['perform'],['performance']
Performance,"@navidcy it shouldn't impact developer workflow too much. When going over the test structure with @glwagner on Tues. I suggested the following restructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:373,concurren,concurrent,373,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778,1,['concurren'],['concurrent']
Performance,"@navidcy thanks for the review! ; Indeed maybe we should document it. . Just to give a quick explanation of the different flavours. WENO involves the reconstruction of the value of the advected quantity on the face performed on different ""biased stencils"". <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2 ,r} = p_r(x_{i %2B 1/2}) = \sum_{j=0}^k c_{rj} \overline{v}_{i - r %2B j}"">. where <img src=""https://render.githubusercontent.com/render/math?math=p""> is the reconstruction polynomial constructed from the biased stencil <img src=""https://render.githubusercontent.com/render/math?math=r""> and <img src=""https://render.githubusercontent.com/render/math?math=k""> is the order of the polynomial. As we want a 5th order scheme, there will be three polynomials (<img src=""https://render.githubusercontent.com/render/math?math=r = 0, 1, 2"">) with (<img src=""https://render.githubusercontent.com/render/math?math=k = 2"">). Now the coefficients of these polynomials (<img src=""https://render.githubusercontent.com/render/math?math=c_{rj}"">) are based on the Lagrange interpolation of the integral of <img src=""https://render.githubusercontent.com/render/math?math=\overline{v}_{i}""> and, as such, are coordinate-dependent. The first thing to do, when wanting to implement the WENO scheme on a stretched grid, is then to make sure that the reconstruction is correctly done, and, as such, `WENO5(grid = grid)` takes care that (<img src=""https://render.githubusercontent.com/render/math?math=c_{rj}"">) are correctly calculated based on the underlying grid. Now, WENO schemes differ from ENO schemes since they do not just choose the ""smoothest stencil"" among the (in this case) three stencils, but weight them as such. <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2} = \sum_{r=0}^k w_{r} v_{i %2B 1/2,r} "">. Those weights have to satisfy <img src=""https://render.githubusercontent.com/render/math?math=\sum_{r=0}^k w_{r} = 1""> and are mostly a matte",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397:215,perform,performed,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397,2,['perform'],['performed']
Performance,@navidcy what's the last version before the catastrophic performance loss? I'll do a benchmark to compare with `main`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480454534:57,perform,performance,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480454534,1,['perform'],['performance']
Performance,@sandreza might be a good idea to code up the case we were using the diagnose the race condition as a test and see if we can catch the race condition in CI @ali-ramadhan,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926693915:82,race condition,race condition,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926693915,2,['race condition'],['race condition']
Performance,"@siddharthabishnu, `CUDA.@allowscalar` introduced by [3cdd470](https://github.com/CliMA/Oceananigans.jl/pull/3488/commits/3cdd4705fedf3238d8858bb0f56e9b27b01ba34a) is detrimental for performance. Like it induces O(10-100x) slowdown I think.... Is this a temporary solution?. cc @glwagner, @simone-silvestri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2033827149:183,perform,performance,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2033827149,1,['perform'],['performance']
Performance,"@simone-silvestri : I tried running the branch in it's current version and received a GPU error. Is this something that works on your machine?. ```; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Guh!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.v; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1130253785:156,Load,LoadError,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1130253785,1,['Load'],['LoadError']
Performance,@simone-silvestri @jagoosw I think this PR may solve the race condition issue. The essential reason is that the Manifest was being re-resolved after init because downstream tests imported additional packages that were not imported during the initial instantiation.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2361545069:57,race condition,race condition,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2361545069,1,['race condition'],['race condition']
Performance,"@simone-silvestri In addition to the NetCDF issue I mentioned [here](https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524), I found out that the `cell_advection_timescale()` and `interior()` aren't working with `MultiRegionGrids` yet. Here's an error example:. ```julia; ERROR: LoadError: type MultiRegionObject has no field parent; Stacktrace:; [1] getproperty; @ ./Base.jl:38 [inlined]; [2] cell_advection_timescale(model::NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, MultiRegionGrid{Float64, Bounded, Periodic, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, RightConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, RectilinearGrid{Float64, LeftConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}}, Tuple{CPU, CPU}}, Tuple{CPU, CPU}, CPU}, MultiRegionObject{Tuple{Tuple{Colon, Colon, Colon}, Tuple{Colon, Colon, Colon}}, Tuple{CPU, CPU}}, MultiRegionObject{Tuple{OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}}, Tuple{CPU, CPU}}, Any, MultiRegionObject{Tuple{FieldBoundaryConditions{Nothing, Bo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304574572:300,Load,LoadError,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304574572,1,['Load'],['LoadError']
Performance,"@simone-silvestri Will do!. At the moment I am using `momentum_advection = VectorInvariant()`. If it goes unstable I will try the one you suggested on the other PR. I also tried what you suggested on the other PR,. ```; VectorInvariant(vorticity_scheme = WENO(), kinetic_energy_gradient_scheme = WENO()); ```. This failed because of the error below. Any idea what I need to do to fix this?. ```; ERROR: LoadError: MethodError: no method matching _symmetric_interpolate_yᵃᶜᵃ(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{…}, ::EnergyConserving{…}, ::typeof(Oceananigans.Advection.δx_v²), ::Field{…}, ::Field{…}). Closest candidates are:; _symmetric_interpolate_yᵃᶜᵃ(::Any, ::Any, ::Any, ::ImmersedBoundaryGrid, ::Union{Centered{2}, Centered{3}, Centered{4}, Centered{5}, Centered{6}, UpwindBiased{2}, UpwindBiased{3}, UpwindBiased{4}, UpwindBiased{5}, UpwindBiased{6}, WENO}, ::Any...); @ Oceananigans ~/Software/Oceananigans.jl/src/ImmersedBoundaries/conditional_fluxes.jl:210; _symmetric_interpolate_yᵃᶜᵃ(::Any, ::Any, ::Any, ::ImmersedBoundaryGrid, ::Union{Centered{1}, UpwindBiased{1}}, ::Any...); @ Oceananigans ~/Software/Oceananigans.jl/src/ImmersedBoundaries/conditional_fluxes.jl:207; _symmetric_interpolate_yᵃᶜᵃ(::Any, ::Any, ::Any, ::Any, ::VectorInvariant{<:Any, <:Any, true}, ::Any, ::Any...); @ Oceananigans ~/Software/Oceananigans.jl/src/Advection/vector_invariant_advection.jl:250; ... ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1984534233:403,Load,LoadError,403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1984534233,1,['Load'],['LoadError']
Performance,"@simone-silvestri any tips?. For conditionals, we should use `ifelse`; then there is no issue for performance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2737#issuecomment-1252872891:98,perform,performance,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2737#issuecomment-1252872891,1,['perform'],['performance']
Performance,"@simone-silvestri this doesn't seem to be working when the domain is `Bounded` in the x direction. Is this expected?:. ```julia; ERROR: LoadError: MethodError: no method matching PressureSolver(::CPU, ::MultiRegionGrid{Float64, Bounded, Bounded, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, RightConnected, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, RectilinearGrid{Float64, LeftConnected, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}}, Tuple{CPU, CPU}}, Tuple{CPU, CPU}, CPU}); Closest candidates are:; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number, <:Number}) at ~/.julia/packages/Oceananigans/F1fni/src/Models/NonhydrostaticModels/NonhydrostaticModels.jl:24; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number}) at ~/.julia/packages/Oceananigans/F1fni/src/Models/NonhydrostaticModels/NonhydrostaticModels.jl:25; PressureSolver(::Any, ::ImmersedBoundaryGrid) at ~/.julia/packages/Oceananigans/F1fni/src/Models/NonhydrostaticModels/NonhydrostaticModels.jl:28; ...; Stacktrace:; [1] NonhydrostaticModel(; grid::MultiRegionGrid{Float64, Bounded, Bounded, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1302898706:136,Load,LoadError,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1302898706,1,['Load'],['LoadError']
Performance,@simone-silvestri you mentioned that in this PR the pressure solver is done on a single GPU for the time being. Can https://github.com/CliMA/Oceananigans.jl/pull/2538 be a stating point to optimize that as well? That PR is really close to ready I think,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1302354230:189,optimiz,optimize,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1302354230,1,['optimiz'],['optimize']
Performance,@tomchor I guess we are hoping we can merge without the 3/4 performance penalty.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1190886871:60,perform,performance,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1190886871,1,['perform'],['performance']
Performance,"@tomchor just wanted to echo @ali-ramadhan's thank you for finding that bug!. Right now Oceananigans shines for medium-size LES problems around 256^3, perhaps up to 384^3. For that application I think you may find it is as fast or faster than other codes. On that note, it'd be great to compare performance with other codes for this problem size. . For utterly massive problems like the one reported in the Sullivan paper you've posted, Oceananigans is probably not the right tool right now. We haven't experimented with multi-node parallelism yet, but as @ali-ramadhan suggests, its possible we will start working on either multi-CPU parallelism or multi-GPU parallelism soon. For reproducing the Sullivan paper, you may want multi-CPU parallelism simply because of the sheer number of nodes you'll need. It's worth noting that our AMD turbulence closure *may* be less resolution-dependent than the TKE-based closure used by NCAR LES / Sullivan (and yourself?) and thus it may be possible to run at lower resolution (potentially saving factors of 10-100 in resolution. A [paper by Abkar and Moin (2017)](https://link.springer.com/article/10.1007/s10546-017-0288-4) hints at the potential for very coarse simulations with AMD.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539774569:295,perform,performance,295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539774569,1,['perform'],['performance']
Performance,"@tomchor unfortunately we don't have an issue for this problem. @sandreza is it possible to open an issue to document the problem that we are seeing? In the case that this PR does not resolve the issue, we'd like to have an issue open... I don't have much hard evidence to provide but I can describe the problem as I've seen it. Basically, very rare, subtle irregularities have been observed on the GPU when using `HydrostaticFreeSurfaceModel` in a `Periodic, Bounded, Bounded` configuration. I think that it is possible the main issue is an interaction (a read-write race condition) associated with both impenetrable boundary conditions and periodic boundary conditions that affects the 8 corner points. The race condition affects model trajectories via the Coriolis force (which is the only term as far as I know that touches the 8 ""corner"" points affected by this race condition). Because the race condition only manifests when a `Coriolis` or `VectorInvariant` stencil touches corner points, it may not affect _most_ `Periodic, Periodic, Bounded` models, which could explain why we haven't caught it. The reason it doesn't affect those models is because this race condition would only affect the corner points of `w`, which are not touched when using an `FPlane` Coriolis model. However, it's possible (I'm not sure) that the race condition could affect models using `NonTraditionalFPlane` in `Periodic, Periodic, Bounded` configurations. More generally, it will also affect models that are bounded in the `y`-direction, because in those models the corner points of the `y`-velocity are affected and also invoked when using `FPlane` or `BetaPlane` coriolis. That's as much as I know. It's very hard to gather information about this bug because it's so rare are subtle. In other words, only one grid point among 10,000 iterations might be affected, and the errors induced are very small. To find this issue, we have to run tens of thousands of iterations of identical models on the GPU, and then co",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865:568,race condition,race condition,568,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865,4,['race condition'],['race condition']
Performance,"@vchuravy - I modified `src/Grid/zeros_and_ones.jl` to be; ```; using CUDA; using AMDGPU; using Oceananigans.Architectures: CPU, CUDAGPU, ROCmGPU, AbstractArchitecture; using KernelAbstractions; import Base: zeros. zeros(FT, ::CPU, N...) = zeros(FT, N...); zeros(FT, ::CUDAGPU, N...) = CUDA.zeros(FT, N...); zeros(FT, ::ROCmGPU, N...) = KernelAbstractions.zeros(AMDGPU.ROCBackend(), FT, N...). zeros(arch::AbstractArchitecture, grid, N...) = zeros(eltype(grid), arch, N...); zeros(grid::AbstractGrid, N...) = zeros(eltype(grid), architecture(grid), N...). @inline Base.zero(grid::AbstractGrid) = zero(eltype(grid)); @inline Base.one(grid::AbstractGrid) = one(eltype(grid)); ```. This throws the same error as just using `AMDGPU.jl`. For reference. ```; ERROR: LoadError: Not implemented; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] runtime_module(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/interface.jl:173; [3] build_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:101; [4] (::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}})(); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:139; [5] lock(f::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}, l::ReentrantLock); @ Base ./lock.jl:229; [6] macro expansion; @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GP",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936309420:760,Load,LoadError,760,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936309420,1,['Load'],['LoadError']
Performance,@xkykai do you think you could run some immersed boundary tests with this branch to make sure this change doesn’t affect your work? I think we’re interested in both performance and making sure the solution is high quality.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1582732172:165,perform,performance,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1582732172,1,['perform'],['performance']
Performance,"A more hierarchical organization of the docs is. 1. Introduction; * What's Oceananigans?; * Installation; * Writing your first script; * Do you want to save the world? (by contributing to Oceananigans); - Contributing guide; - Features that need validating; - Features that need documenting and examples; * Gallery; 2. Examples; 3. Building models, running simulations, and post processing; * Grids and computer architectures; * Fields, BoundaryCondition, and AbstractOperations; * IncompressibleModel; * HydrostaticFreeSurfaceModel; * ShallowWaterModel; * Setting initial conditions; * Diffusion, viscosity, and TurbulenceClosures; * Forcing functions; * Coriolis forces; * Buoyancy forces; * Simulation; * OutputWriters; * OutputReaders, post-processing, and plotting; 5. Useful tips; * Using Graphics Processing Units (GPUs); * Common errors and performance pitfalls; 8. Fluid dynamics and ocean physics; * Navier-Stokes and tracer conservation equations; * The hydrostatic approximation and shallow water equations; * The Boussinesq approximation and equations of state for seawater; * Rotating domains and Coriolis forces; * Diffusion, hyperdiffusion, and parameterization of subgrid processes; - Basic models for diffusive processes; - Large eddy simulation; - Boundary layer parameterization; 9. Numerical implementation; * The finite volume discretization on a staggered grid; * Interpolation, differencing, and advection schemes; * Boundary conditions and immersed boundaries; * The pressure correction method for enforcing mass conservation; * Discretization of hydrostatic and non-hydrostatic pressure; * Implicit time-stepping; * Multi-domain simulations and the cubed sphere; 10. Developer guide; 11. Appendix; * References",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142:849,perform,performance,849,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142,2,['perform'],['performance']
Performance,"A new idea for extending the pressure solver to `MultiRegion` is to divide the FFT computations into ""local"" and ""non-local"" directions. . The FFT in local directions can be easily performed wrapping the transform in `@apply_regionally`; For non local directions, if `storage` and `plan` are `unified_array`s, the non local FFT can be performed by permuting the partitioning of the `MultiRegionGrid` without having to transpose memory (that will happen under the hood thanks to unified memory). . This strategy would not be easily extensible to generally subdivided regions and will play well only with one direction partitioning, but given the current limitations of the FFT solver (only regular grid), I think it is a good strategy to get something to work",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969:181,perform,performed,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969,2,['perform'],['performed']
Performance,"ADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fullscreen::Bool, monitor::Nothing, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:344; [4] GLMakie.Screen(; resolution::Tuple{Int64, Int64}, visible::Bool, title::String, kw_args::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:373; [5] Screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:345 [inlined]; [6] global_gl_screen; @ ~/.julia/packages/GLMakie/XG7Hm/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:1386,Load,LoadError,1386,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985,1,['Load'],['LoadError']
Performance,"According to @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654:856,optimiz,optimized,856,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654,2,['optimiz'],['optimized']
Performance,"After adding `MPI.Init()` back to `distributed_nonhydrostatic_model_mpi.jl`, the script seems to run (it's still running...). Here's a few idle thoughts (independent of this PR, just leaving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:637,Load,Loading,637,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590,1,['Load'],['Loading']
Performance,"After discussing with @ali-ramadhan, it seems more clear that a simple solution is just to use a default halo size of 3. For most models that use the highest order advection scheme we offer this has no effect. For models that use a lower-order advection scheme but don't change the halo size, the memory foot print of the model is ever-so-slightly larger than it needs to be. But this slightly-larger footprint probably isn't noticeable for most problems. So in summary, minimal halo sizes are a minor optimization that has little effect on most problems. Auto-optimizing the halo size has major downsides for usability, so I think the trade-off leans towards big default halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-741886883:502,optimiz,optimization,502,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-741886883,4,['optimiz'],"['optimization', 'optimizing']"
Performance,"After some discussion with @glwagner , I'm going to close this PR and rebase off of CLIMA:main. Stay tuned for a new PR..",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3466#issuecomment-1934850421:101,tune,tuned,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3466#issuecomment-1934850421,1,['tune'],['tuned']
Performance,Again unsure if it affects performance but since `rate` is referenced as global it needs to be `const`; eg `const rate = 1/10`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875683170:27,perform,performance,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875683170,1,['perform'],['performance']
Performance,"Agreed. Useful and related comment. > I was thinking of doing some prototyping and benchmarking in a sandbox by building off the example in my PR [vchuravy/GPUifyLoops.jl#18](https://github.com/vchuravy/GPUifyLoops.jl/pull/18).; > ; > The PR contains an example that can be extended to rely on a `Grid` struct, multiple `FaceField`s and ` CellField`. So I'll prototype grids and fields that are `isbitstype` (you already helped by doing this for a grid in [#59 (comment)](https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-467660181)) and test to see if they work on the GPU with GPUifyLoops.jl. If they do work and performance isn't degraded then I'll rewrite the operators to use grid and field structs.; > ; > You probably know how to do this better than me, but might be good if I rewrite the operators as they's still undocumented and do some _slightly convoluted_ stuff to avoid having to store intermediate calculations.; > ; > Right now I'm focusing on system tests and benchmarks but once @christophernhill @jm-c and I get closer to implementing the variable _Δz_ grid #47 I will work on this.; >; >_Originally posted by @ali-ramadhan in https://github.com/climate-machine/Oceananigans.jl/issues/115#issuecomment-470782067_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-470297910:639,perform,performance,639,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-470297910,1,['perform'],['performance']
Performance,"Ah ok I see why your original script didn't work now. When executing. ```julia; model = IncompressibleModel(grid=grid,; closure = closure,; boundary_conditions = (v=v_bcs); ); ```. this assigned `v_bcs` to the new variable `v` and passes it to the `IncompressibleModel` function. `v_bc` itself is a `NamedTuple` containing `x, y, z` properties so the `IncompressibleModel` constructor does not complain. Since the named tuple that is passed does not not have a `v` property, the velocities get the default boundary conditions (free slip and no normal flow). Then when you call `set!(model, v=-0.5)` it fills v to be -0.5 everywhere but then `update_state!(model)` is called to ensure that the velocity field is incompressible (divergence-free) by performing a pressure projection step. Since the default boundary condition enforces no-normal flow, the velocity cannot be -0.5 everywhere so the pressure field updates it to be zero to enforce incompressibility. This is a pretty subtle bug (related to #1204)... Since the proper named tuple can't be checked for in the constructor function signature, I wonder if it's worth adding a manual check to make sure a `NamedTuple{(:x,:y,:z)}` was not passed to the model constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1294#issuecomment-756979930:747,perform,performing,747,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1294#issuecomment-756979930,1,['perform'],['performing']
Performance,"Ah so I've realised this isn't the fix we needed, and I was just hiding it from myself in the profile because I replaced the function by writing it in the REPL. I made an MWE:. ```jula; using Oceananigans. grid = RectilinearGrid(GPU(), topology = (Flat, Flat, Bounded), size = (100, ), extent = (400, )). model = HydrostaticFreeSurfaceModel(; grid, velocities = PrescribedVelocityFields(), momentum_advection=nothing, buoyancy=nothing, tracers = ntuple(n->Symbol(:T, n), Val(30))); ```; <img width=""1361"" alt=""Screenshot 2024-09-26 at 12 00 29"" src=""https://github.com/user-attachments/assets/2cf2a379-88e9-428f-8156-4ddead2a02e4"">; You can see from this profile that `fill_open_boundary_regions!` takes a lot longer than `fill_halo_event!`, even though there are no velocity open boundaries. This is because it is launching a load of zero size kernels where as `fill_halo_event!` just returns nothing instead. I've fixed this now and get this from the profile instead:; <img width=""1251"" alt=""Screenshot 2024-09-26 at 12 02 11"" src=""https://github.com/user-attachments/assets/0bf91086-bc12-4a17-ba48-89b9b1c2e7ae"">. In numbers, the original version benchmarks `time_step!` at around 4.074 ms ± 581.472 μs and the new version 2.438 ms ± 501.642 μs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3792#issuecomment-2376508207:827,load,load,827,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3792#issuecomment-2376508207,1,['load'],['load']
Performance,"Ah sorry I must have misunderstood your question. Yeah I think broadcasts; tend to perform really well on scalar operations so I don't see why not. On Tue, Mar 5, 2019, 12:13 PM Gregory L. Wagner <notifications@github.com>; wrote:. > I'm not suggesting we should always use broadcasting. I'm just wondering; > if it's ok to use it for simple operations. It's a nice abstraction that; > works on CPUs and GPUs for simple calculations / global array updates (for; > example; > <https://github.com/glwagner/StaggeredPoisson.jl/blob/d104825ba33f184af3b90ca0d958247d0011c7ad/src/solvers.jl#L148>; > ).; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/108#issuecomment-469768233>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/ATKyBSiIR6hlh-r4hjpSmahUJhp3x7Gzks5vTqXEgaJpZM4bfFUj>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/108#issuecomment-469769111:83,perform,perform,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/108#issuecomment-469769111,1,['perform'],['perform']
Performance,"Ah yes as noted here:. > This speed issue disappears either when ζ = ∂x(v) - ∂y(u) is replaced with ζ = Field(∂x(v) - ∂y(u)), or when ζ is the only variable in fields_slice. That's pretty bizarre. That makes me think it's some kind of weird interaction between `NCDatasets` and `Oceananigans`. I can say, with `ζ = Field(∂x(v) - ∂y(u))` the output type is different. It would seem more complex in fact, because it has one more layer of indirection (ie it's the window that refers to a 3D computed field, rather than a windowed computed field). So I don't know why that would compile faster. Honestly I don't think any of us has much experience optimizing compile time. Perhaps first reading this blog post:. https://julialang.org/blog/2020/08/invalidations/. and then the source code for `NetCDFOutputWriter` will lead to revelations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805104189:644,optimiz,optimizing,644,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805104189,1,['optimiz'],['optimizing']
Performance,"Ah! In `HydrostaticFreeSurfaceModel`, the implicit free surface algorithm uses a pressure correction / operator splitting method. It's really a sort of pseudo-implicit treatment (because the velocity field is _corrected_ rather than time-stepped concurrently with the free surface. I think it would be possible to implement an operator splitting method in `ShallowWaterModel`. But is this useful? This could lead to a loss of accuracy (I'm not sure). In the event that the pressure / free surface displacement is passive (so one doesn't care about accuracy), it might be better to use a rigid lid approximation (and thus a two-dimensional `IncompressibleModel`, rather than `ShallowWaterModel`). But I am ready to stand corrected.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1378#issuecomment-781574578:246,concurren,concurrently,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1378#issuecomment-781574578,1,['concurren'],['concurrently']
Performance,"Ah, apparently the error appears when we have an `AveragedTimeInterval`. Change the `simple_output` call to. ```julia; simulation.output_writers[:simple_output] = NetCDFOutputWriter(model, wout,; schedule = AveragedTimeInterval(10seconds),; filepath = ""windowed_avg.nc"", mode = ""c""); ```. and we have the following error:. ```; ERROR: LoadError: Custom output Uw needs dimensions!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Int64},Array{Float64,2},FieldSlicer{Colon,Colon,Colon}}, ::String, ::Type{T} where T, ::Int64, ::Tuple{}, ::Dict{Any,Any}) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:357; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :b),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{Coordinat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056:335,Load,LoadError,335,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056,1,['Load'],['LoadError']
Performance,"Ah, nice! Maybe using `ConditionalOperation` is a bit slower than `WindowSpatialAverage` because the reduction is performed on the whole domain. Anyways, I don't think reduction is performance-critical so I agree to nuke `WindowSpatialAverage`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022501885:114,perform,performed,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022501885,2,['perform'],"['performance-critical', 'performed']"
Performance,"Ah, thanks for that @maleadt. So microbenchmarks suggest squaring by `Float64` and `Int32` are virtually indistinguishable in simple code. Is there any way that this change is somehow affected by compiler heuristics; eg code inlining is somehow much more effective / optimized when we can invoke `nv_pow`... ? Otherwise I'm at a loss. I think prior to the changes we grouped into our ""upgrade to julia 1.6"" we were using the function `CUDA.pow` (from an ancient `CUDA.jl` version).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869812530:267,optimiz,optimized,267,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869812530,2,['optimiz'],['optimized']
Performance,"Also important to keep in mind in this discussion: Our workflow will be different from most standard models, which write out instantaneous output that then is post-processed to get statistics etc. We will have to accumulate statistics on the fly, and we can (and should) forgo most instantaneous output, at least for the atmosphere. The model will learn from the accumulated statistics. Otherwise, with instantaneous output, the data volume, especially with embedded LES, will create an I/O and data transfer bottleneck that will limit us, and, e.g., will limit our ability to use distributed computing platforms.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475692509:509,bottleneck,bottleneck,509,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475692509,1,['bottleneck'],['bottleneck']
Performance,"Also, I forgot to post an example of the error that happens when you pass an operation as a `condition`. Here's the error that I get in that case:. ```; ERROR: LoadError: MethodError: no method matching arch_array(::CPU, ::KernelFunctionOperation{Center, Center, Face, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64, typeof(boundary_node), Tuple{Center, Center, Face}}). Closest candidates are:; arch_array(::Distributed, ::Any); @ Oceananigans ~/repos/Oceananigans.jl/src/DistributedComputations/distributed_architectures.jl:263; arch_array(::CPU, ::Array); @ Oceananigans ~/repos/Oceananigans.jl/src/Architectures.jl:59; arch_array(::CPU, ::CUDA.CuArray); @ Oceananigans ~/repos/Oceananigans.jl/src/Architectures.jl:60; ... Stacktrace:; [1] condition_operand; @ ~/repos/Oceananigans.jl/src/ImmersedBoundaries/immersed_reductions.jl:24 [inlined]; [2] sum(f::Function, c::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, Periodic, Periodic, B",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1907385408:160,Load,LoadError,160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1907385408,1,['Load'],['LoadError']
Performance,"Also, the docs are failing to build with this error:. ```; ERROR: LoadError: IOError: sendfile: no space left on device (ENOSPC); ```. Do we still have a storage problem? I believe these tests run on tartarus, not sverdrup, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867678106:66,Load,LoadError,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867678106,1,['Load'],['LoadError']
Performance,"Also, the implicit vertical solver seems to affect the performance. I would have to guess that it is because we are passing functions as arguments to the kernel.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1485410927:55,perform,performance,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1485410927,1,['perform'],['performance']
Performance,"Also, what's the correct syntax to define kernel_parameters over one dimension? For example, the line; ```julia; kernel_parameters = KernelParameters((Nc, 1), (0, Nz_grid-1)); ```; works correctly. However, when I try to define it for one dimension with; ```julia; kernel_parameters = KernelParameters((1,), (Nz_grid-1,)); ```; I encounter the following error:; ```julia; ERROR: LoadError: MethodError: no method matching heuristic_workgroup(::Int64). Closest candidates are:; heuristic_workgroup(::Any, ::Any, ::Any, ::Any); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-aquaplanet/src/Utils/kernel_launching.jl:48; heuristic_workgroup(::Any, ::Any, ::Any); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-aquaplanet/src/Utils/kernel_launching.jl:48; heuristic_workgroup(::Any, ::Any); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-aquaplanet/src/Utils/kernel_launching.jl:48; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3611#issuecomment-2138476721:379,Load,LoadError,379,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3611#issuecomment-2138476721,1,['Load'],['LoadError']
Performance,"An easier course of action would be to forget about performance at first and just fill halos every substep.; This will be quite inefficient but will allow us to test open boundary conditions for the hydrostatic model and validate them first. There is an implementation of a split explicit free surface solver that does not require special operators (specifically for a multi region grid) in #3596 ; https://github.com/CliMA/Oceananigans.jl/blob/a6e9a465aa9528b5b3afd49737310e710e4681b0/src/MultiRegion/multi_region_split_explicit_free_surface.jl#L130-L170. We could adapt this implementation for normal grids by implementing a keyword argument in the `SpliExplicitFreeSurface` constructor. Something like the `extended_halos` that is mentioned here; https://github.com/CliMA/Oceananigans.jl/blob/a6e9a465aa9528b5b3afd49737310e710e4681b0/src/MultiRegion/multi_region_split_explicit_free_surface.jl#L19-L28. For serial grids, `extended_halos` is not the correct argument, though, because we do not extend halos (we do that only on distributed and multi region grids), so maybe something like `use_boundary_aware_operators.` . Once the numerics have been settled we can adapt the open boundary condition implementation to the special operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2399186268:52,perform,performance,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2399186268,1,['perform'],['performance']
Performance,"Another important point is that this discussion is not about ""deciding"" on a _single_ user interfaces, but rather deciding what interfaces we want to put into the code. We can and perhaps should have multiple ways of specifying stretched grids. We have already agreed that specifying cell interface locations with an array (loaded from file, for example) is an important pattern to support.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814924072:324,load,loaded,324,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814924072,1,['load'],['loaded']
Performance,"Another thought for @christophernhill . At the talk today on `ImplicitGlobalGrid.jl`, they were using `@view` in the simplest code but they dropped it as soon as they started to optimize the code. I believe they started using `LazyArrays.jl`. I don't know what it is but I suspect it doesn't have the problems that `@view` might have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885901320:178,optimiz,optimize,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885901320,2,['optimiz'],['optimize']
Performance,"Apologies - other urgent work and family needs have delayed me. I'm using; Julia 1.9.3; CairoMakie v0.9.4; and have in my status report; GLMakie v0.7.4 and Makie v0.18.4. I tried to use update with the pkg manager to no effect, but see I should be using CairoMakie@0.11, which I am now installing.; This was not successful. For example the file S7LmV_3TYIX.dll would not load giving a permission denied error, but my check of the properties/security did not reveal a deficiency. However, the example worked fine. Many thanks - Kevin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3442#issuecomment-1920152651:371,load,load,371,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3442#issuecomment-1920152651,1,['load'],['load']
Performance,"Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?. ```julia; wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); Stacktrace:; [1] check; @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; [2] nc_create(path::String, cmode::UInt16); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; [4] NCDataset; @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{O",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784:585,Load,LoadError,585,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784,1,['Load'],['LoadError']
Performance,"Are the current options (`@async` blocks) not sufficient? I'd rather not have a parallel mechanism and have to maintain the APIs (explicitly passing streams/queues) to support it. Even right now it's relatively broken, only supporting kernel launches and memory copies (i.e. BLAS APIs do not take explicit stream arguments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1429353692:157,queue,queues,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1429353692,1,['queue'],['queues']
Performance,"Are we ok with this as a user interface? it's a little implicit. We could alternatively use a function-based API to make things a little more obvious, something like. ```julia; fts[1, 2, 3, 4] # get 4th time-index; ```. ```julia; at_time(4, fts, 1, 2, 3) # linearly interpolate to t=4; ```. mainly i'd be worried about issues like. ```julia; fts[1, 2, 3, 4] \ne fts[1, 2, 3, 4.0]; ```. which is rather easy to confuse?. We also might be able to use syntax like. ```julia; fts[1, 2, 3, time=4]; ```. if that is performant. Or. ```julia; fts[1, 2, 3, Time(4)]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696028139:510,perform,performant,510,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696028139,1,['perform'],['performant']
Performance,"Are you proposing a third interface that takes a 3-argument function of `x, L, N`? I think that's fine as a proposal, I just want to be clear about what is being suggested, exactly. What I didn't understand is how one can specify the cell interface locations (call it the ""`z_faces` interface"" --- the one we currently have) without knowing the number of grid points:. > I agree that to define the grid with z_faces we need to know the number of grid points, but that can be done internally. I agree there are other possible interfaces that _do not_ require passing the number of grid points as a parameter; or rather simplify this process by performing calculations under the hood. It could be nice to design types such as `LinearStretching` or `ChebyshevStretching` that provide users with out-of-the-box stretched grids to be used with interface 2 proposed above (call this the ""coordinate map interface""). We can incorporate dispatch on such types (versus on plain functions) in the grid constructor. An example of this being used is. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = ChebyshevStretching()); ```. or, when a parameter is involves such as for hyperbolic stretching, something like. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = HyperbolicStretching(stretching_parameter=1.3)); ```. It seems like maybe there is a 3rd option too? It looks somewhat similar to the coordinate map interface, except that the map expects three arguments rather than one, and returns an array rather than a scalar value that represents the map?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100:643,perform,performing,643,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100,2,['perform'],['performing']
Performance,"As an aside, I think this issue illustrates that users are indeed interested in being able to evaluate gradients across boundaries. This is important because @simone-silvestri proposed a change that would make this impossible (eg it has been proposed we do not fill halos for `Value` and `Gradient` boundary conditions, and instead evaluate the associated fluxes in the same way we do for immersed boundaries --- because this has performance advantages for very large models).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689901112:430,perform,performance,430,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689901112,1,['perform'],['performance']
Performance,"As an update, I have pushed a commit consisting of a working version of the double gyre example, where Δz is replaced by zspacings and znodes, the plots are improved with additional attributes, and visualization is performed on the CPU even if the code runs on the GPU. I still need to incorporate some of the suggested modifications listed above. I am uploading the plots and animation here. In today's meeting with Navid and Simone, we looked at switching to the lat-lon grid and more. In the upcoming commits, I will run for longer time on a lat-lon grid, introduce checkpoints for restarting the simulation, and add a topography. . [double_gyre_grid_spacing.pdf](https://github.com/CliMA/Oceananigans.jl/files/11493173/double_gyre_grid_spacing.pdf). [double_gyre_circulation.pdf](https://github.com/CliMA/Oceananigans.jl/files/11493174/double_gyre_circulation.pdf). https://github.com/CliMA/Oceananigans.jl/assets/12926768/cf148a0c-58c8-4ba2-b649-cb40418d0665",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3087#issuecomment-1550535207:215,perform,performed,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3087#issuecomment-1550535207,1,['perform'],['performed']
Performance,"As discussed via zoom with @kburns, passing a key to computations to be stored and used to determine whether a computation needs to be performed is a simple method that may work for us. A simple option for a key is the current model time, which works for all the time stepping methods we employ and has the additional advantage of interpretability. One complication is that we allow users to specify memory space for `ComputedField`s and `AveragedField`s. As a result, two `ComputedField`s that share memory space may have incorrect `data` if the memory is overwritten. This is, in fact, a problem even in the current code and not dependent on the optimizations discussed in this issue. Since we think it is important to give users the option of avoiding unnecessary memory allocation by managing the allocation of scratch space for computations, we cannot prevent incorrect output resulting from overwriting of scratch space during operations with embedded averaged fields and computed fields. We simply have to document this potential ""gotcha"". We can make avoiding repeated operations a bit safer by requiring users to enable it when a `ComputedField` or `AveragedField` is constructed by a keyword argument, something like `recompute_safely`: . ```julia; U = AveragedField(model.velocities.u, dims=(1, 2), data=scratch, recompute_safely=false); ```. When `recompute_safely` is disabled, the model time at computation will be cached. The cache can either be inside `AveragedField`, or in a global cache. (A global cache has the advantage of being on the CPU; a local cache has the advantage of being local).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/955#issuecomment-694601458:135,perform,performed,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/955#issuecomment-694601458,7,"['cache', 'optimiz', 'perform']","['cache', 'cached', 'optimizations', 'performed']"
Performance,"As suggested by @francispoulin, the following was commented out https://github.com/CliMA/Oceananigans.jl/blob/master/src/Models/ShallowWaterModels/update_shallow_water_state.jl#L19-L22 to remove filling halo regions and buffering between ranks.; This gave perfect efficiency up to 3 ranks. This was mainly done to locate where possible bottlenecks are and not a legitimate change to the code. It was expected that buffering is what's causing efficiency decreases, and this confirms that there are no other additional undetected causes for efficiency drops.; <html>; <body>; <!--StartFragment-->. size | ranks | slowdown | efficiency | memory | allocs; -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 1.0 | 1.0 | 1.0 | 1.0; (4096, 512) | (1, 2) | 0.988079 | 1.01206 | 1.06328 | 1.0406; (4096, 768) | (1, 3) | 0.992832 | 1.00722 | 1.06328 | 1.0406. <!--EndFragment-->; </body>; </html>. system environment and CUDA.versioninfo():; ```; Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); Environment:; JULIA_MPI_PATH = /home/software/spack/openmpi/3.1.4-nhjzelonyovxks5ydtrxehceqxsbf7ik; JULIA_CUDA_USE_BINARYBUILDER = false; JULIA_DEPOT_PATH = /nobackup/users/henryguo/projects/henry-test/.julia; GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.1.243, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0; Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.1; - CUFFT: 10.1.1; - CUSOLVER: 10.2.0; - CUSPARSE: 10.3.0; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing; Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75; Environment:; - JULIA_CUDA_USE_BINARYBUILDER: false; 3 devices:; 0: Tesla V100-SXM2-32GB (",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887933846:336,bottleneck,bottlenecks,336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887933846,1,['bottleneck'],['bottlenecks']
Performance,"Average reduction with conditional expressions, e.g., like. https://github.com/CliMA/Oceananigans.jl/blob/748feab10a55fa65a46455620203252a6fc0646e/test/test_field_reductions.jl#L107. induce scalar operations on the GPU. I guess it's not a surprise. I just had to add, e.g,. ```Julia; @compute Txyz = CUDA.@allowscalar Field(Average(T, condition=T.>3)); ```. Only mentioning this here in case it might something in the source code that could be affecting code performance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221170568:459,perform,performance,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221170568,1,['perform'],['performance']
Performance,"Averaging operations does not allocate any extra memory and is more performant than precalculating a field, storing the data, and then taking the average of that. In general, you only need 3D scratch space if you have 3D output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1439244612:68,perform,performant,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1439244612,1,['perform'],['performant']
Performance,"Below is a link to a paper that compares the scalability of multi-threading in Python, Julia and Chapel. . Brief Summary: They find that none of them do as well as OpenMP but give some reasons as to why. But they do find some improvements going up to 64 threads, but the effiicency in some cases go down to 20%. It seems that Python might do better on low numbers of threads but Julia does better on more. This was last year so I am sure this should probably redone. Also, I should mention I don't believe their problem is like ours but it's an example and has some pictures, so that's nice to see. https://hal.inria.fr/hal-02879767/document",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886076610:45,scalab,scalability,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886076610,2,"['multi-thread', 'scalab']","['multi-threading', 'scalability']"
Performance,"Billy mentioned it in some other comments but while we do splat args for some of the function calls, the function definitions use Varargs instead. This should avoid the catastrophic slowdown we saw with splatting earlier, but I agree that it should be tested. Do you have any good CPU performance tests set up @glwagner ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2150096206:285,perform,performance,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2150096206,1,['perform'],['performance']
Performance,"But I'm not sure which part are you referring as ""good idea or not"". The fact that they belong to a different module? Perhaps we could have these constants loaded/exported with Oceananigans main module. Is this what you are thinking? That would work also!. What I think is _not_ good is having, e.g., every module redefining constants. E.g., `R_Earth` is currently defined in two places. Say we change one definition thinking it will affect everything but it won't. Also I found it quite cumbersome in scripts when I wanted to load these constants I had to load one from `Grids` and one from `Coriolis` and one from `BuoyancyModels`.... That's a bit counterintuitive from a user's perspective.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492618180:156,load,loaded,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492618180,3,['load'],"['load', 'loaded']"
Performance,"But definitely clean up and performance. Just to clarify fixing type inference doesn't change the result of the reduction, it just makes it go much faster",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3794#issuecomment-2380363489:28,perform,performance,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3794#issuecomment-2380363489,1,['perform'],['performance']
Performance,"By the way, WENO (and other advection schemes) are always going to be at most second order as they are implemented right now. So the _order_ might not be the correct metric to look at the performance, the truncation error is probably what we want to look at",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164473690:188,perform,performance,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164473690,1,['perform'],['performance']
Performance,"Can we use a wrapper that automagically loads data from file for the specified time index (and also perform spatial slicing), using the nice GeoData getindex syntax?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-738272413:40,load,loads,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-738272413,2,"['load', 'perform']","['loads', 'perform']"
Performance,"Can you tell us a bit more about your system?. What is `versioninfo(verbose=true)` and `] status -m`?. Was there anything more printed above the message that precompilation; failed?. One thing you might want to try is using Julia 1.10, instead of 1.9, but; right now I don't have information to pinpoint what is causing the; segmentation fault. On Wed, Jul 17, 2024, 12:23 Logan Knudsen ***@***.***> wrote:. > Update: I have been able to reduce the error to be a procompiling error in; > oceananigans.jl:; >; > ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); > @ Base ./loading.jl:2300; > [3] compilecache; > @ ./loading.jl:2167 [inlined]; > [4] _require(pkg::Base.PkgId, env::String); > @ Base ./loading.jl:1805; > [5] _require_prelocked(uuidkey::Base.PkgId, env::String); > @ Base ./loading.jl:1660; > [6] macro expansion; > @ ./loading.jl:1648 [inlined]; > [7] macro expansion; > @ ./lock.jl:267 [inlined]; > [8] require(into::Module, mod::Symbol); > @ Base ./loading.jl:1611; > in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; >; > I have been trying to make sure that everything is up to date, and I am; > running on Julia version 1.9.2. My code is just; >; > using Oceananingans; >; > as I have been trying to get the library to loas properly. Does anyone; > have any experience with this error or does it make things any clearer?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XAIMUIHCDCBIJA4NLZM2K75AVCNFSM6AAAAABK643UJWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDEMZTG4YTAMZXGI",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098:518,Load,LoadError,518,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098,7,"['Load', 'load']","['LoadError', 'loading']"
Performance,"Changing the function call to ; ```julia; function define_output_variable!(dataset,; wsa::Union{WindowedSpatialAverage, WindowedTimeAverage{<:WindowedSpatialAverage}},; name, array_type, compression, attributes, dimensions); ```; raises some other errors and I'm not sure the best way to fix them. I think the issue is that a `WindowedTimeAverage` doesn't have the properties `field` (it has `operand`) and it doesn't have the property `dims`. . For example, running the code above I get:. ```; ERROR: LoadError: type WindowedTimeAverage has no field field; Stacktrace:; [1] getproperty(::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Int64},Array{Float64,2},FieldSlicer{Colon,Colon,Colon}}, ::Symbol) at ./Base.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryCo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449:502,Load,LoadError,502,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449,1,['Load'],['LoadError']
Performance,"Compilation performance is affected by this, so I think it's more correct to say that performance is affected.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3851#issuecomment-2429332352:12,perform,performance,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3851#issuecomment-2429332352,2,['perform'],['performance']
Performance,"Copied below. ```; ERROR: LoadError: `makedocs` encountered an error. Terminating build; --;   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33;   | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);   | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255;   | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);   | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170;   | [4] #2;   | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined];   | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);   | @ Base.Filesystem ./file.jl:106;   | [6] #makedocs#1;   | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined];   | [7] top-level scope;   | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155;   | 🚨 Error: The command exited with status 1;   | user command error: exit status 1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884364299:26,Load,LoadError,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884364299,1,['Load'],['LoadError']
Performance,"Could you explain why using `ifelse` has better performance?; Is this because the ternary `? :` is an alias for `ifelse`? ; What about `@inline`?. In this case, we only had the wind velocity from the specifications of the computer fans we used for the rotating tank experiment, but I understand that even in this case, I could calculate `τ₀` using bulk formula while defining `p`. Thanks for the idea. For the boundary conditions. I was my bad. You specify on the [Documentation](https://clima.github.io/OceananigansDocumentation/stable/model_setup/boundary_conditions/#.-Spatially-and-temporally-varying-flux) that. > By default, a function boundary condition is called with the signature; > ; > `f(ξ, η, t)`; > ; > where t is time and ξ, η are spatial coordinates that vary along the boundary:; > ; > `f(y, z, t)` on x-boundaries;; > `f(x, z, t)` on y-boundaries;; > `f(x, y, t)` on z-boundaries. I am just repeating here in case someone falls in the same problem and comes to this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066113425:48,perform,performance,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066113425,1,['perform'],['performance']
Performance,"Currently in my workflow, I define an environment variable that contains an string like `$init_$end.nc`, where `init` is the initial time and `end` is the `stop_time` of the simulation. In the first instantiation of the model for 60 days, this string will be appended to my output filename e.g.`vel_field_`, resulting on something like `vel_field_0_60.nc`. For the next pickup the filename will be changed to `vel_field_60_120.nc`. This works well when the files are not split, i.e. `file_splitting = NoFileSplitting()`. However when splitting the file, e.g. `file_splitting = TimeInterval(30days)`, the first instantiation will result in the following files:; ```; vel_fields_0_60_part1.nc vel_fields_0_60_part2.nc vel_fields_0_60_part3.nc; ```; then the next pickup will result in files: ; ```; vel_fields_60_120_part1.nc vel_fields_60_120_part3.nc vel_fields_60_120_part5.nc; vel_fields_60_120_part2.nc vel_fields_60_120_part4.nc; ```; of this files, the first 2 parts (`vel_fields_60_120_part1.nc` and `vel_fields_60_120_part2.nc`) are empty, and the `vel_fields_60_120_part3.nc` contains data from the day 61 until 91. This makes the loading of the data for post-processing a bit tricky, since some of they are empty and the disk storage will make more difficult chunking data. . If I don't change the name each time I pickup, with the `overwrite_existing=false` it crashes, and with `overwrite_existing=true` it rewrites all the files. . Another workflow will be to create a new folder for each pickup keeping the same filename, but splitting the files will result in the same issue of file duplication. . I hope this description of the workflow is clearer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391946301:1139,load,loading,1139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391946301,2,['load'],['loading']
Performance,"Damn, it looks like the tests on the GPU are not working because CUDA is not loaded properly. ; I am trying to address this in #3880. A segmentation fault probably means the MPI is not CUDA-aware. Typically, the MPI that is shipped with MPI_jll is not cuda-aware. A good way to check is; ```julia; julia> using MPI. julia> MPI.has_cuda(); true; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878#issuecomment-2443869989:77,load,loaded,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878#issuecomment-2443869989,1,['load'],['loaded']
Performance,Data is loaded into `FieldTimeSeries` by. https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/OutputReaders/field_time_series.jl#L146. which calls. https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/OutputReaders/field_time_series.jl#L200-L205. The data seems to be loaded into the intermediate `Field`:. https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/OutputReaders/field_time_series.jl#L237. so the problem may be. https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/OutputReaders/field_time_series.jl#L205. Voila... https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/Fields/set!.jl#L43-L55,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689910675:8,load,loaded,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689910675,2,['load'],['loaded']
Performance,"Did a quick small strong scaling benchmark on Tartarus (256^3) up to 16 cores but results don't look super great? ~9.5x speedup on 16 cores. Better than multi-threading though. Maybe I'm not benchmarking properly though. Could also be missing some MPI barriers. Should probably learn how to profile MPI code. ```; Incompressible model strong scaling benchmark; ┌─────────────────┬───────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ size │ ranks │ min │ median │ mean │ max │ memory │ allocs │; ├─────────────────┼───────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ (256, 256, 256) │ 1 │ 3.641 s │ 3.686 s │ 3.686 s │ 3.730 s │ 355.28 KiB │ 2336 │; │ (256, 256, 256) │ 2 │ 1.917 s │ 1.918 s │ 1.921 s │ 1.928 s │ 346.00 KiB │ 2782 │; │ (256, 256, 256) │ 4 │ 1.249 s │ 1.283 s │ 1.279 s │ 1.300 s │ 348.47 KiB │ 2822 │; │ (256, 256, 256) │ 8 │ 652.029 ms │ 714.833 ms │ 704.940 ms │ 738.885 ms │ 353.84 KiB │ 2902 │; │ (256, 256, 256) │ 16 │ 377.153 ms │ 388.435 ms │ 394.780 ms │ 415.562 ms │ 366.16 KiB │ 3062 │; └─────────────────┴───────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ```; Incompressible model strong scaling speedup; ┌─────────────────┬───────┬─────────┬──────────┬─────────┐; │ size │ ranks │ speedup │ memory │ allocs │; ├─────────────────┼───────┼─────────┼──────────┼─────────┤; │ (256, 256, 256) │ 1 │ 1.0 │ 1.0 │ 1.0 │; │ (256, 256, 256) │ 2 │ 1.92195 │ 0.973876 │ 1.19092 │; │ (256, 256, 256) │ 4 │ 2.87312 │ 0.980825 │ 1.20805 │; │ (256, 256, 256) │ 8 │ 5.15614 │ 0.995954 │ 1.24229 │; │ (256, 256, 256) │ 16 │ 9.48879 │ 1.03061 │ 1.31079 │; └─────────────────┴───────┴─────────┴──────────┴─────────┘; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-794954624:153,multi-thread,multi-threading,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-794954624,1,['multi-thread'],['multi-threading']
Performance,"Doctests fail because of all the `loop not unrolled` warnings we get.; We should remedy this before we move to Julia v1.10. @glwagner you bumped onto this previously, right?. ```Julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 143 already precompiled.; [ Info: Oceananigans will use 8 threads. julia> grid = RectilinearGrid(size=(1, 8, 8), extent=(1, 1, 1)); 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.125. julia> model = NonhydrostaticModel(; grid); warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requeste",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:845,optimiz,optimizer,845,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814,2,"['optimiz', 'perform']","['optimizer', 'perform']"
Performance,"Documents/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/compute_hydrostatic_free_surface_tendencies.jl:236; [7] gpu_compute_hydrostatic_free_surface_Gu!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:90; [8] gpu_compute_hydrostatic_free_surface_Gu!; @ ./none:0; Hint: catch this exception as `err` and call `code_typed(err; interactive = true)` to introspect the erronous code with Cthulhu.jl; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/validation.jl:147; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:440 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/RsWnF/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:439 [inlined]; [5] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:89; [6] emit_llvm; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:83 [inlined]; [7] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:129; [8] codegen; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:110 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:106; [10] compile; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:98 [inlined]; [11] #45; @ ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:57 [inlined]; [12] JuliaContext(f::Metal.var""#45#46""{GPUCompiler.CompilerJob{",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:36336,optimiz,optimize,36336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822,1,['optimiz'],['optimize']
Performance,Does this reduce performance or is the effect negligible? (Just curious.),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261409044:17,perform,performance,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261409044,1,['perform'],['performance']
Performance,"Exactly what I am struggling with right now: figuring out how to quickly get x, y, z coordinates when loading an output file created previously (with JLD2 output writer}). So as far as I understand in that case the 'model' and 'grid' variables do not exist. ; `xc = file([""grid/xC""]) `; etc. works, but contains the halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-1022295367:102,load,loading,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-1022295367,1,['load'],['loading']
Performance,"Executing the validation/multi_region/cubed_sphere_steady_state.jl file yields an error partially shown below:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 41.133 ms, wall time: 0 seconds; [ Info: ... simulation initialization complete (820.774 ms); [ Info: Executing initial time step...; ERROR: LoadError: MethodError: no method matching _fill_south_halo!(::Int64, ::Int64, ::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, NamedTuple{(:ξ, :η, :rotation), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}, Rotations.RotXY{Float64}}}, CPU}, ::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ::BoundaryCondition{Oceananigans.BoundaryConditions.MultiRegionCommunication, Oceananigans.MultiRegion.CubedSphereRegionalConnectivity{Oceananigans.MultiRegion.South, Oceananigans.MultiRegion.North, Nothing}}, ::Tuple{Center, Center, Face}). Closest candidates are:; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::BoundaryCondition{<:Oceananigans.BoundaryConditions.Open}, ::Any, ::Any...); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/BoundaryConditions/fill_halo_regions_open.jl:36; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::BoundaryCondition{<:Oceananigans.BoundaryConditions.Flux}, ::Any...); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/BoundaryConditions/fill_halo_regions_flux.jl:32; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::Union{BoundaryCondition{<:Oceananigans.BoundaryConditions.Value}, BoundaryCondition{<:Oceananigans.BoundaryCondition",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742355619:409,Load,LoadError,409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742355619,1,['Load'],['LoadError']
Performance,"Float32, 3, 1}}}}, Nothing, NamedTuple{(:u, :v, :w, :T, :S), NTuple{5, typeof(Oceananigans.Forcings.zeroforcing)}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float32, Int64, Int64}}}}}, args::LLVM.Module); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/validation.jl:111; [2] macro expansion; @ /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/driver.jl:319 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/.julia/packages/TimerOutputs/PZq45/src/TimerOutput.jl:226 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/driver.jl:317 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/utils.jl:62; [6] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/mVgLI/src/compiler/execution.jl:313; [7] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/cache.jl:89; [8] cufunction(f::typeof(Cassette.overdub), tt::Type{Tuple{Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CUDA.CuDeviceArray{Float32, 3, 1}}, RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360:17236,cache,cache,17236,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360,1,['cache'],['cache']
Performance,"For better or for worse, Oceananigans currently does not store intermediate terms in the computation of a PDE's right hand side (with notable exceptions hydrostatic pressure and eddy diffusivities). In other words, a single, sometimes large kernel that evaluates the right hand side at each grid point `i, j, k` is compiled for each PDE in a user's model, and there's no way to pull out intermediate steps in that calculation to use elsewhere. It's important to note when considering optimization strategies that our computations are probably memory-limited, rather than compute-limited. In other words, we think the process of transferring data from global memory to local thread memory is a bottleneck for our computations (we can really only know this through profiling a particular application, however, since all models are different...) Storing intermediate components of the tendency terms would probably create more memory accesses overall (since rather than immediately using intermediate results for subsequent calculations, we would have to send them to global memory, and then back, to complete the evaluation of a tendency) --- and thus could slow down tendency evaluations that are performed 1-3 times per time-step. For example, our best idea for speeding up tendency evaluations is to better manage memory movement using GPU shared memory (unfortunately, we haven't had the time to explore such optimization strategies...). I think there may be other ways to optimize diagnostics calculations, however. # Fusing `ComputedField` kernels. One possibility to speed up diagnostics is to ""fuse"" kernels for different `ComputedField` diagnostics. The kernel for a `ComputedField` is. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/Fields/computed_field.jl#L112-L115. where `operand` is an `AbstractOperation`. But different `ComputedField`s may somehow depend on the same underlying data in memory. Thus if the kernels for differnet `ComputedField",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837:484,optimiz,optimization,484,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837,2,"['bottleneck', 'optimiz']","['bottleneck', 'optimization']"
Performance,"From a correctness and functionality stand point this PR should be ready to merge. I have some problems with performance though. It looks like with `--check-bounds=no` this PR has roughly the same wall time than main (slightly more if you have weno because of additional boundary weno schemes) but without it's 2 - 2.5X slower. (Exacerbated on the GPU). I guess it might be a matter of `@inbounds` having to be placed strategically, but I seem to miss it; @glwagner, @navidcy do you have any easy suggestion that I might have missed?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177948330:109,perform,performance,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177948330,1,['perform'],['performance']
Performance,"From the standpoint of `NonhydrostaticModel`, the only requirement (I think?) is a pressure solver that's valid on more grids. The `FourierTridiagonalPoissonSolver` combines FFTs with a tridiagonal solve in one direction to solve the Poisson equation. Thus, this method can be used if the grid is stretched in just one (1) direction. Right now, we only support grids that are stretched in `z`, the third direction / index. Presumably it's at most a matter of copy and paste and index permutation to support grids that are stretched in `x` (and regular in `y, z`) or stretched in `y` (and regular in `x, z`). Under the hood, the `FourierTridiagonalPoissonSolver` relies on the `BatchedTridiagonalSolver` to perform the tridiagonal solve:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/fourier_tridiagonal_poisson_solver.jl#L81-L82. The `BatchedTridiagonalSolver` launches a kernel over `xy` and performs a tridiagonal solve in `z`:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L79-L80. So the first task is to extend the tridiagonal solver to support integrals in `x` and `y`. . This could be straightforwardly supported by adding some kind of tag to indicate the ""tridiagonal direction"" (ie `:x`, `:y`, or `:z`), and copy-pasting the functionality for each case. It's a bit of code duplication but pretty straightforward... Alternatively we could introduce some kind of abstraction that permutes array dimensions. Then we just have one algorithm which assumes the tridiagonal index is `k`, and support `i` or `j` under the hood via an array wrapper that performs an index permutation. I'm leaning towards copy/paste because it's a little easier to understand and it's not that much code in this case...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1557689620:706,perform,perform,706,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1557689620,3,['perform'],"['perform', 'performs']"
Performance,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575:385,optimiz,optimize,385,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575,2,['optimiz'],['optimize']
Performance,"Given that there seems to be increasing interest in vertically-periodic simulations, we could revive #3080 (despite the caveats mentioned there, which mainly unknowns associated with the performance of potential future nonhydrostatic solvers for complex domains), since it's always possible to reverse course in the future and restore the separation (perhaps when the separation is restored, it can be done in a way that's compatible with vertically periodic domains).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782219409:187,perform,performance,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782219409,1,['perform'],['performance']
Performance,"Good idea, let's change the phrase but keep this issue open so that I remember to tackle the performance benchmarks",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3758#issuecomment-2327680150:93,perform,performance,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3758#issuecomment-2327680150,1,['perform'],['performance']
Performance,"Good news: shallow water tests pass!. Bad news: the halo tests now has 12 fails, of 600 in total. . ```; <div class=""JobLogOutputComponent"" style=""box-sizing: border-box; background: rgb(23, 23, 23); border-radius: 3px; min-height: 85px; color: white; font-size: 12px; padding: 0px 0px 15px; width: 1108px; font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Helvetica, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;""><div class=""JobLogOutputComponent__Body"" style=""box-sizing: border-box; font-family: SFMono-Regular, Monaco, Menlo, Consolas, &quot;Liberation Mono&quot;, Courier, monospace;"">; Oceananigans \| 818 12 830; --; &nbsp; | Distributed MPI Oceananigans \| 816 12 828; &nbsp; | Multi architectures rank connectivity \| 28 28; &nbsp; | Local grids for distributed models \| 24 24; &nbsp; | Injection of halo communication BCs \| 168 168; &nbsp; | Halo communication \| 588 12 600; &nbsp; | Time stepping IncompressibleModel \| 4 4; &nbsp; | Time stepping ShallowWaterModel \| 4 4; &nbsp; | Distributed FFT-based Poisson solver \| 2 2; &nbsp; | ERROR: ERROR: ERROR: ERROR: LoadError: LoadError: LoadError: LoadError: Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:1477,Load,LoadError,1477,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,4,['Load'],['LoadError']
Performance,"Good question @simone-silvestri !. On main it doesn't run as is. There are two issues. . First, there is `device!(2)` in line 30 but I commented that out easily. . Second, on line 159 we load `VorticityStencil`, which is not defined. I deleted that and changed the momentum_advection to `VectorInvariant()`, but it occurs to me that this is not what was done before. Before it was using a vorticity stencil. How would I change to use the other formulation?. However, when I try running this on main it goes far beyond what I see in the PR. So I guess the version on main does run and is stable. Pasat a day easy. Hmm... If we have a problem with the height going negative, I wonder if this is a sign that the conservation of mass equation is not quite right? I will look at that today.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1983382184:187,load,load,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1983382184,1,['load'],['load']
Performance,"Greg, Ali, and what if we began to consider more complex geometries etc -; hard to resist going in that direction..... we'd have to change the solvers; - more MITgcm-like, congrad etc - but what would the implications be for; boundary conditions? More food for thought. John. On Sat, Mar 28, 2020 at 10:22 AM Gregory L. Wagner <notifications@github.com>; wrote:. > Mostly I am worried about scalability and sustainability in this design,; > or future designs.; >; > Currently our models are fairly simple, but its challenging to place; > bounds on potential future complexity. For example, models in the future; > may require additional fields associated with closures or; > parameterizations, such as (two-dimensional) boundary layer depth fields,; > plume quantities, mixing lengths and perhaps other auxiliary fields; > associated with various prognostic / diagnostic LES models. We probably; > can't plan to support setting boundary conditions on every possible field; > via the model constructor.; >; > With our current design we have essentially special-cased turbulent; > diffusivities because our focus is LES, turbulent diffusivities are; > relatively common, and it convenient for us. However doing this incurs some; > maintenance burden --- which will increase if we plan to hard-code; > validation and error checking.; >; > Food for thought.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/721#issuecomment-605453798>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQT642WME2EIX3DDSITRJYBYXANCNFSM4LVSZPAA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605455060:391,scalab,scalability,391,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605455060,1,['scalab'],['scalability']
Performance,"Happy to open an issue (or post to #1634) when I have the time to work on CI. What should we do with this PR? I think it's a net positive change so I'm happy to approve as long as the images aren't in git history. If we decide to nuke this part of the docs then I suppose this PR is moot and should be closed. > _when_ / _if_ somebody can take responsibility for maintaining it. I think responsibility for maintaining the pipeline should fall on all maintainers/developers, otherwise it's not sustainable. Ideally if you open a PR that breaks a validation experiment you should fix it. If done concurrently it should only consist of small changes so it should only be a small burden (although burdens to add up). I guess we don't run the validation CI on every PR since it's too expensive so maintenance is tough right now. Maybe we can run validation CI before every tagged release or something? Better infrastructure is needed I suppose.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872481889:594,concurren,concurrently,594,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872481889,1,['concurren'],['concurrently']
Performance,"Hello, @amontoison. Nice work. Do you see a performance improvement when switching to this package?; There should be some benchmarks in the `benchmark` folder that we can test (probably we need to update that folder a bit, let me know if you have problems with it)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3778#issuecomment-2353126955:44,perform,performance,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3778#issuecomment-2353126955,1,['perform'],['performance']
Performance,"Here's a few options for optimizing AbstractOperations with `^`:. 1. Auto-convert exponents to `Int32`. For this we'd define. ```julia; Base.^(L::Tuple, a::AbstractField, b::Int64) = ^(L::Tuple, a, Int32(b)); ```. Basically implementing the approach CUDA previously took. For us it's a ""less egregious"" hack since, unlike CUDA.jl, we can ""almost surely"" guarantee that users won't exponentiate with integers larger than `2^31-1 = 2147483647`. Probably the easiest thing to do in the near term. This is a specific extension of the abstract operation defined via `@binary ^` (such that `op = ^`):. https://github.com/CliMA/Oceananigans.jl/blob/1756bc9380999f160f3d2b96f64bf76771614c60/src/AbstractOperations/binary_operations.jl#L100-L108. 2. Convert small-power exponents to literal multiplications. Like `Base.literal_pow`:. ```julia; Base.^(L::Tuple, a::AbstractField, b::Integer) = our_literal_pow(L, a, Val(b)). our_literal_pow(L, a, Val{0}) = one(eltype(a)); our_literal_pow(L, a, Val{1}) = a; our_literal_pow(L, a, Val{2}) = *(L, a, a) # binary operation; our_literal_pow(L, a, Val{3}) = *(L, a, a, a) # multiary operation; our_literal_pow(L, a, Val(b)) where b = _binary_operation(location(a), ^, a, b, location(a), location(a), a.grid) ; ```. etc. I guess 2 would instead happen under the hood when abstract operations are compiled, hopefully, in the best of worlds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1832#issuecomment-876812225:25,optimiz,optimizing,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1832#issuecomment-876812225,1,['optimiz'],['optimizing']
Performance,"Here's a summary of the current design:. I've introduced a new type called `ImmersedBoundaryCondition` to represent boundary conditions on immersed boundaries. The type has 6 fields for each direction, west, east, south, north, bottom, top. I believe this covers the general case in which we might have different fluxes on any face of a cell that's the boundary between a wet node and an immersed node. For example, we can implement ""bottom drag"" for large scale ocean models, with no ""side drag"". In practice this is really just a performance optimization rather than a physical model (the horizontal drag has no effect on the solution), but it's probably important that we can support it. This low-level, but fully general interface allow advanced users to specify any kind of immersed flux / boundary condition they need to. The next challenge is to design a convenient API that interprets user-input and builds `ImmersedBoundaryCondition` appropriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don'",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991:532,perform,performance,532,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991,4,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"Here's the julia docs on constants for reference:. https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Constants. This statement in the julia docs could maybe be clarified:. > It is difficult for the compiler to optimize code involving global variables, since their values (or even their types) might change at almost any time. because its ambiguous what ""code involving global variables"" is. For Oceananigans, this almost always means ""functions that capture global variables in their scope"". So `f(x) = a * x` is going to be slow unless `a` is `const`; otherwise `f(x)` cannot be inlined properly because the type of `a` is uncertain.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881696539:223,optimiz,optimize,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881696539,1,['optimiz'],['optimize']
Performance,"Here's where we're at.; I've made the following modifications to `baroclinic_adjustment.jl`. ```; using Oceananigans, AMDGPU; ```; and the grid construction now specifies GPU architecture with `GPU(AMDGPU.ROCBackend())`, ie,. ```; grid = RectilinearGrid(GPU(AMDGPU.ROCBackend());; size = (48, 48, 8),; x = (0, Lx),; y = (-Ly/2, Ly/2),; z = (-Lz, 0),; topology = (Periodic, Bounded, Bounded)); ```. When running this, we hit a runtime issue at `plan_forward_transform`. ```; $ julia --project=. baroclinic_adjustment.jl ; ERROR: LoadError: MethodError: no method matching plan_forward_transform(::ROCArray{ComplexF64, 3, AMDGPU.Runtime.Mem.HIPBuffer}, ::Periodic, ::Vector{Int64}, ::UInt32). Closest candidates are:; plan_forward_transform(::CUDA.CuArray, ::Union{Bounded, Periodic}, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/DPfYS/src/Solvers/plan_transforms.jl:36; plan_forward_transform(::Array, ::Periodic, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/DPfYS/src/Solvers/plan_transforms.jl:16; plan_forward_transform(::Union{CUDA.CuArray, Array}, ::Flat, ::Any...); @ Oceananigans ~/.julia/packages/Oceananigans/DPfYS/src/Solvers/plan_transforms.jl:47; ... Stacktrace:; [1] plan_transforms(grid::RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, GPU{ROCBackend}}, storage::ROCArray{ComplexF64, 3, AMDGPU.Runtime.Mem.HIPBuffer}, planner_flag::UInt32); @ Oceananigans.Solvers ~/.julia/packages/Oceananigans/DPfYS/src/Solvers/plan_transforms.jl:93; [2] Oceananigans.Solvers.FFTBasedPoissonSolver(grid::RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.Offset",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1946746065:528,Load,LoadError,528,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1946746065,1,['Load'],['LoadError']
Performance,"Hey @beta-effect!. Yes as of PR #282 (included in master, but not in v0.8.0), boundary conditions must be specified at `Model` creation time. This is part of an ongoing attempt at making the types we use in Oceananigans more concrete. If we use structs whose types are set once the struct is created (concrete types), then the compile can more easily optimize things as it knows the data type won't change. The default boundary conditions are given by `ModelBoundaryConditions()` where; ```julia; function ModelBoundaryConditions(;; u = DoublyPeriodicBCs(),; v = DoublyPeriodicBCs(),; w = DoublyPeriodicBCs(),; T = DoublyPeriodicBCs(),; S = DoublyPeriodicBCs(); ); return ModelBoundaryConditions(u, v, w, T, S); end; ```; so I think what you want instead is something like; ```julia; T_bc = FieldBoundaryConditions(; x = CoordinateBoundaryConditions(; BoundaryCondition(Periodic, nothing),; BoundaryCondition(Periodic, nothing)),; y = CoordinateBoundaryConditions(; BoundaryCondition(Periodic, nothing),; BoundaryCondition(Periodic, nothing)),; z = CoordinateBoundaryConditions(; BoundaryCondition(Flux, 0),; BoundaryCondition(Flux, bottom_flux))). bcs = ModelBoundaryConditions(; u = DoublyPeriodicBCs(),; v = DoublyPeriodicBCs(),; w = DoublyPeriodicBCs(),; T = T_bc,; S = DoublyPeriodicBCs()); ```. We still need to figure the API a little because this gets a little annoying: you need to compute `bottom_flux` before constructing the `Model` but it's nice to use `xC, yC, zC` to compute `bottom_flux` but we get them from `model.grid`... The easiest thing to do right now might be to just create the model again but with the new `bcs`:; ```julia; # Set up the model and use an artificially high viscosity ν and diffusivity κ.; model = Model(N=(Nx, Ny, Nz), L=(Lx, Ly, Lz), arch=GPU(),; ν=1e-4, κ=1e-4). # Get location of the cell centers in x, y, z and reshape them to easily; # broadcast over them when calculating hot_bubble_perturbation.; xC, yC, zC = model.grid.xC, model.grid.yC, model.grid.zC",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/314#issuecomment-515189875:351,optimiz,optimize,351,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/314#issuecomment-515189875,1,['optimiz'],['optimize']
Performance,"Hey thanks for doing all this! Things look a lot neater. Just have a few comments/thoughts that I'll pepper throughout but should be good to merge!. > A `Model` constructor is now provided in which all important information can be input via keyword arguments. This is great for understanding what the model does, I agree. Would still be nice to keep the ""legacy constructor"" around for when you just want to create a simple `Model` for playing around with or for testing. And it makes for very nice and simple example code. > I also reduced the computational burden of a few of the tests, and changed to factor of 2 resolutions since this makes sense for FFTs (though relatively unimportant for testing, I think should encourage users to use powers of 2 and make a habit of using them ourselves). I would argue against this. While we should try to use powers of 2 for performance, I think that overly restricts the model resolutions we can be running at. There are a LOT of choices between e.g. `512x512x128` and `1024x1024x128`. It might be that the largest model that fits in memory isn't nice powers of 2. Users may have various reasons for running resolutions that aren't powers of 2. Either way, we should always be testing a wide range of grid sizes (and weird grid sizes like `109x77x13`) because the code should work for all of them. If computational cost becomes an issue we should look into paying for extra CI resources rather than reduce testing. > A few more notes:. Might be good to create some new issues based on those just to keep track of what needs to be done. > The examples are outdated. We should probably reduce the number of examples until the code becomes more stable, and commit to maintaining the few that remain. This is something I'm actively working on in a different branch. I'll make sure they work with the changes in this pull request. > Lots of work to do!. For sure!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468525078:868,perform,performance,868,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468525078,1,['perform'],['performance']
Performance,"Hey, original author of both https://github.com/JuliaGeo/NetCDF.jl and https://github.com/meggart/ZarrNative.jl here. Regarding the state of NetCDF.jl , yes I would say I mostly stopped developing the package due to time constraints and currently shift my focus towards Zarr since this is what we are using in our current project. . My last attempt at improving the NetCDF solved many of the issues with the package https://github.com/JuliaGeo/NetCDF.jl/pull/61 but was not merged because of conflicts with other bugfix PRs. However, might be source of inspiration if someone wants to do a rewrite. . Regarding write performance, I would be very interested to see examples where NetCDF.jl performs worse than e.g. python-netcdf4, since most of the time should be spent in the same NetCDF C library. I have been using the package extensively and did not experience it to be slower than comparable packages. . I you are worried about the robustness of NetCDF.jl, you should not even look at ZarrNative.jl, since it is still very young and rather a prototype. . I would be very happy to discuss the issues further, maybe in a call? Would also be interested to learn about your project which seems to be very cool.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475680874:617,perform,performance,617,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475680874,2,['perform'],"['performance', 'performs']"
Performance,"Hi @roxyboy, we'll make some docs/examples soon! There are some tools in a different repo but they are rough on the edges at the moment and I'm bit reluctant to point you to it. If you have the `bathymetry` loaded as an array of the same size as a flat-bottom latitude-longitude grid then you can use [GridFittedBottom](https://clima.github.io/OceananigansDocumentation/stable/appendix/library/#Oceananigans.ImmersedBoundaries.GridFittedBottom) to do something like:. ```Julia; underlying_grid = LatitudeLongitudeGrid(arch,; size = (Nx, Ny, Nz),; longitude = (-180, 180),; latitude = (-75, 75),; z = (-depth, 0),; topology = (Periodic, Bounded, Bounded)). grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809223215:207,load,loaded,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809223215,1,['load'],['loaded']
Performance,"Hi, PencilArrays / PencilFFTs author here. I'd be happy to help solving this issue, and I'd also welcome any ideas that would help improve the PencilArrays interface and docs. I am not familiar with how you define your domain partition. However, from the point of view of PencilFFTs, there is one restriction, which is that the first dimension (`x`) must *not* be decomposed in physical space. This is because FFTs are first performed along this dimension (along which data is contiguous, as usual for Julia arrays). Also, to avoid potential issues, your eigenvalues should be `PencilArray` wrappers. For now, PencilArrays allows broadcasting together `PencilArray`s and regular `Array`s, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. So I'm thinking about changing the current behaviour in the future -- and improving documentation on this. Finally, when you write:. ```julia; xc = b = solver.storage[2]; ```. you probably mean `xc = solver.storage[3]` (or, equivalently, `last(solver.storage)`, as in [this example](https://jipolanco.github.io/PencilFFTs.jl/dev/generated/in-place/#Applying-plans)). `storage[2]` holds an intermediate state that has no ""physical"" meaning, since it has been overwritten by the end of a transform. I should clarify all this in the in-place transforms example... Feel free to ping me if things are unclear in the docs or if I can provide any other information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088:425,perform,performed,425,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088,2,['perform'],['performed']
Performance,"Hmmm - I am skeptical about that from a computer point of view? In an implicit algorithm and/or radiative transfer alg the next step often depends on the result of the previous steps. . As every CCE graduate student learns, computers take many tens of cycles to evaluate an operation like a an add or multiply. The operation is sequential and carried out in a multi-stage pipeline in the heart of a CPU (or GPU). So unless the compiler has something else for the processor to do, the processor will have to wait for one step to make it through the pipeline before the next step? . I think the normal way to do this is to have some inner horiz blocking that is flexible (and can be 1,1) and then iterate over levels with some intermediate stores? The horiz block can be some fraction of inner cache or GPU local proc shared mem. The math doesn't quite look at this way because it assumes that a+b and/or a*b etc.. happen ""instantaneously"". It does not take into account that the awnser from a*b might take; 5-10 clock cycles to pass through the CPU floating point unit. . I think that is fairly generally true? Functional style code in Julia should make it possible; to express this in a fairly clean way, but with flexibility to change blocking for different ; target arch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541363073:792,cache,cache,792,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541363073,1,['cache'],['cache']
Performance,Hmmm a lot of failures due to CUDA scalar `getindex` operations even though we explicitly set `CUDA.allowscalar(true)` in `runtests.jl`... We could take this opportunity to get rid of all scalar operations in the tests and just use `CUDA.@allowscalar` where it's needed. Maybe new CUDA scalar operations are hurting performance and that's why GPU CI has slowed down?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-816964002:316,perform,performance,316,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-816964002,1,['perform'],['performance']
Performance,"Huh --- on my GPU I was getting 2x speed up for `Float32`. I'll have to check that again. The slow down has to do with the abstractions I have introduced. 30% is a huge slow down for one function, indicative of a major problem --- probably a type inference issue? . I think that once this problem is solved the code may become faster because of the disambiguation this PR lends to the innermost kernels. This problem becomes catastrophic for the closures, which make heavy use of the abstraction. So solving this problem is imperative. We can restore the performance of the default closure by simply pasting the old operators into `constant_diffusivity_closures.jl`. However, I believe the issue with type inference is solvable. . Unfortunately, I'm in `Cthulhu` hell right now trying to figure it out... I'm wondering whether these problems will vanish once we eliminate branches from the inmost functions...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496902962:555,perform,performance,555,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496902962,1,['perform'],['performance']
Performance,"I add a bit of context here:. @Yixiao-Zhang is doing a non-hydrostatic simulation with an immersed boundary and he finds that the code crashes with the PCG solver. That is not necessarily connected with the PCG solver but it might be caused by simulation setup or other issues. Since the pressure solver used is experimental (from [this branch](https://github.com/CliMA/Oceananigans.jl/tree/glw-xk/divergence-free-immersed-velocity-field)), as a way to assess where the crashing comes from, I suggested using another method to see if the crash would also happen, which would validate or not the experimental pressure solver. @Yixiao-Zhang, optimizing GPU preconditioners is a quite difficult task as demonstrated by the preconditioners slowing down the simulation, and probably not a good use of time of trying to figure out a way to speed up these solvers that we are not sure we want to use. ; Since this simple attempt to have a simulation that runs (with another _correct_ solver) up to the crashing point does not work, I would suggest to just trying to use a (slightly non-correct) FFT pressure solver to see if the simulation still crashes.; If not, then we can assume the crashing occurs due to the PCG solver and try to catch the bug. ; This will probably be a better way to ""optimize"" the solver since we know that the PCG preconditioned with FFT is faster than these other methods.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2052606749:640,optimiz,optimizing,640,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2052606749,4,['optimiz'],"['optimize', 'optimizing']"
Performance,"I agree that I would expect it to saturate at higher than 16 if there were 48 cores, but clearly I'm wrong. Getting another benchmark would be a good idea. I'm happy to consider the numba + parallel idea since that would be good to test the architecture. This [mini-course](https://github.com/omlins/parallel-gpu-workshop-JuliaCon21) did give some threaded examples to solve the diffusion equation in 3D. I wonder if we might want to ask Ludovic if they have done any scalings for multi-threading?. I'm happy to discuss this with @hennyg888 on Monday and see what we come up with. Others are happy to join the discussion if they like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886074548:481,multi-thread,multi-threading,481,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886074548,2,['multi-thread'],['multi-threading']
Performance,"I agree with @navidcy's points. Of course, it doesn't even matter whether the tracer is initialized or not (referring to the comment in @navidcy's script). The main point is that you can ""re-initialize"" a state whenever you like. I'd also like to make the extra point that @navidcy's pattern is interpretable and readable. I'm not sure we would achieve the same if we hide such a feature inside the source code. Does @navidcy's suggestion work for you @tomchor ?. I also think it is preferred to use separate files for a situation like this (though it may not be necessary to save intermediate times in the spin-up at all --- so a second file might not be necessary). If the spin up is recorded, I think it's better to use a separate file for its data. If the spin up is expensive, the following performance optimization could be used (we can leverage the `velocities` kwarg to save a bit of allocation):. ```julia; # Spin up with no tracers; model = NonhydrostaticModel(; tracers=nothing, kwargs...); simulation = Simulation(model, ...) # etc; run!(simulation). # Run for real, re-using the old `velocities` fields but overwriting the old `model`; model = NonhydrostaticModel(; tracers=:c, velocities=model.velocities, kwargs...); simulation = Simulation(model, ...) # etc; ```. There is some additional memory allocation for tendencies in this case, however, so it may not work for simulations that push GPU memory. > (I'm not aware of any way to ""remove"" the old Simulation from the GPU memory, but if there is, then this downside can be negated.). This occurs automatically with garbage collection, provided that there's no reference to the old simulation in the name space. CUDA may have a way to manually call the garbage collector, after doing something like `model=nothing; simulation=nothing`. If you figure that out, it'd be nice to know. > It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work. I don't foll",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1605717680:796,perform,performance,796,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1605717680,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"I also had this issue, as new into GPU running, I was super confused about this error. It will be helpful if this issue is not fixable, to at least point out in the documentation. . I encountered this error by running a simulation based on the tutorial ([Langmuir turbulence](https://clima.github.io/OceananigansDocumentation/stable/generated/langmuir_turbulence/#Langmuir-turbulence-example)) in GPUs. Note that the print function prints the `maximum(abs, u), maximum(abs, v), maximum(abs, w)`:; ```; msg = @sprintf(""i: %04d, t: %s, Δt: %s, umax = (%.1e, %.1e, %.1e) ms⁻¹, wall time: %s\n"",; iteration(simulation),; prettytime(time(simulation)),; prettytime(simulation.Δt),; maximum(abs, u), maximum(abs, v), maximum(abs, w),; prettytime(simulation.run_wall_time)); ```; thus resulting in the error:; ```; LoadError: CUDA error: too many resources requested for launch; ```; For reference, the code works once the `maximum` functions are removed:; ```; msg = @sprintf(""i: %04d, t: %s, �~Tt: %s, wall time: %s\n"",; iteration(simulation),; prettytime(time(simulation)),; prettytime(simulation.�~Tt),; prettytime(simulation.run_wall_time)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1992106103:807,Load,LoadError,807,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1992106103,1,['Load'],['LoadError']
Performance,"I also want to drop another optimization that can be used here --- using a `Float32` grid with the preconditioner. This will speed things up a bit. Eg:. ```julia; using Oceananigans.Grids: with_number_type. reduced_precision_grid = with_number_type(Float32, underlying_grid). pressure_solver = ConjugateGradientPoissonSolver(grid;; preconditioner = fft_poisson_solver(reduced_precision_grid),; maxiter = 10; ); ```. I also suggest plotting the divergence to get a handle on how the solver is working. A well-converged solution seems to have isotropically-distributed divergence errors. With looser tolerances, the divergence may be concentrated around the bathymetry (and of course with the naive FFT solver it has a thin layer adjacent to the bathymetry). I also think it would be nice if setting `maxiter=0` had a similar effect as simply using the FFT-based preconditioner. It's not the case right now, I think because we do not apply the preconditioner to the pressure initially before doing the CG iteration. It might not work (I believe I experimented briefly with that to no avail).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2414308611:28,optimiz,optimization,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2414308611,2,['optimiz'],['optimization']
Performance,I am actually looking into implementing a multidimensional _sweep_ approach that will allow us to break the 2nd order limit. https://d-nb.info/1124132775/34; https://www.sciencedirect.com/science/article/pii/S0021999104002281. I ll see if it is too difficult or unfeasible in terms of performance,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164483965:285,perform,performance,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164483965,1,['perform'],['performance']
Performance,"I am happy to open a PR but when I try the line you suggested , unfortunately, there is still a problem. Some good news! This fixes it for the vector invariant formulation. However, when I try the conervative form it complains about not knowing `u`. See the start of the output below. ```; ERROR: LoadError: TaskFailedException. nested task error: type NamedTuple has no field u; Stacktrace:; [1] getproperty(x::NamedTuple{(:uh, :vh, :h), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152672984:297,Load,LoadError,297,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152672984,1,['Load'],['LoadError']
Performance,"I am happy with both names but do we need a distributed for each framework? I thought they were almost identical but don't remember the details. Francis; ________________________________; From: Ali Ramadhan ***@***.***>; Sent: Tuesday, March 23, 2021 10:34:09 AM; To: CliMA/Oceananigans.jl ***@***.***>; Cc: Francis Poulin ***@***.***>; Author ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] `MultiCPU` or `MPI_CPU` (#1502). True. I guess we don't have a separate architecture for multi-threaded. I agree that MPI_CPU or MPICPU would be more precise. What do you think of DistributedCPU and DistributedGPU?. -; You are receiving this because you authored the thread.; Reply to this email directly, view it on GitHub<https://github.com/CliMA/Oceananigans.jl/issues/1502#issuecomment-804952861>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/AB63PQIRKGMIJUKMEU5CYQTTFCRGDANCNFSM4ZUIJ5FQ>.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1502#issuecomment-804964762:484,multi-thread,multi-threaded,484,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1502#issuecomment-804964762,1,['multi-thread'],['multi-threaded']
Performance,"I am not certain what the `ignore-cache` flag does, I borrowed the module loading sequence. I am pretty it ignores previously loaded modules with the same or similar name.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2256247465:34,cache,cache,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2256247465,3,"['cache', 'load']","['cache', 'loaded', 'loading']"
Performance,"I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353966686:97,perform,performance,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353966686,1,['perform'],['performance']
Performance,I believe #1770 does the trick:. ```; [2021/06/25 18:04:55.066] INFO Writing Advection_schemes_relative_performance_(CPU).html...; Advection schemes relative performance (GPU); ┌───────────────┬────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Schemes │ slowdown │ memory │ allocs │; ├───────────────┼────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ CenteredFourthOrder │ 1.36629 │ 1.07711 │ 1.66944 │; │ GPU │ CenteredSecondOrder │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ UpwindBiasedFifthOrder │ 1.53522 │ 1.11266 │ 1.9781 │; │ GPU │ UpwindBiasedThirdOrder │ 1.31322 │ 1.03505 │ 1.30432 │; │ GPU │ WENO5 │ 1.84272 │ 1.1889 │ 2.64008 │. ```. would be good to get confirmation from someone.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868903480:158,perform,performance,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868903480,1,['perform'],['performance']
Performance,"I believe there's some issue with initialization. It doesn't help to rebuild the individual jobs, because the initialization only happens once and the results are cached are re-used within each build. I think somehow we have to start a new build with a new ID.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3580#issuecomment-2371783629:163,cache,cached,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3580#issuecomment-2371783629,1,['cache'],['cached']
Performance,"I changed `∂xᶠᵃᵃ` to use `Δxᶠᵃᵃ` and when I try and compute the `x` derivative of the free surface in the `x` momentum equation I get the following error. It seems to me like we need to generalize this function, and others, to work on immersed grids. I pressume this is what the other models do? Looks like the fix could be easy. ```; ERROR: LoadError: TaskFailedException. nested task error: MethodError: no method matching ∂xᶠᵃᵃ(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Bounded, Flat, RegularRectilinearGrid{Float64, Periodic, Bounded, Flat, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{typeof(bump)}}, ::typeof(Oceananigans.Models.ShallowWaterModels.gh2), ::Field{Center, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Flat, RegularRectilinearGrid{Float64, Periodic, Bounded, Flat, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{typeof(bump)}}, Float64, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, CoordinateBoundaryConditions{Nothing, Nothing}}}}, ::Float64); Closest candidates are:; ∂xᶠᵃᵃ(::Any, ::Any, ::Any, ::AbstractRectilinearGrid, ::F, ::Any...) where F<:Function at /home/fpoulin/software/Oceananigans.jl/src/Operators/derivative_operators.jl:16; ∂xᶠᵃᵃ(::Any, ::Any, ::Any, ::AbstractRectilinearGrid, ::Any) at /home/fpoulin/software/Oceananigans.jl/src/Operators/derivative_operators.jl:6; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-849719531:342,Load,LoadError,342,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-849719531,1,['Load'],['LoadError']
Performance,"I completely agree. I'd even go further and suggest a section for simulation tips in general, and then a subsection for GPU tips specifically. As an example, I noticed that defining as many things as `const` as possible helps with performance, even if I'm running on a CPU. It seems kinda obvious in hindsight, but it took me a few months to think of that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800468178:231,perform,performance,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800468178,1,['perform'],['performance']
Performance,"I copied one of the errors below. I remember seeing this error before but I'm not sure how it was resolved. Restarting the tests?. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 87 seconds (200 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7803/compiled/v1.6/Oceananigans/hU93i_V4y9F.ji"": No such file or directory;   | Stacktrace:; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343:305,Load,LoadError,305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343,2,['Load'],['LoadError']
Performance,"I d like to try to improve performance a bit first... Anyways, by next week I ll merge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1190872511:27,perform,performance,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1190872511,1,['perform'],['performance']
Performance,"I do hope that I found something useful but at the moment I am a bit confued as to what's going wrong. I'm going to copy the errors below so others can see this more easily. The error in the docs complains about `PlotUtils` failing to precompile. That doesn't seem related to shallow water so I am confused. The CPU test seems to be with `MPI`, but I didn't know we had any `MPI` tests that used shallow water that were being run. Docs:; ```; ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; --; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: Failed to precompile PlotUtils [995b91a9-d308-5afd-9ec6-746e21dbc043] to /storage7/buildkite-agent/.julia-2556/compiled/v1.5/PlotUtils/YveHG_R3lk8.ji.; &nbsp; | Stacktrace:; &nbsp; | [1] top-level scope at none:2; &nbsp; | [2] eval at ./boot.jl:347 [inlined]; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2556/packages/Plots/SjqWU/src/Plots.jl:20; &nbsp; | ERROR: LoadError: Failed to precompile Plots [91a5bcdd-55d7-5caf-9e0b-520d859cae80] to /storage7/buildkite-agent/.julia-2556/compiled/v1.5/Plots/ld3vC_R3lk8.ji.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-1/clima/oceananigans/docs/make.jl:6; &nbsp; | 🚨 Error: The command exited with status 1. ```. CPU test; ```; [8] test() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:72; --; &nbsp; | [9] top-level scope at none:1; &nbsp; | Union{},Union{},Tuple{},NamedTuple{(test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; ERROR: failed process: Process(`/storage7/buildkite-agent/.julia-2556/artifacts/2fcd463fb9498f362be9d1c4ef70a63c920b0e96/bin/mpiexec -np 4 /storage7/buildkite-agent/julia-1.5.4/bin/julia -O0 --color=yes -e 'using Pkg; Pkg.test()'`, ProcessExited(1)) [1]; &nbsp; | &nbsp;; &nbsp; | Stacktrace:; &nbsp; | [1] pipeline_error at ./process.jl:525 [inlined]",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-842643141:460,load,load,460,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-842643141,3,"['Load', 'load']","['LoadError', 'load']"
Performance,"I don't follow everything here but it looks like the simulation is being performed on a login node in the above screenshot. @Sumanshekhar17, your cluster may have a policy in place to stop (""kill"") jobs that run on a login node. To sort out script vs cluster issues I suggest running the script on a local machine (for example, your laptop) first. If it runs to completion, and also starts and runs on the cluster with `architecture=GPU()`, then we know the problem is due to cluster policy or some other cluster-specific setting, rather than a problem with your script or Oceananigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-756149003:73,perform,performed,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-756149003,1,['perform'],['performed']
Performance,"I don't know exactly what to do, so we'll need help. I've started with a post to the julia slack: https://julialang.slack.com/archives/C67910KEH/p1635909337281400. On the other hand, it may not be a huge issue if it only affects diagnostics that are evaluated fewer than 5 times. For long running simulations, our methods do eventually get cached? Do you have an example of a method that doesn't get cached after 5 evaluations?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958631268:340,cache,cached,340,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958631268,2,['cache'],['cached']
Performance,"I don't know if this helps to make the issue clearer, but I just re-ran the code for just ; ```; using Oceananigans ; ```; and it executed without error. I ran it again to see if it was just a fluke and I got the following error:; ```. The following have been reloaded with a version change:; 1) cuda/12.2.1 => cuda/11.8.0. [59837] signal (11.1): Segmentation fault; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; Allocations: 605144 (Pool: 604223; Big: 921); GC: 1; /var/spool/pbs/mom_priv/jobs/1741845.casper-pbs.SC: line 31: 59837 Segmentation fault (core dumped) julia --project testcode.jl /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/; ```; Could it be an issue with the computer loading Oceananigans.jl with a bunch of extra functions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2237133645:739,load,loading,739,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2237133645,2,['load'],['loading']
Performance,"I don't know. Increasing grid points to 4, there's still a problem with 6 threads. ```julia; (base) gregorywagner:Oceananigans.jl/ (main✗) $ JULIA_NUM_THREADS=6 julia --project race_condition_test.jl [19:56:49]; [ Info: Oceananigans will use 6 threads; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (79.416 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (6.660 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; (parent(simulation.model.velocities.u))[1, 1, :] = [1.9557581998545617, 1.9557581998545617, 1.956214574857873, 1.9553566305291932, 1.9553371609848056, 1.9553371609848056]; Test Failed at /Users/gregorywagner/Projects/test/Oceananigans.jl/race_condition_test.jl:17; Expression: (parent(simulation.model.velocities.u))[1, 1, 2] == (parent(simulation.model.velocities.u))[1, 1, 3]; Evaluated: 1.9557581998545617 == 1.956214574857873; ERROR: LoadError: There was an error during testing; in expression starting at /Users/gregorywagner/Projects/test/Oceananigans.jl/race_condition_test.jl:17; ```. and also with 4. But with 3,. ```julia; (base) gregorywagner:Oceananigans.jl/ (main✗) $ JULIA_NUM_THREADS=3 julia --project race_condition_test.jl [19:58:49]; [ Info: Oceananigans will use 3 threads; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (98.396 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (6.548 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; (parent(simulation.model.velocities.u))[1, 1, :] = [1.9543734841879783, 1.9543734841879783, 1.9543734841879783, 1.9560232965664703, 1.9567081251492398, 1.9567081251492398]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809#issuecomment-1308177839:988,Load,LoadError,988,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809#issuecomment-1308177839,1,['Load'],['LoadError']
Performance,"I found this issue [here](https://github.com/JuliaGPU/CUDA.jl/issues/84) that seems to discuss the problem that we had with this PR (or at least my limited understanding of the problem). I went through the steps and I think they fixed it as it worked for me. . @ali-ramadhan , do you know which norm failed on a `CuArray` or did they all fail?. ```; julia> using LinearAlgebra, CUDA. julia> x=cu([1.,2.]); 2-element CuArray{Float32,1}:; 1.0; 2.0. julia> norm(x); 2.236068f0. julia> norm(x,2); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/WV76E/src/host/indexing.jl:43; 2.236068f0. julia> norm(x,0); 2.0f0. julia> norm(x,1); 3.0f0. julia> norm(x,4); 2.030543f0. julia> norm(x,Inf); 2.0f0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1562#issuecomment-817778463:504,Perform,Performing,504,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1562#issuecomment-817778463,1,['Perform'],['Performing']
Performance,I got good results in the past on discretized PDE problems. The main bottleneck is to perform the sparse triangular solves at each iteration of the Krylov method (`ldiv!`) on GPU but I did some operators in `KrylovPreconditioners.jl` to reuse the analysis of the sparsity pattern as well as the buffers:; - https://github.com/JuliaSmoothOptimizers/KrylovPreconditioners.jl/blob/main/ext/CUDA/operators.jl#L82; - https://github.com/JuliaSmoothOptimizers/KrylovPreconditioners.jl/blob/main/ext/AMDGPU/operators.jl#L103; - https://github.com/JuliaSmoothOptimizers/KrylovPreconditioners.jl/blob/main/ext/oneAPI/operators.jl#L50. We can also apply the same strategy for the ILU(0) preconditioner provided by the GPU vendors.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3789#issuecomment-2374729281:69,bottleneck,bottleneck,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3789#issuecomment-2374729281,2,"['bottleneck', 'perform']","['bottleneck', 'perform']"
Performance,"I got it. ```julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 139 already precompiled. julia> grid = RectilinearGrid(size=1, x=(0, 1), topology=(Periodic, Flat, Flat)); 1×1×1 RectilinearGrid{Float64, Periodic, Flat, Flat} on CPU with 1×0×0 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Flat y; └── Flat z. julia> grid = ImmersedBoundaryGrid(grid, GridFittedBoundary(x -> true)); warning: /Users/gregorywagner/.julia/packages/KernelAbstractions/MAxUm/src/cpu.jl:118:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; 1×1×1 ImmersedBoundaryGrid{Float64, Periodic, Flat, Flat} on CPU with 1×0×0 halo:; ├── immersed_boundary: GridFittedBoundary{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Bool, 3, Array{Bool, 3}}, Bool, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}; ├── underlying_grid: 1×1×1 RectilinearGrid{Float64, Periodic, Flat, Flat} on CPU with 1×0×0 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Flat y; └── Flat z. julia> c = CenterField(grid); 1×1×1 Field{Center, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 1×1×1 ImmersedBoundaryGrid{Float64, Periodic, Flat, Flat} on CPU with 1×0×0 halo; ├── boundary conditions: ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3742#issuecomment-2314132900:578,optimiz,optimizer,578,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3742#issuecomment-2314132900,2,"['optimiz', 'perform']","['optimizer', 'perform']"
Performance,"I guess in our terminology ""saving"" is a bit more restricted than ""serializing"". When we ""save"" an object, we do it in a way that might be readable from Python or MATLAB (for example). This means that we only ""save"" common types like numbers, arrays, strings. Anything we output to NetCDF is ""saved"". When we ""serialize"" we might embed a Julia struct in a file. So when we serialize something we can only load it back from Julia. We can only serialize with JLD2.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2245#issuecomment-1039401633:405,load,load,405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2245#issuecomment-1039401633,1,['load'],['load']
Performance,"I have a start to this soon to be PR (I hope) but nothing working yet. . One issue that comes up is that `automatic_halo_sizing.jl` should not extend the halo if the topology is flat This is easy enough to set this up in principle, however, when I try telling it what `Flat` means using the following `using Oceananigans.Grids: Flat`, it fails. . How should I load `Flat` at this stage?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-803738292:360,load,load,360,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-803738292,1,['load'],['load']
Performance,"I have been running on the system Julia for these, I attempted to do my own install but I do not think I ended up doing much with it. I believe `gcc` is a dependency for the subsequent modules as for example when I run:; ```; module --force purge; module load ncarenv/23.10 ; module load ncarcompilers/1.0.0; ```; the last line returns ; ```; Lmod has detected the following error: These module(s) or; extension(s) exist but cannot be loaded as requested: ""ncarcompilers/1.0.0""; Try: ""module spider ncarcompilers/1.0.0"" to see how to load the module(s).; ```; which does not happen if I include `gcc`. I was also able to run my code without netcdf!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258913846:255,load,load,255,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258913846,4,['load'],"['load', 'loaded']"
Performance,"I have checked thoroughly _every_ function in the advection module for a `checkbounds()` call and couldn't produce any Bounds error. This is remaining a mystery to me because it seems that the whole advection module elides bounds checking. On the other hand, I found that `main` has the same problem, on the `near_global_quarter_degree.jl` experiment this is the wall time per 10 time steps; (with `--check-bounds=no`, without `--check-bounds=no`); main -> 2.7 / 3.6 s; this PR -> 3.3 / 4.4 s. so there is for sure a problem of performance (which I will try to solve) but it does not seem to be related to bounds checking as; `2.7 / 3.6 = 3.3 / 4.4 = 0.75`. It is a must to find out where these bounds checks are eating up 25% of our computational time (do you know an easy way to profile it?).; By the way @tomchor, is this also the ratio that you find in your simulations (maybe with the latest commit)? If yes, I ll give up trying to inbound and only try to speed up the advection.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186040507:528,perform,performance,528,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186040507,1,['perform'],['performance']
Performance,"I have moved the open fill to nominally be called within `fill_halo_regions!` as the new format (`fill_halo_regions!` and `fill_open_boundary_regions!` both having to be called separately) is confusing. I think a user would expect `fill_halo_regions!` to fill all of the halos. Instead `fill_halo_regions!` has a kwarg `fill_open_boundaries` which is nominally true, and I have set to `false` in the halo fill following the pressure correction. If we didn't do this we would also have needed to add loads of calls to `fill_open_boundary_regions!` in the hydrostatic model code, which would have confused matters.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2150059461:499,load,loads,499,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2150059461,1,['load'],['loads']
Performance,I have never tried benchmarking this. maybe the gain in performance is negligible. I guess it will depend on the number of particles and the size of the grid.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775560431:56,perform,performance,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775560431,1,['perform'],['performance']
Performance,"I have some validation scripts already that work on the CPU and indicate that the new closure is working. However, I can't make this work on the GPU. I keep getting this error:. ```; ERROR: LoadError: GPU compilation of MethodInstance for Oceananigans.TurbulenceClosures.gpu__compute_scale_invariant_smagorinsky_viscosity!(::KernelAbstractions.CompilerMetadata{…}, ::OffsetArrays.OffsetArray{…}, ::Field{…}, ::Field{…}, ::RectilinearGrid{…}, ::ScaleInvariantSmagorinsky{…}, ::Nothing, ::@NamedTuple{…}, ::@NamedTuple{}) failed; KernelError: passing and using non-bitstype argument. Argument 7 to your kernel function is of type ScaleInvariantSmagorinsky{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Oceananigans.TurbulenceClosures.DirectionalAveraging{Tuple{Int64, Int64}}, Float64, @NamedTuple{}, Integer}, which is not isbits:; .update_frequency is of type Integer which is not isbits.; ```. Reading up on the CUDA.jl docs I _think_ I understand where this error comes from (although I thought `update_frequency`, which is an `Integer`, should work, but it throws an error). Still couldn't figure out how to fix it in this case here. I assume it's not hard to fix though, so I was wondering if someone (I'm assuming @simone-silvestri or @glwagner) can please give me a hand or at least point me in the right direction?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2294992357:190,Load,LoadError,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2294992357,1,['Load'],['LoadError']
Performance,I haven't looked at performance / GPU compilation in detail. I do think there is a type inference issue somewhere in this PR now because the flow over hills experiment is 7-8x slower on my laptop even without any immersed boundary condition. This likely indicates a problem with type inference in the flux divergence function (might also prevent GPU compilation). So we'll have to solve that and also add tests for CPU + GPU...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100751806:20,perform,performance,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100751806,1,['perform'],['performance']
Performance,"I implemented a simple new validation test that runs a two-dimensional barotropic turbulence problem with `ExplicitFreeSurface`: https://github.com/CliMA/Oceananigans.jl/blob/ss/multi_region/validation/multi_region/multi_region_turbulence.jl. Here's some miscellaneous notes:. * `WENO5(vector_invariant=VelocityStencil())` is faster than `WENO5()`. Note that when we write ""WENO5(vector_invariant=stencil)"" we mean that we are using the vector invariant formulation of momentum with a WENO reconstruction for vorticity, using either ""velocity"" or ""vorticity"" in the WENO smoothness metric. The ""WENO, Vector Invariant"" scheme is probably faster because it has fewer WENO interpolations (just one per momentum component rather than 2).; * `WENO5(vector_invariant=VelocityStencil())` blows up with `MultiRegionGrid`. Some timings:. | Resolution | Grid | Advection scheme | Wall time for 1000 time steps |; | ------------- | ------------- | -- | -- |; | 128^2 | `RegularRectilinearGrid` | `WENO5()` | 3.9 s |; | 128^2 | `MultiRegionGrid` | `WENO5()` | 7.4 s |; | 128^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 2.8 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5()` | 14.3 s |; | 256^2 | `MultiRegionGrid ` | `WENO5()` | 18.9 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 10.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5()` | 56.3 s |; | 512^2 | `MultiRegionGrid ` | `WENO5()` | 62.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 40.3 s |. I propose that we. 1) Close the gap between multi-region and single-region performance?; 2) Understand why WENO vector invariant blows up on a multi region grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730:1635,perform,performance,1635,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730,2,['perform'],['performance']
Performance,I just noticed:. https://buildkite.com/clima/oceananigans/builds/11955#018909c3-4c60-4b9c-b4e2-c6260d8b2189/40-2662. ```; [ Info: shallow_water_Bickley_jet.jl example took 28.452 minutes to build.; ```. We should optimize that or make it run first!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3151#issuecomment-1613995023:213,optimiz,optimize,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3151#issuecomment-1613995023,1,['optimiz'],['optimize']
Performance,"I just pushed changes for the geostrophic adjustment case. The code seems alright, but it returns the following warning:. `warning: ~/.julia/packages/KernelAbstractions/GCOhX/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering`. Then it returns the following error:. <details>; <summary>Error output:</summary>. ```; ERROR: ERROR: LoadError: ERROR: LoadError: LoadError: ERROR: LoadError: MethodError: no method matching MethodError: no method matching MethodError: iterate(::SplitExplicitFreeSurface{Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, FullyConnected, Periodic, Bounded, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212:227,optimiz,optimizer,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212,6,"['Load', 'optimiz', 'perform']","['LoadError', 'optimizer', 'perform']"
Performance,"I just want to point out that this involves an extra memory fetch so it might affect performance, probably very negligibly and maybe the compiler is smart enough to elide the extra node call, but it is an extra operation nonetheless.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3074#issuecomment-1516299701:85,perform,performance,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3074#issuecomment-1516299701,1,['perform'],['performance']
Performance,"I looked at one of the errors and saw the message below. I think this means we need to restart the tests. ```; ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-8057/compiled/v1.6/Oceananigans/hU93i_xHskz.ji"": No such file or directory;  ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246:118,Load,LoadError,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246,2,['Load'],['LoadError']
Performance,"I mean, we can move the docs to the caltech cluster but I think they will slow down a lot. This is a bottleneck for us right now so I don't think we can afford to move them... Notice that the out of memory error doesn't occur when we are using the GPU. We only use the GPU for the one quick start example --- and for nothing else. If we want to ""solve"" this, we can just get rid of the quick start example and then return to the previous behavior where we set `CUDA_VISIBLE_DEVICES=-1` for the docs build. Another solution is to hide / prevent tartarus users from using GPU 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356553645:101,bottleneck,bottleneck,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356553645,1,['bottleneck'],['bottleneck']
Performance,"I noticed ""On the other hand, a Z-WENO formulation is *always* beneficial (also in case of a uniform mesh) with no major; decrease in performance."". Why don't we then change `zweno = true`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976013319:134,perform,performance,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976013319,1,['perform'],['performance']
Performance,I opened an issue about the `Int128`/`UInt128` segfault (https://github.com/JuliaGPU/CUDA.jl/issues/793) but will revisit this PR later to look into the performance regression.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809568648:153,perform,performance,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809568648,1,['perform'],['performance']
Performance,"I ran the `benchmark_incompressible_model.jl` script on the master branch (twice) and this branch (also twice), and ; actually see a tiny bit of a speedup, maybe only significant for larger CPU models though. Hard to say whether it's noise, it might be more due to other processes causing small variations in runtime. To me I don't think this PR slows down or speeds up the code, but it simplifies and improves the time stepping code so it should be merged. There's a few more memory allocations now (due to extra kernel launches) but this shouldn't affect performance. # System info. ```; Oceananigans v0.44.1; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23:17 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); GPU: TITAN V; ```. # Master branch; ```; Incompressible model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ Float32 │ 32 │ 5.399 ms │ 5.668 ms │ 5.758 ms │ 7.186 ms │ 242.42 KiB │ 1876 │; │ CPU │ Float32 │ 64 │ 36.710 ms │ 37.583 ms │ 37.974 ms │ 41.678 ms │ 242.42 KiB │ 1876 │; │ CPU │ Float32 │ 128 │ 312.780 ms │ 313.477 ms │ 313.622 ms │ 314.726 ms │ 242.42 KiB │ 1876 │; │ CPU │ Float32 │ 256 │ 2.802 s │ 2.819 s │ 2.819 s │ 2.836 s │ 242.42 KiB │ 1876 │; │ CPU │ Float64 │ 32 │ 5.828 ms │ 6.049 ms │ 6.157 ms │ 7.044 ms │ 293.44 KiB │ 1876 │; │ CPU │ Float64 │ 64 │ 43.084 ms │ 43.619 ms │ 43.650 ms │ 44.363 ms │ 293.44 KiB │ 1876 │; │ CPU │ Float64 │ 128 │ 365.051 ms │ 365.317 ms │ 365.475 ms │ 366.288 ms │ 293.44 KiB │ 1876 │; │ CPU │ Float64 │ 256 │ 3.602 s │ 3.653 s │ 3.653 s │ 3.703 s │ 293.44 KiB │ 1876 │; │ GPU │ Float32 │ 32 │ 2.797 ms │ 2.870 ms ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-736692263:557,perform,performance,557,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-736692263,1,['perform'],['performance']
Performance,"I ran the advection scheme benchmarks and comparing with some older Julia 1.5 results it definitely is slower on the GPU. WENO5 used to only be ~3x slower than CenteredSecondOrder, but now it's 26x slower. All other advection schemes are just as fast as they used to be. Not slow enough to be CUDA scalar operations so maybe the GPU compiler changed in some way that kernels calling/using WENO5 are compiling into suboptimal machine code?. @maleadt might have some ideas/suggestions but maybe we just have to profile and find the new bottleneck?. ---. ```; Advection schemes relative performance (GPU); ┌───────────────┬────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Schemes │ slowdown │ memory │ allocs │; ├───────────────┼────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ CenteredFourthOrder │ 1.38356 │ 1.05911 │ 1.60067 │; │ GPU │ CenteredSecondOrder │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ UpwindBiasedFifthOrder │ 1.53145 │ 1.0868 │ 1.88203 │; │ GPU │ UpwindBiasedThirdOrder │ 1.30611 │ 1.04135 │ 1.42012 │; │ GPU │ WENO5 │ 26.1429 │ 4.68526 │ 38.4468 │; └───────────────┴────────────────────────┴──────────┴─────────┴─────────┘; ```. Compare with: https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868093699:534,bottleneck,bottleneck,534,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868093699,2,"['bottleneck', 'perform']","['bottleneck', 'performance']"
Performance,"I ran the benchmark again with triply periodic but it's still much slower so the issue might be deeper than the logic in `topologically_conditional_interpolation.jl`. ```; Advection schemes relative performance (GPU); ┌───────────────┬────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Schemes │ slowdown │ memory │ allocs │; ├───────────────┼────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ CenteredFourthOrder │ 1.50326 │ 1.06836 │ 1.69674 │; │ GPU │ CenteredSecondOrder │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ UpwindBiasedFifthOrder │ 1.69787 │ 1.09472 │ 1.96539 │; │ GPU │ UpwindBiasedThirdOrder │ 1.39899 │ 1.05598 │ 1.57057 │; │ GPU │ WENO5 │ 33.2728 │ 5.21273 │ 43.9286 │; └───────────────┴────────────────────────┴──────────┴─────────┴─────────┘; ```. ```diff; diff --git a/benchmark/benchmark_advection_schemes.jl b/benchmark/benchmark_advection_schemes.jl; index 81b083e1..e6ba8cd6 100644; --- a/benchmark/benchmark_advection_schemes.jl; +++ b/benchmark/benchmark_advection_schemes.jl; @@ -7,7 +7,8 @@ using Benchmarks; # Benchmark function. function benchmark_advection_scheme(Arch, Scheme); - grid = RegularRectilinearGrid(size=(192, 192, 192), extent=(1, 1, 1)); + topo = (Periodic, Periodic, Periodic); + grid = RegularRectilinearGrid(topology=topo, size=(192, 192, 192), extent=(1, 1, 1)); model = IncompressibleModel(architecture=Arch(), grid=grid, advection=Scheme()); ; time_step!(model, 1) # warmup; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868122855:199,perform,performance,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868122855,1,['perform'],['performance']
Performance,"I removed `show_axis=false` and it still produces an error, see below. . ```; fpoulin@pop-os:~/Software/Oceananigans.jl/validation/barotropic_gyre$ julia visualize_barotropic_gyre.jl ; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fulls",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:203,LOAD,LOADER,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985,6,"['LOAD', 'load']","['LOADER', 'load']"
Performance,"I saw there's a problem with making the documentation, see below. This doesn't seem directly relelvant to what was changed here though?. ```. ERROR: LoadError: `makedocs` encountered an error. Terminating build; --;   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33;   | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);   | @ Documenter.Builder /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Builder.jl:255;   | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);   | @ Documenter.Utilities.Selectors /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Utilities/Selectors.jl:170;   | [4] #2;   | @ /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Documenter.jl:266 [inlined];   | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);   | @ Base.Filesystem ./file.jl:106;   | [6] #makedocs#1;   | @ /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Documenter.jl:265 [inlined];   | [7] top-level scope;   | @ ~/builds/tartarus-3/clima/oceananigans/docs/make.jl:154;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-3/clima/oceananigans/docs/make.jl:154;   | 🚨 Error: The command exited with status 1;   | user command error: exit status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119854495:149,Load,LoadError,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119854495,1,['Load'],['LoadError']
Performance,"I see that one of the errors is `UndefVarError: device_event not defined`, which I suppose means we need to load it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1913#issuecomment-890011382:108,load,load,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1913#issuecomment-890011382,1,['load'],['load']
Performance,"I see the error you got, its. ```julia; ERROR: LoadError: MethodError: no method matching AdvectiveForcing(::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, true}; w=-1); Closest candidates are:; AdvectiveForcing(::Any) at /Users/gregorywagner/Projects/dev/Oceananigans.jl/src/Forcings/advective_forcing.jl:40 got unsupported keyword argument ""w""; AdvectiveForcing(::Any, ::Any) at /Users/gregorywagner/Projects/dev/Oceananigans.jl/src/Forcings/advective_forcing.jl:40 got unsupported keyword argument ""w""; AdvectiveForcing(::Any, ::Any, ::Any) at /Users/gregorywagner/Projects/dev/Oceananigans.jl/src/Forcings/advective_forcing.jl:40 got unsupported keyword argument ""w""; ```. This error means that we do indeed have the name `AdvectiveForcing`, but that the function signature is wrong. The reason here is a bug in the source code (missing semicolon: https://github.com/CliMA/Oceananigans.jl/pull/2389/commits/b30ce7ab846c713663949c3bb6ee8d1e2ec740b0).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082002537:47,Load,LoadError,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082002537,1,['Load'],['LoadError']
Performance,"I share here a double drake experiment that makes full use of this PR ; #### Grid setup; - latitude longitude grid from 75 S to 75 N; - 1/3 of a degree in the horizontal (1080 points in longitude, 450 in latitude); - 150 exponentially stretched vertical levels for a 3km deep ocean; - double drake bathymetry (https://doi.org/10.1175/2009JCLI3197.1); #### Top BC: ; - temperature: restoring to reference profile (cosine shape); - salinity: prescribed latitudinally dependent surface flux; - zonal velocity: prescribed latitudinally dependent wind stress; #### Bottom BC:; - velocities: linear bottom drag with a drag coefficient of 0.003 ms⁻¹; #### Initial conditions; - zero velocities; - exponentially stratified temperature with SST equal to the reference temperature; - constant salinity; #### Model setup; - linear equation of state; - Richardson-based diffusivity for BL mixing ; - vertical background viscosity and diffusivity of 5e-4 and 3e-5, respectively; - vector invariant momentum advection with WENO for vorticity and divergence flux as well as vertical transport (no horizontal viscosity); - WENO for tracer advection (no horizontal diffusivity); - Split explicit free surface using an averaging shape function and a CFL of 0.7 (23 substeps per time step); #### Simulation setup; - time step of 10 minutes; - ran on 2 MPI processes with CUDA-aware MPI; - performs about 10 simulated years per day. On the left, there is the free surface evolution, on the right the surface vertical vorticity (evolved for 9 years). https://user-images.githubusercontent.com/33547697/219039209-e99ad100-2730-4805-bf57-c3b438f64537.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431366185:1370,perform,performs,1370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431366185,1,['perform'],['performs']
Performance,"I think @tomchor is hitting on the right solution: we should separate ""output for analysis"" from ""output for checkpointing"", if possible. Typically we need output for analysis more frequently than output for checkpointing, and we don't require things like the tendency fields for analysis. This motivates creating multiple output writers that are dedicated to their specific tasks. . On the possibility of a NetCDF checkpointer: the first checkpointer design that utilized `restore_from_checkpoint` attempted to serialize as much of a model's data structures as possible. This requirement prevented us from using NetCDF and motivated using JLD2 (there are a few other data formats that can serialize, but JLD2 is fast, simple, and HDF5 compatible, which means it can be loaded from python with `h5py`). However, we now support a simpler paradigm whereby the original run script needs to be modified with `run!(simulation, pickup=true)` in order to ""pick up"" a simulation from a checkpoint. With this simpler design we require only all the prognostic fields and tendencies (for AB2) in the checkpointer file and we could in principle support NetCDF. This has the downside that it would require us to maintain more code. If you do need to inspect, plot, or analyze data in JLD2 files, check out the [JLD2 documentation](https://juliaio.github.io/JLD2.jl/dev/).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924:770,load,loaded,770,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924,2,['load'],['loaded']
Performance,I think I'm happy with the finite volume operators in this PR. Happy to make changes based on feedback so we have versatile and flexible operators. In the next PR I will fully integrate them with the code and make sure they are correct and performant. It will also show if I missed any operators.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-546648773:240,perform,performant,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-546648773,1,['perform'],['performant']
Performance,"I think high performance at 25 km resolution will prove difficult also because we are effectively dividing our kernel size by 1/6 (unless we figure out how to coalesce kernels across panels). On a large GPU this will lead to performance degredation at 25 km resolution, because even a single-panel kernel covering the whole globe at 25 km barely saturates one GPU. Recovering that performance for multi-region simulations may be difficult, especially in the face of the added complexity of distribution across multiple GPUs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719393187:13,perform,performance,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719393187,3,['perform'],['performance']
Performance,"I think it's a plotting issue. We are filling up the immersed boundaries with NaN and, apparently, we cannot plot NaNs anymore? The error says:; ```julia; ERROR: LoadError: On worker 2:;   | Looking up a non-finite or NaN value in a colormap is undefined.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3836#issuecomment-2407601775:162,Load,LoadError,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3836#issuecomment-2407601775,1,['Load'],['LoadError']
Performance,"I think it's ok, the hydrostatic model tests are not the bottleneck",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2181#issuecomment-1021681357:57,bottleneck,bottleneck,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2181#issuecomment-1021681357,1,['bottleneck'],['bottleneck']
Performance,"I think it's probable that `DiscreteForcing` doesn't have the same performance issues. @ali-ramadhan put together a benchmark script for forcing functions a while ago I thought, but it might have disappeared (because it wasn't informative?) That might've been before we had `ContinuousForcing` though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875640465:67,perform,performance,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875640465,1,['perform'],['performance']
Performance,"I think our race condition test is passing after this without the need for a custom `mean!`, so I think this is good to go. It's probably important because there could be other bugs associated with bad interactions between operations on the CUDA default stream and broadcasting...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1803#issuecomment-873180797:12,race condition,race condition,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1803#issuecomment-873180797,1,['race condition'],['race condition']
Performance,"I think the `weno_interpolants.jl` file is the culprit, @tomchor and I saw the loss of performance specifically when using the WENO scheme. I'll test the other advection schemes in the meantime to make sure that it is indeed only a problem of WENO advection.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177983798:87,perform,performance,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177983798,1,['perform'],['performance']
Performance,"I think the double precision numbers are coming from Nx/Ny/Nz being turned into Int64 (even if I manually set them to be Int32) when the grid is constructed. ~~I can't work out exactly where the promotion is happening though.~~ This happens because `Nx` etc. are `::Int` type in the grid, so get promoted when the grid is made, if I change them to be like the floats and be `IT` instead then the promotion doesn't happen. When I try to make the model I get loads of other things converted to `Int64` though so still doesn't work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1729331099:457,load,loads,457,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1729331099,1,['load'],['loads']
Performance,"I think the right way forward is to implement something that works for all grids. Then we can implement the grid-specific versions --- which should be viewed as conveniences or optimizations rather than necessities --- as time allows. I think this is a better and more efficient approach then implementing convenience versions first, and figuring out the general version later. You might find that the convenience versions aren't really necessary because things are convenient enough...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1637681533:177,optimiz,optimizations,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1637681533,1,['optimiz'],['optimizations']
Performance,I think the way to go is to write a single kernel (3D or 2D with a loop in z). In this way you avoid the cost of multiple kernel launching. If you have a 3D kernel with non Local dependencies and you have to update nonlocal values (I don't Think it's the case) you have to make sure that there are no write race conditions,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147416320:307,race condition,race conditions,307,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147416320,1,['race condition'],['race conditions']
Performance,"I think there's still a use for `KernelComputedField`! It's more expensive to construct a calculation by nesting `ComputedField`s inside it. The difference is in the number of kernel launches: when expressing a calculation with a single kernel, the computation is computed with a single loop over all grid points. When expressing a calculation using intermediate `ComputedField`, then first we launch kernels to calculate the intermediate `ComputedField`s, and launch a final kernel to compute the quantity of interest. It can also be more memory intensive since the intermediate `ComputedField`s need to be stored. For some applications, the ""optimization"" of avoiding intermediate kernel launches / calculations may be unimportant (for example, if plenty of memory is available and computations are made very rarely). I think nesting `ComputedField`s is a nice solution that avoids having to hand-write kernels for those cases. But sometimes I do think that users want to optimize diagnostics calculations. There are also some other nice applications of `KernelComputedField`; for example I think it would be nice to make the LES eddy diffusivities into `KernelComputedField` (which are computed every tendency evaluation so performance is crucial), and perhaps some other auxiliary variables. I think it would be fun to try the compiler hack-around that I suggested in my comment above (defining multiple `identity` functions and using an internal counter to scroll through them during compilation). It's just a matter of finding the time to do it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600:644,optimiz,optimization,644,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600,3,"['optimiz', 'perform']","['optimization', 'optimize', 'performance']"
Performance,"I think these lines should be using `ξnode`, `ηnode`, and `rnode`:. https://github.com/CliMA/Oceananigans.jl/blob/7cbf013cb6bed2bd7cef0f4d8e5f04c078e50ee0/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L136-L142. I'll open a PR with a fix tomorrow. Should probably also add a test for particle advection on a lat-lon grid. ---. Some debug printing inside `advect_particle` with 1 particle:. ```; [ Info: Iteration 1...; [ Info: X=(1.0, -1.5, -10.0), I=(47, 109, 53); [ Info: (before) X⁺=(1.0, -1.5, -10.0); (iᴿ, jᴿ, kᴿ) = (101, 201, 61); (xᴸ, yᴸ, zᴸ) = (87813.63270401207, -217942.05622333512, -100.0); (xᴿ, yᴿ, zᴿ) = (136722.49142523398, -124538.3178419058, 0.0); (x⁺, y⁺, z⁺) = (175626.26540802413, -249075.1356838116, -10.0); [ Info: (after) X⁺=(175626.26540802413, -249075.1356838116, -10.0); [ Info: Iteration 2...; [ Info: X=(175626.26540802413, -249075.1356838116, -10.0), I=(39914880, -59303137, 53); ERROR: LoadError: BoundsError: attempt to access 109×208×68 OffsetArray(::Array{Float64, 3}, -3:105, -3:204, -3:64) with eltype Float64 with indices -3:105×-3:204×-3:64 at index [39914881, -59303136, 54]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852#issuecomment-2428098528:940,Load,LoadError,940,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852#issuecomment-2428098528,1,['Load'],['LoadError']
Performance,"I think this PR is finally ready to be merged, provided that tests pass. To make sure that `VerticalDirection` is working, I ran the equation of state benchmarks and they seem to match the benchmarks performed in https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594. If anything, benchmarks seem a bit better (probably different machine) and `RoquetEquationOfState` is surprisingly faster on the CPU (but might be a fluke). ```; Equation of state benchmarks; ┌───────────────┬───────────────────────┬───────────┬───────────┬───────────┬───────────┬─────────────┬────────┐; │ Architectures │ EquationsOfState │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼───────────────────────┼───────────┼───────────┼───────────┼───────────┼─────────────┼────────┤; │ CPU │ LinearEquationOfState │ 2.037 s │ 2.040 s │ 2.039 s │ 2.041 s │ 372.66 KiB │ 2090 │; │ CPU │ RoquetEquationOfState │ 1.759 s │ 1.761 s │ 1.761 s │ 1.763 s │ 373.77 KiB │ 2090 │; │ CPU │ TEOS10EquationOfState │ 2.270 s │ 2.401 s │ 2.378 s │ 2.464 s │ 372.53 KiB │ 2090 │; │ GPU │ LinearEquationOfState │ 10.058 ms │ 13.161 ms │ 12.856 ms │ 13.215 ms │ 1022.19 KiB │ 7154 │; │ GPU │ RoquetEquationOfState │ 10.688 ms │ 13.236 ms │ 12.991 ms │ 13.322 ms │ 1.00 MiB │ 7054 │; │ GPU │ TEOS10EquationOfState │ 10.204 ms │ 13.463 ms │ 13.145 ms │ 13.504 ms │ 1017.58 KiB │ 7154 │; └───────────────┴───────────────────────┴───────────┴───────────┴───────────┴───────────┴─────────────┴────────┘; ```. ```; Equation of state CPU -> GPU speedup; ┌───────────────────────┬─────────┬─────────┬─────────┐; │ EquationsOfState │ speedup │ memory │ allocs │; ├───────────────────────┼─────────┼─────────┼─────────┤; │ LinearEquationOfState │ 154.965 │ 2.74298 │ 3.42297 │; │ RoquetEquationOfState │ 133.062 │ 2.74052 │ 3.37512 │; │ TEOS10EquationOfState │ 178.317 │ 2.73152 │ 3.42297 │; └───────────────────────┴─────────┴─────────┴─────────┘; ```. ```; Equation of state relative performance (CPU); ┌───────────────┬",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800720099:200,perform,performed,200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800720099,1,['perform'],['performed']
Performance,"I think to preserve the work in this PR, we should add a `Float32` test which will fail if a spurious promotion undermines performance",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445215733:123,perform,performance,123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445215733,1,['perform'],['performance']
Performance,I think we are also hitting this problem https://github.com/JuliaParallel/MPI.jl/issues/715; because it looks like the MPIPreferences are correctly loaded at the ; ```julia; julia -O0 --project -e 'using Pkg; Pkg.instantiate()`; ```; but then it loads a completely different MPI in the ; ```julia; julia -O0 --project -e 'using Pkg; Pkg.test()`; ```; step,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3897#issuecomment-2459444337:148,load,loaded,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3897#issuecomment-2459444337,2,['load'],"['loaded', 'loads']"
Performance,"I think we should merge this now, since Oceananigans is barely useable at the moment, and then pick up getting the Enzyme tests passing in @jlk9's PR (which also needs to involve performance benchmarking to ensure we maintain performance)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3477#issuecomment-1948811417:179,perform,performance,179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3477#issuecomment-1948811417,2,['perform'],['performance']
Performance,"I think you need to load cuda before you _build_ Oceananigans. You might need to do this from the login node, eg something like. ```; module load cuda; julia --project -e 'using Pkg; Pkg.build(""Oceananigans"")'; ```. Is that right @ali-ramadhan ?. The issue is that the functions `plan_forward_transforms` for `CuArray`s are not being loaded:. https://github.com/CliMA/Oceananigans.jl/blob/52bfeb09e3562f639deb32b8807f32a88e3a1cfa/src/Solvers/plan_transforms.jl#L30-L33. Note that your script is a julia file, so you should append it with `.jl` so that it's named `model_gpu_waves.jl`. As a side comment, you should take care when initializing a model with zero Eulerian-mean flow --- despite that this is common in the literature, it is unlikely to be a physically relevant initial condition (because it rarely occurs in nature, and because it will excite large inertial oscillations in your simulation). Some perspective on this issue is provided by [observations reported by Jerry Smith (2006)](https://journals.ametsoc.org/view/journals/phoc/36/7/jpo2910.1.xml?tab_body=abstract-display) and [a preprint that I'm first author on](https://glwagner.github.io/assets/pdf/near-inertial-waves-turbulence-growth-swell-preprint.pdf).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767021509:20,load,load,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767021509,3,['load'],"['load', 'loaded']"
Performance,"I thought of another way to achieve this performance optimization without any source-code-specific feature. For a simulation without buoyancy, for example, this might work:. ```julia; # Construct the full model with all desired tracers; model = NonHydrostaticModel(; grid, tracers, ...). model_properties = []; for name in propertynames(model); if name == :tracers; push!(model_properties, nothing); else; push!(model_properties, getproperty(model, name)); end; end. # Build a ""spin-up"" model using the inner constructor for NonhydrostaticModel, with tracers=nothing; spin_up_model = NonhydrostaticModel(model_properties...); ```. I believe that `spin_up_model` will run without evolving tracers. If you require _some_ tracers (ie active tracers like buoyancy) then things are slightly more complicated. You have to replace `tracers=nothing` with the appropriate `NamedTuple`. Also, I think you need to ensure that the active tracers are ""first"" in the list of tracers when the full model is built. Something like. ```julia; # Construct the full model with all desired tracers; model = NonHydrostaticModel(; grid, tracers=(T, S, c1, c2, c3, c4), ...). active_tracers = (T = model.tracers.T, S = model.tracers.S); model_properties = []; for name in propertynames(model); if name == :tracers; push!(model_properties, active_tracers); else; push!(model_properties, getproperty(model, name)); end; end. # Build a ""spin-up"" model using the inner constructor for NonhydrostaticModel, with tracers=(; T, S); spin_up_model = NonhydrostaticModel(model_properties...); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1613481559:41,perform,performance,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1613481559,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"I tried it again and received a similar error, copied below. What I find strange is that it mentions worker 5 but I only asked for 4. . @ali-ramadhan , what did you do to run this file exactly?. ```; ERROR: LoadError: Worker 5 terminated.ProcessExitedException(2). ...and 3 more exception(s). Stacktrace:; [1] sync_end(::Channel{Any}) at ./task.jl:314; [2] macro expansion at ./task.jl:333 [inlined]; [3] _require_callback(::Base.PkgId) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Distributed/src/Distributed.jl:75; [4] #invokelatest#1 at ./essentials.jl:710 [inlined]; [5] invokelatest at ./essentials.jl:709 [inlined]; [6] require(::Base.PkgId) at ./loading.jl:931; [7] require(::Module, ::Symbol) at ./loading.jl:923; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/examples/mpi_shallow_water_turbulence.jl:6; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794288378:207,Load,LoadError,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-794288378,3,"['Load', 'load']","['LoadError', 'loading']"
Performance,"I tried it again with a fresh clone and still received an error. The details are copied below. However, `make_example.jl` does seem to be working so it's not all bad. Unfortunately, I'm not sure why this occurs. ```; ERROR: LoadError: `makedocs` encountered a doctest error. Terminating build; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] runner(#unused#::Type{Documenter.Builder.Doctest}, doc::Documenter.Documents.Document); @ Documenter.Builder ~/.julia/packages/Documenter/f5jts/src/Builder.jl:217; [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document); @ Documenter.Utilities.Selectors ~/.julia/packages/Documenter/f5jts/src/Utilities/Selectors.jl:170; [4] #2; @ ~/.julia/packages/Documenter/f5jts/src/Documenter.jl:249 [inlined]; [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String); @ Base.Filesystem ./file.jl:106; [6] #makedocs#1; @ ~/.julia/packages/Documenter/f5jts/src/Documenter.jl:248 [inlined]; [7] top-level scope; @ ~/software/Second_Oceananigans/Oceananigans.jl/docs/make.jl:160; in expression starting at /home/fpoulin/software/Second_Oceananigans/Oceananigans.jl/docs/make.jl:160; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1772#issuecomment-869017574:224,Load,LoadError,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1772#issuecomment-869017574,1,['Load'],['LoadError']
Performance,"I tried running the `ShallowWaterModel` example on a `GPU` and it failed because of how we compute the norm, see the error message below. @glwagner , I remember we talked about this but, sadly, I don't know if we had a solution. What would you recommend?. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] assertscalar(op::String); @ GPUArrays ~/.julia/packages/GPUArrays/8dzSJ/src/host/indexing.jl:53; [3] getindex(::CUDA.CuArray{Float64, 3}, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/8dzSJ/src/host/indexing.jl:86; [4] getindex; @ ./subarray.jl:276 [inlined]; [5] _getindex; @ ./abstractarray.jl:1214 [inlined]; [6] getindex; @ ./abstractarray.jl:1170 [inlined]; [7] iterate; @ ./abstractarray.jl:1096 [inlined]; [8] iterate; @ ./abstractarray.jl:1094 [inlined]; [9] generic_normInf(x::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); @ LinearAlgebra /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:465; [10] normInf; @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:556 [inlined]; [11] generic_norm2(x::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); @ LinearAlgebra /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:497; [12] norm2; @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:558 ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882647783:268,Load,LoadError,268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882647783,1,['Load'],['LoadError']
Performance,"I tried to follow the terminology in the regression test and sorry it was confusing. I used `truth` to refer to the data that is read from a file, done [here.](https://github.com/CliMA/Oceananigans.jl/blob/3676a718be1160f3ea70c3cce5dd21c5f06f144a/test/regression_tests/shallow_water_bickley_jet_regression.jl#L82) . I agree that only `v` fails but that means that `v` has larger differences compared to `u` and `h`. They all have differences. . I compared the initial data that we used in this regression test with the initial data read from the regression test. I saw that we had the 0th and 20th step saved. If there are differences at the beginning, then they are not solving exactly the same problem. In both we have that v is set to 0 and u and h are set to the Bickley jet with a random perturbation on `u`. The randomness will not be the same (unless we use a seed, which we don't, but we could) however the amplitude of the perturbations are different. This suggests to me that the initial conditions are not the same, and maybe the soruce of why the regression test fails. This is why I would like to know how the initial data was generated, using what script. I do suggest we regenerate it as that might solve a lot of the problems we are having with the regression tests. Do you want me to generate a script that load the inital data and compare it? You can see the results above. The fact that h has differences of `1e-7` is due to single precison, which means they are the same. However, u is different with errors much larger then `1e-7`, so the initial data is different. Unless there is something that I'm missing here?. I saw that the data files were dated June 1st 2022. For me it is stored at the following location. `/home/fpoulin/.julia/datadeps/regression_test_data/`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1446357883:1324,load,load,1324,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1446357883,1,['load'],['load']
Performance,"I was able to get things and I see that 35 files were changed so I suspect a merge happened. However now, when I try the example @glwagner suggested, the first line with `using` errors with the following. Maybe there is a problem with my merge?. ```; julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: LoadError: LoadError: LoadError: UndefVarError: NoImmersedBoundary not defined; Stacktrace:; [1] include(mod::Module, _path::String); @ Base ./Base.jl:386; [2] include(x::String); @ Oceananigans.Models.ShallowWaterModels ~/software/Oceananigans.jl/src/Models/ShallowWaterModels/ShallowWaterModels.jl:1; [3] top-level scope; @ ~/software/Oceananigans.jl/src/Models/ShallowWaterModels/ShallowWaterModels.jl:15; [4] include(mod::Module, _path::String); @ Base ./Base.jl:386; [5] include(x::String); @ Oceananigans.Models ~/software/Oceananigans.jl/src/Models/Models.jl:1; [6] top-level scope; @ ~/software/Oceananigans.jl/src/Models/Models.jl:20; [7] include(mod::Module, _path::String); @ Base ./Base.jl:386; [8] include(x::String); @ Oceananigans ~/software/Oceananigans.jl/src/Oceananigans.jl:1; [9] top-level scope; @ ~/software/Oceananigans.jl/src/Oceananigans.jl:179; [10] include; @ ./Base.jl:386 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:16; in expression starting at /home/fpoulin/software/Oceananigans.jl/src/Models/ShallowWaterModels/ShallowWaterModels.jl:1; in expression st",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-843316815:420,Load,LoadError,420,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-843316815,4,['Load'],['LoadError']
Performance,"I was thinking of doing some prototyping and benchmarking in a sandbox by building off the example in my PR https://github.com/vchuravy/GPUifyLoops.jl/pull/18. The PR contains an example that can be extended to rely on a `Grid` struct, multiple `FaceField`s and ` CellField`. So I'll prototype grids and fields that are `isbitstype` (you already helped by doing this for a grid in https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-467660181) and test to see if they work on the GPU with GPUifyLoops.jl. If they do work and performance isn't degraded then I'll rewrite the operators to use grid and field structs. You probably know how to do this better than me, but might be good if I rewrite the operators as they's still undocumented and do some _slightly convoluted_ stuff to avoid having to store intermediate calculations. Right now I'm focusing on system tests and benchmarks but once @christophernhill @jm-c and I get closer to implementing the variable _Δz_ grid #47 I will work on this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/115#issuecomment-470782067:547,perform,performance,547,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/115#issuecomment-470782067,1,['perform'],['performance']
Performance,"I was wondering if we can regrid in 3D simply by regridding in each dimension in serial. Eg first regrid in x, then, y, then z. It'll be a bit more computation, but we still have the option of future optimization...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2067#issuecomment-973673941:200,optimiz,optimization,200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2067#issuecomment-973673941,2,['optimiz'],['optimization']
Performance,"I would advocate again for moving both CUDA and AMDGPU support into package extensions (see https://github.com/CliMA/Oceananigans.jl/pull/3066 for an outdated start). Having the user install both AMDGPU and CUDA unconditionally is both space and time consuming, loading them both should be unnecessary on most systems and they may at times be incompatible with each other since both are developed independently from each other.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935362327:262,load,loading,262,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935362327,1,['load'],['loading']
Performance,I would like to suggest the following checklist moving forward. - [ ] Decide whether we like the structure of the script `new_rates_of_convergence.jl`. How can we might improve it?; - [ ] Find where the bottleneck is in Oceanangans to make things globally single precision.; - [ ] Adapt this approach to the other validation cases that currently exist.; - [ ] Make `UpwindFirstOrderBiased()` advection scheme.; - [ ] Make `CenteredSixthOrder()` advection scheme.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750476313:203,bottleneck,bottleneck,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750476313,1,['bottleneck'],['bottleneck']
Performance,"I wrote a simple test that I believe represents a similar case, in which the fields of the type in question are pointers. On my machine there does not seem to be any performance difference. ```julia; using Random, BenchmarkTools, Printf ; ; struct Dummy ; a::Array{Float64,2} ; b::Array{Float64,2} ; c::Array{Float64,2} ; end ; ; mutable struct MutableDummy ; a::Array{Float64,2} ; b::Array{Float64,2} ; c::Array{Float64,2} ; end ; ; Dummy(n) = Dummy(rand(n, n), rand(n, n), rand(n, n)) ; MutableDummy(n) = MutableDummy(rand(n, n), rand(n, n), rand(n, n)) ; ; function crunch_dummy(d, nloops) ; for i = 1:nloops ; @. d.a = d.b * d.c ; end ; nothing ; end ; ; nloops = 1000 ; n = 1024 ; d = Dummy(n) ; mutable_d = MutableDummy(n) ; ; # Compile ; crunch_dummy(d, 1) ; crunch_dummy(mutable_d, 1) ; ; @printf ""Dummy crunching numbers: "" ; @btime crunch_dummy(d, nloops) ; ; @printf ""Mutable dummy crunching numbers: "" ; @btime crunch_dummy(mutable_d, nloops) ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/42#issuecomment-462544959:166,perform,performance,166,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/42#issuecomment-462544959,1,['perform'],['performance']
Performance,"I'll close this for now as it's not clear what we can do to make it better, and `@inbounds` helps a lot. We can revisit if we find ourselves in dire need of more performance out of the forcing functions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/365#issuecomment-525333615:162,perform,performance,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/365#issuecomment-525333615,1,['perform'],['performance']
Performance,"I'll explain quickly what is happening to document it.; In this new PR I added a new way to check boundary stencils for advection so that the correct reconstruction method is always used. . This entails checking differently for `Face` reconstructions (where we have to ensure that `Center` locations are active) and vice versa for `Center` reconstructions where `Face` locations have to be active. The problem occurs when checking the last cell for `Center` reconstructions (on a `Periodic` direction); let's say the advection is centered order 4 so hypothetically it requires two halo points. ; We then need to ensure that the nodes at `N + 1` and `N + 2` are active. A `Face` node (i) is active if either centered cell (i) or (i+1) is active, which means that the check will be performed on cells `N+1`, `N+2` and `N+3` (one more than the required halo size = 2!). This is not a problem for a underlying grid where the `inactive_node` function can check out-of-bounds locations and will just return a `true`. On the other hand, it is a problem for an `ImmersedBoundary` where a conditional has to be evaluated against an AbstractArray. . My first solution was to increase by one the halo under the hood in the `ImmersedBoundaryGrid` constructor. This bug with `set!` demonstrated that this is probably not the best solution as this can have a lot of unwanted repercussions. The way I implemented it now is that, when performing the halo checking in the model constructor, if the grid is an `ImmersedBoundaryGrid`, the `required_halo` is incremented by one, and an appropriate warning message is displayed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171677971:780,perform,performed,780,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171677971,2,['perform'],"['performed', 'performing']"
Performance,"I'll wait till it's ready to review in detail, but my main high-level comment is that we need to ensure that, at the end of a time-step, both the prognostic state (horizontal velocities and tracers) and auxiliary state (pressure, vertical velocity, eddy diffusivities) are all consistent and available for output at the current model time. If we intertwine communication with the computation of the auxiliary state and tendencies, then we should _define_ the tendencies as part of the auxiliary state. This will change the semantics and logic of the time stepping loop. But I think it at least as rational as our previous organization of events. The main change is that tendencies will now be computed one ""extra"" time in a simulation (at the very last time-step, the tendencies are not needed if no further time-steps will be taken). In the vast majority of cases this extra cost is negligible because simulations run for hundreds or hundreds of thousands of time-steps. There is the slightly possibility of pessimizing the edge case of a simulation that takes one time step, which may be useful for parameter estimation. For that purpose we may want to avoid computing the ""extra"" tendency. I'm thinking though that we should save that additional optimization until we need it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2953#issuecomment-1452351616:1249,optimiz,optimization,1249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2953#issuecomment-1452351616,1,['optimiz'],['optimization']
Performance,"I'm getting this error when trying to run my code on multiple GPUs (it works fine on CPUs):. ```julia; ERROR: LoadError: BoundsError: attempt to access Tuple{Vector{CuStream}} at index [2]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base ./tuple.jl:29; [2] (::Oceananigans.Architectures.var""#3#6"")(); @ Oceananigans.Architectures /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Architectures.jl:26; [3] lock(f::Oceananigans.Architectures.var""#3#6"", l::ReentrantLock); @ Base ./lock.jl:185; [4] next_stream; @ /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Architectures.jl:24 [inlined]; [5] (::KernelAbstractions.Kernel{CUDAKernels.CUDADevice, KernelAbstractions.NDIteration.StaticSize{(1, 36)}, KernelAbstractions.NDIteration.StaticSize{(36, 1)}, typeof(Oceananigans.BoundaryConditions.gpu_fill_periodic_south_and_north_halo!)})(::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, ::Vararg{Any}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels /glade/work/tomasc/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:218; [6] launch!(::GPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, ::Tuple{Int64, Int64}, ::typeof(Oceananigans.BoundaryConditions.fill_periodic_south_and_north_halo!), ::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, ::Vararg{Any}; dependencies::CUDAKernels.CudaEvent, include_right_boundaries::Bool, reduced_dimensions::Tuple{Int64}, location::Nothing, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils /gl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310681185:110,Load,LoadError,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310681185,1,['Load'],['LoadError']
Performance,I'm not sure --- but it's possible that some GPU utilities not under Oceananigans.jl control incur memory allocations. I don't think we have much GPU-specific code in our codebase (except for pressure solvers...) Definitely a good thing to keep tabs on and open issues in the relevant packages if it affects the performance of our code.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-844319959:312,perform,performance,312,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-844319959,1,['perform'],['performance']
Performance,I'm not sure if we've tested but I've assumed there is a performance benefit to the simpler version for regularly spaced grids rather than using the binary search. It would probably be sensible to change the differentiation between the methods to just `fractional_index` though.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775532157:57,perform,performance,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775532157,2,['perform'],['performance']
Performance,"I'm seeing some significant slow down with the boundary condition. ```julia; # Monin-Obukhov drag coefficient; z₀ = 1e-4 # Charnock roughness; κ = 0.4 # Von Karman constant; Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2. @inline bottom_drag_u(x, y, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2); @inline bottom_drag_u(x, y, z, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, z, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2). Δz = 1 / Nz; Δx = 2π / Nz; u_drag_bc = FluxBoundaryCondition(bottom_drag_u, field_dependencies=(:u, :w), parameters=Cᴰ(Δz)); w_drag_bc = FluxBoundaryCondition(bottom_drag_w, field_dependencies=(:u, :w), parameters=Cᴰ(Δx)); u_bcs = FieldBoundaryConditions(bottom=u_drag_bc, immersed=u_drag_bc); w_bcs = FieldBoundaryConditions(immersed=w_drag_bc); ```. This is the basic way to implement a quadratic drag from the interface in this PR. In this case what happens under the hood is that we create 4 `ContinuousBoundaryFunction` for the relevant faces of boundary-adjacent cells (the other 2 faces are normal to the given velocity component, so receive a no-penetration boundary condition). So there could be a type instability compiling all of those (which have been notoriously fickle to compile in the past). We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. It's too much for this PR though, so I think we should just document how to specify no-slip on immersed boundaries (which appears to be performant), and add a few tests. Then in a future PR we can add a `QuadraticDrag` utility (I have a prototype for this object; others are welcome to collaborate on implementing the necessary functions to support it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081:1767,perform,performant,1767,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081,2,['perform'],['performant']
Performance,"I'm sorry, I misinterpreted the results @ali-ramadhan posted. I thought that `CenteredSecondOrder` was 1.0x slower with julia 1.6 than with 1.5 (and that small slowdowns were observed for the other schemes, which is why I recommended testing the biharmonic scheme.) Now I understand that these results are all for julia 1.6; we are comparing the results with previously obtained benchmarks (not posted) for julia 1.5. Looking at @tomchor and @ali-ramadhan's results then it looks like simulations with WENO5 are running approximately 6-8 times slower on julia 1.6 than it was on julia 1.5, while other advection schemes (and closures) are unchanged --- correct?. Is the _CPU_ performance of WENO5 roughly equivalent between julia 1.5 and julia 1.6?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868677634:676,perform,performance,676,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868677634,1,['perform'],['performance']
Performance,"I'm trying to run the near global shallow water model and having difficulties with the latitude longitude grid. The line that calls it is here. https://github.com/CliMA/Oceananigans.jl/blob/5ba82e5786d1b7725d6bfa3e45072d2f6fad487a/validation/shallow_water_model/near_global_shallow_water_quarter_degree.jl#L95. And the error that I get is the following,. ```; julia> include(""near_global_shallow_water_quarter_degree.jl""); ┌ Warning: Over-writing registration of the datadep; │ name = ""quarter_degree_near_global_lat_lon""; └ @ DataDeps ~/.julia/packages/DataDeps/Y2lje/src/registration.jl:15; ERROR: LoadError: UndefVarError: `Nλ` not defined; Stacktrace:; [1] validate_lat_lon_grid_args(topology::Tuple{…}, size::Tuple{…}, halo::Tuple{…}, FT::Type, latitude::Tuple{…}, longitude::Tuple{…}, z::Nothing, precompute_metrics::Bool); @ Oceananigans.Grids ~/Software/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:257; [2] LatitudeLongitudeGrid(architecture::GPU, FT::DataType; size::Tuple{…}, longitude::Tuple{…}, latitude::Tuple{…}, z::Nothing, radius::Float64, topology::Tuple{…}, precompute_metrics::Bool, halo::Tuple{…}); @ Oceananigans.Grids ~/Software/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:189; [3] macro expansion; @ show.jl:1181 [inlined]; [4] top-level scope; @ ~/Software/Oceananigans.jl/validation/shallow_water_model/near_global_shallow_water_quarter_degree.jl:95; [5] include(fname::String); @ Base.MainInclude ./client.jl:489; [6] top-level scope; @ REPL[70]:1; [7] top-level scope; @ ~/.julia/packages/CUDA/nbRJk/src/initialization.jl:205; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/shallow_water_model/near_global_shallow_water_quarter_degree.jl:95; Some type information was truncated. Use `show(err)` to see complete types.; ```. Should the lat-lon grid be able to handle flat in the vertical? @simone-silvestri, maybe this is something you tried to fix the last time we chatted?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1972247275:600,Load,LoadError,600,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1972247275,1,['Load'],['LoadError']
Performance,"I'm trying to time the performance of this branch but I'm getting a out-of-bounds error when running my simulations on GPUs (haven't tried them on CPUs). I can reproduce it using the MWE below and I'm pretty sure it's related to the stretched grid:. ```julia; using Oceananigans.Units; using CUDA; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. if has_cuda_gpu(); arch = GPU(); else; arch = CPU(); end. grid_base = RectilinearGrid(arch,; size=(4, 4, 4),; x=(0, 1), y=(0,1),; z=0:0.25:1,; halo=(3,3,3),; ). bathymetry(x, y) = grid_base.Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). model = NonhydrostaticModel(grid = grid,; advection = WENO5(grid_base),; ). using Oceanostics: TimedProgressMessenger; simulation = Simulation(model, Δt=1,; stop_iteration=10,; ); run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1162289700:23,perform,performance,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1162289700,1,['perform'],['performance']
Performance,"I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors. There's a few other things that are required to get things working on GPUs --- for example, Oceananigans must be _built_ (not just run) with a GPU / CUDA installation available; this is a common pitfall on clusters.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818076711:114,perform,performance,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818076711,2,"['optimiz', 'perform']","['optimizations', 'performance']"
Performance,"I've already made sure the forcing function doesn't reference anything outside the function (reduces clarity unfortunately) and pasted the benchmarks using the script from PR #370 at the bottom. Did not try changing the function signature to `FT(grid, u, v, w, T, S, i, j, k)` as that would make implementing #25 more difficult. Also, I was kind of lazy. Adding `@inbounds` seems to help a lot. Went from being 2.1x slower to being 1.3x slower. Still a significant slowdown considering that these forcing functions aren't as computationally demanding as the rest of the right-hand-side calculation. But good enough for me right now. It can be a very powerful feature (essentially replacing the MITgcm RBCS package, for one example) so would be good to get maximum performance out of the forcing functions. But it will probably always depend on exactly how you write them. So might make sense to have guidelines on writing ""performant forcing functions"" in the documentation. ---; Attempt 1:; ```julia; @inline function Fu(grid, U, Φ, i, j, k); if k == 1; return -2*0.1/grid.Δz^2 * (U.u[i, j, 1] - 0); elseif k == grid.Nz; return -2*0.1/grid.Δz^2 * (U.u[i, j, grid.Nz] - 0); else; return 0; end; end. @inline FT(grid, U, Φ, i, j, k) = ifelse(k == 1, -1e-4 * (Φ.T[i, j, 1] - 0), 0); ```; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Forcing function benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 59.9s / 0.41% 7.38GiB / 0.36% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 128×128×128 with forcing (GPU, Float64) 10 166ms 68.2% 16.6ms 13.8MiB 51.2% 1.38MiB; 128×128×128 no forcing (GPU, Float64) 10 77.4ms 31.8% 7.74ms 13.1MiB 48.8% 1.31MiB; ──────────────────────────────────────────────────────────────────────────────────────────────────; ```; ---; Attempt 2:; ```julia. @inline function Fu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/365#issuecomment-525326208:764,perform,performance,764,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/365#issuecomment-525326208,2,['perform'],"['performance', 'performant']"
Performance,"I've gotten the transforms taken care of, but now the baroclinic_adjustment example fails with ; ```; $ julia --project=. baroclinic_adjustment.jl ; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; [3] getindex; @ ~/.julia/packages/GPUArrays/dAUOE/src/host/indexing.jl:48 [inlined]; [4] scalar_getindex(::ROCArray{Float64, 3, AMDGPU.Runtime.Mem.HIPBuffer}, ::Int64, ::Vararg{Int64}); @ GPUArrays ~/.julia/packages/GPUArrays/dAUOE/src/host/indexing.jl:34; [5] _getindex; @ ~/.julia/packages/GPUArrays/dAUOE/src/host/indexing.jl:17 [inlined]; [6] getindex; @ ~/.julia/packages/GPUArrays/dAUOE/src/host/indexing.jl:15 [inlined]; [7] getindex; @ ./subarray.jl:288 [inlined]; [8] macro expansion; @ ./multidimensional.jl:917 [inlined]; [9] macro expansion; @ ./cartesian.jl:64 [inlined]; [10] macro expansion; @ ./multidimensional.jl:912 [inlined]; [11] _unsafe_getindex!; @ ./multidimensional.jl:925 [inlined]; [12] _unsafe_getindex(::IndexCartesian, ::SubArray{Float64, 3, ROCArray{Float64, 3, AMDGPU.Runtime.Mem.HIPBuffer}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, ::Int64, ::Base.Slice{Base.OneTo{Int64}}, ::Base.Slice{Base.OneTo{Int64}}); @ Base ./multidimensional.jl:903; [13] _getindex; @ ./multidimensional.jl:889 [inlined]; [14] getindex(::SubArray{Float64, 3, ROCArray{Float64, 3, AMDGPU.Runtime.Mem.HIPBuffer}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, ::Int64, ::Function, ::Function); @ Base ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1947171608:156,Load,LoadError,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1947171608,1,['Load'],['LoadError']
Performance,"I've ran several different simulations with this branch and a majority (but curiously not all of them) failed with the following error:. `ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`. An older version of this branch doesn't show this error and instead runs fine for all simulations. I couldn't figure out what happened yet (or why some runs failed but others didn't) so I couldn't create a MWE yet, but I thought I'd report this in case someone can understand this better than me. Here's a [more complete error log](https://pastebin.com/dCbBAgKp) (although it's only about 5% of the full log since the last few lines repeat many many times).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179751296:145,Load,LoadError,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179751296,1,['Load'],['LoadError']
Performance,"I've retried the tests a couple of times but I keep getting errors like this:. ```; Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/data5/glwagner/.julia-16001/compiled/v1.10/Oceananigans/jl_Bzx0zi"".; ERROR: LoadError: SystemError: opening file ""/data5/glwagner/.julia-16001/packages/CUDA_Runtime_jll/dOYZJ/.pkg/platform_augmentation.jl"": No such file or directory; ```. Is something wrong with the servers at the moment?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3623#issuecomment-2179086381:238,Load,LoadError,238,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3623#issuecomment-2179086381,1,['Load'],['LoadError']
Performance,"I've tried using the forcing as:. ```julia; @inline sponge_func(x, y, z, ϕ) = -rate * bot_mask(x, y, z) * (ϕ - 0); sponge_u(x, y, z, t, u) = sponge_func(x, y, z, u); sponge_v(x, y, z, t, v) = sponge_func(x, y, z, v); sponge_w(x, y, z, t, w) = sponge_func(x, y, z, w). forc_u = Forcing(sponge_u, field_dependencies=:u,); forc_v = Forcing(sponge_v, field_dependencies=:v,); forc_w = Forcing(sponge_w, field_dependencies=:w,); forcing = (u=forc_u, v=forc_v, w=forc_w); ```; and the same performance issues appear. But I guess this still uses `ContinuousForcing`. I've never used `DiscreteForcing` but I'll try to use it and see what happens. If you have any examples that would help.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875651677:484,perform,performance,484,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875651677,1,['perform'],['performance']
Performance,"Ideally you don't want `CUDA.@allowscalar` in front of `estimate_growth_rate` but rather you wanna go and modify `estimate_growth_rate` to ensure that you only put `CUDA.@allowscalar` in places that does not affect performance. Scalar operations on the GPU could diminish _all_ the speedup you get from the GPU, so `CUDA.@allowscalar` must be used with great caution!! There is a relevant discussion [in the docs](https://clima.github.io/OceananigansDocumentation/stable/simulation_tips/). (I'll convert this Issue into a Discussion btw.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2029361635:215,perform,performance,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2029361635,1,['perform'],['performance']
Performance,"If you didn't define new advection schemes but use the implemented ones they automatically lower the order near the boundaries. The implementation is in `topologically_conditional_interpolation.jl`. If you did not define new `symmetric_left_biased_interpolation_xᶠᵃᵃ` functions you should be ok. ; Otherwise you have to add your methods in the above mentioned file. If you are using an immersed boundary, the limiting is performed in the `conditional_fluxes.jl` file in the ImmersedBoundaries module. You can always use high order and fill more halos but then you are making an assumption on the field which you are trying to evolve",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182333702:421,perform,performed,421,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182333702,1,['perform'],['performed']
Performance,"If you want to adopt this PR, that would be great. I would leave the boundary conditions outside the operator for the moment, then we can look at the influence of those in performance in another PR. To test the performance we should push PR #3596 that implements split explicit with fill halos at every substep. Using that implementation for split-explicit will make boundary conditions for barotropic variables quite trivial to implement, but probably extremely slow. However, we can use it as a benchmark",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353152298:172,perform,performance,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353152298,2,['perform'],['performance']
Performance,If you want to give an example of an expensive forcing function it could be instructive to discuss the options for performance optimization! Perhaps there will be some unexpectedly useful tips. A discussion might be a better place for that though.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2035251797:115,perform,performance,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2035251797,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"In addition to the bounded-x error above, interpolation methods also appear to be failing at times:. ```julia; using Oceananigans. grid_base = RectilinearGrid(size=(4, 4, 4), extent = (1,1,1)); grid = MultiRegionGrid(grid_base, partition = XPartition(2), devices = 2); @info grid. model = NonhydrostaticModel(grid = grid); @info """" model. u, v, w = model.velocities. ω_x = Field((@at (Center, Face, Face) ∂y(w)-∂z(v))); ```. This throws me the following error:. ```; ERROR: LoadError: MethodError: no method matching interpolate_index(::Tuple{Colon, Colon, Colon}, ::Colon, ::Type{Center}, ::Type{Center}); Closest candidates are:; interpolate_index(::UnitRange, ::Colon, ::Any, ::Any) at ~/.julia/packages/Oceananigans/F1fni/src/AbstractOperations/at.jl:80; interpolate_index(::Colon, ::Colon, ::Any...) at ~/.julia/packages/Oceananigans/F1fni/src/AbstractOperations/at.jl:77; interpolate_index(::Colon, ::UnitRange, ::Any...) at ~/.julia/packages/Oceananigans/F1fni/src/AbstractOperations/at.jl:78; ...; Stacktrace:; [1] interpolate_indices(::Oceananigans.AbstractOperations.Derivative{Center, Face, Face, typeof(Oceananigans.Operators.∂yᶜᶠᶠ), Field{Center, Center, Face, Nothing, MultiRegionGrid{Float64, Periodic, Periodic, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, St",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1303864523:474,Load,LoadError,474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1303864523,1,['Load'],['LoadError']
Performance,"In discussion with Tim I decided against it. I tried implementing it on the CPU, but that's basically why I required events everywhere. See https://github.com/JuliaGPU/KernelAbstractions.jl/blob/main/examples/mpi.jl, but Tim and I are bullish on using Julia's native concurrency mechanism, to express what streams normally do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1464051102:267,concurren,concurrency,267,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1464051102,1,['concurren'],['concurrency']
Performance,"In fact, the entire construction process could be simplified with the rules:. 1) If a location is shared, perform the operation there, and interpolate afterwards; 2) If a location is not shared, perform the operation at the final location. Currently rule 1) is enforced only if _all_ locations are shared (eg for tracer-tracer operations, or operations of fields with themselves).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/959#issuecomment-694942449:106,perform,perform,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/959#issuecomment-694942449,2,['perform'],['perform']
Performance,"In hindsight I think that @christophernhill is probably right about; pipeline stalls becoming a bottleneck if we use z as the fast index. (Which; leaves me unsure why it's common in the atmospheric models I've used....; Maybe just prioritizing simplicity over performance?). On Sat, Oct 12, 2019, 5:33 PM Chris Hill <notifications@github.com> wrote:. > P.S. that was a comment on the @ali-ramadhan; > <https://github.com/ali-ramadhan> comment, not the @glwagner; > <https://github.com/glwagner> comment. Greg is correct that some code; > generation can help, although sometimes its cleaner just to write elegant; > code than get carried away with meta-programming ( e.g. see Steve J; > meta-programming regrets talk https://www.youtube.com/watch?v=mSgXWpvQEHE; > ).; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/470?email_source=notifications&email_token=ACZDSTS5AH2A5CC2HC43EELQOI7CRA5CNFSM4JAEMGO2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEBCIYQQ#issuecomment-541363266>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ACZDSTWNQED7NDAS2U5KTETQOI7CRANCNFSM4JAEMGOQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541364103:96,bottleneck,bottleneck,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541364103,2,"['bottleneck', 'perform']","['bottleneck', 'performance']"
Performance,"In some way this comes back to the fundamental question of: What is the point of KernelAbstractions CPU support. I originally intended it only for making debugging easier... But folks seem to be depending on it as a performance solution... I think it is feasible to get there, but it would require quite a bit of time and effort",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481464331:216,perform,performance,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481464331,1,['perform'],['performance']
Performance,"In summary, we can encounter at least 3 different errors:. ### 1. Dynamic function invocation. ```; julia> compute!(ComputedField(u + v - w)); ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),...; Reason: unsupported dynamic function invocation...; ```. Solution: probably the compiler isn't inferring types correctly. I think we can use Cthulhu to fully diagnose this error (though we may still need to be creative to solve the problem). ### 2. device kernel image is invalid?!?!. ```; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2)); ERROR: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. Solution: ??????. ### 3. ""Entry function uses too much parameter space"". ```; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593:150,Load,LoadError,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593,1,['Load'],['LoadError']
Performance,"In that example I'm using [`schedule = AveragedTimeInterval(2Δt; window=1.999Δt, stride=1)`](https://pastebin.com/F6ankx4L). So (unless I'm missing something), I expected the time-averaged results to be very close (if not identical) to the snapshot one, since it's only an average over `2Δt`. . From the plot it looks like the average instead is being performed over the interval `[0, t]`, for every `t`. (i.e., a cumulative average starting at the beginning of the simulation)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817998872:352,perform,performed,352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817998872,1,['perform'],['performed']
Performance,Indeed those are some great speedups! Doesn't even look like the GPU is saturated yet. > Do you think we need to get `MultiGPU` working or try and merge what we have with `MultiCPU` plus some tests? I'm tempted to merge sooner rather than later since already this is a big addition. It does seem to work :P But maybe it just needs some profiling to understand where the bottlenecks are. I guess we need to get some CUDA-aware MPI on Buildkite to test `MultiGPU` so maybe we don't have to explicitly test it just yet in this PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-799598593:370,bottleneck,bottlenecks,370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-799598593,1,['bottleneck'],['bottlenecks']
Performance,"Instead of saying that trig functions should be avoided on gpus, which seems very strong, I suggest pointing out that there have been some examples where trig functions have performed much slower, and include this example. . This clearly problem needs further exploration but I don't want people to be scared to use sin and cos because sometimes they just make a lot of sense. My two cents worth.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951478103:174,perform,performed,174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951478103,2,['perform'],['performed']
Performance,"Interesting that `mutable`s can't be `isbits`. But `Array` is mutable and `isbits`? Maybe some exceptions... I do think you should avoid fields with abstract or unspecified types in all cases (when simple, like this one) though, even if just for style points, but also to avoid an unexpected performance gotcha. `Clock{T}` seems appropriate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/19#issuecomment-477677073:292,perform,performance,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/19#issuecomment-477677073,1,['perform'],['performance']
Performance,"Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?. I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299561134:510,perform,performed,510,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299561134,2,['perform'],['performed']
Performance,Is there some kind of performance benefit of. https://github.com/CliMA/Oceananigans.jl/blob/d0b7ec8f98c860ce49927e0a7214961d2f47fb75/src/Fields/interpolate.jl#L63-L67. compared to. https://github.com/CliMA/Oceananigans.jl/blob/d0b7ec8f98c860ce49927e0a7214961d2f47fb75/src/Fields/interpolate.jl#L75-L81. ?. Why do we have both?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775526816:22,perform,performance,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775526816,1,['perform'],['performance']
Performance,"Is this PR looking for an adopter? Happy to try to complete it since it seems like the first step towards open BCs for hydrostatic models. > > Thinking of revamping this, I think `T` is a good notation; we do not need to specify `U` and `C` since probably (in the future) we will need to refactor these a little to pass through boundary conditions.; > ; > Hopefully we don't have to pass boundary conditions 🥺; > ; > Not all complexity is justified by the performance gains... Ah I'm actually not sure where the performance gains would come from, but I thought that the operators need to be aware of the boundary condition in order to correctly implement open BCs (at least based on @simone-silvestri's comments in https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2312725203).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2350225617:456,perform,performance,456,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2350225617,2,['perform'],['performance']
Performance,"Is this task required to complete the cubed sphere, or should we regard it as an optimization that's important for performance but not functionality?. @simone-silvestri @navidcy",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718257374:81,optimiz,optimization,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718257374,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"It can't be completely independent because it still needs `using Oceananigans`, but it could be _more_ independent. I agree that's desirable. I think using absolute filepaths rather than referencing the existing output writers, and using more explicit `nodes` functions could help, eg. ```julia; xζ, yζ, zζ = nodes((Face, Face, Center), grid) ; xδ, yδ, zδ = nodes((Center, Center, Center), grid); ```. I think the grid is serialized so you could load it from file (though this feature isn't very robust right now since it doesn't work for stretched grids, for example).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-878315017:446,load,load,446,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-878315017,1,['load'],['load']
Performance,"It is not an optimization; rather, to fill in periodic halos, a field must have a grid size larger than the halos (for other boundary conditions, only one is required). ; @navidcy, you could probably look at how the periodic halos are filled and make sure that they work also if the dimension is smaller than the number of halos. ; It might entail writing some ifelse in the fill periodic halo kernels. For example:; ```julia; @kernel function fill_periodic_west_and_east_halo!(c, ::Val{H}, N) where H; j, k = @index(Global, NTuple); @unroll for i = 1:H; @inbounds begin; # Put some ifelse condition here to make sure that halos pick from the interior; # and not other halos; c[i, j, k] = c[N+i, j, k] # west; c[N+H+i, j, k] = c[H+i, j, k] # east; end; end; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3622#issuecomment-2309039454:13,optimiz,optimization,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3622#issuecomment-2309039454,1,['optimiz'],['optimization']
Performance,"It makes sense that using `const` for variables referenced ""globally"" in functions increases CPU performance, see: https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800574436:97,perform,performance,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800574436,2,['perform'],"['performance', 'performance-tips']"
Performance,"It returns a int with the value of the number of files or file divisions already performed and the file name. if files are file_part_1.nc, file_part_2.nc, file_part_3.nc, the output will be: `3 file_part_3.nc`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2414533461:81,perform,performed,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2414533461,1,['perform'],['performed']
Performance,"It seems ths is pretty close, but I'm this error:. ```; ┌ Debug: checking footnote links.; --;   | └ @ Documenter.DocChecks /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/DocChecks.jl:110;   | [ Info: Populate: populating indices.;   | ERROR: LoadError: `makedocs` encountered an error. Terminating build;   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33;   | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);   | @ Documenter.Builder /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Builder.jl:255;   | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);   | @ Documenter.Utilities.Selectors /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Utilities/Selectors.jl:170;   | [4] #2;   | @ /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Documenter.jl:257 [inlined];   | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);   | @ Base.Filesystem ./file.jl:106;   | [6] #makedocs#1;   | @ /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Documenter.jl:256 [inlined];   | [7] top-level scope;   | @ ~/builds/tartarus-13/clima/oceananigans/docs/make.jl:155;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-13/clima/oceananigans/docs/make.jl:155;   | 🚨 Error: The command exited with status 1;   | user command error: exit status 1; ```. which doesn't really give me any information, so I'm unsure about how to proceed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-945152318:264,Load,LoadError,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-945152318,1,['Load'],['LoadError']
Performance,It seems to be good to merge! I have run at different resolutions and for longer times without seeing any race conditions,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-924096447:106,race condition,race conditions,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-924096447,1,['race condition'],['race conditions']
Performance,"It seems to have failed already so I will revert to what we had before. The error message is copied below. ```; [ Info: Populate: populating indices.; --;   | ERROR: LoadError: `makedocs` encountered an error. Terminating build;   | Stacktrace:;   | [1] error(::String) at ./error.jl:33;   | [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Builder.jl:255;   | [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Utilities/Selectors.jl:170;   | [4] #2 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:249 [inlined];   | [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104;   | [6] #makedocs#1 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:248 [inlined];   | [7] top-level scope at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | [8] include(::Function, ::Module, ::String) at ./Base.jl:380;   | [9] include(::Module, ::String) at ./Base.jl:368;   | [10] exec_options(::Base.JLOptions) at ./client.jl:296;   | [11] _start() at ./client.jl:506;   | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | 🚨 Error: The command exited with status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366:166,Load,LoadError,166,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366,1,['Load'],['LoadError']
Performance,"It turns out this also affects `JLD2OutputWriter`. I believe this is due to us ""double-counting"" indices in `construct_output()`. Specifically, we _always_ slice outputs with `indices` here: https://github.com/CliMA/Oceananigans.jl/blob/3322f1879cf8c84c88e9c7cf4e33bdcf70520c36/src/OutputWriters/output_construction.jl#L49-L51. When a `Field` isn't ""pre-sliced"" (i.e., isn't constructed with the `indices` keyword) then that's okay. But if a `Field` is already sliced, then we slice it again there. Depending on how both `indices` are defined (the one when constructing the `Field` and the one passed to the output writer), we try to access outputs at indices that aren't there anymore, leading to a `BoundsError`:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; ```. I'll open a PR soon to fix this, but I just wanted to leave this saved here. I think the way to go is to change the default `indices` in the constructors to `nothing` and then use that to avoid the double slicing in `construct_output()`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067:728,Load,LoadError,728,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067,1,['Load'],['LoadError']
Performance,"It'd be nice to state in writing the justification for writing a separate CPU solver for certain problems. In general, I think that any algorithm that works on the GPU will also work on the CPU. Thus at least in principle the simplest choice is presumably to use the same solver on both architectures. For example, benchmarking *might* show that a GPU-friendly algorithm performs poorly compared to a CPU-specific algorithm, which might justify maintaining separate solvers for the GPU and CPU. Is this the case?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/586#issuecomment-572064187:371,perform,performs,371,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586#issuecomment-572064187,1,['perform'],['performs']
Performance,"It's a ""performance"" task really but I have the gut feeling that it might be impeding performance so much that we won't be able to consider the cubed sphere done if we don't deal with this. So probably good idea to leave it in the milestone of global simulation using cubed sphere as is now?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718731994:8,perform,performance,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718731994,2,['perform'],['performance']
Performance,"It's a problem of particles being advected in the x-direction. You can see that the out-of-bounds error is in the x-direction; `ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]`; You are moving out of the periodic grid because the particle is being advanced beyond the periodic domain.; There is no bouncing happening and it is not a problem of Bounded directions because the particle is not moving in the y- or in the z-direction. You are prescribing a steady state flow which is characterized by a u-velocity only. There is no tendency term that can develop a shear instability since a y-gradient in u is stable if there are no additional frictional forces, i.e.:; $$\frac{\partial u}{\partial t} = - \frac{\partial uu}{\partial x} - \frac{\partial uv}{\partial y} - \frac{\partial uw}{\partial z} - \frac{\partial p}{\partial x}$$; All the terms on the RHS of this equation are zero because; - $v = 0$; - $w = 0$; - $\frac{\partial uu}{\partial x} = 0$; - $\frac{\partial p}{\partial x} = 0$ since $\delta_x u^* + \delta_y v^* + \delta_z w^* = 0$ and you have periodic boundary conditions in the x-direction. from how you initialized it, the flow cannot change, irrespective of your CFL (if you remove your particles you'll see that the code will run indefinitely without changing, even with CFL = 100). In your second case, when you change the velocity to ; ```julia; function initial_u(x::R, y::R, z::R) where {R<:Real}; ϵ = 1e-7; return (max_velocity / Lx) * y + ϵ * max_velocity * sin(6π * x / Lx); end; ```; you are initializing your solution with a divergent flow $\partial_x u + \partial_y v + \partial_z w \ne 0$ which is not ""admissible"" in an incompressible model (such as Oceananigans' non-hydrostatic-model). The initialization then triggers a pressure correction which will act to suppress the divergence in your initial conditions, by either includi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773296277:135,Load,LoadError,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773296277,1,['Load'],['LoadError']
Performance,"It's interesting that this affects performance so much. IIRC, we previously called `Base.power_by_squaring`, which seems slower than the current Float64 intrinsic:. ```julia; julia> A = CUDA.rand(1024,1024);. # current version; julia> @benchmark CUDA.@sync broadcast!(A, A, 10) do a, b; a^b; end; BenchmarkTools.Trial: ; memory estimate: 496 bytes; allocs estimate: 7; --------------; minimum time: 33.429 μs (0.00% GC); median time: 33.970 μs (0.00% GC); mean time: 35.515 μs (0.00% GC); maximum time: 464.024 μs (0.00% GC); --------------; samples: 10000; evals/sample: 1. # Int32 is faster indeed; julia> @benchmark CUDA.@sync broadcast!(A, A, 10) do a, b; a^(b%Int32); end; BenchmarkTools.Trial: ; memory estimate: 496 bytes; allocs estimate: 7; --------------; minimum time: 29.600 μs (0.00% GC); median time: 30.289 μs (0.00% GC); mean time: 33.132 μs (0.00% GC); maximum time: 740.031 μs (0.00% GC); --------------; samples: 10000; evals/sample: 1. # old code path was slower than both; julia> @benchmark CUDA.@sync broadcast!(A, A, 10) do a, b; Base.power_by_squaring(a, b); end; BenchmarkTools.Trial: ; memory estimate: 496 bytes; allocs estimate: 7; --------------; minimum time: 39.410 μs (0.00% GC); median time: 40.629 μs (0.00% GC); mean time: 45.890 μs (0.00% GC); maximum time: 1.195 ms (0.00% GC); --------------; samples: 10000; evals/sample: 1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869801976:35,perform,performance,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869801976,1,['perform'],['performance']
Performance,"It's just a suggestion... Perhaps it's not needed. But having it as a parameter of the type could be useful, even if the parameter is the same value as `grid.Nz` because if it's part of type you can write methods that do different things based on the number of layers your model has. E.g.,. ```Julia; function compute_this_and_that(model::ShallowWaterModel{1}); a = 1 # simple calculation for single-layer models; return a; end. function compute_this_and_that(model::ShallowWaterModel); number_of_layers = model.number_of_layers; a = sum(rand(number_of_layers)) # more complicated stuff only needed for multi-layer models; return a; end; ```. This way we don't use `if number_of_layers > 1; do this; else; do that` which reduces performance because the compiler has to compile all cases and check every time the value of layers and do this or the other....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469188127:729,perform,performance,729,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469188127,2,['perform'],['performance']
Performance,"It's now obvious that tests like the one in #1807 implicitly perform this test, so it's not needed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1802#issuecomment-873294152:61,perform,perform,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1802#issuecomment-873294152,1,['perform'],['perform']
Performance,"Just a clue from https://github.com/jipolanco/PencilArrays.jl/issues/49:. I think it's likely we need to use some `PencilArrays` interface to set up / partition the eigenvalues, rather than attempting to manually hack together a partition. Also by the way, it looks like we might be able to use ""pencil"" decomposition with the non-hydrostatic model now too: . https://github.com/jipolanco/PencilArrays.jl/issues/42#issuecomment-1029766858. previously we could not because PencilFFTs required FFTs to be performed along dimension 1. Since we can't decompose in ""z"" (because at least right now there are vertical integrals in `NonhydrostaticModel` --- this should also be relaxed), this only left the `y` dimension for partitioning. It feels like we might be relatively straightforward to solve if we become proficient with PencilArrays?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1101627302:503,perform,performed,503,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1101627302,1,['perform'],['performed']
Performance,"Just a quick update, zero-viscosity Bicklet jet test case for `VectorInvariant`, `WENOVectorInvariant` (smoothness calculated based on `ζ`), modified VectorInvariant WENO with smoothness based on 2D stencils of `u` and `v`, here called `WENOVectorInvariantZVEL`. `VectorInvariant`. https://user-images.githubusercontent.com/33547697/157745561-a8e5f128-2f4e-42e3-9305-3f624498590b.mp4. `WENOVectorInvariant`. https://user-images.githubusercontent.com/33547697/157745569-41c52e2d-c80b-4d43-b2bf-8a914e8856a2.mp4. `WENOVectorInvariantZVEL`. https://user-images.githubusercontent.com/33547697/157745571-725ea604-8dec-44bd-bd08-dcd70d9ed4b1.mp4. `WENOVectorInvariantZVEL` seems to perform actually very well compared to a (somewhat) standard ""vorticity-reconstruction"" `WENOVectorInvariant` and compared to the very noisy standard `VectorInvariant` in lie of the fact that; - Noise is reduced significantly despite dissipation not being too high; - Agreement between different resolutions is much higher",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064455116:676,perform,perform,676,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064455116,1,['perform'],['perform']
Performance,Just a thought that we probably want reductions on field time series to be performant anyways. So it's better that we call data summary because then more people will be annoyed that they are slow => more pressure to fix it 😆,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3750#issuecomment-2322232441:75,perform,performant,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3750#issuecomment-2322232441,1,['perform'],['performant']
Performance,"Just an update (mostly for my own benefit later), apparently the outputs are constructed appropriately now, but the outputs still can't be written to NetCDF because the writer creates the variables with a different size:. ```julia; ERROR: LoadError: NetCDF error: size mismatch for variable 'op_sliced2' in file './sliced.nc'. Trying to write (2, 1, 6) elements while [2, 1, 4, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:943; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:954; [3] setindex!; @ ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:457 [inlined]; [4] setindex!(::NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:490; [5] setindex!(::NCDatasets.CFVariable{Float32, 4, NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/cfvariable.jl:732; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:239,Load,LoadError,239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655,1,['Load'],['LoadError']
Performance,"Just some comments at this point:; * At this point, we have the HydrostaticFreeSurface model working with the split explicit free surface. It would be great to find some time later on to figure out what was going on with the implicit free surface on AMD GPUs (is the issue isolated only to that architecture??) and get this resolved.; * To get everything moved over to KernelAbstractions would constitute a rather large change, something I think @glwagner expressed an interest in avoiding. I'd vote in favor of pushing this change off for future PR's.; * I'm wrapping up a profiling report that includes MI210 and A100 GPU performance; this report will include some recommendations should we be interested in performance improvements on GPU hardware (AMD and Nvidia). This kind of work could also constitute PR's further down the road.; * The main outstanding issue seems to be that we need a platform for testing on AMD GPUs. . It appears the CliMA fork `Project.toml` and `Manifest.toml` have diverged; I'll take a look to see if I can fix.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1997632147:624,perform,performance,624,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1997632147,2,['perform'],['performance']
Performance,"Just some restructuring of the `fill_halo_regions!` to allow the application of `apply_regionally!` to the directional fill_halo.; The `fill_halo_regions!` looks like this; ```; halo_tuple = permute_boundary_conditions(boundary_conditions); ; for task = 1:3; barrier = device_event(arch); fill_halo_event!(task, halo_tuple, c, loc, arch, barrier, grid, args...; kwargs...); end; ```; this should actually not change the performance... but I guess it will change completely since we will not want a loop over halo events anymore, neither to permute BCs.; There are differences in the `HydrostaticFreeSurfaceModel` where I lumped all the `fill_halo_regions` together and exposed a little bit of parallelism, and in the `QuasiAdamsBashforthTimeStepper` which might affect the `NonhydrostaticModel` benchmarks",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116140545:420,perform,performance,420,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116140545,1,['perform'],['performance']
Performance,"Just to be clear, the point of doing this is because you want to use dispatch to write flexible array operations that are agnostic to whether the array is a 'raw' array (like an `Array` or `CuArray`), or some kind of wrapper like an `OffsetArray`. By writing `parent(a)`, you ensure correct behavior on `a` in both cases; you don't need to write new high-level functions for wrappers versus arrays because dispatch is performed at the lower level, where it belongs. With `data` we can use the same logic --- this concept is deployed extensively in PR #463.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/454#issuecomment-542269350:418,perform,performed,418,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/454#issuecomment-542269350,1,['perform'],['performed']
Performance,"Just to clarify things a bit for you @loganpknudsen --- your error says. > ERROR: LoadError: Failed to precompile Oceananigans. this means that the segmentation fault occurs during precompilation of `Oceananigans`, which occurs before any code you have written executes. That's why the error comes from ""line 1"" of your script (is that where you write `using Oceananigans`?). Another clue is the text. > [52922] signal (11.1): Segmentation fault; > in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:129. That says the error comes from line 129 in the file `src/Oceananigans.jl`. Going to that line on `main` branch we find:. https://github.com/CliMA/Oceananigans.jl/blob/d6e63e53e795272378b7657c4a6f32da2d62d6f9/src/Oceananigans.jl#L129. so there's something wrong with your CUDA / how it's loaded. The best course of action is probably to update to julia 1.10 first of all rather than using julia 1.9.2. Next, see if you can simply write `using CUDA` rather than trying to run your whole script. If you can get that to work (better yet if you can use some of `CUDA.jl` on a GPU on derecho then move on to simply writing `using Oceananigans` and trying to build a grid on the GPU. If that succeeds move on to your script.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2240940342:82,Load,LoadError,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2240940342,3,"['Load', 'load']","['LoadError', 'loaded']"
Performance,"Just to summarize where we are here:. 1. The new test fails.; 2. We also expect that changes on #3477 will cause the test to fail. A possible solution to the changes that #3477 will incur is to replace the slurped locations with `args::Varargs{N, T}` @wsmoses ; 3. We need to merge #3477 to restore normal CPU performance. Otherwise, Oceananigans can't be used even merely to demonstrate capabilities on the CPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-1948850386:310,perform,performance,310,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-1948850386,1,['perform'],['performance']
Performance,"Latest error:. ```julia; ERROR: LoadError: task switch not allowed from inside staged nor pure functions; Stacktrace:; [1] try_yieldto(undo::typeof(Base.ensure_rescheduled)); @ Base ./task.jl:921; [2] wait(); @ Base ./task.jl:995; [3] uv_write(s::Base.TTY, p::Ptr{UInt8}, n::UInt64); @ Base ./stream.jl:1048; [4] unsafe_write(s::Base.TTY, p::Ptr{UInt8}, n::UInt64); @ Base ./stream.jl:1120; [5] write; @ Base ./strings/io.jl:248 [inlined]; [6] print; @ Base ./strings/io.jl:250 [inlined]; [7] print(::Base.TTY, ::String, ::String, ::Vararg{String}); @ Base ./strings/io.jl:46; [8] println(::Base.TTY, ::String, ::Vararg{String}); @ Base ./strings/io.jl:75; [9] println(::String, ::String); @ Base ./coreio.jl:4; [10] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType, prev::LLVM.UndefValue, lidxs::Vector{…}, ridxs::Vector{…}); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:270; [11] calling_conv_fixup (repeats 2 times); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:183 [inlined]; [12] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler/utils.jl:183; [13] enzyme_custom_common_rev(forward::Bool, B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, normalR::Ptr{…}, shadowR::Ptr{…}, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler.jl:4610; [14] enzyme_custom_rev(B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzyme.jl/src/compiler.jl:4770; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786194570:32,Load,LoadError,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786194570,1,['Load'],['LoadError']
Performance,Let's do a simple test of CPU performance to make sure we won't have to revert this soon given the change to splatting (which was implemented to solve a 100x slow down a few months ago),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2137702684:30,perform,performance,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2137702684,2,['perform'],['performance']
Performance,"Looks good to me. My only question is about the derivation of ``wˢ``, which results from a vertical integration of the analytical functions. Currently this integral is performed under the assumption that ``wˢ`` is zero at large depths, which I clarified in the code:; https://github.com/CliMA/Oceananigans.jl/blob/06f6ac746742d08c78b3cfed0bd40f7df4392819/src/StokesDrifts.jl#L213-L215. **Is this the correct assumption here?** It effectively means that ``wˢ`` and its gradients are a maximum at the surface under a depth-decaying Stokes drift, so any horizontal convergence/divergence of Stokes drift manifests a local change in sea surface height:; https://github.com/CliMA/Oceananigans.jl/blob/06f6ac746742d08c78b3cfed0bd40f7df4392819/src/StokesDrifts.jl#L248-L250. An alternative would be to set ``wˢ`` to zero at the surface, which would cause ``wˢ`` and its horizontal gradients to reach a maximum at large depths, as the occurrences of ``ûˢ(z)`` above would become ``( ûˢ(z) - ûˢ(0) )``. Essentially, horizontal convergence/divergence would manifest as downwelling/upwelling (rather than SSH changes in the current case). I feel like this approach makes sense for LES setups, but it could cause problems for simulations of the full water column where you don't want direct Stokes drift effects deep in the ocean interior. I'm happy to go forward with this example as is, but the above would be a useful question to answer in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3425#issuecomment-1891314292:168,perform,performed,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3425#issuecomment-1891314292,1,['perform'],['performed']
Performance,Looks like I forgot this in #3847. The performance should be identical if using both the methods provided the methods are precompiled correctly. The method in [`tracer_advection_operators.jl:11`](https://github.com/CliMA/Oceananigans.jl/blob/7cbf013cb6bed2bd7cef0f4d8e5f04c078e50ee0/src/Advection/tracer_advection_operators.jl#L11) avoids the immersed boundary check with `nothing` advection so probably it's a tad better.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3851#issuecomment-2428436798:39,perform,performance,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3851#issuecomment-2428436798,1,['perform'],['performance']
Performance,"Looks like you're referencing `grid` as a global in `Z(k)`. Not sure if that causes performance issues, but it won't compile on the GPU. So you might want to propagate that argument through.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875673065:84,perform,performance,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875673065,1,['perform'],['performance']
Performance,"MA/OceananigansArtifacts.jl/raw/ss/new_hydrostatic_data_after_cleared_bugs/quarter_degree_near_global_input_data/tau_x-1440x600-latitude-75.jld2""; │ dest = ""/u/fpoulin/.julia/scratchspaces/124859b0-ceae-595e-8997-d05f6a7a8dfe/datadeps/quarter_degree_near_global_lat_lon/tau_x-1440x600-latitude-75.jld2""; │ progress = NaN; │ time_taken = ""0.07 s""; │ time_remaining = ""NaN s""; │ average_speed = ""3.493 MiB/s""; │ downloaded = ""250.411 KiB""; │ remaining = ""∞ B""; └ total = ""∞ B""; ERROR: HTTP.Exceptions.StatusError(404, ""GET"", ""/CliMA/OceananigansArtifacts.jl/raw/ss/new_hydrostatic_data_after_cleared_bugs/quarter_degree_near_global_input_data/tau_x-1440x600-latitude-75.jld2"", HTTP.Messages.Response:; """"""; HTTP/1.1 404 Not Found; Server: GitHub.com; Date: Thu, 20 Jun 2024 13:36:59 GMT; Content-Type: text/html; charset=utf-8; Vary: X-PJAX, X-PJAX-Container, Turbo-Visit, Turbo-Frame, Accept-Encoding, Accept, X-Requested-With; Cache-Control: no-cache; Strict-Transport-Security: max-age=31536000; includeSubdomains; preload; X-Frame-Options: deny; X-Content-Type-Options: nosniff; X-XSS-Protection: 0; Referrer-Policy: origin-when-cross-origin, strict-origin-when-cross-origin; Content-Security-Policy: default-src 'none'; base-uri 'self'; child-src github.com/assets-cdn/worker/ gist.github.com/assets-cdn/worker/; connect-src 'self' uploads.github.com www.githubstatus.com collector.github.com raw.githubusercontent.com api.github.com github-cloud.s3.amazonaws.com github-production-repository-file-5c1aeb.s3.amazonaws.com github-production-upload-manifest-file-7fdce7.s3.amazonaws.com github-production-user-asset-6210df.s3.amazonaws.com api.githubcopilot.com objects-origin.githubusercontent.com copilot-proxy.githubusercontent.com/v1/engines/github-completion/completions *.actions.githubusercontent.com wss://*.actions.githubusercontent.com productionresultssa0.blob.core.windows.net/ productionresultssa1.blob.core.windows.net/ productionresultssa2.blob.core.windows.net/ productionresultssa3.b",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2180730454:1148,Cache,Cache-Control,1148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2180730454,2,"['Cache', 'cache']","['Cache-Control', 'cache']"
Performance,"MITgcm I believe uses the same two-dimensional preconditioned conjugate gradient solver for the rigid lid case as for the implicit free surface case. Many ocean models often have a split explicit method for stepping forward the free surface so there is no elliptic solve. ([Killworth et al. 1991](https://journals.ametsoc.org/view/journals/phoc/21/9/1520-0485_1991_021_1333_tdoafs_2_0_co_2.xml) discusses the disadvantages of either implicit free surface or rigid lid for ocean modeling with realistically complex geometries / coastlines.). This optimization really applies just to hydrostatic models on regular grids (no horizontal stretching). Much of the time I think it would be preferable to use the nonhydrostatic model for this case, since our FFT solver is so fast that the price paid is utterly minor. Yet with an immersed boundary (and perhaps only with a non-grid-fitted immersed boundary), there are some lingering issues that we haven't resolved about whether the FFT solver can be used as is while maintaining mass conservation. The hydrostatic solver uses a vertical integral of the continuity equation and is thus far more straightforward to maintain incompressibility with non-grid-fitted boundaries. So there is a little corner case in which you might want this feature. It's also obviously useful for testing the hydrostatic model.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1727#issuecomment-851699446:546,optimiz,optimization,546,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1727#issuecomment-851699446,1,['optimiz'],['optimization']
Performance,"Might be cool to be able to dispatch on the order so the order could be specified as part of the model, e.g. ```julia; model = ShallowWaterModel(grid=grid, order=4); ```. and it would make it easier to use the operators in other models. We could define new types like. ```julia; struct SecondOrderCenteredDifference end # one option; struct CenteredDifference{N} end # another option; ```. then dispatch on `::SecondOrderCenteredDifference` or `::CenteredDifference{Val{4}}` or we could dispatch on numbers via `Val`. ```julia; julia> δ(i, A, ::Val{2}) = A[i] - A[i-1]; δ (generic function with 1 method). julia> δ(i, A, ::Val{4}) = (-2A[i+1] + 16A[i] - 16A[i-1] +2A[i-2]) / 12; δ (generic function with 2 methods). julia> δ(10, collect(1:20) .^ 2, Val(2)); 19. julia> δ(10, collect(1:20) .^ 2, Val(4)); 15.833333333333334; ```. but might have to be careful to [avoid performance regressions with `Val`](https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-value-type). That said it might take a non-trivial amount of refactoring to support and test dispatching on the operator order, at least for the incompressible model. Maybe it makes sense for `ShallowWaterModel` to add support for 4th-order operators first (with or without dispatch, probably easier without first) and from there we can investigate how to generalize?. If we go all out and start supporting lots of different operators I wonder if it's worth looking into [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl) or [FiniteDifferences.jl](https://github.com/JuliaDiff/FiniteDifferences.jl). Not sure what role these packages would play. From skimming the FiniteDifferences.jl README it seems that there are no higher-order non-allocating implementations between the two packages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-740952155:868,perform,performance,868,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-740952155,3,['perform'],"['performance', 'performance-tips', 'performance-value-type']"
Performance,"Might be worthwhile to profile with `timestepper=:RungeKutta3` as a sanity check, considering that this benchmark suggests a simple time-stepping function is 12% (!) of the cost. Another thought --- we should probably benchmark ""fully loaded"" models that at least use WENO advection (and perhaps some turbulence closure?), since that's more realistic. I think most usage of `NonhydrostaticModel` also has one tracer, rather than two (someday, we should change that default...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890002262:235,load,loaded,235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890002262,2,['load'],['loaded']
Performance,Might have something to do with how many threads are running on how many physical cores. I'll try to tune how the threaded processes are launched and specify one thread per core more clearly. Hyperthreading seems to be what enables 2 threads to run on one core. There should be options to disable it either through slurm or julia.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-890031307:101,tune,tune,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-890031307,2,['tune'],['tune']
Performance,"More information, I tried changing Oceananigans.jl builds by running in Julia; ```; ] add https://github.com/climate-machine/Oceananigans.jl.git; ```; and I ran my code and it loaded fine the first time, but again it had a segmentation fault on the rerun. Similarly, when I executed; ```; ] add Oceananigans; ```; it ran the first time then got a segmentation fault on the second run again. Could this not be an issue with Oceananigans.jl but with how I am running my code on the GPU?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2237197159:176,load,loaded,176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2237197159,1,['load'],['loaded']
Performance,"Mostly I am worried about scalability and sustainability in this design, or future designs. . Currently our models are fairly simple, but its challenging to place bounds on potential future complexity. For example, models in the future may require additional fields associated with closures or parameterizations, such as boundary layer depth fields, in-plume tracer concentrations and vertical momentum, precomputed mixing length fields, and perhaps other auxiliary fields associated with various prognostic / diagnostic LES models. We probably can't plan to support setting boundary conditions on every possible field via the model constructor. With our current design we have essentially special-cased turbulent diffusivities because our focus is LES, turbulent diffusivities are relatively common, and it convenient for us. However doing this incurs some maintenance burden --- which will increase if we plan to hard-code validation and error checking. Food for thought.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605453798:26,scalab,scalability,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605453798,1,['scalab'],['scalability']
Performance,"Mu understanding is that it is _required_ for GPU runs, but it also helps optimize CPU runs. In any case, you're using a `NamedTuple`, which is immutable, so it might not help here, but I think it's worth checking anyway.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816749082:74,optimiz,optimize,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816749082,1,['optimiz'],['optimize']
Performance,"My biggest concern is that introducing a grid topology and keeping the current implementation of boundary conditions will cause confusion as they perform overlapping functions. But I think with a bit of thinking there can be lots of benefits to adding a grid topology as you say. > This change will eliminate the need for a special `ChannelModel` constructor, and also eliminates the need for constructors with names like `HorizontallyPeriodicBCs`. Instead, we have a generic constructor for `FieldBoundaryConditions` that lets a user specify boundary conditions in any direction. That would be great I think. If each field now carries around its own boundary conditions and horizontally periodic and channel BCs are treated a grid topology then we can get rid of `HorizontallyPeriodicBCs`, `HorizontallyPeriodicSolutionBCs`, `ChannelBCs`, and `ChannelSolutionBCs` (+ same for triply periodic and boxes) which would greatly simplify model setup and eliminate most overlap between boundary conditions and grid topology. > A `Flat` topology will enable us to set halo sizes to 0 for `Flat` directions, and elide the unnecessary interpolation and differentiation operations in `Flat` directions that currently plagues two and one-dimensional models. True. We currently don't have a clean way of eliding unnecessary operations for 1D and 2D models. Dispatching on the grid topology would provide a way of doing this very cleanly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/489#issuecomment-579888892:146,perform,perform,146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/489#issuecomment-579888892,1,['perform'],['perform']
Performance,My goal right now is to do all of the changes without introducing new constructs and then evaluate performance from there.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1429925832:99,perform,performance,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1429925832,1,['perform'],['performance']
Performance,"My suggestion of opening a separate issue comes from the fact that I don't have much time to work on this PR (as you guys could probably see by the month-delay in answering the last comments). And in the meantime there's a bug in the code that could be fixed rn with one extra commit. But fair enough. Let's solve this here. > I think the right way forward is to implement something that works for all grids. Then we can implement the grid-specific versions --- which should be viewed as conveniences or optimizations rather than necessities --- as time allows. I think this is a better and more efficient approach then implementing convenience versions first, and figuring out the general version later. You might find that the convenience versions aren't really necessary because things are convenient enough... If I understand what you're proposing, the way forward would be to implement something that always returns the 3D field/array, since that's the only way that works for all grids no matter what. Correct?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1638223596:504,optimiz,optimizations,504,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1638223596,1,['optimiz'],['optimizations']
Performance,Nah…. Every preview is 200MB of load on the repo I then have to clean and it’s not that easy to clean up a repository’s history. I’d rather I make the PR twice or built the docs locally :),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2886#issuecomment-1409054886:32,load,load,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2886#issuecomment-1409054886,1,['load'],['load']
Performance,"New log level should be enough if we just need flat per-iteration timings to time a few blocks for a few iterations. Are you thinking of just logging raw `@time` data?. I'm not sure if we need anything more than a new log level, but I imagine some of the benefits of using a package like TimerOutputs.jl would make the timer blocks much more useful for debugging and for users. It allows for nested timers and produces a very nice table summary at the end which includes number of calls and average time/memory allocations. This could also be useful for users wishing to time their simulations to figure out how much time is being spent on I/O vs. in kernels vs. solvers vs. callbacks, etc. I guess I also see timers as a debugging tool for users. Could help be figure out cluster filesystem issues or figure out whether Oceananigans or my coupled model (via callback) is the bottleneck. Otherwise if the timers are just a developer debugging tool that dumps timing information, that's useful but it might not be useful for timing real-world scripts/simulations since the log would fill up with a huge number of lines that can't be interpreted without further processing. Here's an example of it in use: https://github.com/JuliaGPU/CUDA.jl/issues/149#issuecomment-461943376 (CUDA.jl has been using TimerOutputs.jl for a long time I think). TimerOutputs.jl is easy to use since you just add `@timeit` blocks but that does add some noise to the code (not sure if more or less than using a timing log level).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887921831:876,bottleneck,bottleneck,876,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887921831,1,['bottleneck'],['bottleneck']
Performance,Nice! Performance differences could be noise too. Is it possible to say what the changes to fill halo regions were? Just in case #2477 takes longer than expected?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116134666:6,Perform,Performance,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116134666,1,['Perform'],['Performance']
Performance,"Nice, maybe this will also increase the performance!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2782#issuecomment-1284065270:40,perform,performance,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2782#issuecomment-1284065270,1,['perform'],['performance']
Performance,"No need to apologize, just trying to help. I think you can form an AbstractOperation for velocities when the model is constructed, eg:. ```julia; velocities = (u = uh/h, v = vh/h); ```. These can be stored in `ShallowWaterModel.velocities`, and used in kernels. They have a getindex method so they'll work with WENO functions too. This doesn't use any extra memory. AbstractOperations perform the calculation `uh/h` with correct interpolation on the fly. > Just so that I understand, instead of having momentum_flux_huu, advection and transport_tracer_flux_x we should have had something involving the area? I'm happy to help fix this where I can. We'd write a horizontal divergence either as. ```; div(Q) = 1 / V * (δx(Ax * Qx) + δy(Ay * Qy)); ```. or. ```; div(Q) = 1 / Az * (δx(Δy * Qx) + δy(Δx * Qy)); ```. I think this is written in the docstrings but doesn't appear to be reflected in the code. Correct me if I'm wrong.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-882666483:385,perform,perform,385,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-882666483,1,['perform'],['perform']
Performance,No need to worry about CUDA package errors anymore!. https://discourse.julialang.org/t/cuarrays-cudanative-psa-simplified-package-loading/27897,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/366#issuecomment-524361260:130,load,loading,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/366#issuecomment-524361260,1,['load'],['loading']
Performance,"No, the purpose of this line is to add the Oceananigans root directory to the load path. This allows the local version of `Oceananigans` to be used when building the docs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1777#issuecomment-869743740:78,load,load,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1777#issuecomment-869743740,1,['load'],['load']
Performance,"Not sure this is related, but while I usually use other languages to load and plot the outputs, I always come across `permission denied` when I have the file open by another kernel. I was wondering if there is a way to bypass that and force the overwrite.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2097044533:69,load,load,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2097044533,1,['load'],['load']
Performance,"Note that this PR does not affect at all `UpwindBiased` reconstruction: instead of this pattern ; ```julia; R_left = _left_reconstruction(.....); R_right = _right_reconstruction(.....). return ifelse(u > 0, u * R_left, u * R_right); ```. the upwind reconstruction ends up doing; ```julia; R = _reconstruction(bias(u), .....). return u * R; ```; where the double computation is performed _inside_ the reconstruction function; ```julia; _reconstruction(bias(u), .....) = ifelse(bias == LeftBias(), left_reconstruction(...), right_reconstruction(...); ````; so formally, nothing changes for linear upwind reconstructions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3658#issuecomment-2243554967:377,perform,performed,377,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658#issuecomment-2243554967,1,['perform'],['performed']
Performance,Note: It seems that it didn't really reduce the docs built overall time. I guess we've reached to the point where examples aren't the bottleneck anymore but rather doctests and compilation times are. :),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3180#issuecomment-1631462344:134,bottleneck,bottleneck,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3180#issuecomment-1631462344,1,['bottleneck'],['bottleneck']
Performance,"Now that the spacing functions are in place, I'm going to start working on this. (I'll update the top post with the information below.). The goal here is to add grid metrics to NetCDF output. The are two main avenues to follow:. 1. We can follow Oceananigans nomenclature and conventions, which would make the output play more nicely with Oceananigans itself (and more generally in the Julia environment).; 2. We can follow standard community conventions, which would mean the output won't follow Oceananigans naming etc., but it would optimize its readability by other software. I think we should follow option 2, since if a user wants to work with the output in Oceananigans/Julia, then using JLD2 output is probably the right choice anyway. Given that most people in the community use Python, `xarray` and `xgcm` to analyze model output, I think we should optimize the output to work with that ecosystem out of the box. Based on the discussion in https://github.com/CliMA/Oceananigans.jl/issues/1334, it seems the preferred conventions to use are the [SGRID conventions](https://sgrid.github.io/sgrid/). For the more technical aspects, I'm planning on starting with `RectilinearGrids` and `LatLonGrids` in this PR since these are more straightforward. And then we can expand from there. I also think this should be presented to the user as an opt-in flag in `NetCDFWriter` constructor, as opposed to being included in every NetCDF output by default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516604529:536,optimiz,optimize,536,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516604529,2,['optimiz'],['optimize']
Performance,"OK, with [9916af8](https://github.com/CliMA/Oceananigans.jl/pull/3475/commits/9916af841ae2b4069eef50b216a5ac5ac90ff1d2) I think I moved (almost) all the AMDGPU-related methods into an extension. @fluidnumerics-joe now when you do . ```Julia; julia> using Oceananigans; ```. you don't have access to the AMDGPU methods you added. But if you do. ```Julia; julia> using Oceananigans, AMDGPU; ```. then the extension loads and everything is available!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1944305273:413,load,loads,413,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1944305273,1,['load'],['loads']
Performance,"Obukhov-compliant bottom drag. I couldn't reproduce the simulation perfectly (for example, they use a pseudo-spectral scheme in the horizontal directions, force their drag with a horizontal average, and modify the `SmagLilly` constant slightly) so the results are a bit different from what's in their paper, but I think that's okay. Let me know if anyone thinks otherwise. Importantly, the `ScaleInvSmag` shows an improvement over the `SmagLilly`, with the later being expectedly overly diffusive and pretty much killing any turbulence at this resolution:. https://github.com/user-attachments/assets/6440450d-52f4-43ef-9ad5-0f8fcd9993d5. For reference, this is what similar plots from the paper look like (the equivalent for us here would be SMAG and PASI):. ![image](https://github.com/user-attachments/assets/5607d340-d4b4-4405-a0a6-67ed43bfd274). Some quick notes:. - Many tests are failing become I made an ad-hoc modification for now which passes the velocities to `DiffusivityFields()`. I did that because otherwise it was hard to make the model performant and simulations were taking way too long. We can (and should) review this and either come up with a better way to construct the `diffusivity_fields` or make this change separately in another PR, which will require changing the other models too.; - I'm updating the dynamic model once every 5 time steps only (this is user-defined). This is common practice for dynamic models since their cost is significantly higher than that of constant Smag or even AMD. With that practice, the dynamic model is taking about 3 times longer to run than the constant Smagorinsky. It does take significantly longer to compile (I haven't timed it). I believe there might be some optimizations still on the table though.; - I also found that the precise value of the Smag coefficient calculated via the dynamic procedure is dependent on the advection scheme, with WENO generally leading to smaller values. In hindsight, I think that's not surprising though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2417879667:2322,perform,performant,2322,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2417879667,4,"['optimiz', 'perform']","['optimizations', 'performant']"
Performance,"OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, typeof(identity), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, typeof(condition_greater_3), Int64, Float64}}}}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/07qaN/src/driver.jl:76; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:346; [10] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/07qaN/src/cache.jl:90; [11] cufunction(f::typeof(CUDA.partial_mapreduce_grid), tt::Type{Tuple{typeof(identity), typeof(Base.add_sum), Nothing, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, Val{true}, Base.ReshapedArray{Float64, 4, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}, Oceananigans.AbstractOperations.ConditionalOperation{Center, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, typeof(identity), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Offs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568:9361,cache,cache,9361,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568,1,['cache'],['cache']
Performance,"Oh ok, this error on CPU initialization?. ```; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /storage7/buildkite-agent/.julia-1965/compiled/v1.5/GPUArrays/v5u0T_Ru6eV.ji.; --;   | Stacktrace:;   | [1] top-level scope at none:2;   | [2] eval at ./boot.jl:347 [inlined];   | in expression starting at /storage7/buildkite-agent/.julia-1965/packages/CUDA/wTQsK/src/CUDA.jl:5;   | WARNING: Error during initialization of module LinearAlgebra:;   | ErrorException(""could not load library ""libopenblas64_"";   | libopenblas64_.so: ELF load command past end of file"");   | ┌ Error: Error during initialization of module CHOLMOD;   | │ exception =;   | │ could not load library ""libcholmod"";   | │ libopenblas64_.so.0: ELF load command past end of file;   | │ Stacktrace:;   | │ [1] dlopen(::String, ::UInt32; throw_error::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109;   | │ [2] dlopen at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109 [inlined] (repeats 2 times);   | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90;   | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187;   | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; ```. I believe these happen occasionally when using `instantiate` and the solution is typically to restart the build?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1566#issuecomment-817009364:54,Load,LoadError,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1566#issuecomment-817009364,7,"['Load', 'load']","['LoadError', 'load', 'loading']"
Performance,Oh wow! Let me check the performance,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3127#issuecomment-1577385126:25,perform,performance,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3127#issuecomment-1577385126,1,['perform'],['performance']
Performance,"Oh, it looks good, it would be interesting to perform some complex operation and see if we get a speedup",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694026789:46,perform,perform,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694026789,1,['perform'],['perform']
Performance,"Ok I think I figured it out. The `Float64` values are coming in from functions like `depthᶜᶜᶠ` and `height_above_bottomᶜᶜᶠ`. The main issue is actually the grid coordinates not being fully `Float32`. In particular, when coordinates like `grid.zᵃᵃᶜ` are ranges the reference and step size are `Float64`:. ```julia; julia> r = range(0.0f0, 1.0f0, 16); 0.0f0:0.06666667f0:1.0f0. julia> typeof(r); StepRangeLen{Float32, Float64, Float64, Int64}; ```. You can force it to be `Float32` via:. ```julia; julia> rr = StepRangeLen{Float32, Float32, Float32, Int}(r); 0.0f0:0.06666667f0:1.0f0. julia> typeof(rr); StepRangeLen{Float32, Float32, Float32, Int64}; ```. Doing this in `grid_coordinates.jl` fixes the MWE. Curiously this behavior of `range` is not mentioned in the docs for `range` or `StepRangeLen` but is discussed on the [Julia Discourse](https://discourse.julialang.org/t/the-type-of-a-range-step-defined-as-float32-changes-to-float64/27411). Well looks like it was briefly mentioned in the `StepRangeLen` docstring in 2019. The step size being twice the precision is supposed to help with rounding errors. But maybe on the GPU it can do more harm than good?. I can see how this leads to type promotion to `Float64` but I'm not totally sure how having a `Float64` reference and step size leads to illegal memory accesses. I'm also surprised that this issue never cropped up before. On another note, I wonder if this had any impact on performance. I'm curious to do some benchmarking before and after this change.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445532635:1438,perform,performance,1438,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445532635,1,['perform'],['performance']
Performance,"Ok here's something simple:. ```julia; using Oceananigans; using BenchmarkTools. grid = RectilinearGrid(CPU(), size=(128, 128, 1), x=(0, 2π), y=(0, 2π), z=(0, 1)); model = NonhydrostaticModel(; grid, advection=WENO()). function lots_of_steps!(model, Δt, steps=100); for _ = 1:steps; time_step!(model, Δt); end; end. @btime lots_of_steps!(model, 0.01); ```. Here's what I've done:. * Run this on fresh clone of `main`. This returns. ```julia; julia> include(""../simple_benchmark.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; 20.460 s (144483404 allocations: 94.43 GiB); ```. * Restrict compat on KernelAbstractions to 0.7.2 and CUDAKernels to 0.3.3. This returns:. ```julia; julia> include(""../simple_benchmark.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; 2.202 s (118604 allocations: 52.20 MiB); ```. I'm running on a single core, Mac M1. Here the performance loss is just 10x so I'll change the somewhat dramatic title of this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481304842:917,perform,performance,917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481304842,2,['perform'],['performance']
Performance,"Ok, a bit better now!. The following uses some lower-level Oceananigans functions and `KernelFunctionOperation`. I suspect this is a bit more performant, but I'm not sure. The main reason is that I think our broadcasting machinery has some overhead right now, so writing `field .= op` is not all that cheap (we can fix this, but it might take some work). @iuryt if you have the chance to benchmark different solutions, it'd be interesting to hear what works best!. The main downside of this solution is that we need to understand the staggered grid to implement it. Maybe not too onerous (@simone-silvestri thinks I should give users more credit), but part of me feels like we should be able to auto-magic our way around this. The main barrier to using abstract operations here is figuring out how to implement this function with a `ConditionalOperation` (and also having `<` as a valid `BinaryOperation`, eg figuring out #2169). I also like the following because it's the first known example of `auxiliary_fields` being used. Hooray for that! Also I realized that we can just use a linear stratification which is nice. I made the shear stronger to increase the drama. Working on this helped uncover a few wrinkles in the user API:. * `closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=κᵇ)` doesn't work (#2342); * `HydrostaticFreeSurfaceModel(; velocities=velocities)` doesn't work (#2341). ```julia; using Oceananigans; using Oceananigans.Units; using Oceananigans.Operators; using GLMakie. # A bit of code...; @inline f²(i, j, k, grid, f, args...) = @inbounds f(i, j, k, grid, args...)^2. @inline function Riᶜᶜᶜ(i, j, k, grid, U, b); N² = ℑzᵃᵃᶜ(i, j, k, grid, ∂zᶜᶜᶠ, b); S²u = ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u); S²v = ℑyzᵃᶜᶜ(i, j, k, grid, f², ∂zᶜᶠᶠ, U.v); S² = S²u + S²v; return ifelse(S² == 0, zero(eltype(grid)), N² / S²); end. grid = RectilinearGrid(size=128, z=(-100, 0), halo=3, topology=(Flat, Flat, Bounded)); fake_model = HydrostaticFreeSurfaceModel(; grid, trac",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066093967:142,perform,performant,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066093967,1,['perform'],['performant']
Performance,"Ok, so if we shouldn't be using KernelAbstractions for performance on CPU, then I think this means we should write our own CPU infrastructure stuff and rely on KA only for GPU? Is that what you recommend?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481472066:55,perform,performance,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481472066,1,['perform'],['performance']
Performance,"Ok. That makes sense, since CPU is not our goal; we can accept some loss of performance on CPU in order to simplify the code. The other question is why we are not implementing this in PencilArrays / PencilFFTs. Having an independent implementation may not be the best practice (we want to be good open source community members), but could be justified, maybe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727562842:76,perform,performance,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727562842,2,['perform'],['performance']
Performance,"Ok. The case where I think `SumOfFields` could be needed is if one runs into parameter space issues if its embedded into a tendency kernel function on the GPU. This is a compilation issue that is very hard to fix (performance problems, on the other hand, should be fixable).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2269566739:214,perform,performance,214,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2269566739,1,['perform'],['performance']
Performance,"Okay interesting!. I'm not sure why you would need `gcc`. Have you tried omitting that?. Also, did you try installing julia yourself? There could be some benefit in using the system Julia via `module load julia/1.9.2`, but this would mostly have to do with compilation speed (not execution speed) I think. If you have found discrepancy between the system Julia vs your own Julia install that'd be interesting to hear about... You could also let julia handle netcdf --- again, I'm not sure if this would have performance implications or not, but it might provide faster way to get up and running if you are simply trying to run scripts. Julia's package manager should be able to automatically detect and install netcdf appropriate for the system, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258884823:200,load,load,200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258884823,4,"['load', 'perform']","['load', 'performance']"
Performance,On Satori using stupidly large meshes gives 85% - 89% efficiency going from 1 to 2 GPU for the `multi_region_turbulence.jl` benchmark (Note `1440×600×48` is the size of the 1/4 degree simulation); Unfortunately the efficiency decreases on a larger number of GPUs... we definitely have to fix the scaling. #### Strong Scaling; | Grid size | Grid | GPUs | wall time | efficiency |; | -- | -- | -- | -- | -- |; | `1024×1024×100`| `RectilinearGrid` | 1 | 3.4 minutes | 100% |; | `1024×1024×100`| `MultiRegionGrid` | 2 | 1.9 minutes | 89.5% | ; | `1440×600×48`| `RectilinearGrid` | 1 | 1.4 minutes | 100% |; | `1440×600×48`| `MultiRegionGrid` | 2 | 49.2 seconds | 85.4% |; | `1440×600×48`| `MultiRegionGrid` | 3 | 38.8 seconds | 72.2% |. Going to smaller meshes than these hampers the efficiency incredibly. I think there might be a lot of low hanging fruits to optimize multi GPU,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116489219:857,optimiz,optimize,857,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116489219,1,['optimiz'],['optimize']
Performance,"PU │ 256 │ (Periodic, Bounded, Bounded) │ 25.185 ms │ 25.761 ms │ 25.702 ms │ 25.865 ms │ 29.56 KiB │ 629 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 9.832 ms │ 10.689 ms │ 10.631 ms │ 10.849 ms │ 13.06 KiB │ 290 │; └───────────────┴─────┴───────────────────────────────┴───────────┴───────────┴───────────┴───────────┴───────────┴────────┘; ```. ### CPU to GPU speedup. ```; Fourier-tridiagonal Poisson solver CPU -> GPU speedup; ┌─────┬───────────────────────────────┬─────────┬─────────┬─────────┐; │ Ns │ Topologies │ speedup │ memory │ allocs │; ├─────┼───────────────────────────────┼─────────┼─────────┼─────────┤; │ 256 │ (Bounded, Bounded, Bounded) │ 50.4045 │ 21.5194 │ 32.4444 │; │ 256 │ (Bounded, Periodic, Bounded) │ 51.2039 │ 15.8992 │ 23.2963 │; │ 256 │ (Periodic, Bounded, Bounded) │ 52.4472 │ 15.8992 │ 23.2963 │; │ 256 │ (Periodic, Periodic, Bounded) │ 99.4371 │ 6.48062 │ 10.7407 │; └─────┴───────────────────────────────┴─────────┴─────────┴─────────┘; ```. ### Relative performance on the CPU. ```; Fourier-tridiagonal Poisson solver relative performance (CPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬──────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼──────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.58185 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.24529 │ 0.922481 │ 1.0 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.27117 │ 0.922481 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴──────────┴────────┘; ```. ### Relative performance on the GPU. ```; Fourier-tridiagonal Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼──────────────────",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:8232,perform,performance,8232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050,1,['perform'],['performance']
Performance,"PUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:79; [10] compile; @ ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:74 [inlined]; [11] #1145; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/compilation.jl:250 [inlined]; [12] JuliaContext(f::CUDA.var""#1145#1148""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}}; kwargs::@Kwargs{}); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:34; [13] JuliaContext(f::Function); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:25; [14] compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/compiler/compilation.jl:249; [15] actual_compilation(cache::Dict{Any, CuFunction}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::typeof(CUDA.compile), linker::typeof(CUDA.link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/execution.jl:237; [16] cached_compilation(cache::Dict{Any, CuFunction}, src::Core.MethodInstance, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::Function, linker::Function); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/execution.jl:151; [17] macro expansion; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:380 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] cufunction(f::typeof(Oceananigans.Models.NonhydrostaticModels.gpu_compute_Gu!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(10, 10, 10)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 10)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, ImmersedBoundaryGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Periodic, Bounded, Rectilinear",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2428001700:7852,cache,cache,7852,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2428001700,1,['cache'],['cache']
Performance,"Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics/math.jl:5; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /home/tomas/.julia/compiled/v1.6/CUDA/jl_q4lPlx.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; [7] include; @ ./Base.jl:386 [inlined]; [8] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [9] top-level scope; @ none:1; [10] eval; @ ./boot.jl:360 [inlined]; [11] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [12] top-level scope; @ none:1; in expression starting at /home/tomas/repos/Oceananigans.jl/src/Oceananigans.jl:1; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /home/tomas/.julia/compiled/v1.6/Oceananigans/jl_psrPk0.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371:2294,load,loading,2294,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371,1,['load'],['loading']
Performance,"Perhaps we could convert to this: https://github.com/DTolm/VkFFT which supports hardware-accelerated FFT on CUDA, Metal and lots of others. It looks like that library is more performant than `cuFFT` as well.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734214155:175,perform,performant,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734214155,1,['perform'],['performant']
Performance,"Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisi...; 763 0 @Oceananigans/src/Advection/weno_fifth_order.jl 211 left_biased_interpolate_xᶠᵃᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisi...; 768 0 @Oceananigans/src/Advection/topologically_conditional_interpolation.jl 36 _right_biased_interpolate_xᶠᵃᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci...; 768 0 @Oceananigans/src/Advection/upwind_biased_advective_fluxes.jl 49 overdub; 781 0 @Oceananigans/src/Simulations/run.jl 127 run!(sim::Simulation{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.Offs...; 781 0 @Base/boot.jl 360 eval; 781 0 @Base/loading.jl 1116 include_string(mapexpr::typeof(identity), mod::Module, code::String, filename::String); 781 0 @Base/loading.jl 1170 _include(mapexpr::Function, mod::Module, _path::String); 781 0 @Base/Base.jl 386 include(mod::Module, _path::String); 781 0 @Base/client.jl 285 exec_options(opts::Base.JLOptions); 781 0 @Base/client.jl 485 _start(); 796 796 @Cassette/src/context.jl ? overdub; 821 0 @Oceananigans/src/Advection/topologically_conditional_interpolation.jl 36 _right_biased_interpolate_yᵃᶠᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci...; 821 0 @Oceananigans/src/Advection/upwind_biased_advective_fluxes.jl 85 overdub; 860 860 @KernelAbstractions/src/compiler/contract.jl 18 sub_float_contract; 860 0 @KernelAbstractions/src/compiler.jl 46 overdub; 873 0 @Oceananigans/src/Advection/weno_fifth_order.jl 148 overdub; 879 0 @Oceananigans/src/Operators/difference_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846:31141,load,loading,31141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846,1,['load'],['loading']
Performance,"Possibly, we should start using a merge queue that would disallow PRs from being merged unless tests pass.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867019151:40,queue,queue,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867019151,1,['queue'],['queue']
Performance,"Preferences are loaded by the `climacommon` module, which has seen a new release over the past few months. This release was to move to Julia 1.11 and there was no change with respect to the preferences. . In general, you shouldn't set any preference when running on the Caltech clusters because everything is set for you by the module system.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3897#issuecomment-2455064613:16,load,loaded,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3897#issuecomment-2455064613,1,['load'],['loaded']
Performance,Probably race condition with apply regionally then. Cc @simone-silvestri,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1298402412:9,race condition,race condition,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1298402412,1,['race condition'],['race condition']
Performance,"Probably the easiest thing to do is to fork `LambertW.jl` and remove that warning. The rest seems ok, though a max iterations of 1000 seems a bit high if you want performance. It depends what you want, but as a hack you can return a NaN upon non-convergence rather than throwing a warning.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1904993244:163,perform,performance,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1904993244,1,['perform'],['performance']
Performance,"Profiling is a very good idea. It probably makes sense to use an integrated / application profiler (rather than simply timing functions), because WENO5 is itself composed of many small functions and we don't know which one is the bottleneck. I have never tried profiling on the GPU, but there's some info here: https://juliagpu.gitlab.io/CUDA.jl/development/profiling/. Specifically I think we need to install NSight: https://juliagpu.gitlab.io/CUDA.jl/development/profiling/#NVIDIA-Nsight-Systems",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868829956:230,bottleneck,bottleneck,230,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868829956,2,['bottleneck'],['bottleneck']
Performance,"Quickly benchmarked stepping the simulation and as setup in `test/test_biogeochemistry_npzd.jl` (just realized this is incorrectly named) got:; ```; BenchmarkTools.Trial: 3359 samples with 1 evaluation.; Range (min … max): 1.162 ms … 11.420 ms ┊ GC (min … max): 0.00% … 62.52%; Time (median): 1.324 ms ┊ GC (median): 0.00%; Time (mean ± σ): 1.479 ms ± 842.222 μs ┊ GC (mean ± σ): 5.25% ± 7.80%. ▇█▆▄▃▂▂▁ ▁; ████████▇▆▆▅▄▁▃▁▁▃▃▁▃▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▄▆▆ █; 1.16 ms Histogram: log(frequency) by time 7.82 ms <. Memory estimate: 1.52 MiB, allocs estimate: 2522. ```; And in `test/test_biogeochemistry_tracer_based.jl`got:; ```; BenchmarkTools.Trial: 978 samples with 1 evaluation.; Range (min … max): 2.071 ms … 77.292 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 3.359 ms ┊ GC (median): 0.00%; Time (mean ± σ): 5.091 ms ± 4.405 ms ┊ GC (mean ± σ): 5.49% ± 10.75%. ▄▂▃▃█▃ ; ███████▄▃▂▂▂▂▁▁▁▂▂▂▂▂▂▂▁▁▁▂▂▃▄▅▄▅▃▃▃▃▃▃▂▂▂▂▂▁▂▂▂▁▁▁▁▁▁▁▁▁▂ ▃; 2.07 ms Histogram: frequency by time 18.3 ms <. Memory estimate: 3.84 MiB, allocs estimate: 6731.; ```; So there seems to be a lot of room for optimization in how I've written `TracerBasedBiogeochemistry`. The difference when I just benchmarked `time_step!` was slightly less but still ∼2x slower. (Time to increment stop_iteration by 1 and run! after doing that for an initial step)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311928286:1096,optimiz,optimization,1096,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311928286,1,['optimiz'],['optimization']
Performance,"Re-posting from #3026... that PR solved performance problems with `NonhydrostaticModel`, but `HydrostaticFreeSurfaceModel` is still 2x slower roughly than when using KA 0.7.2. Here's a simple benchmark:. ```julia; using Oceananigans; using BenchmarkTools. grid = RectilinearGrid(CPU(), size=(128, 128, 1), x=(0, 2π), y=(0, 2π), z=(0, 1), topology=(Periodic, Periodic, Bounded)); model = HydrostaticFreeSurfaceModel(; grid, momentum_advection=WENO(), tracer_advection=WENO()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ). function lots_of_steps!(model, Δt, steps=100); for _ = 1:steps; time_step!(model, Δt); end; end. @btime lots_of_steps!(model, 0.01); ```. Results. ```; 10.220 s (85845109 allocations: 37.94 GiB) # main; 6.284 s (66184308 allocations: 16.31 GiB) # main with KA downgraded to 0.7.2; ```. cc @simone-silvestri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1482198037:40,perform,performance,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1482198037,2,['perform'],['performance']
Performance,"Recently, I treid running this example with the change to the environment and now get an error. See below. This is more of a problem as no mp4 file is created. . @ali-ramadhan any suggestions on how to fix this? . One option is not using `Plots.jl`, but is that what people might want to consider?. ```; ERROR: LoadError: failed process: Process(`/home/fpoulin/.julia/artifacts/7f40eeb66d90d3026ae5fb68761c263b57adb840/bin/ffmpeg -v 16 -framerate 15 -i /tmp/jl_CtisJw/%06d.png -vf format=yuv420p -loop 0 -y /scratch/fpoulin/software/Oceananigans.jl/examples/one_dimensional_diffusion.mp4`, ProcessExited(1)) [1]. Stacktrace:; [1] pipeline_error; @ ./process.jl:525 [inlined]; [2] run(::Cmd; wait::Bool); @ Base ./process.jl:440; [3] run; @ ./process.jl:438 [inlined]; [4] (::FFMPEG.var""#4#6""{Cmd})(command_path::String); @ FFMPEG ~/.julia/packages/FFMPEG/OUpap/src/FFMPEG.jl:112; [5] (::JLLWrappers.var""#2#3""{FFMPEG.var""#4#6""{Cmd}, String})(); @ JLLWrappers ~/.julia/packages/JLLWrappers/bkwIo/src/runtime.jl:49; [6] withenv(::JLLWrappers.var""#2#3""{FFMPEG.var""#4#6""{Cmd}, String}, ::Pair{String, String}, ::Vararg{Pair{String, String}, N} where N); @ Base ./env.jl:161; [7] withenv_executable_wrapper(f::Function, executable_path::String, PATH::String, LIBPATH::String, adjust_PATH::Bool, adjust_LIBPATH::Bool); @ JLLWrappers ~/.julia/packages/JLLWrappers/bkwIo/src/runtime.jl:48; [8] #invokelatest#2; @ ./essentials.jl:708 [inlined]; [9] invokelatest; @ ./essentials.jl:706 [inlined]; [10] #ffmpeg#7; @ ~/.julia/packages/JLLWrappers/bkwIo/src/products/executable_generators.jl:7 [inlined]; [11] ffmpeg; @ ~/.julia/packages/JLLWrappers/bkwIo/src/products/executable_generators.jl:7 [inlined]; [12] #exe#2; @ ~/.julia/packages/FFMPEG/OUpap/src/FFMPEG.jl:111 [inlined]; [13] ffmpeg_exe; @ ~/.julia/packages/FFMPEG/OUpap/src/FFMPEG.jl:123 [inlined]; [14] buildanimation(anim::Animation, fn::String, is_animated_gif::Bool; fps::Int64, loop::Int64, variable_palette::Bool, verbose::Bool, show_msg::Bool); @",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657#issuecomment-866922873:311,Load,LoadError,311,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657#issuecomment-866922873,1,['Load'],['LoadError']
Performance,"Reductions on FieldTimeSeries are performed individually for each element by constructing two Fields and reducing one into another. Probably, the construction of the individual field is what is causing the loss in performance?; We do not necessarily need to do that, we can just wrap the data in a `ConditionalOperation`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3750#issuecomment-2322204413:34,perform,performed,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3750#issuecomment-2322204413,2,['perform'],"['performance', 'performed']"
Performance,"Right! The CPU -> GPU speed up has limited value, because the CPU is not a good reference / is not optimized. More useful would be a comparison with other models, somehow, but this is always challenging, especially for complicated models. Another useful piece of information would compare performance for difference GPUs. This blog post (which advertises the advantages of liquid cooled GPUs) is relevant and includes some Oceananigans benchmarks:. https://www.markiiisys.com/blog/liquid-cooled-workstation-advantageous-for-big-ocean-simulations-exceptional-for-small-tasks-oregon-state-mark-iii-nvidia-supermicro/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3684#issuecomment-2272422585:99,optimiz,optimized,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3684#issuecomment-2272422585,2,"['optimiz', 'perform']","['optimized', 'performance']"
Performance,"Running with `--check-bounds=yes` on the CPU provides a strong hint:. ```; at index [39914881, -59303136, 54]; ```. Yeah that'll do it lol. ---. ```; [ Info: Iteration 1...; [ Info: Iteration 2...; ERROR: LoadError: BoundsError: attempt to access 109×208×68 OffsetArray(::Array{Float64, 3}, -3:105, -3:204, -3:64) with eltype Float64 with indices -3:105×-3:204×-3:64 at index [39914881, -59303136, 54]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:422 [inlined]; [4] getindex; @ ~/atdepth/Oceananigans.jl/src/Fields/field.jl:401 [inlined]; [5] _interpolate; @ ~/atdepth/Oceananigans.jl/src/Fields/interpolate.jl:295 [inlined]; [6] interpolate; @ ~/atdepth/Oceananigans.jl/src/Fields/interpolate.jl:245 [inlined]; [7] advect_particle; @ ~/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:113 [inlined]; [8] macro expansion; @ ~/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; [9] cpu__advect_particles!; @ ~/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; [10] cpu__advect_particles!(__ctx__::KernelAbstractions.CompilerMetadata{…}, particles::StructArrays.StructVector{…}, restitution::Float64, grid::LatitudeLongitudeGrid{…}, Δt::Float64, velocities::@NamedTuple{…}); @ Oceananigans.Models.LagrangianParticleTracking ./none:0; [11] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.NoDynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; [12] __run(obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstracti",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852#issuecomment-2427969795:205,Load,LoadError,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852#issuecomment-2427969795,1,['Load'],['LoadError']
Performance,"RvJ/ext/TaylorSeriesIAExt.jl:182; [2] include; @ ./Base.jl:495 [inlined]; [3] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::Nothing); @ Base ./loading.jl:2222; [4] top-level scope; @ stdin:3; in expression starting at /Users/navid/.julia/packages/TaylorSeries/2qRvJ/ext/TaylorSeriesIAExt.jl:1; in expression starting at stdin:3; ┌ Error: Error during loading of extension TaylorSeriesIAExt of TaylorSeries, use `Base.retry_load_extensions()` to retry.; │ exception =; │ 1-element ExceptionStack:; │ Failed to precompile TaylorSeriesIAExt [ed7ef945-33a4-511e-97fe-2b89c7a130ca] to ""/Users/navid/.julia/compiled/v1.10/TaylorSeriesIAExt/jl_TNauRw"".; │ Stacktrace:; │ [1] error(s::String); │ @ Base ./error.jl:35; │ [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); │ @ Base ./loading.jl:2468; │ [3] compilecache; │ @ ./loading.jl:2340 [inlined]; │ [4] (::Base.var""#968#969""{Base.PkgId})(); │ @ Base ./loading.jl:1974; │ [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; │ [6] #mkpidlock#6; │ @ ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; │ [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; │ [8] #invokelatest#2; │ @ ./essentials.jl:894 [inlined]; │ [9] invokelatest; │ @ ./essentials.jl:889 [inlined]; │ [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); │ @ Base ./loading.jl:2983; │ [11] maybe_cachefile_lock; │ @ ./loading.jl:2980 [inlined]; │ [12] _require(pkg::Base.PkgId",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:1292,load,loading,1292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"Same tests performed on an **Immersed** grid with a random bathymetry (i.e. roughly 50% of the cells are immersed); on main:. ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true,; bathymetry = random_bathymetry()); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 20.150 ms … 21.143 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 20.174 ms ┊ GC (median): 0.00%; Time (mean ± σ): 20.384 ms ± 428.856 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. █▁ ▁ ▁; ██▁▁▁▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 20.1 ms Histogram: frequency by time 21.1 ms <. Memory estimate: 482.09 KiB, allocs estimate: 407. julia> trial1 = run_model_benchmark!(tracer_kernel_test, GPU();; use_benchmarktools = true,; bathymetry = random_bathymetry()); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 9.614 ms … 10.272 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 9.717 ms ┊ GC (median): 0.00%; Time (mean ± σ): 9.797 ms ± 271.120 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. █ █ █ █ █; █▁█▁▁▁▁▁▁█▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 9.61 ms Histogram: frequency by time 10.3 ms <. Memory estimate: 89.45 KiB, allocs estimate: 320. ```. on this branch:; ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true,; bathymetry = random_bathymetry()); trial1 = run_model_benchmark!(momentum_kernel_test, arch; use_benchmarktools = true, bottom_height = random_bathymetry()) = Trial(13.991 ms); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 13.991 ms … 22.167 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 14.057 ms ┊ GC (median): 0.00%; Time (mean ± σ): 15.676 ms ± 3.629 ms ┊ GC (mean ± σ): 0.00% ± 0.00%. █; █▇▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▇ ▁; 14 ms Histogram: f",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3658#issuecomment-2243530643:11,perform,performed,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658#issuecomment-2243530643,1,['perform'],['performed']
Performance,Seems to work:. ```; [2021/06/25 18:04:55.066] INFO Writing Advection_schemes_relative_performance_(CPU).html...; Advection schemes relative performance (GPU); ┌───────────────┬────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Schemes │ slowdown │ memory │ allocs │; ├───────────────┼────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ CenteredFourthOrder │ 1.36629 │ 1.07711 │ 1.66944 │; │ GPU │ CenteredSecondOrder │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ UpwindBiasedFifthOrder │ 1.53522 │ 1.11266 │ 1.9781 │; │ GPU │ UpwindBiasedThirdOrder │ 1.31322 │ 1.03505 │ 1.30432 │; │ GPU │ WENO5 │ 1.84272 │ 1.1889 │ 2.64008 │; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-868903511:141,perform,performance,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-868903511,1,['perform'],['performance']
Performance,"Settled on the code below. ```julia; struct SpatialWindowAverage{F, S, D} ; field :: F; field_slicer :: S; dims :: D; end. SpatialWindowAverage(field; dims, field_slicer=FieldSlicer()) = SpatialWindowAverage(field, field_slicer, dims). function (wsa::SpatialWindowAverage)(model); compute!(wsa.field); window = view(data(wsa.field), wsa.field_slicer.i, wsa.field_slicer.j, wsa.field_slicer.k); return mean(window, dims=wsa.dims); end; ```. Which constructs an object fine, but it doesn't work when outputting. I can call `compute!` on it, but really it doesn't do anything. When including it to a `NetCDFWriter` I get this error:. <details>; <summary>Click to expand!</summary>. ```; ERROR: LoadError: Custom output Us needs dimensions!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::SpatialWindowAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64}}, ::String, ::Type{T} where T, ::Int64, ::Tuple{}, ::Dict{Any,Any}) at /home/tomas/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:357; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :b),Tuple{Fie",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170:691,Load,LoadError,691,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170,1,['Load'],['LoadError']
Performance,Should we also expect the MG preconditioner to perform similarly to the FFT-based preconditioner? Those are relatively similar algorithms. How many CG iterations are we performing for either?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2728#issuecomment-1238512157:47,perform,perform,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2728#issuecomment-1238512157,2,['perform'],"['perform', 'performing']"
Performance,"Should we also try things like. ```julia; node(i, j, k, grid, ::Nothing, ℓy, ℓz) = _node(i, j, k, grid, nothing, ℓy, ℓz)[1:2]; ```. I think we determined there could be a tiny performance loss but it would make the code a little simpler and also easier to read since we don't have to define every combination of locations for `_node`. I still want to clean up and streamline `xspacings` and `xnodes` (etc) so that they use `xnode` directly (rather than ""re-implementing"" the nodes) but that'll have to wait for another PR I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1775504750:176,perform,performance,176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1775504750,2,['perform'],['performance']
Performance,"Since there's no performance benefit, I'm closing this. We can revisit `heuristic_workgroup` in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-958088865:17,perform,performance,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-958088865,1,['perform'],['performance']
Performance,"Since we need the performance provided by KA 0.7, and we need to use KA 0.8+ on GPU, does that mean that we should invest in developing our own CPU infrastructure (replicating what KA 0.7 offered) to achieve that performance?. Another possibility is that we re-write much of the code base to avoid the performance pitfalls we are currently facing in order to get back to the level of performance we have with current code + KA 0.7. I believe the issue is basically an interaction between some of the abstractions / indirection we have developed and the compiler, so possibly rolling back that abstraction / indirection will bring us back to where we were previously.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481707882:18,perform,performance,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481707882,4,['perform'],['performance']
Performance,"So I reduced my code to be just; ```; using Oceananigans; ```; and the code gave the following error; ```; [20610] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA_Runtime_jll/YgJCI/.pkg/platform_augmentation.jl:283; Allocations: 2907 (Pool: 2898; Big: 9); GC: 0; ERROR: LoadError: Failed to precompile CUDA_Runtime_jll [76a88914-d11a-5bdc-97e0-2f5a05c973a2] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA_Runtime_jll/jl_FIXMhf"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6 ; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] inv",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:327,Load,LoadError,327,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,4,"['Load', 'load']","['LoadError', 'loading']"
Performance,"So in this I've got a load of `update_tendencies!` being called, and adding `synchronize(device(architecture(model)))` at the end appears to have fixed this. To summarise: ; - `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)` error; - Resolved by manually synchronizing the device with `synchronize(device(architecture(model)))`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721361808:22,load,load,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721361808,1,['load'],['load']
Performance,So there is a performance issue with the FFT? How does `PencilFFTs` scale when run stand-alone?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1948#issuecomment-902786645:14,perform,performance,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1948#issuecomment-902786645,1,['perform'],['performance']
Performance,"So, I'm hitting some errors running the `baroclinic_adjustment` example with the ROCBackend. The only modification of this example script is the specification of the architecture as `GPU()`. It seems that this chokes on AMDGPU's `zeros`. I did not encounter this in the other work I was doing on Simone's branch; though the test we were using was not building with a recilinear grid. ```; $ julia --project=. ./bench/baroclinic_adjustment.jl ; ERROR: LoadError: Not implemented; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] runtime_module(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/interface.jl:173; [3] build_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:101; [4] (::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}})(); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:139; [5] lock(f::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}, l::ReentrantLock); @ Base ./lock.jl:229; [6] macro expansion; @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:86 [inlined]; [11] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:129; [12] ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273:451,Load,LoadError,451,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273,1,['Load'],['LoadError']
Performance,"Some of the lessons over on https://github.com/CliMA/Oceananigans.jl/issues/2024 could warrant using an object after all. The reason is a bit technical... but because of how the compiler works, we have. ```julia; julia> using Oceananigans.AbstractOperations: Δx. julia> using Oceananigans. julia> grid = RegularRectilinearGrid(size=(2, 2, 2), extent=(1, 1, 1));. julia> u = XFaceField(grid);. julia> udx1 = u / Δx; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=2); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; / at (Face, Center, Center);    ├── Field located at (Face, Center, Center);    └── Δxᶠᶜᵃ at (Face, Center, Center). julia> udx2 = u / Δx; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=2); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; / at (Face, Center, Center);    ├── Field located at (Face, Center, Center);    └── Δxᶠᶜᵃ at (Face, Center, Center). julia> udx1 === udx2; false; ```. The reason we get different types is because of the different ""identity"" functions introduced in. https://github.com/CliMA/Oceananigans.jl/blob/6dcf6ffd1fdb2febaf0d20dfab85ef1d3f83d758/src/Operators/interpolation_utils.jl#L29-L66. which we do to avoid the compiler from detecting recursion during compilation. A few things to digest here but basically we want to cache the operations `u / Δx`, etc because reforming them for every calculation may incur high compilation costs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958994106:1484,cache,cache,1484,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958994106,1,['cache'],['cache']
Performance,"Some pretty promising Lagrangian particle tracking benchmarks!. Couple of takeaways (all assuming a model with 128^3 grid points and QAB2 time stepping):; 1. **Low overhead**: You can advect up to ~100,000 particles on the CPU and up to ~10,000,000 particles on a (Titan V) GPU before the model slows down by more than 30%.; 2. **Great on GPUs**: Seems that the GPU is great for advecting millions of particles. You can advect ~100,000,000 particles and your model only slows down by a factor of 4x. In this scenario, the GPU is ~620x faster than a single CPU core.; 3. Calculated using `(t_100000000 - t_0) / 100000000`, advecting a single particle on the CPU takes ~110 ns while on the GPU it only takes ~0.127 ns. This seems a little too good to be true but I'll double check this. I'll start refactoring this PR using @glwagner's and @zhenwu0728's feedback, but I think it would be really great if we can keep this performance. # Benchmarks. ```; Oceananigans v0.44.1; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23:17 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); GPU: TITAN V; ```. ```; Lagrangian particle tracking benchmarks; ┌───────────────┬─────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Architectures │ N_particles │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 0 │ 361.749 ms │ 364.041 ms │ 364.293 ms │ 368.854 ms │ 293.44 KiB │ 1876 │; │ CPU │ 1 │ 375.030 ms │ 376.591 ms │ 377.959 ms │ 385.248 ms │ 297.16 KiB │ 1906 │; │ CPU │ 10 │ 377.251 ms │ 380.792 ms │ 387.560 ms │ 443.325 ms │ 297.16 KiB │ 1906 │; │ CPU │ 100 │ 378.867 ms │ 381.194 ms │ 381.328 ms │ 383.461 ms │ 297.16 KiB │ 1906 │; │ CPU │ 1000 │ 378.076 ms │ 384.114 ms │ 383.611 ms │ 388.507 ms │ 297.16 KiB │ 1906 │; │",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732529975:919,perform,performance,919,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732529975,1,['perform'],['performance']
Performance,"Some thoughts:. The first case (`N=100`) doesn't look great but it shows that the MPData schemes do not differ very much whether we have 2 or 5 iteractions, and they are somewhere between 1st and 3rd order upwinding. The second case (`N=200`) looks better and I can't really see any difference between 2 and 5 iterations. The third case (`N=400`) has all the schemes performing well, even first order upwinding. Again we can't differentiate between the two MPData schemes and it's even hard to differentiate between 3rd and 5th order upwinding. I lesson that I learned from here is to use as much spatial resolution as we can as this does much more compared to the number of iterations. . @simone-silvestri : do you think we should do a similar comparison for 2D advection?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1954430883:367,perform,performing,367,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1954430883,2,['perform'],['performing']
Performance,"Something related with the boundary conditions of the loaded saved `b` perhaps?. E.g., . ```julia; julia> b_timeseries[10]; Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (128, 1, 64); ├── grid: RegularRectilinearGrid{Float64, Bounded, Flat, Bounded}(Nx=128, Ny=1, Nz=64); └── boundary conditions: JLD2.ReconstructedTypes.var""##NamedTuple{(:x, :y, :z),Tuple}#261""(CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}(BoundaryCondition: type=ZeroFlux, condition=nothing, BoundaryCondition: type=ZeroFlux, condition=nothing), CoordinateBoundaryConditions{Nothing, Nothing}(nothing, nothing), JLD2.ReconstructedTypes.var""##CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Value,Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center,Center,Nothing,64,Main.#bₛ,Nothing,Tuple{},Tuple{},Tuple{}}}}#262""()); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-878829232:54,load,loaded,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-878829232,1,['load'],['loaded']
Performance,Sometimes tests fail to load. Merely restarting them does the job. Did that. Let’s see.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2733#issuecomment-1252866889:24,load,load,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2733#issuecomment-1252866889,1,['load'],['load']
Performance,"Sorry I didn't realize I didn't get the full error message:; ```; [52922] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:129; Allocations: 618273 (Pool: 617476; Big: 797); GC: 1; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2300; [3] compilecache; @ ./loading.jl:2167 [inlined]; [4] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1805; [5] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1660; [6] macro expansion; @ ./loading.jl:1648 [inlined]; [7] macro expansion; @ ./lock.jl:267 [inlined]; [8] require(into::Module, mod::Symbol); @ Base ./loading.jl:1611; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; ```; The versioninfo gave me the following as output:; ```; Julia Version 1.9.2; Commit e4ee485e90 (2023-07-05 09:39 UTC); Platform Info:; OS: Linux (x86_64-suse-linux); ""openSUSE Leap 15.4""; uname: Linux 5.14.21-150400.24.46-default #1 SMP PREEMPT_DYNAMIC Thu Feb 9 08:38:18 UTC 2023 (2d95137) x86_64 x86_64; CPU: Intel(R) Xeon(R) Gold 6240 CPU @ 2.60GHz: ; speed user nice sys idle irq; #1-72 2600 MHz 922553194 s 727867 s 363212152 s 5414020342 s 0 s; Memory: 370.290340423584 GB (301775.56640625 MB free); Uptime: 9.37897786e6 sec; Load Avg: 13.61 25.96 27.94; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-14.0.6 (ORCJIT, cascadelake); Threads: 1 on 72 virtual cores; Environment:; LD_LIBRARY_PATH = /glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1/dgcv/lib:/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64:/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:278,Load,LoadError,278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,7,"['Load', 'load']","['LoadError', 'loading']"
Performance,"Sorry that I didn't emphasize this but this is the initial error. ```; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Utilities/Selectors.jl:170; [4] #2 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:249 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:248 [inlined]; [7] top-level scope at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796866901:117,Load,LoadError,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796866901,1,['Load'],['LoadError']
Performance,"Sorry, you are right. You use set_num_threads. See the constructors in. https://github.com/FourierFlows/FourierFlows.jl/blob/master/src/domains.jl. On Sat, Mar 9, 2019 at 8:55 AM Ali Ramadhan <notifications@github.com>; wrote:. > Weird, I see no mention of threads or multi-threading; >; > help?> plan_fft; >; > search: plan_fft plan_fft! plan_rfft plan_ifft plan_bfft plan_ifft! plan_bfft! plan_irfft plan_brfft; >; >; >; > plan_fft(A [, dims]; flags=FFTW.ESTIMATE, timelimit=Inf); >; >; >; > Pre-plan an optimized FFT along given dimensions (dims) of arrays matching the shape and type of A. (The first two arguments have the same meaning as for fft.) Returns an object P which; >; > represents the linear operator computed by the FFT, and which contains all of the information needed to compute fft(A, dims) quickly.; >; >; >; > To apply P to an array A, use P * A; in general, the syntax for applying plans is much like that of matrices. (A plan can only be applied to arrays of the same size as the A for which; >; > the plan was created.) You can also apply a plan with a preallocated output array Â by calling mul!(Â, plan, A). (For mul!, however, the input array A must be a complex floating-point; >; > array like the output Â.) You can compute the inverse-transform plan by inv(P) and apply the inverse plan with P \ Â (the inverse plan is cached and reused for subsequent calls to inv or; >; > \), and apply the inverse plan to a pre-allocated output array A with ldiv!(A, P, Â).; >; >; >; > The flags argument is a bitwise-or of FFTW planner flags, defaulting to FFTW.ESTIMATE. e.g. passing FFTW.MEASURE or FFTW.PATIENT will instead spend several seconds (or more) benchmarking; >; > different possible FFT algorithms and picking the fastest one; see the FFTW manual for more information on planner flags. The optional timelimit argument specifies a rough upper bound on; >; > the allowed planning time, in seconds. Passing FFTW.MEASURE or FFTW.PATIENT may cause the input array A to be ov",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471179341:268,multi-thread,multi-threading,268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471179341,2,"['multi-thread', 'optimiz']","['multi-threading', 'optimized']"
Performance,"Still, we shouldn't get race condition; that's a bug.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809#issuecomment-1308175859:24,race condition,race condition,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809#issuecomment-1308175859,1,['race condition'],['race condition']
Performance,"Suggestion: If the filename loaded is, e.g., a `_part1.jld2` then it would be of interest to detail that and whether this is part1 out of X?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3859#issuecomment-2433313107:28,load,loaded,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3859#issuecomment-2433313107,1,['load'],['loaded']
Performance,"Sure!. ```; (Oceananigans) pkg> status; Project Oceananigans v0.53.0; Status `~/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v3.2.0; [052768ef] CUDA v2.4.1; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.3.2; [e9467ef8] GLMakie v0.1.30; [c27321d9] Glob v1.3.0; [033835bb] JLD2 v0.4.3; [63c18a36] KernelAbstractions v0.5.4; [da04e1cc] MPI v0.16.1; [442fdcdd] Measures v0.3.1; [85f8d34a] NCDatasets v0.11.3; [6fe1bfb0] OffsetArrays v1.6.2; [bac558e1] OrderedCollections v1.4.0; [4a48f351] PencilFFTs v0.12.2; [d330b81b] PyPlot v2.9.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [09ab397b] StructArrays v0.5.0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```. ```; ERROR: LoadError: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928:857,Load,LoadError,857,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928,1,['Load'],['LoadError']
Performance,"Sure, the PR resolves the rounding issue caused by `previous_interval_stop_time` through the use of actuations (as inspired by its application [here](https://github.com/CliMA/Oceananigans.jl/blob/dc5dc28c6cf433dcb8a6668cef99e98309e6ead9/src/Utils/schedules.jl#L58-L63)).; Here is the part of the code showing these [changes](https://github.com/CliMA/Oceananigans.jl/pull/3721/commits/a52812b00eb38e712ed20c7a6db3cf2e0c3a7877#diff-532eb4a17264dc44a7cae7601aca768c39bfb08f0493561c333f24a3261d6a46R123-R130). Another important change is that ; ```julia. # Save averaging start time and the initial data collection time; wta.window_start_time = model.clock.time; wta.window_start_iteration = model.clock.iteration; wta.previous_collection_time = model.clock.time. wta.schedule.collecting = false; wta.schedule.actuations += 1; ```. occurs only when the window ends, i.e., when `end_of_window(wta.schedule, model.clock) == true`. In contrast, the [previous version](https://github.com/CliMA/Oceananigans.jl/pull/3721/commits/a52812b00eb38e712ed20c7a6db3cf2e0c3a7877#diff-532eb4a17264dc44a7cae7601aca768c39bfb08f0493561c333f24a3261d6a46L265-L268) triggered this only when the model wasn't collecting. > I'm wondering if it makes sense that this is hard or if we should actually consider a more fundamental redesign to make it more robust... I agree that a more fundamental redesign could improve robustness in the long term. That said, the current adjustments seem to resolve the issue for now (I'll look into why certain cases aren't passing the test). We can continue to monitor its performance and consider a redesign if further issues arise.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379285570:1579,perform,performance,1579,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379285570,1,['perform'],['performance']
Performance,"Thank you @christophernhill , that is kind of you to offer and I will certainly take you up on your offer. . @hennyg888 has tried running things on 2 GPUs and has been getting an error at `Waitall!`, which is the first time that information is shared between GPUs. I hope we can look into this a bit more and then ask you about it next week. The last time that @ali-ramadhan successfully ran the distirbuted models on GPUs he found that the efficiency on 2 gpus was `50%`. Not great. We are trying to reproduce this as a starting point and when we do, it'll be nice to figure out what's causing the bottleneck. At the moment it's unknown to us but hope to start looking at this soon. We will certainly ask you about this next week!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-868677525:599,bottleneck,bottleneck,599,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-868677525,1,['bottleneck'],['bottleneck']
Performance,"Thank you for all your comments. I will try those lines; Just one question. Is the sintax of. `ΞT = randn(size(T)...) *. shape`. correct? I am getting this error message:. > Warning: No xauth data; using fake authentication data for X11 forwarding.; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: syntax: invalid identifier name "".""; Stacktrace:; [1] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197; in expression starting at /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197. Line 197 corresponds to the line above. I removed the `*.shape` and the simulations are now running. Is that ok?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962:772,Load,LoadError,772,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962,1,['Load'],['LoadError']
Performance,"Thank you for the links !. The Oceananigans src code is very clearly written so the reading is relatively OK (I could use some explanations on your closure usage). If it was up to me I would prefer an extended documentation of GPUifyLoops ;) I only understand how it works by reading what you do with it. . The GPU shared memory is basically a programmable cache while the cache of CPU can't be (easily) controlled. In both cases there is cache so, if you compute multiple partial derivatives of a given (set of) field(s) (d/dx,d/dy, d2/dx2,...) once a block has been fetched in the cache then the memory operations are cheap. Cache is also useful for performing tiny transpositions enabling fast access and vectorized (SIMD) CPU or GPU ops in both X,Y or Z directions. . I hope that obtaining an efficient code for both (multicore SIMD) CPUs and GPUs maybe possible adjusting the (recursive?) block sizes (i.e. controlling the data layout and adapt it to the computing target). I will try to use part of your code to rewrite the toy 2D CFD solver I have translated from Matlab (https://discourse.julialang.org/t/asynchronous-makie/27127/9?u=laurentplagne). Kudos again to your team for this inspiring package. Laurent",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/333#issuecomment-518372592:357,cache,cache,357,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/333#issuecomment-518372592,5,"['cache', 'perform']","['cache', 'performing']"
Performance,"Thank you for your feedback @maleadt! What is CUDAnative compilation? If you mean the precompilation phase when CUDAnative is first loaded, then it's not that as I start timing after all packages are loaded. I thought 6-7 minutes was normal/expected as @vchuravy et al. reported similar GPU compilation times for their shallow water model: https://github.com/JuliaLabs/ShallowWaterBench. I haven't done any rigorous benchmarking yet but out of those 6 minutes, ~1.5 minutes are spent on compiling code that creates CuFFT plans (the first plan takes 1.5 minutes then the others take <1 second). From watching the log I'm guessing the other 4.5 minutes are evenly split between setting up the model (creating CuArrays, initializing them, etc.) and the first time step (where the kernels are getting compiled presumably). I don't think we have that many kernels (just 5 bigger ones) but one of them; https://github.com/ali-ramadhan/Oceananigans.jl/blob/2b64d584c79ece0429f2421335ddb6bc0c6c6663/src/time_steppers.jl#L213; has several layers of inlining (it's inlining the majority of the functions in [operators/ops_regular_cartesian_grid_elementwise.jl](https://github.com/ali-ramadhan/Oceananigans.jl/blob/master/src/operators/ops_regular_cartesian_grid_elementwise.jl)) after which it probably balloons up to be a pretty big kernel. They also have tons of arguments crammed in as the structs I was passing weren't `isbitstype` (working on this #59). I should come back and update this issue once we do some proper benchmarking (note to self: nvprof seems like it's being deprecated in favor of Nsight). Caching kernels between sessions sounds tough but will definitely look into timing compilations in CUDAnative, might provide some insight on how to speed things up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/66#issuecomment-466847765:132,load,loaded,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/66#issuecomment-466847765,2,['load'],['loaded']
Performance,"Thank you to everyone who took the time to respond to this issue! I am still unclear on what exactly was driving the error I was getting, but I was able to fix it by creating a new environment in a clean directory and running the following modules on Casper for the UCAR HPC resources:; ```; module --force purge; module --ignore-cache load ncarenv/23.10 gcc ncarcompilers netcdf; module --ignore-cache load cuda; module --ignore-cache load julia/1.10.2; ```; and then running my script. Thanks again for all the help!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2256200159:330,cache,cache,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2256200159,6,"['cache', 'load']","['cache', 'load']"
Performance,"Thanks @ali-ramadhan and @navidcy . Adding `const U = 1.0` definitely seemed to help as now it has gone further. However, at this stage I believe it's complaining about the norm. Below is the beginning part of the output, in case this makes sense to others. ```; ERROR: LoadError: scalar getindex is disallowed; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] assertscalar(::String) at /home/fpoulin/.julia/packages/GPUArrays/WV76E/src/host/indexing.jl:41; [3] getindex at /home/fpoulin/.julia/packages/GPUArrays/WV76E/src/host/indexing.jl:96 [inlined]; [4] getindex at /home/fpoulin/.julia/packages/OffsetArrays/lli7H/src/OffsetArrays.jl:300 [inlined]; [5] getindex at ./subarray.jl:257 [inlined]; [6] _getindex at ./abstractarray.jl:1100 [inlined]; [7] getindex at ./abstractarray.jl:1060 [inlined]; [8] iterate at ./abstractarray.jl:986 [inlined]; [9] iterate at ./abstractarray.jl:984 [inlined]; [10] generic_normInf(::SubArray{Float64,3,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},Tuple{UnitRange{Int64},UnitRange{Int64},UnitRange{Int64}},false}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:445; [11] normInf at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:536 [inlined]; [12] generic_norm2(::SubArray{Float64,3,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},Tuple{UnitRange{Int64},UnitRange{Int64},UnitRange{Int64}},false}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:477; [13] norm2 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:538 [inlined]; [14] norm(::SubArray{Float64,3,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},Tuple{UnitRange{Int64},UnitRange{Int64},UnitRange{Int64}},false}, ::Int64) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/LinearAlgebra/src/generic.jl:607; [15] norm(::SubArray{Float64,3",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1477#issuecomment-800208000:270,Load,LoadError,270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1477#issuecomment-800208000,1,['Load'],['LoadError']
Performance,"Thanks @maleadt, that's very helpful!. In this PR, we haven't directly changed any kernel function signatures. However, this PR does pass more complicated objects into kernels (a wrapper around an `OffsetArray` called a ""`Field`"", rather than simply the `OffsetArray`). The primary changes in this PR are thus 1. _not_ to extract the underlying `OffsetArray` from a `Field`, and 2. writing an `adapt_structure` method for `Field`s. I suppose the translation that's performed by `adapt_structure` increases the number or arguments to the function `ptxcall_calculate_Gu__66`?. The changes made in this PR are not strictly necessary --- they are a convenience. If manually unwrapping `Field`s (the method we previously used) is necessitated by CUDA limitations, I think we can live with that. If I understand this issue correctly, we are facing a basic trade-off between (compiler?) performance and the use of convenient but complicated abstraction objects?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/746#issuecomment-655255987:465,perform,performed,465,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/746#issuecomment-655255987,2,['perform'],"['performance', 'performed']"
Performance,"Thanks @navidcy for the quick approval. Strangely, 3 tests have already failed. I looked at one and see that it can't find a file, see below. This is not actually related to this PR but I don't know how to fix it. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 88 seconds (199 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7768/compiled/v1.6/Oceananigans/hU93i_huVsp.ji"": No such file or directory;  ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2598#issuecomment-1146595140:388,Load,LoadError,388,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2598#issuecomment-1146595140,2,['Load'],['LoadError']
Performance,"Thanks @simone-silvestri @glwagner! I encountered a different error on CPU recently that might be related. I ran a 3D (Bounded,Bounded,Bounded) simulation with immersed boundary on CPU. When using `FieldTimeSeries` to load the JLD2 output, I get a `BoundsError` message:. ```b = FieldTimeSeries(""moving_source_complex_topography.jld2"",""b"",grid=nothing); Error showing value of type FieldTimeSeries{Center, Center, Center, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 512×512×128×10 FieldTimeSeries{Center, Center, Center, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1124607638:218,load,load,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1124607638,1,['load'],['load']
Performance,Thanks @simone-silvestri for adding a GPU test for `FieldTimeSeries`! I've adapted it correctly now and tests pass locally so I think this PR is ready for review. Actually I should add a test that uses the new kwargs. Would do a test where multiple threads open the same `FieldTimeSeries` but don't think we have multi-threaded tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2397361158:313,multi-thread,multi-threaded,313,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2397361158,1,['multi-thread'],['multi-threaded']
Performance,Thanks Simone! So I guess [this line](https://github.com/CliMA/Oceananigans.jl/blob/edef0fc49a1019bfba093ffa1c0bcce23535ac41/src/Solvers/sparse_preconditioners.jl#L70) explains why we only see a performance increase on GPU? I don't understand why ILU is hard to parallelise - would you mind explaining this?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1258832262:195,perform,performance,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1258832262,1,['perform'],['performance']
Performance,"Thanks everyone for your feedback. @vchuravy , great to know that multi-threading is built in! . I agree that profiling would be a good way to determine why we get not great efficiency. I have not used perf but we can look into it. Also, do you know of benchmarking others have done using `KernelAbstractions` on threads that we could look at for comparison?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880844335:66,multi-thread,multi-threading,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880844335,2,['multi-thread'],['multi-threading']
Performance,"Thanks for clarifying. Yes, I was thinking about being able to perform fit in any dimension you choose and save outputs like this. Putting the heavy load on the GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2178922830:63,perform,perform,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2178922830,2,"['load', 'perform']","['load', 'perform']"
Performance,"Thanks for looking through the time stepping code, this is great feedback!. I agree it would be nice to dispatch on the array type (or even the architecture, another reason to use types instead of symbols). No reason why `xC, xF, yC, ...` have no assigned type in `RegularCartesianGrid`, just oversight on my part. There will probably be a major refactor of the code's design soon-ish to get all this little stuff right. I remember fields initially had the array type be a parameter, e.g. `CellField{T}` then `data::T` but I hit some performance issues with that I think. I may have just been encountering the [Avoid fields with abstract containers](https://docs.julialang.org/en/v1/manual/performance-tips/index.html#Avoid-fields-with-abstract-containers-1) Julia performance tip, but I think making the parameter an `AbstractArray` as you're suggesting shouldn't sacrifice performance. And yes, the solver is not spectral. Will probably generically call it `PoissonSolver` when the next refactor happens (and the documentation would make it clear what it actually does).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/45#issuecomment-462783213:534,perform,performance,534,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/45#issuecomment-462783213,4,['perform'],"['performance', 'performance-tips']"
Performance,Thanks for posting the solution. What does the `ignore-cache` flag do? And how did you get to it?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2256203467:55,cache,cache,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2256203467,1,['cache'],['cache']
Performance,Thanks for running these tests. It would be nice to see how MPData performs in a 2D flow. . It's interesting that tweaking the number of iterations doesn't seem to make much difference. I'm a bit skeptical about this scheme though; it seems pretty diffusive and doesn't even beat third-order upwind which is way simpler. I might have introduced a bug although I went through the code again and it looks correct to me. Another possibility is that the high diffusivity is the trade-off for keeping the scheme positivity-preserving?; Godunov's theorem sets some tough standards -- it's not possible to obtain monotonic advection with a linear scheme beyond first order.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1954700946:67,perform,performs,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1954700946,2,['perform'],['performs']
Performance,Thanks for taking a look @glwagner! I'll open a PR to make sure we're working with `PrescribedVelocityFields` correctly. And I'll also open a second PR to start looking at cubed sphere performance + getting it working on the GPU.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-819603798:185,perform,performance,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-819603798,1,['perform'],['performance']
Performance,"Thanks for the additional changes and it seems to be doing much better! Still three tests that fail. I looked ath the initialize environments and saw what I copied below. It seems to have probelms with Oceananigans?. ```. ✗ Oceananigans; --;   | 105 dependencies successfully precompiled in 112 seconds;   | 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package;   | Precompiling project...;   | ✗ Oceananigans;   | 0 dependencies successfully precompiled in 22 seconds. 105 already precompiled.;   |  ;   | ERROR: The following 1 direct dependency failed to precompile:;   |  ;   | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];   |  ;   | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-9773/compiled/v1.8/Oceananigans/jl_yggB5x.;   | [NVBLAS] No Gpu available;   | [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf';   | [NVBLAS] Cannot open default config file 'nvblas.conf';   | [NVBLAS] Config parsed;   | [NVBLAS] CPU Blas library need to be provided;   | ERROR: LoadError: syntax: missing comma or ) in argument list;   | Stacktrace:;   | [1] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/non_traditional_beta_plane.jl:75;   | [2] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [3] include(x::String);   | @ Oceananigans.Coriolis ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:1;   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:28;   | [5] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [6] include(x::String);   | @ Oceananigans ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:5;   | [7] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:230;   | [8] include;   | @ ./Base.jl:419 [inlined];   | [9] include_package_for_output(pkg::Base.Pk",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445:396,load,load,396,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445,1,['load'],['load']
Performance,Thanks for the feedback @ranjanan !; * Instead of using `const` we went with structs.; * CuArrays have worked quite well but still working on writing performant CPU/GPU shared kernels (hoping [GPUifyLoops.jl](https://github.com/vchuravy/GPUifyLoops.jl) will help here).; * Multicore parallelism is a bit lower priority right now but have had some pretty good results with DistributedArrays although I think MPIArrays will be the way forward for us here.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2#issuecomment-462058793:150,perform,performant,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2#issuecomment-462058793,1,['perform'],['performant']
Performance,"Thansk for the quick feedback. 1. I should say this is not as much of a concern as I found a work around. In my definition of b\tilde, I changed `f` to `model.coriolis.f` and received an error. Below is the beginning and it's huge so can't copy the whole thing. I will stick to my simple solution for the moment but want to point this out, in case there was a concern. ```; include(""inertially_unstable_jet.jl""); ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 64, 64)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 64)},KernelAbstractions.NDIteration.StaticSize{(1, 64, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Fields.gpu__compute!), OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}}, Oceananigans.AbstractOperations.BinaryOperation{Center,Center,Center,typeof(-),OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}},Oceananigans.Fields.FunctionField{Center,Center,Center,Nothing,Nothing,typeof(b̄),RegularRectilinearGrid{Float64,Flat,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Flat,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); Stacktrace:; [1] b̄ at /home/fpoulin/software/Oceananigans.jl/examples/inertially_unstable_jet.jl:39; [2] call_func at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.jl:61; [3] getindex at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815099807:420,Load,LoadError,420,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815099807,1,['Load'],['LoadError']
Performance,That code allows two things that would not be possible with `maximum(parent(f.data))`. - it returns a `ReducedField` instead of an Array if `dims != :`; - it is possible to perform a conditional reduction which means that we can remove immersed cells from the reduction. It can be done in another way though if it errors... when do you find the error?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2727#issuecomment-1237038870:173,perform,perform,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2727#issuecomment-1237038870,1,['perform'],['perform']
Performance,"That is a huge leap forward @hennyg888 and great to see! Before we were at 50% and now we are at 75%. An increase of 50%, which is pretty huge all things considered. I like @christophernhill 's suggest of adding the version info. Yesterday when we talked the consensus was that one major problem was how we do buffering. As a silly experiment, what if we redo this without updating any halos, ever. Physically, it's going to be wrong but do we get another huge increase in the efficiency? If the efficiency gets close to 100% then in my mind that validate the hypothesis. If not, then that would signify there is another bottleneck that we need to hunt down.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887431593:621,bottleneck,bottleneck,621,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887431593,1,['bottleneck'],['bottleneck']
Performance,"That probably shouldn't have changed, can you file an issue on CUDA.jl/GPUArrays.jl? I'll have a look next week. The only change to `@allowscalar` that comes to mind is task/thread-safety, which does come at a certain performance cost (it now does a TLS lookup instead of a simple pointer check, but the cost of that should be negligible compared to the subsequent memory transfer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817088189:218,perform,performance,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817088189,2,['perform'],['performance']
Performance,That's awesome @simone-silvestri. Great work!. A couple of questions:. > - Design correct OutputWriters and OutputReaders for MultiRegionFields. Does this mean that the code with multi-grid doesn't have the ability to output things at the moment? Or does it output to one file per region/GPU?. > - Implement a multi-region version of the Nonhydrostatic pressure solver. So I take that a nonhydrostatic pressure solver for multi-grid isn't defined yet? Or is it just non-optimized (but will run)?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116857309:470,optimiz,optimized,470,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116857309,1,['optimiz'],['optimized']
Performance,"That's great news @ali-ramadhan . I guess by looking at your code I can learn how to adapt it to `ShallowWaterModel`. Maybe I will start by doing some tests for the two-dimensional turbulence example, or has someone done that already? By that I mean checking scalabiilty.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-786696921:259,scalab,scalabiilty,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-786696921,1,['scalab'],['scalabiilty']
Performance,"That's not expected and sounds like a huge change! The only important change I can think of is when we started pre-calculating the immersed boundary (rather than allowing it to be a function):. https://github.com/CliMA/Oceananigans.jl/blob/3557db3692ff8e1978b126369230c9bacae42ae8/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl#L70. That adds one 2D (x, y) field. The reason is because in the majority of cases this is more performant (we think). In a model with one tracer and AMD, we have something like 16 3D fields. So 25% is a huge amount of data equivalent to four 3D fields. Any ideas @simone-silvestri ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1298967328:435,perform,performant,435,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1298967328,1,['perform'],['performant']
Performance,"That's right. Purely for simplicity we launch all the tendency kernels from 1:N, though for Face-fields in Bounded directions, we only require 2:N. In fact using tendencies only from 2:N could allow an optimization where we don't need to ""enforce"" no-penetration boundary conditions. It'd be hard to achieve this optimization though because users can write things like `parent(u) .= 1` so I'm not sure we can get away with this being guaranteed correct. This has never been a problem because we simply overwrite the boundary velocity and therefore simply discard the tendency at index 1. > The problem is if we try to integrate something like a radiation condition. Can you point me to where in the code this goes down?. > On bounded topology I don't think we ever want to integrate the tendency right? But it might be more complicated to do that. I think that's right that we don't need the tendency. This has been part of the algorithm since time immemorial and back in the mists of time it was indeed more complicated than worthwhile. The complication is that KernelAbstractions assumes indices start at 1... However, we now have a way of offsetting indices in kernels via our `KernelParameters`. So it's not very hard to do this anymore. I can give it a start. If we make this change, we also want to take a step back and look at all the kernels we are launching currently to make sure everything makes sense. For example, here is a question: while we don't want to integrate the velocity tendencies on boundaries, what do we do about diagnostics? Do we want to compute vorticity on the boundary, for example, if we are computing a vorticity diagnostic? It seems simpler if we don't, that way we don't have special cases...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2388758985:202,optimiz,optimization,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2388758985,4,['optimiz'],['optimization']
Performance,The Langmuir example was failing because it was loading the arrays with the halos to plot. Switching to using the MakieExt does the job better and cleaner.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3860#issuecomment-2434352236:48,load,loading,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3860#issuecomment-2434352236,1,['load'],['loading']
Performance,"The Roquet’s approximation is perfectly sufficient for Oceananigans, because it will never be used for global calculations where local approximations are an issue. However I agree with everybody else that it would be best to use the same EOS in Ocenanigans and Climate_Ocean. in that case we should adopt TEOS-10. Be warned that it is quite inefficient through. So we may be hit performance-wise. Hard to tell without trying. Raffaele. > On Mar 9, 2020, at 11:48 AM, Gregory L. Wagner <notifications@github.com> wrote:; > ; > I also think it’s a good idea to use a full equation of state for all simulations sooner rather than later. It’s simpler: we won’t have to report constants of linearization everywhere. And setting up simulations will be easier.; > ; > I’ll defer to the modelers for whether Roquet’s approximation is an acceptable model for TEOS-10.; > ; > This package is relevant and we should consider contributing to it rather than implementing an equation of state somewhere in the Clima ecosystem:; > ; > https://github.com/gher-ulg/PhysOcean.jl <https://github.com/gher-ulg/PhysOcean.jl>; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub <https://github.com/climate-machine/Oceananigans.jl/issues/692?email_source=notifications&email_token=AK24ROIBMZMYD77AGEZNM3DRGUMURA5CNFSM4LEKJAAKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEOHZCYQ#issuecomment-596611426>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AK24ROONT4RO4YCCF6BTIIDRGUMURANCNFSM4LEKJAAA>.; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/692#issuecomment-596726895:379,perform,performance-wise,379,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/692#issuecomment-596726895,1,['perform'],['performance-wise']
Performance,The actual bottlenecks (as seen from the profile) are the transpose steps. The FFT steps are basically irrelevant.; This file shows how to setup and perform the transposes; https://github.com/CliMA/Oceananigans.jl/blob/ss/distributed-fft/test/test_distributed_transpose.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1986306179:11,bottleneck,bottlenecks,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1986306179,2,"['bottleneck', 'perform']","['bottlenecks', 'perform']"
Performance,"The advection-like Coriolis scheme was a non-sequitur because `f` is a very regular field, so upwinding it was just decreasing performance without a significative increase in quality of the simulation. On the other hand, upwinding `u` is very much discouraged because the energy builds up rapidly (by upwinding the velocity the divergence of the reconstructed tangential velocity is not a direct interpolation of the divergence of the original velocity, which is a necessary condition to maintain the algorithm stable). The only thing I can think to increase the order of velocity interpolation in the Coriolis force is to use a centered high-order scheme to interpolate velocity, but that would not help with the noise since a centered scheme is dispersive in nature. . I converted this PR to implement a `WetPointCoriolisScheme` (described in [Numerical boundary layers and spurious residual flows](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/JC091iC09p10621)). ; This is just a simple addition to an enstrophy conserving scheme where edge (""dry"") points are neglected in the interpolation of the velocity in the tangential direction. A comparison of the output of this scheme in a global 1 degree setup will follow",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272:127,perform,performance,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272,2,['perform'],['performance']
Performance,"The boundary condition functions should have the arguments `x, y, t, p` (no `z`!) so. ```julia; Qᵘ(x, y, t, p) = radius(x, y) < p.L ? imag(p.ρₐ / p.ρₒ * p.cᴰ * U(x, y, p.L) * abs(U(x, y, p.L))) : 0 # m² s⁻²; Qᵛ(x, y, t, p) = radius(x, y) < p.L ? - real(p.ρₐ / p.ρₒ * p.cᴰ * U(x, y, p.L) * abs(U(x, y, p.L))) : 0 # m² s⁻²; ```. You may also want to tag functions with `@inline` and use `ifelse` rather than the shortcircuiting ternary `? :` for performance:. ```julia; @inline d(x, y) = sqrt(x^2 + y^2); @inline U(x, y, L) = sin(π * d(x, y) / L) * exp(1im * angle(x + y*im)); @inline Qᵘ(x, y, t, p) = ifelse(d(x, y) < p.L, +imag(p.ρₐ / p.ρₒ * p.cᴰ * U(x, y, p.L) * abs(U(x, y, p.L))), 0.0) # m² s⁻²; @inline Qᵛ(x, y, t, p) = ifelse(d(x, y) < p.L, -real(p.ρₐ / p.ρₒ * p.cᴰ * U(x, y, p.L) * abs(U(x, y, p.L))), 0.0) # m² s⁻²; ```. Is `U` air speed? We sometimes recommend using the momentum flux itself as an input, rather than introducing a bulk formula (like a drag law) because this reduces the number of parameters in the problem (making it easier to understand and reproduce) --- but that's up to you. Here you could write. ```julia; @inline d(x, y) = sqrt(x^2 + y^2); @inline s(x, y, L) = sin(π * d(x, y) / L) * exp(1im * angle(x + y*im)); @inline Qᵘ(x, y, t, p) = p.τ₀ * ifelse(d(x, y) < p.L, +imag(s(x, y, p.L) * abs(s(x, y, p.L))), 0.0) # m² s⁻²; @inline Qᵛ(x, y, t, p) = p.τ₀ * ifelse(d(x, y) < p.L, -real(s(x, y, p.L) * abs(s(x, y, p.L))), 0.0) # m² s⁻²; ```. or something like that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066015300:444,perform,performance,444,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066015300,1,['perform'],['performance']
Performance,"The connectivity creates a ""cartesian grid"" of ranks which informs us which ranks are spatial neighbours. ; The more general way to arrange this grid, in absence of any other information is to wrap around the ranks as if the cartesian rank grid was `Periodic`. This is enough information for parsing the rank configuration, but not enough to perform fill halo regions. ; For this, we need a grid! Only with a grid, we will know if some directions are Bounded or Periodic, so, leveraging this information we can correctly assess which boundaries need communicating or not. Philosophically speaking, architecture provides the general rank layout while the grid concretizes this information ; leveraging the topology to decide whether to perform halo passing or not. Practically speaking the implementation leverages an `inject_halo_communication_boundary_conditions` implemented here:; https://github.com/CliMA/Oceananigans.jl/blob/34a3b930e0ace7df7dc7660f9c74f52315f41da7/src/DistributedComputations/halo_communication_bcs.jl#L14; previously only the connectivity was passed to this function, while this function should require also grid information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758117187:342,perform,perform,342,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758117187,2,['perform'],['perform']
Performance,"The issue is a little tricky. Typically we expect abstract operations to be computed during time-stepping. In that case, the halos should be correctly filled. However, @navidcy expects that abstract operations should be correct at any time and does not expect to have to call fill halo regions. Thus for `compute!` to be more generally useful to users I think we do want this behavior. The problem is that fill halo regions can be expensive eg for distributed models. Therefore to both serve expected user behavior and provide a performant interface we perhaps have to add a flag to `compute!` like `fill_halo_regions=false` so that computation for output does not trigger extra calls to fill halo regions. Note @navidcy you can also use the simpler and more transparent . ```julia; parent(model.velocities.u) .= 1; ```. or just `fill!(model.velocities.u, 1)`. I think your result would be correct then. But still if we are setting to functions then we need `set!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3114#issuecomment-1559611530:529,perform,performant,529,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3114#issuecomment-1559611530,2,['perform'],['performant']
Performance,"The issue was that, prior to the update the fill_halo_region! function, the test in validation/mesoscale/baroclinic_adjustment.jl , which in particular, uses the hydrostatic model with an explicit free surface, would produce different answers when run twice after several thousand timesteps. This typically happens when there is a race condition in the code and this particular one was hard to find since it occurs only after several timesteps have occurred. The reason for ""potential"" in the title of the PR is that I do not understand why this race condition exists in the first place, since I have not seen this in any other Oceananigans model, including Hydrostatic + Implicit Free Surface or the NonHydrostatic Model",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920473363:331,race condition,race condition,331,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920473363,2,['race condition'],['race condition']
Performance,"The logic should be reversed, we should have to include ""compute_tendencies=false"" as an _optimization_. Rather than what's implemented here, which does the unsafe thing by default. The problem with this logic is that it makes it harder to implement new models. The optimizations should be the optional thing basically, if one is naive, then things should work even if they are slower than they could be",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3741#issuecomment-2313416515:266,optimiz,optimizations,266,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3741#issuecomment-2313416515,1,['optimiz'],['optimizations']
Performance,The module loading sequence I was running was before that didn't work were; ```; module --force purge; module load ncarenv/23.10 gcc/12.2.0; module load ncarcompilers/1.0.0; module load netcdf/4.9.2 openmpi/4.1.6 ; module load julia/1.9.2; module load cuda/12.2.1; ```; if needed I can see if I can find the versions of the modules that ended up working. There are no other major difference in how I load in the packages or Julia. Let me know if you have any questions,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258742898:11,load,loading,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258742898,7,['load'],"['load', 'loading']"
Performance,"The only parts of the solver algorithm that require communication between nodes are `norm` and `dot`, right?. The ""matrix product"" --- a Poisson operator for us --- has unavoidable communication as well. But, we should be able to keep this limited in scope and we only need 1 halo. The trickier part where I think there is room for significant optimization is in the development of an effective multi-GPU preconditioner that is also efficient in parallel.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2386795222:344,optimiz,optimization,344,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2386795222,1,['optimiz'],['optimization']
Performance,"The preconditioner we used at high resolution is an asymptotic approximation of the inverse matrix that assumes that the original matrix is diagonally dominant. This is an increasingly worst approximation as you increase the resolution, deteriorating the performance when cells size is decreased",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1257981531:255,perform,performance,255,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1257981531,1,['perform'],['performance']
Performance,"The problem is I haven't yet figured out where in `weno_interpolants.jl` the code relies on very heavy bounds checking, so running julia with or without `--check-inbounds=no` changes the performance radically. . It's probably not too hard to identify where the problem is, but I have been missing it and I also find myself in a moment in which I have very little time. On the other hand, this PR fixes a lot of problems, so all the next PRs are kind of contingent on this one. I can wait a little bit more to merge this...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185571576:187,perform,performance,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185571576,1,['perform'],['performance']
Performance,"The problem is not only with the `Nothing`, it's that the reduced fields are effectively launched with a reduced grid size . for example the west boundary kernel launch for a `(Center, Center, Center)` field will be of size `Ny*Nz`; for a `(Center, Center, Nothing)` it will be of size `Ny`. For the moment I just filter the reduced fields and do them individually. I don't think it will create too much problem. This is only an optimization for time-stepping where we do not have too many reduced fields (only free surface I think)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065523937:429,optimiz,optimization,429,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065523937,1,['optimiz'],['optimization']
Performance,"The problem is not with the reduction but with derivatives that act on reduced fields.; The reductions are not an issue, because by performing a reduction we know what operation leads us to a reduced field, so we can perform the reduction accordingly (for example we exclude immersed cells from reductions). . When performing a derivative we use all three indices regardless of the field being reduced or not. ; In this case we get a funky result where we are trying to evaluate a derivative at `k == 1` for a reduced field that does not necessarily live at `k == 1`. In other words, the assumption that the field lives at `k == 1` is wrong for a reduced field; the right solution, on the other hand, is not so clear cut:. If we assume that reduced fields ""lives"" nowhere in the reduced direction, then we can remove the k index and just perform an ""immersed-boundary-unaware"" derivative. On the other hand, if the reduced field lives on the whole reduced column (like for example an integral) then we need to be aware of the ""immersed column"", because if the whole column is immersed then the derivative should return a zero.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2097124708:132,perform,performing,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2097124708,8,['perform'],"['perform', 'performing']"
Performance,The problems seen in the global simulation were actually fixed by #2774. The test was performed without updating the code to the latest version. I will close this PR,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2778#issuecomment-1279612571:86,perform,performed,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2778#issuecomment-1279612571,1,['perform'],['performed']
Performance,"The regression tests take a long time just because there are quite a few tests. We recently added many new hydrostatic regression tests (10-20? or more?) where there used to be just a handful. The solver tests have always been a bottleneck but I think there are a few new solvers being tested which probably increased the test length? I'm not sure why `time_stepping_2` would have increased (possibly that was always a bit slow). I definitely agree that CI time is a problem, which is why we opened #1962 to move the CI over to Caltech's central cluster and to split tests into a ""nightly"" category (running every night rather than on every PR / commit), and a per-commit category. However, we haven't made much progress on that PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2139#issuecomment-1009058943:229,bottleneck,bottleneck,229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2139#issuecomment-1009058943,1,['bottleneck'],['bottleneck']
Performance,"The results in [A simple algorithm to improve the performance of the WENO scheme on non-uniform grids](https://link.springer.com/article/10.1007/s10409-017-0715-2) show that WENO reverts to 2nd-order accuracy on stretched grids. So its not ""incorrect"", just less accurate. However, for any given problem, the convergence rate is only one aspect of the accuracy of a solution. It's possible that WENO5 is still more accurate than any other numerical scheme, even if the solution only _converges_ to the true solution at a 2nd order rate. It also seems likely that this is true for any reconstruction stencil. I'm not sure how much attention is paid to this issue in other codes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1704#issuecomment-967312861:50,perform,performance,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1704#issuecomment-967312861,2,['perform'],['performance']
Performance,The tests have sped up a lot (presumably because compile time is so much better with KA 0.9). This means that the docs build is a much bigger bottleneck. I think we're at 2h48m:. https://buildkite.com/clima/oceananigans/builds/11123#01879a9c-fde8-4691-a3f5-29ef6060e288. so we will see what we get down to.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3075#issuecomment-1515556985:142,bottleneck,bottleneck,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3075#issuecomment-1515556985,1,['bottleneck'],['bottleneck']
Performance,"The tests should run with `--check-bounds=yes` automatically. I think that when calling `Pkg.test()` the testing environment automatically activates the 0 optimization flag (`-O0`) and the bounds checking flag `--check-bounds=yes`, but I cannot find a reference at the moment.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3747#issuecomment-2318384101:155,optimiz,optimization,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3747#issuecomment-2318384101,1,['optimiz'],['optimization']
Performance,"The way I implemented it, the matrix ""constructors"" are saved in the solver without the variable diagonal term. Basically the constructors include all the terms except for the term that varies with the time step which is saved in `solver.diagonal`. ; i.e. the `Dᵢⱼₖ` in; ```; Axᵢ₊₁ ηᵢ₊₁ + Axᵢ ηᵢ₋₁ + Ayⱼ₊₁ ηⱼ₊₁ + Ayⱼ ηⱼ₋₁ + Azₖ₊₁ ηₖ₊₁ + Azₖ ηⱼ₋₁ ; - 2 ( Axᵢ₊₁ + Axᵢ + Ayⱼ₊₁ + Ayⱼ + Azₖ₊₁ + Azₖ ) ηᵢⱼₖ ; + ( Cᵢⱼₖ + Dᵢⱼₖ/Δt^2 ) ηᵢⱼₖ = b; ```. Every time that the time step changes this is the operation that is performed:; ```; constructors = deepcopy(solver.matrix_constructors); M = prod(solver.problem_size); update_diag!(constructors, arch, M, M, solver.diagonal, Δt, 0); solver.matrix = arch_sparse_matrix(arch, constructors) ; ```. So the matrix is constructed from a copy of the updated constructors. In this way there is no need to subtract anything to the diagonal because `solver.matrix_constructors` does not include the diagonal term. . `update_diag!` adds `Dᵢⱼₖ/Δt^2` to the diagonal elements. . If you want to do the something analogous with the linear operation, remove the time dependent term from it. Then add it separately with `update_diag!` every time the time step changes. Of course you want to make sure that you have elements in your diagonal, non trivial if `Cᵢⱼₖ` because a sparse matrix removes 0 elements. check out this function ; `ensure_diagonal_elements_are_present!(sparse_matrix)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179415403:509,perform,performed,509,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179415403,1,['perform'],['performed']
Performance,"Then you can just load in your ""bottom"" from the `ImmersedBoundaryGrid` and set that to; ```; bottom[ bottom .>0 ] .= NaN; bottom[ bottom .<0 ] .= 0.0; ```; then when you lift the variable; ```; ζ′ = @lift file[""timestepper/ζ′/ *string($iter][:, 1:end-1, 1] .+ bottom; ```; (it is not going to be in the exact same position since `ζ′` is at faces and bottom is at centers, but on a 1/4 degree resolution I don't think makes much of a change)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128082953:18,load,load,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128082953,1,['load'],['load']
Performance,"There are some errors that occurred right away, and I copied one below. Is this because of something in this PR or because of the system perhaps?. ```. ERROR: The following 1 direct dependency failed to precompile:; --;   |  ;   | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];   |  ;   | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-3746/compiled/v1.6/Oceananigans/jl_IfcPYz.;   | ERROR: LoadError: LoadError: SystemError: opening file ""/var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Advection/upwind_biased_first_order.jl"": No such file or directory;   | Stacktrace:;   | [1] systemerror(p::String, errno::Int32; extrainfo::Nothing);   | @ Base ./error.jl:168;   | [2] #systemerror#62;   | @ ./error.jl:167 [inlined];   | [3] systemerror;   | @ ./error.jl:167 [inlined];   | [4] open(fname::String; lock::Bool, read::Nothing, write::Nothing, create::Nothing, truncate::Nothing, append::Nothing);   | @ Base ./iostream.jl:293;   | [5] open;   | @ ./iostream.jl:282 [inlined];   | [6] open(f::Base.var""#326#327""{String}, args::String; kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}});   | @ Base ./io.jl:328;   | [7] open;   | @ ./io.jl:328 [inlined];   | [8] read;   | @ ./io.jl:434 [inlined];   | [9] _include(mapexpr::Function, mod::Module, _path::String);   | @ Base ./loading.jl:1166;   | [10] include(mod::Module, _path::String);   | @ Base ./Base.jl:386;   | [11] include(x::String);   | @ Oceananigans.Advection ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:1;   | [12] top-level scope;   | @ ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:43;   | [13] include(mod::Module, _path::String);   | @ Base ./Base.jl:386;   | [14] include(x::String);   | @ Oceananigans ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:1;   | [15] top-level scope;   | @ ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:173;   | [16] i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134:459,Load,LoadError,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134,2,['Load'],['LoadError']
Performance,"There is a fair amount of scalar iteration right now, largely I think because we have array-like objects (Fields, and friends) that lack fully-featured broadcasting capabilities. This means writing something like `a .== 2` triggers scalar iteration on the GPU because it hits Base broadcasting. We _can_ fix the problem by fleshing out broadcasting a bit so `a .== 2` works ""correctly"" / sensibly, but we haven't prioritized it (we also didn't have broadcasting at all for Field until a month or two ago). Possibly, if changing a global via `allowscalar(true)` were not available we would have been forced to address this deficiency in our Field abstraction sooner. So that could have been a good thing depending on your perspective. It did allow us to sweep some things under the hood. On the other hand I don't think we have any performance issues; scalar iteration is only used on very small arrays for testing where we are completely dominated by compile times.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-864145884:831,perform,performance,831,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-864145884,1,['perform'],['performance']
Performance,"There is still a problem. This time with the vector size:. > ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] No Gpu available; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 129 and 128""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs (repeats 3 times); @ ./broadcast.jl:495 [inlined]; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] instantiate; @ ./broadcast.jl:266 [inlined]; [6] materialize(bc::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3}, Nothing, typeof(*), Tuple{Array{Float64, 3}, Array{Float64, 3}}}); @ Base.Broadcast ./broadcast.jl:883; [7] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case13/c16_128_128m.jl:200. Also, shouldn't we set v (last line below, I added the commented v's):. `Random.seed!(1414). T = model.tracers.T; u, v, w = model.velocities. x, y, z = nodes(T, reshape=true); Lz = model.grid.Lz. shape = @. z / Lz * (1 + z / Lz); ΞT = randn(size(T)...) .* shape; Ξu = randn(size(u)...) .* shape; #Ξv = randn(size(v)...) .* shape; Ξw = randn(size(w)...) .* shape. Tᵢ = @. 20 + dTdz * z + dTdz * Lz * 1e-6 * ΞT; uᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξu; #vᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξv; wᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξw. #set!(model, u=uᵢ, v=vᵢ, w=wᵢ, T=Tᵢ, S=35); set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=35)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743:610,Load,LoadError,610,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743,1,['Load'],['LoadError']
Performance,"There were a bunch of bugs in `shallow_water_model.jl`. The reason for the error. > ERROR: LoadError: LoadError: LoadError: LoadError: UndefVarError: NoImmersedBoundary not defined. is because there was a line. ```julia; using Oceananigans.ImmersedBoundaries: NoImmersedBoundary; ```. in the file `src/Models/ShallowWaterModels/shallow_water_model.jl`. Since `NoImmersedBoundary` is not defined (there is no name `NoImmersedBoundary` in the module `ImmersedBoundaries`, or anywhere else in the code), this line threw an error. I am not sure if I found all the bugs in `shallow_water_model.jl`; more debugging may be necessary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-843325766:91,Load,LoadError,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-843325766,4,['Load'],['LoadError']
Performance,"There's some info in CUDA docs but it doesn't explicitly answer my question:. > For small integer powers (e.g., x2 or x3), explicit multiplication is almost certainly faster than the use of general exponentiation routines such as pow(). While compiler optimization improvements continually seek to narrow this gap, explicit multiplication (or the use of an equivalent purpose-built inline function or macro) can have a significant advantage. This advantage is increased when several powers of the same base are needed (e.g., where both x2 and x5 are calculated in close proximity), as this aids the compiler in its common sub-expression elimination (CSE) optimization. So maybe we shouldn't square at all here...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870017593:252,optimiz,optimization,252,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870017593,2,['optimiz'],['optimization']
Performance,"These benchmarks:. https://github.com/CliMA/Oceananigans.jl/pull/2412. show a factor of 2 speed up on the CPU. In principle, the FFT is faster than a matrix multiply which may explain it? Or, perhaps the benchmarks test the wrong thing so we should re-run them. As explained on that PR, some performance is left on the table, because the fastest combination would use an FFT-based preconditioner with a matrix multiply to compute the LHS.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172613179:292,perform,performance,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172613179,1,['perform'],['performance']
Performance,"Thinking about this more, I think it would make sense to make an even more radical change. I think we should add `diagnostics`, `output_writers`, and `clock` to `Simulation`. . The `time_step!` function then performs a single time-step, whereas to run a simulation one should write `run!(simulation)`, which handles diagnostics, output writing, adaptive time-stepping, and logging in an integrated way. This orthogonalizes the design a bit: `diagnostics` and `output_writers` are not really aspects of a ""model"", if we use a narrow interpretation of a model as a discrete representation of a physical system. A single physical system might conceivably be associated with a wide range of disparate diagnostics and output, depending on what kind of science is being done. I think scripts become clearer. The user writes. ```julia; model = Model(; model_parameters...). simulation = Simulation(model; simulation_parameters...). simulation.diagnostics[:diag] = # something. run!(simulation); ```. As an example to illustrate why `Simulation` is orthogonal to `Model`, here's a possible clear and coherent usage of this separation:. ```julia; model = Model(; model_parameters...). set!(model; first_interesting_initial_condition...). first_simulation = Simulation(model, first_simulation_parameters...); first_simulation[:diag] = diag_specific_to_first_simulation; run!(first_simulation). set!(model; second_interesting_initial_condition...) # same physical model, but different starting initial condition... no new memory allocated, no recompilation --- fast. second_simulation = Simulation(model, second_simulation_parameters...); second_simulation[:diag] = diag_specific_to_second_simulation; run!(second_simulation); ```. We can use `run!(simulation, time_steps=nsteps)` to allow hand-coded user loops that achieve a functionality similar to what we have now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542294442:208,perform,performs,208,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542294442,1,['perform'],['performs']
Performance,This abstraction would also simplify the ECCO/SOSE LESbrary.jl setup although it's also messy due to other terms and me jamming in Interpolations.jl objects: https://github.com/CliMA/LESbrary.jl/blob/master/scripts/pilot_simulation.jl#L117-L145. It seems like some complex setups could benefit a lot from a background fields abstraction. It shouldn't affect performance since the two interaction terms should results in no-ops. > I think we would want this functionality to assume that the linear balances between background terms are somehow separately satisfied. Agree with this. Users are responsible for making sure that they impose sensible background fields (just like they are responsible for setting sensible fields).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/960#issuecomment-701523300:358,perform,performance,358,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/960#issuecomment-701523300,1,['perform'],['performance']
Performance,"This has implications in terms of code performance, if we have `set!(field)` somewhere in the code it will trigger automatically a `fill_halo_regions!` which we might not want as we are very careful to where we call `fill_halo_regions!`. There are two options then:; (1) remove all instances of `set!` in the internals and make sure to never use it; (2) implement a different interface that can be user-facing which triggers set! and fill_halo_regions! together. I would vote for (2)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3010#issuecomment-1480334115:39,perform,performance,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3010#issuecomment-1480334115,1,['perform'],['performance']
Performance,"This is a breaking change for some scripts that load, e.g., Earth's gravity from the `BuoyancyModels` module. Let's aim to release a new version when both this PR and #2979 are merged.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492610370:48,load,load,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492610370,1,['load'],['load']
Performance,This is super exciting! Out of curiosity is there any/which Krylov solver is compatible on multiple GPUs? Seems to be an important bottleneck for our current `PreconditionedConjugateGradientSolver` approach.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2386649167:131,bottleneck,bottleneck,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2386649167,1,['bottleneck'],['bottleneck']
Performance,"This is the same benchmark performed with `ImplicitFreeSurface`, by imposing a divergent velocity `u(x, y, z) = x / 10` to make sure the implicit solver iterates. Looking at the results it seems like it doesn't iterate too much... (probably WENO cleans up?) And it is very weird that the `RectilinearGrid` version is not affected by the FreeSurface calculation? (I have double checked that the free surface solver is correct). #### Strong Scaling; | Grid size | Grid | GPUs | wall time | efficiency |; | -- | -- | -- | -- | -- |; | `1440×600×48`| `RectilinearGrid` | 1 | 1.37 minutes | 100% |; | `1440×600×48`| `MultiRegionGrid` | 2 | 1.05 minutes | 65.2% |",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116777025:27,perform,performed,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116777025,1,['perform'],['performed']
Performance,"This is worrisome!. What is being plotted in the comparisons? It looks like 3D fields are being outputted, but the time series plots show some reduction of the 3D data. It certainly seems that the time-averaged output is incorrect, but only for certain types of output, which is puzzling. One thought is that it seems possible to write a utility / function that calculates time-averages directly from snapshots and compares the result with time-averages generated by `WindowedTimeAverage`. We could even write a function that takes in a field and a simulation, and then constructs the two output writers, runs the simulation, and performs the analysis. The first TKE example should pass, but dissipation should not. Perhaps even time-averaging the velocity field is not correct? We can then experiment with types of output to figure out what ingredient leads to a discrepancy. > Here the snapshot results are consistent with each other, but the time-averaged TKE results computed with ComputedFields actually match the snapshots, but not the time-averaged TKE results computed with KernelComputedFields!. I think I might have missed something --- in the very first example, was TKE computed using a `ComputedField` or `KernelComputedField`? Are the later results in this post consistent with the first posted results?. Is there any way that any of this has to do with time-step alignment?. Lastly, why is the window slightly different from the `TimeInterval`? What happens when the time-interval and averaging window are the same (which appears to be our default?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809893411:630,perform,performs,630,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809893411,1,['perform'],['performs']
Performance,"This kind of feature can't be implemented directly in `Forcing`, because all explicit tendency terms are evaluated in the same kernel. So we have to evaluate `forcing` in every cell that requires a tendency. It is possible to expose a feature that allows kernels to be launched over some subset of cells. Then users could implement this kind of optimization in their script by using an array to represent the forcing, and then by precomputing the forcing into that array using a kernel that only evaluates some subset of all the cells in a callback. Or something like that. If forcing functions are expensive there may be simpler ways to do performance optimization though. For example, we can recommend piecewise linear masking functions for sponge layers instead of tanh or exp.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2028469830:345,optimiz,optimization,345,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2028469830,6,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"This looks like a good start!. I think we should use multiples of 2 and 3 for the resolution in x and z (24, 48, 64, etc). This has some minor advantages for FFT performance, but more importantly is something of a convention that I think is nice to stick to. We may want to write a simple abstraction for specifying systems of reactions. I will think about that. What would be a good biochemical system to consider that involves a handful of reactive tracers?. @ali-ramadhan just to be clear, the diel vertical migration cycle is something that's computed offline? In other words, we are not modeling the vertical motion of individual plankton in this model. We can, however, model other tracers directly in Oceananigans, such as nutrient concentrations, CO2, and carbonates that contribute to dissolved inorganic carbon.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629398620:162,perform,performance,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629398620,1,['perform'],['performance']
Performance,This looks slightly slower than the solution on #1770 (slow down of 2.0x rather than 1.8x):. ```; Advection schemes relative performance (GPU); ┌───────────────┬────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Schemes │ slowdown │ memory │ allocs │; ├───────────────┼────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ CenteredFourthOrder │ 1.36394 │ 1.08012 │ 1.6807 │; │ GPU │ CenteredSecondOrder │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ UpwindBiasedFifthOrder │ 1.53947 │ 1.08022 │ 1.6815 │; │ GPU │ UpwindBiasedThirdOrder │ 1.3124 │ 1.06337 │ 1.53834 │; │ GPU │ WENO5 │ 2.04368 │ 1.22539 │ 2.91485 │; └───────────────┴────────────────────────┴──────────┴─────────┴─────────┘; ```. I find this surprising. @hennyg888 can you confirm?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1783#issuecomment-870041934:125,perform,performance,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1783#issuecomment-870041934,1,['perform'],['performance']
Performance,"This seems like a way forward, but I would wait for #2924 (that seems to be our bottleneck) to pass before changing CI",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3042#issuecomment-1498500356:80,bottleneck,bottleneck,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3042#issuecomment-1498500356,1,['bottleneck'],['bottleneck']
Performance,This seems reasonable. I'm not sure if there are performance implications. @navidcy @simone-silvestri any thoughts?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3455#issuecomment-1927382247:49,perform,performance,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3455#issuecomment-1927382247,1,['perform'],['performance']
Performance,"This seems to work out-of-the box with our simple example, but I'm encountering errors when applying to one of my complex scripts. I'm getting errors of the kind `ERROR: LoadError: Custom output b_tot needs dimensions!`. And when I do specify the dimensions manually I get `Trying to write (1, 1, 16) elements while [17, 1] are expected`. So clearly we're missing something. Looking at the behavior of `AveragedField` I think we should not `dropdim` when doing the average anymore since `AveragedField` always returns a 3D array:. ```julia; julia> bmean = AveragedField(b, dims=(1, 2)); AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (1, 1, 20); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=1024, Nz=16); ├── dims: (1, 2); ├── operand: Field located at (Center, Center, Center); └── status: time=0.0. julia> bmean.data; 1×1×20 OffsetArray(::Array{Float64,3}, 1:1, 1:1, -1:18) with eltype Float64 with indices 1:1×1:1×-1:18:; [:, :, -1] =; 0.0. [:, :, 0] =; 0.0. [:, :, 1] =; 0.0. ... [:, :, 16] =; 0.0. [:, :, 17] =; 0.0. [:, :, 18] =; 0.0; ```. But even without using `dropdim` I still get an error. I think maybe the issue is because `WindowedSpatialAverage` is returning an Array, and not an OffsetArray. Any thoughts?. ```julia; julia> bwind = WindowedSpatialAverage(b, dims=(1, 2), field_slicer=FieldSlicer(j=3:7)); WindowedSpatialAverage{Field{Center,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783777559:170,Load,LoadError,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783777559,1,['Load'],['LoadError']
Performance,"This week I plan to revisit this and hopefully figure out how to make the `ShallowWaterModel` stable and not experimental. Lots of nice work was started on the multi-layer version and I hope that we can continue to work towards that after we get the fluxes and the regression tests. I just wanted to confirm that people are still supportive of this before I dive in too deep. If yes, @simone-silvestri , would you have time to meet for 1 hour next week to fine tune things?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1808221910:461,tune,tune,461,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1808221910,1,['tune'],['tune']
Performance,"To fill in a few more details for @hennyg888 --- _almost all_ multithreading in Oceananigans is achieved via [`KernelAbstractions.jl`](https://github.com/JuliaGPU/KernelAbstractions.jl). Improving efficiency for Oceananigans kernels likely means contributing to `KernelAbstractions.jl` (which @vchuravy may or may not be excited about :-D). More specifically, all tendency evaluations, non-communicative / non-periodic halo fills (periodic halo filling uses Base broadcasting and thus is not parallelized), integrals (like the hydrostatic pressure integral, or vertical velocity computation in `HydrostaticFreeSurfaceModel`), evaluation of diagnostics, and broadcasting with fields all use KernelAbstractions via the Oceananigans function `launch!`:. https://github.com/CliMA/Oceananigans.jl/blob/6e39d3fcc098c69ac207cc21be759cf6bd3ec604/src/Utils/kernel_launching.jl#L71-L90. The line . ```julia; event = loop!(args...; dependencies=dependencies, kwargs...); ```. launches a kernel, using [`KernelAbstractions` syntax](https://juliagpu.github.io/KernelAbstractions.jl/stable/#Quickstart-1). `event` is a token that can be ""waited"" on if we need to. So either we can improve multithreading by changing what happens when `loop!` is called --- or, possibly, by refining the dependency tree so that we can launch more kernels simultaneously. The second optimization is probably more important for small problems. You have mostly benchmarked fairly large problems so I don't we'd see much speed for them. But I'm not 100% sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880826423:1350,optimiz,optimization,1350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880826423,1,['optimiz'],['optimization']
Performance,"To summarize the updates, we can make use of the type `ConditionalOperation` to perform conditional reductions with a mask. If a mask is not specified, the specific neutral value for that particular reduction will be used. Example:. ```; julia> grid = RectilinearGrid(arch, size = (4, 1, 1), extent = (1, 1, 1)); RectilinearGrid{Float64, Periodic, Periodic, Bounded}; architecture: CPU(); domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); size (Nx, Ny, Nz): (4, 1, 1); halo (Hx, Hy, Hz): (1, 1, 1); spacing in x: Regular, with spacing 0.25; spacing in y: Regular, with spacing 1.0; spacing in z: Regular, with spacing 1.0. julia> field = Field{Center, Center, Center}(grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (4, 1, 1); ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=1, Nz=1); └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux. julia> set!(field, [1, 2, 3, 4]). julia> sum(field); 10.0. julia> sum(field, condition = field .> 2); 7.0. julia> sum(field, condition = field .> 2, mask = 100); 207.0. julia> sum(field, condition = (i, j, k, grid, field) -> grid.xᶜᵃᵃ[i] < 0.3); 1.0; ```. This type is used to automatically exclude the immersed region in reductions of `AbstractField{<:Any, <:Any, <:Any, <:ImmersedBoundaryGrid}`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1018860248:80,perform,perform,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1018860248,1,['perform'],['perform']
Performance,True. I guess we don't have a separate architecture for multi-threaded. I agree that `MPI_CPU` or `MPICPU` would be more precise. What do you think of `DistributedCPU` and `DistributedGPU`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1502#issuecomment-804952861:56,multi-thread,multi-threaded,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1502#issuecomment-804952861,1,['multi-thread'],['multi-threaded']
Performance,True. Should probably also link to https://docs.julialang.org/en/v1/manual/performance-tips/,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-804942693:75,perform,performance-tips,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-804942693,1,['perform'],['performance-tips']
Performance,"Try. ```julia; const width = 100kilometers; @inline ν(x, y, z, t) = ifelse(abs(y - Ny*kilometers/2) < Ny*kilometers/2 - width, 1, 10) # sponge layers; ```. The `const` is necessary here for GPU and will also improve performance on CPU. The reason is that we need to assure the compiler that the type of `width` will not change for GPU compilation to be possible. If that fails you may also need to change `kilometers` to `1e3`, or to define another `const`. However, I think that `kilometers` should already b `const` so this may not be necessary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068643259:216,perform,performance,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068643259,1,['perform'],['performance']
Performance,"Tuple{(), Tuple{}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:a,), Tuple{Int64}}, Nothing, NamedTuple{(:u, :v, :w, :a), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, Nothing, typeof(forc_u), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}, typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing), Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}}}}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/kb6yJ/src/driver.jl:76; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/BbliS/src/compiler/execution.jl:347; [10] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/kb6yJ/src/cache.jl:90; [11] cufunction(f::typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gu!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Tw",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353:8717,cache,cache,8717,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353,1,['cache'],['cache']
Performance,"Unfortunately it doesn't work for me:. ```julia; (base) tomas@np900:~/repos/Oceananigans.jl$ julia1.6 --project=docs/ -e 'using Pkg; Pkg.instantiate()'; (base) tomas@np900:~/repos/Oceananigans.jl$ julia1.6 --project=docs/ docs/make.jl; ERROR: LoadError: LoadError: LoadError: ArgumentError: Package SpecialFunctions [276daf66-3868-5448-9aa4-cd146d93841b] is required but does not seem to be installed:; - Run `Pkg.instantiate()` to install all recorded dependencies. Stacktrace:; [1] _require(pkg::Base.PkgId); @ Base ./loading.jl:990; [2] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [3] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; [4] include(mod::Module, _path::String); @ Base ./Base.jl:386; [5] include(x::String); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; [6] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; [7] include(mod::Module, _path::String); @ Base ./Base.jl:386; [8] include(x::String); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; [9] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:46; [10] include; @ ./Base.jl:386 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics/math.jl:5; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /home/tomas/.julia/compiled/v1.6/CUDA/jl_q4lPlx.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compile",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371:243,Load,LoadError,243,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371,6,"['Load', 'load']","['LoadError', 'loading']"
Performance,"Update: I have been able to reduce the error to be a procompiling error in oceananigans.jl:; ```; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2300; [3] compilecache; @ ./loading.jl:2167 [inlined]; [4] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1805; [5] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1660; [6] macro expansion; @ ./loading.jl:1648 [inlined]; [7] macro expansion; @ ./lock.jl:267 [inlined]; [8] require(into::Module, mod::Symbol); @ Base ./loading.jl:1611; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; ```; I have been trying to make sure that everything is up to date, and I am running on Julia version 1.9.2. My code is just; ```; using Oceananingans; ```; as I have been trying to get the library to load properly. Does anyone have any experience with this error or does it make things any clearer?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372:105,Load,LoadError,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372,15,"['Load', 'load']","['LoadError', 'load', 'loading']"
Performance,"Using ; ```; grid = RectilinearGrid(arch, size=(Nx, Ny, Nz), halo=(4, 4, 4), x=(0, 2π), y=(0, 2π), z=(0, 1), topology=(Periodic, Periodic, Bounded)). bottom = zeros(Nx, Ny); bound = Int.(Ny/2-40:Ny/2+40); bottom[bound, bound] .= 0.5. grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)); mrg = MultiRegionGrid(grid, partition=XPartition(2), devices = 2); ```; and ; ```; u(x, y, z) = (x * z) / 10; ```. (with `ImplicitFreeSurface`) we get. #### Strong Scaling; | Grid size | Grid | GPUs | wall time | efficiency |; | -- | -- | -- | -- | -- |; | `1440×600×48`| `RectilinearGrid` | 1 | 1.85 minutes | 100% |; | `1440×600×48`| `MultiRegionGrid` | 2 | 1.12 minutes | 82.5% |. Scaling gets better?? at this point I a little confused...; Bottomline... ; there is still a bunch of optimization and more systematic benchmarking to be done, I'll merge this PR and then we can think about improving the scaling, the first things that come in mind are; - Ensure that all the `apply_regionally!` and `construct_regionally` calls are asynchronous. This might not be the case if there are memory copies inside function calls. That would serialize the execution of part of the code. To ensure this we require a more in-depth profiling using ***nsys***; - remove all `fill_halo_regions!` that are not `Periodic` or `Communication` which will allow asynchronous execution of halo filling across different direction (luckily already being done in #2477); - Bundle together the halo passing in a single boundary buffer to allow sending field tuples together (depends on #2509). Additional work to do on `MultiRegion` is ; - Perform more systematic benchmarking; - Design correct `OutputWriters` and `OutputReaders` for `MultiRegionFields`. Maybe not immediate priorities but definitely important; - Adapt `RungeKutta3` to `Multiregion` through `@apply_regionally`; - Implement a multi-region version of the Nonhydrostatic pressure solver; - Overlap computation and communication (for this we require _non-blocking",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178:781,optimiz,optimization,781,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178,1,['optimiz'],['optimization']
Performance,"We have to debate the best choice... fate cannot decide it for us. I think split-explicit is probably the best choice for a default --- it's performant in all contexts, and potentially also the least complicated? I believe it will also handle nonlinearity better than an implicit formulation (which we don't support now, but could support in the future). @simone-silvestri can probably best advise. Not sure how the docstring diverged from the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3289#issuecomment-1734789419:141,perform,performant,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3289#issuecomment-1734789419,1,['perform'],['performant']
Performance,We maybe want to optimize the construction of the `SparseInverse`.; I naively wrote a serial code to do that because I didn't know that `CUDA.jl` had implemented a GPU version of the `qr` factorization. Since the construction of the preconditioner is embarrassingly parallelizable we can shift it to the GPU easily,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1119052363:17,optimiz,optimize,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1119052363,1,['optimiz'],['optimize']
Performance,"We need an MPI tips / wiki section... been working on getting distributed simulations running on Engaging since yesterday (we need people to be able to start running distributed simulations immediately with minimal start up time). Here are a few things I learned:. * Remember to load a system MPI on your HPC, eg `module load openmpi`; * MPI may have to be installed / configured carefully --- after loading a system MPI. `MPIPreferences` can help:. ```julia; using MPIPreferences; MPIPreferences.use_system_binary(); ```. https://juliaparallel.org/MPI.jl/stable/configuration/. * Configuring SLURM correctly may also require some trial and error, because the documentation is unclear and there are a huge number of options. I can't figure out if the documentation is wrong, in fact, or if instead the engaging cluster does not support some options. Either way, a small test script like. ```julia; using MPI. MPI.Init(); @show MPI.Comm_rank(MPI.COMM_WORLD); @show MPI.Comm_size(MPI.COMM_WORLD); ```. Is helpful for debugging. Also, I recommend first trying to start jobs interactively before using `sbatch`. Interactive jobs launch faster, so we get a faster trial-error iteration. I'm still working on things, but it seems like another point may be salient:. * Initialize / precompile outside of a parallel job before trying to launch a parallel job via `mpiexec`. Here are some notes that may be specific to engaging:. I'm using `srun` to get a 4-GPU node to use interactively:. ```; srun -p my_partition --tasks-per-node=4 --cpus-per-task=32 --gres=gpu:4 --gpus-per-node=4 --mem=0 -t 01:00:00 -N 1; ```. it seems we have to use the option `gpus-per-node`, rather than setting the total number of GPUs. Also we redundantly also have to specify `gres=gpu:4` (`gres` stands for ""generalized resource""). Why `gres` can't tell what `gpus-per-node` is, I don't know. `-N 1` means 1 node. Finally we also have to specify ``--tasks-per-node=4` (matching `gres` _and_ the number of GPUs per node), otherwise",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436:279,load,load,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436,6,['load'],"['load', 'loading']"
Performance,"We should close this, but I'd like to leave an explanatory note in case others want to weigh in. This issue is really about ""vision"" than something missing with output writers. This issue really proposes that we think about JLD2 output differently (perhaps, in a way that's similar to how NetCDF views output). In that mode output would be somewhat independent of Oceananigans; if we output ""sliced"" data, then we could also output a ""sliced grid"" that represents the portion of the grid on which the data lives. One might then be able to load data and a grid ""simply"" (ie as `Array`s) and make sense of it without `using Oceananigans`. But since this issue was opened we have implemented `Field.indices` to move towards more full support for ""windowed"" or ""sliced"" fields (not _only_ when writing output), which sends us in a slightly different direction. Now a single output writer can be used to output fields that are differently sliced or windowed. We also support loading sliced fields with `FieldTimeSeries` (which is then able to correctly locate sliced fields on a grid), and doing further computations with those fields (we even envision supporting computations between fields that are sliced differently by computing index ""intersections""). Since we do save index information now when we slice a field, it is actually possible to manually slice a grid after data has been outputted. So savvy users can achieve this functionality with themselves if they (for some reason) are allergic to `FieldTimeSeries`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1194#issuecomment-1115175994:539,load,load,539,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1194#issuecomment-1115175994,2,['load'],"['load', 'loading']"
Performance,"We think there is a race condition in the CI. Partly discussed on #3661 and also #3662, although one conclusions is that we should update to use the buildkite plugin (started on #3042)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3751#issuecomment-2322236885:20,race condition,race condition,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3751#issuecomment-2322236885,1,['race condition'],['race condition']
Performance,"We use that function to initialize a correct array before performing global reductions (i.e. all zeros for sums, all 1s for prods and so on...) which are called when showing a field (if you put a semicolon after `myfield = CenterField(grid)` the error will disappear) Apparently they have changed the signature of the function in julia-1.8. Adapting Oceananigans to the new `initarray!` was on the table, I guess it's a good time to fix it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2663#issuecomment-1185068632:58,perform,performing,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2663#issuecomment-1185068632,1,['perform'],['performing']
Performance,"We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions). Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047180293:113,perform,performance,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047180293,2,"['optimiz', 'perform']","['optimizations', 'performance']"
Performance,"We've seen issues noise in the vertical velocity along immersed boundaries in other configurations too. I've seen at least one result in which the noise is substantially mitigated by using the PCG solver, which avoids the approximations of the ""naive"" FFT solver. Unfortunately, we don't yet have a performant PCG-based solver cc @simone-silvestri @xkykai . I think it's interesting and also convenient that the noise is mitigated in turbulent cases or by the inclusion of bottom drag.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3526#issuecomment-2028935410:299,perform,performant,299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3526#issuecomment-2028935410,1,['perform'],['performant']
Performance,"Weird, I see no mention of threads or multi-threading; ```; help?> plan_fft; search: plan_fft plan_fft! plan_rfft plan_ifft plan_bfft plan_ifft! plan_bfft! plan_irfft plan_brfft. plan_fft(A [, dims]; flags=FFTW.ESTIMATE, timelimit=Inf). Pre-plan an optimized FFT along given dimensions (dims) of arrays matching the shape and type of A. (The first two arguments have the same meaning as for fft.) Returns an object P which; represents the linear operator computed by the FFT, and which contains all of the information needed to compute fft(A, dims) quickly. To apply P to an array A, use P * A; in general, the syntax for applying plans is much like that of matrices. (A plan can only be applied to arrays of the same size as the A for which; the plan was created.) You can also apply a plan with a preallocated output array Â by calling mul!(Â, plan, A). (For mul!, however, the input array A must be a complex floating-point; array like the output Â.) You can compute the inverse-transform plan by inv(P) and apply the inverse plan with P \ Â (the inverse plan is cached and reused for subsequent calls to inv or; \), and apply the inverse plan to a pre-allocated output array A with ldiv!(A, P, Â). The flags argument is a bitwise-or of FFTW planner flags, defaulting to FFTW.ESTIMATE. e.g. passing FFTW.MEASURE or FFTW.PATIENT will instead spend several seconds (or more) benchmarking; different possible FFT algorithms and picking the fastest one; see the FFTW manual for more information on planner flags. The optional timelimit argument specifies a rough upper bound on; the allowed planning time, in seconds. Passing FFTW.MEASURE or FFTW.PATIENT may cause the input array A to be overwritten with zeros during plan creation. plan_fft! is the same as plan_fft but creates a plan that operates in-place on its argument (which must be an array of complex floating-point numbers). plan_ifft and so on are similar; but produce plans that perform the equivalent of the inverse transforms ifft and so",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471179127:38,multi-thread,multi-threading,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471179127,2,"['multi-thread', 'optimiz']","['multi-threading', 'optimized']"
Performance,"Well, it looks like this PR does not completely solve the problem, and the jury is out perhaps on whether it helps or not. I did learn a few things. It seems the race condition originates from an attempt to ""re-resolve"" the manifest during the test:. https://buildkite.com/clima/oceananigans/builds/17516#01920c32-4e89-4654-a4a8-9b077e51e87c/39-221. The puzzling part is how to solve the problem. I thought at first we could solve it by preventing the Manifest from being ""re-resolved"" --- perhaps by resolving it correctly during initialization? But actually, this isn't possible, since the problematic manifest in question is a temporary run that is created only for the tests (and its different from the project's manifest, because it also includes the test dependencies). This temporary test manifest can't be initialized as far as I can tell and is created independently for each test. Finally, it seems that some race conditions happen in a print statement (this is just from reading the error message). It all boils down eventually to these two lines:. https://github.com/JuliaLang/Pkg.jl/blob/5fbfa125045ce3e68ce10bf9fc1727bb3232c123/src/Operations.jl#L799-L800. The command its trying to run is. ```julia; ERROR: failed process: Process(`/net/ocean/home/data44/data5/glwagner/julia-1.10.5/bin/julia -C native -J/net/ocean/home/data44/data5/glwagner/julia-1.10.5/lib/julia/sys.so -O0 -g1 --color=yes -O0 --color=no --history-file=no --startup-file=no --project=/tmp/jl_f9Z8t1/Project.toml --eval 'append!(empty!(Base.DEPOT_PATH), [""/data5/glwagner/.julia-17516""]); --;   | append!(empty!(Base.DL_LOAD_PATH), String[]). cd(""/data5/glwagner/.julia-17516/packages/CUDA_Runtime_jll/YgJCI/.pkg""); --;   | include(""/data5/glwagner/.julia-17516/packages/CUDA_Runtime_jll/YgJCI/.pkg/select_artifacts.jl"");   | ' -t1 --startup-file=no x86_64-linux-gnu-libgfortran5-cxx11-julia_version+1.10.5`, ProcessSignaled(11)) [0]; ```. and supposedly the issue arises within the `select_artifacts.jl` call in `CUD",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2362378199:162,race condition,race condition,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2362378199,4,['race condition'],"['race condition', 'race conditions']"
Performance,"Well, there was a major bug associated with the fact that we were trying to avoid precomputed the diffusivities. Basically, diffusivities cannot be computed on the fly due to the ""predictor-corrector"" algorithm we use for implicit time stepping. Opting to precompute diffusivities solves this problem, at the cost of three additional 3D model fields when using `TKEBasedVerticalDiffusivity`. I think this is not a huge price to pay considering that models with 3 velocities and n tracers have (3 + n) * 3 fields already; thus in the simplest case (one buoyancy tracer and one TKE tracer) we incur ~20% (3/15) additional memory allocation from diffusivity precomputation. We can optimize memory allocation further in the future as well, potentially. On the upside, things are looking pretty good now. From the wind mixing validation:. ![image](https://user-images.githubusercontent.com/15271942/118858897-14dba700-b886-11eb-93b2-b4be1a6ea8ed.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1664#issuecomment-844323514:678,optimiz,optimize,678,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1664#issuecomment-844323514,2,['optimiz'],['optimize']
Performance,"What do you mean by 'fetched'? Are you referring to memory movement from main memory to cache?. I don't know much about cache optimization, but I think a guideline is that nearby operations should be nearby in memory. For example, when looping over elements of an array `u[i]`, your machine will use a linear forecast to bring `u[i-1], u[i-2], u[i+1], u[i+2]` into the cache simultaneous to `u[i]`. This idea leads to the 'struct of arrays' optimization when running loops over the elements of many arrays simultaneously. This may be useful:. https://software.intel.com/en-us/articles/memory-layout-transformations",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/44#issuecomment-462541310:88,cache,cache,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/44#issuecomment-462541310,5,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"What does J-M think?; John. On Mon, Mar 9, 2020, 3:07 PM rafferrari <notifications@github.com> wrote:. > The Roquet’s approximation is perfectly sufficient for Oceananigans,; > because it will never be used for global calculations where local; > approximations are an issue. However I agree with everybody else that it; > would be best to use the same EOS in Ocenanigans and Climate_Ocean. in that; > case we should adopt TEOS-10. Be warned that it is quite inefficient; > through. So we may be hit performance-wise. Hard to tell without trying.; >; > Raffaele; >; >; >; > > On Mar 9, 2020, at 11:48 AM, Gregory L. Wagner <notifications@github.com>; > wrote:; > >; > > I also think it’s a good idea to use a full equation of state for all; > simulations sooner rather than later. It’s simpler: we won’t have to report; > constants of linearization everywhere. And setting up simulations will be; > easier.; > >; > > I’ll defer to the modelers for whether Roquet’s approximation is an; > acceptable model for TEOS-10.; > >; > > This package is relevant and we should consider contributing to it; > rather than implementing an equation of state somewhere in the Clima; > ecosystem:; > >; > > https://github.com/gher-ulg/PhysOcean.jl <; > https://github.com/gher-ulg/PhysOcean.jl>; > > —; > > You are receiving this because you were mentioned.; > > Reply to this email directly, view it on GitHub <; > https://github.com/climate-machine/Oceananigans.jl/issues/692?email_source=notifications&email_token=AK24ROIBMZMYD77AGEZNM3DRGUMURA5CNFSM4LEKJAAKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEOHZCYQ#issuecomment-596611426>,; > or unsubscribe <; > https://github.com/notifications/unsubscribe-auth/AK24ROONT4RO4YCCF6BTIIDRGUMURANCNFSM4LEKJAAA; > >.; > >; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/692?email_source=notifications&email_token=AKXUEQUJLIMSIC2HX",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/692#issuecomment-596864018:499,perform,performance-wise,499,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/692#issuecomment-596864018,1,['perform'],['performance-wise']
Performance,What's are the possible causes of the performance difference? What code should we focus on if we want to close this performance gap in the future?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1194187328:38,perform,performance,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1194187328,2,['perform'],['performance']
Performance,When I ran this locally I got a load of `@test_broken` passing for computed fields which is quite strange,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2180941031:32,load,load,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2180941031,1,['load'],['load']
Performance,"When using `with_halos = true` in the `JLD2OutputWriter` works well, however in `NetCDFOutputWriter` it crashes with the following error: . ```; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 11 seconds, wall time: 0 seconds; ERROR: LoadError: DimensionMismatch: new dimensions (156, 156, 22, 1) must be consistent with array size 24336; Stacktrace:; [1] (::Base.var""#throw_dmrsa#328"")(dims::NTuple{4, Int64}, len::Int64); @ Base ./reshapedarray.jl:41; [2] reshape(a::Array{Float64, 3}, dims::NTuple{4, Int64}); @ Base ./reshapedarray.jl:45; [3] setindex_disk!(::NCDatasets.Variable{Float64, 4, NCDataset{Nothing}}, ::Array{Float64, 3}, ::Function, ::Vararg{Any}); @ DiskArrays /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:56; [4] setindex!; @ /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:229 [inlined]; [5] setindex!(::CommonDataModel.CFVariable{…}, ::Array{…}, ::Colon, ::Colon, ::Colon, ::UnitRange{…}); @ CommonDataModel /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/CommonDataModel/pO4st/src/cfvariable.jl:419; [6] save_output!(ds::NCDataset{…}, output::Field{…}, model::HydrostaticFreeSurfaceModel{…}, ow::NetCDFOutputWriter{…}, time_index::Int64, name::String); @ Oceananigans.OutputWriters /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/Oceananigans/17XSY/src/OutputWriters/netcdf_output_writer.jl:479; [7] write_output!(ow::NetCDFOutputWriter{…}, model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.OutputWriters /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/Oceananigans/17XSY/src/OutputWriters/netcdf_output_writer.jl:518; [8] initialize!(sim::Simulation{…}); @ Oceananigans.Simulations /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/Oceananigans/17XSY/src/Simulations/run.jl:212; [9] time_step!(sim::Simul",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2007187819:260,Load,LoadError,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2007187819,1,['Load'],['LoadError']
Performance,Width; Max : 16x; Current : 16x; Bridge Chip; Type : N/A; Firmware : N/A; Replays Since Reset : 0; Replay Number Rollovers : 0; Tx Throughput : 0 KB/s; Rx Throughput : 0 KB/s; Atomic Caps Inbound : N/A; Atomic Caps Outbound : N/A; Fan Speed : N/A; Performance State : P0; Clocks Throttle Reasons; Idle : Active; Applications Clocks Setting : Not Active; SW Power Cap : Not Active; HW Slowdown : Not Active; HW Thermal Slowdown : Not Active; HW Power Brake Slowdown : Not Active; Sync Boost : Not Active; SW Thermal Slowdown : Not Active; Display Clock Setting : Not Active; FB Memory Usage; Total : 32768 MiB; Reserved : 267 MiB; Used : 0 MiB; Free : 32500 MiB; BAR1 Memory Usage; Total : 32768 MiB; Used : 2 MiB; Free : 32766 MiB; Compute Mode : Default; Utilization; Gpu : 0 %; Memory : 0 %; Encoder : 0 %; Decoder : 0 %; Encoder Stats; Active Sessions : 0; Average FPS : 0; Average Latency : 0; FBC Stats; Active Sessions : 0; Average FPS : 0; Average Latency : 0; Ecc Mode; Current : Enabled; Pending : Enabled; ECC Errors; Volatile; Single Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : N/A; Total : 0; Double Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : 0; Total : 0; Aggregate; Single Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : N/A; Total : 0; Double Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : 0; Total : 0; Retired Pages; Single Bit ECC : 0; Double Bit ECC : 0; Pending Page Blacklist : No; Remapped Rows : N/A; Temperature; GPU Current Temp : 41 C; GPU Shutdown Temp : 90 C; GPU Slowdown Temp : 87 C; GPU Max Operating Temp : 83 C; GPU Target Temperature : N/A; Memory Current Temp : 44 C; Memory Max Operating Temp : 85 C; Power Readings; Power Management : Supported; Power Draw : 44.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:21405,Cache,Cache,21405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,8,['Cache'],['Cache']
Performance,Will merge and keep a look out for race conditions on Buildkite.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1804#issuecomment-872544140:35,race condition,race conditions,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1804#issuecomment-872544140,1,['race condition'],['race conditions']
Performance,"Would be good to do some profiling (probably with a system profiler like perf), to understand where time is spent. The kernels using KernelAbstractions are automatically multi-threaded.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880765565:170,multi-thread,multi-threaded,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880765565,1,['multi-thread'],['multi-threaded']
Performance,"Yeah I guess we're pretty restricted in our thread-block layouts although it should be easy to generate them for all the grids we usually use. The important thing is that we can run on a wide variety of useful grid sizes, instead of being restricted to multiples of 16 in the horizontal like we are right now. It's also important to keep the kernel indexing intuitive, e.g. this kernel does things point-wise so it gets a triple for-loop, another kernel does things column-wise so it gets a double for-loop and a third unrolled inner loop, another only acts on the surface and bottom, etc. So maybe it's not worth introducing `Tz` (which might complicate the kernels) unless we know it'll improve performance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/249#issuecomment-496545455:697,perform,performance,697,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/249#issuecomment-496545455,1,['perform'],['performance']
Performance,"Yeah the plot is from v0.5.x or something lol. Not sure if CPU -> GPU speedups are as relevant anymore? Well, maybe a lot of people are still on CPUs. The speedup can be much larger with WENO, but it's all very CPU and GPU dependent. I've seen ~8x and ~2000x speedups for the same benchmark. Also not sure if there are any good metrics to quantify performance. But @simone-silvestri's scaling plots would probably be great to include?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3684#issuecomment-2272351495:348,perform,performance,348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3684#issuecomment-2272351495,1,['perform'],['performance']
Performance,Yeah this is pretty worrying... I'm pretty sure this is the cause of https://github.com/CliMA/Oceananigans.jl/issues/1420 which has been open for a while so this slowdown must have been around for a while (and just flew under the radar). [Profiling](https://docs.julialang.org/en/v1/manual/profile/) might help pinpoint the bottleneck.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891426665:324,bottleneck,bottleneck,324,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891426665,1,['bottleneck'],['bottleneck']
Performance,"Yes, from what I could test so far the CPU performance seems roughly; equivalent between versions. Although it would be good if someone else; tried to validate that as well. On Fri, Jun 25, 2021, 09:16 Gregory L. Wagner ***@***.***>; wrote:. > I'm sorry, I misinterpreted the results @ali-ramadhan; > <https://github.com/ali-ramadhan> posted. I thought that; > CenteredSecondOrder was 1.0x slower with julia 1.6 than with 1.5 (and; > that small slowdowns were observed for the other schemes, which is why I; > recommended testing the biharmonic scheme.) Now I understand that these; > results are all for julia 1.6; we are comparing the results with previously; > obtained benchmarks (not posted) for julia 1.5.; >; > Looking at @tomchor <https://github.com/tomchor> and @ali-ramadhan; > <https://github.com/ali-ramadhan>'s results then it looks like; > simulations with WENO5 are running approximately 6-8 times slower on julia; > 1.6 than it was on julia 1.5, while other advection schemes (and closures); > are unchanged --- correct?; >; > Is the *CPU* performance of WENO5 roughly equivalent between julia 1.5; > and julia 1.6?; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868677634>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KV46VENYCZPAGUMK4LTUSTVVANCNFSM47I24R7Q>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868684330:43,perform,performance,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868684330,2,['perform'],['performance']
Performance,Yes. It is! And this example should be optimized. But until then I’m merging this so the developers have a slightly easier life ;),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3168#issuecomment-1616796587:39,optimiz,optimized,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3168#issuecomment-1616796587,1,['optimiz'],['optimized']
Performance,"Yesterday, @ali-ramadhan and I discussed a new idea for improving the abstraction of equations. The idea is to abstract a `RightHandSide` consisting of a tuple of `Flux`es and `VolumeTerm`s or `SourceTerm`s. Each `Flux` or `VolumeTerm` type would define a `getindex` method, and carry around the references needed to execute that `getindex` method on CPU or GPU. This would greatly simplify the time-stepping routines, which currently involve long function signatures. There'd be no need for 'unpacking', because each term in the equation would perform unpacking upon instantiation. It would also probably be easier for users to extend / add terms to an equation. As an example, we can consider a simple implementation. ```julia; struct AdvectiveFlux{S, D, C, G}; u :: D; v :: D; w :: D; c :: C; grid :: G; scheme :: S; end. getindex(adv::AdvectiveFlux{Centered}, i, j, k) = # centered advective flux calculation. struct IsotropicDiffusiveFlux{N, D, G}; ν :: N; ψ :: D; grid :: G; end. getindex(diff::IsotropicDiffusiveFlux, i, j, k) = # calculates flux due to isotropic diffusion by ν. struct RightHandSide{F, V}; fluxes :: F; volume_terms :: V; end. advection = AdvectiveFlux(velocities..., tracers.c); diffusion = IsotropicDiffusiveFlux(ν, tracers.c). tracer_rhs = RightHandSide((advection, diffusion), nothing); ```. We'd have functions that look something like. ```julia; function x_flux_divergence(i, j, k, grid, fluxes...); incoming_flux = add_fluxes(i, j, k, grid, fluxes...); outgoing_flux = add_fluxes(i+1, j, k, grid, fluxes...); return (incoming_flux - outgoing_flux) * grid.Ax / grid.V; end; ```. ... for example. Obviously questions of performance are paramount, though in the case that _everything_ is inlined I think there is hope. A downside of this approach is that we can't use shared memory stencils on the GPU. Shared memory stencils on the GPU require _functions_ for all terms that avoid carrying around internal references to data (since we need to be able to pass them referen",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394:545,perform,perform,545,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394,1,['perform'],['perform']
Performance,"You can use both `@inline` and `@inbounds`; they mean different things. `@inline` is a compiler directive to inline a function (important for performance when a function is called within inner loops). We put `@inline` in front of functions; eg `@inline f(x) = ...`. `@inbounds` elides bounds checking when an array / field is indexed into. We need `@inbounds` in front of any indexing operation that occurs in a loop (eg `u[i, j, k]`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875676924:142,perform,performance,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875676924,1,['perform'],['performance']
Performance,You should be able to load any NetCDF file using xarray and it gives you a nice and powerful interface for analyzing and manipulating the data. Probably not the best example as it's a little old and messy (I've started using Makie more often) but here's one example: https://github.com/CliMA/LESbrary.jl/blob/3595ff2e1db6d5e6898b6ea84335fdb9dbd23b15/src/make_lesbrary_plots.py,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772770432:22,load,load,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772770432,1,['load'],['load']
Performance,"[10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); │ @ Base ./loading.jl:2983; │ [11] maybe_cachefile_lock; │ @ ./loading.jl:2980 [inlined]; │ [12] _require(pkg::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1970; │ [13] __require_prelocked(uuidkey::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1812; │ [14] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [15] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [16] _require_prelocked; │ @ ./loading.jl:1803 [inlined]; │ [17] _require_prelocked; │ @ ./loading.jl:1802 [inlined]; │ [18] run_extension_callbacks(extid::Base.ExtensionId); │ @ Base ./loading.jl:1295; │ [19] run_extension_callbacks(pkgid::Base.PkgId); │ @ Base ./loading.jl:1330; │ [20] run_package_callbacks(modkey::Base.PkgId); │ @ Base ./loading.jl:1164; │ [21] _tryrequire_from_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.jl:1574; │ [23] _require(pkg::Base.PkgId, env::String); │ @ Base ./loading.jl:1938; │ [24] __require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1812; │ [25] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [26] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [27] _require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1803; │ [28] macro expansion; │ @ ./loading.jl:1790 [inlined]; │ [29] macro expansion; │ @ ./lock.jl:267 [inlined]; │ [30] __require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1753; │ [31] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [32] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [33] require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1746; │ [34] eval; │ @ ./boot.jl:385 [inlined]; │ [35] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:3058,load,loading,3058,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"[2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If we use short-circuiting logic, then I guess many optimizations are not possible, because execution on one branch or another must be completely excluded. Some of this is discussed here: https://discourse.julialang.org/t/multiplying-by-booleans-faster-than-if-else/64117. > What about @inline?. This a little hazier. The compiler decides based on a heuristic whether or not to ""inline"" a function (meaning, rather than compiling code for a function independently and jumping to that code at the right moment, it combines the function code with the code that calls the function). We want to inline everything basically, so that every tendency evaluation involves evaluating one giant function. Inlining lets LLVM magic optimize our code to the highest degree (at least that's my impression). For whatever reason the compiler often decides _not_ to inline our functions unless we specifically annotate them. So it seems we probably need to add `@inline` to every ""hot"" function that's called in a kernel, at every grid point (like a forcing function or boundary condition function). But I suggest you benchmark yourself and see!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:2716,optimiz,optimize,2716,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583,1,['optimiz'],['optimize']
Performance,"] is required but does not seem to be installed:; - Run `Pkg.instantiate()` to install all recorded dependencies. Stacktrace:; [1] _require(pkg::Base.PkgId); @ Base ./loading.jl:990; [2] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [3] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; [4] include(mod::Module, _path::String); @ Base ./Base.jl:386; [5] include(x::String); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; [6] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; [7] include(mod::Module, _path::String); @ Base ./Base.jl:386; [8] include(x::String); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; [9] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:46; [10] include; @ ./Base.jl:386 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics/math.jl:5; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /home/tomas/.julia/compiled/v1.6/CUDA/jl_q4lPlx.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @ Ba",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371:1350,load,loading,1350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371,1,['load'],['loading']
Performance,"_bfft plan_ifft! plan_bfft! plan_irfft plan_brfft; >; >; >; > plan_fft(A [, dims]; flags=FFTW.ESTIMATE, timelimit=Inf); >; >; >; > Pre-plan an optimized FFT along given dimensions (dims) of arrays matching the shape and type of A. (The first two arguments have the same meaning as for fft.) Returns an object P which; >; > represents the linear operator computed by the FFT, and which contains all of the information needed to compute fft(A, dims) quickly.; >; >; >; > To apply P to an array A, use P * A; in general, the syntax for applying plans is much like that of matrices. (A plan can only be applied to arrays of the same size as the A for which; >; > the plan was created.) You can also apply a plan with a preallocated output array Â by calling mul!(Â, plan, A). (For mul!, however, the input array A must be a complex floating-point; >; > array like the output Â.) You can compute the inverse-transform plan by inv(P) and apply the inverse plan with P \ Â (the inverse plan is cached and reused for subsequent calls to inv or; >; > \), and apply the inverse plan to a pre-allocated output array A with ldiv!(A, P, Â).; >; >; >; > The flags argument is a bitwise-or of FFTW planner flags, defaulting to FFTW.ESTIMATE. e.g. passing FFTW.MEASURE or FFTW.PATIENT will instead spend several seconds (or more) benchmarking; >; > different possible FFT algorithms and picking the fastest one; see the FFTW manual for more information on planner flags. The optional timelimit argument specifies a rough upper bound on; >; > the allowed planning time, in seconds. Passing FFTW.MEASURE or FFTW.PATIENT may cause the input array A to be overwritten with zeros during plan creation.; >; >; >; > plan_fft! is the same as plan_fft but creates a plan that operates in-place on its argument (which must be an array of complex floating-point numbers). plan_ifft and so on are similar; >; > but produce plans that perform the equivalent of the inverse transforms ifft and so on.; >; >; >; > help?> plan_fft!;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471179341:1350,cache,cached,1350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471179341,1,['cache'],['cached']
Performance,"_require_prelocked; │ @ ./loading.jl:1803 [inlined]; │ [17] _require_prelocked; │ @ ./loading.jl:1802 [inlined]; │ [18] run_extension_callbacks(extid::Base.ExtensionId); │ @ Base ./loading.jl:1295; │ [19] run_extension_callbacks(pkgid::Base.PkgId); │ @ Base ./loading.jl:1330; │ [20] run_package_callbacks(modkey::Base.PkgId); │ @ Base ./loading.jl:1164; │ [21] _tryrequire_from_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.jl:1574; │ [23] _require(pkg::Base.PkgId, env::String); │ @ Base ./loading.jl:1938; │ [24] __require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1812; │ [25] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [26] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [27] _require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1803; │ [28] macro expansion; │ @ ./loading.jl:1790 [inlined]; │ [29] macro expansion; │ @ ./lock.jl:267 [inlined]; │ [30] __require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1753; │ [31] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [32] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [33] require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1746; │ [34] eval; │ @ ./boot.jl:385 [inlined]; │ [35] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; │ [36] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; │ [37] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; │ [38] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); │ @ REPL ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:3557,load,loading,3557,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"`0` is almost always safe. But neither case is really an issue. The main issues are when the entirety of a heavy kernel (like one that calculates a tendency) may be promoted to higher precision. ~`fill(var, 0)`~ `fill!(var, 0)` is cheap and unlikely to affect performance. That said it's just more precise to write `fill(var, zero(eltype(var)))` (this is _exactly_ what you are trying to do) and therefore the preferred way to write it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723671988:260,perform,performance,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723671988,1,['perform'],['performance']
Performance,"```; julia> using Distributed. help?> addprocs; search: addprocs. addprocs(manager::ClusterManager; kwargs...) -> List of process identifiers. Launches worker processes via the specified cluster manager. For example, Beowulf clusters are supported via a custom cluster manager implemented in the package ClusterManagers.jl. The number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable; JULIA_WORKER_TIMEOUT in the worker process's environment. Relevant only when using TCP/IP as transport. To launch workers without blocking the REPL, or the containing function if launching workers programmatically, execute addprocs in its own task. Examples; ≡≡≡≡≡≡≡≡≡≡. # On busy clusters, call `addprocs` asynchronously; t = @async addprocs(...). # Utilize workers as and when they come online; if nprocs() > 1 # Ensure at least one new worker is available; .... # perform distributed execution; end. # Retrieve newly launched worker IDs, or any error messages; if istaskdone(t) # Check if `addprocs` has completed to ensure `fetch` doesn't block; if nworkers() == N; new_pids = fetch(t); else; fetch(t); end; end. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers. Add worker processes on remote machines via SSH. Configuration is done with keyword arguments (see below). In particular, the exename keyword; can be used to specify the path to the julia binary on the remote machine(s). machines is a vector of ""machine specifications"" which are given as strings of the form [user@]host[:port] [bind_addr[:port]]. user defaults to; current user and port to the standard SSH port. If [bind_addr[:port]] is specified, other workers will connect to this worker at the specified; bind_addr and port. It is possible to launch multiple processes on a r",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:919,perform,perform,919,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['perform'],['perform']
Performance,"```; using Oceananigans.Diagnostics: accurate_cell_advection_timescale; using Oceananigans.Utils: cell_advection_timescale; wizard = TimeStepWizard(cfl=0.5,Δt=10.0, max_change=1.1, max_Δt=1minute, cell_advection_timescale = accurate_cell_advection_timescale); ```; gives the following error right now-. ```; MethodError: no method matching TimeStepWizard(; cfl=0.5, Δt=10.0, max_change=1.1, max_Δt=60.0, cell_advection_timescale=Oceananigans.Diagnostics.accurate_cell_advection_timescale); Closest candidates are:; TimeStepWizard(; cfl, diffusive_cfl, max_change, min_change, max_Δt, min_Δt, Δt) at C:\Users\91766\.julia\packages\Oceananigans\zj42o\src\Simulations\time_step_wizard.jl:23 got unsupported keyword argument ""cell_advection_timescale""; TimeStepWizard(::T, ::T, ::T, ::T, ::T, ::T, ::T) where T at C:\Users\91766\.julia\packages\Oceananigans\zj42o\src\Simulations\time_step_wizard.jl:2 got unsupported keyword arguments ""cfl"", ""Δt"", ""max_change"", ""max_Δt"", ""cell_advection_timescale"". Stacktrace:; [1] kwerr(::NamedTuple{(:cfl, :Δt, :max_change, :max_Δt, :cell_advection_timescale),Tuple{Float64,Float64,Float64,Float64,typeof(accurate_cell_advection_timescale)}}, ::Type{T} where T) at .\error.jl:157; [2] top-level scope at In[15]:1; [3] include_string(::Function, ::Module, ::String, ::String) at .\loading.jl:1091; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-862929408:1314,load,loading,1314,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-862929408,1,['load'],['loading']
Performance,"```Julia; [ Info: ... simulation initialization complete (1.471 minutes); [ Info: Executing initial time step...; ERROR: LoadError: TaskFailedException. nested task error: TaskFailedException. nested task error: type Tuple has no field surface_TKE_flux; Stacktrace:; [1] getproperty(x::Tuple{CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.MixingLength{Float64}, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.SurfaceTKEFlux{Float64}}, AnisotropicDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Float64, Float64, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}}}, f::Symbol); @ Base ./Base.jl:33; [2] call; @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:456 [inlined]; [3] fallback; @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:454 [inlined]; [4] overdub; @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:279 [inlined]; [5] overdub; @ ~/.julia/packages/Oceananigans/H39qI/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/surface_TKE_flux.jl:39 [inlined]; [6] getbc(::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.TKETopBoundaryConditionParameters{NamedTuple{(:b, :c, :e), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{NamedTuple{(:Ly, :Lz, :Qᵇ, :y_shutoff, :τ, :μ, :ΔB, :H, :h, :y_sponge, :λt), NTuple{11, Float64}}, typeof(buoyancy_flux)}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, NamedTuple{(:u, :v), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Name",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030718913:121,Load,LoadError,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030718913,1,['Load'],['LoadError']
Performance,"```Julia; julia> using Oceananigans, GLMakie; [ Info: Oceananigans will use 8 threads; [ Info: Precompiling TaylorSeriesIAExt [ed7ef945-33a4-511e-97fe-2b89c7a130ca]; ERROR: LoadError: UndefVarError: `IntervalBox` not defined; Stacktrace:; [1] top-level scope; @ ~/.julia/packages/TaylorSeries/2qRvJ/ext/TaylorSeriesIAExt.jl:182; [2] include; @ ./Base.jl:495 [inlined]; [3] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::Nothing); @ Base ./loading.jl:2222; [4] top-level scope; @ stdin:3; in expression starting at /Users/navid/.julia/packages/TaylorSeries/2qRvJ/ext/TaylorSeriesIAExt.jl:1; in expression starting at stdin:3; ┌ Error: Error during loading of extension TaylorSeriesIAExt of TaylorSeries, use `Base.retry_load_extensions()` to retry.; │ exception =; │ 1-element ExceptionStack:; │ Failed to precompile TaylorSeriesIAExt [ed7ef945-33a4-511e-97fe-2b89c7a130ca] to ""/Users/navid/.julia/compiled/v1.10/TaylorSeriesIAExt/jl_TNauRw"".; │ Stacktrace:; │ [1] error(s::String); │ @ Base ./error.jl:35; │ [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); │ @ Base ./loading.jl:2468; │ [3] compilecache; │ @ ./loading.jl:2340 [inlined]; │ [4] (::Base.var""#968#969""{Base.PkgId})(); │ @ Base ./loading.jl:1974; │ [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; │ [6] #mkpidlock#6; │ @ ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; │ [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; │ [8] #invokelatest#2; │ @ ./essentials.jl:894 [inlined",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:173,Load,LoadError,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,3,"['Load', 'load']","['LoadError', 'loading']"
Performance,"```[DengQ@localhost bin]$ ./julia; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.3 (2020-11-09); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> pkg""st --manifest""; ERROR: LoadError: UndefVarError: @pkg_str not defined; in expression starting at REPL[1]:1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824054281:345,Load,LoadError,345,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824054281,1,['Load'],['LoadError']
Performance,"```julia; (base) gregorywagner:Oceananigans.jl/ (main✗) $ JULIA_NUM_THREADS=6 julia --project race_condition_test.jl; [ Info: Oceananigans will use 6 threads; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (78.718 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (6.593 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; (parent(simulation.model.velocities.u))[1, 1, :] = [1.9561509021434433, 1.9561509021434433, 1.9560395693473134, 1.9560395693473134]; Test Failed at /Users/gregorywagner/Projects/test/Oceananigans.jl/race_condition_test.jl:17; Expression: (parent(simulation.model.velocities.u))[1, 1, 2] == (parent(simulation.model.velocities.u))[1, 1, 3]; Evaluated: 1.9561509021434433 == 1.9560395693473134; ERROR: LoadError: There was an error during testing; in expression starting at /Users/gregorywagner/Projects/test/Oceananigans.jl/race_condition_test.jl:17; ```. bingo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809#issuecomment-1308175571:856,Load,LoadError,856,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809#issuecomment-1308175571,1,['Load'],['LoadError']
Performance,"`const` matters when a variable is referenced as a global variable in a function; something like. ```julia; const a = 2; f(x) = a * x; ```. `a` is not an argument to `f(x)`; it's value is taken from the global scope. In that case it needs to be `const`, or `f(x)` cannot be compiled on the GPU. When numbers are added to explicit data structures --- which is what happens when they are inserted into the `parameters` kwarg in the constructor for `BoundaryCondition` or `Forcing` --- then it's irrelevant whether a variable is declared `const`. This is because in that case the variable is explicitly an argument to the function (eg via the argument `p` in `boundary_condition(x, y, t, p)`). In fact, this is the purpose of the `parameters` kwarg --- to avoid having to use `const` (which is annoying or inconvenient, and has compilation / performance pitfalls). However the API has not developed enough to completely avoid `const` in all cases (eg for `BackgroundFields`, or for masking / target functions in things like `Relaxation`). So we still wrestle with it from time to time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697:839,perform,performance,839,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697,1,['perform'],['performance']
Performance,"a/packages/CUDA/3VnCC/src/device/intrinsics/math.jl:5; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /home/tomas/.julia/compiled/v1.6/CUDA/jl_q4lPlx.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; [7] include; @ ./Base.jl:386 [inlined]; [8] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [9] top-level scope; @ none:1; [10] eval; @ ./boot.jl:360 [inlined]; [11] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [12] top-level scope; @ none:1; in expression starting at /home/tomas/repos/Oceananigans.jl/src/Oceananigans.jl:1; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /home/tomas/.julia/compiled/v1.6/Oceananigans/jl_psrPk0.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; in expression starting at /home/tomas/repos/Oceananigans.jl/docs/make.jl:8; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371:2638,load,loading,2638,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371,7,"['Load', 'load']","['LoadError', 'loading']"
Performance,"actOperation that computes Ri in advance; u, v, w = model.velocities; b = model.tracers.b; Ri_op = @at (Center, Center, Center) ∂z(b) / (∂z(u)^2 + ∂z(v)^2). """""" Compute the Richardson number and store in `Ri`. """"""; function compute_Ri!(sim); Ri .= Ri_op. # Zero NaNs; Ri_parent = parent(Ri); parent(Ri_parent)[isnan.(Ri_parent)] .= 0. fill_halo_regions!(Ri, sim.model.architecture); return nothing; end. simulation.callbacks[:compute_Ri] = Callback(compute_Ri!) # uses default IterationInterval(1). fields = []; function grab_fields!(sim); uⁿ = Array(interior(u, 1, 1, :)); vⁿ = Array(interior(v, 1, 1, :)); bⁿ = Array(interior(b, 1, 1, :)); iter = iteration(sim); t = time(sim); push!(fields, (; t, iter, u=uⁿ, v=vⁿ, b=bⁿ)); return nothing; end. simulation.callbacks[:grabber] = Callback(grab_fields!, TimeInterval(10minutes)). N² = 1e-4; S² = 1e-3 # Ri = 0.1; z₀ = -50; Δzu = 4; Δzb = 16. step(x, c, w) = 1/2 * (1 + tanh((x - c) / w)) # smooth step function. uᵢ(x, y, z) = Δzu * sqrt(S²) * step(z, z₀, Δzu); bᵢ(x, y, z) = Δzb * N² * step(z, z₀, Δzb). set!(model, u=uᵢ, b=bᵢ). run!(simulation). z = znodes(Center, grid); fig = Figure(); ax_u = Axis(fig[1, 1], ylabel=""z (m)"", xlabel=""u (m s⁻¹)""); ax_b = Axis(fig[1, 2], ylabel=""z (m)"", xlabel=""b (m s⁻²)""); slider = Slider(fig[2, :], range=1:length(fields), startvalue=1); n = slider.value; uⁿ = @lift fields[$n].u; bⁿ = @lift fields[$n].b. lines!(ax_u, uⁿ, z); lines!(ax_b, bⁿ, z). title = @lift ""Diffusing shear layer at t = "" * prettytime(fields[$n].t); Label(fig[0, :], title). display(fig). record(fig, ""pacanowski_philander_diffusion.gif"", 1:length(fields), framerate=12) do nn; @info ""Drawing frame $nn of $(length(fields))...""; n[] = nn; end; ```. produces. ![pacanowski_philander_diffusion](https://user-images.githubusercontent.com/15271942/158040409-1157f273-89b7-429e-b9f1-2bde8a62d00b.gif). My main concern is that our broadcasting may not be performant when used online during a simulation. Possibly, we can fix that or make it better.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065996051:2722,perform,performant,2722,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065996051,1,['perform'],['performant']
Performance,"ading.jl:1295; │ [19] run_extension_callbacks(pkgid::Base.PkgId); │ @ Base ./loading.jl:1330; │ [20] run_package_callbacks(modkey::Base.PkgId); │ @ Base ./loading.jl:1164; │ [21] _tryrequire_from_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.jl:1574; │ [23] _require(pkg::Base.PkgId, env::String); │ @ Base ./loading.jl:1938; │ [24] __require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1812; │ [25] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [26] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [27] _require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1803; │ [28] macro expansion; │ @ ./loading.jl:1790 [inlined]; │ [29] macro expansion; │ @ ./lock.jl:267 [inlined]; │ [30] __require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1753; │ [31] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [32] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [33] require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1746; │ [34] eval; │ @ ./boot.jl:385 [inlined]; │ [35] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; │ [36] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; │ [37] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; │ [38] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; │ [39] run_repl(repl::REPL.AbstractREPL, consumer::Any); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/RE",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:3740,load,loading,3740,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"ading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_zRopeZ"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/ap",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:2750,load,loading,2750,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"ading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/Oceananigans/jl_k7YOZN"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:5331,load,loading,5331,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"ait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:1; in expression s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:4499,load,loading,4499,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"ananigans.jl/test/test_enzyme.jl:285 [inlined]; [64] macro expansion; @ ~/.julia/juliaup/julia-1.10.5+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/Test/src/Test.jl:1577 [inlined]; [65] top-level scope; @ ~/Projects/Oceananigans.jl/test/test_enzyme.jl:265; [66] include(fname::String); @ Base.MainInclude ./client.jl:489; [67] top-level scope; @ REPL[6]:1; [68] eval; @ ./boot.jl:385 [inlined]; [69] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); @ REPL ~/.julia/juliaup/julia-1.10.5+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; [70] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); @ REPL ~/.julia/juliaup/julia-1.10.5+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; [71] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL ~/.julia/juliaup/julia-1.10.5+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; [72] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL ~/.julia/juliaup/julia-1.10.5+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; [73] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL ~/.julia/juliaup/julia-1.10.5+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; [74] (::Base.var""#1013#1015""{Bool, Bool, Bool})(REPL::Module); @ Base ./client.jl:432; [75] #invokelatest#2; @ ./essentials.jl:892 [inlined]; [76] invokelatest; @ ./essentials.jl:889 [inlined]; [77] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); @ Base ./client.jl:416; [78] exec_options(opts::Base.JLOptions); @ Base ./client.jl:333; Test Summary: | Error Total Time; Enzyme with CATKEVerticalDiffusivity | 1 1 7m42.2s; ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 1 errored, 0 broken.; in expression starting at /Users/gregorywagner/Projects/Oceananigans.jl/test/test_enzyme.jl:264; ```. @wsmoses",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3837#issuecomment-2400785596:153199,Load,LoadError,153199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3837#issuecomment-2400785596,1,['Load'],['LoadError']
Performance,"anigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid_ver = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz),; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,). model = IncompressibleModel(grid_ver = grid_ver,; ). wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=2,; stop_iteration=10,; ); #----. fields = model.velocities; simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath = ""wenegrat2020.nc"",; schedule = TimeInterval(5minutes),; mode = ""c""). run!(simulation); ```. and the error:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field xC; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] default_dimensions(::Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},B} where B where Z where Y where X}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::FieldSlicer{Colon,Colon,Colon}) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:1245,Load,LoadError,1245,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013,1,['Load'],['LoadError']
Performance,"ar""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6 ; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/h",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:1832,load,loading,1832,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"argument list;   | Stacktrace:;   | [1] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/non_traditional_beta_plane.jl:75;   | [2] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [3] include(x::String);   | @ Oceananigans.Coriolis ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:1;   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:28;   | [5] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [6] include(x::String);   | @ Oceananigans ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:5;   | [7] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:230;   | [8] include;   | @ ./Base.jl:419 [inlined];   | [9] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing);   | @ Base ./loading.jl:1554;   | [10] top-level scope;   | @ stdin:1;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-1/clima/oceananigans/src/Coriolis/non_traditional_beta_plane.jl:75;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:1;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:1;   | in expression starting at stdin:1;   | Stacktrace:;   | [1] pkgerror(msg::String);   | @ Pkg.Types /storage5/buildkite-agent/julia-1.8.2/share/julia/stdlib/v1.8/Pkg/src/Types.jl:67;   | [2] precompile(ctx::Pkg.Types.Context, pkgs::Vector{String}; internal_call::Bool, strict::Bool, warn_loaded::Bool, already_instantiated::Bool, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}});   | @ Pkg.API /storage5/buildkite-agent/julia-1.8.2/share/julia/stdlib/v1.8/Pkg/src/API.jl:1432;   | [3] precompile;   | @ /storage5/buildkite-agent/julia-1.8.2/share/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445:2186,load,loading,2186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445,1,['load'],['loading']
Performance,"arseArrays`; [10745b16] Statistics `@stdlib/Statistics`; [4607b0f0] SuiteSparse `@stdlib/SuiteSparse`; [fa267f1f] TOML `@stdlib/TOML`; [a4e569a6] Tar `@stdlib/Tar`; [8dfed614] Test `@stdlib/Test`; [cf7118a7] UUIDs `@stdlib/UUIDs`; [4ec0a83e] Unicode `@stdlib/Unicode`; [e66e0078] CompilerSupportLibraries_jll `@stdlib/CompilerSupportLibraries_jll`; [deac9b47] LibCURL_jll `@stdlib/LibCURL_jll`; [29816b5a] LibSSH2_jll `@stdlib/LibSSH2_jll`; [c8ffd9c3] MbedTLS_jll `@stdlib/MbedTLS_jll`; [14a3606d] MozillaCACerts_jll `@stdlib/MozillaCACerts_jll`; [05823500] OpenLibm_jll `@stdlib/OpenLibm_jll`; [efcefdf7] PCRE2_jll `@stdlib/PCRE2_jll`; [83775a58] Zlib_jll `@stdlib/Zlib_jll`; [8e850ede] nghttp2_jll `@stdlib/nghttp2_jll`; [3f19e933] p7zip_jll `@stdlib/p7zip_jll`; Precompiling project...; ✗ RecipesPipeline; ✗ Plots; 0 dependencies successfully precompiled in 7 seconds (205 already precompiled); 2 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages; Testing Running tests...; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads; [2023/02/21 06:36:13.652] WARN allowscalar([true]) is deprecated, use `allowscalar() do end` or `@allowscalar` to denote exactly which operations can use scalar operations. -@-> /g/data/v45/nc3020/OC.jl/test/dependencies_for_runtests.jl:71; [2023/02/21 06:36:18.673] WARN allowscalar([true]) is deprecated, use `allowscalar() do end` or `@allowscalar` to denote exactly which operations can use scalar operations. -@-> /g/data/v45/nc3020/OC.jl/test/dependencies_for_runtests.jl:71; [2023/02/21 06:36:18.728] WARN Over-writing registration of the datadep -@-> /g/data/v45/nc3020/.julia/packages/DataDeps/ae6dT/src/registration.jl:15; [2023/02/21 06:36:18.729] WARN Over-writi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:10505,load,load,10505,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['load'],['load']
Performance,"as `err` and call `code_typed(err; interactive = true)` to introspect the erronous code with Cthulhu.jl; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/validation.jl:147; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:440 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/RsWnF/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:439 [inlined]; [5] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:89; [6] emit_llvm; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:83 [inlined]; [7] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:129; [8] codegen; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:110 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:106; [10] compile; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:98 [inlined]; [11] #45; @ ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:57 [inlined]; [12] JuliaContext(f::Metal.var""#45#46""{GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:47; [13] compile(job::GPUCompiler.CompilerJob); @ Metal ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:56; [14] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, wor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:36640,optimiz,optimize,36640,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822,1,['optimiz'],['optimize']
Performance,"as created.) You can also apply a plan with a preallocated output array Â by calling mul!(Â, plan, A). (For mul!, however, the input array A must be a complex floating-point; >; > array like the output Â.) You can compute the inverse-transform plan by inv(P) and apply the inverse plan with P \ Â (the inverse plan is cached and reused for subsequent calls to inv or; >; > \), and apply the inverse plan to a pre-allocated output array A with ldiv!(A, P, Â).; >; >; >; > The flags argument is a bitwise-or of FFTW planner flags, defaulting to FFTW.ESTIMATE. e.g. passing FFTW.MEASURE or FFTW.PATIENT will instead spend several seconds (or more) benchmarking; >; > different possible FFT algorithms and picking the fastest one; see the FFTW manual for more information on planner flags. The optional timelimit argument specifies a rough upper bound on; >; > the allowed planning time, in seconds. Passing FFTW.MEASURE or FFTW.PATIENT may cause the input array A to be overwritten with zeros during plan creation.; >; >; >; > plan_fft! is the same as plan_fft but creates a plan that operates in-place on its argument (which must be an array of complex floating-point numbers). plan_ifft and so on are similar; >; > but produce plans that perform the equivalent of the inverse transforms ifft and so on.; >; >; >; > help?> plan_fft!; >; > search: plan_fft! plan_ifft! plan_bfft! plan_fft plan_rfft plan_ifft plan_bfft plan_irfft plan_brfft; >; >; >; > plan_fft!(A [, dims]; flags=FFTW.ESTIMATE, timelimit=Inf); >; >; >; > Same as plan_fft, but operates in-place on A.; >; >; > But I just learned that you can apply the inverse plan with P \ Â which is; > cool!; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/119#issuecomment-471179127>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AOkIBrJ-I9C04VxTFehp8CvR6NOT2nSeks5vU71agaJpZM4bmrZ0>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471179341:2269,perform,perform,2269,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471179341,1,['perform'],['perform']
Performance,"at the moment for chunked arrays the user can change with `set!`. For the above example of `fts3` which has a chunk size of 4:. ```; julia> fts3[1]; 17×16×10 Field{Face, Center, Center} on LatitudeLongitudeGrid on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── boundary conditions: Nothing; └── data: 23×22×16 OffsetArray(view(::Array{Float64, 4}, :, :, :, 1), -2:20, -2:19, -2:13) with eltype Float64 with indices -2:20×-2:19×-2:13; └── max=2.0, min=2.0, mean=2.0. julia> fts3[7]; ERROR: BoundsError: attempt to access 23×22×16×4 Array{Float64, 4} at index [1:23, 1:22, 1:16, 7]. julia> set!(fts3, 7:10). julia> fts3[7]; 17×16×10 Field{Face, Center, Center} on LatitudeLongitudeGrid on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── boundary conditions: Nothing; └── data: 23×22×16 OffsetArray(view(::Array{Float64, 4}, :, :, :, 1), -2:20, -2:19, -2:13) with eltype Float64 with indices -2:20×-2:19×-2:13; └── max=14.0, min=14.0, mean=14.0. julia> fts3[1]; ERROR: BoundsError: attempt to access 23×22×16×4 Array{Float64, 4} at index [1:23, 1:22, 1:16, -5]; Stacktrace:; ```. So at the moment the chunked field does not ""auto-load"". I am not sure whether it is better to autoload or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3233#issuecomment-1694023533:1310,load,load,1310,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233#issuecomment-1694023533,1,['load'],['load']
Performance,"ays.jl:12; &nbsp; | [13] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [14] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [15] top-level scope at none:2; &nbsp; | [16] eval at ./boot.jl:347 [inlined]; &nbsp; | [17] eval(::Expr) at ./client.jl:467; &nbsp; | [18] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/Pencils/Pencils.jl:7; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | ERROR: LoadError: Failed to precompile PencilArrays [0e08944d-e94e-41b1-9406-dcf66b6a9d2e] to /storage7/buildkite-agent/.julia-2581/compiled/v1.5/PencilArrays/yKKUy_zV1Ut.ji.; &nbsp; | Stacktrace:; &nbsp; | [1] error(::String) at ./error.jl:33; &nbsp; | [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1305; &nbsp; | [3] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [4] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [5] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [6] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [7] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [8] top-level scope at none:2; &nbsp; | [9] eval at ./boot.jl:347 [inlined]; &nbsp; | [10] eval(::Expr) at ./client.jl:467; &nbsp; | [11] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilFFTs/Xwxei/src/PencilFFTs.jl:11; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; |",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:5631,load,loading,5631,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['load'],['loading']
Performance,"belms with Oceananigans?. ```. ✗ Oceananigans; --;   | 105 dependencies successfully precompiled in 112 seconds;   | 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package;   | Precompiling project...;   | ✗ Oceananigans;   | 0 dependencies successfully precompiled in 22 seconds. 105 already precompiled.;   |  ;   | ERROR: The following 1 direct dependency failed to precompile:;   |  ;   | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];   |  ;   | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-9773/compiled/v1.8/Oceananigans/jl_yggB5x.;   | [NVBLAS] No Gpu available;   | [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf';   | [NVBLAS] Cannot open default config file 'nvblas.conf';   | [NVBLAS] Config parsed;   | [NVBLAS] CPU Blas library need to be provided;   | ERROR: LoadError: syntax: missing comma or ) in argument list;   | Stacktrace:;   | [1] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/non_traditional_beta_plane.jl:75;   | [2] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [3] include(x::String);   | @ Oceananigans.Coriolis ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:1;   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:28;   | [5] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [6] include(x::String);   | @ Oceananigans ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:5;   | [7] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:230;   | [8] include;   | @ ./Base.jl:419 [inlined];   | [9] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing);   | @ Base ./loadi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445:1148,Load,LoadError,1148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445,1,['Load'],['LoadError']
Performance,"c). ```; Topologies relative performance (GPU); ┌───────────────┬─────┬────────────────────────────────┬──────────┬──────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼──────────┼──────────┼─────────┤; │ GPU │ 192 │ (Bounded, Bounded, Bounded) │ 2.22277 │ 0.965821 │ 1.70133 │; │ GPU │ 192 │ (Bounded, Bounded, Periodic) │ 1.82308 │ 0.980729 │ 1.496 │; │ GPU │ 192 │ (Bounded, Periodic, Bounded) │ 1.82349 │ 0.984497 │ 1.4736 │; │ GPU │ 192 │ (Bounded, Periodic, Periodic) │ 2.26462 │ 0.989389 │ 1.24018 │; │ GPU │ 192 │ (Periodic, Bounded, Bounded) │ 1.82237 │ 0.984695 │ 1.47467 │; │ GPU │ 192 │ (Periodic, Bounded, Periodic) │ 1.54676 │ 0.992331 │ 1.25653 │; │ GPU │ 192 │ (Periodic, Periodic, Bounded) │ 1.30183 │ 0.99405 │ 1.22631 │; │ GPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴──────────┴─────────┘; ```. # Performance vs. main branch. ## Main branch. ```; Topologies benchmarks; ┌───────────────┬─────┬────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬────────────┬────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼────────┤; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 1.922 s │ 1.922 s │ 1.967 s │ 2.058 s │ 363.61 KiB │ 2163 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 2.143 s │ 2.144 s │ 2.145 s │ 2.146 s │ 317.33 KiB │ 1807 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.791 s │ 1.793 s │ 1.793 s │ 1.794 s │ 277.77 KiB │ 1661 │; │ GPU │ 192 │ (Periodic, Bounded, Bounded) │ 32.188 ms │ 37.447 ms │ 36.936 ms │ 37.557 ms │ 985.94 KiB │ 13476 │; │ GPU │ 192 │ (Periodic, Periodic, Bounded) │ 11.051 ms │ 11.114 ms │ 11.148 ms │ 11.533 ms │ 807.44 KiB │ 10746 │; │ GPU │ 192 │ (Periodic, Periodic, Periodi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:10941,Perform,Performance,10941,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296,1,['Perform'],['Performance']
Performance,"cache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6 ; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.P",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:1703,load,loading,1703,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_zRopeZ"".; Stacktrace:; [1] error(s::String); @ Base ./",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:2116,load,loading,2116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/Oceananigans/jl_k7YOZN"".; Stacktrace:;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:4697,load,loading,4697,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"cc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_zRopeZ"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.Pkg",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:2159,load,loading,2159,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"cc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/Oceananigans/jl_k7YOZN"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:4740,load,loading,4740,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"ce to provide but I can describe the problem as I've seen it. Basically, very rare, subtle irregularities have been observed on the GPU when using `HydrostaticFreeSurfaceModel` in a `Periodic, Bounded, Bounded` configuration. I think that it is possible the main issue is an interaction (a read-write race condition) associated with both impenetrable boundary conditions and periodic boundary conditions that affects the 8 corner points. The race condition affects model trajectories via the Coriolis force (which is the only term as far as I know that touches the 8 ""corner"" points affected by this race condition). Because the race condition only manifests when a `Coriolis` or `VectorInvariant` stencil touches corner points, it may not affect _most_ `Periodic, Periodic, Bounded` models, which could explain why we haven't caught it. The reason it doesn't affect those models is because this race condition would only affect the corner points of `w`, which are not touched when using an `FPlane` Coriolis model. However, it's possible (I'm not sure) that the race condition could affect models using `NonTraditionalFPlane` in `Periodic, Periodic, Bounded` configurations. More generally, it will also affect models that are bounded in the `y`-direction, because in those models the corner points of the `y`-velocity are affected and also invoked when using `FPlane` or `BetaPlane` coriolis. That's as much as I know. It's very hard to gather information about this bug because it's so rare are subtle. In other words, only one grid point among 10,000 iterations might be affected, and the errors induced are very small. To find this issue, we have to run tens of thousands of iterations of identical models on the GPU, and then compare some statistic of the model (ideally the entire velocity field, but @sandreza has gotten away just comparing something like `[maximum(abs, u), maximum(abs, v), maximum(abs, w)]`). If there's no race condition, identical models should produce identical results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865:1330,race condition,race condition,1330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865,2,['race condition'],['race condition']
Performance,"comparison of run wall time for the bickley jet `128²` between this PR and main (on the GPU). ; ; This is running the code till 200 seconds; | | Periodic | Periodic | Bounded | Bounded | Immersed | Immersed | ; | ---- | ---- | ---- | ---- | ---- | ---- | ---- |; | **Scheme** | this PR | Main | this PR | Main | this PR | Main |; Upwind 5 | 33.8967 | 64.0005 | 50.0858 | 47.4800 | 140.9554 | 107.9684 | ; WENO 5 VI | 28.4259 | 30.8202 | 37.8422 | 34.2834 | 123.7893 | 122.7207 |; WENO 5 FF | 27.9952 | 31.9765 | 32.2018 | 36.7740 | 111.0842 | 107.0792 |; Vector Inv | 28.9798 | 27.7792 | 37.5503 | 33.1336 | 125.4214 | 119.6501 |. Looking at these timings, everything seems in the ballpark (except for the immersed boundary) so I am not sure what might be the issue... I guess we would need an in depth profiling to understand this?. I say we merge. The benefit from time step increase covers for the performance decrease. And finding the root of such a decrease might be very difficult",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1192981334:901,perform,performance,901,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1192981334,1,['perform'],['performance']
Performance,"csLLVM; ✓ Colors; ✓ GPUArraysCore; ✓ NVTX. ✓ GPUArrays; ✓ KernelAbstractions; ✓ PrettyTables; ✓ GPUCompiler; ✓ DataFrames; ✗ CUDA; 61 dependencies successfully precompiled in 190 seconds. 5 already precompiled. The following 1 direct dependency failed to precompile:. CUDA [052768ef-5323-5732-b1bb-66c8b64840ba]. Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_UQIv2i"".; [45592] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:25; Allocations: 2907 (Pool: 2898; Big: 9); GC: ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_CUC33l"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:5241,load,loading,5241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,1,['load'],['loading']
Performance,"d = Int.(Ny/2-40:Ny/2+40); bottom[bound, bound] .= 0.5. grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)); mrg = MultiRegionGrid(grid, partition=XPartition(2), devices = 2); ```; and ; ```; u(x, y, z) = (x * z) / 10; ```. (with `ImplicitFreeSurface`) we get. #### Strong Scaling; | Grid size | Grid | GPUs | wall time | efficiency |; | -- | -- | -- | -- | -- |; | `1440×600×48`| `RectilinearGrid` | 1 | 1.85 minutes | 100% |; | `1440×600×48`| `MultiRegionGrid` | 2 | 1.12 minutes | 82.5% |. Scaling gets better?? at this point I a little confused...; Bottomline... ; there is still a bunch of optimization and more systematic benchmarking to be done, I'll merge this PR and then we can think about improving the scaling, the first things that come in mind are; - Ensure that all the `apply_regionally!` and `construct_regionally` calls are asynchronous. This might not be the case if there are memory copies inside function calls. That would serialize the execution of part of the code. To ensure this we require a more in-depth profiling using ***nsys***; - remove all `fill_halo_regions!` that are not `Periodic` or `Communication` which will allow asynchronous execution of halo filling across different direction (luckily already being done in #2477); - Bundle together the halo passing in a single boundary buffer to allow sending field tuples together (depends on #2509). Additional work to do on `MultiRegion` is ; - Perform more systematic benchmarking; - Design correct `OutputWriters` and `OutputReaders` for `MultiRegionFields`. Maybe not immediate priorities but definitely important; - Adapt `RungeKutta3` to `Multiregion` through `@apply_regionally`; - Implement a multi-region version of the Nonhydrostatic pressure solver; - Overlap computation and communication (for this we require _non-blocking_ `fill_halo_regions!` with returning `events`); - Optimize the distributed implicit solver (maybe using `PETSc.jl`? Might not be needed when the implicit solve fits in one GPU)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178:1612,Perform,Perform,1612,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178,2,"['Optimiz', 'Perform']","['Optimize', 'Perform']"
Performance,"d, apparently, `Σ² = S_ij S_ij` (if we believe we understand the notation here):. https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L97. This means that our formula is identical to Pressel et al (2015), but the constant is wrong: Pressel proposes `Cs=0.17`, and we have a default of `Cs=0.23`:. https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L63-L64. Amusingly, . ```julia; julia> 0.165 * sqrt(2); 0.23334523779156072; ```. which is probably not a coincidence. However, I'm not sure how an extra factor of `sqrt(2)` snuck into our constant. As for _clarification_, I don't have much to offer. Perhaps the constant was taken from some reference that used a different formulation than either us or Pressel et al. 2015. Nobody has submitted a validation test for this closure so I don't think we know how it performs. As a historical note, the paper cited by both Pressel et al (2015) and us is Lilly (1962), which does indeed use the same formulation:. ![image](https://user-images.githubusercontent.com/15271942/127507507-c7d11dfc-733a-4472-8216-dca4e5844b3f.png). where. ![image](https://user-images.githubusercontent.com/15271942/127507737-94aa05d4-6fa5-4d38-9a9d-b1bbcc8a1e79.png). @tomchor I can't tell if the formula you've pasted is actually different from ours (or what the definition of `|S|` is). Where does it come from?. It'd be fine to change the constant because there's no validation test. So the best we can do is theorize, and theorization on this issue suggests changing the default to `C=0.17`. If one wanted to set up a validation test, it could be nice to reproduce [Compte-Bellot and Corrsin (1964)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/simple-eulerian-time-correlation-of-fulland-narrowband-velocity-si",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927:2134,perform,performs,2134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927,2,['perform'],['performs']
Performance,"de; @ ./Base.jl:495 [inlined]; [3] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::Nothing); @ Base ./loading.jl:2222; [4] top-level scope; @ stdin:3; in expression starting at /Users/navid/.julia/packages/TaylorSeries/2qRvJ/ext/TaylorSeriesIAExt.jl:1; in expression starting at stdin:3; ┌ Error: Error during loading of extension TaylorSeriesIAExt of TaylorSeries, use `Base.retry_load_extensions()` to retry.; │ exception =; │ 1-element ExceptionStack:; │ Failed to precompile TaylorSeriesIAExt [ed7ef945-33a4-511e-97fe-2b89c7a130ca] to ""/Users/navid/.julia/compiled/v1.10/TaylorSeriesIAExt/jl_TNauRw"".; │ Stacktrace:; │ [1] error(s::String); │ @ Base ./error.jl:35; │ [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); │ @ Base ./loading.jl:2468; │ [3] compilecache; │ @ ./loading.jl:2340 [inlined]; │ [4] (::Base.var""#968#969""{Base.PkgId})(); │ @ Base ./loading.jl:1974; │ [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; │ [6] #mkpidlock#6; │ @ ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; │ [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; │ [8] #invokelatest#2; │ @ ./essentials.jl:894 [inlined]; │ [9] invokelatest; │ @ ./essentials.jl:889 [inlined]; │ [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); │ @ Base ./loading.jl:2983; │ [11] maybe_cachefile_lock; │ @ ./loading.jl:2980 [inlined]; │ [12] _require(pkg::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1970",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:1335,load,loading,1335,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"ded)); ```. `Hmmm, how small was the time step? `. I tried a few different values ranging from 1 sec to 60 sec. . I found that the `NaN` issue has to do with the `AnisotropicBiharmonicDiffusivity`. The following works:. ```; closure = AnisotropicDiffusivity(νh=kappaH_tmp, κh=kappaH_tmp, κz = kappaV, νz = kappaV); ```. but not this: . ```; closure = (AnisotropicDiffusivity(νh=0, κh=0, κz = kappaV, νz = kappaV),; AnisotropicBiharmonicDiffusivity(νh=kappaH, κh=kappaH)); ```. Also, `topology = (Periodic, Periodic, Bounded)` runs fine now, but `topology = (Periodic, Bounded, Bounded)` gives the following error:. ```; Loaded all modules; Starting the simulation...; ┌ Warning: You have used the default iteration_interval=1. This simulation will recalculate the time step every iteration which can be slow.; └ @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/gCqmh/src/Simulations/simulation.jl:68; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field Δz; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] cell_advection_timescale(::CuArray{Float64,3}, ::CuArray{Float64,3}, ::CuArray{Float64,3}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}}) at /home/guptam/.julia/packages/Oceananigans/gCqmh/src/Utils/cell_advection_timescale.jl:9; [3] cell_advection_timescale(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-792994007:1296,Load,LoadError,1296,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-792994007,1,['Load'],['LoadError']
Performance,does it change the performance?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2843#issuecomment-1332805489:19,perform,performance,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2843#issuecomment-1332805489,1,['perform'],['performance']
Performance,"e change we could make would be instead write. ```Julia; ""Calculate the right-hand-side of the u-momentum equation at I, j, k.""; u_eqn(args..., F::Function i, j, k) = stuff + F(u, v, w, T, S, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k); u_eqn(args..., F::AbstractArray i, j, k) = stuff + F[i, j, k]; u_eqn(args..., F::Nothing, i, j, k) = stuff. ""Store previous value of the source term and calculate current source term.""; function update_source_terms!(::Val{Dev}, fCor, χ, ρ₀, κh, κv, 𝜈h, 𝜈v, Nx, Ny, Nz, Δx, Δy, Δz,; u, v, w, T, S, pHY′, Gu, Gv, Gw, GT, GS, Gpu, Gpv, Gpw, GpT, GpS, F) where Dev; ; # ...; # u-momentum equation; @inbounds Gu[i, j, k] = u_eqn(args..., F.u, i, j, k); # ...; ```; We could write even less code if we created an abstraction for the right hand side, something like. ```Julia; struct Equation{TF}; G::Function; F::TF; end. (eq::Equation{TF})(args..., i, j, k) where TF <: Function = eq.G(args..., i, j, k) + eq.F(args..., i, j, k); (eq::Equation{TF})(args..., i, j, k) where TF <: AbstractArray = eq.G(args..., i, j, k) + eq.F(args..., i, j, k); (eq::Equation{TF})(args..., i, j, k) where TF <: Nothing = eq.G(args..., i, j, k) . u_eqn = Equation(Gu, Fu). ...; @inbounds Gu[i, j, k] = u_eqn(args..., i, j, k); ```. We can then load all the equations we have into a `FieldVector` or `LabeledArray` to make things even better and do something like . ```julia; @loop for k in (1:Nz; blockIdx().z); @loop for j in (1:Ny; (blockIdx().y - 1) * blockDim().y + threadIdx().y); @loop for i in (1:Nx; (blockIdx().x - 1) * blockDim().x + threadIdx().x); for (Gφ, i) in enumerate(G); φ_eqn = equation[i]; Gφ[i, j, k] = φ_eqn(args... i, j, k); end; end; end; end; ```. With a time-stepping kernel of that form we can easily add and subtract tracers, equations, sub grid closure variables, etc. I think the inner loop gets unrolled when the array is static, so the compiled code is no different from what we currently have. . This is somewhere down the line hopefully. Maybe v0.6... or 1.0. Heh.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470624169:1867,load,load,1867,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470624169,1,['load'],['load']
Performance,"e easier for users to extend / add terms to an equation. As an example, we can consider a simple implementation. ```julia; struct AdvectiveFlux{S, D, C, G}; u :: D; v :: D; w :: D; c :: C; grid :: G; scheme :: S; end. getindex(adv::AdvectiveFlux{Centered}, i, j, k) = # centered advective flux calculation. struct IsotropicDiffusiveFlux{N, D, G}; ν :: N; ψ :: D; grid :: G; end. getindex(diff::IsotropicDiffusiveFlux, i, j, k) = # calculates flux due to isotropic diffusion by ν. struct RightHandSide{F, V}; fluxes :: F; volume_terms :: V; end. advection = AdvectiveFlux(velocities..., tracers.c); diffusion = IsotropicDiffusiveFlux(ν, tracers.c). tracer_rhs = RightHandSide((advection, diffusion), nothing); ```. We'd have functions that look something like. ```julia; function x_flux_divergence(i, j, k, grid, fluxes...); incoming_flux = add_fluxes(i, j, k, grid, fluxes...); outgoing_flux = add_fluxes(i+1, j, k, grid, fluxes...); return (incoming_flux - outgoing_flux) * grid.Ax / grid.V; end; ```. ... for example. Obviously questions of performance are paramount, though in the case that _everything_ is inlined I think there is hope. A downside of this approach is that we can't use shared memory stencils on the GPU. Shared memory stencils on the GPU require _functions_ for all terms that avoid carrying around internal references to data (since we need to be able to pass them references to shared memory blocks, rather than references to global memory. This is a fair rewrite of the code internals. For example, each term in the `u_velocity_tendency`:. https://github.com/climate-machine/Oceananigans.jl/blob/8e3c27504be68ca06bacc7502cd6095ae390f8c6/src/TimeSteppers/velocity_and_tracer_tendencies.jl#L24. would get it's own type. It's worth brainstorming ways to implement such abstraction incrementally so we might avoid possibly time-consuming total-code-demolishment. This is mostly food for thought at this point. I don't think we should take action without substantial consideration.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394:1650,perform,performance,1650,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394,1,['perform'],['performance']
Performance,"e. I guess you're trying to couple an agent-based larvae model to an ocean model?. Oceananigans.jl should have the features you need I think: mainly Lagrangian particle tracking to advect the larvae around and arbitrary forced passive tracers for the odor from the reef?. I've actually been meaning to set up an example of an agent-based model coupled to Oceananigans.jl (simulating interacting ""microbes"" in the ocean). It's not fully complete yet but might give you some ideas of how to use Lagrangian particles as agents: https://github.com/CliMA/Oceananigans.jl/pull/1244. > If that works, I will implement a continuity equation to simulate the odor which comes from the reef and which is supposed to help the larvae to find back to the home reef. What is the continuity equation for the odor? It should be easy to advect the odor around as a passive tracer but just curious what the equation looks like. > Since I have found Oceananigans, which is also a CFD tool, I was wondering what you think the differences are between that and WaterLily.jl? Given my description of the project above, would you tend to use either of them?. I'm not super familiar with WaterLily.jl but it's definitely a very nice package (and a great README)!. I think WaterLily.jl has a more mature immersed boundary implementation if you need to have complex boundaries and is auto-diff friendly if you need to do some optimization/inference. @weymouth might be able to elaborate!. Oceananigans.jl has native support for Lagrangian particle tracking and might have more mature diagnostics (e.g. if you need to compute vorticity or other statistics) and more mature output writers (among other quality of life features). The examples in the docs should give a pretty good of the current set of mature features. E.g. this example shows how to add in a passive tracer for plankton and evolve it according to some (continuity?) equation: https://clima.github.io/OceananigansDocumentation/stable/generated/convecting_plankton/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1438#issuecomment-793113703:1547,optimiz,optimization,1547,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1438#issuecomment-793113703,1,['optimiz'],['optimization']
Performance,"e.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6 ; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loadi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:1751,load,loading,1751,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"e::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:129; [12] codegen; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:110 [inlined]; [13] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:106; [14] compile; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:98 [inlined]; [15] #40; @ ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:140 [inlined]; [16] JuliaContext(f::AMDGPU.Compiler.var""#40#41""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:47; [17] hipcompile(job::GPUCompiler.CompilerJob); @ AMDGPU.Compiler ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:139; [18] actual_compilation(cache::Dict{Any, AMDGPU.HIP.HIPFunction}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}, compiler::typeof(AMDGPU.Compiler.hipcompile), linker::typeof(AMDGPU.Compiler.hiplink)); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/execution.jl:125; [19] cached_compilation(cache::Dict{Any, AMDGPU.HIP.HIPFunction}, src::Core.MethodInstance, cfg::GPUCompiler.CompilerConfig{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}, compiler::Function, linker::Function); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/execution.jl:103; [20] macro expansion; @ ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:107 [inlined]; [21] macro expansion; @ ./lock.jl:267 [inlined]; [22] hipfunction(f::GPUArrays.var""#6#7"", tt::Type{Tuple{AMDGPU.ROCKernelContext, AMDGPU.Device.ROCDeviceArray{Float64, 3, 1}, Float64}}; kwargs::@Kwargs{name::Nothing}); @ AMDGPU.Compiler ~/.julia/packages/AMD",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273:2838,cache,cache,2838,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273,2,['cache'],['cache']
Performance,"eananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is using. * I think the `README.md` could be clearer and the scripts could have better names (eg which script runs the benchmark versus which script sets up the model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1476,Load,Loading,1476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590,2,['Load'],['Loading']
Performance,"eananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 143 already precompiled.; [ Info: Oceananigans will use 8 threads. julia> grid = RectilinearGrid(size=(1, 8, 8), extent=(1, 1, 1)); 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.125. julia> model = NonhydrostaticModel(; grid); warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:1123,optimiz,optimizer,1123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814,2,"['optimiz', 'perform']","['optimizer', 'perform']"
Performance,"ecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.P",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:4284,load,loading,4284,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"ed to-do some rewriting of that to unpack like `getbc(bc::BoundaryCondition, ...) = getbc(bc.condition, ...)` and then modify all of the existing `getbc` methods. We can also either i) materialize whatever the user provides into a full boundary condition or ii) build `BoundaryCondition` on the fly inside the kernel (it would get compiled away probably anyways). We don't need to modify the existing `getbc` methods. > For e.g. gradient boundary conditions it feels like the ""boundary condition value"" being the gradient at the boundary has about as much meaning as the boundary condition value for an open boundary condition being the external state and then we do some matching to get the internal solution to approximate it. I agree, I think it's acceptable if the `condition` corresponds to the prescribed external state only, and the halo regions are determined by a calculation that additionally involves a scheme + the internal state. The main difference is where the matching calculation is performed --- either in `getbc`, or in `fill_halo_regions`. I don't think either choice is ""harder"" than the other. The difference and points to consider regard code clarity. That said, I see the advantages of generalizing `Open` rather than adding a new classification. Where does that put us? It looks like this PR has more code than we need (19 files changed?), if all we need to do is generalize `Open`. To generalize `Open`, we should only need to change a few files. Should we close this PR and start over? . I'd suggest starting from the very simple place of showing that one can provide a non-trivial external state, with no ""matching scheme"" (or whatever we want to call it), using a sponge layer. I think having that example will be very useful for demonstrating the advantage of different schemes. We may want two examples --- perhaps one constant inflow / constant outflow, and another example with a time-varying inflow/outflow. For the second example, a nice case might be to use an anal",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1992386703:1109,perform,performed,1109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1992386703,2,['perform'],['performed']
Performance,"ed]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/Oceananigans/jl_k7YOZN"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Bas",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:5990,load,loading,5990,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"ed]; │ [12] _require(pkg::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1970; │ [13] __require_prelocked(uuidkey::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1812; │ [14] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [15] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [16] _require_prelocked; │ @ ./loading.jl:1803 [inlined]; │ [17] _require_prelocked; │ @ ./loading.jl:1802 [inlined]; │ [18] run_extension_callbacks(extid::Base.ExtensionId); │ @ Base ./loading.jl:1295; │ [19] run_extension_callbacks(pkgid::Base.PkgId); │ @ Base ./loading.jl:1330; │ [20] run_package_callbacks(modkey::Base.PkgId); │ @ Base ./loading.jl:1164; │ [21] _tryrequire_from_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.jl:1574; │ [23] _require(pkg::Base.PkgId, env::String); │ @ Base ./loading.jl:1938; │ [24] __require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1812; │ [25] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [26] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [27] _require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1803; │ [28] macro expansion; │ @ ./loading.jl:1790 [inlined]; │ [29] macro expansion; │ @ ./lock.jl:267 [inlined]; │ [30] __require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1753; │ [31] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [32] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [33] require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1746; │ [34] eval; │ @ ./boot.jl:385 [inlined]; │ [35] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; │ [36] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:3257,load,loading,3257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"elAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.12.6; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.5; [4a48f351] PencilFFTs v0.14.0; [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.11; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/src/Solvers/Solvers.jl:48; [11] include(mod::Module, _path::String); @ Base ./Base.jl:384; [12] include(x::String); @ Oceananigans ~/Research/OC.jl/src/Oceananigans.jl:5; [13] top-level scope; @ ~/Research/OC.jl/src/Oceananigans.jl:195; [14] include; @ ./Base.jl:384 [inlined]; [15]",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:1872,Load,LoadError,1872,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987,3,['Load'],['LoadError']
Performance,"eldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}, Nothing}, Float64, Float64, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractDiagnostic}, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractOutputWriter}, OrderedCollections.OrderedDict{Symbol, Callback}}); @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/JIHfS/src/Simulations/run.jl:88; [10] top-level scope; @ In[2]:61; [11] eval; @ ./boot.jl:373 [inlined]; [12] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base ./loading.jl:1196. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1083606906:117622,load,loading,117622,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1083606906,1,['load'],['loading']
Performance,"emoving `v` as a background creates oscillations. @glwagner have you checked? If not, let's wait for the video to see what happens... > * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Good move :+1: . > * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; > * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated). I tried to make it 100% GPU friendly actually (although I didn't test it). You already pointed out one flaw, which is the use of an array instead of a tuple for the unit vertical vector. > * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity. This only happens with me when the NetCDF file is open by another program (generally python in my case) while Julia is trying to write to it. Was that the case? If so, that's the usual behavior afaik and I don't think we can do anything on our end except inform users about it. > * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?. If we can get away with the computational cost I see no problem there. I just made this one 2D because it runs faster. > * Can we tilt the visualization? It's disorienting to be looking at the flow at an angle of 3 degrees. I tried to do that but couldn't make it work in Julia. Feel free to give it a shot!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138:1356,Load,LoadError,1356,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138,1,['Load'],['LoadError']
Performance,"empt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If we use short-circuiting logic, then I guess many optimizations are not possible, because execution on one branch or another must be completely excluded. Some of this is discussed here: https://discourse.julialang.org/t/multiplying-by-booleans-faster-than-if-else/64117. > What about @inline?. This a little hazier. The compiler decides based on a heuristic whether or not to ""inline"" a function (meaning, rather than compiling code for a function independently and jumping to that code at the right moment, it combines the function code with the code that calls the function). We want to inline everything basically, so that every tendency evaluation involves evaluating one giant function. Inlining lets LLVM magic optimize our code to the highest degree (at least that's my impression). For whatever reason the compiler often decides _not_ to inline our functions unless we specifically annotate them. So it seems we probably need to add `@inline` to every ""hot"" function that's called in a kernel, at every grid point (like a forcing function or boundary condition functi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:2049,optimiz,optimizations,2049,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583,1,['optimiz'],['optimizations']
Performance,"ent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | [13] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [14] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [15] top-level scope at none:2; &nbsp; | [16] eval at ./boot.jl:347 [inlined]; &nbsp; | [17] eval(::Expr) at ./client.jl:467; &nbsp; | [18] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/Pencils/Pencils.jl:7; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | ERROR: LoadError: Failed to precompile PencilArrays [0e08944d-e94e-41b1-9406-dcf66b6a9d2e] to /storage7/buildkite-agent/.julia-2581/compiled/v1.5/PencilArrays/yKKUy_zV1Ut.ji.; &nbsp; | Stacktrace:; &nbsp; | [1] error(::String) at ./error.jl:33; &nbsp; | [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1305; &nbsp; | [3] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [4] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [5] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [6] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [7] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [8] top-level scope at none:2; &nbsp; | [9] eval at ./boot.jl:347 [inlined]; &nbsp; | [10] eval(::Expr) at ./client.jl:467; &nbsp; | [11] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilFFTs/Xwxei/src/PencilFFTs.jl:11; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:5574,load,loading,5574,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['load'],['loading']
Performance,eredFourthOrder │ 17.309 ms │ 17.419 ms │ 18.107 ms │ 24.384 ms │ 2.71 MiB │ 27650 │ 10 │ ; │ GPU │ CenteredSecondOrder │ 10.369 ms │ 11.588 ms │ 11.472 ms │ 11.642 ms │ 2.53 MiB │ 16296 │ 10 │; │ GPU │ UpwindBiasedFifthOrder │ 19.561 ms │ 19.675 ms │ 20.975 ms │ 32.694 ms │ 2.77 MiB │ 32028 │ 10 │ ; │ GPU │ UpwindBiasedThirdOrder │ 16.131 ms │ 16.211 ms │ 16.806 ms │ 22.239 ms │ 2.68 MiB │ 25594 │ 10 │; │ GPU │ WENO5 │ 382.916 ms │ 385.558 ms │ 385.368 ms │ 386.709 ms │ 13.21 MiB │ 715860 │ 10 │; └───────────────┴────────────────────────┴────────────┴────────────┴────────────┴────────────┴───────────┴────────┴─────────┘; ```. ```; Advection schemes CPU to GPU speedup ; ┌────────────────────────┬─────────┬─────────┬─────────┐ ; │ Schemes │ speedup │ memory │ allocs │ ; ├────────────────────────┼─────────┼─────────┼─────────┤ ; │ CenteredFourthOrder │ 88.7159 │ 1.6849 │ 13.1918 │ ; │ CenteredSecondOrder │ 89.3514 │ 1.57709 │ 7.77481 │ ; │ UpwindBiasedFifthOrder │ 114.4 │ 1.72647 │ 15.2805 │ ; │ UpwindBiasedThirdOrder │ 98.3274 │ 1.66538 │ 12.2109 │ ; │ WENO5 │ 16.4404 │ 8.22094 │ 341.536 │ ; └────────────────────────┴─────────┴─────────┴─────────┘; ```. # Turbulence closure benchmarks. ```; Turbulence closures relative performance (GPU); ┌───────────────┬──────────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Closures │ slowdown │ memory │ allocs │; ├───────────────┼──────────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ AnisotropicBiharmonicDiffusivity │ 1.5313 │ 1.03189 │ 1.54697 │; │ GPU │ AnisotropicDiffusivity │ 1.05623 │ 1.00582 │ 1.01779 │; │ GPU │ AnisotropicMinimumDissipation │ 1.46265 │ 1.19908 │ 1.26817 │; │ GPU │ IsotropicDiffusivity │ 1.13134 │ 1.00607 │ 1.07995 │; │ GPU │ Nothing │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ SmagorinskyLilly │ 1.41905 │ 1.30373 │ 1.18683 │; │ GPU │ TwoDimensionalLeith │ 1.11312 │ 1.06941 │ 1.06147 │; └───────────────┴──────────────────────────────────┴──────────┴─────────┴─────────┘; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868470173:2876,perform,performance,2876,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868470173,1,['perform'],['performance']
Performance,"ering optimization strategies that our computations are probably memory-limited, rather than compute-limited. In other words, we think the process of transferring data from global memory to local thread memory is a bottleneck for our computations (we can really only know this through profiling a particular application, however, since all models are different...) Storing intermediate components of the tendency terms would probably create more memory accesses overall (since rather than immediately using intermediate results for subsequent calculations, we would have to send them to global memory, and then back, to complete the evaluation of a tendency) --- and thus could slow down tendency evaluations that are performed 1-3 times per time-step. For example, our best idea for speeding up tendency evaluations is to better manage memory movement using GPU shared memory (unfortunately, we haven't had the time to explore such optimization strategies...). I think there may be other ways to optimize diagnostics calculations, however. # Fusing `ComputedField` kernels. One possibility to speed up diagnostics is to ""fuse"" kernels for different `ComputedField` diagnostics. The kernel for a `ComputedField` is. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/Fields/computed_field.jl#L112-L115. where `operand` is an `AbstractOperation`. But different `ComputedField`s may somehow depend on the same underlying data in memory. Thus if the kernels for differnet `ComputedField`s are fused into one, we overlap memory accesses for different computations. Our computations are usually memory-limited... so its possible this strategy could produce significant speed ups. For example, for two `ComputedField`s we might have something like. ```julia; function compute!(field1, field2); # calls _compute_two(field1.data, field2.data, field1.operand, field2.operand); end; ```. and the kernel. ```julia; @kernel function _compute_two!(data1, data2, operand1, op",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837:1475,optimiz,optimize,1475,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837,1,['optimiz'],['optimize']
Performance,"est/regression_tests/shallow_water_bickley_jet_regression.jl:94; Expression: all(test_fields.v .≈ truth_fields.v); Stacktrace:; [1] run_shallow_water_regression(arch::GPU, formulation::ConservativeFormulation; regenerate_data::Bool); @ Main /g/data/v45/nc3020/OC.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:94; [2] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:12 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:11 [inlined]; [5] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [6] top-level scope; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:6; Test Summary: | Pass Fail Total; Oceananigans | 4 2 6; Shallow Water Regression | 4 2 6; Shallow Water Bickley jet simulation [GPU, VectorInvariantFormulation] | 2 1 3; Shallow Water Bickley jet simulation [GPU, ConservativeFormulation] | 2 1 3; ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored, 0 broken.; in expression starting at /g/data/v45/nc3020/OC.jl/test/runtests.jl:3; ERROR: Package Oceananigans errored during testing. (Oceananigans) pkg> st; Project Oceananigans v0.76.5; Status `/g/data/v45/nc3020/OC.jl/Project.toml`; [79e6a3ab] Adapt v3.3.3; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.4.6; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.11.2; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:17355,Load,LoadError,17355,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Load'],['LoadError']
Performance,"eviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:a,), Tuple{Int64}}, Nothing, NamedTuple{(:u, :v, :w, :a), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, Nothing, typeof(forc_u), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}, typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing), Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}}}}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/kb6yJ/src/driver.jl:76; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/BbliS/src/compiler/execution.jl:347; [10] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/kb6yJ/src/cache.jl:90; [11] cufunction(f::typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gu!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Cen",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353:8909,cache,cache,8909,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353,1,['cache'],['cache']
Performance,"g 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/src/Solvers/Solvers.jl:48; [11] include(mod::Module, _path::String); @ Base ./Base.jl:384; [12] include(x::String); @ Oceananigans ~/Research/OC.jl/src/Oceananigans.jl:5; [13] top-level scope; @ ~/Research/OC.jl/src/Oceananigans.jl:195; [14] include; @ ./Base.jl:384 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1235; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:360 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [19] top-level scope; @ none:1; during initialization of module AMGX; in expression starting at /Users/navid/Research/OC.jl/src/Solvers/multigrid_solver.jl:5; in expression starting at /Users/navid/Research/OC.jl/src/Solvers/Solvers.jl:1; in expression starting at /Users/navid/Research/OC.jl/src/Oceananigans.jl:1; ```. Was it smooth for you?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:3146,load,loading,3146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987,1,['load'],['loading']
Performance,"g) at ./Base.jl:380; &nbsp; | [14] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [15] top-level scope at none:2; &nbsp; | [16] eval at ./boot.jl:347 [inlined]; &nbsp; | [17] eval(::Expr) at ./client.jl:467; &nbsp; | [18] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/Pencils/Pencils.jl:7; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | ERROR: LoadError: Failed to precompile PencilArrays [0e08944d-e94e-41b1-9406-dcf66b6a9d2e] to /storage7/buildkite-agent/.julia-2581/compiled/v1.5/PencilArrays/yKKUy_zV1Ut.ji.; &nbsp; | Stacktrace:; &nbsp; | [1] error(::String) at ./error.jl:33; &nbsp; | [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1305; &nbsp; | [3] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [4] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [5] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [6] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [7] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [8] top-level scope at none:2; &nbsp; | [9] eval at ./boot.jl:347 [inlined]; &nbsp; | [10] eval(::Expr) at ./client.jl:467; &nbsp; | [11] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilFFTs/Xwxei/src/PencilFFTs.jl:11; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF l",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:5693,load,loading,5693,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['load'],['loading']
Performance,"g; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/src/Solvers/Solvers.jl:48; [11] include(mod::Module, _path::String); @ Base ./Base.jl:384; [12] include(x::String); @ Oceananigans ~/Research/OC.jl/src/Oceananigans.jl:5; [13] top-level scope; @ ~/Research/OC.jl/src/Oceananigans.jl:195; [14] include; @ ./Base.jl:384 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1235; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:360 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [19] top-level scope; @ none:1; during initialization of module AMGX; in expression",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:2368,load,loading,2368,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987,1,['load'],['loading']
Performance,"ggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ between precomputing a potentially expensive operation, and performing it on-the-fly. For constants, precomputation is harmless. For arrays, on-the-fly computation has significant benefits, both for code readability and also possibly for performance (in memory-bound computations). Enlightening users on 1) the existence of this trade-off and 2) how to use benchmarking to find the optimal solution for their problem would probably be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:2130,perform,performing,2130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151,4,['perform'],"['performance', 'performing']"
Performance,"gs{stale_age::Int64}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; │ [8] #invokelatest#2; │ @ ./essentials.jl:894 [inlined]; │ [9] invokelatest; │ @ ./essentials.jl:889 [inlined]; │ [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); │ @ Base ./loading.jl:2983; │ [11] maybe_cachefile_lock; │ @ ./loading.jl:2980 [inlined]; │ [12] _require(pkg::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1970; │ [13] __require_prelocked(uuidkey::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1812; │ [14] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [15] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [16] _require_prelocked; │ @ ./loading.jl:1803 [inlined]; │ [17] _require_prelocked; │ @ ./loading.jl:1802 [inlined]; │ [18] run_extension_callbacks(extid::Base.ExtensionId); │ @ Base ./loading.jl:1295; │ [19] run_extension_callbacks(pkgid::Base.PkgId); │ @ Base ./loading.jl:1330; │ [20] run_package_callbacks(modkey::Base.PkgId); │ @ Base ./loading.jl:1164; │ [21] _tryrequire_from_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.jl:1574; │ [23] _require(pkg::Base.PkgId, env::String); │ @ Base ./loading.jl:1938; │ [24] __require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1812; │ [25] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [26] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [27] _require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1803; │ [28] macro expansion; │ @ ./loading.jl:1790 [inlined]; │ [29] macro expansion; │ @ ./lock.jl:267 [inlined]; │ [30] __require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1753; │ [31] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [32",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:2820,load,loading,2820,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"gy cascade, and further assuming that the cut-off filter is in the inertial range. I think all these assumptions are valid in this simulation, so we expect the dynamically-calculated value of the Smagorinsky coefficient (the black line) to approach the value 0.16 as time goes on. https://github.com/CliMA/Oceananigans.jl/assets/13205162/4049e7cf-452e-4883-a709-a675cf12277c. Although the match is not exact (the value it approaches is ~0.17), I think this is close enough. That said, I'm planning on also implementing a boundary layer validation along similar lines, which we can use to validate the model in the same fashion as [Bou-Zeid et al. (2005)](https://dx.doi.org/10.1063/1.1839152). One thing to note is that the current implementation appears to be very slow. While the simulation with the `SmagorinskyLilly` closure runs on my laptop in 10 seconds, it takes 4 minutes for the simulation with the `ScaleInvariantSmagorinsky`. I know the dynamic model will be slower given the extra computations, but such a difference seems large to me, so I'm hoping something can be changed here to improve performance:. ```julia; ┌ Info: Running; └ closure = SmagorinskyLilly: C=0.16, Cb=1.0, Pr=1.0; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (2.738 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (4.852 seconds).; [ Info: Simulation is stopping after running for 11.657 seconds.; [ Info: Simulation time 1.333 minutes equals or exceeds stop time 1.333 minutes.; ┌ Info: Running; └ closure = ScaleInvariantSmagorinsky: averaging=Averaging over directions Colon(), Pr=1.0; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (2.195 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (2.812 seconds).; [ Info: Simulation is stopping after running for 3.735 minutes.; [ Info: Simulation time 1.333 minutes equals or exceeds stop time 1.333 minutes.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2212623170:1963,perform,performance,1963,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2212623170,1,['perform'],['performance']
Performance,"h @simone-silvestri:. If you want to adapt your script to multiregion you have to:; - define a multiregion grid with: `grid = MultiRegionGrid(grid, partition = XPartition(n_gpus_you_want_to_use), devices = n_gpus_you_want_to_use)` . The multiregion grid supersedes the immersed boundary grid, i.e. if you are using an immersed boundary grid then `grid = MultiRegionGrid(ibg; kwargs...)` , not the other way around.; - if you are using any array for forcing or boundary condition, you have to adapt it to the multiregion paradigm as follows: `using Oceananigans.MultiRegion: multi_region_object_from_array; my_adapted_array = multi_region_object_from_array(my_array, grid)`. MultiRegion works only on single node multi GPU, so all the GPUs should be accessible from a single process in the node. You can check the number of GPUs available by logging in a node and typing nvidia-smi , if you want to split your grid on specific devices (let’s say GPU 0 and 3), you can pass `devices = (0, 3)` to the `MultiRegionGrid` constructor. There is another thing that you have to take care of: the pressure solve is performed on one GPU only so both the storage and source term (a field of complex values of the size of the full grid) reside on 1 GPU only (usually the one corresponding to the last region). This means that if your grid is 100M points, 2.98 GB will have to be reserved for the solver’s auxiliary fields; ```julia; julia> sizeof(complex(zeros(Int(100e6)))) / 1024 / 1024 / 1024 * 2; 2.9802322387695312; ```; So make sure you have that space available. (When I have time I ll try to find a solution to run truly parallel pressure solvers, for both nonhydrostatic and hydrostatic models). In terms of outputs, we make use of `reconstruct_global_field` , a function used to reconstruct a global field from a `MultiRegionField` on the CPU. It is used by the output writers to spit out the full field. It is a slow procedure though, so I would advise against performing too many involved diagnostics.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875:1182,perform,performed,1182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875,2,['perform'],"['performed', 'performing']"
Performance,"he issue, we'd like to have an issue open... I don't have much hard evidence to provide but I can describe the problem as I've seen it. Basically, very rare, subtle irregularities have been observed on the GPU when using `HydrostaticFreeSurfaceModel` in a `Periodic, Bounded, Bounded` configuration. I think that it is possible the main issue is an interaction (a read-write race condition) associated with both impenetrable boundary conditions and periodic boundary conditions that affects the 8 corner points. The race condition affects model trajectories via the Coriolis force (which is the only term as far as I know that touches the 8 ""corner"" points affected by this race condition). Because the race condition only manifests when a `Coriolis` or `VectorInvariant` stencil touches corner points, it may not affect _most_ `Periodic, Periodic, Bounded` models, which could explain why we haven't caught it. The reason it doesn't affect those models is because this race condition would only affect the corner points of `w`, which are not touched when using an `FPlane` Coriolis model. However, it's possible (I'm not sure) that the race condition could affect models using `NonTraditionalFPlane` in `Periodic, Periodic, Bounded` configurations. More generally, it will also affect models that are bounded in the `y`-direction, because in those models the corner points of the `y`-velocity are affected and also invoked when using `FPlane` or `BetaPlane` coriolis. That's as much as I know. It's very hard to gather information about this bug because it's so rare are subtle. In other words, only one grid point among 10,000 iterations might be affected, and the errors induced are very small. To find this issue, we have to run tens of thousands of iterations of identical models on the GPU, and then compare some statistic of the model (ideally the entire velocity field, but @sandreza has gotten away just comparing something like `[maximum(abs, u), maximum(abs, v), maximum(abs, w)]`). If the",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865:1163,race condition,race condition,1163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865,1,['race condition'],['race condition']
Performance,"hmm good to know about possible performance issues, we should be on the lookout. I suspect that (one of the) segfaults is an OOB error that got masked by `@inbounds`, running that now locally.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809493617:32,perform,performance,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809493617,1,['perform'],['performance']
Performance,"ia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:3347,optimiz,optimizer,3347,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814,2,"['optimiz', 'perform']","['optimizer', 'perform']"
Performance,ia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopin,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:1679,optimiz,optimizer,1679,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814,12,"['optimiz', 'perform']","['optimizer', 'perform']"
Performance,igans.jl/examples/geostrophic_adjustment.jl:92; jl_gc_pool_alloc at /buildworker/worker/package_linux64/build/src/gc.c:1148; jl_gc_alloc_ at /buildworker/worker/package_linux64/build/src/julia_internal.h:277 [inlined]; jl_gc_alloc at /buildworker/worker/package_linux64/build/src/gc.c:3150; jl_gc_alloc_buf at /buildworker/worker/package_linux64/build/src/julia_internal.h:304 [inlined]; array_resize_buffer at /buildworker/worker/package_linux64/build/src/array.c:686; jl_array_grow_at_end at /buildworker/worker/package_linux64/build/src/array.c:875 [inlined]; jl_array_grow_end at /buildworker/worker/package_linux64/build/src/array.c:939; jl_array_sizehint at /buildworker/worker/package_linux64/build/src/array.c:1139; sizehint! at ./array.jl:1103 [inlined]; BitSet at ./bitset.jl:18; BitSet at ./bitset.jl:29 [inlined]; construct_ssa! at ./compiler/ssair/slot2ssa.jl:780; slot2reg at ./compiler/ssair/driver.jl:127 [inlined]; run_passes at ./compiler/ssair/driver.jl:134; optimize at ./compiler/optimize.jl:174; typeinf at ./compiler/typeinfer.jl:33; abstract_call_method_with_const_args at ./compiler/abstractinterpretation.jl:266; abstract_call_gf_by_type at ./compiler/abstractinterpretation.jl:134; abstract_call_known at ./compiler/abstractinterpretation.jl:904; abstract_call at ./compiler/abstractinterpretation.jl:926; abstract_call at ./compiler/abstractinterpretation.jl:911; abstract_eval at ./compiler/abstractinterpretation.jl:1005; typeinf_local at ./compiler/abstractinterpretation.jl:1270; typeinf_nocycle at ./compiler/abstractinterpretation.jl:1326; typeinf at ./compiler/typeinfer.jl:12; abstract_call_method_with_const_args at ./compiler/abstractinterpretation.jl:266; abstract_call_gf_by_type at ./compiler/abstractinterpretation.jl:134; abstract_call_known at ./compiler/abstractinterpretation.jl:904; abstract_call at ./compiler/abstractinterpretation.jl:926; abstract_call at ./compiler/abstractinterpretation.jl:911; abstract_eval at ./compiler/abstractinterpretation.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809634040:1729,optimiz,optimize,1729,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809634040,1,['optimiz'],['optimize']
Performance,"imilar).; >; > What does the jargon ""sounding"" mean?; >; > Merger means we need to think carefully about how to reduce boilerplate to; > minimize (within reason) the cost of maintaining two parallel models as we; > develop their shared subcomponents.; >; > I wonder if splitting off the output writers and diagnostics into a; > Simulation type that wraps AbstractModel may help. In this paradigm, a; > ""Model"" is reduced to numerics + physics specification. This would be easy; > to implement (while I think an Equation abstraction would be relatively; > difficult due to myriad difficult design problems, including the; > abstraction of tuples of terms with heterogeneous function signatures; > numerical aspects of the equation, implicit vs explicit treatment of terms,; > etc).; > The Simulation type can then be used to ""run"" simulations over multiple; > time steps, eg; >; > simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); > run!(simulation); >; > and is tasked with managing things like output writing, diagnostics; > calculation, adaptive time-stepping, and progress logging. Each Model; > then simply needs to define a function that performs a single time-step to; > interface with Simulation. This is discussed further in #447; > <https://github.com/climate-machine/Oceananigans.jl/issues/447>. Such a; > orthogonalization of the code means we can develop the Simulation; > abstraction without having to worry about updating each AbstractModel; > individually.; >; > —; > You are receiving this because you commented.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/605?email_source=notifications&email_token=AKXUEQRA7COBFTVWBSDE3ATRALQCRA5CNFSM4KNLLK52YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEKLF25Y#issuecomment-580279671>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQSOSWBJGZJKTTSGCZ3RALQCRANCNFSM4KNLLK5Q>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805:2284,perform,performs,2284,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805,1,['perform'],['performs']
Performance,"imulation initialization complete (112.172 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.376 seconds).; [ Info: Simulation is stopping after running for 7.945 seconds.; [ Info: Model iteration 200 equals or exceeds stop iteration 200.; ```. I should make it clear that `CFL=10` is not large enough to make particles move out of the domain. `CFL` should be larger than `Nx`, because the distance at which a particle moves in one time step needs to larger than the domain size \(not the grid size\). That means $u \Delta t > L_x$, which is equivalent to `CFL > Nx`. Using a `CFL` of `51` (`Nx = 50` in this case) reproduces the error on a CPU:; ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (108.842 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.303 seconds).; ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:420 [inlined]; [4] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/field.jl:399 [inlined]; [5] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Utils/sum_of_arrays.jl:23 [inlined]; [6] _interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:148 [inlined]; [7] interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:197 [inlined]; [8] advect_particle; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135:1048,Load,LoadError,1048,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135,1,['Load'],['LoadError']
Performance,"in general. We currently handle this only during time-stepping --- there is no guarantee, for example, that the diffusivities or ghost cell values are consistent with the velocity field if the velocity field is set by the function `set!` (in fact, the diffusivities are *always* inconsistent with the current velocity field due to the fact that they are calculated *prior* to taking a time-step). If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). What does the jargon ""sounding"" mean?. Merger means we need to think carefully about how to reduce boilerplate to minimize (within reason) the cost of maintaining two parallel models as we develop their shared subcomponents. I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. In this paradigm, a ""Model"" is reduced to numerics + physics specification. This would be easy to implement (while I think an `Equation` abstraction would be relatively difficult due to myriad difficult design problems, including the abstraction of tuples of terms with heterogeneous function signatures, numerical aspects of the equation, implicit vs explicit treatment of terms, etc).; The `Simulation` type can then be used to ""run"" simulations over multiple time steps, eg. ```julia; simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); run!(simulation); ```. and is tasked with managing things like output writing, diagnostics calculation, adaptive time-stepping, and progress logging. Each `Model` then simply needs to define a function that performs a single time-step to interface with `Simulation`. This is discussed further in #447. Such a orthogonalization of the code means we can develop the `Simulation` abstraction without having to worry about updating each `AbstractModel` individually.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671:2063,perform,performs,2063,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671,1,['perform'],['performs']
Performance,"ing in our current project.; > ; > My last attempt at improving the NetCDF solved many of the issues with the package JuliaGeo/NetCDF.jl#61 but was not merged because of conflicts with other bugfix PRs. However, might be source of inspiration if someone wants to do a rewrite.; > ; > Regarding write performance, I would be very interested to see examples where NetCDF.jl performs worse than e.g. python-netcdf4, since most of the time should be spent in the same NetCDF C library. I have been using the package extensively and did not experience it to be slower than comparable packages.; > ; > I you are worried about the robustness of NetCDF.jl, you should not even look at ZarrNative.jl, since it is still very young and rather a prototype.; > ; > I would be very happy to discuss the issues further, maybe in a call? Would also be interested to learn about your project which seems to be very cool. Thanks so much for working on NetCDF.jl! I didn't mean to sound ungrateful about NetCDF.jl's performance. We were just debating which package to use. With https://github.com/JuliaGeo/NetCDF.jl/issues/87 fixed, I think we'll be happy for a long time. The `compress=9` bug explains why the IO was slow. @glwagner has suggested that for a project of our scale we'd want to help and contribute to the packages we use. We definitely want to stick with NetCDF as it's the _de facto_ standard in the climate, atmospheric, and ocean sciences. A discussion might be helpful down the line. With faster IO I think we're happy now and we're still figuring how to do IO long-term. > My feeling is that if you want to write NetCDF files through the HDF API that it will be more work, though I never tried.; > ; > Regarding NetCDF.jl & NCDatasets.jl, I feel that the statements in the OP that NetCDF.jl is not being maintained and that NCDatasets.jl grew out of bugs not being fixed is are a bit of a misrepresentation.; > ; > For installations and dependency reduction, hopefully the new HDF5 release, which wil",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847:1934,perform,performance,1934,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847,1,['perform'],['performance']
Performance,"inish this discussion I think.; > ; > Some notes:; > ; > * The same code on CPUs isn't even close to have the same slowdown. So there's definitely something going on here for GPUs; > * I have struggled with this for quite some time until I found the culprit, so if we can't immediately find and fix the cause I'd suggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ between precomputing a potentially expensive operation, and performing it on-the-fly. For constants, precomputation is harmless.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:1232,optimiz,optimize,1232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151,2,['optimiz'],['optimize']
Performance,"ion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:440 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/RsWnF/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:439 [inlined]; [5] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:89; [6] emit_llvm; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:83 [inlined]; [7] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:129; [8] codegen; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:110 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:106; [10] compile; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:98 [inlined]; [11] #45; @ ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:57 [inlined]; [12] JuliaContext(f::Metal.var""#45#46""{GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:47; [13] compile(job::GPUCompiler.CompilerJob); @ Metal ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:56; [14] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, compiler::typeof(Metal.compile), linker::typeof(Metal.link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/execution.jl:125; [15] cached_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, cfg::GPUCompiler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:36980,optimiz,optimize,36980,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822,1,['optimiz'],['optimize']
Performance,"it::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6 ; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:1; in expression starting at stdin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:1918,load,loading,1918,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"itle=""Incompressible Model Benchmarks: CPU/GPU""); > benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); > benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_Δ, title=""Incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_Δ, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_Δ, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; > docs/src/physics/incompressible_model.md:# Incompressible model; > docs/src/numerical_implementation/time_stepping.md",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:1370,perform,performance,1370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932,1,['perform'],['performance']
Performance,"jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/Oceananigans/jl_k7YOZN"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_ag",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:5873,load,loading,5873,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"jl:93; │ [6] #mkpidlock#6; │ @ ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; │ [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; │ [8] #invokelatest#2; │ @ ./essentials.jl:894 [inlined]; │ [9] invokelatest; │ @ ./essentials.jl:889 [inlined]; │ [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); │ @ Base ./loading.jl:2983; │ [11] maybe_cachefile_lock; │ @ ./loading.jl:2980 [inlined]; │ [12] _require(pkg::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1970; │ [13] __require_prelocked(uuidkey::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1812; │ [14] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [15] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [16] _require_prelocked; │ @ ./loading.jl:1803 [inlined]; │ [17] _require_prelocked; │ @ ./loading.jl:1802 [inlined]; │ [18] run_extension_callbacks(extid::Base.ExtensionId); │ @ Base ./loading.jl:1295; │ [19] run_extension_callbacks(pkgid::Base.PkgId); │ @ Base ./loading.jl:1330; │ [20] run_package_callbacks(modkey::Base.PkgId); │ @ Base ./loading.jl:1164; │ [21] _tryrequire_from_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.jl:1574; │ [23] _require(pkg::Base.PkgId, env::String); │ @ Base ./loading.jl:1938; │ [24] __require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1812; │ [25] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [26] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [27] _require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1803; │ [28] macro expansion; │ @ ./loading.jl:1790 [inlined]; │ [29] macro expans",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:2646,load,loading,2646,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"jll; ✓ JuliaNVTXCallbacks_jll; ✓ MacroTools; ✓ LLVMExtra_jll; ✓ CUDA_Driver_jll; ✓ Random123; ✓ DataStructures; ✓ StringManipulation; ✓ FixedPointNumbers; ✓ SortingAlgorithms; ✗ CUDA_Runtime_jll; ✓ ColorTypes; ✓ LLVM; ✓ LLVM → BFloat16sExt; ✓ StaticArrays; ✓ Adapt → AdaptStaticArraysExt; ✓ StaticArrays → StaticArraysStatisticsExt; ✓ UnsafeAtomicsLLVM; ✓ Colors; ✓ GPUArraysCore; ✓ NVTX. ✓ GPUArrays; ✓ KernelAbstractions; ✓ PrettyTables; ✓ GPUCompiler; ✓ DataFrames; ✗ CUDA; 61 dependencies successfully precompiled in 190 seconds. 5 already precompiled. The following 1 direct dependency failed to precompile:. CUDA [052768ef-5323-5732-b1bb-66c8b64840ba]. Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_UQIv2i"".; [45592] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:25; Allocations: 2907 (Pool: 2898; Big: 9); GC: ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_CUC33l"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/sp",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:4875,Load,LoadError,4875,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,1,['Load'],['LoadError']
Performance,"julia-3746/compiled/v1.6/Oceananigans/jl_IfcPYz.;   | ERROR: LoadError: LoadError: SystemError: opening file ""/var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Advection/upwind_biased_first_order.jl"": No such file or directory;   | Stacktrace:;   | [1] systemerror(p::String, errno::Int32; extrainfo::Nothing);   | @ Base ./error.jl:168;   | [2] #systemerror#62;   | @ ./error.jl:167 [inlined];   | [3] systemerror;   | @ ./error.jl:167 [inlined];   | [4] open(fname::String; lock::Bool, read::Nothing, write::Nothing, create::Nothing, truncate::Nothing, append::Nothing);   | @ Base ./iostream.jl:293;   | [5] open;   | @ ./iostream.jl:282 [inlined];   | [6] open(f::Base.var""#326#327""{String}, args::String; kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}});   | @ Base ./io.jl:328;   | [7] open;   | @ ./io.jl:328 [inlined];   | [8] read;   | @ ./io.jl:434 [inlined];   | [9] _include(mapexpr::Function, mod::Module, _path::String);   | @ Base ./loading.jl:1166;   | [10] include(mod::Module, _path::String);   | @ Base ./Base.jl:386;   | [11] include(x::String);   | @ Oceananigans.Advection ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:1;   | [12] top-level scope;   | @ ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:43;   | [13] include(mod::Module, _path::String);   | @ Base ./Base.jl:386;   | [14] include(x::String);   | @ Oceananigans ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:1;   | [15] top-level scope;   | @ ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:173;   | [16] include;   | @ ./Base.jl:386 [inlined];   | [17] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing);   | @ Base ./loading.jl:1235;   | [18] top-level scope;   | @ none:1;   | [19] eval;   | @ ./boot.jl:360 [inlined];   | [20] eval(x::Expr);",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134:1395,load,loading,1395,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134,1,['load'],['loading']
Performance,"kgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:6897,load,loading,6897,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,8,['load'],['loading']
Performance,"kgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:3; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:6226,load,loading,6226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,8,['load'],['loading']
Performance,"l, cleanup::Bool, validate::Bool, strip::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:100; [8] codegen; @ ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:82 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; kwargs::@Kwargs{}); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:79; [10] compile; @ ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:74 [inlined]; [11] #1145; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/compilation.jl:250 [inlined]; [12] JuliaContext(f::CUDA.var""#1145#1148""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}}; kwargs::@Kwargs{}); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:34; [13] JuliaContext(f::Function); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:25; [14] compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/compiler/compilation.jl:249; [15] actual_compilation(cache::Dict{Any, CuFunction}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::typeof(CUDA.compile), linker::typeof(CUDA.link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/execution.jl:237; [16] cached_compilation(cache::Dict{Any, CuFunction}, src::Core.MethodInstance, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::Function, linker::Function); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/execution.jl:151; [17] macro expansion; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:380 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] cufunction(f::typeof(Oceananigans.Models.NonhydrostaticModels.gpu_compute_Gu!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(10, 10, 10)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.ND",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2428001700:7536,cache,cache,7536,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2428001700,1,['cache'],['cache']
Performance,"lArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | ERROR: LoadError: Failed to precompile PencilArrays [0e08944d-e94e-41b1-9406-dcf66b6a9d2e] to /storage7/buildkite-agent/.julia-2581/compiled/v1.5/PencilArrays/yKKUy_zV1Ut.ji.; &nbsp; | Stacktrace:; &nbsp; | [1] error(::String) at ./error.jl:33; &nbsp; | [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1305; &nbsp; | [3] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [4] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [5] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [6] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [7] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [8] top-level scope at none:2; &nbsp; | [9] eval at ./boot.jl:347 [inlined]; &nbsp; | [10] eval(::Expr) at ./client.jl:467; &nbsp; | [11] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilFFTs/Xwxei/src/PencilFFTs.jl:11; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | 🚨 Error: The command exited with status ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:6162,load,load,6162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['load'],['load']
Performance,"ld; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_zRopeZ"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Bas",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:3377,load,loading,3377,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"le.jl:88 [inlined]; │ [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; │ [8] #invokelatest#2; │ @ ./essentials.jl:894 [inlined]; │ [9] invokelatest; │ @ ./essentials.jl:889 [inlined]; │ [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); │ @ Base ./loading.jl:2983; │ [11] maybe_cachefile_lock; │ @ ./loading.jl:2980 [inlined]; │ [12] _require(pkg::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1970; │ [13] __require_prelocked(uuidkey::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1812; │ [14] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [15] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [16] _require_prelocked; │ @ ./loading.jl:1803 [inlined]; │ [17] _require_prelocked; │ @ ./loading.jl:1802 [inlined]; │ [18] run_extension_callbacks(extid::Base.ExtensionId); │ @ Base ./loading.jl:1295; │ [19] run_extension_callbacks(pkgid::Base.PkgId); │ @ Base ./loading.jl:1330; │ [20] run_package_callbacks(modkey::Base.PkgId); │ @ Base ./loading.jl:1164; │ [21] _tryrequire_from_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.jl:1574; │ [23] _require(pkg::Base.PkgId, env::String); │ @ Base ./loading.jl:1938; │ [24] __require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1812; │ [25] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [26] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [27] _require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1803; │ [28] macro expansion; │ @ ./loading.jl:1790 [inlined]; │ [29] macro expansion; │ @ ./lock.jl:267 [inlined]; │ [30] __require(into::Module, mod::Symbol); │ @ Base ./loadi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:2741,load,loading,2741,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"lerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:106; [10] compile; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:98 [inlined]; [11] #45; @ ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:57 [inlined]; [12] JuliaContext(f::Metal.var""#45#46""{GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:47; [13] compile(job::GPUCompiler.CompilerJob); @ Metal ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:56; [14] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, compiler::typeof(Metal.compile), linker::typeof(Metal.link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/execution.jl:125; [15] cached_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, cfg::GPUCompiler.CompilerConfig{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, compiler::Function, linker::Function); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/execution.jl:103; [16] macro expansion; @ ~/.julia/packages/Metal/lnkVP/src/compiler/execution.jl:162 [inlined]; [17] macro expansion; @ ./lock.jl:267 [inlined]; [18] mtlfunction(f::typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.gpu_compute_hydrostatic_free_surface_Gu!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(3, 3, 50)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 50)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float32, 3, Metal.MtlDeviceArray{Float32, 3, 1}}, RectilinearGrid{Float32, Periodic, Periodic, Bounded, Float32, Float",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:37939,cache,cache,37939,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822,1,['cache'],['cache']
Performance,lin/software/Oceananigans.jl/examples/geostrophic_adjustment.jl:92; jl_gc_pool_alloc at /buildworker/worker/package_linux64/build/src/gc.c:1148; jl_gc_alloc_ at /buildworker/worker/package_linux64/build/src/julia_internal.h:277 [inlined]; jl_gc_alloc at /buildworker/worker/package_linux64/build/src/gc.c:3150; jl_gc_alloc_buf at /buildworker/worker/package_linux64/build/src/julia_internal.h:304 [inlined]; array_resize_buffer at /buildworker/worker/package_linux64/build/src/array.c:686; jl_array_grow_at_end at /buildworker/worker/package_linux64/build/src/array.c:875 [inlined]; jl_array_grow_end at /buildworker/worker/package_linux64/build/src/array.c:939; jl_array_sizehint at /buildworker/worker/package_linux64/build/src/array.c:1139; sizehint! at ./array.jl:1103 [inlined]; BitSet at ./bitset.jl:18; BitSet at ./bitset.jl:29 [inlined]; construct_ssa! at ./compiler/ssair/slot2ssa.jl:780; slot2reg at ./compiler/ssair/driver.jl:127 [inlined]; run_passes at ./compiler/ssair/driver.jl:134; optimize at ./compiler/optimize.jl:174; typeinf at ./compiler/typeinfer.jl:33; abstract_call_method_with_const_args at ./compiler/abstractinterpretation.jl:266; abstract_call_gf_by_type at ./compiler/abstractinterpretation.jl:134; abstract_call_known at ./compiler/abstractinterpretation.jl:904; abstract_call at ./compiler/abstractinterpretation.jl:926; abstract_call at ./compiler/abstractinterpretation.jl:911; abstract_eval at ./compiler/abstractinterpretation.jl:1005; typeinf_local at ./compiler/abstractinterpretation.jl:1270; typeinf_nocycle at ./compiler/abstractinterpretation.jl:1326; typeinf at ./compiler/typeinfer.jl:12; abstract_call_method_with_const_args at ./compiler/abstractinterpretation.jl:266; abstract_call_gf_by_type at ./compiler/abstractinterpretation.jl:134; abstract_call_known at ./compiler/abstractinterpretation.jl:904; abstract_call at ./compiler/abstractinterpretation.jl:926; abstract_call at ./compiler/abstractinterpretation.jl:911; abstract_eval at ./compiler/abstr,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809634040:1706,optimiz,optimize,1706,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-809634040,1,['optimiz'],['optimize']
Performance,"linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: LoadError: IOError: write: broken pipe (EPIPE); &nbsp; | Stacktrace:; &nbsp; | [1] uv_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:951; &nbsp; | [2] unsafe_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:1005; &nbsp; | [3] write(::Base.PipeEndpoint, ::String) at ./strings/io.jl:183; &nbsp; | [4] create_expr_cache(::String, ::String, ::Array{Pair{Base.PkgId,UInt64},1}, ::Base.UUID) at ./loading.jl:1194; &nbsp; | [5] compilecache(::Base.PkgId, ::String) at ./loading.jl:1286; &nbsp; | [6] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [7] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [8] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [9] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [10] include at ./Base.jl:368 [inlined]; &nbsp; | [11] include(::String) at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:1; &nbsp; | [12] top-level scope at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | [13] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [14] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [15] top-level scope at none:2; &nbsp; | [16] eval at ./boot.jl:347 [inlined]; &nbsp; | [17] eval(::Expr) at ./client.jl:467; &nbsp; | [18] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/Pencils/Pencils.jl:7; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:4199,load,loading,4199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['load'],['loading']
Performance,looks like maybe some more race conditions on different hardware?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906714103:27,race condition,race conditions,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906714103,1,['race condition'],['race conditions']
Performance,"ltiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}, Oceananigans.AbstractOperations.ConditionalOperation{Center, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, typeof(identity), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, typeof(condition_greater_3), Int64, Float64}}}}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/07qaN/src/driver.jl:76; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:346; [10] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/07qaN/src/cache.jl:90; [11] cufunction(f::typeof(CUDA.partial_mapreduce_grid), tt::Type{Tuple{typeof(identity), typeof(Base.add_sum), Nothing, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, Val{true}, Base.ReshapedArray{Float64, 4, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}, Oceananigans.AbstractOperations.ConditionalOperation{Center, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, typeof(identity), RectilinearGrid{Float64, Periodic, Perio",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568:9169,cache,cache,9169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568,1,['cache'],['cache']
Performance,"lux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Clock{Float64}}}); @ Oceananigans.AbstractOperations ~/.julia/packages/Oceananigans/RnhUQ/src/AbstractOperations/computed_field.jl:37; [12] test_ke_dissipation_rate_terms(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}; model_type::Type{NonhydrostaticModel}, closure::ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, ThreeDimensionalFormulation, Float64, Float64}); @ Main ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:218; [13] macro expansion; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:418 [inlined]; [14] macro expansion; @ /opt/hostedtoolcache/julia/1.9.2/x64/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [15] top-level scope; @ ~/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:400; [16] include(fname::String); @ Base.MainInclude ./client.jl:478; [17] top-level scope; @ none:6; [18] eval; @ ./boot.jl:[370](https://github.com/tomchor/Oceanostics.jl/actions/runs/5955695197/job/16154870828?pr=151#step:6:373) [inlined]; [19] exec_options(opts::Base.JLOptions); @ Base ./client.jl:280; [20] _start(); @ Base ./client.jl:522; Test Summary: | Pass Error Total Time; Oceanostics | 58 1 59 2m45.4s; ERROR: LoadError: Some tests did not pass: 58 passed, 0 failed, 1 errored, 0 broken.; in expression starting at /home/runner/work/Oceanostics.jl/Oceanostics.jl/test/runtests.jl:399; ERROR: LoadError: Package Oceanostics errored during testing; Stacktrace:; ```. If so, can we register a bugfix version asap?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352:31154,Load,LoadError,31154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3227#issuecomment-1690550352,2,['Load'],['LoadError']
Performance,"lways have them together. At some point we have to get the external value, and if it's in the condition slot in `BoundaryCondition` we can get it like this:; https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/fill_halo_regions_value_gradient.jl#L9. which can be e.g.; https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/continuous_boundary_function.jl#L124-L133; which is called because of there being a `ContinuousBoundaryFunction` in the `BoundaryCondition` type:; https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/continuous_boundary_function.jl#L119; which was automatically set-up and then `regularize`-d. https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/boundary_condition.jl#L53-L67. https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/continuous_boundary_function.jl#L74-L75. But if we have this as part of the condition we get something like:; ```julia; BoundaryCondition{<:Open, <:OpenConditions{ES, MS}}; ```. then we'd have to rewrite loads of stuff to make it so the user can specify whatever they want for the external state. In the existing code the condition and classification are never directly accessed (except from inside `getbc`) and all of the other bits are based on the types:. https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/fill_halo_regions_value_gradient.jl#L15. so we can just write methods like:. ```julia; @inline function _fill_west_halo!(j, k, grid, c, bc::BoundaryCondition{Open{<:SomeMatchingScheme}}, loc, args...); ```. I don't really understand how it makes the code any harder to understand if we then get the condition as above v.s. writing new things so we can do `external_state = some_function(bc)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988307344:1378,load,loads,1378,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988307344,1,['load'],['loads']
Performance,"m(zspacings(grid, Center())) / maximum(abs, model.velocities.u),; stop_time=20); # Create regular output; simulation.output_writers[:fullfields] = NetCDFOutputWriter(model, (; model.velocities.u),; filename = ""fullfields.nc"",; schedule = TimeInterval(5),; overwrite_existing = true,). # Create interpolated u on coarse grid; coarse_grid = RectilinearGrid(size = (grid.Nx, grid.Ny, grid.Nz÷2), extent = (grid.Lx, grid.Ly, grid.Lz)); coarse_u = Field{Face, Center, Center}(coarse_grid). using Oceananigans.Fields: interpolate!; update_coarse_u(simulation) = interpolate!(coarse_u, simulation.model.velocities.u); simulation.callbacks[:update_interp] = Callback(update_coarse_u). # Create coarse output; simulation.output_writers[:coarsefields] = NetCDFOutputWriter(model, (; coarse_u,), coarse_grid;; filename=""coarsefields.nc"",; schedule=TimeInterval(5),; overwrite_existing=true,). run!(simulation); ```. Throws the following error:. ```; ERROR: LoadError: DimensionMismatch: new dimensions (1, 1, 8, 1) must be consistent with array size 4; Stacktrace:; [1] (::Base.var""#throw_dmrsa#328"")(dims::NTuple{4, Int64}, len::Int64); @ Base ./reshapedarray.jl:41; [2] reshape(a::Array{Float64, 3}, dims::NTuple{4, Int64}); @ Base ./reshapedarray.jl:45; [3] setindex_disk!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing, Missing}}, ::Array{Float64, 3}, ::Function, ::Vararg{Any}); @ DiskArrays ~/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:56; [4] setindex!; @ ~/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:229 [inlined]; [5] setindex!(::CommonDataModel.CFVariable{…}, ::Array{…}, ::Colon, ::Colon, ::Colon, ::UnitRange{…}); @ CommonDataModel ~/.julia/packages/CommonDataModel/GGvMn/src/cfvariable.jl:477; [6] save_output!(ds::NCDatasets.NCDataset{…}, output::Field{…}, model::NonhydrostaticModel{…}, ow::NetCDFOutputWriter{…}, time_index::Int64, name::String); @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:482; [7] write_output!(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084:1216,Load,LoadError,1216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084,1,['Load'],['LoadError']
Performance,"masc/.julia/packages/CUDA/fAEDi/src/compiler/exceptions.jl:34; [2] nonblocking_synchronize; @ /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/context.jl:331 [inlined]; [3] device_synchronize(); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/context.jl:319; [4] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/module.jl:41; [5] CuModule; @ /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/module.jl:23 [inlined]; [6] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/src/compiler/execution.jl:479; [7] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/XyxTy/src/cache.jl:95; [8] cufunction(f::typeof(CUDA.partial_mapreduce_grid), tt::Type{Tuple{typeof(identity), typeof(max), Nothing, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, Val{true}, CUDA.CuDeviceArray{Float64, 4, 1}, Oceananigans.AbstractOperations.ConditionalOperation{Face, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, typeof(identity), ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePreci",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871:5897,cache,cache,5897,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871,1,['cache'],['cache']
Performance,"mod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: LoadError: IOError: write: broken pipe (EPIPE); &nbsp; | Stacktrace:; &nbsp; | [1] uv_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:951; &nbsp; | [2] unsafe_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:1005; &nbsp; | [3] write(::Base.PipeEndpoint, ::String) at ./strings/io.jl:183; &nbsp; | [4] create_expr_cache(::String, ::String, ::Array{Pair{Base.PkgId,UInt64},1}, ::Base.UUID) at ./loading.jl:1194; &nbsp; | [5] compilecache(::Base.PkgId, ::String) at ./loading.jl:1286; &nbsp; | [6] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [7] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [8] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [9] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [10] include at ./Base.jl:368 [inlined]; &nbsp; | [11] include(::String) at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:1; &nbsp; | [12] top-level scope at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | [13] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [14] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [15] top-level scope at none:2; &nbsp; | [16] eval at ./boot.jl:347 [inlined]; &nbsp; | [17] eval(::Expr) at ./client.jl:467; &nbsp; | [18] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/Pencils/Pencils.jl:7; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | ERROR: LoadError: Failed to precompile PencilArra",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:4261,load,loading,4261,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['load'],['loading']
Performance,"ms │ 13.06 KiB │ 290 │; └───────────────┴─────┴───────────────────────────────┴───────────┴───────────┴───────────┴───────────┴───────────┴────────┘; ```. ### CPU to GPU speedup. ```; Fourier-tridiagonal Poisson solver CPU -> GPU speedup; ┌─────┬───────────────────────────────┬─────────┬─────────┬─────────┐; │ Ns │ Topologies │ speedup │ memory │ allocs │; ├─────┼───────────────────────────────┼─────────┼─────────┼─────────┤; │ 256 │ (Bounded, Bounded, Bounded) │ 50.4045 │ 21.5194 │ 32.4444 │; │ 256 │ (Bounded, Periodic, Bounded) │ 51.2039 │ 15.8992 │ 23.2963 │; │ 256 │ (Periodic, Bounded, Bounded) │ 52.4472 │ 15.8992 │ 23.2963 │; │ 256 │ (Periodic, Periodic, Bounded) │ 99.4371 │ 6.48062 │ 10.7407 │; └─────┴───────────────────────────────┴─────────┴─────────┴─────────┘; ```. ### Relative performance on the CPU. ```; Fourier-tridiagonal Poisson solver relative performance (CPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬──────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼──────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.58185 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.24529 │ 0.922481 │ 1.0 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.27117 │ 0.922481 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴──────────┴────────┘; ```. ### Relative performance on the GPU. ```; Fourier-tridiagonal Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 3.12065 │ 3.32057 │ 3.02069 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 2.41833 │ 2.26316 │ 2.16897 │;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:8305,perform,performance,8305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050,1,['perform'],['performance']
Performance,"n as `err` and call `code_typed(err; interactive = true)` to introspect the erronous code with Cthulhu.jl; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/validation.jl:147; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:382 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/NRdsv/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:381 [inlined]; [5] emit_llvm(job::GPUCompiler.CompilerJob; toplevel::Bool, libraries::Bool, optimize::Bool, cleanup::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/utils.jl:108; [6] emit_llvm; @ ~/.julia/packages/GPUCompiler/2CW9L/src/utils.jl:106 [inlined]; [7] codegen(output::Symbol, job::GPUCompiler.CompilerJob; toplevel::Bool, libraries::Bool, optimize::Bool, cleanup::Bool, validate::Bool, strip::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:100; [8] codegen; @ ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:82 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; kwargs::@Kwargs{}); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:79; [10] compile; @ ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:74 [inlined]; [11] #1145; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/compilation.jl:250 [inlined]; [12] JuliaContext(f::CUDA.var""#1145#1148""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}}; kwargs::@Kwargs{}); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:34; [13] JuliaContext(f::Function); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:25; [14] compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/compiler/compilation.jl:249; [15] actual_compilation(cache::Dict{Any, CuFunction",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2428001700:6527,optimiz,optimize,6527,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2428001700,1,['optimiz'],['optimize']
Performance,"n interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. Not urgent. > 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. We want to write `fill_halo_regions!(::HorizontalVectorField, ...)`. > 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. No rush... > 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... I don't think less abstraction is more clear. > 12. Fix tests!. Tests must pass or we can't develop. > 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory. Not urgent for this PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333:2881,perform,performance,2881,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333,2,['perform'],['performance']
Performance,"nded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.125. julia> model = NonhydrostaticModel(; grid); warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:1401,optimiz,optimizer,1401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814,2,"['optimiz', 'perform']","['optimizer', 'perform']"
Performance,"ned]; │ [17] _require_prelocked; │ @ ./loading.jl:1802 [inlined]; │ [18] run_extension_callbacks(extid::Base.ExtensionId); │ @ Base ./loading.jl:1295; │ [19] run_extension_callbacks(pkgid::Base.PkgId); │ @ Base ./loading.jl:1330; │ [20] run_package_callbacks(modkey::Base.PkgId); │ @ Base ./loading.jl:1164; │ [21] _tryrequire_from_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.jl:1574; │ [23] _require(pkg::Base.PkgId, env::String); │ @ Base ./loading.jl:1938; │ [24] __require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1812; │ [25] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [26] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [27] _require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1803; │ [28] macro expansion; │ @ ./loading.jl:1790 [inlined]; │ [29] macro expansion; │ @ ./lock.jl:267 [inlined]; │ [30] __require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1753; │ [31] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [32] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [33] require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1746; │ [34] eval; │ @ ./boot.jl:385 [inlined]; │ [35] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; │ [36] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; │ [37] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; │ [38] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:3604,load,loading,3604,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"ngeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, SubArray{Float64, 1, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Tuple{UnitRange{Int64}}, true}}}}}); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/driver.jl:76; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:346; [10] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/cache.jl:90; [11] cufunction(f::typeof(Oceananigans.Fields.gpu__regrid!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Nothing, Nothing}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, OffsetVector{Float64, CuDeviceVe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:6853,cache,cache,6853,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574,1,['cache'],['cache']
Performance,"ns currently does not store intermediate terms in the computation of a PDE's right hand side (with notable exceptions hydrostatic pressure and eddy diffusivities). In other words, a single, sometimes large kernel that evaluates the right hand side at each grid point `i, j, k` is compiled for each PDE in a user's model, and there's no way to pull out intermediate steps in that calculation to use elsewhere. It's important to note when considering optimization strategies that our computations are probably memory-limited, rather than compute-limited. In other words, we think the process of transferring data from global memory to local thread memory is a bottleneck for our computations (we can really only know this through profiling a particular application, however, since all models are different...) Storing intermediate components of the tendency terms would probably create more memory accesses overall (since rather than immediately using intermediate results for subsequent calculations, we would have to send them to global memory, and then back, to complete the evaluation of a tendency) --- and thus could slow down tendency evaluations that are performed 1-3 times per time-step. For example, our best idea for speeding up tendency evaluations is to better manage memory movement using GPU shared memory (unfortunately, we haven't had the time to explore such optimization strategies...). I think there may be other ways to optimize diagnostics calculations, however. # Fusing `ComputedField` kernels. One possibility to speed up diagnostics is to ""fuse"" kernels for different `ComputedField` diagnostics. The kernel for a `ComputedField` is. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/Fields/computed_field.jl#L112-L115. where `operand` is an `AbstractOperation`. But different `ComputedField`s may somehow depend on the same underlying data in memory. Thus if the kernels for differnet `ComputedField`s are fused into one, we overlap m",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837:1196,perform,performed,1196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837,1,['perform'],['performed']
Performance,"ns v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.11; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/src/Solvers/Solvers.jl:48; [11] include(mod::Module, _path::String); @ Base ./Base.jl:384; [12] include(x::String); @ Oceananigans ~/Research/OC.jl/src/Oceananigans.jl:5; [13] top-level scope; @ ~/Research/OC.jl/src/Oceananigans.jl:195; [14] include; @ ./Base.jl:384 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:2153,load,loading,2153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987,1,['load'],['loading']
Performance,"ns.Fields: condition_operand; IF = AbstractField{<:Any, <:Any, <:Any, <:ImmersedBoundaryGrid}; using Oceananigans.ImmersedBoundaries: NotImmersed. using Oceananigans.Architectures: architecture, arch_array; @inline function condition_operand(func::Function, operand::IF, condition::AbstractArray, mask); condition = arch_array(architecture(operand.grid), NotImmersed(condition)); return ConditionalOperation(operand; func, condition, mask); end. using Oceananigans.Grids: ynode, znode; yᶜᶜᶜ = KernelFunctionOperation{Center, Center, Center}(ynode, grid, Center(), Center(), Center()); zᶜᶜᶜ = KernelFunctionOperation{Center, Center, Center}(znode, grid, Center(), Center(), Center()). c = Field((Center, Center, Center), grid); set!(c, (x, y, z) -> ifelse(z>-1/2, ifelse(y<3/4, 7, 13), -9)). b = compute!(Field(Average(c, condition=(yᶜᶜᶜ .>1/2))));; ```. As mentioned, this produces the correct result on the CPU (`(13+7)/2 = 10`) but fails on the GPU with the error:. ```; ERROR: LoadError: GPU compilation of MethodInstance for CUDA.partial_mapreduce_grid(::typeof(identity), ::typeof(Base.add_sum), ::Nothing, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::Val{true}, ::Base.ReshapedArray{Float64, 4, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}, ::ConditionalOperation{Center, Center, Center, Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.Offset",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1905170213:2350,Load,LoadError,2350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1905170213,1,['Load'],['LoadError']
Performance,"nt about it.; > ; > *The packages in JuliaGeo have been mostly focused on IO and has not had the bandwidth to think about how it might interface with packages for (climate/ocean/etc) models. That might be useful down the line! Yes we're both around MIT. I think we're still figuring how we want to do IO in the long-term but will definitely want some way to output NetCDF. > Hey, original author of both https://github.com/JuliaGeo/NetCDF.jl and https://github.com/meggart/ZarrNative.jl here. Regarding the state of NetCDF.jl , yes I would say I mostly stopped developing the package due to time constraints and currently shift my focus towards Zarr since this is what we are using in our current project.; > ; > My last attempt at improving the NetCDF solved many of the issues with the package JuliaGeo/NetCDF.jl#61 but was not merged because of conflicts with other bugfix PRs. However, might be source of inspiration if someone wants to do a rewrite.; > ; > Regarding write performance, I would be very interested to see examples where NetCDF.jl performs worse than e.g. python-netcdf4, since most of the time should be spent in the same NetCDF C library. I have been using the package extensively and did not experience it to be slower than comparable packages.; > ; > I you are worried about the robustness of NetCDF.jl, you should not even look at ZarrNative.jl, since it is still very young and rather a prototype.; > ; > I would be very happy to discuss the issues further, maybe in a call? Would also be interested to learn about your project which seems to be very cool. Thanks so much for working on NetCDF.jl! I didn't mean to sound ungrateful about NetCDF.jl's performance. We were just debating which package to use. With https://github.com/JuliaGeo/NetCDF.jl/issues/87 fixed, I think we'll be happy for a long time. The `compress=9` bug explains why the IO was slow. @glwagner has suggested that for a project of our scale we'd want to help and contribute to the packages we use. We de",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847:1237,perform,performance,1237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847,1,['perform'],['performance']
Performance,"nt changes:. * I removed the `BackgroundField` v-velocity, which had no effect on the solution because the domain is `Flat` in y. The only effect of the background flow is through the bottom drag boundary condition.; * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Minor changes:. * Update style to be consistent with other examples / source code (commas, spaces, etc); * Reorganized the script to read like the other examples / tutorials (like a paper, parameters are introduced when they are used rather than at the top); * Reorganized a few other misc stuff for pedagogical reasons, like building buoyancy + coriolis together; * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; * Change tilting angle to 3 degrees rather than 0.05 radians; * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated); * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity; * Plotting fewer contours makes the animation faster (the most expensive part of this example); * We don't need to form `Field`s any more for the output writers any more. Idle thoughts:. * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?; * Can we tilt the visualization? It's disorienting to be looking at the flow at an angle of 3 degrees.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449:1563,Load,LoadError,1563,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449,1,['Load'],['LoadError']
Performance,"n{Float64, Base.TwicePrecisi...; 763 0 @Oceananigans/src/Advection/weno_fifth_order.jl 211 left_biased_interpolate_xᶠᵃᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisi...; 768 0 @Oceananigans/src/Advection/topologically_conditional_interpolation.jl 36 _right_biased_interpolate_xᶠᵃᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci...; 768 0 @Oceananigans/src/Advection/upwind_biased_advective_fluxes.jl 49 overdub; 781 0 @Oceananigans/src/Simulations/run.jl 127 run!(sim::Simulation{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.Offs...; 781 0 @Base/boot.jl 360 eval; 781 0 @Base/loading.jl 1116 include_string(mapexpr::typeof(identity), mod::Module, code::String, filename::String); 781 0 @Base/loading.jl 1170 _include(mapexpr::Function, mod::Module, _path::String); 781 0 @Base/Base.jl 386 include(mod::Module, _path::String); 781 0 @Base/client.jl 285 exec_options(opts::Base.JLOptions); 781 0 @Base/client.jl 485 _start(); 796 796 @Cassette/src/context.jl ? overdub; 821 0 @Oceananigans/src/Advection/topologically_conditional_interpolation.jl 36 _right_biased_interpolate_yᵃᶠᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci...; 821 0 @Oceananigans/src/Advection/upwind_biased_advective_fluxes.jl 85 overdub; 860 860 @KernelAbstractions/src/compiler/contract.jl 18 sub_float_contract; 860 0 @KernelAbstractions/src/compiler.jl 46 overdub; 873 0 @Oceananigans/src/Advection/weno_fifth_order.jl 148 overdub; 879 0 @Oceananigans/src/Operators/difference_operators.jl 23 δyᵃᶜᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846:31257,load,loading,31257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846,1,['load'],['loading']
Performance,"o @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654:1015,perform,perform,1015,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654,4,"['concurren', 'perform']","['concurrently', 'perform']"
Performance,"o v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/src/Solvers/Solvers.jl:48; [11] include(mod::Module, _path::String); @ Base ./Base.jl:384; [12] include(x::String); @ Oceananigans ~/Research/OC.jl/src/Oceananigans.jl:5; [13] top-level scope; @ ~/Research/OC.jl/src/Oceananigans.jl:195; [14] include; @ ./Base.jl:384 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1235; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:360 [inlined]; [18] eval(x::Expr); @ B",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:2252,load,loading,2252,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987,1,['load'],['loading']
Performance,"oading.jl:1974; │ [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; │ [6] #mkpidlock#6; │ @ ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; │ [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; │ [8] #invokelatest#2; │ @ ./essentials.jl:894 [inlined]; │ [9] invokelatest; │ @ ./essentials.jl:889 [inlined]; │ [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); │ @ Base ./loading.jl:2983; │ [11] maybe_cachefile_lock; │ @ ./loading.jl:2980 [inlined]; │ [12] _require(pkg::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1970; │ [13] __require_prelocked(uuidkey::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1812; │ [14] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [15] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [16] _require_prelocked; │ @ ./loading.jl:1803 [inlined]; │ [17] _require_prelocked; │ @ ./loading.jl:1802 [inlined]; │ [18] run_extension_callbacks(extid::Base.ExtensionId); │ @ Base ./loading.jl:1295; │ [19] run_extension_callbacks(pkgid::Base.PkgId); │ @ Base ./loading.jl:1330; │ [20] run_package_callbacks(modkey::Base.PkgId); │ @ Base ./loading.jl:1164; │ [21] _tryrequire_from_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.jl:1574; │ [23] _require(pkg::Base.PkgId, env::String); │ @ Base ./loading.jl:1938; │ [24] __require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1812; │ [25] #invoke_in_world#3; │ @ ./essentials.jl:926 [inl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:2415,load,loading,2415,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"odic, Bounded) │ 51.2039 │ 15.8992 │ 23.2963 │; │ 256 │ (Periodic, Bounded, Bounded) │ 52.4472 │ 15.8992 │ 23.2963 │; │ 256 │ (Periodic, Periodic, Bounded) │ 99.4371 │ 6.48062 │ 10.7407 │; └─────┴───────────────────────────────┴─────────┴─────────┴─────────┘; ```. ### Relative performance on the CPU. ```; Fourier-tridiagonal Poisson solver relative performance (CPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬──────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼──────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.58185 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.24529 │ 0.922481 │ 1.0 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.27117 │ 0.922481 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴──────────┴────────┘; ```. ### Relative performance on the GPU. ```; Fourier-tridiagonal Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 3.12065 │ 3.32057 │ 3.02069 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 2.41833 │ 2.26316 │ 2.16897 │; │ GPU │ 256 │ (Periodic, Bounded, Bounded) │ 2.41007 │ 2.26316 │ 2.16897 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴─────────┴─────────┘; ```. ---. ## FFT-based Poisson solver. ### Raw benchmarks. ```; FFT-based Poisson solver benchmarks ; ┌───────────────┬─────┬───────────────────────────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ m",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:8950,perform,performance,8950,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050,1,['perform'],['performance']
Performance,"oing wrong. I'm going to copy the errors below so others can see this more easily. The error in the docs complains about `PlotUtils` failing to precompile. That doesn't seem related to shallow water so I am confused. The CPU test seems to be with `MPI`, but I didn't know we had any `MPI` tests that used shallow water that were being run. Docs:; ```; ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; --; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: Failed to precompile PlotUtils [995b91a9-d308-5afd-9ec6-746e21dbc043] to /storage7/buildkite-agent/.julia-2556/compiled/v1.5/PlotUtils/YveHG_R3lk8.ji.; &nbsp; | Stacktrace:; &nbsp; | [1] top-level scope at none:2; &nbsp; | [2] eval at ./boot.jl:347 [inlined]; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2556/packages/Plots/SjqWU/src/Plots.jl:20; &nbsp; | ERROR: LoadError: Failed to precompile Plots [91a5bcdd-55d7-5caf-9e0b-520d859cae80] to /storage7/buildkite-agent/.julia-2556/compiled/v1.5/Plots/ld3vC_R3lk8.ji.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-1/clima/oceananigans/docs/make.jl:6; &nbsp; | 🚨 Error: The command exited with status 1. ```. CPU test; ```; [8] test() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:72; --; &nbsp; | [9] top-level scope at none:1; &nbsp; | Union{},Union{},Tuple{},NamedTuple{(test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; ERROR: failed process: Process(`/storage7/buildkite-agent/.julia-2556/artifacts/2fcd463fb9498f362be9d1c4ef70a63c920b0e96/bin/mpiexec -np 4 /storage7/buildkite-agent/julia-1.5.4/bin/julia -O0 --color=yes -e 'using Pkg; Pkg.test()'`, ProcessExited(1)) [1]; &nbsp; | &nbsp;; &nbsp; | Stacktrace:; &nbsp; | [1] pipeline_error at ./process.jl:525 [inlined]; &nbsp; | [2] run(::Cmd; wait::Bool) at ./process.jl:440; &nbsp; | [3] run(::Cmd) at proc",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-842643141:1049,Load,LoadError,1049,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-842643141,1,['Load'],['LoadError']
Performance,"onditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}, Nothing}, Float64, Float64, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractDiagnostic}, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractOutputWriter}, OrderedCollections.OrderedDict{Symbol, Callback}}); @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/Yz6ub/src/Simulations/run.jl:88; [10] top-level scope; @ In[3]:54; [11] eval; @ ./boot.jl:373 [inlined]; [12] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base ./loading.jl:1196. ```; </details>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084429618:118734,load,loading,118734,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084429618,1,['load'],['loading']
Performance,"onhydrostatic_tendency_kernel_functions.jl:92; [4] macro expansion; @ ~/.julia/packages/Oceananigans/xmqSH/src/Models/NonhydrostaticModels/compute_nonhydrostatic_tendencies.jl:148; [5] gpu_compute_Gu!; @ ~/.julia/packages/KernelAbstractions/491pi/src/macros.jl:95; [6] gpu_compute_Gu!; @ ./none:0; Hint: catch this exception as `err` and call `code_typed(err; interactive = true)` to introspect the erronous code with Cthulhu.jl; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/validation.jl:147; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:382 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/NRdsv/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:381 [inlined]; [5] emit_llvm(job::GPUCompiler.CompilerJob; toplevel::Bool, libraries::Bool, optimize::Bool, cleanup::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/utils.jl:108; [6] emit_llvm; @ ~/.julia/packages/GPUCompiler/2CW9L/src/utils.jl:106 [inlined]; [7] codegen(output::Symbol, job::GPUCompiler.CompilerJob; toplevel::Bool, libraries::Bool, optimize::Bool, cleanup::Bool, validate::Bool, strip::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:100; [8] codegen; @ ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:82 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; kwargs::@Kwargs{}); @ GPUCompiler ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:79; [10] compile; @ ~/.julia/packages/GPUCompiler/2CW9L/src/driver.jl:74 [inlined]; [11] #1145; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/compilation.jl:250 [inlined]; [12] JuliaContext(f::CUDA.var""#1145#1148""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}}; kwargs::@Kwargs{}); @ GPUComp",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2428001700:6221,optimiz,optimize,6221,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2428001700,1,['optimiz'],['optimize']
Performance,"ope; @ ~/software/Oceananigans.jl/src/Models/ShallowWaterModels/ShallowWaterModels.jl:15; [4] include(mod::Module, _path::String); @ Base ./Base.jl:386; [5] include(x::String); @ Oceananigans.Models ~/software/Oceananigans.jl/src/Models/Models.jl:1; [6] top-level scope; @ ~/software/Oceananigans.jl/src/Models/Models.jl:20; [7] include(mod::Module, _path::String); @ Base ./Base.jl:386; [8] include(x::String); @ Oceananigans ~/software/Oceananigans.jl/src/Oceananigans.jl:1; [9] top-level scope; @ ~/software/Oceananigans.jl/src/Oceananigans.jl:179; [10] include; @ ./Base.jl:386 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:16; in expression starting at /home/fpoulin/software/Oceananigans.jl/src/Models/ShallowWaterModels/ShallowWaterModels.jl:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/src/Models/Models.jl:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /home/fpoulin/.julia/compiled/v1.6/Oceananigans/jl_cnHalv.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-843316815:2474,load,loading,2474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-843316815,5,['load'],['loading']
Performance,"open at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109 [inlined] (repeats 2 times); &nbsp; | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: LoadError: IOError: write: broken pipe (EPIPE); &nbsp; | Stacktrace:; &nbsp; | [1] uv_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:951; &nbsp; | [2] unsafe_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:1005; &nbsp; | [3] write(::Base.PipeEndpoint, ::String) at ./strings/io.jl:183; &nbsp; | [4] create_expr_cache(::String, ::String, ::Array{Pair{Base.PkgId,UInt64},1}, ::Base.UUID) at ./loading.jl:1194; &nbsp; | [5] compilecache(::Base.PkgId, ::String) at ./loading.jl:1286; &nbsp; | [6] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [7] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [8] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [9] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [10] include at ./Base.jl:368 [inlined]; &nbsp; | [11] include(::String) at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:1; &nbsp; | [12] top-level scope at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | [13] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [14] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [15] top-level scope at none:2; &nbsp; | [16] eval at ./boot.jl:347 [inlined]; &nbsp; | [17] eval(::Expr) at ./client.jl:467; &nbsp; | [18] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:4012,load,loading,4012,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['load'],['loading']
Performance,"oplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:129; [8] codegen; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:110 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:106; [10] compile; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:98 [inlined]; [11] #45; @ ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:57 [inlined]; [12] JuliaContext(f::Metal.var""#45#46""{GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:47; [13] compile(job::GPUCompiler.CompilerJob); @ Metal ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:56; [14] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, compiler::typeof(Metal.compile), linker::typeof(Metal.link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/execution.jl:125; [15] cached_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, cfg::GPUCompiler.CompilerConfig{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, compiler::Function, linker::Function); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/execution.jl:103; [16] macro expansion; @ ~/.julia/packages/Metal/lnkVP/src/compiler/execution.jl:162 [inlined]; [17] macro expansion; @ ./lock.jl:267 [inlined]; [18] mtlfunction(f::typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.gpu_compute_hydrostatic_free_surface_Gu!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(3, 3, 50)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, K",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:37624,cache,cache,37624,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822,1,['cache'],['cache']
Performance,"orted dynamic function invocation (call to getproperty); Stacktrace:; [1] call at /home/fpoulin/.julia/packages/Cassette/Wjztv/src/context.jl:456; [2] fallback at /home/fpoulin/.julia/packages/Cassette/Wjztv/src/context.jl:454; [3] overdub at /home/fpoulin/.julia/packages/Cassette/Wjztv/src/context.jl:279; [4] b̄ at /home/fpoulin/software/Oceananigans.jl/examples/inertially_unstable_jet.jl:39; [5] call_func at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.jl:61; [6] getindex at /home/fpoulin/software/Oceananigans.jl/src/Fields/function_field.jl:63; [7] identity at /home/fpoulin/software/Oceananigans.jl/src/Operators/interpolation_utils.jl:6; [8] - at /home/fpoulin/software/Oceananigans.jl/src/AbstractOperations/binary_operations.jl:59; [9] identity at /home/fpoulin/software/Oceananigans.jl/src/Operators/interpolation_utils.jl:11; [10] getindex at /home/fpoulin/software/Oceananigans.jl/src/AbstractOperations/binary_operations.jl:34; [11] macro expansion at /home/fpoulin/software/Oceananigans.jl/src/Fields/computed_field.jl:114; [12] gpu__compute! at /home/fpoulin/.julia/packages/KernelAbstractions/mKsXc/src/macros.jl:80; [13] overdub at /home/fpoulin/.julia/packages/Cassette/Wjztv/src/overdub.jl:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/fpoulin/.julia/packages/GPUCompiler/uTpNx/src/validation.jl:123; [2] macro expansion at /home/fpoulin/.julia/packages/GPUCompiler/uTpNx/src/driver.jl:239 [inlined]; [3] macro expansion at /home/fpoulin/.julia/packages/TimerOutputs/4QAIk/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/fpoulin/.julia/packages/GPUCompiler/uTpNx/src/driver.jl:237; [5] compile(::Symbol, ::GPUCompiler.CompilerJob; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate:; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815099807:5401,optimiz,optimize,5401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815099807,4,['optimiz'],['optimize']
Performance,"p!. `Julia uses a semicolon to separate regular arguments from keyword arguments`. Ah yeah, I thought `Float64` should be passed as a keyword argument. The following works now:. ```; grid = VerticallyStretchedRectilinearGrid(Float64; architecture = GPU(),; size = (Nx,Ny,Nz), x=(0, Lx), y=(0, Ly), zF=zF,; halo = (3, 3, 3),; topology = (Periodic, Periodic, Bounded)); ```. `Hmmm, how small was the time step? `. I tried a few different values ranging from 1 sec to 60 sec. . I found that the `NaN` issue has to do with the `AnisotropicBiharmonicDiffusivity`. The following works:. ```; closure = AnisotropicDiffusivity(νh=kappaH_tmp, κh=kappaH_tmp, κz = kappaV, νz = kappaV); ```. but not this: . ```; closure = (AnisotropicDiffusivity(νh=0, κh=0, κz = kappaV, νz = kappaV),; AnisotropicBiharmonicDiffusivity(νh=kappaH, κh=kappaH)); ```. Also, `topology = (Periodic, Periodic, Bounded)` runs fine now, but `topology = (Periodic, Bounded, Bounded)` gives the following error:. ```; Loaded all modules; Starting the simulation...; ┌ Warning: You have used the default iteration_interval=1. This simulation will recalculate the time step every iteration which can be slow.; └ @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/gCqmh/src/Simulations/simulation.jl:68; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field Δz; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] cell_advection_timescale(::CuArray{Float64,3}, ::CuArray{Float64,3}, ::CuArray{Float64,3}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}}) at /home/guptam/.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-792994007:999,Load,Loaded,999,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-792994007,1,['Load'],['Loaded']
Performance,"p; | Downloading artifact: HDF5; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibSSH2; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: CompilerSupportLibraries; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: MPICH; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibCURL; &nbsp; | ######################################################################## 100.0%; &nbsp; | Building MPI ─→ `/storage7/buildkite-agent/.julia-2581/packages/MPI/b7MVG/deps/build.log`; &nbsp; | [ Info: using default MPI jll; &nbsp; | Building FFTW → `/storage7/buildkite-agent/.julia-2581/packages/FFTW/G3lSO/deps/build.log`; &nbsp; | Precompiling project...; &nbsp; | WARNING: Error during initialization of module GMP:; &nbsp; | ErrorException(""could not load library ""libgmp""; &nbsp; | libgmp.so: ELF load command past end of file""); &nbsp; | WARNING: Error during initialization of module LinearAlgebra:; &nbsp; | ErrorException(""could not load library ""libopenblas64_""; &nbsp; | libopenblas64_.so: ELF load command past end of file""); &nbsp; | ┌ Error: Error during initialization of module CHOLMOD; &nbsp; | │ exception =; &nbsp; | │ could not load library ""libcholmod""; &nbsp; | │ libopenblas64_.so.0: ELF load command past end of file; &nbsp; | │ Stacktrace:; &nbsp; | │ [1] dlopen(::String, ::UInt32; throw_error::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109; &nbsp; | │ [2] dlopen at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109 [inlined] (repeats 2 times); &nbsp; | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:2329,load,load,2329,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['load'],['load']
Performance,"pe and type of A. (The first two arguments have the same meaning as for fft.) Returns an object P which; represents the linear operator computed by the FFT, and which contains all of the information needed to compute fft(A, dims) quickly. To apply P to an array A, use P * A; in general, the syntax for applying plans is much like that of matrices. (A plan can only be applied to arrays of the same size as the A for which; the plan was created.) You can also apply a plan with a preallocated output array Â by calling mul!(Â, plan, A). (For mul!, however, the input array A must be a complex floating-point; array like the output Â.) You can compute the inverse-transform plan by inv(P) and apply the inverse plan with P \ Â (the inverse plan is cached and reused for subsequent calls to inv or; \), and apply the inverse plan to a pre-allocated output array A with ldiv!(A, P, Â). The flags argument is a bitwise-or of FFTW planner flags, defaulting to FFTW.ESTIMATE. e.g. passing FFTW.MEASURE or FFTW.PATIENT will instead spend several seconds (or more) benchmarking; different possible FFT algorithms and picking the fastest one; see the FFTW manual for more information on planner flags. The optional timelimit argument specifies a rough upper bound on; the allowed planning time, in seconds. Passing FFTW.MEASURE or FFTW.PATIENT may cause the input array A to be overwritten with zeros during plan creation. plan_fft! is the same as plan_fft but creates a plan that operates in-place on its argument (which must be an array of complex floating-point numbers). plan_ifft and so on are similar; but produce plans that perform the equivalent of the inverse transforms ifft and so on. help?> plan_fft!; search: plan_fft! plan_ifft! plan_bfft! plan_fft plan_rfft plan_ifft plan_bfft plan_irfft plan_brfft. plan_fft!(A [, dims]; flags=FFTW.ESTIMATE, timelimit=Inf). Same as plan_fft, but operates in-place on A.; ```. But I just learned that you can apply the inverse plan with `P \ Â` which is cool!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471179127:1941,perform,perform,1941,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471179127,1,['perform'],['perform']
Performance,"ps://render.githubusercontent.com/render/math?math=c_{rj}"">) are based on the Lagrange interpolation of the integral of <img src=""https://render.githubusercontent.com/render/math?math=\overline{v}_{i}""> and, as such, are coordinate-dependent. The first thing to do, when wanting to implement the WENO scheme on a stretched grid, is then to make sure that the reconstruction is correctly done, and, as such, `WENO5(grid = grid)` takes care that (<img src=""https://render.githubusercontent.com/render/math?math=c_{rj}"">) are correctly calculated based on the underlying grid. Now, WENO schemes differ from ENO schemes since they do not just choose the ""smoothest stencil"" among the (in this case) three stencils, but weight them as such. <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2} = \sum_{r=0}^k w_{r} v_{i %2B 1/2,r} "">. Those weights have to satisfy <img src=""https://render.githubusercontent.com/render/math?math=\sum_{r=0}^k w_{r} = 1""> and are mostly a matter of choice (if the reconstruction is performed correctly for all stencils!). The general way to do this is to make them functions of a ""local smoothness indicator"" <img src=""https://render.githubusercontent.com/render/math?math=\beta_r""> which is calculated as such; <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r} = \sum_{l=1}^k \int_{x_{i-1/2}}^{x_{i %2B 1/2}} \Delta x^{2l -1} \left( \frac{\partial^l p_r(x)}{\partial x^l} \right)^2 dx""> . These <img src=""https://render.githubusercontent.com/render/math?math=\beta_r""> simplify quite nicely for uniform grids. the `streched_smoothness=true` option calculates the coefficients of these smoothness indicators for a stretched grid, by assuming that (<img src=""https://render.githubusercontent.com/render/math?math=k = 2"">). Then the weights are calculated as such; <img src=""https://render.githubusercontent.com/render/math?math=w_{r} = \frac{\alpha_r}{\alpha_0 %2B \alpha_1 %2B \alpha_2}""> . where <img src=""https://render.git",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397:2039,perform,performed,2039,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397,2,['perform'],['performed']
Performance,"r/package_linux64/build/usr/share/julia/stdlib/v1.6/Statistics/src/Statistics.jl:131; [14] compute!; @ ~/Oceananigans.jl/src/Fields/averaged_field.jl:62 [inlined]; [15] compute!(avg::AveragedField{Nothing, Nothing, Center, Oceananigans.Fields.FieldStatus{Float64}, GPU, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, 2, Field{Center, Center, Center, GPU, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/averaged_field.jl:61; [16] top-level scope; @ REPL[35]:1; [17] top-level scope; @ ~/.julia/dev/CUDA/src/initialization.jl:50; ```. using. ```diff; diff --git a/src/mapreduce.jl b/src/mapreduce.jl; index f9489dcf..11c0aee0 100644; --- a/src/mapreduce.jl; +++ b/src/mapreduce.jl; @@ -209,6 +209,10 @@ function GPUArrays.mapreducedim!(f::F, op::OP, R::AnyCuArray{T},; shmem = reduce_shmem; blocks = reduce_blocks*other_blocks; ; + @show threads; + @show blocks; + @show reduce_blocks; +; # perform the actual reduction; if reduce_blocks == 1; # we can cover the dimensions to reduce using a single block; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845602157:10390,perform,perform,10390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845602157,1,['perform'],['perform']
Performance,"ransformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:3625,optimiz,optimizer,3625,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814,6,"['optimiz', 'perform']","['optimizer', 'perform']"
Performance,"red buoyancy frequency) should be calculated using the local thermal expansion coefficient and haline contraction coefficient (the analytical derivatives of the equation of state with respect to temperature and salinity at constant depth) --- This is (apparently) a more accurate approximation to the buoyancy gradient than calculating the buoyancy gradient with finite differences of buoyancy at different vertical levels. But this means that all equations of state should define functions that return these coefficients. In addition, we will supply a function to calculated the buoyancy frequency squared (I'm currently calling it `N2`). 3. For Boussinesq equations of state, we do not require the non-static components of pressure as input; instead we use the geopotential depth (corresponding to the use of hydrostatic pressure, `ρ₀ g depth`, to calculate compressive / thermobaric effects on density). At the moment we thus only require `-z` as an input --- though we may need to generalize the buoyancy implementation in the future if for some reason calculating the 'geopoential depth' requires more information (like free surface elevation). Luckily, this is a small change that just requires changing the function arguments to `buoyancy_perturbation`; etc. 4. The name `buoyancy_perturbation` is ok. It is actually potentially confusing, since ""buoyancy"" in ordinary usage is *already* associated explicitly with density anomalies --- rather than static, typically constant or z-dependent components of the density profile. So I think calling this function simply `buoyancy` might be better. On the other hand, we probably want to use `model.buoyancy` to refer to the model field that holds buoyancy-related parameters. Because of that we may want to stick with `buoyancy_perturbation`. Any ideas / alternative suggestions? An alternative is to perform a translation in the kernel functions; aka use `buoyancy_params` in the function signature of kernel(s) that call the function `buoyancy`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-532995557:2152,perform,perform,2152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-532995557,1,['perform'],['perform']
Performance,"require_prelocked(uuidkey::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1812; │ [14] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [15] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [16] _require_prelocked; │ @ ./loading.jl:1803 [inlined]; │ [17] _require_prelocked; │ @ ./loading.jl:1802 [inlined]; │ [18] run_extension_callbacks(extid::Base.ExtensionId); │ @ Base ./loading.jl:1295; │ [19] run_extension_callbacks(pkgid::Base.PkgId); │ @ Base ./loading.jl:1330; │ [20] run_package_callbacks(modkey::Base.PkgId); │ @ Base ./loading.jl:1164; │ [21] _tryrequire_from_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.jl:1574; │ [23] _require(pkg::Base.PkgId, env::String); │ @ Base ./loading.jl:1938; │ [24] __require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1812; │ [25] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [26] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [27] _require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1803; │ [28] macro expansion; │ @ ./loading.jl:1790 [inlined]; │ [29] macro expansion; │ @ ./lock.jl:267 [inlined]; │ [30] __require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1753; │ [31] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [32] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [33] require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1746; │ [34] eval; │ @ ./boot.jl:385 [inlined]; │ [35] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; │ [36] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; │ [37] start_repl_backend(backend::REPL.REPLBackend, consumer::An",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:3347,load,loading,3347,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"rgs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_zRopeZ"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecac",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:2287,load,loading,2287,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"rgs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/Oceananigans/jl_k7YOZN"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base .",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:4868,load,loading,4868,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"right, remaking the performance benchmark is definitely on the todo list!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3758#issuecomment-2326784686:20,perform,performance,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3758#issuecomment-2326784686,1,['perform'],['performance']
Performance,"rom_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.jl:1574; │ [23] _require(pkg::Base.PkgId, env::String); │ @ Base ./loading.jl:1938; │ [24] __require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1812; │ [25] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [26] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [27] _require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1803; │ [28] macro expansion; │ @ ./loading.jl:1790 [inlined]; │ [29] macro expansion; │ @ ./lock.jl:267 [inlined]; │ [30] __require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1753; │ [31] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [32] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [33] require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1746; │ [34] eval; │ @ ./boot.jl:385 [inlined]; │ [35] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; │ [36] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; │ [37] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; │ [38] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; │ [39] run_repl(repl::REPL.AbstractREPL, consumer::Any); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; │ [40] (::Base.var""#1013#1015""{Bool, Bool, Bool})(REPL::Module); │ @ Base ./client.jl:432; │ [41] #invokelatest#2; │ @ ./essentials.jl:892 [inlined]; │ [42] invokelatest; │ @ ./esse",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:3932,load,loading,3932,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"rtically-implicit time-stepping for diffusion terms (numerics). Ocean models typically use a time-stepping method that treats vertical diffusion terms implicitly. We haven't worried about this because we are focused on LES for the most part, or problems with very little diffusion. But ultimately we will need this, especially when we get around to implementing boundary layer closures. We have a tridiagonal solver that works on the GPU, so in some respects the hard work is already done for this problem. 3. Closures for LES and ocean modeling (Dynamic Smagorinsky, Deardorff, k-epsilon, Gent-McWilliams, convective adjustment (?) etc --- physics). We have a need to implement new turbulence closures new and old alike. Gent-McWilliams is probably easy since we already have a Leith closure implemented which calculates the tensor needed to rotate the diffusivity into an isopycnal coordinate. The others are a bit more challenging. 4. Extensive profiling and benchmarking on the GPU to identify bottlenecks / places for improvement in the algorithm (numerics). We might be able to make the code a lot faster (but we aren't sure). 5. A solver for hydrostatic problems with a free surface that uses a split-explicit time-integration method. This is notoriously tricky, but we've made a lot of progress on this for the purposes of the ClimateMachine and it might be interesting to translate what we've learned into Oceananigans. There's also some minor package stuff that I want to work on, such as refactoring the output writer (#963), improving logging / feedback while oceananigans builds a model or runs a simulation (#1013), getting arrays with named axes to work (#457), and figuring out what's going wrong with models that have `Flat` dimensions (#1024). A more fun project is to come up with cool plotting recipes in 1D, 2D, and 3D (!) We'd like to show people how to use Makie (for example) to create really cool visualizations / animations of turbulence. The examples do some animation, but",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281:2153,bottleneck,bottlenecks,2153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281,1,['bottleneck'],['bottlenecks']
Performance,"runcation error. The error I is consistent with single precision accuracy. ; (The slopes in the legend are taken from the plot shown below and are not the slopes of the curves from Oceananigans.) . ![convergence_rates_oceananigans](https://user-images.githubusercontent.com/8239041/103024246-79841700-451d-11eb-8321-454171fa2381.png). This plot is similar but computed using my own time-stepping code but it does use `advective_tracer_flux_x`. In developing this code I was able to ensure that everything is double precision and they give the correct slopes. ![convergence_rates](https://user-images.githubusercontent.com/8239041/103024241-7721bd00-451d-11eb-8717-6437c7c2c577.png). **Good news:** The advection schemes in Oceananigans can produce the correct slopes, as predicted by theory. **Bad news:** Some part of Oceananigans (maybe times-stepping?) must use single precision accuracy, and that truncates the error of the method as a whole. Question: where is the bottleneck that reduces the global spatial accuracy from double to single precision?. This third figure shows the result for increased spatial resolution and we observe that the higher order methods saturate near `1e-16`, as you would expect from double precision. ![convergence_rates](https://user-images.githubusercontent.com/8239041/103028959-c7514d00-4526-11eb-94c6-81fb3d429882.png). In case you are interested, these are the calculations of the rates of convergence for the two sets of calculations. ```; Method = Center2ⁿᵈ, Rate of Convergence = 1.99, Expected = 2; Method = CenteredSecondOrder(), Rate of Convergence = 1.99, Expected = 2; Method = Upwind3ʳᵈ, Rate of Convergence = 2.99, Expected = 3; Method = UpwindBiasedThirdOrder(), Rate of Convergence = 3.20, Expected = 3; Method = Center4ᵗʰ, Rate of Convergence = 3.98, Expected = 4; Method = CenteredFourthOrder(), Rate of Convergence = 2.45, Expected = 4; Method = Upwind5ᵗʰ, Rate of Convergence = 4.97, Expected = 5; Method = UpwindBiasedFifthOrder(), Rate of Conv",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750409595:1239,bottleneck,bottleneck,1239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750409595,1,['bottleneck'],['bottleneck']
Performance,"r{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics/math.jl:5; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /home/tomas/.julia/compiled/v1.6/CUDA/jl_q4lPlx.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; [7] include; @ ./Base.jl:386 [inlined]; [8] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [9] top-level scope; @ none:1; [10] eval; @ ./boot.jl:360 [inlined]; [11] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [12] top-level scope; @ none:1; in expression starting at /home/tomas/repos/Oceananigans.jl/src/Oceananigans.jl:1; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /home/tomas/.julia/compiled/v1.6/Oceananigans/jl_psrPk0.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371:2234,load,loading,2234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371,1,['load'],['loading']
Performance,"s (like the models implemented in OceanBioME) to ""opt-in"" to a substepping scheme. In this design, there's no need to change the existing ""slow"" kernels I don't think. However, we could consider changing the name of them. For example, all that's needed is for the _implementation_ to know when to return a slow source term vs fast source term. > this is where I had to make some more changes to the existing code (and probably the messiest part of what I did), because the code often expects the tendencies to live at timestepper.G / $G^-$, so I made functions that dispatched on the timestepper and usually returned that, but for the new timestepepr returned timestepper.physics.G etc. I'm not sure that new tendencies are needed for substepping. The substepping scheme for CATKE manages to avoid allocating any additional tendencies by preserving the ""slow"" source term:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl#L167-L171. The only change that is needed within Oceananigans (in principle) --- as far as I can tell --- is to skip the tracer update for certain tracers (like we do for CATKE and TKEDissipation):. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L78-L85. Then the implementer of the BGC model has to perform the substepping inside `update_biogeochemical_state!`:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl#L49. Possibly we can go further and define an interface that does the substepping automatically though. I think that an effort like this would be good not to go so far, and first test ideas in a ""minimal"" implementation that simply uses `update_biogeochemical_state!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851:2037,perform,perform,2037,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851,2,['perform'],['perform']
Performance,"s │ 899.881 ms │ 900.082 ms │ 837.97 KiB │ 1154 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Bounded) │ 882.563 ms │ 883.710 ms │ 883.524 ms │ 884.131 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Periodic) │ 912.389 ms │ 916.994 ms │ 915.908 ms │ 917.212 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Periodic) │ 916.691 ms │ 917.084 ms │ 917.270 ms │ 918.438 ms │ 575.12 KiB │ 1010 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Periodic) │ 918.221 ms │ 920.232 ms │ 920.871 ms │ 925.207 ms │ 772.19 KiB │ 1131 │ 6 │; └───────────────┴─────────────────┴────────────────────────────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┴─────────┘; [2022/05/03 00:36:02.528] INFO Writing Topologies_benchmarks.html...; Topologies relative performance (CPU); ┌───────────────┬─────────────────┬────────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────────────────┼────────────────────────────────┼──────────┼─────────┼─────────┤; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Bounded) │ 0.981253 │ 1.45702 │ 1.14257 │; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Periodic) │ 1.00343 │ 1.34264 │ 1.1198 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Bounded) │ 0.976245 │ 1.34264 │ 1.1198 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Periodic) │ 0.999901 │ 1.22313 │ 1.0703 │; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Bounded) │ 0.972442 │ 1.34134 │ 1.10396 │; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Periodic) │ 0.980426 │ 1.22313 │ 1.0703 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Bounded) │ 0.963608 │ 1.22313 │ 1.0703 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────────────────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. ## 2D model (256x256x1). ```; Topologies benchmarks; ┌───────────────┬──",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728:7992,perform,performance,7992,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728,1,['perform'],['performance']
Performance,"s │ 910.295 ms │ 914.968 ms │ 837.97 KiB │ 1154 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Bounded) │ 886.053 ms │ 892.564 ms │ 894.281 ms │ 904.917 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Periodic) │ 910.500 ms │ 924.085 ms │ 923.571 ms │ 931.683 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Periodic) │ 914.391 ms │ 916.636 ms │ 916.407 ms │ 917.164 ms │ 575.12 KiB │ 1010 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Periodic) │ 923.307 ms │ 925.553 ms │ 926.892 ms │ 932.185 ms │ 772.19 KiB │ 1131 │ 6 │; └───────────────┴─────────────────┴────────────────────────────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┴─────────┘; [2022/05/03 01:05:45.458] INFO Writing Topologies_benchmarks.html...; Topologies relative performance (CPU); ┌───────────────┬─────────────────┬────────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────────────────┼────────────────────────────────┼──────────┼─────────┼─────────┤; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Bounded) │ 0.993457 │ 1.45702 │ 1.14257 │; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Periodic) │ 1.00973 │ 1.34264 │ 1.1198 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Bounded) │ 0.994272 │ 1.34264 │ 1.1198 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Periodic) │ 1.00813 │ 1.22313 │ 1.0703 │; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Bounded) │ 0.98639 │ 1.34134 │ 1.10396 │; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Periodic) │ 0.98391 │ 1.22313 │ 1.0703 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Bounded) │ 0.973739 │ 1.22313 │ 1.0703 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────────────────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. ## 2D model (256x256x1). ```; Topologies benchmarks; ┌───────────────┬─────",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728:2326,perform,performance,2326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728,1,['perform'],['performance']
Performance,"se.jl:386 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics/math.jl:5; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /home/tomas/.julia/compiled/v1.6/CUDA/jl_q4lPlx.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; [7] include; @ ./Base.jl:386 [inlined]; [8] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [9] top-level scope; @ none:1; [10] eval; @ ./boot.jl:360 [inlined]; [11] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [12] top-level scope; @ none:1; in expression starting at /home/tomas/repos/Oceananigans.jl/src/Oceananigans.jl:1; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /home/tomas/.julia/compiled/v1.6/Oceananigans/jl_psrPk0.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371:2102,load,loading,2102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371,1,['load'],['loading']
Performance,"se.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loadi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:4332,load,loading,4332,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"solves to calling a function, whereas calling `getindex` on a `Field` / `Array` fetches data from memory. So they are different. Naively I would expect that evaluating a complicated advection term involving `BackgroundField` would be cheaper than one that involved two concrete `Array`. But sometimes unexpected things happen (the compiler might decide to optimize the code differently...). Can you try running the code on the GPU? I think it would be enlightening to see if there's a slowdown in that case. We could potentially implement an interface whereby `Field`s can be used as `BackgroundField` rather than functions. That might give us some insight, because then the ""additional"" advection terms associated with `BackgroundField` would truly be identical to the ""original"" advection term. > because presumably the advection of the background state by the background state is zero. I would say that the background self-interaction terms are _neglected_ rather than presumed to be zero. Linear terms associated with the background fields are also neglected. The idea being that if there is a valid way to decompose a flow into background and perturbation components, then the equation that governs the background component is completely neglected (this includes both the nonlinear terms and any linear terms involving the background flow). _Side note:_ some nonlinear terms are additionally neglected in the case of nonlinear viscosity. Ideally I think we would include these because the above argument doesn't justify neglecting them, but the implementation seemed too complicated the last time I thought about it so I put it off. I think it's a solvable problem but requires a bit of thought to integrate into the current algorithm seamlessly. > Mu understanding is that it is required for GPU runs, but it also helps optimize CPU runs. This is correct --- if you're missing a `const` on a variable that's used in a kernel, that kernel will fail to compile on the GPU (it won't just be slow).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623:2485,optimiz,optimize,2485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623,1,['optimiz'],['optimize']
Performance,"src/compiler.jl:6657; [7] EnzymeCreatePrimalAndGradient(logic::Enzyme.Logic, todiff::LLVM.Function, retType::Enzyme.API.CDIFFE_TYPE, constant_args::Vector{…}, TA::Enzyme.TypeAnalysis, returnValue::Bool, dretUsed::Bool, mode::Enzyme.API.CDerivativeMode, width::Int64, additionalArg::Ptr{…}, forceAnonymousTape::Bool, typeInfo::Enzyme.FnTypeInfo, uncacheable_args::Vector{…}, augmented::Ptr{…}, atomicAdd::Bool); @ Enzyme.API ~/Projects/Enzymantics/Enzyme.jl/src/api.jl:141; [8] enzyme!(job::GPUCompiler.CompilerJob{…}, mod::LLVM.Module, primalf::LLVM.Function, TT::Type, mode::Enzyme.API.CDerivativeMode, width::Int64, parallel::Bool, actualRetType::Type, wrap::Bool, modifiedBetween::Tuple{…}, returnPrimal::Bool, jlrules::Vector{…}, expectedTapeType::Type, loweredArgs::Set{…}, boxedArgs::Set{…}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:7715; [9] codegen(output::Symbol, job::GPUCompiler.CompilerJob{…}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, toplevel::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9278; [10] codegen; @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:8886 [inlined]; [11] _thunk(job::GPUCompiler.CompilerJob{Enzyme.Compiler.EnzymeTarget, Enzyme.Compiler.EnzymeCompilerParams}, postopt::Bool) (repeats 2 times); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9830; [12] cached_compilation; @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9864 [inlined]; [13] (::Enzyme.Compiler.var""#474#475""{DataType, DataType, DataType, Enzyme.API.CDerivativeMode, Tuple{Bool, Bool, Bool}, Int64, Bool, Bool, UInt64, DataType})(ctx::LLVM.Context); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9921; [14] JuliaContext(f::Enzyme.Compiler.var""#474#475""{DataType, DataType, DataType, Enzyme.API.CDerivativeMode, Tuple{Bool, Bool, Bool}, Int64, Bool, Bool, UInt64, DataType}); @ GPUC",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259:2313,optimiz,optimize,2313,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259,1,['optimiz'],['optimize']
Performance,"ssentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/Oceananigans/jl_k7YOZN"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:5912,load,loading,5912,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"stdout::IO, keep_loaded_modules::Bool); │ @ Base ./loading.jl:2468; │ [3] compilecache; │ @ ./loading.jl:2340 [inlined]; │ [4] (::Base.var""#968#969""{Base.PkgId})(); │ @ Base ./loading.jl:1974; │ [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; │ [6] #mkpidlock#6; │ @ ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; │ [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; │ [8] #invokelatest#2; │ @ ./essentials.jl:894 [inlined]; │ [9] invokelatest; │ @ ./essentials.jl:889 [inlined]; │ [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); │ @ Base ./loading.jl:2983; │ [11] maybe_cachefile_lock; │ @ ./loading.jl:2980 [inlined]; │ [12] _require(pkg::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1970; │ [13] __require_prelocked(uuidkey::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1812; │ [14] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [15] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [16] _require_prelocked; │ @ ./loading.jl:1803 [inlined]; │ [17] _require_prelocked; │ @ ./loading.jl:1802 [inlined]; │ [18] run_extension_callbacks(extid::Base.ExtensionId); │ @ Base ./loading.jl:1295; │ [19] run_extension_callbacks(pkgid::Base.PkgId); │ @ Base ./loading.jl:1330; │ [20] run_package_callbacks(modkey::Base.PkgId); │ @ Base ./loading.jl:1164; │ [21] _tryrequire_from_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.jl:1574; │ [23] _require(pkg::Base.PkgId, env::Strin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:2238,load,loading,2238,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"stol=1.49e-08, solver iterations: 0, residual: (mean=0.00e+00, abs(max)=0.00e+00); [ Info: ... simulation initialization complete (109.482 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (4.840 seconds).; iteration: 1, time: 0.1000, U_max=(1.19e-02, 5.23e-03, 5.19e-03); reltol=1.49e-08, abstol=1.49e-08, solver iterations: 4096, residual: (mean=-1.78e-03, abs(max)=1.06e-02); iteration: 2, time: 0.2000, U_max=(1.21e-02, 4.93e-03, 5.20e-03); reltol=1.49e-08, abstol=1.49e-08, solver iterations: 4096, residual: (mean=-9.30e-04, abs(max)=5.56e-03); iteration: 3, time: 0.3000, U_max=(1.25e-02, 5.02e-03, 5.32e-03); reltol=1.49e-08, abstol=1.49e-08, solver iterations: 4096, residual: (mean=-4.85e-04, abs(max)=2.74e-03); iteration: 4, time: 0.4000, U_max=(6.23e+24, 4.49e+24, 6.19e+24); reltol=1.49e-08, abstol=1.49e-08, solver iterations: 4096, residual: (mean=-2.39e+23, abs(max)=1.51e+24); iteration: 5, time: 0.5000, U_max=(5.48e+179, 4.19e+179, 9.91e+179); reltol=1.49e-08, abstol=1.49e-08, solver iterations: 0, residual: (mean=-1.70e+174, abs(max)=1.13e+181); ERROR: LoadError: time = 0.6, iteration = 6: NaN found in field u. Aborting simulation.; ```. I tried reducing the time step from 0.1 to 0.01 but now it always blows up at iteration 1. Increasing the time step kept it blowing up after ~5 iterations. ---. > You can test this by omitting the preconditioner. Running with `preconditioner = nothing` causes it to always blow up on iteration 1 no matter the time step (after 4096 iterations). ```; [ Info: Initializing simulation...; iteration: 0, time: 0.0000, U_max=(0.00e+00, 0.00e+00, 0.00e+00); reltol=1.49e-08, abstol=1.49e-08, solver iterations: 0, residual: (mean=0.00e+00, abs(max)=0.00e+00); [ Info: ... simulation initialization complete (99.042 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.896 seconds).; ERROR: LoadError: time = 0.1, iteration = 1: NaN found in field u. Aborting simulation.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2412573112:3516,Load,LoadError,3516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2412573112,2,['Load'],['LoadError']
Performance,"strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:106; [14] compile; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:98 [inlined]; [15] #40; @ ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:140 [inlined]; [16] JuliaContext(f::AMDGPU.Compiler.var""#40#41""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:47; [17] hipcompile(job::GPUCompiler.CompilerJob); @ AMDGPU.Compiler ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:139; [18] actual_compilation(cache::Dict{Any, AMDGPU.HIP.HIPFunction}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}, compiler::typeof(AMDGPU.Compiler.hipcompile), linker::typeof(AMDGPU.Compiler.hiplink)); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/execution.jl:125; [19] cached_compilation(cache::Dict{Any, AMDGPU.HIP.HIPFunction}, src::Core.MethodInstance, cfg::GPUCompiler.CompilerConfig{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}, compiler::Function, linker::Function); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/execution.jl:103; [20] macro expansion; @ ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:107 [inlined]; [21] macro expansion; @ ./lock.jl:267 [inlined]; [22] hipfunction(f::GPUArrays.var""#6#7"", tt::Type{Tuple{AMDGPU.ROCKernelContext, AMDGPU.Device.ROCDeviceArray{Float64, 3, 1}, Float64}}; kwargs::@Kwargs{name::Nothing}); @ AMDGPU.Compiler ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:101; [23] hipfunction; @ ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:100 [inlined]; [24] macro expansion; @ ~/.julia/packages/AMDGPU/FdIJi/src/highlevel.jl:157 [inlined]; [25] #gpu_call#49; @ ~/.julia/packages/AMDGPU/FdIJi/src/gpuarrays.jl:8 [inlined]; [26] gpu_call; @ ~/.julia/packages/AMDGPU/FdIJi/src/gpuarrays.jl:5 [",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273:3204,cache,cache,3204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273,2,['cache'],['cache']
Performance,"taticArraysStatisticsExt; ✓ UnsafeAtomicsLLVM; ✓ Colors; ✓ GPUArraysCore; ✓ NVTX. ✓ GPUArrays; ✓ KernelAbstractions; ✓ PrettyTables; ✓ GPUCompiler; ✓ DataFrames; ✗ CUDA; 61 dependencies successfully precompiled in 190 seconds. 5 already precompiled. The following 1 direct dependency failed to precompile:. CUDA [052768ef-5323-5732-b1bb-66c8b64840ba]. Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_UQIv2i"".; [45592] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:25; Allocations: 2907 (Pool: 2898; Big: 9); GC: ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_CUC33l"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_ag",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:5202,load,loading,5202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,1,['load'],['loading']
Performance,"tdlib/v1.10/FileWatching/src/pidfile.jl:111; │ [8] #invokelatest#2; │ @ ./essentials.jl:894 [inlined]; │ [9] invokelatest; │ @ ./essentials.jl:889 [inlined]; │ [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); │ @ Base ./loading.jl:2983; │ [11] maybe_cachefile_lock; │ @ ./loading.jl:2980 [inlined]; │ [12] _require(pkg::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1970; │ [13] __require_prelocked(uuidkey::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1812; │ [14] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [15] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [16] _require_prelocked; │ @ ./loading.jl:1803 [inlined]; │ [17] _require_prelocked; │ @ ./loading.jl:1802 [inlined]; │ [18] run_extension_callbacks(extid::Base.ExtensionId); │ @ Base ./loading.jl:1295; │ [19] run_extension_callbacks(pkgid::Base.PkgId); │ @ Base ./loading.jl:1330; │ [20] run_package_callbacks(modkey::Base.PkgId); │ @ Base ./loading.jl:1164; │ [21] _tryrequire_from_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.jl:1574; │ [23] _require(pkg::Base.PkgId, env::String); │ @ Base ./loading.jl:1938; │ [24] __require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1812; │ [25] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [26] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [27] _require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1803; │ [28] macro expansion; │ @ ./loading.jl:1790 [inlined]; │ [29] macro expansion; │ @ ./lock.jl:267 [inlined]; │ [30] __require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1753; │ [31] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [32] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [33] require(into::Mod",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:2898,load,loading,2898,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"te:. > Some pretty promising Lagrangian particle tracking benchmarks!; >; > Couple of takeaways (all assuming a model with 128^3 grid points and QAB2; > time stepping):; >; > 1. *Low overhead*: You can advect up to ~100,000 particles on the CPU; > and up to ~10,000,000 particles on a (Titan V) GPU before the model slows; > down by more than 30%.; > 2. *Great on GPUs*: Seems that the GPU is great for advecting millions; > of particles. You can advect ~100,000,000 particles and your model only; > slows down by a factor of 4x. In this scenario, the GPU is ~620x faster; > than a single CPU core.; > 3. Calculated using (t_100000000 - t_0) / 100000000, advecting a; > single particle on the CPU takes ~110 ns while on the GPU it only takes; > ~0.127 ns. This seems a little too good to be true but I'll double check; > this.; >; > I'll start refactoring this PR using @glwagner; > <https://github.com/glwagner>'s and @zhenwu0728; > <https://github.com/zhenwu0728>'s feedback, but I think it would be; > really great if we can keep this performance.; > Benchmarks; >; > Oceananigans v0.44.1; > Julia Version 1.5.2; > Commit 539f3ce943 (2020-09-23 23:17 UTC); > Platform Info:; > OS: Linux (x86_64-pc-linux-gnu); > CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; > WORD_SIZE: 64; > LIBM: libopenlibm; > LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); > GPU: TITAN V; >; > Lagrangian particle tracking benchmarks; > ┌───────────────┬─────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; > │ Architectures │ N_particles │ min │ median │ mean │ max │ memory │ allocs │; > ├───────────────┼─────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; > │ CPU │ 0 │ 361.749 ms │ 364.041 ms │ 364.293 ms │ 368.854 ms │ 293.44 KiB │ 1876 │; > │ CPU │ 1 │ 375.030 ms │ 376.591 ms │ 377.959 ms │ 385.248 ms │ 297.16 KiB │ 1906 │; > │ CPU │ 10 │ 377.251 ms │ 380.792 ms │ 387.560 ms │ 443.325 ms │ 297.16 KiB │ 1906 │; > │ CPU │ 100 │ 378.867 ms │ 3",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982:1375,perform,performance,1375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982,1,['perform'],['performance']
Performance,"the Redi tensor and GM for TwoDimensionalLeith so GM-Redi might; > not need too much extra work:; > https://github.com/CliMA/Oceananigans.jl/blob/master/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl; > Questions/proposal; >; > 1. Do we make the small-angle approximation? I would say yes.; >; > In Oceananigans.jl right now each component of the tensor diffusivity is; > calculated on-the-fly so the unapproximated tensor could end up being 2-4x; > more expensive to compute. We cannot compute the full tensor in one go; > (reusing the isopycnal slopes) and we may not want to since it takes up a; > lot of memory (9 extra field?). But maybe there's a good reason to not make; > the small-angle approximation? We could eventually support both; > (unapproximated and small-angle approximation).; >; > See; > https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#redi-scheme-isopycnal-diffusion; > for a comparison of the two.; >; > 1. Is GM-Redi the main parameterization of interest? Would people use; > the fully symmetric or the fully anti-symmetric diffusivity tensor by; > themselves?; >; > If not then maybe we can save some time by just implementing one new; > closure, GMRedi or GentMcWilliamsRedi. If we take the isopycnal; > diffusivity to be the same for both the symmetric and anti-symmetric tensor; > then we the resulting tensor is quite cheap to compute (only 3 components); > if performance is important:; >; > From; > https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#griffies-skew-flux; > [image: image]; > <https://user-images.githubusercontent.com/20099589/111556957-1abbeb80-8762-11eb-9fb3-870d447efa5f.png>; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1492>, or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQT2T2NK46W7G7ZS5ULTEFFH5ANCNFSM4ZLUCVJQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1492#issuecomment-801541587:2311,perform,performance,2311,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1492#issuecomment-801541587,1,['perform'],['performance']
Performance,"tly focused on IO and has not had the bandwidth to think about how it might interface with packages for (climate/ocean/etc) models. That might be useful down the line! Yes we're both around MIT. I think we're still figuring how we want to do IO in the long-term but will definitely want some way to output NetCDF. > Hey, original author of both https://github.com/JuliaGeo/NetCDF.jl and https://github.com/meggart/ZarrNative.jl here. Regarding the state of NetCDF.jl , yes I would say I mostly stopped developing the package due to time constraints and currently shift my focus towards Zarr since this is what we are using in our current project.; > ; > My last attempt at improving the NetCDF solved many of the issues with the package JuliaGeo/NetCDF.jl#61 but was not merged because of conflicts with other bugfix PRs. However, might be source of inspiration if someone wants to do a rewrite.; > ; > Regarding write performance, I would be very interested to see examples where NetCDF.jl performs worse than e.g. python-netcdf4, since most of the time should be spent in the same NetCDF C library. I have been using the package extensively and did not experience it to be slower than comparable packages.; > ; > I you are worried about the robustness of NetCDF.jl, you should not even look at ZarrNative.jl, since it is still very young and rather a prototype.; > ; > I would be very happy to discuss the issues further, maybe in a call? Would also be interested to learn about your project which seems to be very cool. Thanks so much for working on NetCDF.jl! I didn't mean to sound ungrateful about NetCDF.jl's performance. We were just debating which package to use. With https://github.com/JuliaGeo/NetCDF.jl/issues/87 fixed, I think we'll be happy for a long time. The `compress=9` bug explains why the IO was slow. @glwagner has suggested that for a project of our scale we'd want to help and contribute to the packages we use. We definitely want to stick with NetCDF as it's the _de facto_ s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847:1309,perform,performs,1309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847,1,['perform'],['performs']
Performance,"to two parts, so that we can build a tridiagonal solver even when all three directions are regular. That could be useful for testing, for example.; > ; > I have added this capability by passing the `stretched_direction` kwarg.; > ; > > Also note that in terms of operation count the tridiagonal solve is cheaper than FFT...; > ; > I think, all things considered, the mixed FFT / tridiagonal solve will have basically the same computational cost as the pure FFT solve only for a stretched x direction. The additional transposes required for a y or stretched z direction will completely dominate the cost of the actual operations.; > ; > As an example, this is a slab decomposition with a fairly big grid (512 x 256^2) split on 2 GPUs on Tartarus ![311333172-43dba752-a91f-4b33-8ade-5a6ec57c982b](https://private-user-images.githubusercontent.com/33547697/356260457-1a376c1e-9912-4e00-8dca-91deb46338f8.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3MjMyMjUwMzMsIm5iZiI6MTcyMzIyNDczMywicGF0aCI6Ii8zMzU0NzY5Ny8zNTYyNjA0NTctMWEzNzZjMWUtOTkxMi00ZTAwLThkY2EtOTFkZWI0NjMzOGY4LnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNDA4MDklMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjQwODA5VDE3MzIxM1omWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPThhMGNhZDRiOTllYzFjOWFlNGZkMzAwYzI2NDVjY2Y3MzhmYzY5YmU0YzJjOTBlMzI2YzdmNTg4ODNlMGRmMTgmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0JmFjdG9yX2lkPTAma2V5X2lkPTAmcmVwb19pZD0wIn0.6MqQHl0lgCvD7e15b8kOkTduQBQlvSRwfyHAPQuxAps) The AlltoAllv is the dominant cost, while the FFT (in between the two transposes) is quite irrelevant. In the near future, I'll perform scaling tests on Perlmutter, which has a much better network, so it might be that (even if I think it's unlikely) the cost is not all communication after all. Just to clarify --- the mixed tridiagonal + FFT solver also needs eigenvalues, doesn't it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3689#issuecomment-2278419522:3112,perform,perform,3112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3689#issuecomment-2278419522,1,['perform'],['perform']
Performance,"tructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-parallelism to reduce the overall time. @glwagner can control who on the project can submit bors jobs by editing the bors access control settings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:1570,concurren,concurrent,1570,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778,1,['concurren'],['concurrent']
Performance,"ts...; [2023/02/25 15:42:20.355] INFO Testing shallow water Bickley jet simulation regression [CPU, ConservativeFormulation]; [2023/02/25 15:42:21.128] INFO Initializing simulation...; [2023/02/25 15:42:21.129] INFO ... simulation initialization complete (685.283 μs); [2023/02/25 15:42:21.129] INFO Executing initial time step...; [2023/02/25 15:42:23.148] INFO ... initial time step complete (2.019 seconds).; [2023/02/25 15:42:23.672] INFO Simulation is stopping after running for 2.521 seconds.; [2023/02/25 15:42:23.672] INFO Model iteration 20 equals or exceeds stop iteration 20.; [2023/02/25 15:42:23.814] INFO Δu: min=-1.673332e-04, max=+1.094476e-04, mean=+2.507827e-07, absmean=+5.538768e-06, std=+1.574960e-05 (16384/16384 matching grid points); [2023/02/25 15:42:23.814] INFO Δv: min=-2.878156e-04, max=+1.230686e-04, mean=+1.406671e-07, absmean=+2.141572e-05, std=+4.550342e-05 (256/16512 matching grid points); [2023/02/25 15:42:23.814] INFO Δh: min=-1.126421e-03, max=+1.182485e-03, mean=+9.255018e-09, absmean=+7.901569e-05, std=+2.067916e-04 (16384/16384 matching grid points); Shallow Water Bickley jet simulation [CPU, ConservativeFormulation]: Test Failed at /home/fpoulin/Software/Oceananigans.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:95; Expression: all(test_fields.v .≈ truth_fields.v); Stacktrace:; [1] macro expansion; @ ~/Software/julia-1.8.2/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] run_shallow_water_regression(arch::CPU, formulation::ConservativeFormulation; regenerate_data::Bool); @ Main ~/Software/Oceananigans.jl/test/regression_tests/shallow_water_bickley_jet_regression.jl:95; Test Summary: | Fail Total Time; Shallow Water Regression | 1 1 3.5s; Shallow Water Bickley jet simulation [CPU, ConservativeFormulation] | 1 1 3.5s; ERROR: LoadError: Some tests did not pass: 0 passed, 1 failed, 0 errored, 0 broken.; in expression starting at /home/fpoulin/Software/Oceananigans.jl/test/test_shallow_water_regression.jl:6; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1445209446:3574,Load,LoadError,3574,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1445209446,1,['Load'],['LoadError']
Performance,"und + deviation. If that's not the case then the boundary conditions are set up correctly. I believe the next thing to try is the same set up but without `BackgroundField` and imposing the Neumann boundary conditions associated with the buoyancy frequency. If that behaves correctly, then the problem would appear to be in `BackgroundField`, as you suspect. . **Update:** ; I made the following changes,. - Removed the background field from model,; - Added `N^2 * (z + D)` into the initial conditiosn of the buoyancy,; - Imposed `buoyancy_gradient_bc` at the top and bottom of the domain. Unfortunately, the same problems occur at the boundary. . This does not seem to be imposing the correct boundary conditions on a tracer field at the top and bottom. **Periodic condition:**; I did try setting the vertical direction to periodic and unfortunately that gave an error, copied below. . Is this a seperate problem or do people think it's related?. ```; ERROR: LoadError: ArgumentError: batching dims must be sequential; Stacktrace:; [1] create_plan(::CUDA.CUFFT.cufftType_t, ::Tuple{Int64,Int64,Int64}, ::Array{Int64,1}) at /home/fpoulin/.julia/packages/CUDA/wTQsK/lib/cufft/fft.jl:140; [2] plan_fft! at /home/fpoulin/.julia/packages/CUDA/wTQsK/lib/cufft/fft.jl:256 [inlined]; [3] plan_forward_transform at /home/fpoulin/software/Oceananigans.jl/src/Solvers/plan_transforms.jl:42 [inlined]; [4] plan_transforms(::GPU, ::RegularRectilinearGrid{Float64,Flat,Bounded,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::CUDA.CuArray{Complex{Float64},3}, ::UInt32) at /home/fpoulin/software/Oceananigans.jl/src/Solvers/plan_transforms.jl:106; [5] Oceananigans.Solvers.FFTBasedPoissonSolver(::GPU, ::RegularRectilinearGrid{Float64,Flat,Bounded,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::UInt32) at /home/fpoulin/software/Oceananigans.jl/src/Solv",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815670594:1092,Load,LoadError,1092,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815670594,1,['Load'],['LoadError']
Performance,"up Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_Δ, title=""Incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_Δ, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_Δ, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; docs/src/physics/incompressible_model.md:# Incompressible model; docs/src/numerical_implementation/time_stepping.md:where, e.g., ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:1344,perform,performance,1344,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326,1,['perform'],['performance']
Performance,"ure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... 12. Fix tests!. 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much memory.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979:2202,perform,performance,2202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979,2,['perform'],['performance']
Performance,"ut::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::Nothing); @ Base ./loading.jl:2222; [4] top-level scope; @ stdin:3; in expression starting at /Users/navid/.julia/packages/TaylorSeries/2qRvJ/ext/TaylorSeriesIAExt.jl:1; in expression starting at stdin:3; ┌ Error: Error during loading of extension TaylorSeriesIAExt of TaylorSeries, use `Base.retry_load_extensions()` to retry.; │ exception =; │ 1-element ExceptionStack:; │ Failed to precompile TaylorSeriesIAExt [ed7ef945-33a4-511e-97fe-2b89c7a130ca] to ""/Users/navid/.julia/compiled/v1.10/TaylorSeriesIAExt/jl_TNauRw"".; │ Stacktrace:; │ [1] error(s::String); │ @ Base ./error.jl:35; │ [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); │ @ Base ./loading.jl:2468; │ [3] compilecache; │ @ ./loading.jl:2340 [inlined]; │ [4] (::Base.var""#968#969""{Base.PkgId})(); │ @ Base ./loading.jl:1974; │ [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; │ [6] #mkpidlock#6; │ @ ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; │ [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; │ [8] #invokelatest#2; │ @ ./essentials.jl:894 [inlined]; │ [9] invokelatest; │ @ ./essentials.jl:889 [inlined]; │ [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); │ @ Base ./loading.jl:2983; │ [11] maybe_cachefile_lock; │ @ ./loading.jl:2980 [inlined]; │ [12] _require(pkg::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1970; │ [13] __require_prelocked(uuidkey::Base.PkgId, env::Nothing); │ @ Base ./loadin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:1417,load,loading,1417,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/h",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:4413,load,loading,4413,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"wn. So there's definitely something going on here for GPUs; > * I have struggled with this for quite some time until I found the culprit, so if we can't immediately find and fix the cause I'd suggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ between precomputing a potentially expensive operation, and performing it on-the-fly. For constants, precomputation is harmless. For arrays, on-the-fly computation has significant benefits, both for code readability and also possibly for performance",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:1281,perform,performed,1281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151,6,"['optimiz', 'perform']","['optimization', 'performance', 'performed']"
Performance,"y.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::Int64); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] #Field#15; @ ~/github/Oceananigans.jl/src/Fields/field.jl:182 [inlined]; [7] top-level scope; @ REPL[39]:1; Some type information was truncated. Use `show(err)` to see complete types.; ``` . > @josuemtzmo can you show the whole stack trace of your error so we can see where the indexing issue comes in?; Yes, here it is:; ```; ERROR: LoadError: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 4:8]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::UnitRange{Int64}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] Field; @ ~/github/Oceananigans.jl/src/Fields/field.jl:182 [inlined]; [7] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, wit",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:3760,Load,LoadError,3760,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658,1,['Load'],['LoadError']
Performance,"you mean like this?. ```; ERROR: LoadError: AssertionError: false; Stacktrace:; [1] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType, prev::LLVM.UndefValue, lidxs::Vector{UInt32}, ridxs::Vector{UInt32}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler/utils.jl:271; [2] calling_conv_fixup (repeats 2 times); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler/utils.jl:183 [inlined]; [3] calling_conv_fixup(builder::LLVM.IRBuilder, val::LLVM.AddrSpaceCastInst, tape::LLVM.PointerType); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler/utils.jl:183; [4] enzyme_custom_common_rev(forward::Bool, B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, normalR::Ptr{Nothing}, shadowR::Ptr{Nothing}, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:4610; [5] enzyme_custom_rev(B::LLVM.IRBuilder, orig::LLVM.CallInst, gutils::Enzyme.Compiler.GradientUtils, tape::LLVM.ExtractValueInst); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:4770; [6] (::Enzyme.Compiler.var""#201#202"")(B::Ptr{LLVM.API.LLVMOpaqueBuilder}, OrigCI::Ptr{LLVM.API.LLVMOpaqueValue}, gutils::Ptr{Nothing}, tape::Ptr{LLVM.API.LLVMOpaqueValue}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:6657; [7] EnzymeCreatePrimalAndGradient(logic::Enzyme.Logic, todiff::LLVM.Function, retType::Enzyme.API.CDIFFE_TYPE, constant_args::Vector{…}, TA::Enzyme.TypeAnalysis, returnValue::Bool, dretUsed::Bool, mode::Enzyme.API.CDerivativeMode, width::Int64, additionalArg::Ptr{…}, forceAnonymousTape::Bool, typeInfo::Enzyme.FnTypeInfo, uncacheable_args::Vector{…}, augmented::Ptr{…}, atomicAdd::Bool); @ Enzyme.API ~/Projects/Enzymantics/Enzyme.jl/src/api.jl:141; [8] enzyme!(job::GPUCompiler.CompilerJob{…}, mod::LLVM.Module, primalf::LLVM.Function, TT::Type, mode::Enzyme.API.CDerivativeMode, width::Int64, parallel::Bool, actualRetType::Type, wrap::B",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259:33,Load,LoadError,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259,1,['Load'],['LoadError']
Performance,"| ######################################################################## 100.0%; &nbsp; | Downloading artifact: CompilerSupportLibraries; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: MPICH; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibCURL; &nbsp; | ######################################################################## 100.0%; &nbsp; | Building MPI ─→ `/storage7/buildkite-agent/.julia-2581/packages/MPI/b7MVG/deps/build.log`; &nbsp; | [ Info: using default MPI jll; &nbsp; | Building FFTW → `/storage7/buildkite-agent/.julia-2581/packages/FFTW/G3lSO/deps/build.log`; &nbsp; | Precompiling project...; &nbsp; | WARNING: Error during initialization of module GMP:; &nbsp; | ErrorException(""could not load library ""libgmp""; &nbsp; | libgmp.so: ELF load command past end of file""); &nbsp; | WARNING: Error during initialization of module LinearAlgebra:; &nbsp; | ErrorException(""could not load library ""libopenblas64_""; &nbsp; | libopenblas64_.so: ELF load command past end of file""); &nbsp; | ┌ Error: Error during initialization of module CHOLMOD; &nbsp; | │ exception =; &nbsp; | │ could not load library ""libcholmod""; &nbsp; | │ libopenblas64_.so.0: ELF load command past end of file; &nbsp; | │ Stacktrace:; &nbsp; | │ [1] dlopen(::String, ::UInt32; throw_error::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109; &nbsp; | │ [2] dlopen at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109 [inlined] (repeats 2 times); &nbsp; | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: er",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:2376,load,load,2376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,2,['load'],['load']
Performance,"| [8] read;   | @ ./io.jl:434 [inlined];   | [9] _include(mapexpr::Function, mod::Module, _path::String);   | @ Base ./loading.jl:1166;   | [10] include(mod::Module, _path::String);   | @ Base ./Base.jl:386;   | [11] include(x::String);   | @ Oceananigans.Advection ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:1;   | [12] top-level scope;   | @ ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:43;   | [13] include(mod::Module, _path::String);   | @ Base ./Base.jl:386;   | [14] include(x::String);   | @ Oceananigans ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:1;   | [15] top-level scope;   | @ ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:173;   | [16] include;   | @ ./Base.jl:386 [inlined];   | [17] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing);   | @ Base ./loading.jl:1235;   | [18] top-level scope;   | @ none:1;   | [19] eval;   | @ ./boot.jl:360 [inlined];   | [20] eval(x::Expr);   | @ Base.MainInclude ./client.jl:446;   | [21] top-level scope;   | @ none:1;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:1;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:1;   | Stacktrace:;   | [1] pkgerror(msg::String);   | @ Pkg.Types /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Types.jl:55;   | [2] precompile(ctx::Pkg.Types.Context; internal_call::Bool, strict::Bool, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}});   | @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1265;   | [3] precompile;   | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:921 [inlined];   | [4] #prec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134:2273,load,loading,2273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134,1,['load'],['loading']
Performance,"}, args::LLVM.Module); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/validation.jl:111; [2] macro expansion; @ /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/driver.jl:319 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/.julia/packages/TimerOutputs/PZq45/src/TimerOutput.jl:226 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/driver.jl:317 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/utils.jl:62; [6] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/mVgLI/src/compiler/execution.jl:313; [7] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/cache.jl:89; [8] cufunction(f::typeof(Cassette.overdub), tt::Type{Tuple{Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CUDA.CuDeviceArray{Float32, 3, 1}}, RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, WENO5, Nothing, Nothing, Nothing, Buoyancy{SeawaterBuoyancy{Float32, LinearEquationOfState{Float32}, Nothing, Nothing}, Oceananigans.BuoyancyModels.ZDirection}, NamedTuple{(:velocities, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360:17445,cache,cache,17445,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360,1,['cache'],['cache']
Performance,"}}, CPU}, MinimalBiogeochemistryType::Type{MinimalDiscreteBiogeochemistry}, ModelType::Type{HydrostaticFreeSurfaceModel}); @ Main ~/Research/OC5.jl/test/test_biogeochemistry.jl:109; [22] macro expansion; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:139 [inlined]; [23] macro expansion; @ ~/julia-1.9/usr/share/julia/stdlib/v1.9/Test/src/Test.jl:1498 [inlined]; [24] top-level scope; @ ~/Research/OC5.jl/test/test_biogeochemistry.jl:127; [25] include(fname::String); @ Base.MainInclude ./client.jl:478; [26] top-level scope; @ REPL[2]:1; [27] eval; @ ./boot.jl:370 [inlined]; [28] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:153; [29] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:249; [30] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [31] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [32] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL ~/julia-1.9/usr/share/julia/stdlib/v1.9/REPL/src/REPL.jl:365; [33] (::Base.var""#1017#1019""{Bool, Bool, Bool})(REPL::Module); @ Base ./client.jl:421; [34] #invokelatest#2; @ ./essentials.jl:816 [inlined]; [35] invokelatest; @ ./essentials.jl:813 [inlined]; [36] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); @ Base ./client.jl:405; [37] exec_options(opts::Base.JLOptions); @ Base ./client.jl:322; [38] _start(); @ Base ./client.jl:522; Test Summary: | Pass Error Total Time; Biogeochemistry | 9 1 10 1m32.9s; ERROR: LoadError: Some tests did not pass: 9 passed, 0 failed, 1 errored, 0 broken.; in expression start; ```. so it seems like those lines are called by the matrix implicit solver somehow?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635:23261,Load,LoadError,23261,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630460635,1,['Load'],['LoadError']
Performance,"─── v1.3.0; Installed Reexport ──────────────────── v1.2.2; Installed JuliaNVTXCallbacks_jll ────── v0.2.1+0; Installed BFloat16s ─────────────────── v0.5.0; Installed MacroTools ────────────────── v0.5.13; Installed DataStructures ────────────── v0.18.20; Installed Colors ────────────────────── v0.12.11; Installed KernelAbstractions ────────── v0.9.22; Installed RandomNumbers ─────────────── v1.5.3; Installed Missings ──────────────────── v1.2.0; Installed Compat ────────────────────── v4.15.0; Installed StringManipulation ────────── v0.3.4; Installed SortingAlgorithms ─────────── v1.2.1; Installed UnsafeAtomics ─────────────── v0.2.1; Installed Atomix ────────────────────── v0.1.0; Installed LLVM ──────────────────────── v8.0.0; Installed CUDA ──────────────────────── v5.4.3; Updating `/glade/derecho/scratch/knudsenl/BottomBoundaryLayer/Project.toml`; [052768ef] + CUDA v5.4.3; Updating `/glade/derecho/scratch/knudsenl/BottomBoundaryLayer/Manifest.toml`; ERROR: LoadError: failed process: Process(`/glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/bin/julia -C native -J/glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/lib/julia/sys.so -g1 -O0 --color=no --history-file=no --startup-file=no --project=/glade/derecho/scratch/knudsenl/BottomBoundaryLayer/Project.toml --eval 'append!(empty!(Base.DEPOT_PATH), [""/glade/u/home/knudsenl/.julia"", ""/glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/local/share/julia"", ""/glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia""]); append!(empty!(Base.DL_LOAD_PATH), String[]). cd(""/glade/u/home/knudsenl/.julia/packages/CUDA_Runtime_jll/YgJCI/.pkg""); include(""/glade/u/home/knudsenl/.julia/packages/CUDA_Runtime_jll/YgJCI/.pkg/select_artifacts.jl""); ' -t1 --startup-file=no x86_64-linux-gnu-libgfortran5-cxx11-libstdcxx30-julia_version+1.10.2`, ProcessSignaled(11)) [0]. Stacktrace:; [1] pipeline_error; @ ./process.jl:565 [inlined]; [2] read(cmd::Cmd)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2246012900:3274,Load,LoadError,3274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2246012900,1,['Load'],['LoadError']
Performance,"──────────────────────────────┴─────────┴─────────┴─────────┘; ```. ### Relative performance on the CPU. ```; Fourier-tridiagonal Poisson solver relative performance (CPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬──────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼──────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.58185 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.24529 │ 0.922481 │ 1.0 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.27117 │ 0.922481 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴──────────┴────────┘; ```. ### Relative performance on the GPU. ```; Fourier-tridiagonal Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 3.12065 │ 3.32057 │ 3.02069 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 2.41833 │ 2.26316 │ 2.16897 │; │ GPU │ 256 │ (Periodic, Bounded, Bounded) │ 2.41007 │ 2.26316 │ 2.16897 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴─────────┴─────────┘; ```. ---. ## FFT-based Poisson solver. ### Raw benchmarks. ```; FFT-based Poisson solver benchmarks ; ┌───────────────┬─────┬───────────────────────────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:9023,perform,performance,9023,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050,1,['perform'],['performance']
Performance,"───────────────────────────┬─────────┬─────────┬────────┐; │ Ns │ Topologies │ speedup │ memory │ allocs │; ├─────┼────────────────────────────────┼─────────┼─────────┼────────┤; │ 192 │ (Bounded, Bounded, Bounded) │ 33.4393 │ 448.0 │ 226.0 │; │ 192 │ (Bounded, Bounded, Periodic) │ 32.0602 │ 368.0 │ 325.5 │; │ 192 │ (Bounded, Periodic, Bounded) │ 34.7631 │ 366.8 │ 322.5 │; │ 192 │ (Bounded, Periodic, Periodic) │ 17.1932 │ 178.2 │ 147.0 │; │ 192 │ (Periodic, Bounded, Bounded) │ 36.7915 │ 368.0 │ 325.5 │; │ 192 │ (Periodic, Bounded, Periodic) │ 35.3884 │ 196.0 │ 193.0 │; │ 192 │ (Periodic, Periodic, Bounded) │ 49.4769 │ 178.2 │ 147.0 │; │ 192 │ (Periodic, Periodic, Periodic) │ 58.4816 │ 5.83333 │ 7.75 │; └─────┴────────────────────────────────┴─────────┴─────────┴────────┘; ```. ## CPU slowdown (vs. triply-periodic). ```; FFT-based Poisson solver relative performance (CPU); ┌───────────────┬─────┬────────────────────────────────┬──────────┬──────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼──────────┼──────────┼────────┤; │ CPU │ 192 │ (Bounded, Bounded, Bounded) │ 2.76522 │ 1.0 │ 1.0 │; │ CPU │ 192 │ (Bounded, Bounded, Periodic) │ 2.14077 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Bounded, Periodic, Bounded) │ 2.32425 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Bounded, Periodic, Periodic) │ 1.64349 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 2.44462 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Periodic, Bounded, Periodic) │ 1.79278 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 1.72073 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴──────────┴────────┘; ```. ## GPU slowdown (vs. triply-periodic). ```; FFT-based Poisson solver relative performance (GPU); ┌───────────────┬─────┬────────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:3722,perform,performance,3722,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296,2,['perform'],['performance']
Performance,"────────────┬────────────┬──────────┬────────┬─────────┐; │ size │ ranks │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├─────────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ (256, 256, 256) │ (1, 1, 1) │ 4.412 s │ 4.486 s │ 4.486 s │ 4.560 s │ 1.89 MiB │ 2623 │ 2 │; │ (256, 256, 256) │ (1, 2, 1) │ 2.275 s │ 2.303 s │ 2.297 s │ 2.312 s │ 1.74 MiB │ 2979 │ 6 │; │ (256, 256, 256) │ (1, 4, 1) │ 1.095 s │ 1.149 s │ 1.152 s │ 1.280 s │ 1.74 MiB │ 3019 │ 20 │; │ (256, 256, 256) │ (1, 8, 1) │ 583.413 ms │ 667.475 ms │ 663.315 ms │ 924.523 ms │ 1.74 MiB │ 3099 │ 64 │; │ (256, 256, 256) │ (1, 16, 1) │ 341.718 ms │ 383.898 ms │ 405.727 ms │ 771.915 ms │ 1.76 MiB │ 3259 │ 160 │; └─────────────────┴────────────┴────────────┴────────────┴────────────┴────────────┴──────────┴────────┴─────────┘. Incompressible model strong scaling speedup; ┌─────────────────┬────────────┬─────────┬────────────┬──────────┬─────────┐; │ size │ ranks │ speedup │ efficiency │ memory │ allocs │; ├─────────────────┼────────────┼─────────┼────────────┼──────────┼─────────┤; │ (256, 256, 256) │ (1, 1, 1) │ 1.0 │ 1.0 │ 1.0 │ 1.0 │; │ (256, 256, 256) │ (1, 2, 1) │ 1.94757 │ 0.973786 │ 0.918534 │ 1.13572 │; │ (256, 256, 256) │ (1, 4, 1) │ 3.90488 │ 0.976221 │ 0.91981 │ 1.15097 │; │ (256, 256, 256) │ (1, 8, 1) │ 6.72045 │ 0.840057 │ 0.922588 │ 1.18147 │; │ (256, 256, 256) │ (1, 16, 1) │ 11.6847 │ 0.730294 │ 0.928952 │ 1.24247 │; └─────────────────┴────────────┴─────────┴────────────┴──────────┴─────────┘; ```; ![ss_incompressible_times](https://user-images.githubusercontent.com/45054739/122680369-c5f29b80-d1bc-11eb-96eb-79174872e345.png); ![ss_incompressible_efficiency](https://user-images.githubusercontent.com/45054739/122680383-d0ad3080-d1bc-11eb-9939-5af092b042da.png). The overall trend looks like that efficiency plateaus off at around 75% when using 32 or more cores. We'll be trying to benchmark the GPUs' scaling performance next.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-864573659:4985,perform,performance,4985,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-864573659,1,['perform'],['performance']
Performance,"───┬─────────┬─────────┬─────────┐; │ Ns │ Topologies │ speedup │ memory │ allocs │; ├─────┼────────────────────────────────┼─────────┼─────────┼─────────┤; │ 192 │ (Bounded, Bounded, Bounded) │ 107.967 │ 2.24983 │ 3.89024 │; │ 192 │ (Bounded, Bounded, Periodic) │ 122.789 │ 2.55222 │ 3.89223 │; │ 192 │ (Bounded, Periodic, Bounded) │ 103.133 │ 2.56202 │ 3.83395 │; │ 192 │ (Bounded, Periodic, Periodic) │ 84.934 │ 2.95066 │ 3.86268 │; │ 192 │ (Periodic, Bounded, Bounded) │ 102.06 │ 2.56254 │ 3.83673 │; │ 192 │ (Periodic, Bounded, Periodic) │ 108.457 │ 2.95943 │ 3.91362 │; │ 192 │ (Periodic, Periodic, Bounded) │ 161.616 │ 2.96456 │ 3.81949 │; │ 192 │ (Periodic, Periodic, Periodic) │ 178.682 │ 3.4072 │ 3.38448 │; └─────┴────────────────────────────────┴─────────┴─────────┴─────────┘; ```. ## CPU slowdown (vs. triply-periodic). ```; Topologies relative performance (CPU); ┌───────────────┬─────┬────────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼──────────┼─────────┼─────────┤; │ CPU │ 192 │ (Bounded, Bounded, Bounded) │ 1.34309 │ 1.46266 │ 1.48014 │; │ CPU │ 192 │ (Bounded, Bounded, Periodic) │ 1.25281 │ 1.30927 │ 1.30084 │; │ CPU │ 192 │ (Bounded, Periodic, Bounded) │ 1.05249 │ 1.30927 │ 1.30084 │; │ CPU │ 192 │ (Bounded, Periodic, Periodic) │ 1.07645 │ 1.14247 │ 1.08664 │; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 1.0409 │ 1.30927 │ 1.30084 │; │ CPU │ 192 │ (Periodic, Bounded, Periodic) │ 0.938853 │ 1.14247 │ 1.08664 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 1.17749 │ 1.14247 │ 1.08664 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. ## GPU slowdown (vs. triply-periodic). ```; Topologies relative performance (GPU); ┌───────────────┬─────┬────────────────────────────────┬──────────┬──────────┬─────────┐; │ Architectu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:8955,perform,performance,8955,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296,2,['perform'],['performance']
Performance,┤; │ 0 │ 82.2319 │ 3.01565 │ 6.08156 │; │ 1 │ 83.1848 │ 3.01946 │ 6.06663 │; │ 10 │ 83.6845 │ 3.01704 │ 6.0425 │; │ 100 │ 84.1322 │ 3.01704 │ 6.0425 │; │ 1000 │ 84.6106 │ 3.01946 │ 6.06663 │; │ 10000 │ 84.072 │ 3.01704 │ 6.0425 │; │ 100000 │ 86.1581 │ 3.01704 │ 6.0425 │; │ 1000000 │ 106.432 │ 3.01946 │ 6.06663 │; │ 10000000 │ 254.889 │ 3.01935 │ 6.06558 │; │ 100000000 │ 618.565 │ 3.01714 │ 6.04355 │; └─────────────┴─────────┴─────────┴─────────┘; ```. ```; Lagrangian particle tracking relative performance (CPU); ┌───────────────┬─────────────┬──────────┬─────────┬─────────┐; │ Architectures │ N_particles │ slowdown │ memory │ allocs │; ├───────────────┼─────────────┼──────────┼─────────┼─────────┤; │ CPU │ 0 │ 1.0 │ 1.0 │ 1.0 │; │ CPU │ 1 │ 1.03447 │ 1.01267 │ 1.01599 │; │ CPU │ 10 │ 1.04601 │ 1.01267 │ 1.01599 │; │ CPU │ 100 │ 1.04712 │ 1.01267 │ 1.01599 │; │ CPU │ 1000 │ 1.05514 │ 1.01267 │ 1.01599 │; │ CPU │ 10000 │ 1.05397 │ 1.01267 │ 1.01599 │; │ CPU │ 100000 │ 1.07213 │ 1.01267 │ 1.01599 │; │ CPU │ 1000000 │ 1.34006 │ 1.01267 │ 1.01599 │; │ CPU │ 10000000 │ 4.09045 │ 1.01267 │ 1.01599 │; │ CPU │ 100000000 │ 31.6534 │ 1.01267 │ 1.01599 │; └───────────────┴─────────────┴──────────┴─────────┴─────────┘; ```. ```; Lagrangian particle tracking relative performance (GPU); ┌───────────────┬─────────────┬──────────┬─────────┬─────────┐; │ Architectures │ N_particles │ slowdown │ memory │ allocs │; ├───────────────┼─────────────┼──────────┼─────────┼─────────┤; │ GPU │ 0 │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ 1 │ 1.02262 │ 1.01395 │ 1.0135 │; │ GPU │ 10 │ 1.02786 │ 1.01314 │ 1.00947 │; │ GPU │ 100 │ 1.02347 │ 1.01314 │ 1.00947 │; │ GPU │ 1000 │ 1.02548 │ 1.01395 │ 1.0135 │; │ GPU │ 10000 │ 1.0309 │ 1.01314 │ 1.00947 │; │ GPU │ 100000 │ 1.02327 │ 1.01314 │ 1.00947 │; │ GPU │ 1000000 │ 1.03536 │ 1.01395 │ 1.0135 │; │ GPU │ 10000000 │ 1.31966 │ 1.01391 │ 1.01332 │; │ GPU │ 100000000 │ 4.20799 │ 1.01317 │ 1.00964 │; └───────────────┴─────────────┴──────────┴─────────┴─────────┘; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732529975:4831,perform,performance,4831,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732529975,1,['perform'],['performance']
Performance,"✓ PrettyTables; ✓ GPUCompiler; ✓ DataFrames; ✗ CUDA; 61 dependencies successfully precompiled in 190 seconds. 5 already precompiled. The following 1 direct dependency failed to precompile:. CUDA [052768ef-5323-5732-b1bb-66c8b64840ba]. Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_UQIv2i"".; [45592] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:25; Allocations: 2907 (Pool: 2898; Big: 9); GC: ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_CUC33l"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Bas",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:5319,load,loading,5319,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,1,['load'],['loading']
Safety," ; > > ; > > But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us).; > ; > I agree. If we try using whatever closure here that is used in the hydrostatic model, I would think that it should yield a similar result. But that's maybe better saved for a future PR?. Let me clarify. We've never run the hydrostatic model with a single layer on the sphere, but this is a good idea. Most of our runs have been with 50 vertical levels. In the 3D configuration with 50 vertical levels, we smooth results with 1) WENO5 vector invariant advection and 2) biharmonic ""divergence damping"" of the divergence component of the flow. If we are going to compare the shallow water on a sphere to they hydrostatic model, we will have to produce additional runs with just 1 vertical level. In other words, there are no results to compare with right now. When we perform additional runs, we may choose to include divergence damping, or another kind of closure, if we want to. The results presented in #2317 also use a single layer hydrostatic model, and these did not require any explicit dissipation. Therefore, there is reason to believe that divergence damping is only required for 3D simulations. An additional point is that in the shallow water equations we can introduce a WENO reconstruction of the mass flux. This reconstruction may provide divergence damping (whether or not we need it!). In summary, if we would like to perform a comparison, we can choose to either 1) produce a comparison between the shallow water model and one layer hydrostatic model with no explicit closure on the sphere or 2) run new 1 layer hydrostatic simulations with some closure (of our choosing) and then _also_ implement that closure in the shallow water model. My opinion is that with these nice WENO5 numerics there may not be a need for using explicit dissipation right now, so we might as well do the easy thing and avoid it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226:2104,avoid,avoid,2104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226,2,['avoid'],['avoid']
Safety," It's only an opinion piece, so obviously not the objective truth, but I quite agree with it. This passage stuck with me:. > Sometimes the quest for better simulations subordinates even simple physics. About 20 years ago I pointed out that most models of that era neglected to turn dissipated kinetic energy back into heat. For most atmospheric phenomena, this is indeed a small term in the thermodynamic energy budget (though technically required to close any net energy budget), but in strong windstorms like hurricanes, it becomes important. Moreover, no substantial computational benefit accrues from neglecting it. A few weeks later, a researcher came to me to report that he had added this term to his model and found that it made simulated hurricanes too intense, so he took it out again. [...] For this researcher, getting the “right answer” was the goal, even if it is obtained for the wrong reasons. Still today, the conversion of dissipated kinetic energy back into heat remains an optional switch (whose default position is “off”) in a state‐of‐the‐art hurricane prediction model. I'm definitely not accusing anyone of doing this here! But I just wanted to explain a bit where I'm coming from. That said, I agree with @glwagner that maybe we should focus on the more pressing issues at hand:. - 1 - Should Oceananigans keep adding the molecular viscosity as a background to the eddy viscosity? My vote is yes since it's more inline with the physics, which are additive, and we don't gain significant computational efficiency from neglecting it. But that's just my vote. (I also like calling it `ν_total`, as it is unambiguous.); - 2 - What should we do about the numerical implementation docs being out of sync with both the physics docs and the code? I'm happy to change the docs myself, but I think we haven't converged on how to do that yet. I'm okay with nuking one of the docs sections. I don't see why two separate sections are needed and the [physics / turbulence closures](https://",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775361802:1733,predict,prediction,1733,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775361802,2,['predict'],['prediction']
Safety," Random.seed!(rng, 1414); Ξ(z) = randn(rng) * z / model.grid.Lz * (1 + z / model.grid.Lz) ; Tᵢ(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Ξ(z); uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-3 * Ξ(z); set!(model, u=uᵢ, w=uᵢ, T=Tᵢ, S=35); ```. You can try replacing these lines with something like. ```julia; Random.seed!(1414). T = model.tracers.T; u, v, w = model.velocities. x, y, z = nodes(T, reshape=true); Lz = model.grid.Lz. shape = @. z / Lz * (1 + z / Lz); ΞT = randn(size(T)...) *. shape; Ξu = randn(size(u)...) *. shape; Ξw = randn(size(w)...) *. shape. Tᵢ = @. 20 + dTdz * z + dTdz * Lz * 1e-6 * ΞT; uᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξu; wᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξw. set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=35); ```. I'd be curious to know if this works. Here are a few more tips and best practices for raising issues here:. * Please reduce your code to minimum working examples. The script that was linked contains a lot of extraneous code (including comments copy/pasted from an example) that is irrelevant to the issue we are discussing. Reducing your code to a minimum example is kind to the community and will help people answer your questions faster. * If you can, avoid linking to code and instead paste your code directly into the issue. * Use [github's markdown formatting](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) (such as triple backticks, ""```"") to format code and julia prompt instructions. * Finally, I strongly recommend using environments to manage the Oceananigans version (though I don't think this is intrinsic to the issue, it will help us rule out a lot of possible issues if we can focus on one Oceananigans version). We have written some tips in our wiki: https://github.com/CliMA/Oceananigans.jl/wiki/Productive-Oceananigans-workflows-and-Julia-environments which includes a link to the official Julia documentation. * Sounds like LESbrary.jl needs to be updated!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1267909092:1853,avoid,avoid,1853,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1267909092,1,['avoid'],['avoid']
Safety," a similar option could be given to FPlane, avoiding confusion. Ah, the issue is that abstract types cannot have properties --- they can only be used to organize type parameters and dispatch.; The logic and motivation of your suggestion is sound though (avoiding code duplication through good design); we just have to come up with a different solution. A similar solution could perhaps design a more hierarchical interface to `IncompressibleModel.buoyancy`. For example, we might write. ```julia; struct Buoyancy{G, B}; gravitational_direction :: G; model :: B; end; ```. The existing subtypes of `AbstractBuoyancy` are used for `Buoyancy.model`. The user API could be. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9), model=BuoyancyTracer()); ```. or. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9),; model=SeawaterBuoyancy(gravitational_acceleration=9.81, equation_of_state=LinearEquationOfState(α=2e-4, β=8e-5))); ```. This is more verbose but could avoid some of the issues that @tomchor sees. As for `Plane` and `BetaPlane`, I agree that those models are really predicated on a thin aspect ratio assumption that has to do with gravitational accelerations, and therefore ""know"" about the direction of gravity. We could either add a property `gravitational_direction` or, perhaps, add some wrapper / helper functions for constructing coriolis forces in tilted domains (eg `coriolis = TiltedCoriolisForces(FPlane(f=1e-4), vertical_direction=(0.1, 0.0, 0.9))` which returns `GeneralCoriolis` with 3D Coriolis forces --- or something). I think we will start to run into these sorts of issues more generically, where we need to specify ""global"" parameters that impact multiple model components at the same time. This has cropped up in `HydrostaticFreeSurfaceModel` where `gravitational_acceleration` can be specified separately in the buoyancy model and the free surface model. Dealing with global physical parameters is the purpose of the [`CLIMAParameters`](",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047:1285,avoid,avoid,1285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047,1,['avoid'],['avoid']
Safety," have met some strange things in a simple channel flow case, the velocity profile is larger than the log-low profile, and the momentum flux of the second and third points are obviously lower than bottom boundary condition (or other point near the bottom boundary). The code is written below, what causes this difference? ![u_profile (2)](https://user-images.githubusercontent.com/117068415/255586911-14e2c865-ec3b-4065-a13a-213a99257d31.png) ![uw_flux (1)](https://user-images.githubusercontent.com/117068415/255630762-1cd16836-6f59-465b-8d02-0577052b52ba.png); > ; > ```julia; > const H=15 #/m; > grid = RectilinearGrid(GPU(),size=(64,64,64), extent=(π*H, π*H, H)); > const u★=0.01 #friction velocity; > Fx(x,y,z,t)=u★^2/H #forcing; > ; > const z₀ = H*1e-4 # m (roughness length); > const κ = 0.4 # von Karman constant; > const z₁ = -1*znodes(Center,grid)[grid.Nz] # Closest grid center to the bottom; > const cᴰᵇ = (κ / log(z₁ / z₀))^2 # Drag coefficient; > ; > @inline drag_u(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (u); > @inline drag_v(x, y, t, u, v, p) = - p.cᴰᵇ * √(u^2 + v^2) * (v); > ; > drag_bc_u = FluxBoundaryCondition(drag_u, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)); > drag_bc_v = FluxBoundaryCondition(drag_v, field_dependencies=(:u, :v), parameters=(; cᴰᵇ)); > ; > u_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(0.0),bottom = drag_bc_u); > v_bcs = FieldBoundaryConditions(bottom = drag_bc_v); > ; > model = NonhydrostaticModel(; grid, coriolis,; > advection = WENO(),; > timestepper = :RungeKutta3,; > tracers =(:T,:S),; > buoyancy = SeawaterBuoyancy(),; > closure = AnisotropicMinimumDissipation(),; > boundary_conditions = (u=u_bcs,v=v_bcs,T=T_bcs,S=S_bcs),; > forcing=(u=Fx,)); > ```. I also have the same problem here. I am trying to simulate the neutral turbulent boundary layer here. However, I found that the velocity shear at the first grid points is much larger than that predicted by the Monin-Obukhov similarity theory. Any ideas? @glwagner @tomchor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649204834:1932,predict,predicted,1932,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1649204834,2,['predict'],['predicted']
Safety," you will see two plots of the rates of convergence rusing schemes that exist in Oceananigans. . This plot uses the solution obtained from Oceananigans directly. The lower order methods produce the correct slopes but the high order methods flatten out because of truncation error. The error I is consistent with single precision accuracy. ; (The slopes in the legend are taken from the plot shown below and are not the slopes of the curves from Oceananigans.) . ![convergence_rates_oceananigans](https://user-images.githubusercontent.com/8239041/103024246-79841700-451d-11eb-8321-454171fa2381.png). This plot is similar but computed using my own time-stepping code but it does use `advective_tracer_flux_x`. In developing this code I was able to ensure that everything is double precision and they give the correct slopes. ![convergence_rates](https://user-images.githubusercontent.com/8239041/103024241-7721bd00-451d-11eb-8717-6437c7c2c577.png). **Good news:** The advection schemes in Oceananigans can produce the correct slopes, as predicted by theory. **Bad news:** Some part of Oceananigans (maybe times-stepping?) must use single precision accuracy, and that truncates the error of the method as a whole. Question: where is the bottleneck that reduces the global spatial accuracy from double to single precision?. This third figure shows the result for increased spatial resolution and we observe that the higher order methods saturate near `1e-16`, as you would expect from double precision. ![convergence_rates](https://user-images.githubusercontent.com/8239041/103028959-c7514d00-4526-11eb-94c6-81fb3d429882.png). In case you are interested, these are the calculations of the rates of convergence for the two sets of calculations. ```; Method = Center2ⁿᵈ, Rate of Convergence = 1.99, Expected = 2; Method = CenteredSecondOrder(), Rate of Convergence = 1.99, Expected = 2; Method = Upwind3ʳᵈ, Rate of Convergence = 2.99, Expected = 3; Method = UpwindBiasedThirdOrder(), Rate of Convergence = 3",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750409595:1040,predict,predicted,1040,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750409595,1,['predict'],['predicted']
Safety,"#1514 is failing so at this point you are using Julia v1.6 ""at your own risk"" :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-813710211:72,risk,risk,72,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-813710211,1,['risk'],['risk']
Safety,". But now I realize that because of the status of the immersed Poisson solver, the velocity along the boundary is divergent, strongly so. So, `div(u')` is large along the boundary. And when we divide by `Δt` we get something huge. The magnitude of `div(u')` also somehow seems to depend on the time step (as does the magnitude of the spurious circulation). The correct solution to this case remains at rest of course. (An aside is that this problem _could_ be avoided by separately computing the hydrostatic pressure, and then using a special horizontal gradient operators that avoid computing a hydrostatic pressure gradient across an immersed boundary. However, this would only be correct for no-flux boundary conditions on buoyancy on side walls). Anyways, apparently because of this issue with the immersed pressure solver, it seems that `div(u')` is large (because `div(u)` is large) even when `Δt = O(1e-14)`... - As a result of all of this I am confused about whether this MWE is actually reliable for debugging the issue. I guess we should expect to see problems simply when `Δt = O(eps)` because this is when `div(u') / Δt` cannot be reliably computed, I think. This leads to a fairly simple criteria for the time step that's compatible with the pressure correction. But as noted in this PR, this is not enough to fix issues with the immersed boundary MWE... but whether or not that is because of problems with the setup itself, I'm not sure... - All of that said, taking @tomchor suggestion to be more careful in updating the clock for RK3 actually does solve the MWE here. Obviously, this is again addressing the (in principle not entirely solvable) issue of error accumulation in `clock.time`, rather than addressing the other issue with very small time-steps producing an ill-posed pressure correction. I think we should fix RK3 separately, basically because we cannot completely avoid accumulating error in `clock.time`, every little thing we do to make it more accurate is a good idea.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153020136:2644,avoid,avoid,2644,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153020136,2,['avoid'],['avoid']
Safety,.2; [21216c6a] + Preferences v1.4.0; [49802e3a] + ProgressBars v1.5.0; [94ee1d12] + Quaternions v0.7.4; [74087812] + Random123 v1.6.1; [e6cf234a] + RandomNumbers v1.5.3; [c1ae055f] + RealDot v0.1.0; [3cdcf5f2] + RecipesBase v1.3.4; [189a3867] + Reexport v1.2.2; [ae029012] + Requires v1.3.0; [6038ab10] + Rotations v1.5.1; [6c6a2e73] + Scratch v1.2.0; [d496a93d] + SeawaterPolynomials v0.3.2; [66db9d55] + SnoopPrecompile v1.0.3; [276daf66] + SpecialFunctions v2.3.0; [aedffcd0] + Static v0.8.7; [0d7ed370] + StaticArrayInterface v1.4.0; [90137ffa] + StaticArrays v1.6.1; [1e83bf80] + StaticArraysCore v1.4.1; [15972242] + StaticPermutations v0.3.0; [5e0ebb24] + Strided v2.0.1; [4db3bf67] + StridedViews v0.1.2; [09ab397b] + StructArrays v0.6.15; [856f2bd8] + StructTypes v1.10.0; [3783bdb8] + TableTraits v1.0.1; [bd369af6] + Tables v1.10.1; [6aa5eb33] + TaylorSeries v0.15.2; [a759f4b9] + TimerOutputs v0.5.23; [3bb67fe8] + TranscodingStreams v0.9.13; [9d95972d] + TupleTools v1.3.0; [013be700] + UnsafeAtomics v0.2.1; [d80eeb9a] + UnsafeAtomicsLLVM v0.1.3; [81def892] + VersionParsing v1.3.0; [6e34b625] + Bzip2_jll v1.0.8+0; [4ee394cb] + CUDA_Driver_jll v0.5.0+1; [76a88914] + CUDA_Runtime_jll v0.6.0+0; [f5851436] + FFTW_jll v3.3.10+0; [0234f1f7] + HDF5_jll v1.14.0+0; [1d5cc7b8] + IntelOpenMP_jll v2023.1.0+0; [dad2f222] + LLVMExtra_jll v0.0.23+0; [1d63c593] + LLVMOpenMP_jll v15.0.4+0; [94ce4f54] + Libiconv_jll v1.16.1+2; [856f044c] + MKL_jll v2023.1.0+0; [7cb0a576] + MPICH_jll v4.1.2+0; [f1f71cc9] + MPItrampoline_jll v5.3.1+0; [9237b28f] + MicrosoftMPI_jll v10.1.3+4; [7243133f] + NetCDF_jll v400.902.208+0; [fe0851c0] + OpenMPI_jll v4.1.5+0; [458c3c95] + OpenSSL_jll v3.0.9+0; [efe28fd5] + OpenSpecFun_jll v0.5.5+0; [02c8fc9c] + XML2_jll v2.10.3+0; [3161d3a3] + Zstd_jll v1.5.5+0; [477f73a3] + libaec_jll v1.0.6+1; [0dad84c5] + ArgTools v1.1.1; [56f22d72] + Artifacts; [2a0f44e3] + Base64; [ade2ca70] + Dates; [8ba89e20] + Distributed; [f43a241f] + Downloads v1.6.0; [7b1f6079] + FileWatc,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:3648,Unsafe,UnsafeAtomics,3648,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243,1,['Unsafe'],['UnsafeAtomics']
Safety,.3.4; Installed CEnum ─────────────────────── v0.5.0; Installed Random123 ─────────────────── v1.7.0; Installed JuliaNVTXCallbacks_jll ────── v0.2.1+0; Installed InvertedIndices ───────────── v1.3.0; Installed BFloat16s ─────────────────── v0.5.0; Installed Reexport ──────────────────── v1.2.2; Installed CUDA_Runtime_jll ──────────── v0.14.1+0; Installed GPUArrays ─────────────────── v10.2.3; Installed RandomNumbers ─────────────── v1.5.3; Installed DataFrames ────────────────── v1.6.1; Installed DataStructures ────────────── v0.18.20; Installed Compat ────────────────────── v4.15.0; Installed Requires ──────────────────── v1.3.0; Installed ExprTools ─────────────────── v0.1.10; Installed MacroTools ────────────────── v0.5.13; Installed Colors ────────────────────── v0.12.11; Installed KernelAbstractions ────────── v0.9.22; Installed CUDA ──────────────────────── v5.4.3; Installed Missings ──────────────────── v1.2.0; Installed StringManipulation ────────── v0.3.4; Installed UnsafeAtomics ─────────────── v0.2.1; Installed SortingAlgorithms ─────────── v1.2.1; Installed Atomix ────────────────────── v0.1.0; Installed LLVM ──────────────────────── v8.0.0; Precompiling project...; ✓ LLVMLoopInfo; ✓ DataValueInterfaces; ✓ Reexport; ✓ IteratorInterfaceExtensions; ✓ LaTeXStrings; ✓ InvertedIndices; ✓ ExprTools; ✓ DataAPI; ✓ Requires; ✓ CompilerSupportLibraries_jll; ✓ OrderedCollections; ✓ Compat; ✓ AbstractFFTs; ✓ InlineStrings; ✓ Scratch; ✓ CEnum; ✓ StaticArraysCore; ✓ TableTraits; ✓ Missings; ✓ PooledArrays; ✓ BFloat16s; ✓ Preferences. ✓ Adapt; ✓ Statistics; ✓ SentinelArrays; ✓ Compat → CompatLinearAlgebraExt; ✓ Crayons; ✓ UnsafeAtomics; ✓ CUDA_Runtime_Discovery; ✓ PrecompileTools; ✓ JLLWrappers; ✓ Tables; ✓ RandomNumbers; ✓ Atomix; ✓ TimerOutputs; ✓ AbstractFFTs → AbstractFFTsTestExt; ✓ NVTX_jll; ✓ JuliaNVTXCallbacks_jll; ✓ MacroTools; ✓ LLVMExtra_jll; ✓ CUDA_Driver_jll; ✓ Random123; ✓ DataStructures; ✓ StringManipulation; ✓ FixedPointNumbers; ✓ SortingAlgorithms; ✗ CU,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:3068,Unsafe,UnsafeAtomics,3068,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,1,['Unsafe'],['UnsafeAtomics']
Safety,".3.4; Installed NVTX_jll ──────────────────── v3.1.0+2; Installed LLVMExtra_jll ─────────────── v0.0.30+0; Installed LaTeXStrings ──────────────── v1.3.1; Installed OrderedCollections ────────── v1.6.3; Installed NVTX ──────────────────────── v0.3.4; Installed UnsafeAtomicsLLVM ─────────── v0.1.5; Installed CEnum ─────────────────────── v0.5.0; Installed InvertedIndices ───────────── v1.3.0; Installed Reexport ──────────────────── v1.2.2; Installed JuliaNVTXCallbacks_jll ────── v0.2.1+0; Installed BFloat16s ─────────────────── v0.5.0; Installed MacroTools ────────────────── v0.5.13; Installed DataStructures ────────────── v0.18.20; Installed Colors ────────────────────── v0.12.11; Installed KernelAbstractions ────────── v0.9.22; Installed RandomNumbers ─────────────── v1.5.3; Installed Missings ──────────────────── v1.2.0; Installed Compat ────────────────────── v4.15.0; Installed StringManipulation ────────── v0.3.4; Installed SortingAlgorithms ─────────── v1.2.1; Installed UnsafeAtomics ─────────────── v0.2.1; Installed Atomix ────────────────────── v0.1.0; Installed LLVM ──────────────────────── v8.0.0; Installed CUDA ──────────────────────── v5.4.3; Updating `/glade/derecho/scratch/knudsenl/BottomBoundaryLayer/Project.toml`; [052768ef] + CUDA v5.4.3; Updating `/glade/derecho/scratch/knudsenl/BottomBoundaryLayer/Manifest.toml`; ERROR: LoadError: failed process: Process(`/glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/bin/julia -C native -J/glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/lib/julia/sys.so -g1 -O0 --color=no --history-file=no --startup-file=no --project=/glade/derecho/scratch/knudsenl/BottomBoundaryLayer/Project.toml --eval 'append!(empty!(Base.DEPOT_PATH), [""/glade/u/home/knudsenl/.julia"", ""/glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/local/share/julia"", ""/glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia""]); append!(empty!(Base.DL_LOAD_PATH), Str",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2246012900:2904,Unsafe,UnsafeAtomics,2904,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2246012900,1,['Unsafe'],['UnsafeAtomics']
Safety,"00) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 843.428 ms; │ ├── max(u): (2.48e-08, 1.37e-04, 3.09e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 6.17e-06 m; ```. When `IsopycnalSkewSymmetricDiffusivity` is included, however, we find. ```julia; julia> include(""near_global_one_degree.jl""); underlying_grid = LatitudeLongitudeGrid(arch; size = (Nx, Ny, Nz), halo = (4, 4, 4), latitude, z, longitude = (-180, 180), precompute_metrics = true) = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 259.679 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (319.597 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.116 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 1.121 seconds; │ ├── max(u): (1.94e-10, 4.57e-05, 1.03e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.03e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 998.405 ms; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (-16387479425.34, 18491107419.68) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:2611,risk,risk,2611,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518,1,['risk'],['risk']
Safety,"1.32e-16, 5.40e-02, 6.44e-04) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 5.93e-01 m; ┌ Info: Iteration: 2, time: 40 minutes, wall time: 945.169 ms; │ ├── max(u): (1.39e-02, 1.06e-01, 1.05e-03) m s⁻¹; │ ├── extrema(T): (0.05, 30.00) ᵒC; └ └── max|η|: 1.33e+00 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 1 hour, wall time: 945.031 ms; │ ├── max(u): (3.55e-02, 1.52e-01, 1.37e-03) m s⁻¹; │ ├── extrema(T): (0.15, 30.00) ᵒC; └ └── max|η|: 2.08e+00 m; ```. But when they're put back, it still blows up (even with coefficients 1e-9):. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = ImmersedBoundaryGrid on:; architecture: CPU(); grid: 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; with immersed: GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 256.442 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (317.156 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.252 seconds).; ┌ Info: Iteration: 1, time: 20 minutes, wall time: 1.258 seconds; │ ├── max(u): (7.36e-02, 5.18e-02, 7.93e-04) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 3.73e-01 m; ┌ Info: Iteration: 2, time: 40 minutes, wall time: 1.003 seconds; │ ├── max(u): (2.83e-01, 1.13e-01, 1.65e-03) m s⁻¹; │ ├── extrema(T): (-6.76, 50.82) ᵒC; └ └── max|η|: 8.05e-01 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iter",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807:2232,risk,risk,2232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807,1,['risk'],['risk']
Safety,23 v1.7.0; [e6cf234a] RandomNumbers v1.5.3; [c1ae055f] RealDot v0.1.0; [3cdcf5f2] RecipesBase v1.3.4; [189a3867] Reexport v1.2.2; [ae029012] Requires v1.3.0; [6038ab10] Rotations v1.7.1; [6c6a2e73] Scratch v1.2.1; [d496a93d] SeawaterPolynomials v0.3.4; [91c51154] SentinelArrays v1.4.5; [a2af1166] SortingAlgorithms v1.2.1; [276daf66] SpecialFunctions v2.4.0; ⌅ [aedffcd0] Static v0.8.9; [0d7ed370] StaticArrayInterface v1.5.1; [90137ffa] StaticArrays v1.9.7; [1e83bf80] StaticArraysCore v1.4.3; [15972242] StaticPermutations v0.3.0; [82ae8749] StatsAPI v1.7.0; [5e0ebb24] Strided v2.1.0; [4db3bf67] StridedViews v0.3.1; [892a3eda] StringManipulation v0.3.4; [09ab397b] StructArrays v0.6.18; [856f2bd8] StructTypes v1.10.0; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.12.0; ⌅ [6aa5eb33] TaylorSeries v0.16.0; [a759f4b9] TimerOutputs v0.5.24; [3bb67fe8] TranscodingStreams v0.11.0; [24ddb15e] TransmuteDims v0.1.16; [9d95972d] TupleTools v1.5.0; [013be700] UnsafeAtomics v0.2.1; [d80eeb9a] UnsafeAtomicsLLVM v0.1.5; [81def892] VersionParsing v1.3.0; [0b7ba130] Blosc_jll v1.21.5+0; [6e34b625] Bzip2_jll v1.0.8+1; [4ee394cb] CUDA_Driver_jll v0.9.1+1; [76a88914] CUDA_Runtime_jll v0.14.1+0; [f5851436] FFTW_jll v3.3.10+0; [0951126a] GnuTLS_jll v3.8.4+0; ⌃ [0234f1f7] HDF5_jll v1.14.2+1; [e33a78d0] Hwloc_jll v2.11.0+0; [1d5cc7b8] IntelOpenMP_jll v2024.2.0+0; [9c1d0b0a] JuliaNVTXCallbacks_jll v0.2.1+0; [dad2f222] LLVMExtra_jll v0.0.30+0; [1d63c593] LLVMOpenMP_jll v15.0.7+0; [94ce4f54] Libiconv_jll v1.17.0+0; [5ced341a] Lz4_jll v1.9.4+0; [856f044c] MKL_jll v2024.2.0+0; [7cb0a576] MPICH_jll v4.2.1+1; [f1f71cc9] MPItrampoline_jll v5.4.0+0; [9237b28f] MicrosoftMPI_jll v10.1.4+2; [e98f9f5b] NVTX_jll v3.1.0+2; ⌃ [7243133f] NetCDF_jll v400.902.209+0; ⌅ [4c82536e] Nettle_jll v3.7.2+0; [fe0851c0] OpenMPI_jll v5.0.3+0; [458c3c95] OpenSSL_jll v3.0.14+0; [efe28fd5] OpenSpecFun_jll v0.5.5+0; [c2071276] P11Kit_jll v0.24.1+0; [02c8fc9c] XML2_jll v2.13.1+0; [ffd25f8a] XZ_jll v5.4.6+0; [3161d3a3] Zstd,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:19247,Unsafe,UnsafeAtomicsLLVM,19247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['Unsafe'],['UnsafeAtomicsLLVM']
Safety,"6d7b675f75dd867b9f153685""; ---; > project_hash = ""bfbc7775b0a550569ac26abdec5f544ef80e881c""; 23c23; < git-tree-sha1 = ""76289dc51920fdc6e0013c872ba9551d54961c24""; ---; > git-tree-sha1 = ""02f731463748db57cc2ebfbd9fbc9ce8280d3433""; 25c25; < version = ""3.6.2""; ---; > version = ""3.7.1""; 37c37; < git-tree-sha1 = ""f83ec24f76d4c8f525099b2ac475fc098138ec31""; ---; > git-tree-sha1 = ""16267cf279190ca7c1b30d020758ced95db89cd0""; 39c39; < version = ""7.4.11""; ---; > version = ""7.5.1""; 93,94c93,94; < deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; < git-tree-sha1 = ""f062a48c26ae027f70c44f48f244862aec47bf99""; ---; > deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LLVMLoopInfo"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; > git-tree-sha1 = ""64461b0e9df3069248979113ce8ab6d11bd371cf""; 96,97c96; < version = ""5.0.0""; < weakdeps = [""SpecialFunctions""]; ---; > version = ""5.1.0""; 99a99; > ChainRulesCoreExt = ""ChainRulesCore""; 101a102,105; > [deps.CUDA.weakdeps]; > ChainRulesCore = ""d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4""; > SpecialFunctions = ""276daf66-3868-5448-9aa4-cd146d93841b""; >; 104c108; < git-tree-sha1 = ""35a37bb72b35964f2895c12c687ae263b4ac170c""; ---; > git-tree-sha1 = ""1e42ef1bdb45487ff28de16182c0df4920181dc3""; 106c110; < version = ""0.6.0+3""; ---; > version = ""0.7.0+0""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:3425,Unsafe,UnsafeAtomicsLLVM,3425,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361,2,['Unsafe'],['UnsafeAtomicsLLVM']
Safety,"7208cd3bc5d29631a26bc0cff78902""; uuid = ""21216c6a-2e73-6563-6e65-726566657250""; version = ""1.2.1"". [[Printf]]; deps = [""Unicode""]; uuid = ""de0858da-6303-5e67-8744-51eddeeeb8d7"". [[REPL]]; deps = [""InteractiveUtils"", ""Markdown"", ""Sockets""]; uuid = ""3fa0cd96-eef1-5676-8a61-b3b8758bbffb"". [[Random]]; deps = [""Serialization""]; uuid = ""9a3f8284-a2c9-5f02-9a11-845980a1fd5c"". [[Reexport]]; git-tree-sha1 = ""57d8440b0c7d98fc4f889e478e80f268d534c9d5""; uuid = ""189a3867-3050-52da-a836-e630ba90ab69""; version = ""1.0.0"". [[Requires]]; deps = [""UUIDs""]; git-tree-sha1 = ""4036a3bd08ac7e968e27c203d45f5fff15020621""; uuid = ""ae029012-a4dd-5104-9daa-d747884805df""; version = ""1.1.3"". [[Rotations]]; deps = [""LinearAlgebra"", ""StaticArrays"", ""Statistics""]; git-tree-sha1 = ""2ed8d8a16d703f900168822d83699b8c3c1a5cd8""; uuid = ""6038ab10-8711-5258-84ad-4b1120ba62dc""; version = ""1.0.2"". [[SHA]]; uuid = ""ea8e919c-243c-51af-8825-aaa63cd721ce"". [[SafeTestsets]]; deps = [""Test""]; git-tree-sha1 = ""36ebc5622c82eb9324005cc75e7e2cc51181d181""; uuid = ""1bc83da4-3b8d-516f-aca4-4fe02f6d838f""; version = ""0.0.1"". [[Scratch]]; deps = [""Dates""]; git-tree-sha1 = ""ad4b278adb62d185bbcb6864dc24959ab0627bf6""; uuid = ""6c6a2e73-6563-6170-7368-637461726353""; version = ""1.0.3"". [[SeawaterPolynomials]]; deps = [""Test""]; git-tree-sha1 = ""6db1b6004791962cb12d425cd12691506ad7d2b6""; uuid = ""d496a93d-167e-4197-9f49-d3af4ff8fe40""; version = ""0.2.0"". [[Serialization]]; uuid = ""9e88b42a-f829-5b0c-bbe9-9e923198166b"". [[SharedArrays]]; deps = [""Distributed"", ""Mmap"", ""Random"", ""Serialization""]; uuid = ""1a1011a3-84de-559e-8e89-a11a2f7dc383"". [[Sockets]]; uuid = ""6462fe0b-24de-5631-8697-dd941f90decc"". [[SparseArrays]]; deps = [""LinearAlgebra"", ""Random""]; uuid = ""2f01184e-e22b-5df5-ae63-d93ebab69eaf"". [[SpecialFunctions]]; deps = [""ChainRulesCore"", ""OpenSpecFun_jll""]; git-tree-sha1 = ""5919936c0e92cff40e57d0ddf0ceb667d42e5902""; uuid = ""276daf66-3868-5448-9aa4-cd146d93841b""; version = ""1.3.0"". [[Static]]; deps = [""IfElse""]; git-tree-sha1 =",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:14304,Safe,SafeTestsets,14304,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Safe'],['SafeTestsets']
Safety,"8_S31_S8_IS9_Li3ES10_IS9_Li3ELi1EEES9_S32_S33_S11_IS9_S12_S12_S13_S9_S9_S8_IS9_Li1ES10_IS9_Li1ELi1EEES8_IS9_Li1ES14_IS9_S15_IS9_ES15_IS9_ES16_EES8_IS9_Li1ES14_IS9_S15_IS9_ES15_IS9_ES16_EES8_IS9_Li1ES10_IS9_Li1ELi1EEEvES9_ES30_IS28_S28_S28_S31_S8_IS9_Li3ES10_IS9_Li3ELi1EEES9_S34_S35_S11_IS9_S12_S12_S13_S9_S9_S8_IS9_Li1ES10_IS9_Li1ELi1EEES8_IS9_Li1ES14_IS9_S15_IS9_ES15_IS9_ES16_EES8_IS9_Li1ES14_IS9_S15_IS9_ES15_IS9_ES16_EES8_IS9_Li1ES10_IS9_Li1ELi1EEEvES9_EEEEES23_I46__u___v___w___b____1____2____3____4____5____6_S18_I15DiscreteForcingIS23_I13______u______S18_IS16_S16_S9_EE9_sponge_uES37_IS23_I13______u______S18_IS16_S16_S9_EE9_sponge_vES37_IS23_I13______u______S18_IS16_S16_S9_EE9_sponge_wES37_IS23_I13______u______S18_IS16_S16_S9_EE9_sponge_bE12_zeroforcingS42_S42_S42_S42_S42_EES8_IS9_Li3ES10_IS9_Li3ELi1EEES23_I27__time___iteration___stage_S18_IS9_S16_S16_EE' uses too much parameter space (0x1a10 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /glade/scratch/tomasc/jl_XSJ4P4z47a.ptx; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] cufunction_compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/src/compiler/execution.jl:428; [3] #224; @ /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/src/compiler/execution.jl:347 [inlined]; [4] JuliaContext(f::CUDA.var""#224#225""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{typeof(Cassette.overdub), Tuple{Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#312"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gu!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(8, 8, 6)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401133112:5042,abort,aborted,5042,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401133112,1,['abort'],['aborted']
Safety,"9_Li3ES10_IS9_Li3ELi1EEE10_identity1S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S25_S26_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES27_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S29_S18_S25_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES26_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S27_S29_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S31_S31_S13_S16_IS12_S31_S31_S28_S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S26_S27_S29_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEEES14_IS18_S25_S26_7__xz___7__yz___ES19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEE' uses too much parameter space (0x1408 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. We haven't discussed the problem with `AveragedField` on this thread. I think we need a new issue for that (can't remember if there already is one). It actually looks like some, but not all of the issue there have been solved. A minimal example is:. ```julia; julia> U = AveragedField(u, dims=(1, 2)); AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (1, 1, 3); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); ├── dims: (1, 2); ├── operand: Field located at (Face, Center, Center); └── status: time=0.0. julia> compute!(ComputedField(u - U)). julia> compute!(ComputedField((u - U)^2)). julia> V = AveragedField(v, dims=(1, 2)); AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Center, Face, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872338:4135,abort,aborted,4135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-821872338,1,['abort'],['aborted']
Safety,"; Installed Missings ──────────────────── v1.2.0; Installed StringManipulation ────────── v0.3.4; Installed UnsafeAtomics ─────────────── v0.2.1; Installed SortingAlgorithms ─────────── v1.2.1; Installed Atomix ────────────────────── v0.1.0; Installed LLVM ──────────────────────── v8.0.0; Precompiling project...; ✓ LLVMLoopInfo; ✓ DataValueInterfaces; ✓ Reexport; ✓ IteratorInterfaceExtensions; ✓ LaTeXStrings; ✓ InvertedIndices; ✓ ExprTools; ✓ DataAPI; ✓ Requires; ✓ CompilerSupportLibraries_jll; ✓ OrderedCollections; ✓ Compat; ✓ AbstractFFTs; ✓ InlineStrings; ✓ Scratch; ✓ CEnum; ✓ StaticArraysCore; ✓ TableTraits; ✓ Missings; ✓ PooledArrays; ✓ BFloat16s; ✓ Preferences. ✓ Adapt; ✓ Statistics; ✓ SentinelArrays; ✓ Compat → CompatLinearAlgebraExt; ✓ Crayons; ✓ UnsafeAtomics; ✓ CUDA_Runtime_Discovery; ✓ PrecompileTools; ✓ JLLWrappers; ✓ Tables; ✓ RandomNumbers; ✓ Atomix; ✓ TimerOutputs; ✓ AbstractFFTs → AbstractFFTsTestExt; ✓ NVTX_jll; ✓ JuliaNVTXCallbacks_jll; ✓ MacroTools; ✓ LLVMExtra_jll; ✓ CUDA_Driver_jll; ✓ Random123; ✓ DataStructures; ✓ StringManipulation; ✓ FixedPointNumbers; ✓ SortingAlgorithms; ✗ CUDA_Runtime_jll; ✓ ColorTypes; ✓ LLVM; ✓ LLVM → BFloat16sExt; ✓ StaticArrays; ✓ Adapt → AdaptStaticArraysExt; ✓ StaticArrays → StaticArraysStatisticsExt; ✓ UnsafeAtomicsLLVM; ✓ Colors; ✓ GPUArraysCore; ✓ NVTX. ✓ GPUArrays; ✓ KernelAbstractions; ✓ PrettyTables; ✓ GPUCompiler; ✓ DataFrames; ✗ CUDA; 61 dependencies successfully precompiled in 190 seconds. 5 already precompiled. The following 1 direct dependency failed to precompile:. CUDA [052768ef-5323-5732-b1bb-66c8b64840ba]. Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_UQIv2i"".; [45592] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:25; Allocations: 2907 (Pool: 2898; Big: 9); GC: ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:3725,Unsafe,UnsafeAtomics,3725,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,2,['Unsafe'],"['UnsafeAtomics', 'UnsafeAtomicsLLVM']"
Safety,"> * Should we look for other places in the code that do that? Seems like a pretty easy ""mistake"" to make. I agree we should probably always exponentiate with `Int32` since I can't think of a reason to exponentiate with a number bigger than 2^32 for a fluid dynamics calculation... Perhaps we should help users too by converting `Int64` to `Int32` in diagnostics calculations. We can do this via `AbstractOperations`. We should be careful not to add too many surprising under-the-hood transformations, but this one seems fairly safe, since exponentiation by numbers larger than 2^32 seems very unlikely. We may find that `CUDA.jl` has a better solution in the pipeline though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869782247:527,safe,safe,527,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869782247,1,['safe'],['safe']
Safety,"> 1. Modify the CG method to make it numerically stably for positive semi-definite matrices. Right, although I am not sure that this is done correctly in this PR. There may be more work to do... > My method belongs to the second category. I create a new matrix. > $$\tilde{A} = A + cv_0v_0^\dagger$$. > where $c$ is a positive real number and $v_0$ is the basis of the null space of $A$. I was a bit confused about the motivation for defining a new matrix, but with some help from @amontoison I feel I understand this better. The basic idea applies to any semi-definite system; the idea is to ""shift"" an operator by the identity:. $$ \tilde A = A + \epsilon I $$. Where $\epsilon$ is a constant. The key to this method is the smallness of $\epsilon$. Note that we are solving a different system: if the original system is $A x = b$, then the new system is. $$ \left (A + \epsilon I \right ) y = b $$. We do not automatically have $y=x$ or even $y \approx x$. However, we may have $y \approx x$ when $\epsilon$ is smaller than the tolerance of the underlying CG algorithm, for example. In addition to making $\epsilon$ small, another strategy to recover $x$ from $y$ is to solve a new system:. $$ A z = b - A y $$. which, we can show, allows us to recover $x$ via $x = y + z$. For the purpose of implementing shifted operators, some methods in Krylov.jl support provision of a ""shift"" as an argument to the solver, eg the argument `λ` here: https://jso.dev/Krylov.jl/dev/solvers/sid/#Krylov.symmlq. It'd be easy to support a shift of the Poisson operator, the caveat being that the problem being solved is no longer exact. We could additionally support finding the exact solution through a second CG iteration via the method described above, but this would be a bit more work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2415277183:1145,recover,recover,1145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2415277183,2,['recover'],['recover']
Safety,"> 1. Should I have to open an Interactive session by typing julia --project?. This should work. I just wanted to give you commands that would work at the terminal. > Purpose of creating a separate environment? what I understood is that a particular environment will restrict to a particular version. Does it even I mistakenly update it inside that environment?. The purpose of creating a new environment is to carefully control the package versions that are used when you compile and run Oceananigans code. This is good practice regardless of whether bugs like this exist, because you can ensure that you always run the same code with the same release version of Oceananigans. You should update packages in your environment _carefully and deliberately_ --- because updating packages can (and certainly will, given you are working for enough time) break your scripts. Even better, you make it easier for others to run your code, because they can swiftly install and build the environment needed to run your code with a few commands (after you give them your `Project.toml` and `Manifest.toml`). I'm not sure what went wrong for you! There are only a few possibilities though: 1) the Manifest was added to the wrong folder (?); 2) the Manifest was ""accidentally"" updated somehow, either by calling `Pkg.update()` or by adding a package to the environment that required packages to update. I'm not sure. Oceananigans 0.56.0 does not require any packages in the Manifest to be updated, so we can add it safely without updating anything. PS this is an unfortunately tricky solution. A better solution would be isolate the package that's causing the problem and explicitly add it to Project.toml and pin its version to one we know is safe. But since we don't know what the problem package is yet, we can't do that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827293556:1499,safe,safely,1499,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827293556,2,['safe'],"['safe', 'safely']"
Safety,> :/. Only if that will make your life simpler though. :) Just a suggestion so you avoid waiting for ever to see if the test actually fail.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1784#issuecomment-870915738:83,avoid,avoid,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1784#issuecomment-870915738,2,['avoid'],['avoid']
Safety,"> > :/; > ; > Only if that will make your life simpler though. :) Just a suggestion so you avoid waiting for ever to see if the test actually fail. I'm drinking coffee, but some might describe that as ""waiting""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1784#issuecomment-870928976:91,avoid,avoid,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1784#issuecomment-870928976,2,['avoid'],['avoid']
Safety,> > @iuryt do you want to help set up a validation case for this feature?; > ; > Yep. I will be working on the NP model with a P sinking velocity this week. Any idea for an experiment that changes MLD with time? Maybe making it 1D for simplicity? But I would like to test for 3D to make sure I am programming it correctly. Maybe buoyancy=nothing and diffuse a tanh-like temp profile? But would be better to have a shallowing mld instead. I think a 2D example with turbulence + reactions + sinking would be neat. Probably best to keep it simple and avoid an MLD calculation. Now I'm thinking maybe just a sinking tracer with a source near the surface would be good.. 🤔,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081819313:548,avoid,avoid,548,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081819313,2,['avoid'],['avoid']
Safety,"> > @tomchor @whitleyv what's the ultimate vision for this PR; > ; > I think we just want to add a more ""precise"" drag option to IB by using the `conditional_flux` functions, so that a drag can be added at the exact locations that need it for the grid fitted version, while also avoiding the user having to call the correct conditional for each location. (For context, when adding drag to IB I have been just adding drag as a forcing over a cell-width above the boundary. For sure! A forcing function could serve as a prototype for the new tendency kernel function that I'm proposing, right? That was my original motivation for proposing the forcing function --- because we would be able to re-use that code (eg all the right conditionals, etc) when we went to implement immersed boundary conditions in the source code. The new tendency kernel function that @simone-silvestri and I are suggesting would be identical to such a forcing function. > I think, one of our concerns was the interpolating of field dependencies within a functional form of a boundary condition, and how they would interact with the IB, could it be generalized to any input. That's true we have to take care with interpolation. I think the first question is what user API we'd like to support; then we can generate source code to match.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075661345:279,avoid,avoiding,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075661345,1,['avoid'],['avoiding']
Safety,"> > Can we use types rather than symbols? `ThreeDimensional()`, `Horizontal()`, etc.; > ; > They are converted into types in the constructor `return ScalarDiffusivity{TD, eval(direction)}(FT(ν), κ)` (and are effectively types in the type signature. I personally prefer it this way because it allows to build closures in the API avoiding to have to import additional types...; > ; > But, I don't feel so strongly about it... I can also change it. I think the most important thing is a uniform API that's easy to remember. With a few exceptions (that we will hopefully address eventually) we use types throughout (since for many cases we have to since the types can store data). I think if we have an API that's half types, half symbols it will get hard to remember when we use what... I see your point though re: polluting the namespace if there are very many possibilities. Precedent for a ""symbol based specification"" is in Julia's `Colors.jl`. `Makie.jl` also uses a fair amount of symbols.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1039821816:328,avoid,avoiding,328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1039821816,1,['avoid'],['avoiding']
Safety,"> > Does it have to do with output? Do you know what the time-step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > ; > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there. Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. The pressure source term is the divergence of the predictor velocity divided by time-step. As the time-step vanishes, the divergence of the predictor velocity also vanishes (because the flow has not evolved from its previous, non-divergent solution). We get a situation tending to 0/0. I think there's a few things we could do to solve this. First of all if we take a very small time-step, I think we can actually just re-set the model time rather than taking a time-step. Second I am wondering if we want to implement a time type that has finite resolution (ie there is a smallest time increment one can take). For example, datetimes have a smallest unit (micro or nanoseconds). A non-dimensional or dimensional-agnostic time type could also be designed analogously (eg every time is the multiple of an integer by the fundamental unit). This would eliminate round off error but it's a bit of work and also we have to put some thought into how best to accomplish it. There might also be a simpler solution by adjusting how we increment time. I'm not sure. > Also wouldn't that also affect simulations with `bu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025:942,predict,predictor,942,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025,2,['predict'],['predictor']
Safety,"> > First, if `c` is the concentration of a tracer it should be non-negative. If you are picking it to be a `sine` I might suggest having `1 + sin` just to avoid negative values. That being said, I don't think it's going to have any impact on the results but might be worth trying.; > ; > Fair point; using `1 + sin(x)` as the initial condition would measure leakage since the total ""mass"" is then Lx * Ly. I propose adding another tracer though specifically for that purpose since it's easy. I ran a tracer with initial value of 1 everywhere to look at the concentration leakage. I took the percentage of the difference in the area integrated concentration of the IBM and nonIBM scaled by the initial concentration, ie. `100 x abs(IBM - nonIBM)/ initial`. The results are below. It looks like for a 256 x 256 grid after 200s only about 3 x 10^-5 % of the initial concentration has leaked out, which is pretty good and seems to scale well with refinement!; ![volint_Concentration_leakage](https://user-images.githubusercontent.com/67593861/123316291-b051de80-d4fa-11eb-86e7-4ee969af5703.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867903313:156,avoid,avoid,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867903313,1,['avoid'],['avoid']
Safety,"> > I can create a separate issue to address this, but perhaps more importantly, I don't see the interior velocity `V∞` being added anywhere there except in the BCs. Usually we add it as a background field to avoid inertial oscillations, and indeed it used to be done like that in [older versions of the docs](https://clima.github.io/OceananigansDocumentation/v0.73.8/generated/tilted_bottom_boundary_layer/), but at some point this was changed and I don't really understand why (nor can I pinpoint where).; > > I think it's okay to run the example without adding it as a background field, but then we're solving the problem in a reference frame that's moving with the interior flow and that should be made explicit, and I don't see that explanation there. Personally, I'm in favor of including `V∞` as a background field because it's simpler.; > > CC @hdrake @glwagner who were in #3581; > ; > What's the problem with adding it back?. No problem at all, and in my opinion that's what we should do. I'm just checking with the community first since it might have been removed for some reason I'm not aware of. Are you okay if I add it back?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3813#issuecomment-2388736091:209,avoid,avoid,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3813#issuecomment-2388736091,2,['avoid'],['avoid']
Safety,"> > I think having a default but non-trivial CFL would be surprising and therefore undesirable, even if it's convenient for some users.; > > I was hoping we might be able to deprecate `diffusive_cfl` because it's a big maintenance burden, but let's keep it if its useful.; > ; > I wouldn't setting the `diffusive_cfl` is surprising. After all the diffusive cfl is as much of a necessary condition for convergence as the advective cfl, it just is a limiting-factor less often for oceanic simulations. But I'm okay with keeping the current behavior as well. I certainly don't disagree that it's convenient; the question is more whether the benefit justifies the cost. Users also want a code that's easy to maintain and extend because then they get more features! For constant diffusivities, the CFL constraint can be pre-calculated. For some common closures the calculation is simple, but this is not _generically_ the case for all turbulence closures. It's really only for variable diffusivities that we _need_ a feature for on-the-fly calculation. We could also use something like `diffusive_cfl=nothing` which completely avoids the calculation. Then we can justify supporting a diffusive CFL calculation for selected turbulence closures. That might be a good route (discussion for another issue).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247:1122,avoid,avoids,1122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247,2,['avoid'],['avoids']
Safety,"> > I think that's a fine strategy. We can add a kwarg to `NonhydrostaticModel` called `hydrostatic_pressure_anomaly`. We can set it to `CenterField(grid)` to preserve existing behavior, or set it to `nothing` to avoid the separation. And we should probably make `nothing` default so that triply periodic problems can be done out of the box. Then we don't have to re-do the regression tests either because we preserve existing behavior...; > > I think that's also a less invasive change than this PR because we don't have to change `pressures` to `pressure` everywhere, hmm.; > ; > Agreed.; > ; > > Since you've done most of the legwork I think you have prerogative to open a new PR if you like (and I can help once you do).; > ; > Thanks, but I unfortunately won't have time to dedicate to this for at least a few weeks. So please feel free to start the PR!. Great. I think the PR is nearly finished over at #3574. Give it a look over when you have time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-2088592499:213,avoid,avoid,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-2088592499,1,['avoid'],['avoid']
Safety,"> > I think to preserve the work in this PR, we should add a `Float32` test which will fail if a spurious promotion undermines performance; > ; > Agreed. I'll revisit this PR later to see if I can find where the conversion happens. The test I added only checks to see if we can take a time step. But I should be able to also add a test to ensure no spurious promotion occurred. Ah, that will work as a test if we remove the `convert`. The `convert` is a good sanity check to find where the problem is, but its not a solution since it merely allows the code to run without error --- it doesn't actually allow us to realize the benefits of using `Float32`. Arguably with this it is actually worse to use `Float32`, since the numerics are degraded bbut the perfrmance benefit is not fully realized",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445330720:459,sanity check,sanity check,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445330720,1,['sanity check'],['sanity check']
Safety,"> > I would think that passing a function instead of collect(0:Nz) would probably be cleaner but both can work.; > ; > Yeah I definitely think passing a function is more intuitive and efficient. As long as that's still an option, I'm happy :); > ; > > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Nz), z_stretch=collect(0:Nz)); > > What's nice about this is that you still specify the domain boundaries, as other grids do, and you specify the stretching function separately. This makes it easier to do a stretch in any direction, and #1532 does just that.; > ; > Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like; > ; > ```julia; > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); > ```; > ; > If so then it makes sense to me, but that's a bit redundant, no? (Sorry for the confusion!). First, yes, it will certainly be an option. Second, unfortunately I took this example from one of the tests, hence the strange choice of parameters. Sorry about that. . But yes, x,y,z are dimensional and are the physical bounds of the domain. What you propose is what I should have written down before. That would be how to specify the stretched grid using an array. Otherwise, you could pass a function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813447822:1063,redund,redundant,1063,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813447822,2,['redund'],['redundant']
Safety,"> > I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors.; > ; > That's a good point. Although I think we could avoid creating another page and put that information in the [""Using GPUs""](https://clima.github.io/OceananigansDocumentation/stable/using_gpus/) page, so that things are more condensed. 🤦 there's already Using GPUs of course, silly me...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818368200:284,avoid,avoid,284,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818368200,1,['avoid'],['avoid']
Safety,"> > Now what is remaining to do is a global run on a lat lon grid of a `ShallowWater` ocean!; > ; > We can do that? That would be amazing to see, and so much faster than the hydrostatic model. I'm not sure about _so much_. The only thing avoided is the computation of vertical velocity, right? The differences are not cost per time step (likely very similar), but physics and numerics: the `ShallowWaterModel` has a fully nonlinear, explicit free surface, while the hydrostatic model has an implicit, linear free surface. So the shallow water model is more accurate for non-negligible surface slopes, but much more costly because gravity wave time-scales must be resolved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119176866:238,avoid,avoided,238,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119176866,1,['avoid'],['avoided']
Safety,"> > Second, this is a plot of the solution for the 1D case that starts off with no motion and a Gaussian field for height. This is a nice example of geostrophic adjustment, and can certainly be compared to papers that do such things.; > > ![one_dimensional_shallow_water_x](https://user-images.githubusercontent.com/8239041/101361665-45e29500-386d-11eb-82d8-f440f3b07d80.gif); > > Third, I have done a 2D case and everything looks qualitatively the same, but it is much more diffusive. This is a plot of a slide through the centre that should reproduce the same thing as above, but the amplitudes are much weaker. This is only 64x64 so it's not very high resolution but I should probably change the advection scheme to make it more accurate.; > > ![one_dimensional_shallow_water_2D_x](https://user-images.githubusercontent.com/8239041/101361578-251a3f80-386d-11eb-8e59-8c02e271cfcc.gif); > ; > A sanity check would be to check whether geostrophic balance is satisfied in the center of the domain, e.g., something like the last figure from [this example](https://fourierflows.github.io/FourierFlowsDocumentation/dev/generated/OneDShallowWaterGeostrophicAdjustment/#Geostrophic-balance). Thanks @navidcy for the suggestion. After takling with @glwagner I remembered that radiating waves in 2D decay like 1/r, compared to 1D. That's the reason for the large difference in amplitude. I might try and put together an example showing this in detail. As for geostrophic balance, I will work on computing that usin the center differencing operators since they are pretty straightforward to apply.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1258#issuecomment-740619873:896,sanity check,sanity check,896,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1258#issuecomment-740619873,1,['sanity check'],['sanity check']
Safety,"> > This looks good! I'll approve it now but I'll leave the following suggestions if you think they're helpful:; > > ; > > * Add brief docstrings with a quick example; > > * Change the names from `u` and `v` in the functions to something more general in order to avoid confusion. Maybe `a`, `b` or some greek letters. (I'm assuming that this works for any `Field`s, no?); > ; > I agree. Sorry that seems ""rushed"" but we need this feature for some project. But I will put these as an issue!. That's alright. Thanks for creating https://github.com/CliMA/Oceananigans.jl/issues/1991",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923311897:263,avoid,avoid,263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923311897,1,['avoid'],['avoid']
Safety,"> @Sbozzolo might be able to help because I believe they do something special to avoid round off issues in `ClimaAtmos`. With regards to floating point instabilities due to arithmetic with time and time intervals, ultimately, we will be solving this issue (and others) by moving away from a floating point time in favor of an integer one (e.g., milliseconds from a start date). As a fun fact, if you are using Float32 and keep track of your time in seconds, `t + dt` is going to have numerical error after approximately one year of simulated time (which is not that much).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153112248:81,avoid,avoid,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153112248,1,['avoid'],['avoid']
Safety,"> @glwagner ,; > ; > So then, based on the code snippet given by @johnryantaylor and our discussion, this validation could be adapted to something like:; > ; > ```julia; > lamb = 1 # decay scale for slip velocity in meters; > @inline w(x,y,z,t) = (tanh(max(-z/lamb,0))*tanh(max((z+H)/lamb,0))); > sinking = SlipVelocity(WENO5(), w=w); > ```; > ; > The way the code is, does it accept functions for velocity inputs? Is that something I could do to help you?. You can do this a few ways:. ```julia; # Vertical velocity function; const lamb = # something; const H = # something; @inline w_func(x, y, z) = tanh(max(-z / lamb, 0.0)) * tanh(max((z + H) / lamb, 0.0)). # Field (allocates memory and precalculates w_func); w = ZFaceField(grid); set!(w, w_func); sinking = AdvectiveForcing(w = w). # Function field (avoids allocating memory but calls `w_func` every iteration); w = FunctionField{Center, Center, Face}(w_func, grid); sinking = AdvectiveForcing(w = w); ```. We could also add the feature to `AdvectiveForcing` that, if an input is a function, we assume it's a function of `x, y, z, t` and deal with it appropriately (by wrapping in a `FunctionField` and adding reference to the model `clock`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436:807,avoid,avoids,807,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436,1,['avoid'],['avoids']
Safety,"> @glwagner : I agree that the major savings would be the lack of vertical grid points, but having a full free-surface will likely force a smaller time step because of CFL. There would be two ways to reduce this constraint (in the future).; > ; > 1. Rigid lid (solve for the surface pressure); > 2. Implicit free-surface (treat the free-surface implicitly in the time-stepping); > ; > Both of these would borrow from the hydrostatic model, but the ingrediants are there, and would make it a lot faster. I would vote for implementing a rigid lid / vertically-`Flat` mode for the hydrostatic model instead, in order to keep the shallow water model as simple as possible (generalizing to multiple layers as an alternative direction would be nice I think). Have you benchmarked this? It is true that vertically `Flat` avoids a few vertical operations in the vertical advection term but since the kernel sizes are the same I'd be surprised if the performance differences are huge in terms of cost per time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736:814,avoid,avoids,814,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736,2,['avoid'],['avoids']
Safety,"> @glwagner, how can we avoid `collect`? E.g., at; > ; > https://github.com/CliMA/Oceananigans.jl/blob/d913858aa771f096e8ce48da132749361c8f1647/validation/elliptic_solvers/doubly_bounded_poisson.jl#L130; > ; > I tried `arch_array` but seems like we need to write some more methods for it?; > ; > ```julia; > julia> r_array = arch_array(arch, reshape(interior(r), Nx * Ny * Nz)); > ERROR: MethodError: no method matching arch_array(::CPU, ::Base.ReshapedArray{Float64, 1, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}); > Closest candidates are:; > arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; > arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; > arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; > ...; > Stacktrace:; > [1] top-level scope; > @ REPL[6]:1; > [2] top-level scope; > @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; > ; > julia> r_array = arch_array(arch, interior(r)); > ERROR: MethodError: no method matching arch_array(::CPU, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); > Closest candidates are:; > arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; > arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; > arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; > ...; > Stacktrace:; > [1] top-level scope; > @ REPL[7]:1; > [2] top-level scope; > @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; > ```. Why do you need to convert to architecture? Is it enough to use. ```julia; r_reshaped = reshape(interior(r), Nx * Ny * Nz); ```. ?. If you can't use that then I think y",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1163085492:24,avoid,avoid,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1163085492,1,['avoid'],['avoid']
Safety,> @hennyg888 I think we need line info (not just file) to precisely interpret the profiling results?. If you scroll right in my big block of text you can see a column that shows the line number and function name in the file specified in the file column that's visible without scrolling. Please see the full file attached below. Might be easier to view or reformat than the embedded code block above.; [nonhydrostatic_profile_flat.txt](https://github.com/CliMA/Oceananigans.jl/files/6931920/nonhydrostatic_profile_flat.txt). I tried to avoid flame graphs and go for something as close to percentages as I could so I went with the default output. I'll add in StatProfilerHTML.jl outputs as well since the flame graphs and html files do look very neat. In the very last row there's a total snapshots count of 24177. Dividing the counts shown in the left-most column by this number should give the percentage time spent on this line or in any functions executed by this line.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892703448:535,avoid,avoid,535,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892703448,1,['avoid'],['avoid']
Safety,"> @navidcy Hmmm, digging into Documenter.jl's Buildkite config it looks like push previews are only provided if the build belongs to a PR?; > ; > https://github.com/JuliaDocs/Documenter.jl/blob/4be8243d31a6ffdbc64d779e3f8c2fb7c61de075/src/deployconfig.jl#L719-L725; > ; > Maybe there was no push preview here since @tomchor pushed this branch at which Buildkite ran, before the PR existed, so Buildkite did not publish a preview. Maybe if a second commit was made on this PR, it would be detected by Buildkite as a PR and therefore a preview would be published?. Perhaps if we update Documenter.jl in the docs to the latest version we can alleviate that. At the moment DocumenterCitations v0.2.0 is precluding Documenter from v0.26 and later; see https://github.com/ali-ramadhan/DocumenterCitations.jl/pull/34#issuecomment-782308024.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782308873:488,detect,detected,488,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782308873,1,['detect'],['detected']
Safety,"> @tomchor @whitleyv what's the ultimate vision for this PR. I think we just want to add a more ""precise"" drag option to IB by using the `conditional_flux` functions, so that a drag can be added at the exact locations that need it for the grid fitted version, while also avoiding the user having to call the correct conditional for each location. (For context, when adding drag to IB I have been just adding drag as a forcing over a cell-width above the boundary. So I'd prefer something a little more exact.) Hard coding this option in is mostly a test to see how it would go while using the available framework, before creating a full method that users would be able to implement nicely. . Implementing immersed boundary conditions as a separate term would work, I believe! A `value` immersed option wouldn't involve as much effort (as we've previously worked out for no slip), besides getting the direction correct. I think, one of our concerns was the interpolating of field dependencies within a functional form of a boundary condition, and how they would interact with the IB, could it be generalized to any input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075635953:271,avoid,avoiding,271,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075635953,1,['avoid'],['avoiding']
Safety,"> @tomchor do you want help with this? I'd be happy to help move this along (looks like we need to merge with master). I'm also wondering if we can simplify the setup. For example, I don't think `BackgroundField` is essential --- we can just run an initial value problem and obtain very similar physics and visualizations. I also think we can get rid of the sponge layer at the top of the domain. I think these simplifications might make the example a little easier to interpret and focus attention on the novel parts of the example (mostly, the tilting of gravity + Coriolis). Thanks for the offer! I'm actually making progress very slowly on this branch. I just haven't pushed it to avoid running CI (I have the feeling that the CI servers have been kinda overwhelmed lately?). But some help would definitely be nice :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974301910:685,avoid,avoid,685,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-974301910,2,['avoid'],['avoid']
Safety,"> Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated).; > ; > There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one.; > ; > > if the name is changed to include Cartesian then we can merge this and discuss further in an issue.; > ; > Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here. For physics tests we can't avoid introducing an arbitrary tolerance. So its ok. That's one reason why physics tests in CI are a bit problematic and we also need validation tests analyzed by humans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957:867,avoid,avoid,867,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957,2,['avoid'],['avoid']
Safety,"> Agreed. Although I think that's for another PR, right?. For sure but if that case actually requires another abstraction that would mean we can safely recommend not using `ImmersedBoundaryCondition`, then we shouldn't put too much effort into it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1599998597:145,safe,safely,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1599998597,1,['safe'],['safely']
Safety,"> Ah interesting. Does this work because broadcasting over GPU subarray views is a little rough around the edges?; > ; > Also, is it worth adding the MWE from [#1767 (comment)](https://github.com/CliMA/Oceananigans.jl/issues/1767#issuecomment-868793917) as a test?. Certainly _something_ is rough... I think it's ""broadcasting over ReducedField"" that's the issue here. Prior to this PR, `mean!` used a broadcast over `R::AbstractReducedField` to compute the normalization. For some reason this has data synchronicity issues on the GPU (I'm at a loss to explain why). This PR just changes that broadcast operation to compute over all members of `R`. The halo regions of `R` (presumably) aren't touched during `sum!`, so doing some extra normalization in the halos doesn't really matter, I guess... (if we want halos to be right we should probably fill them after executing `mean!` in `compute!`, or something). But the _reason_ why this change fixes the issue isn't at all obvious to me. Maybe there's a bad interaction between `KernelAbstractions` (which gets used for the broadcast) and `sum!`? Not sure. Maybe another solution would wrap `sum!` in `CUDA.@sync` (eg the solution here could _implicitly_ synchronize in order to perform the broadcast correctly; otherwise CUDA wouldn't work generally... ?!?). Might be worth testing that, though I don't know which solution we should prefer (if any). In fact, it seems better to avoid using custom broadcasting machinery if possible (which is the current solution)...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-868839671:1428,avoid,avoid,1428,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-868839671,1,['avoid'],['avoid']
Safety,"> Ah, I see. Sounds like it wouldn't be trivial to add that support.; > ; > I guess a workaround to avoid partially-averaged results when picking up would be to set the `Checkpointer` to only write checkpoints when the `TimeAveraged` results are also written. I'm not sure what that would do to other (more frequent) outputs though, since it'd potentially try to write some time steps twice (and not in monotonic ordering)... There are two things. One is to fix the flow of information... that's probably pretty easy because we can either 1) make `Checkpointer` a callback or 2) change `write_output!` to have the syntax `write_output(writer, simulation)` here:. https://github.com/CliMA/Oceananigans.jl/blob/643b484e81e0aeb038b3038266912ad051bce9b8/src/Simulations/run.jl#L147. then with a fallback `write_output!(writer, sim) = write_output!(writer, sim.model)`, very little has to change... The other task is to figure out how to save down the ""state"" of the time-averaging apparatus so that it can be restored correctly. That's maybe the harder part but of course unavoidable to make checkpointing work with it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3485#issuecomment-1969272305:100,avoid,avoid,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3485#issuecomment-1969272305,1,['avoid'],['avoid']
Safety,"> Any place where the loop limits are not types, it's wrong. It only works if the limits are known via types (so they are known at compile time rather than runtime). Typically this would require uusing `Val{N}` or `Val{H}` but even then it can fail sometimes. I'm not sure I understand what you mean here. Can you give an example that's OK and one that's not?; Also, @unroll comes from `KernelAbstractions.Extras.LoopInfo.@unroll`, right? The docstring is not really helping me on this:. ```Julia; help?> KernelAbstractions.Extras.LoopInfo.@unroll; @unroll expr. Takes a for loop as expr and informs the LLVM unroller to fully unroll it, if it is safe to do so and the loop count is known. ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. @unroll N expr. Takes a for loop as expr and informs the LLVM unroller to unroll it N times, if it is safe to do so.; ```. In particular, I don't know what ""if it is safe to do so"" refers to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874465464:647,safe,safe,647,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874465464,3,['safe'],['safe']
Safety,"> As soon as I put `fig[0, :] = Label(fig, title, textsize=24)` then the plot size gets all small and weird... Any ideas?. I would avoid using index `0` and also using `:` if you can. What happens when you put the label in `fig[1, 1:2]` and the contours in `fig[1, 2]`?. I also think it's probably better to use heatmap for all plots. While contour does look better, heatmap is a lot faster and less finnicky, and we get 95% percent of the educational value of the visualization with a heatmap. I almost never use contour except at the very final stages of visualization for paper plots, so...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2553#issuecomment-1126952448:131,avoid,avoid,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2553#issuecomment-1126952448,1,['avoid'],['avoid']
Safety,"> Billy mentioned it in some other comments but while we do splat args for some of the function calls, the function definitions use Varargs instead. This should avoid the catastrophic slowdown we saw with splatting earlier, but I agree that it should be tested. Do you have any good CPU performance tests set up @glwagner ?. Any simple test will do, for example one of the examples",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2150416681:161,avoid,avoid,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2150416681,2,['avoid'],['avoid']
Safety,"> But I do have one question: how are we supposed to treat open boundaries for quantities located at cell centers? I don't see any specific new code dealing with that. I see you used `GradientBoundaryCondition(0)` in your validation codes but, for example, for buoyancy that's not gonna cut it and will lead to reflections. The majority of the new code here deals with the fact that you can't update the boundary condition on wall normal velocities after the pressure correction step and maintain the interior domain to be physical and divergence-free, so we have a new function `_fill_X_open_halo!`, but there is nothing stopping you from also defining new methods for `_fill_west_halo!` which still acts before both the predictor and correct step and is what you would need to write for centre field OBCs. The reason I used `GradientBoundaryCondition(0)` in the validation case is that the literature suggests that it doesn't make much of a difference for the non-wall normal velocity component what boundary condition you use (e.g. https://doi.org/10.1002/fld.1650181006 ""(iii)&plat + Vacp/dn = 0, where V is ‘user-specified’, but cannot be zero, and should be positive if fluid is leaving the domain. (The average normal velocity through the boundary is a reasonable candidate.) This OBC may be gaining in popularity over acp/an = 0 for reasons which are not entirely clear to us.""), but I guess the reflection might be reduced by something else.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263595729:722,predict,predictor,722,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263595729,2,['predict'],['predictor']
Safety,"> By the way, i didn't use the scheme described in #1704 because it didn't give great results when implemented. I have implemented the ENO coefficients as derived before the assumption of uniform grid to the stencil interpolation (tomorrow I'll go back and check the report which describes them) . The smoothness functions are kept the same. That's interesting. Does that mean you were not able to reproduce the results reported in ""[A simple algorithm to improve the performance of the WENO scheme on non-uniform grids](https://link.springer.com/article/10.1007/s10409-017-0715-2)""?. > > By the way, it would be quite easy to modify the type to include the order of the WENO scheme which we could change at will. What do you think? Would it be usefull to do that?; > ; > If it's easy, then I definitely vote that we do that! A lower order, faster WENO scheme may be a good compromise between computational cost and accuracy. If that's true, we could use it as the default scheme for models. I think a higher order WENO scheme is more important than lower-order scheme. However, a low-order WENO method is proposed [here](https://link.springer.com/article/10.1007/s10915-020-01164-6). I think the 3rd order scheme may be quite diffusive and runs the risk of limiting to 1st order (?!). #995 attempts to implement nth order WENO but I think failed to achieve good CPU performance / compilation on the GPU. But @simone-silvestri perhaps you're able to achieve this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969290093:1250,risk,risk,1250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969290093,2,['risk'],['risk']
Safety,"> Can we use types rather than symbols? `ThreeDimensional()`, `Horizontal()`, etc. They are converted into types in the constructor `return ScalarDiffusivity{TD, eval(direction)}(FT(ν), κ)` (and are effectively types in the type signature. I personally prefer it this way because it allows to build closures in the API avoiding to have to import additional types... But, I don't feel so strongly about it... I can also change it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1039818469:319,avoid,avoiding,319,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1039818469,1,['avoid'],['avoiding']
Safety,"> Could you give a brief summary how the model equations differ from implicit to explicit free-surface?. It might be best to save that for the PR that implements the implicit free surface. Suffice to say that the implicit free surface uses a fractional step algorithm that first advances the velocity field to a predictor state U*, and then takes a free surface time-step using a backwards Euler method that utilizes U*. After that, the predictor velocity field is updated using the new barotropic pressure associated with η^{n+1}. The algorithm is described in the MITgcm docs:. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#pressure-method-with-implicit-linear-free-surface",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778466439:312,predict,predictor,312,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778466439,2,['predict'],['predictor']
Safety,"> Do you want that all for this PR or can we merge this part after I've implemented a simple matching scheme as a demonstration and then work on the rest elsewhere?. That's up to you. Smaller PRs can be easier because you will have less risk of merge conflicts. However you should make sure that the code in any individual PR is motivated and tested (ie if you implement a new type then it'd be best to have a use case for it, plus a test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2038114155:237,risk,risk,237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2038114155,2,['risk'],['risk']
Safety,"> Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. We already do ""unwrap"" data from fields on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Fields/field.jl#L368. > I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. Okay, this makes sense. Solving the problem for `calculate_Gu` just bumps the error down to `calculate_tracer_tendency`, and the issue isn't tractable in that case, since it's clearly important to support tracer forcing functions that depend on other tracers (eg for biogeochemical models). Can you provide a minimum script that reproduces the error? I do think many tracers is an important use case so solving this could warrant reducing the kinds of forcing functions we support --- if that's necessary. I think there also may be solutions that don't change what we support while still solving this problem; eg we provide some features that extend model capabilities specifically for the case of large numbers of tracers. For example, we could avoid passing the tracers explicitly into the kernels. Instead, we can attach references _only_ to the relevant / used fields directly in `Forcing` (we'd have to change the user API to `DiscreteForcing` to support this, but the changes need not be major). This way one might be able to support systems of reacting tracers, as well as many ""additional"" passive tracers that are not involved in a forcing function. Or, we can explore https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878:1239,avoid,avoid,1239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878,2,['avoid'],['avoid']
Safety,"> Exactly, in practice a transpose is communication + permutation, but with `unified_memory` we avoid the communication part (I mean it is there but it's handled by CUDA). So maybe we need three unified memory arrays for `solver.storage`, each permuted with respect to one another?. I was thinking it'd be nice to avoid coding it ourselves by using cufftxt, but now that we're talking about it doesn't seem too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119921486:96,avoid,avoid,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119921486,2,['avoid'],['avoid']
Safety,"> Have you tried using `wc = Field(w*c, indices=(:, 1, :))` and also `wc_avg = Average(w*c, dims=2)`? This would allow you to avoid using the `indices` kwarg. I haven't tried that solution specifically, but I suspect it would work. I think the issue with this bug isn't that there aren't workarounds (for example, one could just separate slices and averages into two different files, which is what I'm currently doing) it's just that it fails silently and subtly, so it could catch users off guard.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1438716451:126,avoid,avoid,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1438716451,1,['avoid'],['avoid']
Safety,"> Hmm. What is; > ; > ```julia; > view(u[region_W], 1, Nc+1-Hc:Nc, k); > ```; > ; > is this a `Field`? Next question, what is; > ; > ```julia; > reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k)); > ```; > ; > If the former is a `Field` I don't think we've defined `reverse` on `Field`. But you could do that... @glwagner, yes, `view(u[region_W], 1, Nc+1-Hc:Nc, k)` is a `WindowedField`, on which `reverse` is not defined yet. But `reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data)` is a valid operation. However, simply typing ; ```julia; u[region][1, Nc+1:Nc+Hc, k] .= reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data) * plmn; u[region][Nc+1, 1-Hc:0, k] .= reverse(view(u[region_E], 2:Hc+1, 1, k)); ```; might throw the above-mentioned error due to a dimension mismatch or fill the LHS with junk or incorrect values. So, a safe solution is ; ```julia; view(u[region], 1, Nc+1:Nc+Hc, k).data .= reshape(reverse(view(u[region_W], 1, Nc+1-Hc:Nc, k).data) * plmn, 1:1, Nc+1:Nc+Hc, k:k); view(u[region], Nc+1, 1-Hc:0, k).data .= reshape(reverse(view(u[region_E], 2:Hc+1, 1, k).data), Nc+1:Nc+1, 1-Hc:0, k:k); ```; @glwagner, @navidcy, if you guys are fine with this fix, I will close the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2033319769:819,safe,safe,819,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2033319769,2,['safe'],['safe']
Safety,"> Hmmm, I am not sure how you solved this in the serial grid, but I guess in the same way. By removing that assumption and calculating the coordinate accordingly?. Since we removed the assumption, do we also eliminate the need for this code which avoids the assumption?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3467#issuecomment-1946400260:247,avoid,avoids,247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3467#issuecomment-1946400260,1,['avoid'],['avoids']
Safety,"> Hmmm, doesn't rectilinear imply orthogonal?; > ; > `RegularRectilinearOrthogonalGrid` might be a little redundant?. No. Rectilinear just means that the axis are straight lines... But the axis could intercept in angles other than 90 degrees.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782295927:106,redund,redundant,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782295927,1,['redund'],['redundant']
Safety,"> How about this?; > ; > ```julia; > @warn ""Inflating model grid halo size to ($Hx, $Hy, $Hz) and recreating grid. "" *; > ""The model grid will be different from the input grid. To avoid this warning, "" *; > ""pass halo=($Hx, $Hy, $Hz) when constructing the grid.""; > ```. Sounds great! I have added it in my branch. I will close this issue and we cna modify this when the branch makes its way as a PR. Soon I hope!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1501#issuecomment-805046294:180,avoid,avoid,180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1501#issuecomment-805046294,1,['avoid'],['avoid']
Safety,"> However, I found that the velocity shear at the first grid points is much larger than that predicted by the Monin-Obukhov similarity theory. I don't have much experience with solid wall boundary layers. A quick search returns this review:. https://journals.aps.org/prfluids/pdf/10.1103/PhysRevFluids.2.104601?casa_token=VBO0hrNqp-cAAAAA%3A3XEKZfLTdhiVluwRl8sCQCkOK44GoGUX-546uFtqQjSWAUIDQpKyyQsA4lQd65Oz6Kw5ClWias_CVQ0. suggesting that correct flux predictions in wall-modeled LES is unsolved. For example:. <img width=""616"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/a6ffe67e-2009-441a-a440-80afe0dc4a70"">. shows a mismatch between DNS and wall-modeled LES for a few standard codes. Based on the literature, a failure to reproduce the log-law is expected?. It might help if you provide more background on what exactly you're trying to achieve, and why you believe the current approach will achieve that objective. For example, are we attempting to reproduce a known result?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1650818364:93,predict,predicted,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1650818364,2,['predict'],"['predicted', 'predictions']"
Safety,"> I actually think having an error=true option to NaNChecker would be useful for other purposes than avoiding a nan-filled checkpoint. Okay. > I personally still think that's the best solution here. I disagree, because it only solves the problem for a narrow range of checkpointer schedules. If you checkpoint based on `TimeInterval` and check for NaNs based on `IterationInterval`, there is no guarantee that you won't write NaNs to a checkpoint file whether or not the NaNChecker throws an error. I think a better solution is to explicitly avoid writing a checkpoint file (or any other task) when NaNs are detected. > it's also pretty simple. There's hardly a difference in the simplicity of either implementation. > Unless there's a reason why that's a bad idea that I'm missing... I don't think there is an intrinsic problem with throwing an error, I just think that it's often a brittle hack that can damage productivity (errors thrown by the NaNChecker generate a long stacktrace of irrelevant information --- because the emergence of a NaN is not an error in the usual sense). So I think it's useful to think of more user-friendly solutions to various issues / tasks we face when setting up simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538:101,avoid,avoiding,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538,6,"['avoid', 'detect']","['avoid', 'avoiding', 'detected']"
Safety,"> I also think it'd be fun to try to automatically detect the appropriate device. Something like; > ; > ```julia; > function GPU(); > has_cuda_device = has_cuda(); > has_amd_device = AMDGPU.has_rocm_gpu(); > has_cuda_device && has_amd_device && # this user is blessed with CUDA _and_ ROCm!!; > throw(ArgumentError(""Both a CUDA _and_ an AMD GPU are detected! One of them must be selected for the GPU architecture"")); > ; > has_cuda_device && return CUDAGPU(); > has_amd_device && return ROCMGPU(); > ; > throw(ArgumentError(""Cannot build GPU architecture because neither a CUDA GPU nor an AMD GPU were detected!"")); > end; > ```. I think it's a nice thing to have, but I'm not sure where this will be called. Will it be Oceananigans.jl's top module file?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112510197:51,detect,detect,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112510197,3,['detect'],"['detect', 'detected']"
Safety,"> I believe for your implementation, since the tracer values are not corrected for pressure, any leakage will be due to the advection of tracer by momentum that _is_ impacted by the pressure correction. This advection should be less with a smaller spacial step if I remember correctly. Well, I agree that less leakage implies that less tracer is advected across the boundary. But why is less tracer advected across the boundary?. It occurs to me that we are not converging to a particular solution as we refine the grid in this case, because this problem has no viscosity. Perhaps we should do a convergence test for a case with finite viscosity. We do introduce grid-scale gradients in the predictor velocity field via masking, so it does seem possible to me that the leakage / pressure gradient error might scale with resolution. It'd be nice to have a solid mathematical explanation for this behavior. Another question might be whether the leakage / error depends on the extent of the masked region (holding resolution constant). I'm not sure whether its worth looking into all this stuff though --- it might be better simply to work on implementing an accurate pressure solver, since I don't think it would be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867965142:691,predict,predictor,691,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-867965142,2,['predict'],['predictor']
Safety,"> I can create a separate issue to address this, but perhaps more importantly, I don't see the interior velocity `V∞` being added anywhere there except in the BCs. Usually we add it as a background field to avoid inertial oscillations, and indeed it used to be done like that in [older versions of the docs](https://clima.github.io/OceananigansDocumentation/v0.73.8/generated/tilted_bottom_boundary_layer/), but at some point this was changed and I don't really understand why (nor can I pinpoint where).; > ; > I think it's okay to run the example without adding it as a background field, but then we're solving the problem in a reference frame that's moving with the interior flow and that should be made explicit, and I don't see that explanation there. Personally, I'm in favor of including `V∞` as a background field because it's simpler.; > ; > CC @hdrake @glwagner who were in #3581. What's the problem with adding it back?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3813#issuecomment-2388706841:207,avoid,avoid,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3813#issuecomment-2388706841,2,['avoid'],['avoid']
Safety,"> I did a few tests with some criteria for timestep-skipping with a couple of my own simulations in addition to the MWE included here. In summary:; > ; > 1. Criterion `sim.Δt / 1e10`: successfully gets rids of the problem in both the MWE and in my simulations; > 2. Criterion `10 * eps(sim.Δt) * sim.Δt`: doesn't get rid of the problem in any simulation; > 3. `100 * eps(sim.Δt) * sim.Δt`: fixes the problem in the MWE but not in my simulations, although it does decrease its frequency of occurrence a good amount.; > 4. `1000 * eps(sim.Δt) * sim.Δt`: fixes everything in all simulations I've tried.; > ; > So only options 1 and 4 fully fix the problem (at least in the simulations I've tried so far). For me both those options rely on pretty arbitrary numbers though, so I'm not very happy with neither. From the point of view seeing the timestep-skipping as an approximation (un+1≈un), then maybe criterion 1 makes more sense, although I'm not sure how it'd behave for Float32 simulations.; > ; > I see three possible ways to go about it right now:; > ; > 1. Do what this PR is doing, and manually set the criterion to either option 1 or 4 above. If it turns out that some simulations still have issues, we revisit.; > 2. We add `min_Δt` as a property of `NonhydrostaticModel` (or maybe `Simulation`?). I think the minimum `Δt` for which time skipping will be necessary will vary significantly between simulations, so this solution deals with that by leaving the decision up to the user if they are interested in the pressure output.; > 3. We try something that actually prevents these round-off errors instead of dealing with them. @glwagner suggested an `Integer`-based model clock, but there might be other options. Note that `eps(sim.Δt)` is similar to `sim.Δt * eps(typeof(Δt))`. So `Δt / 1e10` is pretty similar to `100000 * eps(sim.Δt)`. The only point of using `eps` is to avoid hard coding `Float64`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2136281567:1883,avoid,avoid,1883,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2136281567,1,['avoid'],['avoid']
Safety,"> I feel we need a more general solution to avoid boilerplate when new grids are added. If we really can't crack this problem then we can merge this as an experimental feature. But I feel we really will want many more grid types that accept stretching, curvilinearity, cubed sphere, etc. I agree that we can do better and am keen to try things out. I need to think about this a little more before I can suggest an alternative.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1504#issuecomment-805152260:44,avoid,avoid,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1504#issuecomment-805152260,1,['avoid'],['avoid']
Safety,"> I found that using --check-bounds=yes or running the code on a CPU cannot reproduce the error in the original script posted by me. Interesting --- does that mean that this is not an out-of-bounds issue?. > I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Are the NaNs appearing in the particle coordinates, or in the model velocity fields? The _default_ `NaNChecker` only checks the first entry in the model's prognostic field:. https://github.com/CliMA/Oceananigans.jl/blob/00006c17c2ede7f819e15ae14aabb14ab62a0136/src/Simulations/simulation.jl#L71. https://github.com/CliMA/Oceananigans.jl/blob/00006c17c2ede7f819e15ae14aabb14ab62a0136/src/Models/Models.jl#L163-L169. Note also that by default, the `NaNChecker` is only actuated every 100 iterations. You are free to use a different NaNChecker, however. The balance between the computational cost of checking NaNs / frequency of NaN checking and the cost of a time-step is use-case-specific. Can you clarify why you expect the model to abort itself when NaNs appear? Are you suggesting that we can improve the default NaN checker?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771382783:235,abort,abort,235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771382783,2,['abort'],['abort']
Safety,"> I hope this description of the workflow is clearer. It's clear!. > I thought the optimal implementation is to append to the previous existing file when using checkpoints. Of course I agree with this. I think our basic principle should be that there is no difference in workflow, either for running or analysis, between scripts for checkpointing or not. Also, I think that `overwrite_existing` should not delete your files if you are picking up from a checkpoint (regardless of what it is set to). Do you agree?. > If I don't change the name each time I pickup, with the overwrite_existing=false it crashes, and with overwrite_existing=true it rewrites all the files. If we have a system that does not overwrite files when picking up from a checkpoint, do you think that it will be necessary to have `overwrite_existing=false` by default? In this case, the only time we risk overwriting files is when we _re-run_ a simulation from the beginning. Assume for the following discussion that the ""overwriting issue"" is solved for checkpointing:. In my experience, I typically set up a script with `overwrite_existing=true` from the very beginning. This is because when we first write a script, we are prototyping. I have never then gone back and changed `overwrite_existing=false` because of some concern about overwriting data. It's inconvenient, in fact, to set `overwrite_existing=false`. My thought is that it makes more sense to ask people to intentionally request `overwrite_existing=false` in the _rare_ case that this is desired. The key insight is that we spend the vast majority of time prototyping. I would even argue from an economic standpoint that the productivity saved from this setting outweights any rare instances of lost data, if they actually would ever occur due to changing the default. Also, even for this purpose I don't really want a ""non-overwriting guarantee"" as a feature. I would prefer something like ""unique_filenames = true"" or something, which I could then ""turn on"" if I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2392162201:871,risk,risk,871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2392162201,2,['risk'],['risk']
Safety,"> I propose; > ; > ```julia; > xspacing(X, Y, Z, grid); > yspacing(X, Y, Z, grid); > zspacing(X, Y, Z, grid); > ```; > ; > where `X, Y, Z` are all _instantiated_ locations eg; > ; > ```julia; > x = xspacing(Center(), Center(), Center(), grid); > ```; > ; > I propose we avoid ""one location"" versions that only work for rectilinear / lat-lon grids. I like this API. Although, since this is a user-facing function, I'd vote for us to have one-location methods defined only for grids that support it. Although I don't feel strongly about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328277603:270,avoid,avoid,270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328277603,1,['avoid'],['avoid']
Safety,"> I see @glwagner's point. I'm a bit skeptical in that part of the PR (which claims that trig functions should be avoided). Perhaps we can elaborate a bit more on that or point the reader to some other source? I'm a bit on the fence. On the other hand, if I was trying to code up something and was ending up having my code 100 slower because I was doing `cos(pi/4)` instead of `sqrt(2)/2`, then I'd be very grateful if somebody pointed it out in a ""Tips"" section!. 100x slower is definitely a scripting bug. We are missing `@inline` in the examples?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951425555:114,avoid,avoided,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951425555,1,['avoid'],['avoided']
Safety,"> I think I get the idea, but I still can't imagine what could be wrong with the vertically stretched grids themselves. They seems pretty straightforward. Could you clarify what specific metrics you're talking about that are different?; > ; > > We might be able to convert the internal wave setup dynamics test to a vertically bounded domain and put it on a stretched grid to test these issues.; > ; > This seems like a good idea. I don't know which ones are problematic --- once we find those, the problem is solved. The answer might be obvious; it looks like we only redefine `Flat` metrics for `RegularRectilinearGrid`:. https://github.com/CliMA/Oceananigans.jl/blob/326f22aff244ad1f9d0778b9d06184f348db211b/src/Operators/spacings_and_areas_and_volumes.jl#L57-L62. We may just have to use `AbstractGrid` rather than `RegularRectilinearGrid`. I'm not sure why the above functions are specific to `RegularRectilinearGrid` in the first place. @francispoulin you helped with this, right? Do you know?. We're missing many of the horizontal metrics too so I think we should add those, otherwise `Flat` won't work with curvilinear grids, either. EDIT: definitions for flat _area_ metrics are probably not very useful / represent edge cases that need special consideration. So we might just focus on flat _linear_ metrics for now (dx, dy at various locations). Right now additional horizontal linear metrics are irrelevant because there are no rectilinear grids that are stretched in horizontal directions. However, we will need these once we have general stretched rectilinear grids and it might be good to avoid confusion like what's happening in the present issue... I'm putting together a test for rectilinear grids that catches this. I suggest we fix the problem after we have the test. If anyone has more information about `Flat` please chime in.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-881923453:1603,avoid,avoid,1603,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-881923453,1,['avoid'],['avoid']
Safety,> I think for accumulation of a scalar you should use `val = Ref(0.0)` then `val[] += dt * d_val`. Thanks! Yeah it makes sense to avoid globals. I went with this suggestion,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1485437711:130,avoid,avoid,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1485437711,1,['avoid'],['avoid']
Safety,"> I think it should be T₁(kᵖ, z) - T₂(kᵖ, z) in the above code?. Thanks @qingli411 ! Fixed:. ![image](https://user-images.githubusercontent.com/15271942/156587002-2f14ad93-f287-4900-bb49-b89101076c4d.png). I talked to Nick Pizzo and spent some time reading [Lenain and Melville 2017](https://airsea.ucsd.edu/wp-content/uploads/sites/10/2019/06/2017_Lenain_Melville-Journal_of_Physical_Oceanography_vol_47-2.pdf) and [Lenain and Pizzo 2020](https://journals.ametsoc.org/view/journals/phoc/50/12/JPO-D-20-0116.1.xml) and I'm left with a few questions. First and foremost is: how is it possible to formulate a stationary relationship between Stokes drift and transport as in McWilliams and Restrepo? In the experiments we run, we impose a constant momentum flux / constant wind on top of an _initially quiescent_ boundary layer. Thus it seems the most appropriate model for the peak wavenumber would be one that accounts for the _fetch dependence_; eg, the peak wavenumber decreases in time as the wind continues to blow, consistent with the concept of a constant wind that starts blowing impulsively over an ocean at rest. Two other details in those papers are:. * The relationships are formulated in terms of friction velocity rather than atmospheric wind speed, so we avoid introducing bulk formula which I think is an advantage.; * [Lenain and Pizzo 2020](https://journals.ametsoc.org/view/journals/phoc/50/12/JPO-D-20-0116.1.xml) claim that their correction to the surface wave spectrum changes the surface Stokes drift (and I suppose Stokes shear) by 15-20%. I'm not sure how much this would imprint on our results but it's something to think about.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058116153:1268,avoid,avoid,1268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058116153,1,['avoid'],['avoid']
Safety,"> I think it would be more effort if we take into account the need to rebenchmark a lot of cases. I also think it adds some risk... Yeah true, they do claim it is more peformant so maybe something to consider in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735298477:124,risk,risk,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735298477,1,['risk'],['risk']
Safety,"> I think passing the tendencies automatically is going to require some materialization step when the model is setup to pass into the boundary conditions but I know we're trying to avoid doing that so any other suggestions would be useful. I've started testing this by initialising the timestepper first but it is a bit clumsy. Well, we already do materialize boundary conditions, so possibly this isn't such a big deal. Another possibility is to pass the tendencies through to `fill_halo_regions!`, but that has wider implications that we'd have to think about (for example should the tendencies also be passed on to discrete-form boundary condition functions?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1965127320:181,avoid,avoid,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1965127320,1,['avoid'],['avoid']
Safety,"> I think that's a fine strategy. We can add a kwarg to `NonhydrostaticModel` called `hydrostatic_pressure_anomaly`. We can set it to `CenterField(grid)` to preserve existing behavior, or set it to `nothing` to avoid the separation. And we should probably make `nothing` default so that triply periodic problems can be done out of the box. Then we don't have to re-do the regression tests either because we preserve existing behavior...; > ; > I think that's also a less invasive change than this PR because we don't have to change `pressures` to `pressure` everywhere, hmm. Agreed. > Since you've done most of the legwork I think you have prerogative to open a new PR if you like (and I can help once you do). Thanks, but I unfortunately won't have time to dedicate to this for at least a few weeks. So please feel free to start the PR!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-2088574534:211,avoid,avoid,211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-2088574534,1,['avoid'],['avoid']
Safety,> I think we should fix the problem once. Otherwise we'll end up with unnecessary code somewhere that has to be deleted. @glwagner Can you please be clearer? Does that mean adding `min_Δt` to `Simulation` is an acceptable solution? Or should we try to avoid these round-off errors to even happen in the first place?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2150576412:252,avoid,avoid,252,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2150576412,2,['avoid'],['avoid']
Safety,"> I would avoid using index `0` and also using `:` if you can. What happens when you put the label in `fig[1, 1:2]` and the contours in `fig[1, 2]`?. The 0 indexing was not the issue. `tellwidth=false` did the trick!!!. ```julia; fig[0, :] = Label(fig, title, textsize=24, tellwidth=false); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2553#issuecomment-1126969454:10,avoid,avoid,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2553#issuecomment-1126969454,1,['avoid'],['avoid']
Safety,"> I would think that passing a function instead of collect(0:Nz) would probably be cleaner but both can work. Yeah I definitely think passing a function is more intuitive and efficient. As long as that's still an option, I'm happy :). > VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Nz), z_stretch=collect(0:Nz)); What's nice about this is that you still specify the domain boundaries, as other grids do, and you specify the stretching function separately. This makes it easier to do a stretch in any direction, and #1532 does just that. Sorry, but I'm a but confused. Aren't `x`, `y` and `z` supposed to be dimensional? Meaning they are the physical bounds of the domain? In your example `z=(0, Nz)`, which does not correspond to the physical boundaries at all. Or did you mean to write something like. ```julia; VerticallyStretchedRectilinearGrid(FT, size=(1, 1, Nz), x=(0, 1), y=(0, 1), z=(0, Lz), z_stretch=collect(0:Δz:Lz)); ```. If so then it makes sense to me, but that's a bit redundant, no? (Sorry for the confusion!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813445443:1021,redund,redundant,1021,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813445443,2,['redund'],['redundant']
Safety,"> I'm not sure I follow then. Are you saying that you're not sure all the versions in this range are bug-free? That being the case it's best to pin it to a version we know is safe?; > […](#); > On Tue, Oct 5, 2021, 17:05 Gregory L. Wagner ***@***.***> wrote: ***@***.**** commented on this pull request. ------------------------------ In Project.toml <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)> : > @@ -33,7 +33,7 @@ Tullio = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc"" [compat] Adapt = ""^3"" -CUDA = ""3"" +CUDA = ""3.0.0 - 3.3.6"" Note that Manifest.toml pins a specific version. Right, that's why I figured making it specific was the safest option. — You are receiving this because you were mentioned. Reply to this email directly, view it on GitHub <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/ADEX5KRJ3DYWCNI4IRO6RNTUFNSC3ANCNFSM5FKUICWQ> . Triage notifications on the go with GitHub Mobile for iOS <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675> or Android <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>. Oh, I just can't remember how far back we're able to go. But if you've gone to the effort to test a whole range of versions then certainly we might as well use a range, since it has the benefits you mentioned! My thought was just that it'd be quick and simple to pin to the version in the Manifest.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502:175,safe,safe,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502,4,['safe'],"['safe', 'safest']"
Safety,"> I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling. I didn't know this was a KA.jl-based GPU workload when commenting on Slack. The dependency/event model of KernelAbstractions.jl also uses stream queries (i.e. `cuStreamQuery`) when selecting a new stream. Maybe that's the source of these calls. It'd be good to figure out where they come from: if it's from CUDA.jl, and thus presumably because of calling the `synchronize` function, (1) why are you synchronizing that much [1], and if it's for good reasons (2) does it hurt performance and should we tweak our `synchronize` implementation to perform fewer stream queries?. [1]: some synchronization happens implicitly, e.g. when copying memory to or from the CPU (https://github.com/JuliaGPU/CUDA.jl/blob/6758fcab7ae0d72659a1ca0d56ad2c86d3b451f1/src/array.jl#L385-L399). One way to avoid some of those synchronizations, is by using pinned memory, but that's up to the application.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869:945,avoid,avoid,945,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869,1,['avoid'],['avoid']
Safety,"> I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors. That's a good point. Although I think we could avoid creating another page and put that information in the [""Using GPUs""](https://clima.github.io/OceananigansDocumentation/stable/using_gpus/) page, so that things are more condensed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818364275:275,avoid,avoid,275,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818364275,1,['avoid'],['avoid']
Safety,"> I've been thinking on how to divide the function, but it will require the duplication of the lines:; > ; > ```; > filename = first(split(basename(filepath),""."")) * ""_part""; > filelist = filter(startswith(filename), readdir(folder)); > existing_files = length(filelist) > 0; > ```; > ; > within the code, how important is it to avoid duplication vs clarity?. Clarity matters most. But usually there are not strong trade-offs: duplication improves clarify only if the duplicated code is short and easy to understand. How is this:. ```julia; filename = first(split(basename(filepath),""."")) * ""_part""; ```. different from `current_filename`. For clarity I think it's it's best to use more lines for complicated operations rather than concatenating many operations into a single line. That line does a lot of things at once: basename, split with ""."", first, and then finally concatenation with _part. That's quite a few things for one line.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2418455151:329,avoid,avoid,329,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2418455151,1,['avoid'],['avoid']
Safety,"> Indeed, it seems like; > ; > ```; > @inline tank(x, y) = ifelse(radius(x, y) < L, -H, Float64(0.0)); > ```; > ; > clears the problem. Interesting... Do you guys have any idea why that could influence the `fill_halo_bottom`?. If there's a function that can return two possible types (which is inferred to a type `Union` I think) then this might propagate downstream in the compiled code (ie two possible scenarios must be maintained; one when the returned value is `Float64`, and another with different intrinsics for when the returned value is `Int`). I think in principle this can greatly complicate the kernel function for filling the boundary condition. Broadly speaking, for functions that must be inlined into complicated kernels, it's safest to use functions that can only return one type. But I don't have a good answer for why we get the specific error `an illegal memory access was encountered`. This could be a bug in `CUDA.jl`. However, we are using an old version of `CUDA.jl` so there's not much point in raising an issue. The behavior very well may be different in the latest version... Someone with deeper knowledge of the Julia compiler / compilation system might have a better answer too...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084049440:743,safe,safest,743,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084049440,2,['safe'],['safest']
Safety,"> Instead of saying that trig functions should be avoided on gpus, which seems very strong, I suggest pointing out that there have been some examples where trig functions have performed much slower, and include this example.; > ; > This clearly problem needs further exploration but I don't want people to be scared to use sin and cos because sometimes they just make a lot of sense. My two cents worth. I think there may be a bug in the setup that produces 100x slowdown. (@tomchor if you supply the whole script, we can investigate.) We've run many successful problems with trig functions. Some recent work by @simone-silvestri suggests we can get 2x speed up for _some_ problems by precomputing grid metrics for the `RegularLatitudeLongitudeGrid` rather than computing them on the fly:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/Operators/spacings_and_areas_and_volumes.jl#L178-L179. But I don't think we've definitely shown that we _always_ will get 2x speed up. Thus we are going to retain the option to compute metrics on the fly in #2025 so we can continue to investigate it. 2x is a long way from 100x though. If used in a boundary conditions, its basically irrelevant whether one uses a trig function or not. Even a forcing function is only evaluated once per grid point compared to 15x (or more?) for a `BackgroundField` velocity component with high-order advection. Some of these thoughts might be distilled into useful advice in this section of the docs. But we should definitely focus on _approaches_ to performance optimization rather than advice for specific scenarios.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951555050:50,avoid,avoided,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951555050,2,['avoid'],['avoided']
Safety,> Is it also safer to infer `FT` from `grid`?. There is no safety difference but it is preferred to use `eltype(grid)`. This also conforms to YASGuide.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3419#issuecomment-1883486297:13,safe,safer,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3419#issuecomment-1883486297,2,['safe'],"['safer', 'safety']"
Safety,"> Is it possible to calculate the components `fx, fy, fz` on the fly? Also, can we infer `rotation_axis` from user-specified `fx, fy, fz`? If so, we can have one type for a constant rotation rate (storing just the parameters `rotation_axis` and `rotation_rate`), and use it for both Cartesian / rectilinear and spherical geometries. EDIT: this might be a bad idea if it adds functions like sin / cos to kernels. If we do need to pre-calculate fx, fy, fz, I think we should somehow indicate that this type is specifically Cartesian or rectilinear to avoid confusion with its spherical-geometry counterpart... unfortuntately, because its annoying.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887762725:549,avoid,avoid,549,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887762725,1,['avoid'],['avoid']
Safety,"> Is that a reason why you define the closure for the coarse_model?. There reason is that at the moment `NetCDFWriter` needs it to get some info on the `grid`. But as @glwagner and I pointed out, it's probably pretty easy to change `NetCDFWriter` to avoid that. I might try a PR soon that makes the simplest change possible and see it tests pass.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2091121584:250,avoid,avoid,250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2091121584,2,['avoid'],['avoid']
Safety,"> It is also of course possible to simply write a function that calculates the eddy viscosity, and call this function repeatedly to avoid temporaries altogether. Don't know if it's always possible but if we can avoid temporary variables by aggressively inlining all calculations, that would be cool. Every temporary field saved means being able to run a larger model on GPUs. We will always need a couple of temporary arrays so if we can't inline we can just try to share and reuse the temporary arrays as much as possible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-468751396:132,avoid,avoid,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-468751396,2,['avoid'],['avoid']
Safety,"> It might be a problem of the forcings which are divided by `h` (I am not sure that is correct, but I forsee a problem when `h → 0`). I agree that this case is a problem and we need to avoid vanishing layer depth. I noticed that the bathymetry had a maximum that was 100, not 0. Since we are setting `h = - bathymetry`, i think we have negative heights from the very beginning. This is part of the problem maybe?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129192752:186,avoid,avoid,186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129192752,1,['avoid'],['avoid']
Safety,"> It occurs to me that we are not converging to a particular solution as we refine the grid in this case, because this problem has no viscosity. Perhaps we should do a convergence test for a case with finite viscosity. This is likely to help since the velocity is small in the boundary layer, and so will reduce the magnitude of the local correction in a step. > We do introduce grid-scale gradients in the predictor velocity field via masking, so it does seem possible to me that the leakage / pressure gradient error might scale with resolution. It'd be nice to have a solid mathematical explanation for this behavior. I would be interested in such an argument. Other than zooming in on the slowest part of the BL, I'm not sure if/why increasing resolution would reduce the total flux over a fixed interval of time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-868299100:407,predict,predictor,407,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-868299100,1,['predict'],['predictor']
Safety,"> Just so I understand this filtering thing. It doesn't remove the regex-filtered lines from the output; it just doesn't test those lines against the ""prediction"", right?. Yeap!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2083#issuecomment-982048875:151,predict,prediction,151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2083#issuecomment-982048875,1,['predict'],['prediction']
Safety,"> May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it. As far as I can tell when people say they use ""Gent-McWilliams"" they are referring to a constant skew diffusivity (typically 0.3 m^2 / s). But in this closure, the diffusivity can be an arbitrary function or field. If anything it would have to be `GentMcWilliamsRedi` since we include the symmetric component as well as the skew component. Still though, I think it's important to emphasize that this closure is more general than Gent-McWilliams; not least because the only point in implementing this scheme is to develop a new, better, different parameterization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924962650:100,avoid,avoid,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924962650,2,['avoid'],['avoid']
Safety,"> Nice! Do you have an image that illustrates the problems at low resolution, ie a plot that reproduces the Adcroft result?. Yes. Here they are. I improved the visualization on the latest commit and pushed it right now. The types of immersed boundary and plot are included in the filenames. The discrete version of the topography (i.e. the Gaussian bump for this test case) is detectable only for the heatmaps. https://github.com/CliMA/Oceananigans.jl/assets/12926768/f94a6b92-cb5e-4197-9e5b-bd8ea1bad42a. https://github.com/CliMA/Oceananigans.jl/assets/12926768/c2d37eb9-931e-4efa-aa99-c113e38bf393. https://github.com/CliMA/Oceananigans.jl/assets/12926768/38771b36-e030-4877-8c9f-61944cd9aefc. https://github.com/CliMA/Oceananigans.jl/assets/12926768/baf6c24b-3fc1-4f4e-aec7-17826bd4da61",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3123#issuecomment-1593757333:377,detect,detectable,377,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123#issuecomment-1593757333,1,['detect'],['detectable']
Safety,"> No we should fix this for sure. I'm asking because you would save a lot of memory if you avoid writing `Field(w*c)`. Ah, I see. That's a good point, I'll investigate that. I'm wrapping things in `Field()` calls because I use the `data` option in all of them to reuse scratch space and save memory. But indeed when averages are involved that might not be the best way to go...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1438745870:91,avoid,avoid,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1438745870,1,['avoid'],['avoid']
Safety,"> Ok here's an idea: replace `Scan` with `Accumulation`. I think a sum can be thought of as ""accumulating"" without any leaps. We then would have _reducing_ accumulations (intermediate accumulations are not stored), and _cumulative_ accumulations (where the result is not reduced). Pardon my being pedantic, but ""cumulative accumulations"" sounds pretty redundant. We might not have enough words in the English language to describe this functionality precisely :laughing:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2104572604:352,redund,redundant,352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2104572604,1,['redund'],['redundant']
Safety,"> One thing to note is that the current implementation appears to be very slow. While the simulation with the `SmagorinskyLilly` closure runs on my laptop in 10 seconds, it takes 4 minutes for the simulation with the `ScaleInvariantSmagorinsky`. I know the dynamic model will be slower given the extra computations, but such a difference seems large to me, so I'm hoping something can be changed here to improve performance:. Avoided recomputation of the strain rate at `ccc` and sped things up a bit more. Now it runs in 2.9 minutes. A lot more to go...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2241696460:426,Avoid,Avoided,426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2241696460,1,['Avoid'],['Avoided']
Safety,"> Only concern might be that by using Logging.global_logger, Oceananigans now hijacks the global logger and everything starts using it for logging. But maybe this isn't a big deal and we can revert behaviour at any time. I'm not passionate either way, but is it easy to simply avoid importing the macros associated with the global logger and defining them for a custom logger instead?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/855#issuecomment-674115587:277,avoid,avoid,277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/855#issuecomment-674115587,1,['avoid'],['avoid']
Safety,> PS @christophernhill: Buildkite tests did not run on this PR since we disable Buildkite on PRs from forks (to avoid random PRs executing potentially malicious code on Tartarus and Sverdrup).; > ; > So we usually open and merge branches from the repo itself. OK - I'll put it in a branch sometime today,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1333#issuecomment-772577271:112,avoid,avoid,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1333#issuecomment-772577271,1,['avoid'],['avoid']
Safety,"> Pardon my being pedantic, but ""cumulative accumulations"" sounds pretty redundant. I think ""cumulative sum"" is redundant too. If I say I have an ""accumulation of beans"", I'm talking about the whole pile of beans. It doesn't seem to me that terminology exists, to answer your first question about whether ""scan"" is commonly used. There isn't any term that is commonly used.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2104624096:73,redund,redundant,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2104624096,2,['redund'],['redundant']
Safety,"> Perhaps the feature being asked for here is a checkpointer that avoids writing NaNs --- is that correct?. I actually think having an `error=true` option to `NaNChecker` would be useful for other purposes than avoiding a nan-filled checkpoint, so I personally still think that's the best solution here, since it's also pretty simple. If the script has plots or other analyses after `run!()`, a user might not want to waste resources running all that stuff if a `NaN` is detected. (Or they might! And hence the option :) ). Unless there's a reason why that's a bad idea that I'm missing...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982910455:66,avoid,avoids,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982910455,6,"['avoid', 'detect']","['avoiding', 'avoids', 'detected']"
Safety,"> Point taken, but I think there are still Oceananigans-relevant applications where Value / Gradient boundary conditions on non-immersed boundaries are useful enough to be a ""core"" feature (e.g. imposing observed SST patterns rather than observed air-sea heat fluxes), but there is always the workaround of strongly restoring boundary-adjacent sponge regions. I think this is what many ocean modelers do to implement such boundary conditions anyway. True! I'm not aware that has ever been done, but since it's not difficult to support (notwithstanding @simone-silvestri's concerns about parallel performance) it's interesting to allow it --- agree. For future readers I want to point out that SST restoring (and similar models) are typically be implemented as a `FluxBoundaryCondition` using a piston velocity model, rather than using `ValueBoundaryCondition` (which implies a flux mediated by some diffusivity / viscosity, possibly derived from a parameterization). (`FluxBoundaryCondition` is mathematically identical to restoring in the surface grid point, though it would be a slightly different model to distribute the restoring over some depth). It could be an interesting project to explore using some parameterization-derived diffusivity together with `ValueBoundaryCondition` to predict surface fluxes, though, I'm not sure what the implications would be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452:1288,predict,predict,1288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452,1,['predict'],['predict']
Safety,"> Right yeah RegularRectilinearGrid called it grid.zC but VerticallyStretchedRectilinearGrid calls it grid.zᵃᵃᶠ to be more consistent with the curvilinear grids being added, but the output writers might not know this yet. Can we refactor the tests to use `all_z_nodes`? This could avoid issues with property names.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-791630388:281,avoid,avoid,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-791630388,1,['avoid'],['avoid']
Safety,"> Second, are there any boundary conditions imposed on the tracer at the immersed boundary? I remember there was a discussion but I don't remember the conclusion. Sorry. Boundary conditions are zero _second-order_ / diffusive flux on tracer. However, there can be non-zero advective flux as noted. > First, if `c` is the concentration of a tracer it should be non-negative. If you are picking it to be a `sine` I might suggest having `1 + sin` just to avoid negative values. That being said, I don't think it's going to have any impact on the results but might be worth trying. Fair point; using `1 + sin(x)` as the initial condition would measure leakage since the total ""mass"" is then Lx * Ly. I propose adding another tracer though specifically for that purpose since it's easy.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866298163:452,avoid,avoid,452,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866298163,1,['avoid'],['avoid']
Safety,"> Second, this is a plot of the solution for the 1D case that starts off with no motion and a Gaussian field for height. This is a nice example of geostrophic adjustment, and can certainly be compared to papers that do such things.; > ; > ![one_dimensional_shallow_water_x](https://user-images.githubusercontent.com/8239041/101361665-45e29500-386d-11eb-82d8-f440f3b07d80.gif); > ; > Third, I have done a 2D case and everything looks qualitatively the same, but it is much more diffusive. This is a plot of a slide through the centre that should reproduce the same thing as above, but the amplitudes are much weaker. This is only 64x64 so it's not very high resolution but I should probably change the advection scheme to make it more accurate.; > ; > ![one_dimensional_shallow_water_2D_x](https://user-images.githubusercontent.com/8239041/101361578-251a3f80-386d-11eb-8e59-8c02e271cfcc.gif). A sanity check would be to check whether geostrophic balance is satisfied in the center of the domain, e.g., something like the last figure from [this example](https://fourierflows.github.io/FourierFlowsDocumentation/dev/generated/OneDShallowWaterGeostrophicAdjustment/#Geostrophic-balance).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1258#issuecomment-740212374:894,sanity check,sanity check,894,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1258#issuecomment-740212374,1,['sanity check'],['sanity check']
Safety,> Seems risky... let's see how the tests do... OK... indeed... too ambitious. I'm closing.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1618#issuecomment-826248213:8,risk,risky,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1618#issuecomment-826248213,1,['risk'],['risky']
Safety,"> Since we need the performance provided by KA 0.7, and we need to use KA 0.8+ on GPU, does that mean that we should invest in developing our own CPU infrastructure (replicating what KA 0.7 offered) to achieve that performance?; > ; > Another possibility is that we re-write much of the code base to avoid the performance pitfalls we are currently facing in order to get back to the level of performance we have with current code + KA 0.7. I believe the issue is basically an interaction between some of the abstractions / indirection we have developed and the compiler, so possibly rolling back that abstraction / indirection will bring us back to where we were previously. To follow up with @vchuravy, it seems that rewriting just _some_ of the code was sufficient, so we are (probably) in the clear! The lesson learned is that we cannot slurp / splat `@kernel` function arguments, because it prevents the kernel code from being inlined.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1482198741:300,avoid,avoid,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1482198741,2,['avoid'],['avoid']
Safety,"> So what do you guys think if this tilting is implement at the AbstractBuoyancy level? If I understand correctly all buoyancy types inherit that, right? That way we'd have a keyword for the tilt (maybe tilt, gravitational_direction or gravity_projection) that would default to (0, 0, 1) and a similar option could be given to FPlane, avoiding confusion. Ah, the issue is that abstract types cannot have properties --- they can only be used to organize type parameters and dispatch.; The logic and motivation of your suggestion is sound though (avoiding code duplication through good design); we just have to come up with a different solution. A similar solution could perhaps design a more hierarchical interface to `IncompressibleModel.buoyancy`. For example, we might write. ```julia; struct Buoyancy{G, B}; gravitational_direction :: G; model :: B; end; ```. The existing subtypes of `AbstractBuoyancy` are used for `Buoyancy.model`. The user API could be. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9), model=BuoyancyTracer()); ```. or. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9),; model=SeawaterBuoyancy(gravitational_acceleration=9.81, equation_of_state=LinearEquationOfState(α=2e-4, β=8e-5))); ```. This is more verbose but could avoid some of the issues that @tomchor sees. As for `Plane` and `BetaPlane`, I agree that those models are really predicated on a thin aspect ratio assumption that has to do with gravitational accelerations, and therefore ""know"" about the direction of gravity. We could either add a property `gravitational_direction` or, perhaps, add some wrapper / helper functions for constructing coriolis forces in tilted domains (eg `coriolis = TiltedCoriolisForces(FPlane(f=1e-4), vertical_direction=(0.1, 0.0, 0.9))` which returns `GeneralCoriolis` with 3D Coriolis forces --- or something). I think we will start to run into these sorts of issues more generically, where we need to specify ""global"" parameters that impact mu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047:335,avoid,avoiding,335,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047,2,['avoid'],['avoiding']
Safety,"> Somehow, though, we can't have every module redefining `R_Earth` and using it as default, right?. I think you're right that if we are going to have a default value for this, then it should only be defined once. But if we are going to go ahead with a ""master module"" approach, then we need to implement tests. What we should avoid is people trying to change constants in the master module as a way of setting parameters. This is going to take time and effort to resolve. We should discuss in an issue, not a PR, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492631291:326,avoid,avoid,326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492631291,1,['avoid'],['avoid']
Safety,"> Thank you @navidcy! ; > ; > ; > ; > Mind if I ask how? I feel like I might have been given permission to do this last year, but just never tried it. If I don't have permission, no problem, but if I do I can learn to do this to avoid bothering others with this. . I don't have permission to give you permission. :(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1158827707:229,avoid,avoid,229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1158827707,2,['avoid'],['avoid']
Safety,"> Thank you for your help! I have installed the updated version of Julia and when running it appears to be Segfaulting when trying to add CUDA. I will open an issue with them if I cannot figure out how to solve it. Thank you again. @logan can you link the CUDA issue here please?. Also, if you haven't tried, erase everything on your `$JULIA_DEPOT_PATH` (really to be safe you should make a backup of everything there first) and then run the same script you've been running with `using Pkg; Pkg.instantiate()` on the first line. This should ""re-install"" all the packages from scratch. For context [`$JULIA_DEPOT_PATH`](https://docs.julialang.org/en/v1/manual/environment-variables/#JULIA_DEPOT_PATH) by default is `~/.julia`, I think, and that's where julia stores the package files it downloads. The hypothesis here is that at some point some package download/compilation went wrong and you have some broken code there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245639622:368,safe,safe,368,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245639622,1,['safe'],['safe']
Safety,"> That probably shouldn't have changed, can you file an issue on CUDA.jl/GPUArrays.jl? I'll have a look next week. The only change to `@allowscalar` that comes to mind is task/thread-safety, which does come at a certain performance cost (it now does a TLS lookup instead of a simple pointer check, but the cost of that should be negligible compared to the subsequent memory transfer). Seems I can't reproduce the supposed error so, sorry, my bad... Something else must have been the issue. 😔",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817385393:183,safe,safety,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817385393,2,['safe'],['safety']
Safety,"> The paper that I cited used periodic boundary conditions for the deviations in the horizontal. Not physically meaningful but it is one way to avoid the walls. Agreed. But I am arguing that there is a problem with the boundary conditions in the vertical in your script (and the tilted bottom boundary layer script in the docs). Rearranging the boundary conditions in WT2020, . <img width=""313"" alt=""Screenshot 2024-04-29 at 12 09 29 PM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/12971166/216d7f9f-6f5c-4ab7-8a73-15a0f2318aeb"">. we get $\frac{\partial b}{\partial z} = - N^{2}_{\infty} \cos {\theta}$ at $z=0$.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083473885:144,avoid,avoid,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083473885,1,['avoid'],['avoid']
Safety,"> Third, what exactly is computed in the last plot fo the integrated stress tensor? Also, have you computed these for the nonIBM case to see what the real wall does?. Sorry probably could have been clearer on this. This is just du/dy, calculated with a centered difference between the closest two fluid cells to the boundary, then integrated along the boundary line (ie. du/dy summed and multiplied by Lx). The plot above is the error between the IBM and nonIBM case. This plot here is the values themselves (dashed is nonIBM, solid is IBM); ![Bickley_dudy](https://user-images.githubusercontent.com/67593861/122993772-b4a0bf00-d375-11eb-9b60-2243077ce838.png); ; > > First, if `c` is the concentration of a tracer it should be non-negative. If you are picking it to be a `sine` I might suggest having `1 + sin` just to avoid negative values. That being said, I don't think it's going to have any impact on the results but might be worth trying.; > ; > Fair point; using `1 + sin(x)` as the initial condition would measure leakage since the total ""mass"" is then Lx * Ly. I propose adding another tracer though specifically for that purpose since it's easy. You are correct. I think the added tracer idea would be perfect. My mind was stuck on the cylinder concentration one I've done before, and didn't think about the difference here!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866308816:820,avoid,avoid,820,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866308816,2,['avoid'],['avoid']
Safety,"> This looks good! I'll approve it now but I'll leave the following suggestions if you think they're helpful:; > ; > * Add brief docstrings with a quick example; > * Change the names from `u` and `v` in the functions to something more general in order to avoid confusion. Maybe `a`, `b` or some greek letters. (I'm assuming that this works for any `Field`s, no?). I agree. Sorry that seems ""rushed"" but we need this feature for some project. But I will put these as an issue!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923295323:255,avoid,avoid,255,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923295323,1,['avoid'],['avoid']
Safety,"> This was mostly dealt with #3488 but still the implementation in #3488 requires 1 region per panel. Maybe we close this issue (to avoid confusion), and later, create a new one to enable multiple regions per panel and an associated PR (to close it)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3199#issuecomment-2044094083:132,avoid,avoid,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3199#issuecomment-2044094083,1,['avoid'],['avoid']
Safety,"> Thought: we provide the sugary syntax `.top` and `.bottom` for boundary conditions in `z`. Should we also provide east, west, south, and north, and avoid using `.left` and `.right` in the code for full clarity?. Sounds like a good idea. I think `setbc!` and `getbc` aren't fully tested so also worth adding some simple tests there. I'll open an issue to document this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589873540:150,avoid,avoid,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589873540,1,['avoid'],['avoid']
Safety,"> To start working on this I think we need an MWE. Mabye that's easy, just a simulation with constant time-step and output on TimeInterval which should, in theory, work perfectly. Wouldn't the MWE I posted above work? Or do you mean a MWE that generates round-off errors at _predictable_ times? (I cannot predict when the errors will occur in the MWE above.). > Hmm and there is one more point. Round-off error is the reason we get tiny time-steps, and we should fix that. However, that would still leave open the underlying problem, which is that the pressure correction fails for machine epsilon time-steps. So I'm wondering if in fact we should fix both issues. I agree with this point, but I feel like I'm also missing something here. Let's say we change the pressure correction so that it works for machine epsilon. Won't the pressure gradient force still depend on `Δt`? That is, won't it be larger for small `Δt`s and vice-versa? If so, this implies the pressure gradient doesn't converge with `Δt` and if so, how do we close a budget where the pressure term is important? (Maybe that's a question for another place also... I don't want to derail the discussion from the specific issue at hand.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104553427:305,predict,predict,305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104553427,1,['predict'],['predict']
Safety,> Under ColPrac people should merge their own PRs to avoid surprises but I'll take your comment as permission to merge and tag a new release :P. I have been doing that. I'm just not sure about the tagging thing so I thought it was best if you did it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1367#issuecomment-780208984:53,avoid,avoid,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1367#issuecomment-780208984,1,['avoid'],['avoid']
Safety,"> Update: I used the formulas in the paper to approximate the gradient of pressure. In a test case that is pressure dominated, I found that the accuracy imporoved by more than what the theory predicted (> 16), but that is very encouraging that we are doing something right. Note that ""4th-order"" refers to the rate of convergence of the scheme as the grid spacing is reduced. For a particular resolution (and assuming that you are in the ""asymptotic regime of convergence""), the improvement gained from higher-order scheme involves both the rate of convergence / slope of the error estimate as well as a constant (the intercept) that's specific to the problem. As a result, you usually don't have a theoretical prediction for improvement at fixed resolution, I don't think (though I suppose you might be able to generate an estimate if you are differentiating a function with easily knowable properties). Empirically we usually find that higher-order schemes reduce the constant by quite a bit! Which is good --- since we often run marginally resolved problems, improving the constant (rather than the slope/rate of convergence) turns out to be the most important benefit of a high-order scheme. The plot is super busy, but the point is hopefully illustrated: higher-order advection schemes not only converge _more quickly_ to the exact solution as resolution is increased (eg, the slopes of the lines are steeper) but _also_ have reduced error at a _fixed_ resolution (eg, the error is less for WENO5 than CenteredSecondOrder at the fixed resolution 2^7):. ![image](https://user-images.githubusercontent.com/15271942/101667154-fba01600-3a1c-11eb-824e-f3ec82367229.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741942088:192,predict,predicted,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741942088,2,['predict'],"['predicted', 'prediction']"
Safety,"> We could procede in a couple of ways from here:. Let me provide a few other options:. * Compute the 2D boolean masks for reduced operations in `x`, `y`, and `z` when forming `ImmersedBoundaryGrid`. Then, use those masks for conditional differencing of reduced fields, rather than calling `immersed_inactive_node`. * For `GridFittedBottom` and `PartialCellBottom`, as a stop gap, define these methods:. ```julia; @inline conditional_δx_f(ℓy, ℓz, i, j, k, ibg::GFBIBG, δx, r::ZIRF, args...) = ifelse(immersed_inactive_node(i, j, ibg.Nz, ibg, c, ℓy, ℓz) |; immersed_inactive_node(i-1, j, ibg.Nz, ibg, c, ℓy, ℓz),; zero(ibg),; δx(i, j, k, ibg.underlying_grid, r, args...)). ```. That use a condition based on whether `k == Nz` is immersed. This will fix fields that are reduced in `z` without increasing memory storage or doing a computation in the immersed boundary grid constructor. And that's the most common case anyways. * When building a `ReducedField`, compute the mask that has to be applied to abstract operations. Then, extend the `_derivative` constructor for the combination of a `ReducedField` argument + `ImmersedBoundaryGrid` using conditional operation. This has the advantage of avoiding the mask computation in `ImmersedBoundaryGrid` (since its only needed to do operations on reduced fields). The disadvantage is that different reduced fields have to redo the computation. Also, this only fixes abstract operations and does not fix the internal operators. We also have to update the conditional operators to throw away the immersed boundary grid for reduced fields, or throw away the immersed boundary grid inside the abstract operation. * A variant on the above approach is to compute the mask when forming `Derivative`. But then a new mask is computed for every operation. There's probably a lot of other options. Keep the brainstorming coming.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2099195353:1194,avoid,avoiding,1194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2099195353,1,['avoid'],['avoiding']
Safety,"> We have to keep masking for velocities in the hydrostatic model.; > ; > In the nonhydrostatic model, the equivalent masking procedure acts on the predictor velocity field prior to solving for pressure:. Yes, I kept that in the nonhydrostatic model. Although I think I removed it on the hydrostatic one so I'll put it back in.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1224091327:148,predict,predictor,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1224091327,1,['predict'],['predictor']
Safety,"> What is being plotted in the comparisons? It looks like 3D fields are being outputted, but the time series plots show some reduction of the 3D data. In the 1D comparisons I'm plotting the volume average over the whole domain. Sorry if that wasn't clear. > I think I might have missed something --- in the very first example, was TKE computed using a ComputedField or KernelComputedField? Are the later results in this post consistent with the first posted results?. My example script changed a bit throughout the day. In the beginning I was only using KernelComutedFields since I thought that was the source of the problem. Later I started computing the diagnostics with both KernelComputedFields and ComputedFields for comparison. Which is when I found that ComputedFields were also output incorrectly... So basically the code that I linked [in my previous comment](https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809655170), which is the most up-to-date, should be the one we should continue to use to sort this out I think. > Is there any way that any of this has to do with time-step alignment?. It's possible, but I'm not sure how to test that for now... > Lastly, why is the window slightly different from the TimeInterval? What happens when the time-interval and averaging window are the same (which appears to be our default?). I think I reported it in an issue a while ago, but basically if I set the `window` to be exactly the same as `interval` I get warnings on Oceananigans telling me that I'm calculating the average before the window is complete or someting like that (this should be easy to fix I think...). So I always set the `window` to be slightly smaller than `interval` to avoid those messages. I tried setting the `window` exactly the same as `interval` and the results were the same (plus I got a lot of those warnings...).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809905267:1715,avoid,avoid,1715,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809905267,2,['avoid'],['avoid']
Safety,"> What's the motivation for using a macro rather than multiple dispatch?. The main motivation being that we don't have to write extra functions that dispatch on the forcing, thus simplifying the time stepping code. As you point out we don't want to write _5! = 120_ new functions. The `update_source_terms!` function is already 52 lines long so I'd rather avoid having to dispatch on this function. > An argument against macros is that they make the code more obscure. It's harder to figure out what is happening because you have to find the definition of the macro. I think this is context-dependent. The purpose of a macro with a name like `@insert_forcing_u` or `@insert_forcing_term` is pretty clear. If we used dispatch then you'd still have to scroll through multiple function definitions. > Come to think of it, the user can also just define a forcing function that indexes into some constant array. Why is this not a good solution?. I think this would work pretty well. I couldn't figure out how to pass in the array to be indexed so that it can fit in the `Fu(grid, velocities, tracers, i, j, k)` signature and be available for the user to fill. Where in the model should we store the forcing array in this case?. Hmmm, actually we could make the function accept the forcing struct, e.g.; ```julia; Fu(grid, velocities, tracers, forcing, i, j, k); ```; but then we'd have to have arrays in the forcing struct, e.g.; ```julia; struct Forcing{Tu,Tv,Tw,TT,TS,TA<:AbstractArray}; u::Tu; v::Tv; w::Tw; T::TT; S::TS; u_arr::TA; v_arr::TA; w_arr::TA; T_arr::TA; S_arr::TA; end; ```; and then the forcing function is just; ```julia; Fu(grid, velocities, tracers, forcing, i, j, k) = forcing.u_arr[i, j, k]; ```. Either we have 5 array types so fields with an actual forcing function get `nothing` for the array or we have 1 array type `TA` and set the arrays for forcings with a function to something like `Array{Float64}(undef, 0)`. Might be a little too ugly but I think yeah we should be able to a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470548318:356,avoid,avoid,356,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470548318,1,['avoid'],['avoid']
Safety,"> When I set the halo to be `halo=(3,3)` I get the following error message since it wants `halo=(3,3,0)`. This seems slightly less than idea. Should we make it so that either are acceptable?; > ; > ```; > [2021/05/18 12:08:59.339] WARN Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid. -@-> /home/fpoulin/software/Oceananigans.jl/src/Grid; > ```. This is a warning, not an error right?. Yes, I think it'd be good to change the warning (since it's wrong). I would save this for another PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843321244:358,avoid,avoid,358,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843321244,1,['avoid'],['avoid']
Safety,"> Where in the model should we store the forcing array in this case?. The user would define an array in a script, declare it `const` to the compiler, and then write a function that indexes into it as a global:. ```julia; # define a; forcing(..., i, j, k) = a[i, j, k]; ```. We can also include a constructor for `Forcing` that allows the user to pass some function that defines a constant array, and set up the same functionality internally. > The main motivation being that we don't have to write extra functions that dispatch on the forcing, thus simplifying the time stepping code. As you point out we don't want to write 5! = 120 new functions. The update_source_terms! function is already 52 lines long so I'd rather avoid having to dispatch on this function. I think the problem is that our functions are trying to do too much at once. We need smaller functions that perform more atomic operations so we can dispatch on atomic operations. I don't think we need to re-invent multiple dispatch with macros. We just need to refactor the code so we can use multiple dispatch effectively.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470556414:722,avoid,avoid,722,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470556414,1,['avoid'],['avoid']
Safety,"> Work with FieldTimeSeries as if it were a 4D array (with operations ignoring the halos). To clarify, are you referring to getting broadcasting and reduction to work?. If so I would clarify this comment: we need to extend our existing broadcasting and reduction machinery for 3D fields to 4D field time series. The problem is not merely to avoid operations on halos, but also to correctly interpolate between locations on a staggered grid and correctly apply derivatives on arbitrary grids. The built-in broadcasting machinery launches kernels via `launch!` so such functionality avoids operations on halos like all other `launch!` kernels.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1641#issuecomment-835433735:341,avoid,avoid,341,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1641#issuecomment-835433735,2,['avoid'],"['avoid', 'avoids']"
Safety,> Yeah we could just do it for Metal. I was just thinking it might be just as much effort as using it for all. I think it would be more effort if we take into account the need to rebenchmark a lot of cases. I also think it adds some risk...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735296417:233,risk,risk,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735296417,1,['risk'],['risk']
Safety,"> You are passing too many parameters in the `compute!` kernel, unfortunately. GPUs have a limit on the size of the parameters you can pass (4352 bytes, and you are using 4592 bytes). Ah I see. So basically this is just a GPU limitation and there's nothing to be done in the Oceananigans/user side (apart ofc from splitting the computations)?. Also, is there a way to know at compile time whether the max parameter size is being reached? That way I can define things without ""nesting"" `Field` calls when possible (which saves memory), and use `Field` calls only when necessary to avoid this error. Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3140#issuecomment-1581740522:580,avoid,avoid,580,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140#issuecomment-1581740522,1,['avoid'],['avoid']
Safety,"> You can try incorporating the background buoyancy field into the forcing functions (formulated using the discrete form). You may also try inserting the parameters as globals rather than using the kwarg `parameters` (not sure if that will help). I'd also suggest testing whether the Smagorinsky closure affects the results of the simulation; if you can avoid using that you might be able to compile more complexity. @glwagner thanks for all these tips. I've tried them all (including using the discrete form) and the only thing that allows me to achieve the number of tracers I need is using `closure=nothing`. However I don't think that's an option for me since I will probably need the physical (KE) dissipation at some point in the research, which doesn't exist without a closure. ; Also I think `closure=nothing` prevents me from using flux boundary conditions, no?. What would you recommend as the next step?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1402856222:354,avoid,avoid,354,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1402856222,1,['avoid'],['avoid']
Safety,"> `clobber=false` is probably safer. That's what I was thinking too but apparently with NCDatasets.jl the other modes are append (`""a""`) and read-only (`""r""`) so if you're creating files for the first time (the most common use case) then clobber must be used. Otherwise you get NetCDF errors when it tries to open a non-existent file. > Named tuples are trivial to support; but maybe users don't care. Personally, I much prefer them in the JLD2OutputWriter. I actually wasn't able to get named tuples to work with JLD2 but I opened an issue about that: #562. I don't see the big advantage of a `NamedTuple` over a `Dict` in this case so I'm going to keep it simple and stick to named tuples here for now. The original point of this PR was that the documentation was wrong. `NetCDFOutputWriter` needs to be refactored a little anyways, and I'd like to add some features to it as well so I'll add support for named tuples then.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/556#issuecomment-564362931:30,safe,safer,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/556#issuecomment-564362931,1,['safe'],['safer']
Safety,> hey you need to use; > ; > ```; > DocTestSetup = quote; > function foo(x); > return x^2; > end; > end; > ```. I wanted to avoid activating it globally,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3707#issuecomment-2287869743:124,avoid,avoid,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3707#issuecomment-2287869743,1,['avoid'],['avoid']
Safety,"> is it easy to simply avoid importing the macros associated with the global logger and defining them for a custom logger instead?. You mean like defining and using `@custom_info`, `@custom_warn` for `OceananigansLogger`? That might not be great in case users want to use a different logger. I think we want to use `@info`, `@warn`, etc. and users can always go back to the base/default logger whenever they want.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/855#issuecomment-674213130:23,avoid,avoid,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/855#issuecomment-674213130,1,['avoid'],['avoid']
Safety,"> the constructors of a CuSparseMatrix are different from the ones for a SparseMatrix. Can the constructors for CuSparse be derived from Sparse? If so, we just build the sparse on CPU, and then implement `arch_array`. > It means that we will first have to create the full matrix (of size Nx * Ny x Nx * Ny!!) Or is this computationally/memory-wise restrictive?. I think you should avoid allocating the whole matrix and build the sparse representation on the fly. The sparse representation is like a graph --- we add nodes only when they exist. Once we've built the graph, we can convert it to a computationally efficient format for time-stepping on CPU or GPU. > Also it is kind of a brute force which would be quite computationally inefficient because it scales badly. I propose we get this up and running in 2D and see whether this is a feasible calculation to perform during model construction. There is the question of preconditioners / changing time-step. Do the sparse matrix implementations we work with have efficient implementations for operations like. ```julia; A += b * I; ```. where `I isa UniformScaling` and `b` is a scalar?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109680238:381,avoid,avoid,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109680238,1,['avoid'],['avoid']
Safety,> to avoid waiting on another round of tests to pass 🙃. Exactly! Takes for ever...!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2448498814:5,avoid,avoid,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2448498814,1,['avoid'],['avoid']
Safety,"> yep broadcasting works. My thought was that `plan` can be hacked to store unified memory. I still have to look at the data structure to see how to do it.; > ; > cufftxt basically works in the same way (local FFT direction distributed among the workers then transpose and nonlocal FFT). I am not sure they use unified memory but they for sure use transposes https://on-demand.gputechconf.com/gtc/2014/presentations/S4788-rapid-multi-gpu-programming-cuda-libraries.pdf. Mmm ok. Is this proposal a way to avoid cuffxt basically? I think what you outlined is somehow roughly how PencilFTTs work:. 1. FFT along local direction (dim=1); 2. Simultaneously communicate and permute data to (2, 1, 3) (or is it (2, 3, 1)?); 3. FFT along local direction (dim=2); 4. Simultaneously communicate and permute data to (3, 2, 1); 5. FFT along dim=3. At the end, the data has permutation (3, 2, 1). The backwards transform then reverses this process. `solver.storage` is actually a tuple of 3 preallocated arrays to support this algorithm. For the tridiagonal solver I think we want to use the same algorithm, except that we skip step 1 (ie the first step is to communicate and permute data with no transform). Once the two other transforms are complete we have data in the configuration (x, y, z) where z is local, and we can do a tridiagonal solve in eigenfunction space. Then we transform back and obtain data back in the (z, y, x) permutation, with z local, and copy into the pressure. We have to extend the tridiagonal solver to accomodate this kind of permutation for distributed CPU, so if we have an algorithm like the one above we can then also use it for MultiRegionGrid solves on the GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119916674:504,avoid,avoid,504,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119916674,1,['avoid'],['avoid']
Safety,"@ali-ramadhan I did not see this in PR #147 (too many lines of diff for time_steppers.jl, so i missed this).; But regarding your question about ""epsilon"", this is just an other name for parameter ""χ"" (chi).; In fact, I would prefer to have ""0.5 + χ"" i beeing called the AB-2 parameter; this way, if set to zero then ; we recover a simple first order forward time stepping.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/160#issuecomment-479312286:321,recover,recover,321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/160#issuecomment-479312286,1,['recover'],['recover']
Safety,@ali-ramadhan do we need to call `CUDA.versioninfo()`? Can we avoid this for now?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1799#issuecomment-872252367:62,avoid,avoid,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1799#issuecomment-872252367,1,['avoid'],['avoid']
Safety,"@ali-ramadhan, the docs log says:; ```; ┌ Info:;   | │ Buildkite config:;   | │ Commit branch: ""tomchor-patch-1"";   | │ Pull request: ""false"";   | │ Commit tag: """";   | │ Detected build type: devbranch;   | │ - ✘ ENV[""BUILDKITE_BRANCH""] matches devbranch=""master"";   | │ - ✔ ENV[""DOCUMENTER_KEY""] exists;   | └ Deploying to folder ""dev"": ✘; ```; Seems like buildkite will only reply from master? I don't see where that setting in buildkite is though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782282187:171,Detect,Detected,171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782282187,1,['Detect'],['Detected']
Safety,"@christophernhill is it possible to come up with a benchmark that does not use `ContinuousBoundaryFunction`, thereby avoiding the bug in #1928 ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894674873:117,avoid,avoiding,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894674873,1,['avoid'],['avoiding']
Safety,"@francispoulin @glwagner @ali-ramadhan @christophernhill ; I took a look at all the benchmarking scripts in our benchmarks folder and realized that many of them are very similar and can be unified. For example, the single script for shallow water model's strong and weak scaling differ only by one substring. ; The latest commit I pushed to this branch unifies all of the launcher and single scripts for shallow water model into three scripts. Now, at the top of the launcher script `distributed_shallow_water_model.jl`, there are two boolean variables that the user can toggle for strong vs weak scaling and mpi vs threaded parallel execution. Everything including output graphs, HTML tables, and info messages also change accordingly based on the two booleans. There are some other features that Francis and I have discussed but would like your approval first before adding them in.; Other possible additions to the script can include a for loop which wraps around the whole launcher script which loops through the strong/weak scaling and mpi/threaded parallelism options to allow for running 4 benchmarks at once. Another possible addition is to have what model is benchmarked also be an option. Granted, I could just copy and paste the shallow water model scripts and replace all instances of `shallow water` with `nonhydrostatic` or `hydrostatic` and tune some options a little bit, but then this would again cause avoidable clutter. Having what model is benchmarked as an easily changeable option can be achieved through a model setup function that dispatches what model is initialized based on a custom model type object that's passed to it. Everything else would be cosmetic formatting of outputs and info messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441:1420,avoid,avoidable,1420,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441,1,['avoid'],['avoidable']
Safety,"@francispoulin I do not know but I think it would be good to find out. `VerticallyImplicitTimeDiscretization`, despite being verbose, is actually too terse --- what we are really implementing is a _backwards_ vertically implicit time discretization. Our implementation in `QuasiAdamsBashforth2` is a first-order backwards approximation. Note that `QuasiAdamsBashforth2` is also first-order for explicit stepping, so this implementation should not change the accuracy of the scheme, I don't think. In `RungeKutta3` we implement a scheme that is backwards ""within stages"". This corresponds to some particular choice of Butcher tableau and I am not sure if it is formally 3rd order still. We might be able to develop a convergence test to an analytical solution to investigate this problem. It needs to be relatively high spatial resolution so that time-stepping errors are larger than spatial discretization errors. I propose we implement some validation tests and convergence tests in a future PR though to avoid bogging this PR down more...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1639#issuecomment-838806675:1006,avoid,avoid,1006,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1639#issuecomment-838806675,1,['avoid'],['avoid']
Safety,"@francispoulin you are correct that a source charge is added to the Poisson RHS to facilitate a solve using eigenfunctions for the homogeneous Neumann problem. The way the source charge is added is very subtle: the source is added by setting the predictor velocity boundary values (typically this means zeroing them out, when the boundary is impermeable):. https://github.com/CliMA/Oceananigans.jl/blob/4011a3431144c3a58671e5d827ab39da8fe6e948/src/Models/IncompressibleModels/pressure_correction.jl#L12. This algorithm is very subtle because one can implement it by simply _not updating the predictor velocities_ on boundaries. Changing the wall-normal values of the predictor velocity field modifies the predictor velocity divergence that contributes to the RHS of the pressure Poisson equation. The reason this is an effective source term is because the predictor velocities _do not_ satisfy the same boundary conditions as the physical velocity field (in particular, the predictor velocities have non-zero wall normal components when there is a pressure gradient on the boundary). Thus zeroing out the wall-normal predictor velocities changes the Poisson equation RHS. With some head scratching, it turns out that the modification is precisely what is needed to describe pressure gradients on the boundary. We need to write this up somewhere, not least because there's no clear reference for this algorithm in the literature. We also would like to generalize the algorithm to work for time-varying wall-normal velocities (a separate issue but worth noting here that the current algorithm does not work for this case).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-735421171:246,predict,predictor,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-735421171,7,['predict'],['predictor']
Safety,@glwagner ; All Krylov solvers have an in-place version where the first argument is a workspace that contains all storage needed by the solver.; You can recover the solution with `solver.x` or just `solution(solver)`. I wrote a section about in-place methods in the documentation:; https://jso.dev/Krylov.jl/dev/inplace/. The in-place version of CG is detailed [here](https://jso.dev/Krylov.jl/dev/solvers/spd/#Krylov.cg!). The cost in terms of storage of each solver is also documented:; https://jso.dev/Krylov.jl/dev/storage/,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387566461:153,recover,recover,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387566461,1,['recover'],['recover']
Safety,"@glwagner As you mentioned, I attempted to follow your suggestion by specifying the ```CUDA.@allowscalar```. However, I still encountered the same error on a different line. Code:; ```; function rescale!(model, energy; target_kinetic_energy = 1e-6); compute!(energy); rescale_factor = CUDA.@allowscalar √(target_kinetic_energy / energy[1, 1, 1]) ; #rescale_factor = √(target_kinetic_energy / energy[1, 1, 1]). for f in merge(model.velocities, model.tracers); f .*= rescale_factor; end. return nothing; end; ```; Error:; ```; Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question. Stacktrace:; [1] error(s::String); @ Base .\error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore C:\Users\ADMIN\.julia\packages\GPUArraysCore\GMsgk\src\GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore C:\Users\ADMIN\.julia\packages\GPUArraysCore\GMsgk\src\GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore C:\Users\ADMIN\.julia\packages\GPUArraysCore\GMsgk\src\GPUArraysCore.jl:116; [5] getindex(A::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); @ GPUArrays C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:48; [6] scalar_getindex; @ C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:34 [inlined]; [7] _getindex; @ C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:17 [inlined]; [8] getindex; @ C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:15 [inlined]; [9] getindex; @ .\subarray.jl:290 [inlined]; [10] macro expansion; @ .\multidimensional.jl:917 [inlined]; [11] macro",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2022273164:806,avoid,avoided,806,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2022273164,1,['avoid'],['avoided']
Safety,"@glwagner I am trying to run the Kelvin-Helmholtz instability example on a GPU; however, the model has failed, throwing some errors. Can someone help me to sort this error. Please find the attached error below: . using Random, Statistics. mean_perturbation_kinetic_energy = Field(Average(1/2 * (u^2 + w^2))); noise(x, z) = randn(); set!(model, u=noise, w=noise, b=noise); rescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=1e-6); growth_rates, power_method_data = estimate_growth_rate(simulation, mean_perturbation_kinetic_energy, perturbation_vorticity, b). @info ""Power iterations converged! Estimated growth rate: $(growth_rates[end])"". Error: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-2016739183:960,avoid,avoided,960,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-2016739183,1,['avoid'],['avoided']
Safety,"@glwagner I have opened a PR with the branch sb/cut-cells-experiment, on which I have been working on implementing the cut cells. To summarize the progress:. - The two-dimensional [tracer advection test case](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/tracer_advection_over_bump.jl) over a Gaussian bump is run successfully using the low resolution from the [Adcroft](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml) paper and a relatively higher resolution. Both partial cells and full cells are used. Time evolution of the passive tracer concentration is visualized. - CutCellBottom is implemented in the ImmersedBoundary module similar to PartialCellBottom, and the tracer advection test case is repeated with cut cells. No noticeable difference in the results is detected so far (with the simulation using partial cells). So, tasks 1 (a) and 2 (b) have been completed so far. Tasks 2(b) and 2(c) are being worked on right now, after completion of which tasks 1 (b) and 3 will be initiated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3123#issuecomment-1592059402:856,detect,detected,856,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123#issuecomment-1592059402,1,['detect'],['detected']
Safety,"@glwagner I've been thinking about the WENO5 algorithm based on our discussion in https://github.com/CliMA/Oceananigans.jl/discussions/2054, and I just wanted to ask a quick question to make sure I understand the problem in this issue. If I understand correctly, the WENO5 scheme calculates the advection with different advection schemes (all of which are correct regardless of the grid) and then does a weighted sum of these solutions according so some criterion. So the issue with WENO5 and StretchedGrids is not that the advection calculated is ""wrong"", it's just that the weighting of the solutions is done in a non-optimal manner, and therefore introduces errors that could be avoided, right?. Basically I'm asking the question: is it the case the shouldn't use WENO5 with stretched grids because the answer is wrong, period? Or we can use it, it's just not gonna be as accurate as it potentially could be?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1704#issuecomment-967303636:682,avoid,avoided,682,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1704#issuecomment-967303636,1,['avoid'],['avoided']
Safety,@glwagner The goal of shifting the system is to recover a positive definite matrix by adding \lambda to all eigenvalue of the problem.; The proposition of @Yixiao-Zhang is to do that by adding v_0 * v_0^T. `v_0 * v_0^T` is ONLY semi-positive definite so not all eigenvalues will be modified. But it should lead to a positive definite A + c * v_0 * v_0^T (rank-one updating) by only updating one eigenvalue (the 0 eigenvalue). I just don't understand why we will find the same solution because CG should return one solution among an infinity of solution (before the shift).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2415314678:48,recover,recover,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3802#issuecomment-2415314678,1,['recover'],['recover']
Safety,"@glwagner and @ali-ramadhan I took a quick look. ; I think you should go ahead and merge, but quick comments for future reference - . 1. there are a bunch of changes unrelated to the PR in the PR. They are probably there by accident, but the Git gods really don't like that. When done well a PR can be a very helpful record for show what needs to be changed to achieve ""X"". When the PR is polluted with random other stuff that valuable use is lost. Most git projects more diligent about avoiding polluted PRs, which can be useful. . 2. I think ultimately we want halos to just be a thing that does a slightly more general form of what is in ::PBC mode. Everything else is not in halo rules. This is where we ended up in MITgcm and is similar to what is in MPIStateArray in the DG work (I am fairly sure!). A distinction to maybe think about is a set of halo() functions that just do the stuff that does not appear in any of the equations. Anything in equations turns out to be stuff that people may want to tinker with in surprisingly interesting ways. For example someone ultimately might want to do a numerical experiment that has flux BC on some set of the one bit of a boundary, something else on another bit etc.... (people do do things like this). For better or worse having bc's better separated from halos may ultimately prove the right thing. For now I wouldn't worry about it though! . 3. Related to 2. I suspect that trying to express complicated things like hybrid bc's will eventually break reducing bc to a type. Types are good for simple things, but Type::ItsComplicated is often also needed eventually.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/371#issuecomment-528944237:487,avoid,avoiding,487,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/371#issuecomment-528944237,1,['avoid'],['avoiding']
Safety,"@glwagner this almost became stale but I think it's ready to review and possibly merge. It doesn't re-work the code like you suggest [here](https://github.com/CliMA/Oceananigans.jl/pull/2752/#issuecomment-1315578507), but it does make the functions more easily understandable on first pass by being more verbose. . It also changes the behavior of `viscosity()` and `diffusivity()`, which no longer sum over all individual closures by default when the closure is a tuple, avoiding user error (as you suggested [here](https://github.com/CliMA/Oceananigans.jl/pull/2752/#issuecomment-1273620776)). Finally it also changes the function `calc_κᶜᶜᶜ` ro `calc_nonlinear_κᶜᶜᶜ` in order to differentiate from `κᶜᶜᶜ`. Although I'm agnostic about the name and could change it to anything else. This PR used to also remove a fallback that was a bit problematic because it silently returned zero diffusivity values for closures like Smagorinsky, but it seems some other PR got around to that first before merging this one :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1398498518:471,avoid,avoiding,471,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1398498518,1,['avoid'],['avoiding']
Safety,"@glwagner, how can we avoid `collect`? E.g., at. https://github.com/CliMA/Oceananigans.jl/blob/d913858aa771f096e8ce48da132749361c8f1647/validation/elliptic_solvers/doubly_bounded_poisson.jl#L130. I tried `arch_array` but seems like we need to write some more methods for it?. ```julia; julia> r_array = arch_array(arch, reshape(interior(r), Nx * Ny * Nz)); ERROR: MethodError: no method matching arch_array(::CPU, ::Base.ReshapedArray{Float64, 1, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}); Closest candidates are:; arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; ...; Stacktrace:; [1] top-level scope; @ REPL[6]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52. julia> r_array = arch_array(arch, interior(r)); ERROR: MethodError: no method matching arch_array(::CPU, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); Closest candidates are:; arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; ...; Stacktrace:; [1] top-level scope; @ REPL[7]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1162602827:22,avoid,avoid,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1162602827,1,['avoid'],['avoid']
Safety,"@glwagner, there isn't much code in it. So, it is safe to close this PR and delete the associated branch. I will proceed with that. @navid, after some digging, I discovered that my default git pull command was set to git rebase instead of git merge following git fetch. This altered the commit history to linearize it, causing confusion in both my previous tracer advection branch and the one associated with this PR. I have now reset the default setting. My apologies for the oversight.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3222#issuecomment-1724393955:50,safe,safe,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3222#issuecomment-1724393955,1,['safe'],['safe']
Safety,"@ilyascfd welcome and thanks for opening this issue, it's very helpful!. The problem here is that `Value` is not exported by default when we write `using Oceananigans` anymore. As a result, these lines:. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/validation/stratified_couette_flow/stratified_couette_flow.jl#L103-L110. do not work. . The recommended syntax nowadays is, for example,. ```; bc = ValueBoundaryCondition(0); ```. rather than `BoundaryCondition(Value, 0)`. This change was made to avoid name conflicts with some common names in the Julia ecosystem (like `Flux`). But, it looks like the validation script was not updated when this change was made to our exported names. I opened a PR to fix it in #1982. You can fix the script yourself as well by replacing `BoundaryCondition(Value, ` with `ValueBoundaryCondition(`. PS @ilyascfd here are a few tips for writing issues that will help us solve your problem as fast as possible; * Include links to the lines that are failing so we don't have to look for them ourselves. Github is really handy for this!; * When including code in an issue, please format it with triple backticks (```). Note: we run this script during CI, so at first I was surprised that we hadn't caught this yet. But when we run the tests, we do indeed import `Oceananigans.BoundaryConditions.Value` via. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/test/runtests.jl#L20. and. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/src/BoundaryConditions/BoundaryConditions.jl#L3-L4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1981#issuecomment-918194547:538,avoid,avoid,538,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1981#issuecomment-918194547,1,['avoid'],['avoid']
Safety,@jagoosw I would say avoid the flat `LatitudeLongitudeGrid` in the testing (use periodic directions instead) in this PR,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630792224:21,avoid,avoid,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3179#issuecomment-1630792224,1,['avoid'],['avoid']
Safety,"@maleadt, I tried all combinations I could think of but I couldn't get `Codecov.submit()` to work using the `SECRET_CODECOV_TOKEN`. It was only when I added the actual token as a kwarg that worked, e.g.,; https://github.com/CliMA/Oceananigans.jl/blob/ed1fe321199fd08c28052cd23a8c1b9d68368345/.buildkite/pipeline.yml#L540. Any ideas how to avoid using the token per se?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063818500:339,avoid,avoid,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063818500,1,['avoid'],['avoid']
Safety,"@matinraayai I think it will also help us get those tests passing quicker, because keeping `GPU` will allow us to avoid refactoring a lot of existing code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2493#issuecomment-1112369281:114,avoid,avoid,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2493#issuecomment-1112369281,1,['avoid'],['avoid']
Safety,"@navidcy Hmmm, digging into Documenter.jl's Buildkite config it looks like push previews are only provided if the build belongs to a PR?. https://github.com/JuliaDocs/Documenter.jl/blob/4be8243d31a6ffdbc64d779e3f8c2fb7c61de075/src/deployconfig.jl#L719-L725 . Maybe there was no push preview here since @tomchor pushed this branch at which Buildkite ran, before the PR existed, so Buildkite did not publish a preview. Maybe if a second commit was made on this PR, it would be detected by Buildkite as a PR and therefore a preview would be published?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782289428:475,detect,detected,475,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782289428,1,['detect'],['detected']
Safety,"@navidcy Thanks for the feedback. I added a docstring for `aligned_time_step` that explains its purpose:. ```; aligned_time_step(sim). Returns a time step Δt that is aligned with the output writer schedules and stop time of the simulation `sim`.; The purpose of aligning the time step is to ensure simulations do not time step beyond the `sim.stop_time` and; to ensure that output is written at the exact time specified by the output writer schedules.; ```. ---. > 1. Why does `aligned_time_step(sim)` return a negative time-step? Is this a bug? ; > 2. Why is this fix temporary? What would a more permanent fix look like?; > ; > It seems that aligning the time-step is causing a host of issues. Is this the real problem? Should we stop aligning time-steps until we are sure that we can do it safely?. @glwagner Sorry I thought I explained the issue in #1280 but looks like I didn't. The problem has to do with checkpointing and pickup when output writers are using `TimeInterval` schedules. Output writer schedules are not checkpointed so when you pickup a simulations that includes output writers with `TimeInterval` schedules, the `model.clock` is restored but the `schedule.previous_actuation_time` is 0 for all `TimeInterval` schedules. So `aligned_time_step` thinks it needs to take a negative time step as it needs to write output at t = `schedule.time_interval`. The permanent fix is to checkpoint and pickup schedules (properly fixing #1280) which would prevent `aligned_time_step` from returning negative time steps. I see this as more of a checkpointing issue than a time step alignment issue. In general we are not extensively testing checkpointing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050:793,safe,safely,793,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303#issuecomment-766101050,2,['safe'],['safely']
Safety,"@peterahrens thanks for that tip!. @vchuravy, by closure-specific temporary variables (or fields), I am referring to domain-size quantities that can be re-used in computing the contribution of an LES closure to the 'source terms' for momentum and tracers. In other words, [this line, which computes the source term for `u`](https://github.com/ali-ramadhan/Oceananigans.jl/blob/a544300cabe6f8d872b7f9658284cad34c8619ad/src/time_steppers.jl#L223) could become something like. ```julia; kernel_temporaries!(subgrid_closure, ..., i, j, k); Gu[i, j, k] = ... + subgrid_closure.u(subgrid_closure_temporaries, ..., i, j, k); ```. ... I think. In physical terms, the intermediate variable is an 'eddy viscosity' that acts on all momentum terms. But I guess when I say the computation 'will benefit' from variables to store intermediate results, what I really mean is that I'm expecting the calculation of this temporary variable to be fairly involved (potentially >20 derivatives of velocity and tracer fields in x, y, z, plus scalar operations to combine the fields, and a 'clipping' function to make sure the viscosity is not negative --- see [the formula for the eddy viscosity predictor](https://dedales.readthedocs.io/en/latest/closures/anisotropic_minimum_dissipation.html#the-eddy-viscosity-predictor)). It is also of course possible to simply write a function that calculates the eddy viscosity, and call this function repeatedly to avoid temporaries altogether.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-468747674:1173,predict,predictor,1173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-468747674,3,"['avoid', 'predict']","['avoid', 'predictor']"
Safety,"@simonbyrne do you have any advice for how to avoid these annoying round-off errors? Basically I'm wondering if theres a robust way to get. ```; ├── Periodic x ∈ [0.0, 6.28319) regularly spaced with Δx=0.0490874; ```. here we are given the length of the domain (2pi), but then we have to construct a range of nodes which extends _left_ of 0, so that it includes our halo region. The problem is when we do that, the first face (which is then something like `range[4]` if we have 3 halo points) has round-off error (or at least that's how I'm interpreting it... maybe there's no way around it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2499#issuecomment-1113423017:46,avoid,avoid,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2499#issuecomment-1113423017,1,['avoid'],['avoid']
Safety,"@simone-silvestri I refactored the tuple halo filling (partly to shorten the code but also to filter more stuff from the tuples, and to avoid filling halos for the same fields twice --- sometimes a field can appear twice in a named tuple...) But it looks like my changes broke some stuff, so I might need some help fixing that up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2426#issuecomment-1094117367:136,avoid,avoid,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2426#issuecomment-1094117367,1,['avoid'],['avoid']
Safety,@tomchor I think it should automatically detect dimensions for `WindowedSpatialAverage` now but the solution is not pretty since `NetCDFOutputWriter` plays nicest with fields. Could probably be made clearer though.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783762674:41,detect,detect,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-783762674,2,['detect'],['detect']
Safety,"@tomchor does this result occur with just one OutputWriter, or do you have more than one OutputWriter being used at the same time?. Averaging collection is finalized here:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/OutputWriters/windowed_time_average.jl#L179-L187. when `run_diagnostic!(wta::WindowedTimeAverage, model)` is called. But the criterion that triggers output is. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/Utils/schedules.jl#L38-L52. I have to say I don't understand why we special case `time == schedule.previous_actuation_time + schedule.interval`, since `rem(time, schedule.interval)` should be 0 and the algorithm should still work. Or am I missing something? It does seem to assume that `0` is the initial time (we could avoid that maybe by saving the initial `model.clock.time`...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747092535:835,avoid,avoid,835,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274#issuecomment-747092535,1,['avoid'],['avoid']
Safety,"A few comments:. 1. Let's call this `materialize_biogeochemistry`. We would like to change the names of the functions to ""materialize"" as well.; 2. This should be avoided unless strictly necessary. Generally, this step introduces complexity and fragility to model setup. One source of insidious bugs is when the user-build `biogeochemistry` is different from `model.biogeochemistry`. Can you provide an example of when this is necessary to motivate this feature, given its serious downsides?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1714600321:163,avoid,avoided,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1714600321,1,['avoid'],['avoided']
Safety,"A long time ago, I did some scaling tests of the pure FFT algorithm. These were the results. <img width=""537"" alt=""Screenshot 2024-08-10 at 2 57 20 PM"" src=""https://github.com/user-attachments/assets/a60f2f50-13f3-4fc2-858f-8d5303ccd918"">. I will probably redo the scaling test later on after the summer. ; In general, always use slab partitioning if you can because you avoid one transposition. ; This might lead to larger halo to domain ratio, but the fill halo, contrarily to the transpose, is hidden so it should still be better to have a slab partitioning then a pencil one.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3689#issuecomment-2282246515:371,avoid,avoid,371,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3689#issuecomment-2282246515,1,['avoid'],['avoid']
Safety,"Actually `Array` and `CuArray` aren't `isbits`. But from what I understand, I think CUDAnative uses Adapt.jl to convert a `CuArray` to something like a `CuDeviceArray` which is `isbits` when passing arguments to CUDA kernels, which is what we would have to do to convert our `Field` structs to be `isbits`. But yeah, definitely agree about avoiding abstract and unspecified types. Comes with learning Julia I guess.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/19#issuecomment-477678970:340,avoid,avoiding,340,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/19#issuecomment-477678970,1,['avoid'],['avoiding']
Safety,"Actually, I think those docs are misleading. The straightforward way to arrive at the implicit step equation is to first discretize in space, and then after that derive the fractional step method. The key steps are:. 1. Discretize the continuity equation, and then sum in the vertical to obtain the finite-volume discretized free surface equation in terms of the vertically integrated transports; 2. Introduce the predictor velocities in the discretized momentum equation, and then sum the discretized momentum equation in the vertical.; 3. Combine the discretized momentum equation with the free surface equation by taking the divergence of the vertically-summed momentum equation. Steps 2 introduces the vertical sum of the discretized barotropic pressure gradient into the implicit step equation, which is how we see that these two contributions in fact come from the same place.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109690145:414,predict,predictor,414,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109690145,1,['predict'],['predictor']
Safety,"Agree this is redundant and if we aren't checking in the grid constructor, we should.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2595#issuecomment-1144794360:14,redund,redundant,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2595#issuecomment-1144794360,1,['redund'],['redundant']
Safety,"Agreed. Useful and related comment. > I was thinking of doing some prototyping and benchmarking in a sandbox by building off the example in my PR [vchuravy/GPUifyLoops.jl#18](https://github.com/vchuravy/GPUifyLoops.jl/pull/18).; > ; > The PR contains an example that can be extended to rely on a `Grid` struct, multiple `FaceField`s and ` CellField`. So I'll prototype grids and fields that are `isbitstype` (you already helped by doing this for a grid in [#59 (comment)](https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-467660181)) and test to see if they work on the GPU with GPUifyLoops.jl. If they do work and performance isn't degraded then I'll rewrite the operators to use grid and field structs.; > ; > You probably know how to do this better than me, but might be good if I rewrite the operators as they's still undocumented and do some _slightly convoluted_ stuff to avoid having to store intermediate calculations.; > ; > Right now I'm focusing on system tests and benchmarks but once @christophernhill @jm-c and I get closer to implementing the variable _Δz_ grid #47 I will work on this.; >; >_Originally posted by @ali-ramadhan in https://github.com/climate-machine/Oceananigans.jl/issues/115#issuecomment-470782067_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-470297910:902,avoid,avoid,902,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-470297910,1,['avoid'],['avoid']
Safety,Ah I think Buildkite tests did not run on this PR since we disable Buildkite on PRs from forks (to avoid random PRs executing potentially malicious code on our machines). So we usually open and merge branches from the repo itself. You should be able to do this since you're a repo collaborator.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1346#issuecomment-775428627:99,avoid,avoid,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1346#issuecomment-775428627,1,['avoid'],['avoid']
Safety,"Ah I think you forgot to squash and merge and instead created a merge commit so the image file entered git history, e.g. it's now in the `master` branch: https://github.com/CliMA/Oceananigans.jl/commit/0d10840b92e67c60c18102d5183affff993f896a. It's not a big deal since this particular file only increases the repo size by 64 KiB but in general I think we should avoid merging binary files like images into the repo since the increase in repo size is cumulative.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1650#issuecomment-839882879:363,avoid,avoid,363,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1650#issuecomment-839882879,1,['avoid'],['avoid']
Safety,Ah is it worth doing something with #3740 then so the model doesn't error with `free_surface = nothing` or would that just be misleading?. I can also update the PR to get rid of `rigid_lid.jl` to avoid confusing users into thinking a rigid lid mode exists.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3735#issuecomment-2313395254:196,avoid,avoid,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3735#issuecomment-2313395254,1,['avoid'],['avoid']
Safety,"Ah ok so I think this is just an issue with running `makedocs` multiple times after each other without cleaning up what `makedocs` has done before. So it's complaining that when it ran the `jldoctest` a second time it got this message:. ```; more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; ```. so the output is different. I guess we have 3 possible automated fixes (manual fix being to remove the files manually):; 1. We can clean up and remove these files as part of `make.jl`.; 2. Using `NetCDFOutputWriter` in `jldoctest` we should use the `mode = ""c""` kwarg to avoid the info/warning message.; 3. `jldoctest` blocks should remove files at the end of the block (and there should be a way to hide this from the docs but not 100% sure right now).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796853994:766,avoid,avoid,766,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796853994,1,['avoid'],['avoid']
Safety,Ah once the PR is merged you just do it via a comment (we comment on the latest commit): https://github.com/CliMA/Oceananigans.jl/commit/47caa85138047acb4584cf97092c62c3e59b3543#comments. You're a repo collaborator so you should be able to tag new releases. Under ColPrac people should merge their own PRs to avoid surprises but I'll take your comment as permission to merge and tag a new release :P,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1367#issuecomment-780201946:309,avoid,avoid,309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1367#issuecomment-780201946,1,['avoid'],['avoid']
Safety,"Ah sorry about that! Happy to chat over Slack but don't wanna butcher @glwagner's suggestion. I guess having the `X, Y, Z` is important for `NetCDFOutputWriter` since it uses that information to know which dimensions to assign to each variable. They could be specified manually via the `dimensions` kwarg (there should be an example of this in the docstring) but ideally the dimensions should be detected automatically for an Oceananigans field. Maybe you just need to use `reduced_location` to determine the `X, Y, Z` for the `SpatialWindowAverage`? https://github.com/CliMA/Oceananigans.jl/blob/0ff8cd8e7d4565c8493ec7b81e531599277ab645/src/Fields/reduced_field.jl#L137. Maybe something like this could work?. ```julia; function SpatialWindowAverage(field; dims, field_slicer=FieldSlicer()); X, Y, Z = reduced_location(location(field), dims=dims); return SpatialWindowAverage{X, Y, Z}(field.data, field.grid, field, field_slicer, dims); end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783553934:396,detect,detected,396,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783553934,1,['detect'],['detected']
Safety,"Ah yeah I agree that cleaning up the `Operators` module is a big and largely thankless task. Something that should be done soon though. But for `ShallowWaterModel` I don't think anything in `Operators` needs to be touched. What needs to change is where `ShallowWaterModel` uses those grid spacing operators. In other words, on a regular grid one has two options for computing grid spacing. One can either compute grid spacing by calling the function `Δx`, or by calling the function `Δxᶜᶜᵃ`. These produce the _same_ result. In order to completely clean up `Operators`, we need to change all of the ; _model code_ so that nobody uses the operator `Δx`. Once nobody uses `Δx`, that is the point at which we can safely delete it from `Operators`. If you can find where in `ShallowWaterModel` the operator `Δx` is used, and replace this with something like `Δxᶜᶜᵃ` (or the appropriate spacing operator for the correct location, thus ensuring that `ShallowWaterModel` will work on curvilinear grids as well), we have made good progress.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-848011218:710,safe,safely,710,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-848011218,1,['safe'],['safely']
Safety,"Ah, I see. Sounds like it wouldn't be trivial to add that support. I guess a workaround to avoid partially-averaged results when picking up would be to set the `Checkpointer` to only write checkpoints when the `TimeAveraged` results are also written. I'm not sure what that would do to other (more frequent) outputs though, since it'd potentially try to write some time steps twice (and not in monotonic ordering)...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3485#issuecomment-1969259005:91,avoid,avoid,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3485#issuecomment-1969259005,1,['avoid'],['avoid']
Safety,"Ahh hmm... I think you can get more diagnostics to work this way. The reason complex diagnostics fail, as discussed on #1241, is because of the recursive calls to `identity` (for example). We have to do this with `AbstractOperations` because that framework is written so that users don't have to ""know"" where their computations occur (or end up) --- at least not necessarily. In the above code, the user (you) is manually providing location information by selecting `∂zᵃᵃᶜ`; therefore we don't have to call an interpolation function (such as `identity`). This can be seen in the code in the crucial `getindex` function defined for all `AbstractOperations`, such as:. https://github.com/CliMA/Oceananigans.jl/blob/f6d65f8bd0f97c4e97d9e81b126c78c3e0d463c8/src/AbstractOperations/derivatives.jl#L25. I believe in this case that the function `d.▶` from the above is `identity`, which could fail because it's also called in the calculation of the binary operation `w * v`?. I think we could avoid some calls to `identity` in `AbstractOperations` if we restrict their generality. But I'm not sure that's the right philosophy. Maybe we just want to fix the compilation issues instead and preserve full generality in `AbstractOperations`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786817960:986,avoid,avoid,986,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786817960,1,['avoid'],['avoid']
Safety,"Also, I noticed there was an error at the very beginning, copied below. ```; TEST_GROUP=shallow_water julia --project -e 'using Pkg; Pkg.test()'; Testing Oceananigans; ┌ Error: Pkg.Resolve.ResolverError(""Unsatisfiable requirements detected for package JLLWrappers [692b3bcd]:\n JLLWrappers [692b3bcd] log:\n ├─possible versions are: [1.0.0-1.0.2, 1.1.0-1.1.4, 1.2.0] or uninstalled\n ├─restricted to versions 1.1.3 by an explicit requirement, leaving only versions 1.1.3\n └─restricted by compatibility requirements with IntelOpenMP_jll [1d5cc7b8] to versions: 1.2.0 — no versions left\n └─IntelOpenMP_jll [1d5cc7b8] log:\n ├─possible versions are: 2018.0.3 or uninstalled\n └─restricted to versions 2018.0.3 by an explicit requirement, leaving only versions 2018.0.3"", nothing); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326#issuecomment-770853975:231,detect,detected,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326#issuecomment-770853975,1,['detect'],['detected']
Safety,"Also, I tried the following that mostly worked:; ```; using Oceananigans.Grids; using Oceananigans.Models; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary. grid = RegularRectilinearGrid(size=(256, 256), x=(-10, 10), y=(0, 5), topology=(Periodic, Bounded, Flat)). # Gaussian bump of width ""1""; bump(x, y, z) = y < exp(-x^2). grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)); model = ShallowWaterModel(grid=grid_with_bump, gravitational_acceleration=1); ```. and it worked until the last line, which gave an error I copied below. I presume we should fix this before we think about doing any merging. Any suggestions @glwagner ?. ```; Warning: Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid.; └ @ Oceananigans.Grids ~/software/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ERROR: MethodError: no method matching with_halo(::Tuple{Int64, Int64, Int64}, ::ImmersedBoundaryGrid{Float64, Periodic, Bounded, Flat, RegularRectilinearGrid{Float64, Periodic, Bounded, Flat, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{typeof(bump)}}); Closest candidates are:; with_halo(::Any, ::RegularRectilinearGrid) at /home/fpoulin/software/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:218; with_halo(::Any, ::VerticallyStretchedRectilinearGrid) at /home/fpoulin/software/Oceananigans.jl/src/Grids/vertically_stretched_rectilinear_grid.jl:242; Stacktrace:; [1] ShallowWaterModel(; grid::ImmersedBoundaryGrid{Float64, Periodic, Bounded, Flat, RegularRectilinearGrid{Float64, Periodic, Bounded, Flat, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{typeof(bump)}}, gravitational_acceleration::Int64, architecture::Oceananigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844218915:816,avoid,avoid,816,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844218915,1,['avoid'],['avoid']
Safety,"An easier method might be to use a streamfunction (a field at Face, Face, Center) and use built in operators and broadcasting to calculate the velocity field and buoyancy in terms of this steam function. You avoid bringing in another package with this method and I think the result is closer to the discrete finite volume balance condition.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1826#issuecomment-874985362:208,avoid,avoid,208,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1826#issuecomment-874985362,1,['avoid'],['avoid']
Safety,Another idea: check that the grid architecture and model architecture match to avoid issues like the test failure in #1467.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-799734876:79,avoid,avoid,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-799734876,1,['avoid'],['avoid']
Safety,"Apparently the new syntax does help avoid `@allowscalar` instances, and things do compile locally for me, but the errors on buildkite are still [there](https://buildkite.com/clima/oceananigans/builds/9727#01860b25-0d9a-419e-bd01-3ec11bcb8c6b/38-603):. ```; Computations with Averaged Fields [GPU, RectilinearGrid]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-13/clima/oceananigans/test/test_computed_field.jl:583; --;   | Expression: all(interior(tke_yz) .== 9 / 2); ```. Any ideas on what might be the cause of the differences between builkite and my local server? If someone could also run one of the failing tests on a GPU locally and see if they get the same errors that buildkite is throwing, that would be helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2865#issuecomment-1414131063:36,avoid,avoid,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2865#issuecomment-1414131063,1,['avoid'],['avoid']
Safety,"As @navidcy hints I think the difficulties here are using `Plots.jl` on a headless system. To address this issue @navidcy is suggesting that you execute / write `ENV[""GKSwstype""] = ""100""` at the top of the tutorial. Alternatively, you can avoid remote plotting and attempt to run the `@animate` block locally, after downloading the data. I do think it is convenient to plot remotely however, so it'd be nice if you can make that work for you. Searching ""headless plotting julia Plots"" might turn up more information (I didn't find anything immediately, but I've seen useful threads before and it'd be nice to paste them here).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1281#issuecomment-752068938:239,avoid,avoid,239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281#issuecomment-752068938,1,['avoid'],['avoid']
Safety,"As discussed in https://github.com/CliMA/Oceananigans.jl/discussions/3177#discussioncomment-6448740 I see two solutions: either drop support for v1.8 or prior with a v1.9 compat entry, or add something like; ```Julia; if VERSION < v""1.8""; ...; else; ...; end; ```. Adding the compat requirement is safer since tests only run on v1.9. . On the other hand, in this case, allowing backwards compatibility might be just a few lines like above.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636223845:298,safe,safer,298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636223845,1,['safe'],['safer']
Safety,"As discussed via zoom with @kburns, passing a key to computations to be stored and used to determine whether a computation needs to be performed is a simple method that may work for us. A simple option for a key is the current model time, which works for all the time stepping methods we employ and has the additional advantage of interpretability. One complication is that we allow users to specify memory space for `ComputedField`s and `AveragedField`s. As a result, two `ComputedField`s that share memory space may have incorrect `data` if the memory is overwritten. This is, in fact, a problem even in the current code and not dependent on the optimizations discussed in this issue. Since we think it is important to give users the option of avoiding unnecessary memory allocation by managing the allocation of scratch space for computations, we cannot prevent incorrect output resulting from overwriting of scratch space during operations with embedded averaged fields and computed fields. We simply have to document this potential ""gotcha"". We can make avoiding repeated operations a bit safer by requiring users to enable it when a `ComputedField` or `AveragedField` is constructed by a keyword argument, something like `recompute_safely`: . ```julia; U = AveragedField(model.velocities.u, dims=(1, 2), data=scratch, recompute_safely=false); ```. When `recompute_safely` is disabled, the model time at computation will be cached. The cache can either be inside `AveragedField`, or in a global cache. (A global cache has the advantage of being on the CPU; a local cache has the advantage of being local).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/955#issuecomment-694601458:746,avoid,avoiding,746,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/955#issuecomment-694601458,3,"['avoid', 'safe']","['avoiding', 'safer']"
Safety,"Based on [this finding](https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952119253) it's not just the trig functions that are causing problems, so I agree that the statement about avoiding them shouldn't be there. I removed that and hopefully we can still merge this PR since it's a small improvement. I do think we should look into what's causing the slowdown with the trig function for me specifically though, so I created an issue for that: https://github.com/CliMA/Oceananigans.jl/issues/2034",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-956540913:195,avoid,avoiding,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-956540913,1,['avoid'],['avoiding']
Safety,Better safe than sorry :),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-798968747:7,safe,safe,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-798968747,1,['safe'],['safe']
Safety,"Billy mentioned it in some other comments but while we do splat args for some of the function calls, the function definitions use Varargs instead. This should avoid the catastrophic slowdown we saw with splatting earlier, but I agree that it should be tested. Do you have any good CPU performance tests set up @glwagner ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2150096206:159,avoid,avoid,159,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2150096206,1,['avoid'],['avoid']
Safety,"Btw, when I am doing small exploratory runs I only need to ""pay compilation time"" once per model. Constructing another model in the same REPL session doesn't have any extra compilation costs unless I change something in the source code (Oceananigans source code; node my scripts). I think my gut feeling would be against implementing such a feature, mostly because of the _test and maintain_ part you mentioned. Also because I can see sort-of-easy ways around it. Perhaps I'm missing something? E.g. I don't really quite understand what do you mean by ""safe to pick-up"" and ""due to the way pick-ups work"" in. > It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1605301393:553,safe,safe,553,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1605301393,2,['safe'],['safe']
Safety,"But this is confusing notation... can we update to use the triple notation that we use throughout the code?. The confusion is that MITgcm uses the notation `ΔzF` to denote the _difference of_ `zF`. This is _opposite_ the meaning of our superscripts, which indicate the _location_. In our notation `Δz^aaf` is the _difference of_ `z^aac`. . I suggest we just avoid these capital letters and use only superscripts...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2150#issuecomment-1012204391:358,avoid,avoid,358,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2150#issuecomment-1012204391,1,['avoid'],['avoid']
Safety,"CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S27_S13_S16_IS27_S12_S27_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S27_S27_S13_S16_IS12_S27_S27_S25_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEEES14_IS18_S18_S18_7__xz___7__yz___ES19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEE' uses too much parameter space (0x1408 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. Solution: probably some of the suggestions on #746 are useful; we might need to submit a PR to CUDA.jl for this. I think this might be the toughest of all (more argument for also resolving #1246)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593:2640,abort,aborted,2640,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593,1,['abort'],['aborted']
Safety,"Calculating trigonometric functions is ""slow"" (compared to simple arithmetic operations) on _all_ hardware because they require various series expansions and iterative calculations. Division is also ""slow""; a single division operation requires something like 20 operations. An issue with any psuedo-anecdotal advice like this is that it may not be valid on all hardware. Just how ""slow"" is `sin` on various hardware? Is it slow on all Nvidia GPUs, or just some? Is it slow on AMD GPUs? What does ""slow"" mean, exactly?. Philosophically, I disagree that trigonometric functions should be avoided. Speed is not always a primary concern for computations. Other concerns that may be equally or more important are reproducibility, programmer productivity, accuracy, etc. I think that users will probably better served by a nice comprehensive reference to floating point calculations on various hardware on CPUs and GPUs...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951424095:586,avoid,avoided,586,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951424095,2,['avoid'],['avoided']
Safety,Can someone explain the purpose of `MPI.Init()`? Is it a bad idea to call this inside `MultiArch` constructor rather than requiring users to write it out? Can we detect if it's been called in the constructor and then call _by default_ if it hasn't been called yet?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1066202040:162,detect,detect,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1066202040,1,['detect'],['detect']
Safety,Can we also avoid using index 0 even if it works this time?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2553#issuecomment-1126983885:12,avoid,avoid,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2553#issuecomment-1126983885,1,['avoid'],['avoid']
Safety,"Clearly I was very mixed up in terms of my directions but I think I have improved things and you can see my code below. - At the moment, the sponge is only to the west. Since I am imposing outflow conditions to the east I feel like I should have a second sponge there. Or, said differently, have a sponge that is zero in the interior but turns on both to the west and east. Agreed?; - Some good news is that I do seem to be imposing boundary conditions. Bad news, there is some asymmetry in that the inflow condition does no seem to be imposed at `x=-10` along the southern wall. I can't think if a physical reason why that would be the case. Any ideas?; - Is there an easy way to plot the grid? It occurs to me that if I had done this at the beginning I would have avoided a bit of trouble that I created for myself. ```; julia> model.solution.uh[:,:,1]; 14×14 OffsetArray(::Matrix{Float64}, -2:11, -2:11) with eltype Float64 with indices -2:11×-2:11:; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0. ```. ```; using Oceananigans; using Oceananigans.Grids; using Oceananigans.Models; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary. using Oceananigans.BoundaryConditions: NormalFlow. grid = RegularRectilinearGrid(size",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852958373:766,avoid,avoided,766,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852958373,1,['avoid'],['avoided']
Safety,"Dedalus adds all the ""grid-crossing frequencies"" (e.g. `u/dx`, `v/dy`, `w/dz`) at each point, takes the maximum of this quantity across all grid points, and takes its reciprocal to determine the CFL time. We chose this because its pretty simple and properly handles doppler boosting of waves on top of mean flows. Apparently according to wikipedia this is also the right thing for diagonal velocities... but I'm not sure that's something you can show rigorously for spectral methods. Maybe so. In any event, we find that the stability boundaries in terms of the CFL safety factor (scaling the `dt` selected as described) vary a lot based on the timestepper and problem, anyways.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1201#issuecomment-735250942:566,safe,safety,566,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1201#issuecomment-735250942,1,['safe'],['safety']
Safety,Did you try avoiding broadcasting ? That's the first thing to do. Then we can take a closer look at the initial condition function and see if there's more to change.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1115990673:12,avoid,avoiding,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1115990673,1,['avoid'],['avoiding']
Safety,"During the coefficients down to 1e-9 (!!) allows 3 stable time steps _when continents / bathymetry are removed_:. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 226.942 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (288.084 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.446 seconds).; ┌ Info: Iteration: 1, time: 20 minutes, wall time: 1.452 seconds; │ ├── max(u): (1.32e-16, 5.40e-02, 6.44e-04) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 5.93e-01 m; ┌ Info: Iteration: 2, time: 40 minutes, wall time: 945.169 ms; │ ├── max(u): (1.39e-02, 1.06e-01, 1.05e-03) m s⁻¹; │ ├── extrema(T): (0.05, 30.00) ᵒC; └ └── max|η|: 1.33e+00 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 1 hour, wall time: 945.031 ms; │ ├── max(u): (3.55e-02, 1.52e-01, 1.37e-03) m s⁻¹; │ ├── extrema(T): (0.15, 30.00) ᵒC; └ └── max|η|: 2.08e+00 m; ```. But when they're put back, it still blows up (even with coefficients 1e-9):. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = ImmersedBoundaryGrid on:; architecture: CPU(); grid: 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bound",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807:624,risk,risk,624,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807,1,['risk'],['risk']
Safety,EDIT: Sorry I see now that it's to avoid additional allocation :) https://github.com/CliMA/Oceananigans.jl/blob/24710f4b9d3733d09f8af0eb459eb9984908175a/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl#L108. I'm trying to implement a multigrid equivalent of the PCG implicit free surface solver but I don't understand why we need this field https://github.com/CliMA/Oceananigans.jl/blob/aea5494a763eb3949b234b5302ddb0a2e9764678/src/Models/HydrostaticFreeSurfaceModels/pcg_implicit_free_surface_solver.jl#L25. I thought the right hand side would change each iteration and is passed to the `solve!` function?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1168091279:35,avoid,avoid,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1168091279,1,['avoid'],['avoid']
Safety,"Exactly, in practice a transpose is communication + permutation, but with `unified_memory` we avoid the communication part (I mean it is there but it's handled by CUDA)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119919377:94,avoid,avoid,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119919377,1,['avoid'],['avoid']
Safety,"Excellent!. To summarize:. 1. A `materialize_biogeochemistry` feature may still be needed sometime in the future; 2. Generally we think it's best to avoid this step if possible, for a few reasons:; - code that relies on this step may end up unnecessarily complicated or convoluted; - materializing objects leads to a distinction between user input and model properties that can produce hard-to-find bugs; - it can be complicated to maintain a `materialize_X` feature.; 3. For the specific problem considered here, we can probably find a solution that avoids `materialize_biogeochemistry`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1719382840:149,avoid,avoid,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1719382840,2,['avoid'],"['avoid', 'avoids']"
Safety,"Extrinsic is what we decide. When we use the cubed sphere we want to use geographic coordinates. But vector fields on the c-grid have their own coordinate system dictated by the structure of the grid. Except for `LatitudeLongitudeGrid`, the geographic coordinate system does not coincide with the ""other"" coordinate system (I called it intrinsic above, but if this is confusion we need another name) that's associated with the grid. What language would you like to use to describe (1) the coordinate system that we would like to impose on the grid for the user interface and 2) the coordinate system that the raw vector fields use (I'm trying to avoid the language I proposed to ask this question).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3625#issuecomment-2187115309:646,avoid,avoid,646,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3625#issuecomment-2187115309,1,['avoid'],['avoid']
Safety,Finally all type issues have been resolved using three different fixes; - Ensure that `apply_regionally!` and `construct_regionally` are always inlined; - Avoid any Generator in the `getregion` function but explicitly pass arguments to it by using metaprogramming to input the correct expression; - Use alternating inner and outer `getregion` to force compilation through recursive use; - For `Tuple`s force compilation by recursive getregion based on tuple's size,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116006280:155,Avoid,Avoid,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116006280,1,['Avoid'],['Avoid']
Safety,"For those following this thread the [SGRID PR](https://github.com/xgcm/xgcm/pull/559#pullrequestreview-1383786186) mentioned above has now been merged to add SGRID functionalities into [xgcm](https://github.com/xgcm/xgcm). Please do try out if useful.; There are some docs for it [here](https://xgcm.readthedocs.io/en/latest/grids.html) describing to to have it automatically detect and extract an SGRID grid, and I'm happy for feedback/questions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1507314745:376,detect,detect,376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1507314745,2,['detect'],['detect']
Safety,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575:1307,avoid,avoid,1307,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575,2,['avoid'],['avoid']
Safety,"Haha it did take a while but with a satisfying ending!. And thanks for the suggestion! I didn't realize that `4.1.1` and `^4.1.1` would be the same here. But since it's okay with you, I'll merge to avoid waiting on another round of tests to pass :upside_down_face:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2448306882:198,avoid,avoid,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2448306882,1,['avoid'],['avoid']
Safety,"Have you tried using `wc = Field(w*c, indices=(:, 1, :))` and also `wc_avg = Average(w*c, dims=2)`? This would allow you to avoid using the `indices` kwarg.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1438706195:124,avoid,avoid,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1438706195,1,['avoid'],['avoid']
Safety,"Here's some benchmarks against the current implementation. Contrary to what I just claimed, there is some speed up for `Bounded` domains, especially with 2D problems (where avoiding halos is advantageous) -- but nothing too significant. Note these are with `WENO5` advection, which should pessimize `Periodic` models as there are larger halos to fill. I came to the prior conclusions by running the two-dimensional turbulence example. I'll try to make sure the ""speed up"" is generic and also benchmark GPU and the hydrostatic model. # `main`. ## Modest 3D model (128x128x128). ```; Topologies benchmarks; ┌───────────────┬─────────────────┬────────────────────────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────┼────────────────────────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Periodic) │ 900.894 ms │ 901.887 ms │ 902.516 ms │ 905.129 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Bounded) │ 895.527 ms │ 911.386 ms │ 910.441 ms │ 921.211 ms │ 772.19 KiB │ 1131 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Bounded) │ 900.389 ms │ 904.161 ms │ 906.879 ms │ 916.145 ms │ 771.44 KiB │ 1115 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Bounded) │ 903.676 ms │ 910.638 ms │ 910.295 ms │ 914.968 ms │ 837.97 KiB │ 1154 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Bounded) │ 886.053 ms │ 892.564 ms │ 894.281 ms │ 904.917 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Periodic) │ 910.500 ms │ 924.085 ms │ 923.571 ms │ 931.683 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Periodic) │ 914.391 ms │ 916.636 ms │ 916.407 ms │ 917.164 ms │ 575.12 KiB │ 1010 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Periodic",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728:173,avoid,avoiding,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728,1,['avoid'],['avoiding']
Safety,"Here's the docstring before this PR. ```julia; help?> Oceananigans.Fields.FunctionField; FunctionField{LX, LY, LZ}(func, grid; clock=nothing, parameters=nothing) where {LX, LY, LZ}. Returns a FunctionField on grid and at location LX, LY, LZ. If clock is not specified, then func must be a function with signature func(x, y, z). If clock is specified, func must be a; function with signature func(x, y, z, t), where t is internally determined from clock.time. A FunctionField will return the result of func(x, y, z [, t]) at LX, LY, LZ on grid when indexed at i, j, k. ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. FunctionField{LX, LY, LZ}(func::FunctionField, grid; clock) where {LX, LY, LZ}. Adds clock to an existing FunctionField and relocates it to (LX, LY, LZ) on grid. ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. FunctionField(L::Tuple, func, grid). Returns a stationary FunctionField on grid and at location L = (LX, LY, LZ), where func is callable with signature func(x, y, z).; ```. Three docstrings come up. But we only want users to use one of them. Moreover the second one is actually redundant with the first and provides no new information. The last one is supposed to be for internal use only. But as a user who is new to julia (perhaps), you may see only the last docstring. This is what happened over on the discussion linked at the top.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3678#issuecomment-2269968189:1270,redund,redundant,1270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3678#issuecomment-2269968189,1,['redund'],['redundant']
Safety,"Hi @tomchor There are a few examples of SGRID datasets listed on the original [xgcm sgrid issue](https://github.com/xgcm/xgcm/issues/109). I can also dig these out on my computer and share via email if you need - let me know. When you say documentation, is that the general [SGRID documentation](https://sgrid.github.io/sgrid/), or the [specific xgcm documentation relating to SGRID](https://xgcm.readthedocs.io/en/latest/grids.html#detecting-axes-from-dataset-attributes)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1516623832:433,detect,detecting-axes-from-dataset-attributes,433,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1516623832,1,['detect'],['detecting-axes-from-dataset-attributes']
Safety,"Hi both, Thanks for the quick replies on this. I agree that it seems like it is likely coming from the background gradient and lack of periodicity when applied to the hydrostatic presssure. As far as I can tell there aren't any problems for passive scalars which supports that interpretation. As an aside, I think that there are also boundary artifacts in the internal_wave.jl example (although you need to run the simulation longer and you can't see them with the default contouring of the plots). . A solution that should work is to implicitly cancel the hydrostatic pressure gradient associated with the background field with the buoyancy term. This is what we do in Diablo (although we don't decompose the pressure into hydrostatic and nonhydrostatic components). Implementing this is simple since you just don't include the background gradient when calculating the hydrostatic pressure. The only trouble that I see is figuring out when to do this. In other contexts you want to keep this term. E.g. in the geostrophic adjustment problem, the hydrostatic pressure gradient is needed to drive the flow. Maybe it would be safe to exclude the background buoyancy field in the calculation of the hydrostatic pressure anytime when the topology is periodic in the vertical direction?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1783557267:1124,safe,safe,1124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1783557267,2,['safe'],['safe']
Safety,"Hi folks. I just saw this issue. We are very glad that you're working to support interoperability btw oceananigans and xgcm! 🎉 We'd love to help however we can. Ideally you would not have to really do much here other than use CF conventions in your netCDF output and things would ""just work."" That's the beauty of standards. Unfortunately, CF conventions don't quite provide the right vocabulary to describe the curvilinear geometry of staggered grid models compactly (see https://github.com/cf-convention/discuss/issues/5). In the meantime, every modeling center seems to have their own preference for how to encode this (e.g. [comodo conventions](https://web.archive.org/web/20160417032300/http://pycomodo.forge.imag.fr/norm.html) [now offline] used by ROMS and NEMO, [S-grid](https://github.com/sgrid/sgrid), [mosaics](https://extranet.gfdl.noaa.gov/~vb/talks/grids-short.pdf) from GFDL). . With xgcm, we decided to use the Comodo conventions (rather than invent yet another new convention). In retrospect, this was maybe the wrong choice, since the pycomodo project seems to have totally disappeared. 🤦 However, if you put the [right metadata](https://xgcm.readthedocs.io/en/latest/grids.html#detecting-axes-from-dataset-attributes) in your attributes, xgcm should be able to figure out your grid. Whatever you do, please try your best to squeeze your data into existing standard file formats and metadata conventions. ; Don't invent something new. MITgcm did this with the mds data format and it has been endless headaches for our community. I don't know what JLD2 is, but it sounds like you could be going down that route... If you have any questions, please ask! I'll try to respond.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134:1197,detect,detecting-axes-from-dataset-attributes,1197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134,1,['detect'],['detecting-axes-from-dataset-attributes']
Safety,"Hi, PencilArrays / PencilFFTs author here. I'd be happy to help solving this issue, and I'd also welcome any ideas that would help improve the PencilArrays interface and docs. I am not familiar with how you define your domain partition. However, from the point of view of PencilFFTs, there is one restriction, which is that the first dimension (`x`) must *not* be decomposed in physical space. This is because FFTs are first performed along this dimension (along which data is contiguous, as usual for Julia arrays). Also, to avoid potential issues, your eigenvalues should be `PencilArray` wrappers. For now, PencilArrays allows broadcasting together `PencilArray`s and regular `Array`s, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. So I'm thinking about changing the current behaviour in the future -- and improving documentation on this. Finally, when you write:. ```julia; xc = b = solver.storage[2]; ```. you probably mean `xc = solver.storage[3]` (or, equivalently, `last(solver.storage)`, as in [this example](https://jipolanco.github.io/PencilFFTs.jl/dev/generated/in-place/#Applying-plans)). `storage[2]` holds an intermediate state that has no ""physical"" meaning, since it has been overwritten by the end of a transform. I should clarify all this in the in-place transforms example... Feel free to ping me if things are unclear in the docs or if I can provide any other information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088:526,avoid,avoid,526,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088,2,['avoid'],['avoid']
Safety,Hm... I also noticed they were defined here:; https://github.com/CliMA/Oceananigans.jl/blob/a3faff771f3dec60be12cc7fab8ebabeffc1657e/test/test_time_stepping.jl#L202; so I thought the code I removed was redundant. But perhaps some tests were using that... I'll look into it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2016#issuecomment-946342621:202,redund,redundant,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2016#issuecomment-946342621,1,['redund'],['redundant']
Safety,"Hmm... we'd have to convert this to an array, and then convert back for this to work automatically. A simple fix to start could just be to avoid saving boundary conditions when they contain references to an array. Is it possible to use `has_reference(CuArray, boundary_conditions)`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/420#issuecomment-532780341:139,avoid,avoid,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/420#issuecomment-532780341,1,['avoid'],['avoid']
Safety,"Hmmm, doesn't rectilinear imply orthogonal?. `RegularRectilinearOrthogonalGrid` might be a little redundant?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782295162:98,redund,redundant,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782295162,1,['redund'],['redundant']
Safety,"How about `PrimitiveSolutionLinearHeight`? It might be redundant to refer to the surface as ""free"" in the context of the shallow water equations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1339#issuecomment-772789508:55,redund,redundant,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1339#issuecomment-772789508,1,['redund'],['redundant']
Safety,"How about this?. ```julia; @warn ""Inflating model grid halo size to ($Hx, $Hy, $Hz) and recreating grid. "" *; ""The model grid will be different from the input grid. To avoid this warning, "" *; ""pass halo=($Hx, $Hy, $Hz) when constructing the grid.""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1501#issuecomment-804961658:168,avoid,avoid,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1501#issuecomment-804961658,1,['avoid'],['avoid']
Safety,"I actually appreciate the verbose-ness of the grid show functions (actually most of Oceananigans show functions in general). So I can only assume that more beginner users appreciate that as well, since it makes extremely clear what the grid characteristics are. I also don't think there's a very important downside to being verbose here, so I'd vote to keep the same style. Although I agree that we could get rid of some redundant information. My suggestion would be something like:. ```julia; julia> grid = RectilinearGrid(size=3, z=[0.0, 0.2, 0.5, 1.0], topology=(Flat, Flat, Bounded)); RectilinearGrid{Float64, Flat, Flat, Bounded} on the CPU(); domain: x ∈ [1.0, 1.0], y ∈ [1.0, 1.0], z ∈ [0.0, 1.0]; topology: (Flat, Flat, Bounded); size (Nx, Ny, Nz): (1, 1, 3); halo (Hx, Hy, Hz): (0, 0, 1); z spacing: Stretched, with min=0.2, max=0.5; ```. In other words, I'd remove the flat dimensions (since that's unnecessary), and clean and align the `z` spacing statement. I'd also keep the ` topology: (Flat, Flat, Bounded)` because the line `RectilinearGrid{Float64, Flat, Flat, Bounded}` might not be very intuitive to everyone. If a shorter show is necessary in some places maybe we could create something like `short_show`? (Or maybe define `show` differently based on the display?: https://schurkus.com/2018/01/05/julia-print-show-display-dump-what-to-override-what-to-use/)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971810297:421,redund,redundant,421,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971810297,2,['redund'],['redundant']
Safety,"I agree that `z_faces` is clearer! I just wanted to be sure we were talking about the same changes. I believe that specifying the grid with `z_faces` does indeed require knowledge of the number of grid points, because the user specification depends on the vertical _index_. The case of a uniform grid illustrates this point: `z_faces = k -> (k - 1) * Lz / (Nz + 1)` for `z = (0, Lz)`. Note that the keyword argument `z` is redundant, since it can be inferred from `z_faces` (by evaluating `z_faces(1)` and `z_faces(Nz+1)`. Thus I am not sure I agree that we should require the `z` keyword argument when `z_faces` is supplied. I think it'd be nice to have both a ""discrete"" interface that uses the `z_faces` or `z_cell_interfaces` keyword argument, as well as a ""continuous"" interface that accepts a ""mapping"" or ""stretching"" function as I described above. With a ""continuous"" interface, the interval kwarg `z` is required because it cannot be inferred from `z_stretching` or `z_map` (whichever we prefer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490:423,redund,redundant,423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490,2,['redund'],['redundant']
Safety,"I agree that it'd be good to have a different name for them to avoid confusion. I think `thermodynamics` is not very intuitive, but I do agree with the name `active_tracers`. We would need to change the name `SeawaterBuoyancy` though, like you mentioned.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-949813544:63,avoid,avoid,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-949813544,2,['avoid'],['avoid']
Safety,"I agree that your example does assign the first halo points correct. . We are using the main branch now and indeed we are trying to use higher order schemes near the boundary, a bad idea, and we will try and avoid that. . I looked over #2603 and can you point out where, say 3rd order upwinding switches to 1st order near the boundaries? That should help us to modify our forcing function appropriately. A more general piont is, if we never want to use the extra two halo points, why do we define them? Wouldn't it be more cost efficientive to only define them in the periodic case, and have smaller halos in the bounded case?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182107240:208,avoid,avoid,208,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182107240,1,['avoid'],['avoid']
Safety,"I also don't feel we can motivate this feature unless we understand the specific thing we are going for and ensure that it can't be achieved otherwise. It has wider implications too, because if we can't move away from the `materialize_x` pattern, then we can commit to supporting it. We've discussed at various times trying to eliminate the `materialize_x` step, and ways to avoid having it. A similar example pertains to grids and halos. We've decided that it's best to throw an error when the grid halo is not adequate for the chosen advection scheme. Previously, we had the notion that we might ""automatically expand"" the grid within the model constructor if the halo was not correct. So, let's discuss.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1717609010:375,avoid,avoid,375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1717609010,1,['avoid'],['avoid']
Safety,"I also reported this on https://github.com/CliMA/Oceananigans.jl/issues/3056, so maybe we should close this to avoid multiple issues of the same problem. I don't have a PR specifically trying to fix that, but it is possible that https://github.com/CliMA/Oceananigans.jl/pull/3606 fixes, or least ameliorates, the issue. @mncrowe can you test your simulation on that branch and check if you see the same behavior?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3614#issuecomment-2150439493:111,avoid,avoid,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3614#issuecomment-2150439493,1,['avoid'],['avoid']
Safety,"I also think it'd be fun to try to automatically detect the appropriate device. Something like. ```julia; function GPU(); has_cuda_device = has_cuda(); has_amd_device = AMDGPU.has_rocm_gpu(); has_cuda_device && has_amd_device && # this user is blessed with CUDA _and_ ROCm!!; throw(ArgumentError(""Both a CUDA _and_ an AMD GPU are detected! One of them must be selected for the GPU architecture"")). has_cuda_device && return CUDAGPU(); has_amd_device && return ROCMGPU(). throw(ArgumentError(""Cannot build GPU architecture because neither a CUDA GPU nor an AMD GPU were detected!"")); end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112418189:49,detect,detect,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112418189,3,['detect'],"['detect', 'detected']"
Safety,"I am not very familiar with this use of scan, and despite ""cumulative sum"" sounding redundant, it express to me better the idea that I am not simply summing all values of a series. I think that this is the reason why `cumsum` is so common.; I agree that we might not find a perfect word for that... haha; However, I was thinking that `CumulativeScan` also works. Scan gives this idea of an action moving through the series and Cumulative suggests that we are summing terms as we move through.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2105535912:84,redund,redundant,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2105535912,2,['redund'],['redundant']
Safety,"I attempted to reproduce the issue using the 1D diffusion example in the same environment, but I was unable to do so. After picking up the checkpoint, the output saving interval looked normal (not saving every iteration). The simple example is demonstrated as follows: [here](https://github.com/liuchihl/internal-tide-mixing/blob/3D-realtopo-delta-glw-background-flux-div/oneD_diffusion_checkpoint_test.jl). . Our initial guess is that it might be related to #3056. However, after conducting some tests, such as avoiding setting intervals to transcendental numbers, the output saving interval after picking up the checkpoint is still 1 iteration for a while (which is not the desired behavior). I noticed that when I use `IterationInterval` instead of `TimeInterval`, the problem is resolved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2244122542:512,avoid,avoiding,512,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2244122542,2,['avoid'],['avoiding']
Safety,"I can approve this but I am concerned about the benchmarking being contained in another package. What's the reason for this? For example, we already have a `benchmark` directory in the code, which not only has some custom source code in `benchmark/src` but many benchmarking scripts. It seems that rather than address the issue with this code (which has a lot of stale stuff) we are trying to skirt / avoid the problem by creating another repo. Ultimately though this just leads to lower quality code across the board since its not clear whether we are supposed to continue to maintain `benchmark` or move to `NESAPOceananigans`. Eventually _somebody_ will have to address this, right? Who will do that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3658#issuecomment-2246632050:401,avoid,avoid,401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658#issuecomment-2246632050,2,['avoid'],['avoid']
Safety,"I can create a separate issue to address this, but perhaps more importantly, I don't see the interior velocity `V∞` being added anywhere there except in the BCs. Usually we add it as a background field to avoid inertial oscillations, and indeed it used to be done like that in [older versions of the docs](https://clima.github.io/OceananigansDocumentation/v0.73.8/generated/tilted_bottom_boundary_layer/), but at some point this was changed and I don't really understand why (nor can I pinpoint where). I think it's okay to run the example without adding it as a background field, but then we're solving the problem in a reference frame that's moving with the interior flow and that should be made explicit, and I don't see that explanation there. Personally, I'm in favor of including `V∞` as a background field because it's simpler. CC @hdrake @glwagner who were in https://github.com/CliMA/Oceananigans.jl/pull/3581",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3813#issuecomment-2388670415:205,avoid,avoid,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3813#issuecomment-2388670415,2,['avoid'],['avoid']
Safety,"I checked and this seems to work:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));. julia> model = NonhydrostaticModel(grid=grid); NonhydrostaticModel{CPU, Float64}(time = 0 seconds, iteration = 0) ; ├── grid: RectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=4, Ny=4, Nz=4); ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> noise(x, y, z) = 100+randn(); noise (generic function with 1 method). julia> set!(model, u=noise). julia> simulation = Simulation(model, Δt=100, stop_iteration=200); Simulation{typename(NonhydrostaticModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0; ├── Next time step: 1.667 minutes; ├── Elapsed wall time: 0 seconds; ├── Stop time: Inf years; ├── Stop iteration : 200.0; ├── Wall time limit: Inf; ├── Callbacks: typename(OrderedCollections.OrderedDict) with 4 entries:; │ ├── stop_time_exceeded => typename(Callback); │ ├── stop_iteration_exceeded => typename(Callback); │ ├── wall_time_limit_exceeded => typename(Callback); │ └── nan_checker => typename(Callback); ├── Output writers: typename(OrderedCollections.OrderedDict) with no entries; └── Diagnostics: typename(OrderedCollections.OrderedDict) with no entries. julia> simulation.callbacks[:nan_checker].func.erroring = true; true. julia> run!(simulation); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (454.946 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.370 ms).; ERROR: time = 10000.0, iteration = 100: NaN found in field u. Aborting simulation.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.Simulations.NaNChecker{NamedTuple{(:u,), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, RectilinearGrid{Float64, Period....; ....; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2087#issuecomment-986101637:1629,Abort,Aborting,1629,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2087#issuecomment-986101637,1,['Abort'],['Aborting']
Safety,"I don't believe there is a strong need for this example as it is. Considering that #1430 is using two-dimensional turbulence a as a test case, and that might become an example, this PR seems a bit redundant. That is why I will close this but happy to return to it if there is interest. There was mention of introducing beta and looking at the development of zonal jets. This is easy enough to do and could be fun, but not sure if this warrents an example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-799461263:197,redund,redundant,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1365#issuecomment-799461263,1,['redund'],['redundant']
Safety,"I don't know this fits here, but I was thinking about a way to have a separate repository for examples from community that doesn't affect the test running time of the main repo. . The repo could generate a wiki-like page with the examples. We could give a code template for the simulations. For instance, all simulations must inform and check the version of Oceananigans and it's dependencies. Or maybe containing a yml equivalent for Julia project. What do you guys think? . I know this can get messy.. but it could be a nice way to avoid people reinventing the wheel while making their own simulations. With enough time, almost any experiment will have some others similar.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062498801:534,avoid,avoid,534,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062498801,1,['avoid'],['avoid']
Safety,I don't think so.; Now both `h` and `z` are just floats so the `.` you suggest is redundant.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3530#issuecomment-2030090662:82,redund,redundant,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3530#issuecomment-2030090662,1,['redund'],['redundant']
Safety,"I guess it does if you do `interpolate` outside a kernel. To avoid scalar operations, `interpolate` has to be wrapped in a `@kernel`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1277733108:61,avoid,avoid,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1277733108,1,['avoid'],['avoid']
Safety,"I guess part of the confusion is that some kwargs are for users while others were introduced for checkpointer usage. I agree that `timestepper_method` and `timestepper` are redundant. We should be able to just do something like `time_stepper = AdamsBashforth2()` for something. Or go with your suggestion on Slack of having the choice of either passing a Symbol for a full struct. Users might usually pass `tracers = (:a, :b)` but checkpointer might pass `tracers = TracerFields(...)`. > It's probably best if we assign only one keyword argument to each ""concept"", for the sake of simplicity and interpretability. I'm totally on board with this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/647#issuecomment-592499852:173,redund,redundant,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/647#issuecomment-592499852,1,['redund'],['redundant']
Safety,"I guess we can avoid using `Flat` for the moment and that looks to fix the problem. @fadaie91 , did you want to try this with the example and your original problem?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2798#issuecomment-1306151916:15,avoid,avoid,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2798#issuecomment-1306151916,1,['avoid'],['avoid']
Safety,I guess when there are no tracers you want to avoid showing kappa.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2443#issuecomment-1100804033:46,avoid,avoid,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2443#issuecomment-1100804033,1,['avoid'],['avoid']
Safety,"I have been running on the system Julia for these, I attempted to do my own install but I do not think I ended up doing much with it. I believe `gcc` is a dependency for the subsequent modules as for example when I run:; ```; module --force purge; module load ncarenv/23.10 ; module load ncarcompilers/1.0.0; ```; the last line returns ; ```; Lmod has detected the following error: These module(s) or; extension(s) exist but cannot be loaded as requested: ""ncarcompilers/1.0.0""; Try: ""module spider ncarcompilers/1.0.0"" to see how to load the module(s).; ```; which does not happen if I include `gcc`. I was also able to run my code without netcdf!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258913846:352,detect,detected,352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258913846,1,['detect'],['detected']
Safety,"I have tried to follow the discussion but think I missed an important bit, sorry if it was stated above. @navidcy : what's the motvation for building `A` explicitly in the multigrid method? . As has been said before, this is very expensive in 3D and hope we can avoid it if possible. But I say this having forgotten most of what I used to know about mulgrid methods. ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109798525:262,avoid,avoid,262,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109798525,1,['avoid'],['avoid']
Safety,"I like it! The concept a function name that is something like `take_action_on(argument)` is typical, eg the function `fill!(array, value)` rather than `fill_value!(array, value)` (which is redundant for the reader). I liek the readability of `mask_immersed = 0`, as in ""mask immersed [grid cells with] = value"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1528236585:189,redund,redundant,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061#issuecomment-1528236585,1,['redund'],['redundant']
Safety,I like kwarg because it’s more verbose. ; Is there any other reason why it should be positional?; As you said `grid=grid` can be avoided although some people like it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3250#issuecomment-1710017077:129,avoid,avoided,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3250#issuecomment-1710017077,1,['avoid'],['avoided']
Safety,"I looked briefly at the code but don't understand it fully. However, I didn't see a construction that I was expecting. I think we need grid constructors that take `architecture` as a positional argument:. ```julia; RectilinearGrid(arch=CPU(); keyword_arguments...) = ...; ```. Then, the `Distributed` module needs to define special grid constructors that dispatch on `architecture::MultiArchitecture`. These constructors will return only the _local_ grid for each process. This pattern will allow us to avoid having to define things like `DistributedNonhydrostaticModel`, etc. Perhaps this will allow us to achieve the pattern that you're referring to @simone-silvestri where `Distributed` has precedence over `Models`. I guess if we were to fracture the Oceananigans repo into ""finite volume specific code"" and ""physics specific code"", it certainly would be the case that the physics specific code would depend on the finite volume utilities.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594690:503,avoid,avoid,503,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594690,1,['avoid'],['avoid']
Safety,I merged main but cancelled the CI to avoid clutter. We should restart the CI when there is no other PR running CI tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2147#issuecomment-1013760179:38,avoid,avoid,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2147#issuecomment-1013760179,1,['avoid'],['avoid']
Safety,"I noticed there was a problem with the halos so I hard coded it to be `(3,3)`, which is appropriate for the default advection scheme. Now the example seems to yield `NaNs`, which is another mystery. Maybe the halos are not set correctly?. ```; Time stepping ShallowWaterModel: Time stepping ShallowWaterModel: Error During Test at Error During Test at Time stepping ShallowWaterModel: /storage7/buildkite-agent/builds/tartarus-mit-edu-11/clima/oceananigans/test/test_distributed_models.jl:496; --; &nbsp; | Got exception outside of a @test; &nbsp; | Time stepping ShallowWaterModel: time = 1.9999999999999998, iteration = 2: NaN found in field uh. Aborting simulation.; &nbsp; | Stacktrace:; &nbsp; | [1] error(::String) at ./error.jl:33; &nbsp; | [2] error_if_nan_in_field at /storage7/buildkite-agent/builds/tartarus-mit-edu-11/clima/oceananigans/src/Diagnostics/nan_checker.jl:22 [inlined]; &nbsp; | [3] run_diagnostic!(::NaNChecker{IterationInterval,NamedTuple{(:uh,),Tuple{Field{Face,Center,Center,CPU,OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Flat,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Float64,NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{HaloCommunication,Oceananigans.Distributed.HaloCommunicationRanks{Int64,Int64}},BoundaryCondition{HaloCommunication,Oceananigans.Distributed.HaloCommunicationRanks{Int64,Int64}}},CoordinateBoundaryConditions{Nothing,Nothing}}}}}}}, ::ShallowWaterModel{RegularRectilinearGrid{Float64,Periodic,Periodic,Flat,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},MultiCPU{RegularRectilinearGrid{Float64,Periodic,Periodic,Flat,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843222534:648,Abort,Aborting,648,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843222534,1,['Abort'],['Aborting']
Safety,"I prefer the three letter notation because it's more explicit. I'm worried that mistakes might be easier to make, since the current format has a redundancy that in my experience often catches hard to find bugs when coding and formatting long expressions. I guess I also feel it helps me ""visualize"" terms but maybe that's just me. Here's an example of such an expression:. https://github.com/CliMA/Oceananigans.jl/blob/b7871d3fc8b53e8bfecb5395e80287ac9c12d0da/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L262-L301. I agree though that the ""minimal"" notation is more readable for short expressions like the example above.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2236#issuecomment-1033314105:145,redund,redundancy,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2236#issuecomment-1033314105,1,['redund'],['redundancy']
Safety,"I propose. ```julia; xspacing(X, Y, Z, grid); yspacing(X, Y, Z, grid); zspacing(X, Y, Z, grid); ```. where `X, Y, Z` are all _instantiated_ locations eg. ```julia; x = xspacing(Center(), Center(), Center(), grid); ```. I propose we avoid ""one location"" versions that only work for rectilinear / lat-lon grids.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328167384:232,avoid,avoid,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328167384,1,['avoid'],['avoid']
Safety,"I see @glwagner's point. I'm a bit skeptical in that part of the PR (which claims that trig functions should be avoided). Perhaps we can elaborate a bit more on that or point the reader to some other source? I'm a bit on the fence. On the other hand, if I was trying to code up something and was ending up having my code 100 slower because I was doing `cos(pi/4)` instead of `sqrt(2)/2`, then I'd be very grateful if somebody pointed it out in a ""Tips"" section!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951425101:112,avoid,avoided,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951425101,1,['avoid'],['avoided']
Safety,"I started tackling this issue in ClimaAtmos last week. I wrote a module, `OutputPathGenerator`, in a separate utilities package ([documentation](https://clima.github.io/ClimaUtilities.jl/dev/outputpathgenerator/)). This module defines an object, `OutputPathGenerator` that can be extended with different `OutputPathGeneratorStyle`s. ; The `OutputPathGenerator` is used in a `generate_output_path` function that takes the base output dir and the style.; The simplest of such styles is ""overwrite"". . The style that is currently being used in Atmos is `ActiveLinkStyle`. Citing from the docs:; > This style provides a more convenient and non-destructive approach. It manages a sequence of subfolders within the base directory specified by `output_path`. It also creates a symbolic link named `output_active` that points to the current active subfolder. This allows you to easily access the latest simulation results with a predictable path. > Example:; > Let's assume your output_path is set to data.; > If data doesn't exist, the module creates it and returns data/output_active. This link points to the newly created subfolder data/output_0000.; > If data exists and contains an output_active link pointing to data/output_0005, the module creates a new subfolder data/output_0006 and updates output_active to point to it.; > If data exists with or without an output_active link, the module checks for existing subfolders named data/output_XXXX (with XXXX a number). If none are found, it creates data/output_0000 and a link data/output_active pointing to it. Atmos uses `OutputPathGenerator` internally. My vision is that end users would be providing the base path and possibly choosing a `Style` if they don't want the default behavior (which is the ActiveLinkStyle). `Styles` are Julia objects and new ones can be defined in scripts by implementing a method for the function `generate_output_path`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041168662:921,predict,predictable,921,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041168662,2,['predict'],['predictable']
Safety,I think a doctest is a good idea... just avoided it here because they're often finnicky and I didn't feel like I had the time to debug.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1269#issuecomment-744387824:41,avoid,avoided,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1269#issuecomment-744387824,1,['avoid'],['avoided']
Safety,I think here `return` and `return nothing` would have the same effect (probably also just avoiding the whole `return` statement but that will print the variable to screen if used in the REPL). . ```; julia> function test!(a); a[1] +=1; return; end; test! (generic function with 1 method). julia> function test_two!(a); a[1] +=1; return nothing; end; test_two! (generic function with 1 method). julia> a = [1]; 1-element Vector{Int64}:; 1. julia> test!(a). julia> a; 1-element Vector{Int64}:; 2. julia> test_two!(a). julia> a; 1-element Vector{Int64}:; 3. julia> function test_three!(a); a[1] +=1; end; test_three! (generic function with 1 method). julia> test_three!(a); 4. julia> a; 1-element Vector{Int64}:; 4; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005242652:90,avoid,avoiding,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005242652,1,['avoid'],['avoiding']
Safety,"I think high performance at 25 km resolution will prove difficult also because we are effectively dividing our kernel size by 1/6 (unless we figure out how to coalesce kernels across panels). On a large GPU this will lead to performance degredation at 25 km resolution, because even a single-panel kernel covering the whole globe at 25 km barely saturates one GPU. Recovering that performance for multi-region simulations may be difficult, especially in the face of the added complexity of distribution across multiple GPUs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719393187:365,Recover,Recovering,365,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719393187,1,['Recover'],['Recovering']
Safety,"I think it's a great idea to use types to control order of approximation. `struct CenteredDifference{N} end` is more cleanly generalizable. But note that the right concept might be ""interpolating the derivative from cell-centered locations to face-centered locations"", rather than the order of a finite difference approximation. This distinction will become relevant when we have arbitrarily stretched grids (arbitrary stretching is simple for shallow water models, so this could come sooner than we anticipated previously). One simple possibility that might involve minimal code modifications is to add an order of approximation annotation to `RegularCartesianGrid`. We can then define ""nth-order"" interpolation and differencing operators with special notation (something like `δⁿxᶠᵃᵃ`) that types can opt into, such as `IsotropicDiffusivity` or the pressure term for `ShallowWaterModel`. The primary application for incompressible models is diffusion operators, I think. I'm not sure about high-order interpolation for other physics, such as Coriolis forces, etc. Using `grid` might avoid the complexity associated with specifying an ""order of approximation"" for each aspect of the physics separately. I guess we already separate out advection (we could in principle come up with default advection schemes associated with grid's order of approximation...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-741499554:1085,avoid,avoid,1085,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-741499554,2,['avoid'],['avoid']
Safety,I think it's not the end of the world if we go a few days without docs. It's a risk but it's not worth losing sleep and mental health over this,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1789302908:79,risk,risk,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1789302908,1,['risk'],['risk']
Safety,"I think option 4 -- `VerticalFormulation`, `HorizontalFormulation` -- probably makes the most sense for closures. I think it's important that users realize that these types indicate more than just the direction. We don't want to lose this distinction with the kwarg `directions` (or the kwarg `isotropy`, which we've learned will be interpreted as meaning ""direction""). I also think in terms of API there are a few choices:. ```julia; closure = ScalarDiffusivity(ν=1, κ=1, formulation=VerticalFormulation()) # kwarg; closure = ScalarDiffusivity(VerticalFormulation(), ν=1, κ=1) # positional argument; closure = ScalarDiffusivity{VerticalFormulation}(ν=1, κ=1) # explicit type parameter specification; closure = VerticalScalarDiffusivity(ν=1, κ=1) # alias; ```. Separately, this discussion make me think we should use `gravity_unit_vector` instead of `vertical_unit_vector` in the API for `Buoyancy` (to avoid conflicting defintions between ""vertical"" in `Buoyancy` and `TurbulenceClosures`). We can define `NegativeZDirection()` as the default for `gravity_unit_vector`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049988760:903,avoid,avoid,903,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049988760,2,['avoid'],['avoid']
Safety,"I think that's a fine strategy. We can add a kwarg to `NonhydrostaticModel` called `hydrostatic_pressure_anomaly`. We can set it to `CenterField(grid)` to preserve existing behavior, or set it to `nothing` to avoid the separation. And we should probably make `nothing` default so that triply periodic problems can be done out of the box. Then we don't have to re-do the regression tests either because we preserve existing behavior... I think that's also a less invasive change than this PR because we don't have to change `pressures` to `pressure` everywhere, hmm. Since you've done most of the legwork I think you have prerogative to open a new PR if you like (and I can help once you do).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-2088540295:209,avoid,avoid,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-2088540295,1,['avoid'],['avoid']
Safety,"I think the conclusion is that we need to use `mapreduce` to avoid Tullio, but we can't use `AbstractOperations` (because the CFL formula involves an operation between fields at different locations, which `AbstractOperations` are not designed to do)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1416920362:61,avoid,avoid,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1416920362,1,['avoid'],['avoid']
Safety,I think the outer one just transforms `kwargs` in positional `args` by requiring a `time` specified and filling the type of time in the parametric type `T`. . I think we can safely delete the interior constructor (if we have no need of something like `Clock(0)`),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2323#issuecomment-1062210149:174,safe,safely,174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2323#issuecomment-1062210149,1,['safe'],['safely']
Safety,"I think the problem comes from the fact that you build the advection scheme _outside_ the model with `WENO(grid)` but the grid changes inside the model and this change is not recorded in the advection scheme. . What do you think about just spitting out an error then? In that way the user is forced to rebuild the grid and any error which derives from inconsistencies between model grid and preliminary grid is solved. . We can always regularize the advection scheme _inside_ the model (as I am already planning to do, and will do in #2642) and that will clear the error with advection. . The downside of inflating the grid inside the model is that we always have to make sure that _anything_ that we build outside the model is regularized when inflating the halos (functions, auxiliary fields, viscosity functions, etc). This might be a little bit unsustainable. . For this reason, I am in favour of just spitting out an error, which might be a little bit inconvenient for the user (not extremely though) but is much safer. . In general a decision has to be made, I lean towards the latter, what do you guys think? @tomchor @navidcy @glwagner @francispoulin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072:1018,safe,safer,1018,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072,2,['safe'],['safer']
Safety,"I think the solution discussed here, where the time-step _change_ associated with `TimeInterval` schedules is restricted by a sort of relative tolerance criteria, is acceptable if we can't tease out the underlying issue (or its unsolvable). If we could indeed solve the problem simply by eliminating round off error, then this would almost certainly be preferred since it might be much simpler (eg just fixing an floating-point-unstable arithmetic operation by rearranging terms). That could be really easy. @Sbozzolo might be able to help because I believe they do something special to avoid round off issues in `ClimaAtmos`. I would hesitate to establish an absolute `min_Δt` that's independent of the units being used, unless the default is `0`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2152027136:587,avoid,avoid,587,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2152027136,2,['avoid'],['avoid']
Safety,I think the way to go is to write a single kernel (3D or 2D with a loop in z). In this way you avoid the cost of multiple kernel launching. If you have a 3D kernel with non Local dependencies and you have to update nonlocal values (I don't Think it's the case) you have to make sure that there are no write race conditions,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147416320:95,avoid,avoid,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147416320,1,['avoid'],['avoid']
Safety,"I think there's still a use for `KernelComputedField`! It's more expensive to construct a calculation by nesting `ComputedField`s inside it. The difference is in the number of kernel launches: when expressing a calculation with a single kernel, the computation is computed with a single loop over all grid points. When expressing a calculation using intermediate `ComputedField`, then first we launch kernels to calculate the intermediate `ComputedField`s, and launch a final kernel to compute the quantity of interest. It can also be more memory intensive since the intermediate `ComputedField`s need to be stored. For some applications, the ""optimization"" of avoiding intermediate kernel launches / calculations may be unimportant (for example, if plenty of memory is available and computations are made very rarely). I think nesting `ComputedField`s is a nice solution that avoids having to hand-write kernels for those cases. But sometimes I do think that users want to optimize diagnostics calculations. There are also some other nice applications of `KernelComputedField`; for example I think it would be nice to make the LES eddy diffusivities into `KernelComputedField` (which are computed every tendency evaluation so performance is crucial), and perhaps some other auxiliary variables. I think it would be fun to try the compiler hack-around that I suggested in my comment above (defining multiple `identity` functions and using an internal counter to scroll through them during compilation). It's just a matter of finding the time to do it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600:661,avoid,avoiding,661,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600,2,['avoid'],"['avoiding', 'avoids']"
Safety,"I think this problem is more general than just `AveragedField`. It appears to apply to all reductions and broadcasting with `AbstractOperations`. For example:. ```julia; julia> a, b, c = (CenterField(GPU(), grid) for i = 1:3); Base.Generator{UnitRange{Int64}, var""#5#6""}(var""#5#6""(), 1:3). julia> @time a .= b + c; 0.929868 seconds (180.70 k allocations: 11.424 MiB, 99.79% compilation time). julia> @time a .= b + c; 0.924904 seconds (159.14 k allocations: 10.031 MiB, 99.79% compilation time); ```. Note that if we avoid constructing an `AbstractOperation` we get. ```julia; julia> @time a .= b .+ c; 1.339598 seconds (2.24 M allocations: 127.662 MiB, 2.91% gc time, 47.98% compilation time). julia> @time a .= b .+ c; 0.000280 seconds (180 allocations: 41.109 KiB); ```. Then I noticed this:. ```julia; julia> a_plus_1 = a + 1; BinaryOperation at (Center, Center, Center); ├── grid: RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded}; domain: longitude λ ∈ [-10.0, 10.0], latitude ∈ [0.0, 45.0], z ∈ [-1000.0, 0.0]; topology: (Bounded, Bounded, Bounded); size (Nx, Ny, Nz): (512, 512, 32); halo (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δλ, Δφ, Δz): (0.0390625, 0.087890625, 31.25); │ └── domain: longitude λ ∈ [-10.0, 10.0], latitude ∈ [0.0, 45.0], z ∈ [-1000.0, 0.0]; └── tree: ; + at (Center, Center, Center);    ├── Field located at (Center, Center, Center);    └── 1. julia> a .= a_plus_1. julia> @time a .= a_plus_1; 1.674752 seconds (2.22 M allocations: 127.371 MiB, 2.18% gc time, 56.65% compilation time). julia> @time a .= a_plus_1; 0.280226 seconds (17.11 k allocations: 1.104 MiB, 99.87% compilation time). julia> @time a .= a_plus_1; 1.525796 seconds (2.22 M allocations: 127.356 MiB, 2.15% gc time, 51.88% compilation time). julia> @time a .= a_plus_1; 0.294972 seconds (17.11 k allocations: 1.104 MiB, 99.88% compilation time). julia> @time a .= a_plus_1; 0.000274 seconds (170 allocations: 35.438 KiB). julia> @time a .= a_plus_1; 0.000274 seconds (170 allocations: 35.43",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958603853:517,avoid,avoid,517,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958603853,1,['avoid'],['avoid']
Safety,"I think we should make it a rule that we don't write about experimental and transient features in the docs. I propose that instead we use Discussions and Issues for that. I prefer we make the docs ""slow moving"" and carefully curated --- like a textbook --- while using GitHub discussions to encapsulate ""living"", transient, and often more fine-grained knowledge about usage, experimental / rapidly changing features, and generally things that might require extended discussion and benefit from clarification questions. In part this means mostly avoiding tagging issues and pull requests in the documentation. The motivation for this approach has a few parts. First is to clarify ""what belongs in the docs"" versus what kinds of things will be documented elsewhere on the vast internet, so that people know where to look to get the answers they need. The second reason is to help control the development of docs by the community. As the code grows, the docs will have to necessarily grow to become very long. The docs are much shorter than they should be right now because the hydrostatic model in particular is still somewhat ""experimental"" (it's a multi-year effort to develop a fully functional GCM, and we are in the thick of it now). There will be so much more in the docs in the end --- a dozen or more parameterizations for ocean turbulence, sea ice, biogeochemistry, and on and on. As a result, it's going to become very important that the docs are as concise as possible (eg, the same constraint we face when writing a textbook). Thus in this process we'll have to carefully curate whatever goes into the docs as a community, and I think it will be helpful if the docs are only used for ""big"" things. A third reason is just that I think this is will reduce the effort required to maintain docs. For example, this change to the docs will become incorrect when we merge the multi-region PR (which hopefully will be soon). That means that we need to update the docs when we merge that PR. Maybe we",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498:545,avoid,avoiding,545,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498,1,['avoid'],['avoiding']
Safety,I think we should use `return nothing` at the end of every function to avoid confusion.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005285364:71,avoid,avoid,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005285364,1,['avoid'],['avoid']
Safety,"I think you're right that `view(::Field)` doesn't recover the same behavior as `view(::Array)`. This is because `Field` are fixed to three dimensions; we don't have a way to express the concept of a `Field` with one dimension. So for example:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(2, 3, 4), x=(0, 1), y=(0, 1), z=(0, 1));. julia> c = CenterField(grid);. julia> size(view(c, 1, :, 2)); (1, 3, 1). julia> size(view(parent(c), 1, :, 2)); (9,); ```. If our objective purely regards broadcasting, then we could probably generalize broadcasting so that `Fields` with singleton indices and/or `Nothing` location act more like reduced-dimensionality arrays. Is that what you would like to see?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038148481:50,recover,recover,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038148481,1,['recover'],['recover']
Safety,"I took those values from the Model Setup-Turbulent diffusivity closures and large eddy simulation models-constant anisotropic diffusivity section of the documentation. Probably should have sanity checked them beforehand. > julia> using Oceananigans.TurbulenceClosures; >; >julia> closure = AnisotropicDiffusivity(νh=1e-3, νz=5e-2, κh=2e-3, κz=1e-1); >AnisotropicDiffusivity: (νx=0.001, νy=0.001, νz=0.05), (κx=0.002, κy=0.002, κz=0.1). Taking a look at my textbook, both the diffusivities look too small for the real world, especially the horizontal κh, as you mentioned. If I'm not mistaken, eddy diffusivity is much greater in magnitude than molecular diffusivity (and therefore more important), with typical vertical values of 10^-5 m^2/s, and horizontal eddy diffusivities range anywhere from 1m^2/sec to 10^4 m^2/sec. The kinematic viscosity `νh=1e-3` looks to be much too big, though, with typical values ranging from `1.8 *10^-6` m^2/sec at 0ºC to `1.0*10^-6` m^2/ sec at 20ºC. However, substituting those measured values in results in an even more fantastic blowup than before:; ![10s Timestep INFINITE TEMPERATURE REPRODUCER](https://user-images.githubusercontent.com/55706146/99763049-b720fa80-2aae-11eb-860e-ce707cd9d874.gif). Substituting in a larger value (1) for the kinematic viscosity while keeping the above eddy diffusivities also leads to mayhem:; ![10s Timestep INFINITE TEMPERATURE REPRODUCER](https://user-images.githubusercontent.com/55706146/99763726-5c889e00-2ab0-11eb-9a97-a6368ea470a3.gif). I should also note that the simulation issues happening in areas of strong temperature contrast are not exclusive to this specific kind of simulation. Even a simple wind stress simulation I tried to set up earlier with a fairly normal thermocline exhibits bizarre behavior at it (you'll probably have to view the gif frame by frame):; ![More Degeneracy](https://user-images.githubusercontent.com/55706146/99763478-cfdde000-2aaf-11eb-964f-b5c3e76c9e83.gif). Given the above results, i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-730875824:189,sanity check,sanity checked,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1190#issuecomment-730875824,1,['sanity check'],['sanity checked']
Safety,"I tried to use CUDA's [`compute-sanitizer`](https://cuda.juliagpu.org/stable/development/debugging/#compute-sanitizer) to debug the memory issue, but couldn't get anything useful out of it so I went back to debug print statements lol. I printed out the value of `maximum(CuArray(randn(100)))` which should error after the illegal memory access occurs. So I peppered these statements around to try and find where the error happens. The issue happens somewhere here:. https://github.com/CliMA/Oceananigans.jl/blob/d66ed9b8b7c4def36260fccf94725c20106029e4/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl#L246-L252. Adding. ```julia; κu★ = convert(eltype(grid), κu★); κc★ = convert(eltype(grid), κc★); κe★ = convert(eltype(grid), κe★); ```. causes the MWE to work, which is weird because `@show` on the CPU tells me that they are `Float32` anyways. And I'm not sure on the GPU because `@cushow` can't show strings. Commenting out. ```julia; # κu★ = mask_diffusivity(i, j, k, grid, κu★); # κc★ = mask_diffusivity(i, j, k, grid, κc★); # κe★ = mask_diffusivity(i, j, k, grid, κe★); ```. also causes the MWE to work. I haven't been able to isolate the problematic line/operation yet. And as far as I can tell, the code used to compute `κuᶜᶜᶠ`, `κcᶜᶜᶠ`, and `κeᶜᶜᶠ` is all type-safe. Will continue later.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2439779361:1339,safe,safe,1339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2439779361,1,['safe'],['safe']
Safety,"I was thinking of doing some prototyping and benchmarking in a sandbox by building off the example in my PR https://github.com/vchuravy/GPUifyLoops.jl/pull/18. The PR contains an example that can be extended to rely on a `Grid` struct, multiple `FaceField`s and ` CellField`. So I'll prototype grids and fields that are `isbitstype` (you already helped by doing this for a grid in https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-467660181) and test to see if they work on the GPU with GPUifyLoops.jl. If they do work and performance isn't degraded then I'll rewrite the operators to use grid and field structs. You probably know how to do this better than me, but might be good if I rewrite the operators as they's still undocumented and do some _slightly convoluted_ stuff to avoid having to store intermediate calculations. Right now I'm focusing on system tests and benchmarks but once @christophernhill @jm-c and I get closer to implementing the variable _Δz_ grid #47 I will work on this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/115#issuecomment-470782067:803,avoid,avoid,803,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/115#issuecomment-470782067,1,['avoid'],['avoid']
Safety,"I wish I left more info in PR #1229 haha but I think keeping the file open between writes was actually an oversight. My thinking was that you don't want to leave the file open when you don't explicitly need it to be open in case the simulation or Julia crashes. In some cases, this could corrupt the file or could leave the file unreadable by other processes until the Julia process exits. NetCDF files and NCDatasets.jl may not suffer from these issues, but I was probably doing it to be safe. If downgrading `NetCDF_jll` works that seems like a fine temporary fix? I don't think Oceananigans.jl needs super new features from NetCDF?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3777#issuecomment-2350139242:489,safe,safe,489,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3777#issuecomment-2350139242,1,['safe'],['safe']
Safety,"I wonder if we can lean on the compiler to avoid having to store objects directly, eg. ```julia; struct SumOfFields{N, F}; fields :: F; function SumOfFields{N}(fields...) = new{N, typeof(fields)}(fields); end. @inline getindex(s::SumOfFields{1}, i, j, k) = @inbounds s.fields[1][i, j, k]; @inline getindex(s::SumOfFields{2}, i, j, k) = @inbounds s.fields[1][i, j, k] + s.fields[2][i, j, k]; @inline getindex(s::SumOfFields{3}, i, j, k) = @inbounds s.fields[1][i, j, k] + s.fields[2][i, j, k] + s.fields[3][i, j, k]; ```. then inside kernels maybe it'll be enough to write. ```julia; i, j, k = @index(Global, NTuple). U = SumOfFields{2}(velocities, background_fields.velocities). div_Uc(i, j, k, grid, U, c); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2928#issuecomment-1435106594:43,avoid,avoid,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2928#issuecomment-1435106594,1,['avoid'],['avoid']
Safety,"I would have rather left the volume in the flux divergence to avoid this type of confusion. In a finite volume scheme, the advection tendency is $\frac{\sum_k F_k}{V_c}$ , where there is no mention of areas because they should be embedded in the fluxes calculation. Then the cell volume $V_c$ is a 1D metric in a 1D problem, a 2D metric in a 2D problem and a 3D metric in a 3D problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165828928:62,avoid,avoid,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165828928,1,['avoid'],['avoid']
Safety,"I would keep the benchmarks simple and avoid a near-global ocean setup. The setups have to be maintained so its best if they are simple and easy to update when syntax changes. Also just for the purpose of setting up the pipeline, you probably only need one or two setups. Then we can incrementally build them up after we have observed that the pipeline is useful for at least a few days (if launching nightly). Hopefully the benchmarks will be efficient enough to run nightly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3492#issuecomment-1973858990:39,avoid,avoid,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3492#issuecomment-1973858990,2,['avoid'],['avoid']
Safety,"I would like to start working on this. Note that in terms of maintenance burden, the docs already depend extensively on plotting. So I'm not sure a plotting extension will increase CI significantly. On the contrary we can start with a minimalist approach that simply uses the examples to test the functionality in the extension. I'd like to discuss design before starting. I think the basic functionality we need is to support automatically plotting of 2D fields. Basically we want to be able to write `heatmap!(ax, c)` and have it work automatically, eg if `c` is two-dimensional, then the non-trivial dimensions are automatically detected and appropriate node values inserted. I think this should work even if the dimensions are not `Flat`, so basically we just want to take a look at `size(c)`. We can also support `lines!` and `scatter!` and `scatterlines!` for 1D fields. Is there a streamlined way to do this for all situations, or do we need to add support for each method like `heatmap!`, `contour!`, `contourf!`, etc, individually?. A second question is how to support inspection of 3D fields. I think this is pretty hard. @Sbozzolo has some experience with this so he might have some valuable input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591:632,detect,detected,632,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591,2,['detect'],['detected']
Safety,"I would rather the first option (`avg_c = Field(Average(c, dims=1))`) because it avoids to have to code functions as `IntegrateField ....` and I think option option 1 is clearer than option 2 (you see that the average operation is applied to the fields c)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2052#issuecomment-969400613:81,avoid,avoids,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052#issuecomment-969400613,2,['avoid'],['avoids']
Safety,"I'll wait till it's ready to review in detail, but my main high-level comment is that we need to ensure that, at the end of a time-step, both the prognostic state (horizontal velocities and tracers) and auxiliary state (pressure, vertical velocity, eddy diffusivities) are all consistent and available for output at the current model time. If we intertwine communication with the computation of the auxiliary state and tendencies, then we should _define_ the tendencies as part of the auxiliary state. This will change the semantics and logic of the time stepping loop. But I think it at least as rational as our previous organization of events. The main change is that tendencies will now be computed one ""extra"" time in a simulation (at the very last time-step, the tendencies are not needed if no further time-steps will be taken). In the vast majority of cases this extra cost is negligible because simulations run for hundreds or hundreds of thousands of time-steps. There is the slightly possibility of pessimizing the edge case of a simulation that takes one time step, which may be useful for parameter estimation. For that purpose we may want to avoid computing the ""extra"" tendency. I'm thinking though that we should save that additional optimization until we need it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2953#issuecomment-1452351616:1155,avoid,avoid,1155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2953#issuecomment-1452351616,1,['avoid'],['avoid']
Safety,I'm detecting also a massive slow down in model execution and out of control allocations on the CPU. Type inference failure? Unfortunate to find it this late after the PRs are merged.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480454093:4,detect,detecting,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480454093,1,['detect'],['detecting']
Safety,"I'm gonna add to this:. 1. Avoid throwing a warning when initializing an output writer in ""pickup mode""; 2. Perhaps some way to check that a time-series is ""valid"" when appending to a file during pickup mode?. Here's an example that illustrates how 2 could work:. - During a big run, we record a checkpoint at iteration 1234.; - The run continues, saving high frequency output for iterations 1244 and 1254.; - The allocation ends and the most recent checkpoint is 1234. -- later --. - We restart the run from checkpoint 1234.; - When doing this, we observe that existing output writers have output for 1244 and 1254.; - This means that compatibility between the checkpointer and existing output writers _requires_ that the pickup simulation triggers output writing at 1244 and 1254 (which we can safely avoid, since it's redundant with the data already in the file. Conversely, if the pickup simulation does _not_ ask for output at these iterations, something is wrong (perhaps an invalid timeseries is being recorded). Similar to overriding `overwrite_existing`, implementing this feature basically makes the output writers ""pickup-aware"" (either after creation in `run!`, or via some environmental ""pickup mode"").",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120443544:27,Avoid,Avoid,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120443544,4,"['Avoid', 'avoid', 'redund', 'safe']","['Avoid', 'avoid', 'redundant', 'safely']"
Safety,I'm having trouble following your example. Can you come up with a simpler illustration of the issue and avoid constructions with many operations on a line?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3455#issuecomment-1926176837:104,avoid,avoid,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3455#issuecomment-1926176837,2,['avoid'],['avoid']
Safety,"I'm not familiar with the Oceananigans code writing practice, but it looks like the parameter `number_of_layers` is redundant as it is already present in `grid.Nz`. Is the parameter added in a case where the user inputs the number of layers explicitly?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469180135:116,redund,redundant,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469180135,1,['redund'],['redundant']
Safety,"I'm not planning on running simulations with surface waves any time soon, so this doesn't directly affect me for now. That said, I think `stokes_drift` is the more correct term (regardless of the possibility of a free surface feature in the future). After all what is imposed is a Stokes drift, so I think calling it `stokes_drift` avoids confusion/ambiguity!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-772093692:332,avoid,avoids,332,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-772093692,1,['avoid'],['avoids']
Safety,"I'm not sure I follow then. Are you saying that you're not sure all the; versions in this range are bug-free? That being the case it's best to pin; it to a version we know is safe?. On Tue, Oct 5, 2021, 17:05 Gregory L. Wagner ***@***.***>; wrote:. > ***@***.**** commented on this pull request.; > ------------------------------; >; > In Project.toml; > <https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022>; > :; >; > > @@ -33,7 +33,7 @@ Tullio = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc""; >; > [compat]; > Adapt = ""^3""; > -CUDA = ""3""; > +CUDA = ""3.0.0 - 3.3.6""; >; > Note that Manifest.toml pins a specific version.; >; > Right, that's why I figured making it specific was the safest option.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KRJ3DYWCNI4IRO6RNTUFNSC3ANCNFSM5FKUICWQ>; > .; > Triage notifications on the go with GitHub Mobile for iOS; > <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>; > or Android; > <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.; >; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-934858603:175,safe,safe,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-934858603,2,['safe'],"['safe', 'safest']"
Safety,"I'm not sure what's best. We're _assuming_ that iteration 0 is scheduled. I guess under ordinary circumstances, iteration 0 is scheduled for `IterationInterval` and `TimeInterval` --- though this need not always be true. Also we might argue that iteration 0 should not be scheduled automatically for `SpecifiedTimes`. Perhaps schedules themselves should somehow explicitly specify whether they should be actuated at iteration 0 or not. A downside of avoiding iteration 0 is that issues / bugs with a callback are not caught until first actuation. So it may be a sensible default to actuate at iteration 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233192961:450,avoid,avoiding,450,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233192961,1,['avoid'],['avoiding']
Safety,I'm only concerned the warning is confusing rather than helpful. The problem on #1554 was solved by avoiding `BackgroundField`... ?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1556#issuecomment-815862625:100,avoid,avoiding,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1556#issuecomment-815862625,1,['avoid'],['avoiding']
Safety,"I'm usually for verbose names as they are clearer but in this case the basic regular rectilinear grid is something every user will interact with and will show up in at the top of each example/tutorial so I agree with @francispoulin that a shorter name (without redundancies) would be good. We probably need more than just 1 approval to merge this PR, preferably unanimous consent amongst ourselves?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782316024:261,redund,redundancies,261,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1386#issuecomment-782316024,2,['redund'],['redundancies']
Safety,"I'm wondering if we should abandon the one-location methods. They are convenient, but don't generalize well. They may not even generalize to all immersed boundary methods; for example even with simple `GridFittedBottom` the vertical grid spacing depends on horizontal locations. My thought is that the overall system is simpler and we avoid ""dialects"" if we are disciplined and always require all three locations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328371814:335,avoid,avoid,335,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328371814,2,['avoid'],['avoid']
Safety,"I've been thinking on how to divide the function, but it will require the duplication of the lines: ; ```; filename = first(split(basename(filepath),""."")) * ""_part""; filelist = filter(startswith(filename), readdir(folder)); existing_files = length(filelist) > 0; ```; within the code, how important is it to avoid duplication vs clarity?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2416111586:308,avoid,avoid,308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2416111586,1,['avoid'],['avoid']
Safety,"I've worked out where my problem is coming from. For the wall-normal velocity: first, we compute and apply the tendencies from 1:N face points, then compute the pressure correction at 1:N center points, then fill the boundary points at 1 and N+1, and apply it at 1:N face points (except the gradient is zero across the 1 face point so this doesn't do anything to the boundary. The N+1 boundary point is fine because we can just set it to anything, or time integrate something at the point since nothing else effects its value. The same is true if we prescribe a value at the 1 face point because (even though we redundantly integrate the tendencies there) it just gets reset to whatever we want. The problem is if we try to integrate something like a radiation condition there then we actually end up with $u(1, j, k) = \int (G_u + B_u) dt$ where $B_u$ is whatever integration we're trying to do at the boundary. On bounded topology I don't think we ever want to integrate the tendency right? But it might be more complicated to do that than to think of a different way todo it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2387806695:612,redund,redundantly,612,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2387806695,1,['redund'],['redundantly']
Safety,"If tracer masking changes the pressure solver, it is likely a bug. The pressure solver finds the solution to the Poisson pressure equation, which is a Poisson equation with a RHS proportional to the divergence of the predictor velocity. Tracer masking should have no effect on dynamics and is purely a convenience for output (so we should probably move the masking step to output writers to avoid the unnecessary computational expense). However, there is a bug with immersed boundaries and high-order advection schemes (solved by #2603) that means the value of tracer fields in the immersed boundaries _does_ (spuriously and incorrectly) influence the outcome of a simulation. In addition to that, interpolation / reconstruction across immersed boundaries can in principle touch tracer values within immersed boundaries. However, as far as I know we do not ever reconstruct across immersed boundaries in any core routines except the experimental `IsopycnalSkewSymmetricDiffusivity`. #2477 solves this problem by implementing ""homogeneous"" operators that do not touch tracer values within the immersed boundaries (ie differences return 0, reconstruction returns values from ""active"" cells only). This PR could move tracer masking to output writing to save the computation. However, if the tracer masking affects the outcome of a simulation, then there is a deeper issue at hand (perhaps the issue that's solved by #2603?). Perhaps a more specific question is: why does removing the tracer masking step improve simulation outcomes?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683:217,predict,predictor,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683,2,"['avoid', 'predict']","['avoid', 'predictor']"
Safety,"Instead of saying that trig functions should be avoided on gpus, which seems very strong, I suggest pointing out that there have been some examples where trig functions have performed much slower, and include this example. . This clearly problem needs further exploration but I don't want people to be scared to use sin and cos because sometimes they just make a lot of sense. My two cents worth.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951478103:48,avoid,avoided,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951478103,2,['avoid'],['avoided']
Safety,"Interesting that `mutable`s can't be `isbits`. But `Array` is mutable and `isbits`? Maybe some exceptions... I do think you should avoid fields with abstract or unspecified types in all cases (when simple, like this one) though, even if just for style points, but also to avoid an unexpected performance gotcha. `Clock{T}` seems appropriate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/19#issuecomment-477677073:131,avoid,avoid,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/19#issuecomment-477677073,2,['avoid'],['avoid']
Safety,"Interesting. We have deliberately avoided operations for field time series but we can consider it. How does this work for operations that involve both a Field and a FieldTimeSeries? I'm worried this will be a bit brittle and potentially lead to some wasted time for users, since it may only work for the simplest cases. Another issue is that we don't have a time derivative operator. Another way to implement a time series computation is to make a new/empty FieldTimeSeries, and then loop over the time-index to compute each field in the time series. Is this PR merely a convenience to avoid that loop? Are there other solutions / syntax we could think about supporting that might be more useful / generalize better for users?. Note I think for big feature changes like this it's best to discuss in an issue first before having a PR, but we can discuss here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3644#issuecomment-2198635393:34,avoid,avoided,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3644#issuecomment-2198635393,4,['avoid'],"['avoid', 'avoided']"
Safety,Is it also safer to infer `FT` from `grid`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3419#issuecomment-1880742060:11,safe,safer,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3419#issuecomment-1880742060,1,['safe'],['safer']
Safety,"Is the server headless? Have you tried writing. ```julia; ENV[""GKSwstype""] = ""100""; ```. before running the script?. This is a known issue with GR on headless systems:. * https://github.com/jheinen/GR.jl/issues/278; * https://discourse.julialang.org/t/deactivate-plot-display-to-avoid-need-for-x-server/19359",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657#issuecomment-867130275:279,avoid,avoid-need-for-x-server,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657#issuecomment-867130275,1,['avoid'],['avoid-need-for-x-server']
Safety,"It depends. If you are also passing `indices` to the writer, then `Field(abstract_op, data=scratch.data)` wastes a lot because it allocates a 3D array for `abstract_op`. If you want to use indices AND scratch data, you can use `Field(abstract_op; data=scrath.data, indices)`, where `indices` is the same thing you would pass to the output writer. Generally, you should only need to worry about scratch data if you have a lot of 3D output. If you have 2D output, it's unlikely that using scratch data will help much (and will significantly complicate your scripts, so I'd say best practice would be to avoid it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302680903:601,avoid,avoid,601,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302680903,1,['avoid'],['avoid']
Safety,"It looks like there is a problem with GM. Taking 1 second time-steps without GM, `idealized_one_degree_simulation.jl` produces . ```julia; julia> include(""near_global_one_degree.jl""); underlying_grid = LatitudeLongitudeGrid(arch; size = (Nx, Ny, Nz), halo = (4, 4, 4), latitude, z, longitude = (-180, 180), precompute_metrics = true) = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 5.177 seconds; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (388.072 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (28.553 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 28.596 seconds; │ ├── max(u): (1.94e-10, 4.57e-05, 1.03e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.03e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 1.632 seconds; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 843.428 ms; │ ├── max(u): (2.48e-08, 1.37e-04, 3.09e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 6.17e-06 m; ```. When `IsopycnalSkewSymmetricDiffusivity` is included, however, we find. ```julia; julia> include(""near_globa",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:775,risk,risk,775,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518,1,['risk'],['risk']
Safety,"It makes sense that using `const` for variables referenced ""globally"" in functions increases CPU performance, see: https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800574436:173,Avoid,Avoid-global-variables,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800574436,1,['Avoid'],['Avoid-global-variables']
Safety,It seems like the `Δt` that is calculated in `accumulate_result!` does not agree with the simulation `Δt` because of finite precision arithmetic. Wouldn't it be better to pass the simulation `Δt` to the schedule so everything becomes more consistent and we avoid discrepancies between schedule time and simulation time?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2261675303:257,avoid,avoid,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2261675303,1,['avoid'],['avoid']
Safety,"It seems this updates a lot of versions, including StructArrays. Seems like a good idea but there are some failed tests. When I looked at the errors one of them seemed to be about `OffsetArrays`, copied below right before the stacktrace. Not sure how to resolve this but I suspect others have ideas. ```; ┌ Warning: Could not use exact versions of packages in manifest, re-resolving;   | └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:1526;   | ERROR: Unsatisfiable requirements detected for package OffsetArrays [6fe1bfb0]:;   | OffsetArrays [6fe1bfb0] log:;   | ├─OffsetArrays [6fe1bfb0] has no known versions!;   | └─restricted to versions 1.4.0-1 by Oceananigans [9e8cae18] — no versions left;   | └─Oceananigans [9e8cae18] log:;   | ├─possible versions are: 0.58.5 or uninstalled;   | └─Oceananigans [9e8cae18] is fixed to version 0.58.5;  ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1785#issuecomment-870516627:543,detect,detected,543,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1785#issuecomment-870516627,1,['detect'],['detected']
Safety,"It turns out this also affects `JLD2OutputWriter`. I believe this is due to us ""double-counting"" indices in `construct_output()`. Specifically, we _always_ slice outputs with `indices` here: https://github.com/CliMA/Oceananigans.jl/blob/3322f1879cf8c84c88e9c7cf4e33bdcf70520c36/src/OutputWriters/output_construction.jl#L49-L51. When a `Field` isn't ""pre-sliced"" (i.e., isn't constructed with the `indices` keyword) then that's okay. But if a `Field` is already sliced, then we slice it again there. Depending on how both `indices` are defined (the one when constructing the `Field` and the one passed to the output writer), we try to access outputs at indices that aren't there anymore, leading to a `BoundsError`:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; ```. I'll open a PR soon to fix this, but I just wanted to leave this saved here. I think the way to go is to change the default `indices` in the constructors to `nothing` and then use that to avoid the double slicing in `construct_output()`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067:1054,avoid,avoid,1054,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067,1,['avoid'],['avoid']
Safety,"It was my impression that `Δx` worked differently. I even asked a similar question [here](https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1368277630) about it. But if it returns the same thing, maybe indeed `xspacing` is redundant. I believe the functions `xspacings()` and such (which return an array) are novel and necessary though, right @simone-silvestri ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2842#issuecomment-1468277435:239,redund,redundant,239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2842#issuecomment-1468277435,1,['redund'],['redundant']
Safety,"It's a bit hard to tell what's gone wrong here at this point. I'd do something like; * Create a local branch with `git branch logging_orig $some_hash_or_branch_name` or something to keep this safe. If you've lost the original branch or hash name, don't panic (and don't delete your .git directory)! You can use `git reflog` to find it again.; * Create and check out another local branch as a work in progress `git checkout -b logging_wip logging_orig`; * Squash your changes with `git rebase -i` on `logging_wip` branch into a single commit.; * Reset your master (this PR) to the new rewritten upstream master `git checkout master; git reset --hard origin/master` (presuming origin is `git@github.com:climate-machine/Oceananigans.jl.git`); * Cherry pick the single commit from `logging_wip` onto this new master with `git cherry-pick logging_wip`.; * Force push your new master up to this pull request. (By the way, this would probably be clearer for you if you'd made the original pull request off a branch rather than your master branch. Generally that's a good idea, especially if you want to do multiple PRs)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-550581496:192,safe,safe,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-550581496,1,['safe'],['safe']
Safety,"It's because on an immersed boundary grid, reduced operations are wrapped in `ConditionalOperation` in order to mask the reduction --- and `ConditionalOperation` had a bug; namely it was missing a definition of `compute_at!` (which all the other abstract operations have, eg `BinaryOperation`). For `compute!` on a reduction to be correct, we first have to compute all of the fields that are involved in the reduction. To make this work, we call `compute_at!` on `reduction.operand`. This in turn has to trigger the computation of _any_ fields that are in the expression tree associated with `reduction.operand`. Thus all `AbstractOperations` with field operands must define `compute_at!`. The difference between `compute_at!` and `compute!` is that `compute_at!` has a ""time"" associated with it. This allows us to avoid ""recomputing"" fields --- if possible (eg, if a field is not sharing its data with another field). PS I think a better descriptor than ""Odd behavior"" would be ""Wrong behavior"". ""Odd"" is a bit too general... by the title, it's not clear that something is actually amiss! ""Odd"" might just mean ""unexpected"", but somehow technically correct. Here that's not the case, the results are definitely wrong.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191:815,avoid,avoid,815,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191,2,['avoid'],['avoid']
Safety,"It's coming from this annoying function:. https://github.com/CliMA/Oceananigans.jl/blob/30e3e05fe661cb5f7a0db37ab6c3f42ac8c5f80e/src/Fields/field_tuples.jl#L56-L83. which we can certainly simplify. We can also play around this avoiding hitting this line altogether, at least for a certain class of models.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436404214:227,avoid,avoiding,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436404214,2,['avoid'],['avoiding']
Safety,"It's used for some of the simulations in this paper to mitigate a too-low subgrid tracer flux prediction in free convection:. https://journals.ametsoc.org/view/journals/phoc/51/5/JPO-D-20-0178.1.xml. In cases that lack sufficient shear it seems that AMD can underpredict the eddy viscosity near boundaries. Almost all cases of interest have some mean shear though --- free convection is essentially an edge case. Others may use it too, I don't know.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1856#issuecomment-879274829:94,predict,prediction,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1856#issuecomment-879274829,1,['predict'],['prediction']
Safety,"Just a few notes:. * There's surprisingly little ""interpolation"" / reconstruction in our code (except for trivial reconstruction). Most of the reconstruction occurs for advection, but advective reconstruction doesn't need to be touched by this PR. So this PR actually mostly affects the implementation of GM.; * There are a few things re: using homogeneous operators for Coriolis forces. I suspect that it won't have an effect, but it needs to be tested.; * It should be feasible to use homogeneous / boundary-aware operators _only_ for fluxes. ; * Finally, I'm going to implement an ""enforce_impenetrability!"" operator that does 3D masking and works for both non-immersed and immersed boundaries. After that, we can use `nothing` as a default boundary condition for velocities rather than `ImpenetrableBoundaryCondition` and avoid `mask_immersed_field!` during time-stepping. It seems that impenetrable is still useful for users though for ""user-defined, additional"" velocity components so we may want to keep it...; * An even further step would eliminate the need for masking boundary regions by never updating the tendency there. But this approach allows users to more easily make mistakes, ie changing the velocity field during a run, but forgetting to enforce impenetrability.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116063491:826,avoid,avoid,826,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116063491,1,['avoid'],['avoid']
Safety,"Just a note on this PR: It's kind of hacky but to avoid images and videos taking up space in git history (they take up a lot!) I'd advocate for uploading images into an issue (effectively hosting them on GitHub's servers) and then linking/embedding them. In an ideal world the validation experiment CI pipeline would run and produce figures for all validation experiments which would then be automatically embedded into the docs with every version release. But setting up this infrastructure would take time and effort which I suspect no one can spare right now. Unfortunately it's a thankless job haha. > We try to fix this issue and keep the validation experiments and benchmarks up-to-date. I've always wanted to do this and wish I had the time to do it... This was the original motivitation for setting up the validation experiment CI pipeline: https://buildkite.com/clima/oceananigans-validation-experiments. It only runs the convergence tests right now and it still runs every night but it's been neglected so stuff is failing. I personally think we should be reviving the validation experiments one-by-one starting with the most important ones by running them as part of that CI pipeline and fixing it when it fails. But without the ability to dedicate the time I can see why reducing our maintenance burden would be desirable. I've also always wanted to set up a benchmarking CI pipeline, but I don't think we have the proper computational resources to set it up right now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872386226:50,avoid,avoid,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872386226,1,['avoid'],['avoid']
Safety,"Just looked into this briefly. I don't see any typos in either the biharmonic diffusivity implementation:. https://github.com/CliMA/Oceananigans.jl/blob/master/src/Operators/derivative_operators.jl. or in the implementation of the fourth-order derivatives:. https://github.com/CliMA/Oceananigans.jl/blob/8f4432eff4a2bc4775cc722080318ee1cb7dee5b/src/Operators/derivative_operators.jl#L78. The odd thing is that this problem occurs even when the grid spacing is uniform, which means, I suppose, that it can't be due to a misplaced ""c"" or ""f"". Can you try halos of size 3 just for a sanity check?. We really need to overhaul how ""biharmonic"" diffusion is implemented soon...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1574#issuecomment-826103006:580,sanity check,sanity check,580,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1574#issuecomment-826103006,1,['sanity check'],['sanity check']
Safety,"Just so I understand this filtering thing. It doesn't remove the regex-filtered lines from the output; it just doesn't test those lines against the ""prediction"", right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2083#issuecomment-981525228:149,predict,prediction,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2083#issuecomment-981525228,1,['predict'],['prediction']
Safety,"Just some comments at this point:; * At this point, we have the HydrostaticFreeSurface model working with the split explicit free surface. It would be great to find some time later on to figure out what was going on with the implicit free surface on AMD GPUs (is the issue isolated only to that architecture??) and get this resolved.; * To get everything moved over to KernelAbstractions would constitute a rather large change, something I think @glwagner expressed an interest in avoiding. I'd vote in favor of pushing this change off for future PR's.; * I'm wrapping up a profiling report that includes MI210 and A100 GPU performance; this report will include some recommendations should we be interested in performance improvements on GPU hardware (AMD and Nvidia). This kind of work could also constitute PR's further down the road.; * The main outstanding issue seems to be that we need a platform for testing on AMD GPUs. . It appears the CliMA fork `Project.toml` and `Manifest.toml` have diverged; I'll take a look to see if I can fix.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1997632147:481,avoid,avoiding,481,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1997632147,1,['avoid'],['avoiding']
Safety,Just tested the script and it runs! I haven't tested that the outputs are correct but I think it's safe to leave this closed.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1116725273:99,safe,safe,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1116725273,1,['safe'],['safe']
Safety,"Latest thinking incorporating some of the suggestions above:. Rename `Buoyancy` to `BuoyancyTerm` (as in, the buoyancy term in the Navier-Stokes equations) with. ```julia; struct BuoyancyTerm; equation_of_state; gravitational_acceleration; vertical_unit_vector; end; ```. Then we move `constant_temperature` and `constant_salinity` to the equations of state; and as @jm-c suggested, the equation of state determines the active tracers. Additionally, we'll define a convenience function. ```julia; BuoyancyTracer(vertical_unit_vector=ZDirection()) = BuoyancyTerm(BuoyancyTracer(), nothing, vertical_unit_vector); ```. so we then have `equation_of_state=BuoyancyTracer()` when buoyancy itself is one of the tracers. If we want to be very friendly, we can also throw an error when `!isnothing(gravitational_acceleration)` but `equation_of_state isa BuoyancyTracer` to help users avoid confusion. I think this is a good change because it allows us to define a function `buoyancy(model)` that returns an `AbstractField` (potentially `ZeroField`, `AbstractOperation`, or `Field`) representing buoyancy for use in diagnostics. It reduces the number of types we need (since we won't have `SeawaterBuoyancy` anymore), and it's a bit more parsimonious with semantics (since it avoids using the word ""model"").",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1016840612:876,avoid,avoid,876,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1016840612,2,['avoid'],"['avoid', 'avoids']"
Safety,"Let's get to the blackboard together and sort it out. Don't code things; that are not clear. On Thu, May 23, 2019, 8:41 AM Ali Ramadhan <notifications@github.com> wrote:. > Ali, Please explain why it's x delt rather than divide. John; >; > I think when you discretize you get ∂u/∂t you get 1/Δt but then I think; > you're solving for the *predictor* or intermediate velocity *u**, which; > is fed into the right hand side, has a Δt multiplying the *Gu* source; > terms. It's not super clear to me yet, probably a good reason to actually; > write out all the equations and properly document this step.; >; > I ended up following the MITgcm manual:; > https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#equation-elliptic-pnh; >; > Equation (2.52) gives the 3D elliptic equations, and if you expand the; > right hand side using (2.53-2.55) and (2.58-2.59), and set *η=0* (we have; > no free surface) then we get ∇²ϕNH = ∇·u(n) + Δt*∇·Gu(n+½).; >; > What's worrying me right now is that this all seems to work great when *Δt; > = 1* but otherwise it doesn't work. I tried dividing by *Δt* just to make; > sure but it also didn't work (you get very high velocity divergences and it; > eventually blows up).; >; > Ps Does it work for 32bit now?; >; > It works better (the velocity divergence accumulates 10-20x more slowly); > but we might still need further fixes.; >; > Before:; >; > [ Info: Velocity divergence after 1 time steps (CPU(), Float32): min=-2.6085445e-10, max=-2.6085445e-10, sum=-2.683187e-11, abs_sum=7.933663e-7; >; > [ Info: Velocity divergence after 10 time steps (CPU(), Float32): min=-1.2560122e-9, max=-1.2560122e-9, sum=1.3686829e-12, abs_sum=3.0624833e-6; >; > [ Info: Velocity divergence after 100 time steps (CPU(), Float32): min=-5.4315024e-9, max=-5.4315024e-9, sum=1.2459012e-10, abs_sum=2.1301974e-5; >; > [ Info: Velocity divergence after 1000 time steps (CPU(), Float32): min=-6.495975e-8, max=-6.495975e-8, sum=-3.066242e-8, abs_sum=0.0002503319; >; >; > Afte",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495204146:339,predict,predictor,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/228#issuecomment-495204146,1,['predict'],['predictor']
Safety,"Let's table this, one nice thing about numbers is that we avoid the need for ""x"" and ""lambda""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2006#issuecomment-1479955890:58,avoid,avoid,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2006#issuecomment-1479955890,1,['avoid'],['avoid']
Safety,"Looks great! I think we still don't want images like `validation/convergence_tests/convergence_rates.png` getting into the repo but we can ""squash and merge"" this PR to avoid this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1650#issuecomment-839388522:169,avoid,avoid,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1650#issuecomment-839388522,1,['avoid'],['avoid']
Safety,Looks like I forgot this in #3847. The performance should be identical if using both the methods provided the methods are precompiled correctly. The method in [`tracer_advection_operators.jl:11`](https://github.com/CliMA/Oceananigans.jl/blob/7cbf013cb6bed2bd7cef0f4d8e5f04c078e50ee0/src/Advection/tracer_advection_operators.jl#L11) avoids the immersed boundary check with `nothing` advection so probably it's a tad better.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3851#issuecomment-2428436798:332,avoid,avoids,332,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3851#issuecomment-2428436798,1,['avoid'],['avoids']
Safety,"May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924418422:98,avoid,avoid,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924418422,2,['avoid'],['avoid']
Safety,"Maybe we can design a custom `Clock` object that opts-in to this kind of behavior, when warranted. The default could be our original clock, but if you know what basis to use and you'd like to avoid rounding issues for very long running simulations, you can opt-in to `ExactSteppingClock` or something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512206338:192,avoid,avoid,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512206338,1,['avoid'],['avoid']
Safety,"Might be cool to be able to dispatch on the order so the order could be specified as part of the model, e.g. ```julia; model = ShallowWaterModel(grid=grid, order=4); ```. and it would make it easier to use the operators in other models. We could define new types like. ```julia; struct SecondOrderCenteredDifference end # one option; struct CenteredDifference{N} end # another option; ```. then dispatch on `::SecondOrderCenteredDifference` or `::CenteredDifference{Val{4}}` or we could dispatch on numbers via `Val`. ```julia; julia> δ(i, A, ::Val{2}) = A[i] - A[i-1]; δ (generic function with 1 method). julia> δ(i, A, ::Val{4}) = (-2A[i+1] + 16A[i] - 16A[i-1] +2A[i-2]) / 12; δ (generic function with 2 methods). julia> δ(10, collect(1:20) .^ 2, Val(2)); 19. julia> δ(10, collect(1:20) .^ 2, Val(4)); 15.833333333333334; ```. but might have to be careful to [avoid performance regressions with `Val`](https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-value-type). That said it might take a non-trivial amount of refactoring to support and test dispatching on the operator order, at least for the incompressible model. Maybe it makes sense for `ShallowWaterModel` to add support for 4th-order operators first (with or without dispatch, probably easier without first) and from there we can investigate how to generalize?. If we go all out and start supporting lots of different operators I wonder if it's worth looking into [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl) or [FiniteDifferences.jl](https://github.com/JuliaDiff/FiniteDifferences.jl). Not sure what role these packages would play. From skimming the FiniteDifferences.jl README it seems that there are no higher-order non-allocating implementations between the two packages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-740952155:862,avoid,avoid,862,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-740952155,1,['avoid'],['avoid']
Safety,"Might be worthwhile to profile with `timestepper=:RungeKutta3` as a sanity check, considering that this benchmark suggests a simple time-stepping function is 12% (!) of the cost. Another thought --- we should probably benchmark ""fully loaded"" models that at least use WENO advection (and perhaps some turbulence closure?), since that's more realistic. I think most usage of `NonhydrostaticModel` also has one tracer, rather than two (someday, we should change that default...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890002262:68,sanity check,sanity check,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890002262,2,['sanity check'],['sanity check']
Safety,"My statement is somewhat misleading. I should say that I expect the model to abort itself AFTER NaNs appear. It does not have to abort immediately at the first occurrence of NaN, but it needs to abort before an out-of-bounds error. Ideally, we do not want a model to crash due an out-of-bounds error. Instead, it should abort with a error message, and a detailed solution can be found in the document. Does this answer your question?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645:77,abort,abort,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645,4,['abort'],['abort']
Safety,No we should fix this for sure. I'm asking because you would save a lot of memory if you avoid writing `Field(w*c)`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1438718756:89,avoid,avoid,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1438718756,1,['avoid'],['avoid']
Safety,"No, it was due to the alignment process but note that the time step is aligned with both output writing and the simulation stop time. The simulation reached `simulation.stop_time` but it was forced to do more iterations in this loop (see below) so so the aligned time step turned out to be 0 (to avoid overshooting `simulation.stop_time`). https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/Simulations/run.jl#L158-L166. Now the simulation won't end up in this situation anymore since it stops time stepping early if `simulation.stop_time` is reached.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1254#issuecomment-739539551:296,avoid,avoid,296,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1254#issuecomment-739539551,1,['avoid'],['avoid']
Safety,"No, the method looks correct to me. This is some kind of bug. As a sanity check, you might try defining. ```julia; @inline ΔzF(i, j, k, grid::RegularRectilinearGrid{FT, TX, TY, Flat}) where {FT, TX, TY} = one(FT); ```. However, we definitely want to get the method working for `grid::AbstractGrid{FT, TX, TY, Flat}` so that we don't have to redefine `ΔzF` for every grid type.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-805032204:67,sanity check,sanity check,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-805032204,1,['sanity check'],['sanity check']
Safety,"OK, with the help of detective @glwagner we figured this out. The change that happened between those versions is that `with_halos = false` became the default in output writers. To post process saved buoyancy to compute $|\boldsymbol{\nabla} b|^2$ we *crucially* need the boundary conditions on $b$ to be correct in the HC example! Thus, saving output `with_halos = false` was not doing the job right... #2734 fixes this",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2735#issuecomment-1244763584:21,detect,detective,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2735#issuecomment-1244763584,1,['detect'],['detective']
Safety,"OK. All these is great!. So all this info you just shared is it anywhere else written? E.g. ""StretchedSmoothness is much less efficient... another reason to avoid it"". Btw, what exactly is ""StretchedSmoothness""?. We should have a docs section on advection schemes (#1318) and perhaps this PR is not the right place to deal with that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975180531:157,avoid,avoid,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975180531,1,['avoid'],['avoid']
Safety,"Oh. I didn't realize that the time-step was aligned with `simulation.stop_time`. I see then that the problem is intractable with the current ""sub iterations"" design. This problem is avoided by the design proposed in #1138.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1254#issuecomment-739539870:182,avoid,avoided,182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1254#issuecomment-739539870,1,['avoid'],['avoided']
Safety,"Ok getting closer maybe... I think this problem is generic and cannot be solved in general for arbitrary time steps. Here's a few thoughts:. - Reading about [Kahan summation](https://en.wikipedia.org/wiki/Kahan_summation_algorithm) makes it clear that we simply cannot avoid errors if we would like to add a small floating point number (the time step) to a very large number (the model time). . - I think the issue with the time-step is whether or not we can compute the RHS of the pressure Poisson equation accurately --- which is `div(u') / Δt`, where `u' = u + Δt * Gu` is the predictor velocity and `div` is the divergence. This is interesting, because I could not figure out why we would ever find large `div(u')` with small `Δt` even in this MWE. But now I realize that because of the status of the immersed Poisson solver, the velocity along the boundary is divergent, strongly so. So, `div(u')` is large along the boundary. And when we divide by `Δt` we get something huge. The magnitude of `div(u')` also somehow seems to depend on the time step (as does the magnitude of the spurious circulation). The correct solution to this case remains at rest of course. (An aside is that this problem _could_ be avoided by separately computing the hydrostatic pressure, and then using a special horizontal gradient operators that avoid computing a hydrostatic pressure gradient across an immersed boundary. However, this would only be correct for no-flux boundary conditions on buoyancy on side walls). Anyways, apparently because of this issue with the immersed pressure solver, it seems that `div(u')` is large (because `div(u)` is large) even when `Δt = O(1e-14)`... - As a result of all of this I am confused about whether this MWE is actually reliable for debugging the issue. I guess we should expect to see problems simply when `Δt = O(eps)` because this is when `div(u') / Δt` cannot be reliably computed, I think. This leads to a fairly simple criteria for the time step that's compatible with",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153020136:269,avoid,avoid,269,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153020136,4,"['avoid', 'predict']","['avoid', 'predictor']"
Safety,"Ok, I found in the docs for MPI.jl that. > Calling [MPI.Finalize()](https://juliaparallel.org/MPI.jl/stable/reference/environment/#MPI.Finalize) at the end of the program is optional, as it will be called automatically when Julia exits. This is good news. So we can call `MPI.Init()` when we build the architecture, and avoid `MPI.Finalize()`. This brings us one step closer to the ""one line to distributed simulations"" goal. https://github.com/JuliaParallel/MPI.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1750495370:320,avoid,avoid,320,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1750495370,1,['avoid'],['avoid']
Safety,"Okay interesting!. I'm not sure why you would need `gcc`. Have you tried omitting that?. Also, did you try installing julia yourself? There could be some benefit in using the system Julia via `module load julia/1.9.2`, but this would mostly have to do with compilation speed (not execution speed) I think. If you have found discrepancy between the system Julia vs your own Julia install that'd be interesting to hear about... You could also let julia handle netcdf --- again, I'm not sure if this would have performance implications or not, but it might provide faster way to get up and running if you are simply trying to run scripts. Julia's package manager should be able to automatically detect and install netcdf appropriate for the system, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258884823:692,detect,detect,692,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258884823,2,['detect'],['detect']
Safety,"One idea to avoid a huge amount of refactoring could be to define something like. ```julia; default_float_type = Ref(Float64); ```. Then to change to float32 we'd write. ```julia; Oceananigans.default_float_type[] = Float32; ```. Next, everywhere we've written `FT=Float64` we change to `FT=default_float_type[]`. Basically that adds a global variable that users can modulate at the top of a script. We'd also have to introduce type parameters here and there wherever `Float64` was hardcoded (eg `TimeInterval`). Note this is also a reason not to do clock updates with some kind of higher precision it would seem (which we have discussed a bit to solve some rounding errors)...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732204898:12,avoid,avoid,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732204898,1,['avoid'],['avoid']
Safety,"One small note --- while I agree that the buoyancy frequency criterion is more restrictive, it just happens that the internal waves that arise at coarse resolutions have frequencies closer to the inertial frequency rather than the buoyancy frequency. In other words, the buoyancy frequency restriction, while guaranteed to be safe, is often _overly_ restrictive. When running expensive simulations one almost certainly has to increase the time-step beyond this number to obtain results in a reasonable amount of time. I think it's fine to use a conservative estimate for the example, though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1594#issuecomment-820531717:326,safe,safe,326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1594#issuecomment-820531717,1,['safe'],['safe']
Safety,PS @christophernhill: Buildkite tests did not run on this PR since we disable Buildkite on PRs from forks (to avoid random PRs executing potentially malicious code on Tartarus and Sverdrup). So we usually open and merge branches from the repo itself.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1333#issuecomment-772496240:110,avoid,avoid,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1333#issuecomment-772496240,1,['avoid'],['avoid']
Safety,"PS a minor tweak that would help with the issues above would be to add a kwarg to `update_state!` like. ```julia; function update_state!(model; compute_tendencies=true); ```. Then under some circumstances (ie in `set!` or for the last time-step potentially) we can avoid computing the tendencies if we want. PS PS should we use ""compute"" rather than ""calculate"" ? We use both words to mean the same thing which is silly...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2953#issuecomment-1453642566:265,avoid,avoid,265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2953#issuecomment-1453642566,1,['avoid'],['avoid']
Safety,"PS, you can always create a new branch from this one and merge main there. You don't need anybody's permission to run a simulation with certain code. Development is always welcome but we should avoid manufacturing a ""sense of urgency""!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142601356:194,avoid,avoid,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142601356,1,['avoid'],['avoid']
Safety,Perhaps the feature being asked for here is a checkpointer that avoids writing NaNs --- is that correct?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982852359:64,avoid,avoids,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982852359,1,['avoid'],['avoids']
Safety,"Personally I don't see a problem with warnings in the docstrings if that's how the code behaves. > Strikes me that we could also change the log level so that warnings are not emitted. I'm not sure what the expected result of this is. But if this will create a situation where a given docstring won't have warnings, while users copy-pasting the contents from that same docstring may get a warning, then I think it'll be confusing and we should probably avoid that solution. If not, then that sounds like a great solution :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3705#issuecomment-2287861310:452,avoid,avoid,452,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3705#issuecomment-2287861310,1,['avoid'],['avoid']
Safety,"Previously the functions `viscous_flux_u*` and `diffusive_flux_*` dispatched on `AbstractPrimaryGrid`. `AbstractPrimaryGrid` (now called `AbstractUnderlyingGrid` is an abstract type for distinguishing between `ImmersedBoundaryGrid` and the ""primitive"" / ""primary"" / ""underlying"" counterparts (I guess I'm still not sure what the best name is). As a result, flux calculations with `ImmersedBoundaryGrid` were hitting fallback flux functions that returned 0. This PR removes most instances dispatching on `grid` (except where necessary, where the dispatched type was changed from `AbstractPrimaryGrid` to `AbstractGrid`). It also nukes the fallbacks (which were the reason this issue escaped detection originally). The original motivation for dispatching on `AbstractPrimaryGrid` is not only wrong but also appears to be unnecessary, since the tests on this PR pass. For some reason `TwoDimensionalLeith` was also having trouble compiling on the GPU, so we're skipping those tests for now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1835#issuecomment-877174564:690,detect,detection,690,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1835#issuecomment-877174564,1,['detect'],['detection']
Safety,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006:871,recover,recover,871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006,1,['recover'],['recover']
Safety,"Re solving the problem with the user interface (eg the `immersed` boundary condition that we currently have) --- @simone-silvestri and I discussed how to implement this, and our tentative plan is to add a new term to the tendency kernels:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tendency_kernel_functions.jl. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/velocity_and_tracer_tendencies.jl. The reason for this approach is to avoid entangling the immersed boundary condition calculations with the existing closure kernel functions. We're not totally sure what the immersed boundary condition stuff will entail and we think this approach will be easier to maintain and extend in the near future. Hopefully we can adapt some of the ideas and code in this PR to that eventual implementation. I think this implementation will prove useful for users who just want to use the hard-coded boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675:539,avoid,avoid,539,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675,1,['avoid'],['avoid']
Safety,"Resolution is kinda used ambiguously, which is why we renamed ""resolution"" to ""size"", no?. While most people take ""resolution"" to mean grid spacing (myself included), as you yourself pointed out some can take it to mean grid size, so I feel we should avoid this word. I could just keep it as ""grid spacing"" which is absolutely clear and merge it as it is.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2010#issuecomment-942659233:251,avoid,avoid,251,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2010#issuecomment-942659233,2,['avoid'],['avoid']
Safety,"Simple kernels are safe (in fact, faster). ```julia; using Oceananigans; using Oceananigans.Architectures: device; using Oceananigans.Utils: launch!; using Oceananigans.Operators: ∇²ᶜᶜᶜ. using KernelAbstractions: @kernel, @index; using BenchmarkTools. @kernel function _diffuse!(c, Δt); i, j, k = @index(Global, NTuple); @inbounds c[i, j, k] += Δt * ∇²ᶜᶜᶜ(i, j, k, grid, c); end. function diffuse!(c, Δt); grid = c.grid; arch = grid.architecture; ev = launch!(arch, grid, :xyz, _diffuse!, c, Δt); wait(device(arch), ev); return nothing; end. function lots_of_steps!(c, Δt, steps=100); for _ = 1:steps; diffuse!(c, Δt); end; end. grid = RectilinearGrid(CPU(), size=(128, 128, 1), x=(0, 2π), y=(0, 2π), z=(0, 1)); c = CenterField(grid); @btime lots_of_steps!(c, 0.01); ```. yields. ```julia; 447.763 ms (9832300 allocations: 975.37 MiB) # KA 0.8; 499.522 ms (9832300 allocations: 1.81 GiB) # KA 0.7; ```. adding `fill_halo_regions!` doesn't change much either",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481333405:19,safe,safe,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481333405,1,['safe'],['safe']
Safety,"Since we need the performance provided by KA 0.7, and we need to use KA 0.8+ on GPU, does that mean that we should invest in developing our own CPU infrastructure (replicating what KA 0.7 offered) to achieve that performance?. Another possibility is that we re-write much of the code base to avoid the performance pitfalls we are currently facing in order to get back to the level of performance we have with current code + KA 0.7. I believe the issue is basically an interaction between some of the abstractions / indirection we have developed and the compiler, so possibly rolling back that abstraction / indirection will bring us back to where we were previously.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481707882:292,avoid,avoid,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481707882,1,['avoid'],['avoid']
Safety,So is `taper_factor_ccc` function redundant now? Seems like it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2664#issuecomment-1185491600:34,redund,redundant,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2664#issuecomment-1185491600,1,['redund'],['redundant']
Safety,"Some nice detective work @glwagner , and I agree that the initial profile looks much better and therefore justifies this improvement. As for the growth rate plot, in the movies, both cases have an intial perturbation O(1e-3) or so. I can believe this has a norm of O(1e-2). However, initially, the value is much smaller and I'm guessing it's zero. This is probably because we don't compute it at the first index. I will have to look at the plotting script and see why that is. . One easy fix is to start plotting at the second point. A more satisfying fix would be to actually compute the norm at the first index. I will try and figure this out later today, but now breakfast!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-883366377:10,detect,detective,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-883366377,1,['detect'],['detective']
Safety,"Some of the lessons over on https://github.com/CliMA/Oceananigans.jl/issues/2024 could warrant using an object after all. The reason is a bit technical... but because of how the compiler works, we have. ```julia; julia> using Oceananigans.AbstractOperations: Δx. julia> using Oceananigans. julia> grid = RegularRectilinearGrid(size=(2, 2, 2), extent=(1, 1, 1));. julia> u = XFaceField(grid);. julia> udx1 = u / Δx; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=2); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; / at (Face, Center, Center);    ├── Field located at (Face, Center, Center);    └── Δxᶠᶜᵃ at (Face, Center, Center). julia> udx2 = u / Δx; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=2); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; / at (Face, Center, Center);    ├── Field located at (Face, Center, Center);    └── Δxᶠᶜᵃ at (Face, Center, Center). julia> udx1 === udx2; false; ```. The reason we get different types is because of the different ""identity"" functions introduced in. https://github.com/CliMA/Oceananigans.jl/blob/6dcf6ffd1fdb2febaf0d20dfab85ef1d3f83d758/src/Operators/interpolation_utils.jl#L29-L66. which we do to avoid the compiler from detecting recursion during compilation. A few things to digest here but basically we want to cache the operations `u / Δx`, etc because reforming them for every calculation may incur high compilation costs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958994106:1367,avoid,avoid,1367,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958994106,2,"['avoid', 'detect']","['avoid', 'detecting']"
Safety,"Sorry if I'm missing something obvious (still new with the working of Oceananigans/Julia), but I was trying to test this feature and expand it to `BuoyancyTracer` over the weekend and I wonder if this implementation can be made more general. . The way I understand @ali-ramadhan created some functions `g_x` to extract the gravity components in each direction and then used them in the `x_dot_g_b` functions to calculate each component of the gravity acceleration. The thing is that gravity can only be a vector using `SeawaterBuoyancy`. When trying to apply this to `BuoyancyTracer` I found that I'd need to replicate the same feature but with a different name (since, as @glwagner pointed out, `gravitational_acceleration` would be a confusing name when working directly with buoyancy). Also, if you also think issue https://github.com/CliMA/Oceananigans.jl/issues/1372 is relevant, it might be nice to have one unified word/approach for the tilting of the domain. So what do you guys think if this tilting is implement at the `AbstractBuoyancy` level? If I understand correctly all buoyancy types inherit that, right? That way we'd have a keyword for the tilt (maybe `tilt`, `gravitational_direction` or `gravity_projection`) that would default to `(0, 0, 1)` and a similar option could be given to `FPlane`, avoiding confusion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782900312:1312,avoid,avoiding,1312,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782900312,1,['avoid'],['avoiding']
Safety,"Sure we can do that. But before we start a PR with a new test, shouldn't we first make sure there isn't anything wrong with my script?. That said, I think the basic ingredients are. - A time-average (NetCDF?) output (obviously); - Some diagnostic (preferably a Field, not a ComputedField) that changes in time predictably. The issue with creating a truly _minimal_ MWE is that (like [your comment summed up well](https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-810496153)) it's not clear which outputs exhibit the issue and which ones don't. I _think_ we might be able to get away with simply starting a quiescent simulation apart from a uniform u velocity and see if the total momentum is conserved on average. (This should start inertial oscillations.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817971702:310,predict,predictably,310,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-817971702,2,['predict'],['predictably']
Safety,"Sure!. ```; (Oceananigans) pkg> status; Project Oceananigans v0.53.0; Status `~/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v3.2.0; [052768ef] CUDA v2.4.1; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.3.2; [e9467ef8] GLMakie v0.1.30; [c27321d9] Glob v1.3.0; [033835bb] JLD2 v0.4.3; [63c18a36] KernelAbstractions v0.5.4; [da04e1cc] MPI v0.16.1; [442fdcdd] Measures v0.3.1; [85f8d34a] NCDatasets v0.11.3; [6fe1bfb0] OffsetArrays v1.6.2; [bac558e1] OrderedCollections v1.4.0; [4a48f351] PencilFFTs v0.12.2; [d330b81b] PyPlot v2.9.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [09ab397b] StructArrays v0.5.0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```. ```; ERROR: LoadError: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928:578,Safe,SafeTestsets,578,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928,1,['Safe'],['SafeTestsets']
Safety,"Thank you @navidcy! . Mind if I ask how? I feel like I might have been given permission to do this last year, but just never tried it. If I don't have permission, no problem, but if I do I can learn to do this to avoid bothering others with this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1158802256:213,avoid,avoid,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1158802256,2,['avoid'],['avoid']
Safety,"Thank you for bringing this up! I am interested in running simulations with `FT=Float32`. In many of my simulations, the spatial resolution is limited by GPU memory, and thus using `FT=Float32` will hopefully double the number of grid points for a given GPU. \(Although multiple-GPU should be the solution.\). It seems to me that the document does not tell people how to setup a simulation with `FT=Float32`. It only tells people to avoid mixed-precision operations. I am willing to give a try if there is a detailed instruction.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389467592:433,avoid,avoid,433,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389467592,1,['avoid'],['avoid']
Safety,"Thanks @glwagner. I certainly don't want to make any changes that would either slow down code or make things harder to maintain. I can't say that I know this is the right direction to go but let me try and articulate what I want to do and maybe you can suggest a direction to proceed?. The basic idea can be found by looking at `shallow_water_Bickley_jet.jl`. In this example we define a `perturbation_norm` in line 134 that computes the norm of `v`. Then in line 158 we define an output_writer to output this norm. There is nothing special about v and I might want to use use `u` as well. To do this requires two steps:. 1. Defining a new analogous function for the perturbation norm of `u`. I'm hoping we can avoid these functions completely with `using Statistics: norm` but I don't know if that's the case.; 2. In line 161 we need to list these two norms. When I tried that there was an error message, and hence what inspired this PR. I don't think this PR needs to happen and there are probably better ways of addressing points 1 and 2. Any advice?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1558#issuecomment-824937868:711,avoid,avoid,711,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1558#issuecomment-824937868,1,['avoid'],['avoid']
Safety,"Thanks @kburns for the reference. . Nicholas Kevlahan and I are collaborating on a problem now and we have used his wavelet based model. I agree that it does do a lot of things very well. It deals with topography and coastlines using Brinkman penalization, which is quite distinct from our immersed boundary method. I don't know how he preserves positivity in the height field but I will find out. **Update:** their model uses a vertical coordiante in the vertical to avoid layer collapse. Also, in the multi-layer case they use a discretization of vertical diffusion, to also prevent layer collapse (depths going to zero).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116318993:468,avoid,avoid,468,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116318993,1,['avoid'],['avoid']
Safety,"Thanks @simone-silvestri !. > So, the wind stress has a negative sign in the script lines 104 and 105 which has to be removed; > ; > ```; > τˣ = arch_array(arch, - τˣ); > τʸ = arch_array(arch, - τʸ); > ```; > ; > to; > ; > ```; > τˣ = arch_array(arch, τˣ); > τʸ = arch_array(arch, τʸ); > ```; > ; > The negative sign was there because in the hydrostatic model wind stress is a boundary condition and, at the top, a negative flux is a source of momentum. In the shallow water model, this wind stress is a forcing so it does not follow the same convention (we should do something about this convention someday....) and the minus should be removed. (By boundary conditions I meant the forcings); > . That makes sense. I can push the change this afternoon. > to color the continents, if `ζ′` is your vorticity, you should do:; > ; > ```; > Z = interior(ζ′); > Z[Z .== 0] .= NaN; > heatmap!(ax, x, y, Z, colormap=:balance, colorrange=(-2e-5, 2e-5), nan_color=:black); > ```. Very nice. . I had to modify it a little bit (vorticity is not an offset array) but I was able to paint the continents black. . When I make `iter` an Observable, then the vorticity becomes an Observable or a matrix. Unfortunately, it doesn't like this line and I'm not sure how to get it to work with using `@lift`. . ```Z[Z .== 0] .= NaN```. To avoid this in the future, is there a way to do this before we save the data?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128069971:1316,avoid,avoid,1316,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128069971,1,['avoid'],['avoid']
Safety,"Thanks for all the context! . Good points about the time step being more restricted by Coriolis for coarse global simulations and error being dominated by spatial discretization. I'd also be very interested how AB2 compares against RK3 for time-to-solution. I guess this could be readily tested with the non-hydrostatic model simulating turbulence. I'd be curious if RK3 is always faster, or if it's case-dependent. Although it is risky to be on the edge of stability CFL-wise. > It may be a research project to adapt the split-explicit free surface. . Ah I didn't realize that RK3 was not really used for global ocean models, especially with a split-explicit free surface :(. > However, also in this form, successive tendencies do not cancel out. Is this neccessary or is this why Quasi AB2 is technically only first-order accurate? I guess right now with Euler steps the tendency terms do cancel out when an AB2 time step is taken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418146640:431,risk,risky,431,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418146640,1,['risk'],['risky']
Safety,"Thanks for the suggestion @jmbeckers! Since we can now use broadcasting on fields, another possibility is. ```julia; u₀(x, y, z) = rand(); set!(model, u = u₀, v = u₀). model.velocities.u .-= mean(model.velocities.u); model.velocities.v .-= mean(model.velocities.v); ```. This emphasizes using function input, which is generally a better way to work, and avoids annoyances associated with `size` (and is shorter and possibly clearer). However, I agree that @jmbeckers suggestion is better if we want to provide an example of array input. I like the idea of providing such an example, but I'm not sure if we want to put it in such a prominent place as the two dimensional turbulence example because it can be annoying and inconvenient to use them, as this issue illustrates...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-839940253:354,avoid,avoids,354,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-839940253,2,['avoid'],['avoids']
Safety,"Thanks for working on this @josuemtzmo! I do tend to avoid file splitting since one file, even if it is huge, simplifies data analysis. And most of the time, the data analysis can be done on the fly alleviating the need for huge outputs. > Do we test this?. I don't think so. Definitely a good idea to do so since a wrong implementation can result in data loss. Usually Julia would stop then re-run the entire script so would a test look something like: set up a simulation with a checkpointer, run it for a some iterations with some file splitting output, then set up the exact same simulation (copy paste) and run it for some more iterations and more file splitting, then check that the output is all correct?. There may be some edge cases too, e.g. zero or only one output actuation after picking up, or before the initial simulation ends.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2397594302:53,avoid,avoid,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2397594302,2,['avoid'],['avoid']
Safety,"That could work --- though I'd point out that listing the model components that can be inconsistent with one another might be more explicit. I would advocate for a ""blacklisting"" method whereby blacklisted combinations of components are listed local to the implementation of the component. For example, in `beta_plane.jl` we could add. ```julia; validate_coriolis(::BetaPlane, ::AbstractGrid{FT, TX, <:Periodic}) where {FT, TX} = # error; ```. we also need, in `hydrostatic_spherical_coriolis.jl`,. ```julia; validate_coriolis(::HydrostaticSphericalCoriolis, ::AbstractRectilinearGrid) = # error; ```. I think a warning is better than an error for `WENO5` on a curvilinear grid. That'd be a fun scheme to experiment with and we don't know ""how wrong"" it is. If the curvilinear grid is almost regular, we have reason to think it might work. In cases like these where we aren't completely, rock-solid positive that a certain model configuration is invalid I think we should also err conservative and allow such models to be constructed. . We do need to strike a balance between being helicopter parents to users, and catching common mistakes. I don't think we should get in the business of curating science --- we should just provide useful software. Specialty applications can just avoid the kwarg-based constructor so I'm not sure we should worry much about that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796814847:1281,avoid,avoid,1281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796814847,1,['avoid'],['avoid']
Safety,"That probably shouldn't have changed, can you file an issue on CUDA.jl/GPUArrays.jl? I'll have a look next week. The only change to `@allowscalar` that comes to mind is task/thread-safety, which does come at a certain performance cost (it now does a TLS lookup instead of a simple pointer check, but the cost of that should be negligible compared to the subsequent memory transfer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817088189:181,safe,safety,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817088189,2,['safe'],['safety']
Safety,"That was my doubt...; I am not sure wether bathymetry should be added to the momentum equations (as an additional pressure term) or to the continuity equation following ; https://capture.dropbox.com/LxsRg26SQzFKu4lb. I think it depends on how you define `h`. If `h = η + Const` then you add bathymetry to the continuity. If you want to add it to the momentum then `h = η + Const + hB` (and then you add the bathymetry to the momentum because you have to subtract it from the pressure term as bathymetry does not directly influence momentum, but it is directly included in the continuity in this way). The difference is between (if `h = η + Const + hB`); <img src=""https://render.githubusercontent.com/render/math?math={\partial_tu-(\zeta%2Bf)v%2B\partial_x(gh%2Bk)=\partial_x g h_B}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_tv%2B(\zeta%2Bf)u%2B\partial_y(gh%2Bk)=\partial_y g h_B}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_th%2B\partial_x(hu)%2B\partial_y(hv)=0}"">. and (if `h = η + Const`); <img src=""https://render.githubusercontent.com/render/math?math={\partial_tu-(\zeta%2Bf)v%2B\partial_x(gh%2Bk)=0}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_tv%2B(\zeta%2Bf)u%2B\partial_y(gh%2Bk)=0}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_th%2B\partial_x((h%2Bh_B)u)%2B\partial_y((h%2Bh_B)v)=0}"">. the two formulations should be equivalent. I don't know specifically which method is better, I though including it in the continuity would avoid cancellation errors, What do you think?. for the bathymetry, it is the same one I use for the hydrostatic model, but it has a ton of grid noise in it. I think smoothing it a bit might be helpful with increasing the time step without affecting the solution too much. With @sandreza and @kburns we just implemented a spectral smoothing tool for bathymetry recently, so I though we can try it out here",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128958326:1571,avoid,avoid,1571,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128958326,1,['avoid'],['avoid']
Safety,"That's right @navidcy, nice detective work",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3477#issuecomment-1944553636:28,detect,detective,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3477#issuecomment-1944553636,1,['detect'],['detective']
Safety,That's sweet!. I think we should avoid punctuation where possible in `summary` (mirroring Julia Base) so maybe. ```; ImplicitFreeSurface; gravitational acceleration 9.80665 m s⁻²; ```. should be. ```; ImplicitFreeSurface with gravitational acceleration = 9.80665 m s⁻²; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2199#issuecomment-1023334847:33,avoid,avoid,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2199#issuecomment-1023334847,1,['avoid'],['avoid']
Safety,"That's true that `xspacing` etc are redundant. We could also change `xspacings` to `Δx(grid, loc...)`...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2842#issuecomment-1468296362:36,redund,redundant,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2842#issuecomment-1468296362,1,['redund'],['redundant']
Safety,"The argument `dims` indicates what dimensions to average over, where (1=x, 2=y, 3=z). So. ```julia; T_avg = AveragedField(model.tracers.T, dims=(1, 2)); ```. builds a field representing the _horizontal_ averaged of `model.tracers.T` over x and y (dimensions 1 and 2). `data` is an optional field that can be used to supply the underlying data for the `AveragedField` (useful if memory allocations are being carefully managed). `recompute_safely` is relevant only when `AveragedField` are used in other computations. In that case, the `AveragedField` will always be recomputed before computing it's dependent operation if `recompute_safely` is true. Otherwise, the `status` of `AveragedField` is checked and recompution is ""avoided"" when it seems safe to do so.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1965#issuecomment-906451914:723,avoid,avoided,723,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1965#issuecomment-906451914,2,"['avoid', 'safe']","['avoided', 'safe']"
Safety,"The discussion on #2410 reminded me: to complete this implementation, we are going to need to make some modification to the hydrostatic pressure integral. There are two possibilities. We can either. 1) use the MITgcm method, which _avoids_ using the modified grid spacing in the bottom cell for the hydrostatic pressure integral. Using ""underlying"" grid spacing avoids pressure gradient errors that would otherwise induce flow even for horizontally uniform density stratification. 2) Implement Lin 1997 to evaluate the hydrostatic pressure integral: https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=_4v_YF-yx0cAAAAA:vC9wnmpvE_2HqoKudORNBfVCkxK4_YgRfp5_Lh2hIFFNc0ZyST-D7nwEqt1No4FculdvrohhKVF2wT9r",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1086255825:362,avoid,avoids,362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1086255825,1,['avoid'],['avoids']
Safety,"The intended user experience is that only one line should need to be changed: `pickup=false` to `pickup=true` in `run!`. Therefore, users should not have to manually specify the ""part"" that they want to pick up from. I don't like option 2 above. I think that fixing this problem may become much easier if we can ""delay"" the creation of the output file. Right now, the output file is created when we build the output writer. But at that point, we have no way of knowing whether we are going to pick up or not. I've long wanted to implement this ""delay"" but more pressing matters have intervened... The basic thing we need to do is to add an `initialize!(output_writer, sim)` utility, which will create the output file. That function then will know whether the simulation is starting fresh (because `iteration(sim) == 0`, or whether it is ""continuing""). One huge feature this will enable is the ability to avoid overwriting an existing file when it represents the output from the current continuing run. That's a huge problem with the current interface, is that you have to be really careful about `overwrite_existing` if you are trying to pickup from a checkpoint. And I think that's a big problem. With that feature I think we can also figure out how to handle output that is split into multiple files --- because we know if a simulation is continuing that we will have to figure out which `part` to use (if any). > continues writing into the most recent output file once it catches up to the latest unsaved iteration. This is a separate feature from what I was talking about, but I think it's also a great idea! There also may be a clue how to solve a roundoff error issue, where two outputs are written one iteration separate from one another, but at virtually identical times (eg distinguished only by machine epsilon). PS: I simplified the example a bit to help me understand it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221:904,avoid,avoid,904,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221,2,['avoid'],['avoid']
Safety,"The logic should be reversed, we should have to include ""compute_tendencies=false"" as an _optimization_. Rather than what's implemented here, which does the unsafe thing by default. The problem with this logic is that it makes it harder to implement new models. The optimizations should be the optional thing basically, if one is naive, then things should work even if they are slower than they could be",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3741#issuecomment-2313416515:157,unsafe,unsafe,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3741#issuecomment-2313416515,1,['unsafe'],['unsafe']
Safety,The paper that I cited used periodic boundary conditions for the deviations in the horizontal. Not physically meaningful but it is one way to avoid the walls.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083326801:142,avoid,avoid,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083326801,1,['avoid'],['avoid']
Safety,"The risk of doing something automatic is that _in theory_ someone could think ""oh, I only have 2 grid poits in the y direction, but I still expect to observe WENO advection in that direction"". Will someone think that? It doesn't really make sense, with 2 grid points in a direction there won't be advection at all anyways. I don't think this is a big risk. Big risks are like, simulations are dead wrong when they present an illusion that makes them seem ok.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3622#issuecomment-2310605591:4,risk,risk,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3622#issuecomment-2310605591,3,['risk'],"['risk', 'risks']"
Safety,"There are a few more `0.0` in the code. Question:. If there is. ```Julia; fill!(var, 0.0); ```. where `var::Array` and if we don't have access to grid, then is . ```Julia; fill!(var, 0); ```; safe to do?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723594416:192,safe,safe,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723594416,1,['safe'],['safe']
Safety,"There are some differences between how this algorithm is implemented and how we do the stepping for the `NonhydrostaticModel` --- do you have any comment about that? We could try implementing this kind of algorithm for the NonhydrostaticModel as well. The implicit free surface solve can be interpreted as a 2D pressure solve, which in the nonhydrostatic context is replaced by a 3D pressure solve. In particular, it seems that the intermediate predictor velocities $u^\star$ are computed differently and different coefficients are used (1/4, 3/4, 1/3, 2/3) than what we currently use for RK3 in the NonhydrostaticModel:. https://github.com/CliMA/Oceananigans.jl/blob/d66ed9b8b7c4def36260fccf94725c20106029e4/src/TimeSteppers/runge_kutta_3.jl#L57-L62. PS `^\star` is superior to *!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441601967:445,predict,predictor,445,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441601967,1,['predict'],['predictor']
Safety,"There is a script at https://github.com/CliMA/Oceananigans.jl/blob/ncc-glw/cubed-sphere-dynamics/validation/multi_region/cubed_sphere_vorticity.jl. ![vorticity](https://github.com/CliMA/Oceananigans.jl/assets/7112768/fcf66cf7-c257-4fd0-bc5a-39cb79a6bc92). So computing the vorticity there are 6 holes on the 2 corners that do not correspond to an interior point. These are the. `i = 1, j = Ny+1` points for odd panels and `i = Nx+1, j = 1` for even panels. We need to be able to compute the vorticity in those points as well as those points are involved in the $\zeta \hat{\boldsymbol{k}} \times \boldsymbol{u}$ term. One idea is to have each panel of the cubed sphere span until, e.g., `Nx+1` or `Ny+1`. We will have redundancy in the computations but will sort the other issue. Otherwise we just want to call the vorticity kernel on those 3 points; do we do it in a different kernel? Before calling the kernel we need to ensure that the horizontal velocities have their halo regions filled right as the circulation around those points involves some velocities in the halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1758626341:718,redund,redundancy,718,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1758626341,1,['redund'],['redundancy']
Safety,"There's a disadvantage if we need to use `print` for an application other than the one in #2098. Then this PR creates work for us in the future. We can't really predict whether that will occur (but it could come up in the context of log-file creation... ?). I think the purpose of `print` is to remove ""decorations"" and ""Julia-specific details"", rather than important numerical information such as whether the WENO5 coefficients are grid-stretching-dependent:. ```julia; help?> print; search: print println printstyled sprint isprint prevind parentindices precision. print([io::IO], xs...). Write to io (or to the default output stream stdout if io is not given) a canonical; (un-decorated) text representation. The representation used by print includes minimal; formatting and tries to avoid Julia-specific details. print falls back to calling show, so most types should just define show. Define print if; your type has a separate ""plain"" representation. For example, show displays strings with; quotes, and print displays strings without quotes. string returns the output of print as a string. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> print(""Hello World!""); Hello World!; julia> io = IOBuffer();. julia> print(io, ""Hello"", ' ', :World!). julia> String(take!(io)); ""Hello World!""; ```. Here, it looks like `print` returns the ""base name"" of the advection scheme's type, eg similar to `summary(scheme) = string(typeof(scheme))`, but throwing away type parameter information:. ```julia; help?> summary; search: summary MethodSummary. summary(io::IO, x); str = summary(x). Print to a stream io, or return a string str, giving a brief description of a value. By; default returns string(typeof(x)), e.g. Int64. For arrays, returns a string of size and type info, e.g. 10-element Array{Int64,1}. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> summary(1); ""Int64"". julia> summary(zeros(2)); ""2-element Vector{Float64}""; ```. @navidcy suggested `string(typeof(string).name.wrapper)` which seems to do the job of removing type parameter in",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328:161,predict,predict,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328,2,"['avoid', 'predict']","['avoid', 'predict']"
Safety,"These resutls are great @whitleyv , well done! A few thoughts. First, if `c` is the concentration of a tracer it should be non-negative. If you are picking it to be a `sine` I might suggest having `1 + sin` just to avoid negative values. That being said, I don't think it's going to have any impact on the results but might be worth trying. Second, are there any boundary conditions imposed on the tracer at the immersed boundary? I remember there was a discussion but I don't remember the conclusion. Sorry. Third, what exactly is computed in the last plot fo the integrated stress tensor? Also, have you computed these for the nonIBM case to see what the real wall does?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866293419:215,avoid,avoid,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866293419,1,['avoid'],['avoid']
Safety,This PR helps avoid the error; not sure if you want it or not. https://github.com/CliMA/Oceananigans.jl/pull/2110,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989387451:14,avoid,avoid,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2103#issuecomment-989387451,1,['avoid'],['avoid']
Safety,"This is a great feature, though I think it should be implemented as optional functionality rather than hard coded. We can also make it default if we like. > when running on clusters with time limits, you want to checkpoint one final time before the job's time limit is up (to avoid repeating computational work on subsequent jobs). I don't think this PR will solve this issue, because when the time-limit is up the job abruptly ends whether or not `run!` has completed. I don't know if there is a SLURM option to send a signal to your job with some waiting time before quitting (ie, giving you time to Checkpoint before the job ends).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1545#issuecomment-1104643713:276,avoid,avoid,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1545#issuecomment-1104643713,1,['avoid'],['avoid']
Safety,"This works on sverdrup:. ```julia; (base) glwagner@sverdrup:Oceananigans.jl$ julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.1 (2021-04-23); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> N = 32; 32. julia> grid = RegularRectilinearGrid(Float32, size=(N, N, N), extent=(1, 1, 1)); RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (32, 32, 32); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.03125f0, 0.03125f0, 0.03125f0). julia> model = IncompressibleModel(architecture=GPU(), advection=WENO5(), clock=Clock{Float64}(0, 0, 1), buoyancy=Buoyancy(model=SeawaterBuoyancy(Float64)), grid=grid); ┌ Warning: Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid.; └ @ Oceananigans.Grids /archive1/glwagner/Projects/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; IncompressibleModel{GPU, Float32}(time = 0 seconds, iteration = 0) ; ├── grid: RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded}(Nx=32, Ny=32, Nz=32); ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}; └── coriolis: Nothing. julia> time_step!(model, 1). julia> ; ```. @francispoulin can you confirm this solves #1780 ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-870953652:1169,avoid,avoid,1169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-870953652,1,['avoid'],['avoid']
Safety,"Those look great and very similar, as they should be. Each if them should compute a growth rate of the instability. Did you see what that numbers were? Theory predicts 0.139 and before we had 0.138. As long as they are 0.13 ish, then I think we have two working models!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119130951:159,predict,predicts,159,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119130951,1,['predict'],['predicts']
Safety,"To summarize a little more: the issue is not that `Pr` is an empty tuple --- this is perfectly fine. The bug is just in showing an empty `NamedTuple` of `Field`. The reason why . ```julia; julia> closure; SmagorinskyLilly: C=0.16, Cb=1.0, Pr=1.0; ```. works is because `closure` and `model.closure` are different:. ```julia; julia> closure === model.closure; false; ```. This is generically true because we call `with_tracers` on the user-defined closure to build `model.closure`. We can fix this by avoiding `with_tracers` in the model constructor for empty `tracers`, but I'd argue we'll be better off (right now) fixing the bug in `show` for empty `NamedTuple` of `Field`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2398#issuecomment-1084571227:500,avoid,avoiding,500,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2398#issuecomment-1084571227,1,['avoid'],['avoiding']
Safety,"True , we should avoid `reverse`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035289669:17,avoid,avoid,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035289669,1,['avoid'],['avoid']
Safety,Trying to think of a way to avoid adding another name... we can extend `on_architecture` to have different behavior when `grid::String` (and thus a path to file). But `on_architecture` isn't specific to `grid` so that doesn't really make sense.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2179#issuecomment-1025777420:28,avoid,avoid,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2179#issuecomment-1025777420,1,['avoid'],['avoid']
Safety,"Update: I used the formulas in the paper to approximate the gradient of pressure. In a test case that is pressure dominated, I found that the accuracy imporoved by more than what the theory predicted (> 16), but that is very encouraging that we are doing something right. It then occurred to me that we are using centre differencing for the divergence of the transport in the evolution equation for the height. That suggests that we would probably want to use 4-th order approximations to those terms as well. Question: Since we are chaging from approximations at faces to approximations at centers, should the formuals change? I don't think they should but wanted to ask, just in case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741890419:190,predict,predicted,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741890419,1,['predict'],['predicted']
Safety,"Was just looking through this, and not sure if there is still room for comments from noobs (happy to be ignored). Would `tensor_diffusivity` be a good name - skewsymmetric seems a bit like saying that a T-junction is a left_right_turn. :) . > > May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it.; > ; > As far as I can tell when people say they use ""Gent-McWilliams"" they are referring to a constant skew diffusivity (typically 0.3 m^2 / s). But in this closure, the diffusivity can be an arbitrary function or field.; > ; > If anything it would have to be `GentMcWilliamsRedi` since we include the symmetric component as well as the skew component.; > ; > Still though, I think it's important to emphasize that this closure is more general than Gent-McWilliams; not least because the only point in implementing this scheme is to develop a new, better, different parameterization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-971930449:343,avoid,avoid,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-971930449,2,['avoid'],['avoid']
Safety,"We could certainly add a field `error` to `NaNChecker` and throw an error if `error=true`, too. Another possibility though is to design a new `schedule` that doesn't actuate if NaNs are detected. This could be used generically for output writing and checkpointing. Maybe a wrapper like. ```julia; schedule = Skip(hasnan, TimeInterval(100)); ```. Then when the scheduled is queried, if `hasnan(model)` is true, the actuator returns false; otherwise the ""child schedule"" (`TimeInterval(100)` in this case) is queried. Other ""skip conditions"" could be provided to `Skip` as well. I think the nice thing about this solution is that it's more robust than hoping the NaNChecker wil throw an error. Relying on an error from `NaNChecker` only works if the iteration interval for the checkpointer is a multiple of the iteration interval used for the NaNChecker. Otherwise users can still get NaNs in their checkpoint even when using NaNChecker.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949:186,detect,detected,186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949,1,['detect'],['detected']
Safety,"We have to keep masking for velocities in the hydrostatic model. In the nonhydrostatic model, the equivalent masking procedure acts on the predictor velocity field prior to solving for pressure:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Models/NonhydrostaticModels/pressure_correction.jl#L12-L14",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223993421:139,predict,predictor,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223993421,1,['predict'],['predictor']
Safety,"We should probably find these figures and add them back in, but probably not as part of the repo to avoid inflating the repo size. We could use a GitHub issue for figures or we could use https://github.com/CliMA/OceananigansArtifacts.jl for figures as well. X-Ref: https://github.com/CliMA/Oceananigans.jl/issues/1212",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1459#issuecomment-799404046:100,avoid,avoid,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1459#issuecomment-799404046,1,['avoid'],['avoid']
Safety,"We've seen issues noise in the vertical velocity along immersed boundaries in other configurations too. I've seen at least one result in which the noise is substantially mitigated by using the PCG solver, which avoids the approximations of the ""naive"" FFT solver. Unfortunately, we don't yet have a performant PCG-based solver cc @simone-silvestri @xkykai . I think it's interesting and also convenient that the noise is mitigated in turbulent cases or by the inclusion of bottom drag.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3526#issuecomment-2028935410:211,avoid,avoids,211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3526#issuecomment-2028935410,1,['avoid'],['avoids']
Safety,"Well, the usage is limited here because we always ""count from 1"". For an atmospheric simulation with a sponge layer on top, you might have a stretched coordinate as the domain gets higher and higher. Then you could keep your levels fixed and reduce the height of the domain by changing Nz. This might be convenient if you've carefully designed your vertical coordinate to get the spacings ""right"" at the bottom of the domain, but care a lot less about what happens higher up. Then if you get more computational power, you can increase Nz (decreasing the dependence of the stuff lower down on your ""sponge region""). We actually have a similar situation in the ocean where the vertical coordinate is carefully designed in the upper ocean; we could in principle ask for fewer ""lower"" levels --- now that would be a feature we might want to add too!. I think that's why it's good to have a guideline like ""throw an error when we _know_ things are incorrect"". Because if we get into the business of trying to ""predict what users want to do"", we'll quickly find our imaginations are limited! Personally my philosophy is to allow as much as possible because it lets people exercise creativity as freely as possible (not limited by what I personally think people should do). What do you think about that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524:1005,predict,predict,1005,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524,2,['predict'],['predict']
Safety,"Well, there was a major bug associated with the fact that we were trying to avoid precomputed the diffusivities. Basically, diffusivities cannot be computed on the fly due to the ""predictor-corrector"" algorithm we use for implicit time stepping. Opting to precompute diffusivities solves this problem, at the cost of three additional 3D model fields when using `TKEBasedVerticalDiffusivity`. I think this is not a huge price to pay considering that models with 3 velocities and n tracers have (3 + n) * 3 fields already; thus in the simplest case (one buoyancy tracer and one TKE tracer) we incur ~20% (3/15) additional memory allocation from diffusivity precomputation. We can optimize memory allocation further in the future as well, potentially. On the upside, things are looking pretty good now. From the wind mixing validation:. ![image](https://user-images.githubusercontent.com/15271942/118858897-14dba700-b886-11eb-93b2-b4be1a6ea8ed.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1664#issuecomment-844323514:76,avoid,avoid,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1664#issuecomment-844323514,4,"['avoid', 'predict']","['avoid', 'predictor-corrector']"
Safety,"When I set the halo to be `halo=(3,3)` I get the following error message since it wants `halo=(3,3,0)`. This seems slightly less than idea. Should we make it so that either are acceptable?. ```; [2021/05/18 12:08:59.339] WARN Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid. -@-> /home/fpoulin/software/Oceananigans.jl/src/Grid; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843317614:348,avoid,avoid,348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843317614,1,['avoid'],['avoid']
Safety,"Which document are you referring to @Yixiao-Zhang ? . I think its important to enable Float32 for science applications. It's important enough that I think this could be the subject of a paper, especially since it does not seem trivially achievable. Multi-GPU is the safe solution right now. Single precision may also accelerate multi-GPU simulations though, because it reduces the amount of information that has to be communicated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389494160:266,safe,safe,266,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389494160,1,['safe'],['safe']
Safety,Why do we need to show an `OffsetArray` of a `CuArray`? Can we avoid that?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2316#issuecomment-1060142175:63,avoid,avoid,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2316#issuecomment-1060142175,1,['avoid'],['avoid']
Safety,"Writing `@allowscalar` will of course always fix a scalar indexing error. But you may end up with slow code, which defeats the purpose of using the GPU. Taking a look at the script: https://github.com/CliMA/Oceananigans.jl/blob/main/examples/kelvin_helmholtz_instability.jl. we see that there are calls to getindex in a few places:. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L190. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L197. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L256C1-L257C1. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L266. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L270. Wherever we write `energy[1, 1, 1]`, it is safe to use `@allowscalar`. This is just a single indexing operation and will be fast. However, where we write `collect`, its probably better to rewrite this in a different way. But note that `collect` is only used for plotting. So what we do here depends on the application. @sangeethasankar01 are you trying to get this to run on the GPU for some specific purpose? Or is this merely an educational exercise?. I also think we should convert this issue to a discussion. I don't think we want to make these changes to the example in the source code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2023037563:1055,safe,safe,1055,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2023037563,1,['safe'],['safe']
Safety,"Yeah adding the Unicode symbols broke the test, since the tests group detection doesn't recognize them",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3042#issuecomment-1616673693:70,detect,detection,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3042#issuecomment-1616673693,1,['detect'],['detection']
Safety,"Yep, the immersed boundary condition `ImmersedBoundaryCondition` has fields `west, east, south, north, top, bottom`, in that case the `south` immersed bc will be active (all the others will do nothing). Apparently if you construct it with the `immersed = BC` keyword (in the `FieldBoundaryConditions` constructor) that will copy the same BC for all directions, otherwise you can specify different BCs for different directions using the `ImmersedBoundaryCondition` constructor (or avoid them if, for example, you do not want side drag in that instance). For this reason the functions to be passed in the BC have to be 3D",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1183502106:480,avoid,avoid,480,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1183502106,1,['avoid'],['avoid']
Safety,"You can try incorporating the background buoyancy field into the forcing functions (formulated using the discrete form). You may also try inserting the parameters as globals rather than using the kwarg `parameters` (not sure if that will help). I'd also suggest testing whether the Smagorinsky closure affects the results of the simulation; if you can avoid using that you might be able to compile more complexity. After that, we may have to either divide up the kernels or pursue https://github.com/JuliaGPU/CUDA.jl/issues/267",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401327463:352,avoid,avoid,352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401327463,1,['avoid'],['avoid']
Safety,"You can use `FluxBoundaryCondition` with `closure=nothing` (it's `Value` and `Gradient` that won't work). You can obtain global dissipation by differencing globally integrated TKE (and perhaps a pointwise dissipation by evaluating the TKE budget), but I agree that it's probably more difficult. @simone-silvestri may have some tips as he has been developing an implicit LES scheme for mesoscale turbulence. Does `AnisotropicMinimumDissipation` work? Or other closures?. I'm wondering if the problem is the use of a `BinaryOperation` for the diffusivities with `SmagorinskyLilly`:. https://github.com/CliMA/Oceananigans.jl/blob/b7ad891c718c16db35d70ee86da81a74ad2f7370/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L214. It might be possible to avoid using that `BinaryOperation` by instead extending the three diffusivity getter functions:. https://github.com/CliMA/Oceananigans.jl/blob/b7ad891c718c16db35d70ee86da81a74ad2f7370/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L87-L89",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403103597:777,avoid,avoid,777,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403103597,1,['avoid'],['avoid']
Safety,"You don't need to give the grid as an argument. You are calling; ```; FieldBoundaryConditions(default_bounded_bc = NoFluxBoundaryCondition();; west = DefaultBoundaryCondition(default_bounded_bc),; east = DefaultBoundaryCondition(default_bounded_bc),; south = DefaultBoundaryCondition(default_bounded_bc),; north = DefaultBoundaryCondition(default_bounded_bc),; bottom = DefaultBoundaryCondition(default_bounded_bc),; top = DefaultBoundaryCondition(default_bounded_bc),; immersed = DefaultBoundaryCondition(default_bounded_bc)) = ; FieldBoundaryConditions(west, east, south, north, bottom, top, immersed); ```; This should be enough; ```; v_bcs = FieldBoundaryConditions(east = ValueBoundaryCondition(0)); ```. But good catch, we should probably force a type on `default_bounded_bc` to avoid this error, since we also have a `FieldBoundaryConditions(grid, location, indices=default_indices(3))` method which might be confusing",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2768#issuecomment-1267113558:785,avoid,avoid,785,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2768#issuecomment-1267113558,1,['avoid'],['avoid']
Safety,[49802e3a] + ProgressBars v1.5.0; [94ee1d12] + Quaternions v0.7.4; [74087812] + Random123 v1.6.1; [e6cf234a] + RandomNumbers v1.5.3; [c1ae055f] + RealDot v0.1.0; [3cdcf5f2] + RecipesBase v1.3.4; [189a3867] + Reexport v1.2.2; [ae029012] + Requires v1.3.0; [6038ab10] + Rotations v1.5.1; [6c6a2e73] + Scratch v1.2.0; [d496a93d] + SeawaterPolynomials v0.3.2; [66db9d55] + SnoopPrecompile v1.0.3; [276daf66] + SpecialFunctions v2.3.0; [aedffcd0] + Static v0.8.7; [0d7ed370] + StaticArrayInterface v1.4.0; [90137ffa] + StaticArrays v1.6.1; [1e83bf80] + StaticArraysCore v1.4.1; [15972242] + StaticPermutations v0.3.0; [5e0ebb24] + Strided v2.0.1; [4db3bf67] + StridedViews v0.1.2; [09ab397b] + StructArrays v0.6.15; [856f2bd8] + StructTypes v1.10.0; [3783bdb8] + TableTraits v1.0.1; [bd369af6] + Tables v1.10.1; [6aa5eb33] + TaylorSeries v0.15.2; [a759f4b9] + TimerOutputs v0.5.23; [3bb67fe8] + TranscodingStreams v0.9.13; [9d95972d] + TupleTools v1.3.0; [013be700] + UnsafeAtomics v0.2.1; [d80eeb9a] + UnsafeAtomicsLLVM v0.1.3; [81def892] + VersionParsing v1.3.0; [6e34b625] + Bzip2_jll v1.0.8+0; [4ee394cb] + CUDA_Driver_jll v0.5.0+1; [76a88914] + CUDA_Runtime_jll v0.6.0+0; [f5851436] + FFTW_jll v3.3.10+0; [0234f1f7] + HDF5_jll v1.14.0+0; [1d5cc7b8] + IntelOpenMP_jll v2023.1.0+0; [dad2f222] + LLVMExtra_jll v0.0.23+0; [1d63c593] + LLVMOpenMP_jll v15.0.4+0; [94ce4f54] + Libiconv_jll v1.16.1+2; [856f044c] + MKL_jll v2023.1.0+0; [7cb0a576] + MPICH_jll v4.1.2+0; [f1f71cc9] + MPItrampoline_jll v5.3.1+0; [9237b28f] + MicrosoftMPI_jll v10.1.3+4; [7243133f] + NetCDF_jll v400.902.208+0; [fe0851c0] + OpenMPI_jll v4.1.5+0; [458c3c95] + OpenSSL_jll v3.0.9+0; [efe28fd5] + OpenSpecFun_jll v0.5.5+0; [02c8fc9c] + XML2_jll v2.10.3+0; [3161d3a3] + Zstd_jll v1.5.5+0; [477f73a3] + libaec_jll v1.0.6+1; [0dad84c5] + ArgTools v1.1.1; [56f22d72] + Artifacts; [2a0f44e3] + Base64; [ade2ca70] + Dates; [8ba89e20] + Distributed; [f43a241f] + Downloads v1.6.0; [7b1f6079] + FileWatching; [b77e0a4c] + InteractiveUtils; ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:3683,Unsafe,UnsafeAtomicsLLVM,3683,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243,1,['Unsafe'],['UnsafeAtomicsLLVM']
Safety,"[i], 0, zC[k]); π = Π(i, 1, k, grid, gas, Θ). ρ[i, 1, k] = pₛ / (Rᵈ*θ) * π^(cᵥ/Rᵈ); Θ[i, 1, k] = ρ[i, 1, k] * θ; ```. From a user's perspective this is much more complicated than using Oceananigans' `set!` function. To further complicate things, how ρ is computed will change if you're running with entropy as a prognostic variable instead of potential temperature. > If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). This sounds like a good idea and would be of great benefit to users. > What does the jargon ""sounding"" mean?. Ah sorry I'm referring to [atmospheric soundings](https://en.wikipedia.org/wiki/Atmospheric_sounding). From talking to @thabbott apparently it's pretty common to initialize a model using observational data obtained from e.g. a weather balloon. Apparently some models get pretty fancy and construct a hydrostatic base state from the sounding to avoid transient acoustic waves when running the model. > I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. Hmmm, I wasn't super into the idea of a new `Simulation` type before but with multiple model types it makes more sense and would simplify the `Model` type by moving out output writers and diagnostics. I still think we don't need a new type and can simply define a new function like; ```julia; run_model!(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); ```; which just needs `time_step!` to be defined. > Nice work with the test cases @ali-ramadhan! No objections to merging from me, but I think we should have a discussion (in person or in a separate issue) about ways to separate aspects of the model that make it an atmosphere vs. an ocean model from things that make it a compressible vs. incompressible model. Thanks! Hmmm, that's a good point that currently the",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155:2130,avoid,avoid,2130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155,1,['avoid'],['avoid']
Safety,_jll v2.16.8+1; [442fdcdd] Measures v0.3.1; [9237b28f] MicrosoftMPI_jll v10.1.3+0; [e1d29d7a] Missings v0.4.5; [85f8d34a] NCDatasets v0.11.3; [872c559c] NNlib v0.7.18; [77ba4419] NaNMath v0.3.5; [7243133f] NetCDF_jll v400.701.400+0; [ca575930] NetworkOptions v1.2.0; [9e8cae18] Oceananigans v0.54.2; [6fe1bfb0] OffsetArrays v1.6.2; [e7412a2a] Ogg_jll v1.3.4+2; [fe0851c0] OpenMPI_jll v4.0.2+2; [458c3c95] OpenSSL_jll v1.1.1+6; [efe28fd5] OpenSpecFun_jll v0.5.3+4; [91d4177d] Opus_jll v1.3.1+3; [bac558e1] OrderedCollections v1.4.0; [2f80f16e] PCRE_jll v8.42.0+4; [69de0a69] Parsers v1.1.0; [0e08944d] PencilArrays v0.9.3; [4a48f351] PencilFFTs v0.12.2; [30392449] Pixman_jll v0.40.0+0; [ccf2f8ad] PlotThemes v2.0.1; [995b91a9] PlotUtils v1.0.10; [91a5bcdd] Plots v1.12.0; [21216c6a] Preferences v1.2.1; [ea2cea3b] Qt5Base_jll v5.15.2+0; [3cdcf5f2] RecipesBase v1.1.1; [01d81517] RecipesPipeline v0.3.2; [189a3867] Reexport v1.0.0; [ae029012] Requires v1.1.3; [6038ab10] Rotations v1.0.2; [1bc83da4] SafeTestsets v0.0.1; [6c6a2e73] Scratch v1.0.3; [d496a93d] SeawaterPolynomials v0.2.0; [992d4aef] Showoff v1.0.2; [a2af1166] SortingAlgorithms v0.3.1; [276daf66] SpecialFunctions v1.3.0; [aedffcd0] Static v0.2.4; [90137ffa] StaticArrays v1.1.1; [15972242] StaticPermutations v0.3.0; [2913bbd2] StatsBase v0.33.5; [09ab397b] StructArrays v0.5.1; [856f2bd8] StructTypes v1.7.1; [fa267f1f] TOML v1.0.3; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.4.2; [6aa5eb33] TaylorSeries v0.10.13; [a759f4b9] TimerOutputs v0.5.8; [3bb67fe8] TranscodingStreams v0.9.5; [bc48ee85] Tullio v0.2.13; [5c2747f8] URIs v1.2.0; [a2964d1f] Wayland_jll v1.17.0+4; [2381bf8a] Wayland_protocols_jll v1.18.0+4; [02c8fc9c] XML2_jll v2.9.10+3; [aed1982a] XSLT_jll v1.1.33+4; [4f6342f7] Xorg_libX11_jll v1.6.9+4; [0c0b7dd1] Xorg_libXau_jll v1.0.9+4; [935fb764] Xorg_libXcursor_jll v1.2.0+4; [a3789734] Xorg_libXdmcp_jll v1.1.3+4; [1082639a] Xorg_libXext_jll v1.3.4+4; [d091e8ba] Xorg_libXfixes_jll v5.0.3+4; [a51aa0fd] Xorg_l,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824063115:3711,Safe,SafeTestsets,3711,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824063115,1,['Safe'],['SafeTestsets']
Safety,"`0` is almost always safe. But neither case is really an issue. The main issues are when the entirety of a heavy kernel (like one that calculates a tendency) may be promoted to higher precision. ~`fill(var, 0)`~ `fill!(var, 0)` is cheap and unlikely to affect performance. That said it's just more precise to write `fill(var, zero(eltype(var)))` (this is _exactly_ what you are trying to do) and therefore the preferred way to write it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723671988:21,safe,safe,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723671988,1,['safe'],['safe']
Safety,"`^` is one of the operations we define on `AbstractField`:. https://github.com/CliMA/Oceananigans.jl/blob/927630699aac7d071b87cc87350fce6f69dbbd07/src/AbstractOperations/AbstractOperations.jl#L71. I think users will hit `Float64` exponentiation if they use this (unless they convert to `Int32`) since it the operation doesn't get compiled until after the exponent is stored:. ```julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: Oceananigans will use 8 threads. julia> grid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); c = CenterField(CPU(), grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 1, 1); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux). julia> op = c^2; BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree:; ^ at (Center, Center, Center);    ├── Field located at (Center, Center, Center);    └── 2. julia> op.b; 2; ```. Also just as a sanity check:. ```julia; julia> op32 = c^Int32(2); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree:; ^ at (Center, Center, Center);    ├── Field located at (Center, Center, Center);    └── 2. julia> typeof(op32.b); Int32; ```. Further work needed to dig into this though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1832#issuecomment-876057623:1330,sanity check,sanity check,1330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1832#issuecomment-876057623,1,['sanity check'],['sanity check']
Safety,"```; Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question. Stacktrace:; [1] error(s::String); @ Base .\error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore C:\Users\ADMIN\.julia\packages\GPUArraysCore\GMsgk\src\GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore C:\Users\ADMIN\.julia\packages\GPUArraysCore\GMsgk\src\GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore C:\Users\ADMIN\.julia\packages\GPUArraysCore\GMsgk\src\GPUArraysCore.jl:116; [5] getindex(A::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); @ GPUArrays C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:48; [6] scalar_getindex; @ C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:34 [inlined]; [7] _getindex; @ C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:17 [inlined]; [8] getindex; @ C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:15 [inlined]; [9] getindex; @ C:\Users\ADMIN\.julia\packages\OffsetArrays\rMTtC\src\OffsetArrays.jl:422 [inlined]; [10] getindex; @ C:\Users\ADMIN\.julia\packages\Oceananigans\E4XVr\src\Fields\field.jl:540 [inlined]; [11] rescale!(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, @NamedTuple{u::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Fl... (repeats 1 time); [12] top-level scope; @ In[10]:9; ```. This is an error message I am getting from my code. Please share your comments on how to resolve this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2019782299:286,avoid,avoided,286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2019782299,1,['avoid'],['avoided']
Safety,"`const` matters when a variable is referenced as a global variable in a function; something like. ```julia; const a = 2; f(x) = a * x; ```. `a` is not an argument to `f(x)`; it's value is taken from the global scope. In that case it needs to be `const`, or `f(x)` cannot be compiled on the GPU. When numbers are added to explicit data structures --- which is what happens when they are inserted into the `parameters` kwarg in the constructor for `BoundaryCondition` or `Forcing` --- then it's irrelevant whether a variable is declared `const`. This is because in that case the variable is explicitly an argument to the function (eg via the argument `p` in `boundary_condition(x, y, t, p)`). In fact, this is the purpose of the `parameters` kwarg --- to avoid having to use `const` (which is annoying or inconvenient, and has compilation / performance pitfalls). However the API has not developed enough to completely avoid `const` in all cases (eg for `BackgroundFields`, or for masking / target functions in things like `Relaxation`). So we still wrestle with it from time to time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697:753,avoid,avoid,753,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697,2,['avoid'],['avoid']
Safety,"antFormulation] | 2 1 3; Shallow Water Bickley jet simulation [GPU, ConservativeFormulation] | 2 1 3; ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored, 0 broken.; in expression starting at /g/data/v45/nc3020/OC.jl/test/runtests.jl:3; ERROR: Package Oceananigans errored during testing. (Oceananigans) pkg> st; Project Oceananigans v0.76.5; Status `/g/data/v45/nc3020/OC.jl/Project.toml`; [79e6a3ab] Adapt v3.3.3; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.4.6; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.11.2; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.7; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. julia> versioninfo(); Julia Version 1.6.7; Commit 3b76b25b64* (2022-07-19 15:11 UTC); Platform Info:; OS: Linux (x86_64-redhat-linux); CPU: Intel(R) Xeon(R) Platinum 8268 CPU @ 2.90GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; JULIA_DEPOT_PATH = /g/data/v45/nc3020/.julia:/share/julia/site/; JULIA_CUDA_USE_BINARYBUILDER = false; JULIA_LOAD_PATH = @:@v#.#:@stdlib:@site; JULIA_NUM_THREADS = 48. shell> nvidia-smi -q. ==============NVSMI LOG==============. Timestamp : Tue Feb 21 07:30:33 2023; Driver Version : 525.60.13; CUDA Version : 12.0. Attached GPUs : 1; GPU 00000000:3D:00.0; Product Name : Tesla V100-SXM2-32GB; Product Brand : ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:18245,Safe,SafeTestsets,18245,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Safe'],['SafeTestsets']
Safety,"aves. In other words, if particles and thus fluid undergo some net drift, then some external mean force must have imparted mean momentum to the fluid. So the first sentence of the Wikipedia article misleads. It's easy to get this wrong because in many systems the mean dynamics are ""trivial"" and do not evolve. But this is not always the case... The reason this subject is so tricky is because the physics of surface gravity waves _require_ a transfer of mean momentum from some external agent if they are excited (this is part of what it means for a wave field to have pseudomomentum). Thus the forced growth of waves is _also_ associated with a transfer of mean momentum (from the atmosphere to the ocean). But the mean momentum so transferred is not by any reasonable definition a ""wave property""; it undergoes an independent evolution and is easily divorced from wave fields that propagate rapidly away. In particular, if the system is rotating, the mean momentum excites a stationary inertial oscillation that has no net transport over long periods of time (while the wave field happily propagates ad infinitum)... Not that Wikipedia was always right before this on every topic --- but the view on Wikipedia is the same one that's taught in classrooms. I think users know _mathematically_ what is indicated by the keyword `stokes_drift`, especially if we well-document the fact that we solve for the Lagrangian-mean velocity. That's probably the most important thing. Buhler (2014) provides a good perspective on these issues, but doesn't really directly attack the primary conceptual error here (perhaps because such an attack is politically unpopular). I also am publishing a paper on this topic... https://glwagner.github.io/assets/pdf/near-inertial-waves-turbulence-growth-swell-preprint.pdf. I'm not sure this point matters much practically, but I think it might not be responsible to let it slide by without discussion. This was the original reason I avoided using the word `stokes_drift`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777919611:2448,avoid,avoided,2448,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777919611,1,['avoid'],['avoided']
Safety,c] LogExpFunctions v0.3.15; [e6f89c97] LoggingExtras v1.0.0; [da04e1cc] MPI v0.19.2; [3da0fdf6] MPIPreferences v0.1.7; [1914dd2f] MacroTools v0.5.9; [739be429] MbedTLS v1.1.7; [442fdcdd] Measures v0.3.2; [e1d29d7a] Missings v1.1.0; [78c3b35d] Mocking v0.7.5; [85f8d34a] NCDatasets v0.12.4; [77ba4419] NaNMath v1.0.0; [9e8cae18] Oceananigans v0.76.5 `/g/data/v45/nc3020/OC.jl`; [6fe1bfb0] OffsetArrays v1.11.2; [4d8831e6] OpenSSL v1.3.3; [bac558e1] OrderedCollections v1.4.1; [69de0a69] Parsers v2.3.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [b98c9c47] Pipe v1.3.0; [ccf2f8ad] PlotThemes v3.1.0; [995b91a9] PlotUtils v1.3.4; [91a5bcdd] Plots v1.36.0; [21216c6a] Preferences v1.3.0; [94ee1d12] Quaternions v0.5.6; [74087812] Random123 v1.5.0; [e6cf234a] RandomNumbers v1.5.3; [3cdcf5f2] RecipesBase v1.2.1; [01d81517] RecipesPipeline v0.6.9; [189a3867] Reexport v1.2.2; [05181044] RelocatableFolders v1.0.0; [ae029012] Requires v1.3.0; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1; [6c6a2e73] Scratch v1.1.1; [d496a93d] SeawaterPolynomials v0.2.3; [992d4aef] Showoff v1.0.3; [777ac1f9] SimpleBufferStream v1.1.0; [66db9d55] SnoopPrecompile v1.0.3; [a2af1166] SortingAlgorithms v1.1.0; [276daf66] SpecialFunctions v2.1.5; [aedffcd0] Static v0.6.5; [90137ffa] StaticArrays v1.4.4; [15972242] StaticPermutations v0.3.0; [82ae8749] StatsAPI v1.5.0; [2913bbd2] StatsBase v0.33.21; [5e0ebb24] Strided v1.2.2; [09ab397b] StructArrays v0.6.7; [856f2bd8] StructTypes v1.8.1; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.7.0; [6aa5eb33] TaylorSeries v0.10.13; [62fd8b95] TensorCore v0.1.1; [f269a46b] TimeZones v1.9.1; [a759f4b9] TimerOutputs v0.5.19; [bdfc003b] TimesDates v0.3.1; [3bb67fe8] TranscodingStreams v0.9.6; [bc48ee85] Tullio v0.3.4; [9d95972d] TupleTools v1.3.0; [5c2747f8] URIs v1.4.2; [1cfade01] UnicodeFun v0.4.1; [41fe7b60] Unzip v0.1.2; [81def892] VersionParsing v1.3.0; [6e34b625] Bzip2_jll v1.0.8+0; [83423d85] Cairo_jll v1.16.1+1; [2e619515] Ex,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:4826,Safe,SafeTestsets,4826,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Safe'],['SafeTestsets']
Safety,"casa_token=K2HHnGIuaukAAAAA:5PhiRAM7tprmr73KhLpcARMloUdkxYFc0j8hukBAsr_MVpz6BlPSHTg-OoIajqdiaBvQbug-9w) (semi-Lagrangian vertical coordinate that follows high-pass filtered fast motions only and is restored to a target grid on a relatively short time scale). Other formulations, including classical sigma coordinates and quasi-Lagrangian methods that involve grid warping severe enough to require remapping, may fail unless we improve our method for calculating the horizontal pressure gradient force. In particular, the method we use now is essentially finite difference and requires a vertical coordinate that exactly or ""almost"" coincides with a geopotential surface. Finite volume treatment of the pressure gradient force is discussed by. * [Lin (1997)](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=AKlxv5lyqCcAAAAA:iRV8loXCjnioqxfxVDYQQX7oESyUjXPRF7KEZvYk7TCc_fRLhuiy0oGuza5KOGu9ucP63ZPbgCUI5sY) in the context of an atmospheric model with an effectively linear equation of state; * [Shchepetkin and McWilliams (2003)](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2001JC001047) which implements a high-order method for evaluating a contour integral around momentum elements for computing the pressure gradient force; * [Adcroft et al (2008)](https://www.sciencedirect.com/science/article/pii/S1463500308000243?casa_token=97k7TULeY9QAAAAA:_fsnUYOj7nBHPzGZXSO7jG31LMu4qlvJce8lsyof9jQPeICA4CFlsHA6KhH-81xRBiYoiMxElQ) that utilizes a crucial ""analytical integration"" step valid for for a nonlinear equation of state that can be written in a ""simplified"" form, which avoids the relatively more expensive numerical integration of part of the contour (and is more accurate); * [Engwirda et al (2017)](https://www.sciencedirect.com/science/article/pii/S1463500317300665?casa_token=egcQ20_UnnAAAAAA:WuCxxWYCfVpuL8-mrbSLJriY1z9W1TbiQNirtaJ9ZeIoIZkpOWbsod7AY7kLhxy8vcl5GfzcTw) using high-order numerical integration techniques for nonlinear equations of state",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679#issuecomment-847224041:2201,avoid,avoids,2201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679#issuecomment-847224041,2,['avoid'],['avoids']
Safety,"consider the tilted bottom boundary layer example: https://clima.github.io/OceananigansDocumentation/stable/literated/tilted_bottom_boundary_layer/. In this problem, the buoyancy is decomposed ($b=\bar{b} + b^{\prime}$) into a background component $\bar{b} = N^{2} \hat{z}$ (where $\hat{z}$ is positive in the direction opposite the gravitational vector) and the remaining perturbation. The current example script applies no boundary conditions to the perturbation buoyancy, which I believe defaults to a no-normal-flux condition at the top and bottom boundary. Because no boundary conditions are applied to the background field, there is an implied diffusive flux $\hat{\mathbf{n}} \cdot (-\kappa \nabla \bar{b}) = ±\kappa N^{2} \cos{\theta}$ across these boundaries. This means that the boundary condition on the total buoyancy is a non-zero flux across the seafloor, which does not make much sense for this problem. The normal way of implementing this problem is to apply a gradient boundary condition, $\frac{\partial b^{\prime}}{\partial z} = -N^{2}\cos{\theta}$, at the bottom, to impose the no-flux condition. (In my MITgcm configurations, I verified that implementing the boundary condition this way recovered the classical analytical solutions of [Garrett et al. 1993](https://www.annualreviews.org/doi/10.1146/annurev.fl.25.010193.001451). Here is [another example using Dedalus](https://github.com/hdrake/bmli-linear/blob/main/examples/evp_replicate_Wenegrat2018_growth_rates.ipynb) to replicate some of Jacob Wenegrat's results, where I also include a non-zero gradient boundary condition on the perturbation buoyancy to impose no flux on the total buoyancy.). I understand why one might want background fields to be constructed a certain way for idealized problems, but it should be communicated clearly (and consistently) to the user exactly how this works. Is the tilted bottom boundary layer example incorrectly implemented or do I still not understand how the background fields work?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083158198:1263,recover,recovered,1263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083158198,2,['recover'],['recovered']
Safety,dd2f] MacroTools v0.5.6; [739be429] MbedTLS v1.0.3; [c8ffd9c3] MbedTLS_jll v2.16.8+1; [442fdcdd] Measures v0.3.1; [9237b28f] MicrosoftMPI_jll v10.1.3+0; [e1d29d7a] Missings v0.4.5; [85f8d34a] NCDatasets v0.11.3; [872c559c] NNlib v0.7.14; [77ba4419] NaNMath v0.3.5; [7243133f] NetCDF_jll v400.701.400+0; [9e8cae18] Oceananigans v0.54.2; [6fe1bfb0] OffsetArrays v1.6.1; [e7412a2a] Ogg_jll v1.3.4+2; [fe0851c0] OpenMPI_jll v4.0.2+2; [458c3c95] OpenSSL_jll v1.1.1+6; [efe28fd5] OpenSpecFun_jll v0.5.3+4; [91d4177d] Opus_jll v1.3.1+3; [bac558e1] OrderedCollections v1.4.0; [2f80f16e] PCRE_jll v8.42.0+4; [69de0a69] Parsers v1.0.15; [0e08944d] PencilArrays v0.7.0; [4a48f351] PencilFFTs v0.12.2; [30392449] Pixman_jll v0.40.0+0; [ccf2f8ad] PlotThemes v2.0.1; [995b91a9] PlotUtils v1.0.10; [91a5bcdd] Plots v1.9.0; [ede63266] Qt_jll v5.15.2+3; [3cdcf5f2] RecipesBase v1.1.1; [01d81517] RecipesPipeline v0.2.1; [189a3867] Reexport v0.2.0; [ae029012] Requires v1.1.2; [6038ab10] Rotations v1.0.2; [1bc83da4] SafeTestsets v0.0.1; [6c6a2e73] Scratch v1.0.3; [d496a93d] SeawaterPolynomials v0.2.0; [992d4aef] Showoff v0.3.2; [a2af1166] SortingAlgorithms v0.3.1; [276daf66] SpecialFunctions v0.10.3; [90137ffa] StaticArrays v0.12.5; [15972242] StaticPermutations v0.2.1; [2913bbd2] StatsBase v0.33.3; [09ab397b] StructArrays v0.5.0; [856f2bd8] StructTypes v1.4.0; [3783bdb8] TableTraits v1.0.0; [bd369af6] Tables v1.3.2; [6aa5eb33] TaylorSeries v0.10.13; [a759f4b9] TimerOutputs v0.5.8; [3bb67fe8] TranscodingStreams v0.9.5; [bc48ee85] Tullio v0.2.13; [a2964d1f] Wayland_jll v1.17.0+4; [2381bf8a] Wayland_protocols_jll v1.18.0+4; [02c8fc9c] XML2_jll v2.9.10+3; [aed1982a] XSLT_jll v1.1.33+4; [4f6342f7] Xorg_libX11_jll v1.6.9+4; [0c0b7dd1] Xorg_libXau_jll v1.0.9+4; [935fb764] Xorg_libXcursor_jll v1.2.0+4; [a3789734] Xorg_libXdmcp_jll v1.1.3+4; [1082639a] Xorg_libXext_jll v1.3.4+4; [d091e8ba] Xorg_libXfixes_jll v5.0.3+4; [a51aa0fd] Xorg_libXi_jll v1.7.10+4; [d1454406] Xorg_libXinerama_jll v1.1.4+4; [ec84b674],MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824043189:3927,Safe,SafeTestsets,3927,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824043189,1,['Safe'],['SafeTestsets']
Safety,"e easier for users to extend / add terms to an equation. As an example, we can consider a simple implementation. ```julia; struct AdvectiveFlux{S, D, C, G}; u :: D; v :: D; w :: D; c :: C; grid :: G; scheme :: S; end. getindex(adv::AdvectiveFlux{Centered}, i, j, k) = # centered advective flux calculation. struct IsotropicDiffusiveFlux{N, D, G}; ν :: N; ψ :: D; grid :: G; end. getindex(diff::IsotropicDiffusiveFlux, i, j, k) = # calculates flux due to isotropic diffusion by ν. struct RightHandSide{F, V}; fluxes :: F; volume_terms :: V; end. advection = AdvectiveFlux(velocities..., tracers.c); diffusion = IsotropicDiffusiveFlux(ν, tracers.c). tracer_rhs = RightHandSide((advection, diffusion), nothing); ```. We'd have functions that look something like. ```julia; function x_flux_divergence(i, j, k, grid, fluxes...); incoming_flux = add_fluxes(i, j, k, grid, fluxes...); outgoing_flux = add_fluxes(i+1, j, k, grid, fluxes...); return (incoming_flux - outgoing_flux) * grid.Ax / grid.V; end; ```. ... for example. Obviously questions of performance are paramount, though in the case that _everything_ is inlined I think there is hope. A downside of this approach is that we can't use shared memory stencils on the GPU. Shared memory stencils on the GPU require _functions_ for all terms that avoid carrying around internal references to data (since we need to be able to pass them references to shared memory blocks, rather than references to global memory. This is a fair rewrite of the code internals. For example, each term in the `u_velocity_tendency`:. https://github.com/climate-machine/Oceananigans.jl/blob/8e3c27504be68ca06bacc7502cd6095ae390f8c6/src/TimeSteppers/velocity_and_tracer_tendencies.jl#L24. would get it's own type. It's worth brainstorming ways to implement such abstraction incrementally so we might avoid possibly time-consuming total-code-demolishment. This is mostly food for thought at this point. I don't think we should take action without substantial consideration.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394:1905,avoid,avoid,1905,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394,2,['avoid'],['avoid']
Safety,"e would like to add a small floating point number (the time step) to a very large number (the model time). . - I think the issue with the time-step is whether or not we can compute the RHS of the pressure Poisson equation accurately --- which is `div(u') / Δt`, where `u' = u + Δt * Gu` is the predictor velocity and `div` is the divergence. This is interesting, because I could not figure out why we would ever find large `div(u')` with small `Δt` even in this MWE. But now I realize that because of the status of the immersed Poisson solver, the velocity along the boundary is divergent, strongly so. So, `div(u')` is large along the boundary. And when we divide by `Δt` we get something huge. The magnitude of `div(u')` also somehow seems to depend on the time step (as does the magnitude of the spurious circulation). The correct solution to this case remains at rest of course. (An aside is that this problem _could_ be avoided by separately computing the hydrostatic pressure, and then using a special horizontal gradient operators that avoid computing a hydrostatic pressure gradient across an immersed boundary. However, this would only be correct for no-flux boundary conditions on buoyancy on side walls). Anyways, apparently because of this issue with the immersed pressure solver, it seems that `div(u')` is large (because `div(u)` is large) even when `Δt = O(1e-14)`... - As a result of all of this I am confused about whether this MWE is actually reliable for debugging the issue. I guess we should expect to see problems simply when `Δt = O(eps)` because this is when `div(u') / Δt` cannot be reliably computed, I think. This leads to a fairly simple criteria for the time step that's compatible with the pressure correction. But as noted in this PR, this is not enough to fix issues with the immersed boundary MWE... but whether or not that is because of problems with the setup itself, I'm not sure... - All of that said, taking @tomchor suggestion to be more careful in updating the ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153020136:1211,avoid,avoided,1211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153020136,4,['avoid'],"['avoid', 'avoided']"
Safety,"e). model = NonhydrostaticModel(; grid,; advection = WENO(grid=grid, order=5),; tracers = (:b, :τ1, :τ2, :τ3), # This runs fine with one fewer tracer now; closure = SmagorinskyLilly(C=0.1),; background_fields = (b=B_field,),; forcing = (u=Fᵤ, v=Fᵥ, w=Fw, b=Fb),; ); @info model. simulation = Simulation(model, Δt=1, stop_iteration=10). run!(simulation); ```. My actual production code is far too complicated to paste here, but the relevant forcings I'm using there are:. ```julia; const z₀ = -100; const z₂ = -120; const z₁ = -grid.Lz. @inline function bottom_mask_cos(x, y, z); if z₀ >= z > z₁; return 1/2 * (1 - cos( π*(z-z₀)/(z₁-z₀) )); elseif z₁ >= z #> z₂; return 1.0; else; return 0.0; end ; end. @inline sponge_u(x, y, z, t, u, p) = -bottom_mask_cos(x, y, z) * p.σ * u; @inline sponge_v(x, y, z, t, v, p) = -bottom_mask_cos(x, y, z) * p.σ * v; @inline sponge_w(x, y, z, t, w, p) = -bottom_mask_cos(x, y, z) * p.σ * w; @inline sponge_b(x, y, z, t, b, p) = -bottom_mask_cos(x, y, z) * p.σ * (b - b∞(0, 0, z, 0, p)). Fᵤ = Forcing(sponge_u, field_dependencies = :u, parameters = (; params.σ)); Fᵥ = Forcing(sponge_v, field_dependencies = :v, parameters = (; params.σ)); Fw = Forcing(sponge_w, field_dependencies = :w, parameters = (; params.σ)); Fb = Forcing(sponge_b, field_dependencies = :b, parameters = (; params.σ, params.N²∞)); ```. The above are the forcing functions, and below is the background field. There are also parameters passed for the boundary conditions. ```julia; @inline b_bg(x, y, z, t, p) = p.M² * x; B_field = BackgroundField(b_bg, parameters = (; params.M²)); ```. Changing things so that variables that are currently passed as parameters are set as `const`ants helps (as you can see I did with `z₀`, etc.). However, that also means I can't run back-to-back simulations where those parameters differ, which is something that makes my workflow way more streamlined, so I'm trying to avoid that. (Although I'll ultimately have to do that if we can't figure this error out...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401329050:3349,avoid,avoid,3349,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401329050,1,['avoid'],['avoid']
Safety,"e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -> List of process identifiers. Launch np workers on the local host using the in-built LocalManager. Local workers inherit the current package environment (i.e., active project, LOAD_PATH, and DEPOT_PATH) from the main process. Keyword arguments:. • restrict::Bool: if true (default) binding is restricted to 127.0.0.1. • dir, exename, exeflags, env, topology, lazy, enable_threaded_blas: same effect as for SSHManager, see documentation for; addprocs(machines::AbstractVector). │ Julia 1.9; │; │ The inheriting of the package environment and the env keyword argument were added in Julia 1.9.; ```. Ha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:5663,timeout,timeout,5663,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['timeout'],['timeout']
Safety,"el image is invalid (code 200, ERROR_INVALID_IMAGE); ```. amazingly, the error continues to morph. ```julia; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 803; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Name16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES2_I9_1__1__1_ES2_I9_1__1__1_EvvEEv14__PassType_253v12DisableHooksE14_gpu__compute_11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI4CellS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE9_identity20RegularCartesianGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEEE5Int64S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_I4FaceS12_S27_S13_S16_IS27_S12_S27_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES15_IS12_S27_S27_S13_S16_IS12_S27_S27_S25_S8_IS9_Li3ES10_IS9_Li3ELi1EEES18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEES24_S18_S18_S18_S19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEEES14_IS18_S18_S18_7__xz___7__yz___ES19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEEE' uses too much parameter space (0x1408 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738867889:2354,abort,aborted,2354,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738867889,1,['abort'],['aborted']
Safety,"emoving `v` as a background creates oscillations. @glwagner have you checked? If not, let's wait for the video to see what happens... > * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Good move :+1: . > * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; > * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated). I tried to make it 100% GPU friendly actually (although I didn't test it). You already pointed out one flaw, which is the use of an array instead of a tuple for the unit vertical vector. > * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity. This only happens with me when the NetCDF file is open by another program (generally python in my case) while Julia is trying to write to it. Was that the case? If so, that's the usual behavior afaik and I don't think we can do anything on our end except inform users about it. > * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?. If we can get away with the computational cost I see no problem there. I just made this one 2D because it runs faster. > * Can we tilt the visualization? It's disorienting to be looking at the flow at an angle of 3 degrees. I tried to do that but couldn't make it work in Julia. Feel free to give it a shot!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138:1436,avoid,avoid,1436,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138,1,['avoid'],['avoid']
Safety,"f5c54c55a7a9a3aa42bf931c72aa""; uuid = ""85f8d34a-cbdd-5861-8df4-14fed0d494ab""; version = ""0.11.3"". [[NNlib]]; deps = [""Adapt"", ""ChainRulesCore"", ""Compat"", ""LinearAlgebra"", ""Pkg"", ""Requires"", ""Statistics""]; git-tree-sha1 = ""80b8360670f445d88b3475e88b33bbcc92f7866e""; uuid = ""872c559c-99b0-510c-b3b7-b6c96a88d5cd""; version = ""0.7.19"". [[NaNMath]]; git-tree-sha1 = ""bfe47e760d60b82b66b61d2d44128b62e3a369fb""; uuid = ""77ba4419-2d1f-58cd-9bb1-8ffee604a2e3""; version = ""0.3.5"". [[NetCDF_jll]]; deps = [""Artifacts"", ""HDF5_jll"", ""JLLWrappers"", ""LibCURL_jll"", ""LibSSH2_jll"", ""Libdl"", ""MbedTLS_jll"", ""Pkg"", ""Zlib_jll"", ""nghttp2_jll""]; git-tree-sha1 = ""d5835f95aea3b93965a1a7c06de9aace8cb82d99""; uuid = ""7243133f-43d8-5620-bbf4-c2c921802cf3""; version = ""400.701.400+0"". [[Oceananigans]]; deps = [""Adapt"", ""CUDA"", ""Crayons"", ""CubedSphere"", ""Dates"", ""FFTW"", ""Glob"", ""InteractiveUtils"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SafeTestsets"", ""SeawaterPolynomials"", ""Statistics"", ""StructArrays"", ""Tullio""]; git-tree-sha1 = ""861d8cca4447304a21a94110e3ffc786cab52dce""; uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; version = ""0.56.0"". [[OffsetArrays]]; deps = [""Adapt""]; git-tree-sha1 = ""87a728aebb76220bd72855e1c85284c5fdb9774c""; uuid = ""6fe1bfb0-de20-5000-8ca7-80f57d26f881""; version = ""1.7.0"". [[OpenMPI_jll]]; deps = [""Libdl"", ""Pkg""]; git-tree-sha1 = ""41b983e26a7ab8c9bf05f7d70c274b817d541b46""; uuid = ""fe0851c0-eecd-5654-98d4-656369965a5c""; version = ""4.0.2+2"". [[OpenSSL_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""71bbbc616a1d710879f5a1021bcba65ffba6ce58""; uuid = ""458c3c95-2e84-50aa-8efc-19380b2a3a95""; version = ""1.1.1+6"". [[OpenSpecFun_jll]]; deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""9db77584158d0ab52307f8c04f8e7c08ca76b5b3""; uuid = ""efe28fd5-8261-553b-a9e1-b2916fc3738e""; version",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:11329,Safe,SafeTestsets,11329,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Safe'],['SafeTestsets']
Safety,"he problem. It only fails intermittently.; > ; > We have some validation of the shallow water model in the example. I propose that in order to move forward, we should generate a few additional validation tests including some with bathymetry. Once we have those and have analyzed them to ensure we are satisfied with the dynamics, we should then work on designing a better regression test --- one that won't ""pass"" when it should not. Then we can add that better regression test to our test suite, and remove the warning from the shallow water model constructor.; > ; > Probably best to also resolve the issue with the pressure gradient in presence of bathymetry. Maybe a topographic Rossby wave or some such would help build confidence that we are treating non-uniform bathymetry correctly with both of the formulations that we have. Thanks for the explanation. I agree that looking at a topographic Rossby wave is a good test to have. In the case of a small linear slope and small amplitude wave, it should be close to an exact solution so that will be easy. If we want more challenging tests, there are no shortage of those. Lots of tests have shocks and people like to test those but I would suggest avoiding those, as shocks mean the aspect ratio is order one or larger, and that violates the underyling hydrostatic assumption in the model. We could take the Bicklet jet example we have and put it over topography and compute the growth rates. There is a Poulin and Flierl (2005) in JPO that studies that and it would be easy enough to put to get linear stability code to compute the growth rates. That way we also have some theory to support the code. Also, we could look at a wind-driven gyre problem with and without topography. Not a simple test but would help to validate the global simulations that @simone-silvestri did a while ago with the shallow water model. Lots we can do!. I don't remember the issue about the pressure gradient term with bathymetry but happy to get into it sometime.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1498158496:1293,avoid,avoiding,1293,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1498158496,2,['avoid'],['avoiding']
Safety,"hm... I merged master and the unit tests seem to fail saying. ```julia. [2021/04/09 19:34:17.876] WARN Checksum did not match -@-> /storage7/buildkite-agent/.julia-1983/packages/DataDeps/ooWXe/src/verification.jl:24; --;   | Do you wish to Abort, Retry download or Ignore;   | [a/r/i]; ```. Apparently buildkite is not answering so tests stop at that point indefinitely... https://buildkite.com/clima/oceananigans/builds/1983#a259cdda-aa8b-40f1-861f-e198c1e7c7f2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-817029289:240,Abort,Abort,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-817029289,1,['Abort'],['Abort']
Safety,"iguration/. * Configuring SLURM correctly may also require some trial and error, because the documentation is unclear and there are a huge number of options. I can't figure out if the documentation is wrong, in fact, or if instead the engaging cluster does not support some options. Either way, a small test script like. ```julia; using MPI. MPI.Init(); @show MPI.Comm_rank(MPI.COMM_WORLD); @show MPI.Comm_size(MPI.COMM_WORLD); ```. Is helpful for debugging. Also, I recommend first trying to start jobs interactively before using `sbatch`. Interactive jobs launch faster, so we get a faster trial-error iteration. I'm still working on things, but it seems like another point may be salient:. * Initialize / precompile outside of a parallel job before trying to launch a parallel job via `mpiexec`. Here are some notes that may be specific to engaging:. I'm using `srun` to get a 4-GPU node to use interactively:. ```; srun -p my_partition --tasks-per-node=4 --cpus-per-task=32 --gres=gpu:4 --gpus-per-node=4 --mem=0 -t 01:00:00 -N 1; ```. it seems we have to use the option `gpus-per-node`, rather than setting the total number of GPUs. Also we redundantly also have to specify `gres=gpu:4` (`gres` stands for ""generalized resource""). Why `gres` can't tell what `gpus-per-node` is, I don't know. `-N 1` means 1 node. Finally we also have to specify ``--tasks-per-node=4` (matching `gres` _and_ the number of GPUs per node), otherwise we cannot launch `mpiexec` with 4 tasks (1 for each GPU). It's helpful to have the maximum number of CPUs for precompilation. Otherwise precompilation is very slow. I also set. ```; export JULIA_NUM_PRECOMPILE_TASKS=64; ```. (half the total) --- adapt for your system. Here is also a small test script for debuggin Oceananigans:. ```julia; using Oceananigans; arch = Distributed(GPU()); @show arch; ```. as a side note, it would be nice if we could print to the screen from different ranks without them talking over one another. It makes it hard to read the output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436:1713,redund,redundantly,1713,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436,2,['redund'],['redundantly']
Safety,"llect(0:192), architecture = Arch()). if Scheme == :Uniform; scheme = WENO5(); elseif Scheme == :Stretched; scheme = WENO5(grid = grid); elseif Scheme == :StretchedSmoothness; scheme = WENO5(grid = grid, stretched_smoothness = true); elseif Scheme == :ZFormulation; scheme = WENO5(zweno = true); end; model = NonhydrostaticModel(architecture=Arch(), grid=grid, advection=scheme). time_step!(model, 1) # warmup. trial = @benchmark begin; @sync_gpu time_step!($model, 1); end samples=10. return trial; end. Schemes = (:Uniform, :Stretched, :StretchedSmoothness, :ZFormulation); ```; This PR, with a ""stretched"" vertical direction ; ```; ┌───────────────┬─────────────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Schemes │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ Stretched │ 7.122 s │ 7.122 s │ 7.122 s │ 7.122 s │ 949.91 KiB │ 1716 │ 1 │; │ CPU │ StretchedSmoothness │ 11.042 s │ 11.042 s │ 11.042 s │ 11.042 s │ 956.47 KiB │ 1716 │ 1 │; │ CPU │ Uniform │ 6.373 s │ 6.373 s │ 6.373 s │ 6.373 s │ 945.38 KiB │ 1706 │ 1 │; │ CPU │ ZFormulation │ 7.725 s │ 7.725 s │ 7.725 s │ 7.725 s │ 945.38 KiB │ 1706 │ 1 │; │ GPU │ Stretched │ 25.646 ms │ 25.920 ms │ 26.501 ms │ 32.101 ms │ 2.15 MiB │ 30442 │ 10 │; │ GPU │ StretchedSmoothness │ 109.080 ms │ 109.493 ms │ 109.676 ms │ 111.118 ms │ 3.78 MiB │ 134069 │ 10 │; │ GPU │ Uniform │ 25.133 ms │ 25.394 ms │ 25.468 ms │ 26.710 ms │ 2.06 MiB │ 27799 │ 10 │; │ GPU │ ZFormulation │ 30.554 ms │ 32.780 ms │ 32.569 ms │ 32.922 ms │ 2.20 MiB │ 37382 │ 10 │; └───────────────┴─────────────────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┴─────────┘; ```; Apparently on a much larger grid than what I tested, StretchedSmoothness is much less efficient, another reason to try to avoid it if not strictly necessary!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738:5499,avoid,avoid,5499,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738,1,['avoid'],['avoid']
Safety,"losure = ScalarDiffusivity(; ν, κ=(; b=κᵇ)); true_model = NonhydrostaticModel(; grid, closure, velocities, tracers, buoyancy=BuoyancyTracer()); ```. which produces. ```julia; julia> true_model = NonhydrostaticModel(; grid, closure, velocities, tracers, buoyancy=BuoyancyTracer()); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 1×1×128 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: b; ├── closure: ScalarDiffusivity{ExplicitTimeDiscretization}(ν=BinaryOperation at (Center, Center, Center), κ=(b=UnaryOperation at (Center, Center, Center),)); ├── buoyancy: BuoyancyTracer with -ĝ = ZDirection; └── coriolis: Nothing; ```. note the type of `model.closure`. (Also note this doesn't work with `HydrostaticFreeSurfaceModel` apparently... we need to fix that.). One downside of this method is that it precludes `VerticallyImplicitTimeDiscretization()`: because we use a predictor-corrector method for implicit time discretization, diffusivities that are treated implicitly _must_ be precomputed. ## Subtleties. There's more. There are subtleties peculiar to using `Ri` in a closure, because `Ri` easily becomes NaN when both the buoyancy gradient and shear are zero. The usual solution to this for ocean modeling is to use the ""hack"" that 0/0 = 0. In other words, NaNs are intercepted and set to 0. There are again a few solutions to this. One is simply to set all `NaN` to zero in side the function that computes `Ri`, eg. ```julia; u, v, w = model.velocities; b = model.tracers.b; Ri_op = @at (Center, Center, Center) ∂z(b) / (∂z(u)^2 + ∂z(v)^2). """""" Compute the Richardson number and store in `Ri`. """"""; function compute_Ri!(sim); Ri .= Ri_op. # Zero out NaNs; Ri_parent = parent(Ri); parent(Ri_parent)[isnan.(Ri_parent)] .= 0. fill_halo_regions!(Ri, sim.model.architecture); return nothing; end; ```. Other possibilities are 1) use `ConditionalOperation` to intercept `0/0` ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065995186:3692,predict,predictor-corrector,3692,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1065995186,2,['predict'],['predictor-corrector']
Safety,"lp, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.7 (2022-07-19); _/ |\__'_|_|_|\__'_| |; |__/ |. (Oceananigans) pkg> test; Testing Oceananigans; Status `/jobfs/73413669.gadi-pbs/jl_XhyZPR/Project.toml`; [79e6a3ab] Adapt v3.3.3; [6e4b80f9] BenchmarkTools v1.3.2; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [124859b0] DataDeps v0.7.10; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.4.6; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [9e8cae18] Oceananigans v0.76.5 `/g/data/v45/nc3020/OC.jl`; [6fe1bfb0] OffsetArrays v1.11.2; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [91a5bcdd] Plots v1.36.0; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.7; [a759f4b9] TimerOutputs v0.5.19; [bdfc003b] TimesDates v0.3.1; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates `@stdlib/Dates`; [b77e0a4c] InteractiveUtils `@stdlib/InteractiveUtils`; [37e2e46d] LinearAlgebra `@stdlib/LinearAlgebra`; [56ddb016] Logging `@stdlib/Logging`; [44cfe95a] Pkg `@stdlib/Pkg`; [de0858da] Printf `@stdlib/Printf`; [9a3f8284] Random `@stdlib/Random`; [2f01184e] SparseArrays `@stdlib/SparseArrays`; [10745b16] Statistics `@stdlib/Statistics`; [8dfed614] Test `@stdlib/Test`; Status `/jobfs/73413669.gadi-pbs/jl_XhyZPR/Manifest.toml`; [621f4979] AbstractFFTs v1.1.0; [79e6a3ab] Adapt v3.3.3; [4fba245c] ArrayInterface v6.0.1; [30b0a656] ArrayInterfaceCore v0.1.2; [ab4f0b2a] BFloat16s v0.2.0; [6e4b80f9] BenchmarkTools v1.3.2; [d1d4a3ce] BitFlags v0.1.7; [fa961155] CEnum v0.4.2; [179af706] CFTime v0.1.2; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [49dc2e85] Calculus v0.5.1; [7",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:1230,Safe,SafeTestsets,1230,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Safe'],['SafeTestsets']
Safety,"n't have to write extra functions that dispatch on the forcing, thus simplifying the time stepping code. As you point out we don't want to write _5! = 120_ new functions. The `update_source_terms!` function is already 52 lines long so I'd rather avoid having to dispatch on this function. > An argument against macros is that they make the code more obscure. It's harder to figure out what is happening because you have to find the definition of the macro. I think this is context-dependent. The purpose of a macro with a name like `@insert_forcing_u` or `@insert_forcing_term` is pretty clear. If we used dispatch then you'd still have to scroll through multiple function definitions. > Come to think of it, the user can also just define a forcing function that indexes into some constant array. Why is this not a good solution?. I think this would work pretty well. I couldn't figure out how to pass in the array to be indexed so that it can fit in the `Fu(grid, velocities, tracers, i, j, k)` signature and be available for the user to fill. Where in the model should we store the forcing array in this case?. Hmmm, actually we could make the function accept the forcing struct, e.g.; ```julia; Fu(grid, velocities, tracers, forcing, i, j, k); ```; but then we'd have to have arrays in the forcing struct, e.g.; ```julia; struct Forcing{Tu,Tv,Tw,TT,TS,TA<:AbstractArray}; u::Tu; v::Tv; w::Tw; T::TT; S::TS; u_arr::TA; v_arr::TA; w_arr::TA; T_arr::TA; S_arr::TA; end; ```; and then the forcing function is just; ```julia; Fu(grid, velocities, tracers, forcing, i, j, k) = forcing.u_arr[i, j, k]; ```. Either we have 5 array types so fields with an actual forcing function get `nothing` for the array or we have 1 array type `TA` and set the arrays for forcings with a function to something like `Array{Float64}(undef, 0)`. Might be a little too ugly but I think yeah we should be able to accommodate array forcings with the current framework somehow (and avoid complicating the time stepping code).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470548318:2067,avoid,avoid,2067,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470548318,1,['avoid'],['avoid']
Safety,net/ productionresultssa8.blob.core.windows.net/ productionresultssa9.blob.core.windows.net/ productionresultssa10.blob.core.windows.net/ productionresultssa11.blob.core.windows.net/ productionresultssa12.blob.core.windows.net/ productionresultssa13.blob.core.windows.net/ productionresultssa14.blob.core.windows.net/ productionresultssa15.blob.core.windows.net/ productionresultssa16.blob.core.windows.net/ productionresultssa17.blob.core.windows.net/ productionresultssa18.blob.core.windows.net/ productionresultssa19.blob.core.windows.net/ github-production-repository-image-32fea6.s3.amazonaws.com github-production-release-asset-2e65be.s3.amazonaws.com insights.github.com wss://alive.github.com; font-src github.githubassets.com; form-action 'self' github.com gist.github.com copilot-workspace.githubnext.com objects-origin.githubusercontent.com; frame-ancestors 'none'; frame-src viewscreen.githubusercontent.com notebooks.githubusercontent.com; img-src 'self' data: github.githubassets.com media.githubusercontent.com camo.githubusercontent.com identicons.github.com avatars.githubusercontent.com github-cloud.s3.amazonaws.com objects.githubusercontent.com secured-user-images.githubusercontent.com/ user-images.githubusercontent.com/ private-user-images.githubusercontent.com opengraph.githubassets.com github-production-user-asset-6210df.s3.amazonaws.com customer-stories-feed.github.com spotlights-feed.github.com objects-origin.githubusercontent.com *.githubusercontent.com; manifest-src 'self'; media-src github.com user-images.githubusercontent.com/ secured-user-images.githubusercontent.com/ private-user-images.githubusercontent.com github-production-user-asset-6210df.s3.amazonaws.com gist.github.com; script-src github.githubassets.com; style-src 'unsafe-inline' github.githubassets.com; upgrade-insecure-requests; worker-src github.com/assets-cdn/worker/ gist.github.com/assets-cdn/worker/; Transfer-Encoding: chunked; X-GitHub-Request-Id: 85AA:37E5AB:1E9255C:2BAFBE6:6674307A; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2180730454:4181,unsafe,unsafe-inline,4181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2180730454,1,['unsafe'],['unsafe-inline']
Safety,"nt changes:. * I removed the `BackgroundField` v-velocity, which had no effect on the solution because the domain is `Flat` in y. The only effect of the background flow is through the bottom drag boundary condition.; * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Minor changes:. * Update style to be consistent with other examples / source code (commas, spaces, etc); * Reorganized the script to read like the other examples / tutorials (like a paper, parameters are introduced when they are used rather than at the top); * Reorganized a few other misc stuff for pedagogical reasons, like building buoyancy + coriolis together; * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; * Change tilting angle to 3 degrees rather than 0.05 radians; * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated); * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity; * Plotting fewer contours makes the animation faster (the most expensive part of this example); * We don't need to form `Field`s any more for the output writers any more. Idle thoughts:. * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?; * Can we tilt the visualization? It's disorienting to be looking at the flow at an angle of 3 degrees.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449:1643,avoid,avoid,1643,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449,1,['avoid'],['avoid']
Safety,"o switch on/off different terms in the MEKE budget. For instance, as of now, MOM6 OM4 only uses the `PrognosticMEKEDiffusivity` (and no backscatter), but the CPT and others are looking into the energetically-constrained backscatter term intensively these days!; 3. **MEKE vs. GEOMETRIC**: As you mention above, the two schemes are very similar. There are maybe three notable differences: ; a) **energy type**: MEKE solves a prognostic equation for `EKE`, whereas GEOMETRIC solves a prognostic equation for `EKE + EPE`. To inform GM, the two schemes then use the variable `2 * EKE` and `EKE + EPE`, respectively. [Bachman (2017)](10.1016/j.ocemod.2016.12.004) found that in practice, kappa_GM is not sensitive to whether one solves for `EKE` (as MEKE does) or `EKE + EPE` (as GEOMETRIC does). So we could probably start by following the MEKE approach, and just solve for `EKE`.; b) **GM/energy source term**: In MEKE, it is left to the user how to specify the mixing length scale `L_mix` in `kappa_GM = c * sqrt(2 MEKE) * L_mix` and in the inferred MEKE source term. (Options are: the deformation scale, Rhines scale, grid scale, frictional halting scale, Eady length scale, or any combination of those, see [here](https://github.com/NOAA-GFDL/MOM6/blob/0e8acd90b46656ccb7fbc73bc5911ef2733a345c/src/parameterizations/lateral/MOM_MEKE.F90#L995-L1012).) In GEOMETRIC, the mixing length scale is essentially chosen as the Eady length scale. So if you use MEKE with the Eady length scale `L_e` (see Appendix Ab in Kong and Jansen, 2021), you recover the GEOMETRIC source term.; c) **sub-grid dissipation**: MEKE assumes only bottom drag, GEOMETRIC uses one ""catch-all"" linear damping term as the energy sink term in the sub-grid energy budget. As highlighted in [Mak et al. (2022)](https://onlinelibrary.wiley.com/doi/abs/10.1029/2021GL097259), this sub-grid dissipation term is probably the big elephant in the room, which the solution is very sensitive to but noone knows what the term should look like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692:2705,recover,recover,2705,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692,1,['recover'],['recover']
Safety,"on; .; . for this reason I was thinking you cannot have a `DistributedNonhydrostaticModel` vs a `NonhydrostaticModel` as much as you don't have a `CPUNonhydrostaticModel` vs a `GPUNonhydrostaticModel`. About the future direction: I was thinking that `Distributed` could be as much of an architecture as `CPU` and `GPU` are. As an example, there is no GPU.jl module which individually extends all the other modules for gpu execution like the extending the Fields.jl module with a `gpu_fields.jl` in GPU.jl. But I see what you mean when you say boundary conditions and fields have to take the precedence over distributed because it is maybe more linear to extend them in a separate module. Maybe integrating fields and boundary conditions in the respective modules (how is done for CPU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends on the topology of the grid. If then the models should not know about the architecture you would incur in a user code which looks something like ; ```; parent_grid = Rectilin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:1191,interlock,interlocked,1191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,1,['interlock'],['interlocked']
Safety,"oops - pasted this in the wrong place earlier! . @glwagner and @ali-ramadhan I took a quick look.; I think you should go ahead and merge, but quick comments for future reference -. there are a bunch of changes unrelated to the PR in the PR. They are probably there by accident, but the Git gods really don't like that. When done well a PR can be a very helpful record for show what needs to be changed to achieve ""X"". When the PR is polluted with random other stuff that valuable use is lost. Most git projects more diligent about avoiding polluted PRs, which can be useful. I think ultimately we want halos to just be a thing that does a slightly more general form of what is in ::PBC mode. Everything else is not in halo rules. This is where we ended up in MITgcm and is similar to what is in MPIStateArray in the DG work (I am fairly sure!). A distinction to maybe think about is a set of halo() functions that just do the stuff that does not appear in any of the equations. Anything in equations turns out to be stuff that people may want to tinker with in surprisingly interesting ways. For example someone ultimately might want to do a numerical experiment that has flux BC on some set of the one bit of a boundary, something else on another bit etc.... (people do do things like this). For better or worse having bc's better separated from halos may ultimately prove the right thing. For now I wouldn't worry about it though!. Related to 2. I suspect that trying to express complicated things like hybrid bc's will eventually break reducing bc to a type. Types are good for simple things, but Type::ItsComplicated is often also needed eventually. summary - +1 for merge, ; per https://github.com/google/eng-practices/blob/master/review/reviewer/standard.md ""its a step forward, its not a step backward, its maybe not the ultimate answer""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-529061853:531,avoid,avoiding,531,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-529061853,1,['avoid'],['avoiding']
Safety,prTools v0.1.6; [7a1cc6ca] + FFTW v1.4.5; [5789e2e9] + FileIO v1.11.1; [0c68f7d7] + GPUArrays v8.1.1; [61eb1bfa] + GPUCompiler v0.12.9; [c27321d9] + Glob v1.3.0; [615f187c] + IfElse v0.1.0; [92d709cd] + IrrationalConstants v0.1.0; [82899510] + IteratorInterfaceExtensions v1.0.0; [033835bb] + JLD2 v0.4.14; [692b3bcd] + JLLWrappers v1.3.0; [0f8b85d8] + JSON3 v1.9.1; [63c18a36] + KernelAbstractions v0.7.0; [929cbde3] + LLVM v4.6.0; [2ab3a3ac] + LogExpFunctions v0.3.3; [da04e1cc] + MPI v0.19.0; [1914dd2f] + MacroTools v0.5.8; [85f8d34a] + NCDatasets v0.11.7; [77ba4419] + NaNMath v0.3.5; [9e8cae18] + Oceananigans v0.63.1; [6fe1bfb0] + OffsetArrays v1.10.7; [bac558e1] + OrderedCollections v1.4.1; [69de0a69] + Parsers v2.0.5; [0e08944d] + PencilArrays v0.10.0; [4a48f351] + PencilFFTs v0.12.5; [21216c6a] + Preferences v1.2.2; [74087812] + Random123 v1.4.2; [e6cf234a] + RandomNumbers v1.5.3; [189a3867] + Reexport v1.2.2; [ae029012] + Requires v1.1.3; [6038ab10] + Rotations v1.0.2; [1bc83da4] + SafeTestsets v0.0.1; [d496a93d] + SeawaterPolynomials v0.2.2; [276daf66] + SpecialFunctions v1.7.0; [aedffcd0] + Static v0.3.3; [90137ffa] + StaticArrays v1.2.13; [15972242] + StaticPermutations v0.3.0; [5e0ebb24] + Strided v1.1.2; [09ab397b] + StructArrays v0.6.3; [856f2bd8] + StructTypes v1.7.3; [3783bdb8] + TableTraits v1.0.1; [bd369af6] + Tables v1.6.0; [6aa5eb33] + TaylorSeries v0.10.13; [a759f4b9] + TimerOutputs v0.5.13; [3bb67fe8] + TranscodingStreams v0.9.6; [bc48ee85] + Tullio v0.3.2; [9d95972d] + TupleTools v1.3.0; [f5851436] + FFTW_jll v3.3.10+0; [0234f1f7] + HDF5_jll v1.12.0+1; [1d5cc7b8] + IntelOpenMP_jll v2018.0.3+2; [dad2f222] + LLVMExtra_jll v0.0.11+0; [856f044c] + MKL_jll v2021.1.1+2; [7cb0a576] + MPICH_jll v3.4.2+0; [9237b28f] + MicrosoftMPI_jll v10.1.3+0; [7243133f] + NetCDF_jll v400.702.400+0; [fe0851c0] + OpenMPI_jll v4.1.1+2; [458c3c95] + OpenSSL_jll v1.1.10+0; [efe28fd5] + OpenSpecFun_jll v0.5.5+0; [0dad84c5] + ArgTools; [56f22d72] + Artifacts; [2a0f44e3] + Base6,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:2619,Safe,SafeTestsets,2619,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237,1,['Safe'],['SafeTestsets']
Safety,"rpretable and readable. I'm not sure we would achieve the same if we hide such a feature inside the source code. Does @navidcy's suggestion work for you @tomchor ?. I also think it is preferred to use separate files for a situation like this (though it may not be necessary to save intermediate times in the spin-up at all --- so a second file might not be necessary). If the spin up is recorded, I think it's better to use a separate file for its data. If the spin up is expensive, the following performance optimization could be used (we can leverage the `velocities` kwarg to save a bit of allocation):. ```julia; # Spin up with no tracers; model = NonhydrostaticModel(; tracers=nothing, kwargs...); simulation = Simulation(model, ...) # etc; run!(simulation). # Run for real, re-using the old `velocities` fields but overwriting the old `model`; model = NonhydrostaticModel(; tracers=:c, velocities=model.velocities, kwargs...); simulation = Simulation(model, ...) # etc; ```. There is some additional memory allocation for tendencies in this case, however, so it may not work for simulations that push GPU memory. > (I'm not aware of any way to ""remove"" the old Simulation from the GPU memory, but if there is, then this downside can be negated.). This occurs automatically with garbage collection, provided that there's no reference to the old simulation in the name space. CUDA may have a way to manually call the garbage collector, after doing something like `model=nothing; simulation=nothing`. If you figure that out, it'd be nice to know. > It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work. I don't follow, but if there's something to improve about picking simulations up we should pursue that. PS @milankl may be interested in this discussion, because it illustrates the importance of being able to modify tracer fields mid-run rather than requiring that they are initialized when the model is built.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1605717680:1922,safe,safe,1922,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1605717680,1,['safe'],['safe']
Safety,"s:. ```Julia; julia> using Oceananigans; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/E3Wer/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> N = 32; 32. julia> grid = RegularRectilinearGrid(Float32, size=(N, N, N), extent=(1, 1, 1)); RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (32, 32, 32); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.03125f0, 0.03125f0, 0.03125f0). julia> model = IncompressibleModel(architecture=GPU(), float_type=Float32, advection=WENO5(), grid=grid); ┌ Warning: Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid.; └ @ Oceananigans.Grids /g/data/v45/nc3020/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; IncompressibleModel{GPU, Float32}(time = 0 seconds, iteration = 0); ├── grid: RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded}(Nx=32, Ny=32, Nz=32); ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: SeawaterBuoyancy{Float32, LinearEquationOfState{Float32}, Nothing, Nothing}; └── coriolis: Nothing. julia> time_step!(model, 1); ERROR: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Ocean",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360:1047,avoid,avoid,1047,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360,1,['avoid'],['avoid']
Safety,"step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > ; > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there. Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. The pressure source term is the divergence of the predictor velocity divided by time-step. As the time-step vanishes, the divergence of the predictor velocity also vanishes (because the flow has not evolved from its previous, non-divergent solution). We get a situation tending to 0/0. I think there's a few things we could do to solve this. First of all if we take a very small time-step, I think we can actually just re-set the model time rather than taking a time-step. Second I am wondering if we want to implement a time type that has finite resolution (ie there is a smallest time increment one can take). For example, datetimes have a smallest unit (micro or nanoseconds). A non-dimensional or dimensional-agnostic time type could also be designed analogously (eg every time is the multiple of an integer by the fundamental unit). This would eliminate round off error but it's a bit of work and also we have to put some thought into how best to accomplish it. There might also be a simpler solution by adjusting how we increment time. I'm not sure. > Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?. I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025:1032,predict,predictor,1032,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025,2,['predict'],['predictor']
Safety,"stol=1.49e-08, solver iterations: 0, residual: (mean=0.00e+00, abs(max)=0.00e+00); [ Info: ... simulation initialization complete (109.482 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (4.840 seconds).; iteration: 1, time: 0.1000, U_max=(1.19e-02, 5.23e-03, 5.19e-03); reltol=1.49e-08, abstol=1.49e-08, solver iterations: 4096, residual: (mean=-1.78e-03, abs(max)=1.06e-02); iteration: 2, time: 0.2000, U_max=(1.21e-02, 4.93e-03, 5.20e-03); reltol=1.49e-08, abstol=1.49e-08, solver iterations: 4096, residual: (mean=-9.30e-04, abs(max)=5.56e-03); iteration: 3, time: 0.3000, U_max=(1.25e-02, 5.02e-03, 5.32e-03); reltol=1.49e-08, abstol=1.49e-08, solver iterations: 4096, residual: (mean=-4.85e-04, abs(max)=2.74e-03); iteration: 4, time: 0.4000, U_max=(6.23e+24, 4.49e+24, 6.19e+24); reltol=1.49e-08, abstol=1.49e-08, solver iterations: 4096, residual: (mean=-2.39e+23, abs(max)=1.51e+24); iteration: 5, time: 0.5000, U_max=(5.48e+179, 4.19e+179, 9.91e+179); reltol=1.49e-08, abstol=1.49e-08, solver iterations: 0, residual: (mean=-1.70e+174, abs(max)=1.13e+181); ERROR: LoadError: time = 0.6, iteration = 6: NaN found in field u. Aborting simulation.; ```. I tried reducing the time step from 0.1 to 0.01 but now it always blows up at iteration 1. Increasing the time step kept it blowing up after ~5 iterations. ---. > You can test this by omitting the preconditioner. Running with `preconditioner = nothing` causes it to always blow up on iteration 1 no matter the time step (after 4096 iterations). ```; [ Info: Initializing simulation...; iteration: 0, time: 0.0000, U_max=(0.00e+00, 0.00e+00, 0.00e+00); reltol=1.49e-08, abstol=1.49e-08, solver iterations: 0, residual: (mean=0.00e+00, abs(max)=0.00e+00); [ Info: ... simulation initialization complete (99.042 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.896 seconds).; ERROR: LoadError: time = 0.1, iteration = 1: NaN found in field u. Aborting simulation.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2412573112:3576,Abort,Aborting,3576,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2412573112,2,['Abort'],['Aborting']
Safety,"t the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid(arch; kwargs...); ; NonhydrostaticModel(arch, parent_grid (for pressure solver), local_grid); ```; (which could be avoided by eliminating the `Periodic` topology which I am all in favour of but maybe is a too much of a deep change) in the end you still have to pass two grids to the `NonhydrostaticModel`. I was thinking, to avoid this pattern for the user, we have two options; (1) store the local grid in the architecture, and take it within the model if `arch == MultiArch` then you can do this; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...) # interchangeable with CPU() or GPU(). NonhydrostaticModel(arch, parent_grid); ```; The problem now is the fields. Ideally you want to have the fields know that they are on a `MultiArch` so that they don't allocate the whole memory field on all the processes, so you would want them to allocate on `arch.local_grid` if the the arch is Distributed... (2) the other way around where `arch` stores the parent grid then you would have; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); grid = local_grids(arch, parent_grid) # where local_grids(::CPU(), grid) = grid and local_grids(::GPU(), grid) = grid. # from here on out you can ""forget"" about the parent_grid. NonhydrostaticModel(arch, grid); ```. Which, maybe, despite the additional local_grids call, is a better option as you wouldn't have to change the Fields module. Also, the NonhydrostaticModel will become ""agnostic"" to the architecture in this way. Actually maybe this direction is much better (I will change the PR to reflect this option)... In the end, what do you think? How should we solve this `grid` vs `architecture` conundrum avoiding the definition of a `DistributedModel`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:4022,avoid,avoiding,4022,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,1,['avoid'],['avoiding']
Safety,"tVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::Oceananigans.Fields.ZeroField, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); @ ~/software/New_Oceananigans/Oceananigans.jl/src/Advection/momentum_advection_operators.jl:16; ```. The function `_advective_momentum_flux_Ww(i, j, k, grid, scheme, W, w)` is called in `div_Uw`. Later on we see this:. ```; [6] div_Uw(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. Rewriting the error message makes it a bit clearer:. ```julia; div_Uw(::Int64, ::Int64, ::Int64, ; ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ; ::WENO5, ; ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ; ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. We thus see that the first four arguments are `i, j, k, grid`, the fifth argument is `WENO5`, the sixth argument is a named tuple of `ZeroField`s, and the seventh argument is an `OffsetArray`. The sixth argument --- `U` --- is a tuple of `ZeroField`s when the default value of `background_fields.velocities` is the advecting velocity field:. https://github.com/CliMA/Oceananigans.jl/blob/78f63ff9329b15ce20c33faed11e96ebf0dbc67d/src/Models/IncompressibleModels/velocity_and_tracer_tendencies.jl#L140. This PR helps the compiler realize that `div_Uw` called when `U` is a tuple of `ZeroField` should return zero. By avoiding any attempt to compile a stencil for `div_Uw` when `U` is a tuple of `ZeroField` it also skips the step that produces the error.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-871449828:2174,avoid,avoiding,2174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-871449828,2,['avoid'],['avoiding']
Safety,"tandards.; >; > Unfortunately, CF conventions don't quite provide the right vocabulary to; > describe the curvilinear geometry of staggered grid models compactly (see; > cf-convention/discuss#5; > <https://github.com/cf-convention/discuss/issues/5>). In the meantime,; > every modeling center seems to have their own preference for how to encode; > this (e.g. comodo conventions; > <https://web.archive.org/web/20160417032300/http://pycomodo.forge.imag.fr/norm.html>; > [now offline] used by ROMS and NEMO, S-grid; > <https://github.com/sgrid/sgrid>, mosaics; > <https://extranet.gfdl.noaa.gov/~vb/talks/grids-short.pdf> from GFDL).; >; > With xgcm, we decided to use the Comodo conventions (rather than invent; > yet another new convention). In retrospect, this was maybe the wrong; > choice, since the pycomodo project seems to have totally disappeared. 🤦; > However, if you put the right metadata; > <https://xgcm.readthedocs.io/en/latest/grids.html#detecting-axes-from-dataset-attributes>; > in your attributes, xgcm should be able to figure out your grid.; >; > Whatever you do, please try your best to squeeze your data into existing; > standard file formats and metadata conventions.; > Don't invent something new. MITgcm did this with the mds data format and; > it has been endless headaches for our community. I don't know what JLD2 is,; > but it sounds like you could be going down that route...; >; > If you have any questions, please ask! I'll try to respond.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQXRYPNOI5TLPGVKV3DS6L7EJANCNFSM4XBBPGJA>; > .; >. -- ; ==========================================; John Marshall; Earth, Atmospheric and Planetary Sciences, MIT; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777140535:1538,detect,detecting-axes-from-dataset-attributes,1538,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777140535,1,['detect'],['detecting-axes-from-dataset-attributes']
Safety,"tecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends on the topology of the grid. If then the models should not know about the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid(arch; kwargs...); ; NonhydrostaticModel(arch, parent_grid (for pressure solver), local_grid); ```; (which could be avoided by eliminating the `Periodic` topology which I am all in favour of but maybe is a too much of a deep change) in the end you still have to pass two grids to the `NonhydrostaticModel`. I was thinking, to avoid this pattern for the user, we have two options; (1) store the local grid in the architecture, and take it within the model if `arch == MultiArch` then you can do this; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...) # interchangeable with CPU() or GPU(). NonhydrostaticModel(arch, parent_grid); ```; The problem now is the fields. Ideally you want to have the fields know that they are on a `MultiArch` so that they don't allocate the whole memory field on all the processes, so you would want them to allocate on `arch.local_grid` if the the arch is Distributed... (2) the other way around where `arch` stores the parent grid then you would have; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); grid = local_grids(arch, par",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:2394,avoid,avoided,2394,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,1,['avoid'],['avoided']
Safety,ternions v0.7.6; [74087812] Random123 v1.7.0; [e6cf234a] RandomNumbers v1.5.3; [c1ae055f] RealDot v0.1.0; [3cdcf5f2] RecipesBase v1.3.4; [189a3867] Reexport v1.2.2; [ae029012] Requires v1.3.0; [6038ab10] Rotations v1.7.1; [6c6a2e73] Scratch v1.2.1; [d496a93d] SeawaterPolynomials v0.3.4; [91c51154] SentinelArrays v1.4.5; [a2af1166] SortingAlgorithms v1.2.1; [276daf66] SpecialFunctions v2.4.0; ⌅ [aedffcd0] Static v0.8.9; [0d7ed370] StaticArrayInterface v1.5.1; [90137ffa] StaticArrays v1.9.7; [1e83bf80] StaticArraysCore v1.4.3; [15972242] StaticPermutations v0.3.0; [82ae8749] StatsAPI v1.7.0; [5e0ebb24] Strided v2.1.0; [4db3bf67] StridedViews v0.3.1; [892a3eda] StringManipulation v0.3.4; [09ab397b] StructArrays v0.6.18; [856f2bd8] StructTypes v1.10.0; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.12.0; ⌅ [6aa5eb33] TaylorSeries v0.16.0; [a759f4b9] TimerOutputs v0.5.24; [3bb67fe8] TranscodingStreams v0.11.0; [24ddb15e] TransmuteDims v0.1.16; [9d95972d] TupleTools v1.5.0; [013be700] UnsafeAtomics v0.2.1; [d80eeb9a] UnsafeAtomicsLLVM v0.1.5; [81def892] VersionParsing v1.3.0; [0b7ba130] Blosc_jll v1.21.5+0; [6e34b625] Bzip2_jll v1.0.8+1; [4ee394cb] CUDA_Driver_jll v0.9.1+1; [76a88914] CUDA_Runtime_jll v0.14.1+0; [f5851436] FFTW_jll v3.3.10+0; [0951126a] GnuTLS_jll v3.8.4+0; ⌃ [0234f1f7] HDF5_jll v1.14.2+1; [e33a78d0] Hwloc_jll v2.11.0+0; [1d5cc7b8] IntelOpenMP_jll v2024.2.0+0; [9c1d0b0a] JuliaNVTXCallbacks_jll v0.2.1+0; [dad2f222] LLVMExtra_jll v0.0.30+0; [1d63c593] LLVMOpenMP_jll v15.0.7+0; [94ce4f54] Libiconv_jll v1.17.0+0; [5ced341a] Lz4_jll v1.9.4+0; [856f044c] MKL_jll v2024.2.0+0; [7cb0a576] MPICH_jll v4.2.1+1; [f1f71cc9] MPItrampoline_jll v5.4.0+0; [9237b28f] MicrosoftMPI_jll v10.1.4+2; [e98f9f5b] NVTX_jll v3.1.0+2; ⌃ [7243133f] NetCDF_jll v400.902.209+0; ⌅ [4c82536e] Nettle_jll v3.7.2+0; [fe0851c0] OpenMPI_jll v5.0.3+0; [458c3c95] OpenSSL_jll v3.0.14+0; [efe28fd5] OpenSpecFun_jll v0.5.5+0; [c2071276] P11Kit_jll v0.24.1+0; [02c8fc9c] XML2_jll v2.13.1+0; [ffd25f8,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:19214,Unsafe,UnsafeAtomics,19214,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['Unsafe'],['UnsafeAtomics']
Safety,"that we need different Coriolis functions for Cartesian and Spherical coordinates. Why do we need different functions or nonhydrostatic (and shallow water I presumme) and hydrostatic?; > ; > I'm also not clear, although I'm assuming that it has to do with `w` being treated differently (since `w` appears in the equations for the horizontal rotation components). @glwagner can you clarify?. Yes, when we make the hydrostatic approximation, we assume that the aspect ratio is thin and H/L is small. The hydrostatic assumption specifically refers to the use of this scaling in the vertical momentum equation (reducing it to a diagnostic equation for hydrostatic pressure). This same scaling applied to the Coriolis force leads to the ""traditional"" approximation such that Coriolis terms involving the _vertical_ velocity are neglected from the horizontal momentum equations (likewise, the terms involving the horizontal momentum are neglected from the vertical momentum balance; neglecting these terms must be made consistently for the system to conserve kinetic energy). This thin-aspect-ratio approximation (probably best to avoid implicating ""tradition"" in model formulation...) also needs to be invoked to justify ""f-plane"" and ""beta-plane"" approximations to the Coriolis term when the numerical model is supposed to approximate oceanic motion away from the poles. (The so-called ""non-traditional"" terms --- the projection of the planetary vorticity into horizontal directions --- have been variously found to have a small effect on turbulent boundary layer motions. This is probably because the effect of Coriolis forces is most pronounced at the largest scales, and the effect of the horizontal Coriolis components on large scale vertical motions is suppressed by the presence of an impenetrable surface at the top and bottom.). In Oceananigans, we have to express this notion with a _type_ to avoid adding spurious terms to the horizontal momentum equations that depend on the vertical velocity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888419861:1142,avoid,avoid,1142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888419861,4,['avoid'],['avoid']
Safety,"the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends on the topology of the grid. If then the models should not know about the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid(arch; kwargs...); ; NonhydrostaticModel(arch, parent_grid (for pressure solver), local_grid); ```; (which could be avoided by eliminating the `Periodic` topology which I am all in favour of but maybe is a too much of a deep change) in the end you still have to pass two grids to the `NonhydrostaticModel`. I was thinking, to avoid this pattern for the user, we have two options; (1) store the local grid in the architecture, and take it within the model if `arch == MultiArch` then you can do this; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...) # interchangeable with CPU() or GPU(). NonhydrostaticModel(arch, parent_grid); ```; The problem now is the fields. Ideally you want to have the fields know that they are on a `MultiArch` so that they don't allocate the whole memory field on all the processes, so you would want them to allocate on `arch.local_grid` if the the arch is Distributed... (2) the other way around where `arch` stores the parent grid then you would have; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); grid = local_grids(arch, parent_grid) # where local_grids(::CPU(), grid) = grid and local_grids(::GPU(), grid) = grid. # from here on out you can ""forget"" about the parent_grid. NonhydrostaticModel(arch, grid); ```. Which, maybe, despite the additional local_grids call, is a better option as yo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:2604,avoid,avoid,2604,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,1,['avoid'],['avoid']
Safety,"tructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-parallelism to reduce the overall time. @glwagner can control who on the project can submit bors jobs by editing the bors access control settings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:1273,timeout,timeouts,1273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778,1,['timeout'],['timeouts']
Safety,"ur talk:. ### Option 1. First option is we keep calling the directions `Vertical` and `Horizontal`, since those names are pretty intuitive and play well with already-defined terms like `VerticallyImplicit` (which are also intuitive and widely used in the literature). The downside to this option, if we were to follow (2), appears as an inconsistency whenever we tilt the domain and need to use `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)` (`ĝ` being a unit vector). So we could end up with a case where the vertical direction is implicitly defined as being tilted 45 degrees (by means of `Buoyancy`), but for `ScalarDiffusivity` `Vertical` will still mean the `z` direction, which is confusing. Furthermore, the default option for buoyancy would be called `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=Vertical())`, which is not helpful. ### Option 2. Second option is to change the notation to what I proposed here: `XYDirection` etc., which avoids this inconsistency. The downside is that it doesn't play well with terms like `VerticallyImplicit` anymore. Something we either would have to live with, or we'd need to change those terms as well (something like `ZImplicit` isn't wrong, but it's not what people generally call it). ### Option 3. We could also keep the names `Vertical` etc., but change the interface of `Buoyancy` so that it doesn't implicitly define that the vertical direction is. So instead of having the interface be. `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)`. it would be something like. `buoyancy = Buoyancy(model=BuoyancyTracer(), direction_antiparallel_to_gravity=ĝ)`. which is equally correct and doesn't assume that ""vertical"" is connected to the direction of gravity. The issue here is that the name `direction_antiparallel_to_gravity` is super long. ### Option 4. @simone-silvestri raised an interesting point that these aren't just ""directions"" they are also different formulations. In light ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915:1599,avoid,avoids,1599,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915,2,['avoid'],['avoids']
Safety,"ut it might not be the cleanest/most maintainable. I don't think we need to change anything in the existing kernels code. Instead, we can design an interface that allows biogeochemical models (like the models implemented in OceanBioME) to ""opt-in"" to a substepping scheme. In this design, there's no need to change the existing ""slow"" kernels I don't think. However, we could consider changing the name of them. For example, all that's needed is for the _implementation_ to know when to return a slow source term vs fast source term. > this is where I had to make some more changes to the existing code (and probably the messiest part of what I did), because the code often expects the tendencies to live at timestepper.G / $G^-$, so I made functions that dispatched on the timestepper and usually returned that, but for the new timestepepr returned timestepper.physics.G etc. I'm not sure that new tendencies are needed for substepping. The substepping scheme for CATKE manages to avoid allocating any additional tendencies by preserving the ""slow"" source term:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl#L167-L171. The only change that is needed within Oceananigans (in principle) --- as far as I can tell --- is to skip the tracer update for certain tracers (like we do for CATKE and TKEDissipation):. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L78-L85. Then the implementer of the BGC model has to perform the substepping inside `update_biogeochemical_state!`:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl#L49. Possibly we can go further and define an interface that does the substepp",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851:1335,avoid,avoid,1335,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851,2,['avoid'],['avoid']
Safety,"yeah, #2795 does supersede this PR, although #2795 has a custom implementation of transpose + FFT which we might want to avoid now that pencilFFT supports CuArrays",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1630300780:121,avoid,avoid,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1630300780,1,['avoid'],['avoid']
Safety,"⁻¹; │ ├── extrema(T): (-16387479425.34, 18491107419.68) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 997.956 ms; │ ├── max(u): (9.82e+04, 7.85e+04, 2.49e+03) m s⁻¹; │ ├── extrema(T): (-1654340357512160890046119936.00, 2003185335144995241362194432.00) ᵒC; └ └── max|η|: 2.34e+03 m; ```. so the temperature is blowing up. The problem persists even when we don't have an immersed boundary:. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 229.227 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (290.636 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.441 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 1.446 seconds; │ ├── max(u): (7.77e-23, 4.67e-05, 1.18e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.18e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 1.348 seconds; │ ├── max(u): (1.04e-08, 9.33e-05, 2.36e-06) m s⁻¹; │ ├── extrema(T): (-456436497.24, 490120296.28) ᵒC; └ └── max|η|: 3.55e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:4407,risk,risk,4407,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518,1,['risk'],['risk']
Safety,── v1.16.0; Installed PooledArrays ──────────────── v1.4.3; Installed FixedPointNumbers ─────────── v0.8.5; Installed Tables ────────────────────── v1.12.0; Installed LLVMLoopInfo ──────────────── v1.0.0; Installed GPUCompiler ───────────────── v0.26.7; Installed StaticArraysCore ──────────── v1.4.3; Installed TimerOutputs ──────────────── v0.5.24; Installed JLLWrappers ───────────────── v1.5.0; Installed InlineStrings ─────────────── v1.4.2; Installed AbstractFFTs ──────────────── v1.5.0; Installed IteratorInterfaceExtensions ─ v1.0.0; Installed StaticArrays ──────────────── v1.9.7; Installed PrecompileTools ───────────── v1.2.1; Installed DataValueInterfaces ───────── v1.0.0; Installed CUDA_Runtime_Discovery ────── v0.3.4; Installed NVTX_jll ──────────────────── v3.1.0+2; Installed LLVMExtra_jll ─────────────── v0.0.30+0; Installed LaTeXStrings ──────────────── v1.3.1; Installed OrderedCollections ────────── v1.6.3; Installed NVTX ──────────────────────── v0.3.4; Installed UnsafeAtomicsLLVM ─────────── v0.1.5; Installed CEnum ─────────────────────── v0.5.0; Installed InvertedIndices ───────────── v1.3.0; Installed Reexport ──────────────────── v1.2.2; Installed JuliaNVTXCallbacks_jll ────── v0.2.1+0; Installed BFloat16s ─────────────────── v0.5.0; Installed MacroTools ────────────────── v0.5.13; Installed DataStructures ────────────── v0.18.20; Installed Colors ────────────────────── v0.12.11; Installed KernelAbstractions ────────── v0.9.22; Installed RandomNumbers ─────────────── v1.5.3; Installed Missings ──────────────────── v1.2.0; Installed Compat ────────────────────── v4.15.0; Installed StringManipulation ────────── v0.3.4; Installed SortingAlgorithms ─────────── v1.2.1; Installed UnsafeAtomics ─────────────── v0.2.1; Installed Atomix ────────────────────── v0.1.0; Installed LLVM ──────────────────────── v8.0.0; Installed CUDA ──────────────────────── v5.4.3; Updating `/glade/derecho/scratch/knudsenl/BottomBoundaryLayer/Project.toml`; [052768ef] + CUDA v5.4,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2246012900:2175,Unsafe,UnsafeAtomicsLLVM,2175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2246012900,1,['Unsafe'],['UnsafeAtomicsLLVM']
Safety,── v1.4.5; Installed CUDA_Driver_jll ───────────── v0.9.1+1; Installed DataAPI ───────────────────── v1.16.0; Installed PooledArrays ──────────────── v1.4.3; Installed Tables ────────────────────── v1.12.0; Installed FixedPointNumbers ─────────── v0.8.5; Installed GPUCompiler ───────────────── v0.26.7; Installed LLVMLoopInfo ──────────────── v1.0.0; Installed IteratorInterfaceExtensions ─ v1.0.0; Installed StaticArraysCore ──────────── v1.4.3; Installed JLLWrappers ───────────────── v1.5.0; Installed InlineStrings ─────────────── v1.4.2; Installed StaticArrays ──────────────── v1.9.7; Installed TimerOutputs ──────────────── v0.5.24; Installed AbstractFFTs ──────────────── v1.5.0; Installed PrecompileTools ───────────── v1.2.1; Installed DataValueInterfaces ───────── v1.0.0; Installed OrderedCollections ────────── v1.6.3; Installed NVTX_jll ──────────────────── v3.1.0+2; Installed CUDA_Runtime_Discovery ────── v0.3.4; Installed LLVMExtra_jll ─────────────── v0.0.30+0; Installed UnsafeAtomicsLLVM ─────────── v0.1.5; Installed LaTeXStrings ──────────────── v1.3.1; Installed NVTX ──────────────────────── v0.3.4; Installed CEnum ─────────────────────── v0.5.0; Installed Random123 ─────────────────── v1.7.0; Installed JuliaNVTXCallbacks_jll ────── v0.2.1+0; Installed InvertedIndices ───────────── v1.3.0; Installed BFloat16s ─────────────────── v0.5.0; Installed Reexport ──────────────────── v1.2.2; Installed CUDA_Runtime_jll ──────────── v0.14.1+0; Installed GPUArrays ─────────────────── v10.2.3; Installed RandomNumbers ─────────────── v1.5.3; Installed DataFrames ────────────────── v1.6.1; Installed DataStructures ────────────── v0.18.20; Installed Compat ────────────────────── v4.15.0; Installed Requires ──────────────────── v1.3.0; Installed ExprTools ─────────────────── v0.1.10; Installed MacroTools ────────────────── v0.5.13; Installed Colors ────────────────────── v0.12.11; Installed KernelAbstractions ────────── v0.9.22; Installed CUDA ──────────────────────── v5.4.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:1950,Unsafe,UnsafeAtomicsLLVM,1950,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,1,['Unsafe'],['UnsafeAtomicsLLVM']
Security," AMDGPU.Compiler.HIPCompilerParams}})(); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:139; [5] lock(f::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}, l::ReentrantLock); @ Base ./lock.jl:229; [6] macro expansion; @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:86 [inlined]; [11] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:129; [12] codegen; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:110 [inlined]; [13] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:106; [14] compile; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:98 [inlined]; [15] #40; @ ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:140 [inlined]; [16] JuliaContext(f::AMDGPU.Compiler.var""#40#41""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:47; [17] hipcompile(job::GPUCompiler.CompilerJob); @ AMDGPU.Compiler ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:139; [18] actual_compilation(cache::Dict{Any, AMDGPU.H",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273:1871,validat,validate,1871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273,2,['validat'],['validate']
Security," BoundsError: attempt to access 0-element Vector{Ref{Union{Nothing, String}}} at index []; --;   | Stacktrace:;   | [1] throw_boundserror(A::Vector{Ref{Union{Nothing, String}}}, I::Tuple{});   | @ Base ./abstractarray.jl:651;   | [2] checkbounds;   | @ ./abstractarray.jl:616 [inlined];   | [3] _setindex!;   | @ ./abstractarray.jl:1289 [inlined];   | [4] setindex!(::Vector{Ref{Union{Nothing, String}}}, ::String);   | @ Base ./abstractarray.jl:1267;   | [5] find_local_cuda();   | @ CUDA.Deps ~/.julia-3060/packages/CUDA/mVgLI/deps/bindeps.jl:156;   | [6] macro expansion;   | @ ~/.julia-3060/packages/CUDA/mVgLI/deps/bindeps.jl:51 [inlined];   | [7] macro expansion;   | @ lock.jl:209 [inlined];   | [8] toolkit();   | @ CUDA.Deps ~/.julia-3060/packages/CUDA/mVgLI/deps/bindeps.jl:14;   | [9] toolkit_version();   | @ CUDA.Deps ~/.julia-3060/packages/CUDA/mVgLI/deps/bindeps.jl:209;   | [10] versioninfo(io::Base.TTY) (repeats 2 times);   | @ CUDA ~/.julia-3060/packages/CUDA/mVgLI/src/utilities.jl:35;   | [11] top-level scope;   | @ none:1; ```. On CUDA@3.3.0 this comes from a line that looks like. ```julia; __temp_libcusolver[] = ...; ```. I don't this this construct is valid in julia 1.6:. ```; julia> __temp_libcusolver = Ref{Union{Nothing,String}}[]; Ref{Union{Nothing, String}}[]. julia> __temp_libcusolver[] = nothing; ERROR: BoundsError: attempt to access 0-element Vector{Ref{Union{Nothing, String}}} at index []; Stacktrace:; [1] throw_boundserror(A::Vector{Ref{Union{Nothing, String}}}, I::Tuple{}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] _setindex!; @ ./abstractarray.jl:1289 [inlined]; [4] setindex!(::Vector{Ref{Union{Nothing, String}}}, ::Nothing); @ Base ./abstractarray.jl:1267; [5] top-level scope; @ REPL[4]:1; ```. But on CUDA#master the bug may have been fixed:. https://github.com/JuliaGPU/CUDA.jl/blob/3c251c1c210ff3fc75cef8dad688d170caadc275/deps/bindeps.jl#L180. So we might just need to update CUDA. Looking into it...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1799#issuecomment-872246612:1421,access,access,1421,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1799#issuecomment-872246612,1,['access'],['access']
Security," fact that the view uses `-2+3`, where 3 is the size of the halo. I've confirmed that changing the halo in the `RectilinearGrid`, changes the value of the (`z` index) to pass to access the `Field`. ```; julia> Field(eta, indices = (1:5,1:5,-2)); 5×5×1 Field{Center, Center, Face} on RectilinearGrid on CPU; ├── grid: 5×5×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (1:5, 1:5, -2:-2); └── data: 5×5×1 OffsetArray(view(::Array{Float64, 3}, 4:8, 4:8, 1:1), 1:5, 1:5, -2:-2) with eltype Float64 with indices 1:5×1:5×-2:-2; └── max=1.0, min=0.0, mean=0.04; ```. Meanwhile if I set the indices to `(1:5,1:5,2)` to access the supposedly `eta.indices`, I get:. ```; Field(eta, indices = (1:5,1:5,2)); ERROR: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 5:5]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::Int64); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] #Field#15; @ ~/github/Oceananigans.jl/src/Fields/field.jl:182 [inlined]; [7] top-level scope; @ REPL[39]:1; Some type information was truncated. Use `show(err)` to see complete types.; ``` . > @josuemtzmo can you show the whole sta",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:2598,access,access,2598,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658,1,['access'],['access']
Security," factor of `sqrt(2)` snuck into our constant. As for _clarification_, I don't have much to offer. Perhaps the constant was taken from some reference that used a different formulation than either us or Pressel et al. 2015. Nobody has submitted a validation test for this closure so I don't think we know how it performs. As a historical note, the paper cited by both Pressel et al (2015) and us is Lilly (1962), which does indeed use the same formulation:. ![image](https://user-images.githubusercontent.com/15271942/127507507-c7d11dfc-733a-4472-8216-dca4e5844b3f.png). where. ![image](https://user-images.githubusercontent.com/15271942/127507737-94aa05d4-6fa5-4d38-9a9d-b1bbcc8a1e79.png). @tomchor I can't tell if the formula you've pasted is actually different from ours (or what the definition of `|S|` is). Where does it come from?. It'd be fine to change the constant because there's no validation test. So the best we can do is theorize, and theorization on this issue suggests changing the default to `C=0.17`. If one wanted to set up a validation test, it could be nice to reproduce [Compte-Bellot and Corrsin (1964)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/simple-eulerian-time-correlation-of-fulland-narrowband-velocity-signals-in-gridgenerated-isotropic-turbulence/A3D7B0DD621DE46CB6CC543F65A66F93) (this wasn't possible when the closures were written because we didn't support triply periodic domains, but is possible now). This could also be used to validate Anisotropic Minimum Dissipation. Here's a figure with such a comparison from [Rozema et al 2015](https://aip.scitation.org/doi/pdf/10.1063/1.4928700):. ![image](https://user-images.githubusercontent.com/15271942/127508527-e5f7d150-56c4-4949-ad8e-90d67fdbee64.png). I believe for shear flows it has also been found that the constant needs to be as small as `C=0.1` or smaller? It'd be nice to mention and cite these in the docstring as well, if we can find those references. Hope that helps!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927:2867,validat,validation,2867,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927,4,['validat'],"['validate', 'validation']"
Security," runtime_module(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/interface.jl:173; [3] build_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:101; [4] (::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}})(); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:139; [5] lock(f::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}, l::ReentrantLock); @ Base ./lock.jl:229; [6] macro expansion; @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:86 [inlined]; [11] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:129; [12] codegen; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:110 [inlined]; [13] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:106; [14] compile; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:98 [inlined]; [15] #40; @ ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:140 [inlined]; [16] JuliaContext(f::AMDGPU.Compiler.var""#40#41""{GPUCompiler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273:1570,validat,validate,1570,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273,2,['validat'],['validate']
Security," there is something strange, since I also expected what you said `(4:8, 4:8, 1:1)`.; ; > This is maybe where the incorrect assumption is. If we need `(4:8, 4:8, 1:1)`, then we are looking for the indices of the underlying _view_ --- but not the indices of the Field. Because, the indices of `eta` are definitely `(4:8, 4:8, 4:5)`. That's the whole point of the windowed fields abstraction is to be able to properly locate a field in the 3D index space. `eta` is the free surface, so it's indices are at the top of the domain. That's likely the case, since it seems that we are accessing the indexes of the __view__. For example, doing `eta.indices` I get `(Colon(), Colon(), 5:5)`. However, the only way I manage to make work `Field(eta, indices = indices)` is using `indices = (4:8,4:8,-2)`. I think the reason it only works by pass a `-2` (`z` index) results from the fact that the view uses `-2+3`, where 3 is the size of the halo. I've confirmed that changing the halo in the `RectilinearGrid`, changes the value of the (`z` index) to pass to access the `Field`. ```; julia> Field(eta, indices = (1:5,1:5,-2)); 5×5×1 Field{Center, Center, Face} on RectilinearGrid on CPU; ├── grid: 5×5×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (1:5, 1:5, -2:-2); └── data: 5×5×1 OffsetArray(view(::Array{Float64, 3}, 4:8, 4:8, 1:1), 1:5, 1:5, -2:-2) with eltype Float64 with indices 1:5×1:5×-2:-2; └── max=1.0, min=0.0, mean=0.04; ```. Meanwhile if I set the indices to `(1:5,1:5,2)` to access the supposedly `eta.indices`, I get:. ```; Field(eta, indices = (1:5,1:5,2)); ERROR: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 5:5]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base .",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:1834,access,access,1834,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658,1,['access'],['access']
Security, those two classical methods?. [Paper1](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500300X00145/1-s2.0-S1463500302000604/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEDQaCXVzLWVhc3QtMSJHMEUCIQCPbl7iqBAsyZ8sRzkx1Ceu9AQF170J9roBR55QCqWu6QIgK1YF%2FMKz5kEEN%2BLSAk3uM7vp0bn20LDC1tDAUsMe7o0qvQMIvP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARADGgwwNTkwMDM1NDY4NjUiDBDmAWV%2FECe9JTdEPSqRA1h5EvlG9Mou%2F5LQtQ0qTo%2FotTV4Mmai4N7yubrFwotN1oRsCBH1DZYOsmuP%2FAULR6gQ8CmbG4TzyH3e0%2BlVyMQkrFvRWGyE9GDITVa%2FFzxZqmqgiVJvtFdsn0j8XK40BBhk3FlIfr%2FDW5oJjMrU0maDIFvF7fRZiBQupzw7svkvuouMdvyV%2Fj0Z%2BUlp0TRBPY9%2FOE8BfqKD3kVkxTXQFQSrMhixOFlUm3uEEHqKCgIG6XB%2FJJYjcL5%2Fu4wT391kDRgJfhIG%2BUpPibFTPs5XdD6rx7NCxdbO33aqPGJLnhpdsgpQ7J0dMzh%2B0iM0JHyfaae34JX7O%2F6raZWlUFcDpKy6AqGGcJM4hscgDTR%2BdkWGFd9lPUVfluYnaSxZVeLsZ9zDPf%2FQzqVH5PWsdW4aoIhfEM0nf6lw3dm85x8iqPx5vddC2BXvu0oNc1nsGQEWYeEP4XCWVGEBdjyaXJGJ2v4YOpbKjCQfB92tIAHIIAVidzZV%2FYq4a6KghC5deRwUhOn%2BBM4aAgz73gLggs7fGC%2BFMK7w7oQGOusBckSxfT%2Bl68Te6I8GKmj1FFQnX6W1kR1PmETsZjRti47ImhxN8A1Vm3f%2BDT9bl1FSb9B%2FQe0jCAjAtHKJgoaSBVB4Y%2BvzcdjxOkgQjwibNbSbHXhyPCkFAM03hQIneH0DdLRRwIRsBpeJbiXRNqNKpQ0fBOZmXFKG%2BxOqnt9B6qAlxteNnbwa920K8rasugPsuPCIjXXxJQdIgw%2BqM9MK%2FURkc13nU2HizMkm6v4lmAcMifIO1mpx0gDDrMy1cxwaACh%2FJwSd7S3utRdNLQq%2Fa%2B9X8DgBQUR6k6ufGqN2nwyNXPNbX31RXQk78Q%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20210512T124636Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTY5M2JQLUK%2F20210512%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=313b4ff70d811d309b5a8892417798d52cf3e72b5e40f11c3892298d6d57c9fa&hash=d9162dcc50830a9e18fb569db6253e564f0ae5a415cf4ec09165130e634648ef&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500302000604&tid=spdf-7940fbcd-96cc-4ec2-bbf0-16d073dd8922&sid=93981d868accf8424519d9831bbc1028c2b5gxrqa&type=client); [Paper2](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500310X00038/1-s2.0-S1463500309002248/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEDQaCXVzLWV,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602:528,Secur,Security-Token,528,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602,2,"['Secur', 'hash']","['Security-Token', 'hash']"
Security," to other bugs). The `indices` keyword in the output writers is a useful convenience but doesn't generalize well to being able to slice both 3D and reduced or sliced fields. Here's what we have:. * All `Field`s have `indices`. We can define fields that are essentialy _views_ into other fields, but ""sliced"" at particular indices. We can also define abstract operations that slice a portion of the domain.; * We have output writers that can compute and output sliced fields. ; * We have an `indices` kwarg for output writers that _automagically_ will _slice every output_ along the provided indices. This is convenient, but fails to cover the case that we want to slice all 3D fields, but leave fields that are _already sliced_ untouched. A few solutions:. * Throw a `BoundsError` when we attempt to ""re-slice"" a field in a way that's invalid. For example, we cannot slice a field with `k=Nz+1` at the index `k=Nz`. This is how Base julia works:. ```julia; julia> a = rand(2, 3); 2×3 Matrix{Float64}:; 0.493349 0.161279 0.244427; 0.288415 0.0111998 0.543645. julia> b = view(a, :, 4:4); ERROR: BoundsError: attempt to access 2×3 Matrix{Float64} at index [1:2, 4:4]; Stacktrace:; [1] throw_boundserror(A::Matrix{Float64}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view(::Matrix{Float64}, ::Function, ::UnitRange{Int64}); @ Base ./subarray.jl:177; [4] top-level scope; @ REPL[36]:1; ```. * Add new features that help us build output in a sensible way. One idea is a macro that looks something like. ```julia; us, vs, ws, Ts = @indices (:, :, Nz) u v w T; ```. This would be equivalent to writing something like. ```julia; us = Field(u, indices=(:, :, Nz)); vs = Field(v, indices=(:, :, Nz)); ws = Field(w, indices=(:, :, Nz)); Ts = Field(T, indices=(:, :, Nz)); ```. Then, if users want to output surface fields _and_ the free surface, they should use this method rather than the `indices` kwarg.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520:1610,access,access,1610,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520,2,['access'],['access']
Security," underlying_grid = RectilinearGrid(CPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); 4×1×4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Flat y ; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> slope(x) = x; slope (generic function with 1 method). julia> grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)); 4×1×4 ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo:; ├── immersed_boundary: PartialCellBottom(mean(z)=0.5, min(z)=0.125, max(z)=0.875, ϵ=0.2); ├── underlying_grid: 4×1×4 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Flat y ; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> model = HydrostaticFreeSurfaceModel(; grid); ERROR: BoundsError: attempt to access 10×1×1 OffsetArray(::Array{Float64, 3}, -2:7, 1:1, 1:1) with eltype Float64 with indices -2:7×1:1×1:1 at index [1, 0, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:422 [inlined]; [4] getindex; @ ~/atdepth/Oceananigans.jl/src/Fields/field.jl:541 [inlined]; [5] Δzᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_bottom.jl:115 [inlined]; [6] Δzᶜᶠᶜ; @ ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_bottom.jl:141 [inlined]; [7] getindex; @ ~/atdepth/Oceananigans.jl/src/AbstractOperations/grid_metrics.jl:138 [inlined]; [8] getindex; @ ~/atdepth/Oceananigans.jl/src/AbstractOperations/conditional_operations.jl:101 [inlined]; [9] _getindex; @ ./abstractarray.jl:1341 [inlined]; [10] getindex; @ ./abstractarray.jl:1291 [inlined]; [11] macro expansion; @ ./reducedim.j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318340266:1212,access,access,1212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318340266,1,['access'],['access']
Security,"# Progress update. I decided to take a stab at the simplest case: triply-periodic on the CPU. Surprisingly I was able to get a distributed `IncompressibleModel` running just using multiple dispatch without having to modify any existing code, although a cleaner design might require a bit of refactoring. PR is still a work-in-progress so it's a bit messy, the purpose was to demonstrate a proof of concept. MPI.jl and PencilFFTs.jl are new dependencies but I haven't updated the Project.toml yet. So far this PR adds some new infrastructure:; 1. Distributed/multi-architectures (e.g. `MultiCPU`) that know about rank connectivity.; 2. Halo communication between ranks is done via multiple dispatch on a new `HaloCommunicationBC` type.; 3. A `DistributedFFTBasedPoissonSolver` for solving Poisson equations across ranks.; 4. A `DistributedModel` that creates local grids for each ranks, injects halo communication BCs, and passes the distributed pressure solver to a local `IncompressibleModel`. I also added some simple tests for multi architecture rank connectivity, local grid construction, injection of halo communication BCs, and halo communication (testing x, y, and z slab decompositions). Also added tests for the distributed Poisson solver ensuring the solution is divergence-free. Next step for testing would probably be to test that the code handles `Bounded` topologies correctly then add tests that reproduce the regression tests but on multiple ranks and ensure the output matches the regression output. ## Some notes. ### Domain decomposition. Domain decomposition is supported and tested in x, y, and z. But for `IncompressibleModel` z-decomposition won't work right now because vertical integrals are done inside GPU kernels (so we probably don't want to decompose in z). And PencilFFTs.jl supports decompositions in dimensions 2 and 3 (since dimension 1 FFTs are the fastest). As a result, right now Oceananigans.jl only supports slab decompositions in y although we should figure out",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-775301066:886,inject,injects,886,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-775301066,1,['inject'],['injects']
Security,"(rotl90(view(getregion(u, region).data, :, :, 1))). @info ""v values""; display(rotl90(view(getregion(v, region).data, :, :, 1))). # Plotting longitude values using λnodes. Hx, Hy, Hz = grid.Hx, grid.Hy, grid.Hz. for region in 1:6; ; for i in 1-Hx:Nx+Hx, j in 1-Hy:Ny+Hy; getregion(c, region).data[i, j, 1] = λnodes(getregion(grid, region), Center(), Center(), Center(); ; with_halos=true)[i, j, 1]; getregion(u, region).data[i, j, 1] = λnodes(getregion(grid, region), Face(), Center(), Center(); ; with_halos=true)[i, j, 1]; getregion(v, region).data[i, j, 1] = λnodes(getregion(grid, region), Center(), Face(), Center(); ; with_halos=true)[i, j, 1]; end. end. @info ""Plotting longitude values using λnodes"". @info ""c values""; display(rotl90(view(getregion(c, region).data, :, :, 1))). @info ""u values""; display(rotl90(view(getregion(u, region).data, :, :, 1))). @info ""v values""; display(rotl90(view(getregion(v, region).data, :, :, 1))); ```. Here's the output:. ```Julia; julia> include(""validation/multi_region/multi_region_longitude.jl""); [ Info: Plotting longitude values using the set function; [ Info: c values; 7×7 OffsetArray(::Matrix{Float64}, 0:6, 0:6) with eltype Float64 with indices 0:6×0:6:; 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 -38.0887 -20.9234 -9.30769e-16 20.9234 38.0887 0.0; 0.0 -36.589 -18.9205 -2.33529e-15 18.9205 36.589 0.0; 0.0 -36.3047 -18.488 -3.50835e-15 18.488 36.3047 0.0; 0.0 -36.589 -18.9205 -4.68142e-15 18.9205 36.589 0.0; 0.0 -38.0887 -20.9234 -6.08594e-15 20.9234 38.0887 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0; [ Info: u values; 7×7 OffsetArray(::Matrix{Float64}, 0:6, 0:6) with eltype Float64 with indices 0:6×0:6:; 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 -45.0 -30.1124 -10.7432 10.7432 30.1124 0.0; 0.0 -45.0 -27.9373 -9.56157 9.56157 27.9373 0.0; 0.0 -45.0 -27.4907 -9.3003 9.3003 27.4907 0.0; 0.0 -45.0 -27.9373 -9.56157 9.56157 27.9373 0.0; 0.0 -45.0 -30.1124 -10.7432 10.7432 30.1124 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0; [ Info: v values; 7×7 OffsetArray(::Matrix{Float64}, 0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1689366850:1982,validat,validation,1982,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1689366850,1,['validat'],['validation']
Security,"/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:86 [inlined]; [11] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:129; [12] codegen; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:110 [inlined]; [13] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:106; [14] compile; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:98 [inlined]; [15] #40; @ ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:140 [inlined]; [16] JuliaContext(f::AMDGPU.Compiler.var""#40#41""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:47; [17] hipcompile(job::GPUCompiler.CompilerJob); @ AMDGPU.Compiler ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:139; [18] actual_compilation(cache::Dict{Any, AMDGPU.HIP.HIPFunction}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}, compiler::typeof(AMDGPU.Compiler.hipcompile), linker::typeof(AMDGPU.Compiler.hiplink)); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/execution.jl:125; [19] cached_co",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273:2213,validat,validate,2213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273,2,['validat'],['validate']
Security,"00) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 843.428 ms; │ ├── max(u): (2.48e-08, 1.37e-04, 3.09e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 6.17e-06 m; ```. When `IsopycnalSkewSymmetricDiffusivity` is included, however, we find. ```julia; julia> include(""near_global_one_degree.jl""); underlying_grid = LatitudeLongitudeGrid(arch; size = (Nx, Ny, Nz), halo = (4, 4, 4), latitude, z, longitude = (-180, 180), precompute_metrics = true) = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 259.679 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (319.597 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.116 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 1.121 seconds; │ ├── max(u): (1.94e-10, 4.57e-05, 1.03e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.03e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 998.405 ms; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (-16387479425.34, 18491107419.68) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:2584,validat,validated,2584,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518,1,['validat'],['validated']
Security,"1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. Not urgent. > 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. We want to write `fill_halo_regions!(::HorizontalVectorField, ...)`. > 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. No rush... > 11. Figure out if the tests in `test_cubed_sphere_halo_exchange.jl` can be abstracted and run for all six faces. It's tedious to have to type them out but could be clearer and easier to debug in its current form... I don't think less abstraction is more clear. > 12. Fix tests!. Tests must pass or we can't develop. > 13. I think cubed sphere performance can be improved, especially for halo filling. We might need some benchmarks and profiling to figure out where cubed sphere simulations are allocating too much",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333:2063,validat,validation,2063,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333,4,['validat'],['validation']
Security,"1.32e-16, 5.40e-02, 6.44e-04) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 5.93e-01 m; ┌ Info: Iteration: 2, time: 40 minutes, wall time: 945.169 ms; │ ├── max(u): (1.39e-02, 1.06e-01, 1.05e-03) m s⁻¹; │ ├── extrema(T): (0.05, 30.00) ᵒC; └ └── max|η|: 1.33e+00 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 1 hour, wall time: 945.031 ms; │ ├── max(u): (3.55e-02, 1.52e-01, 1.37e-03) m s⁻¹; │ ├── extrema(T): (0.15, 30.00) ᵒC; └ └── max|η|: 2.08e+00 m; ```. But when they're put back, it still blows up (even with coefficients 1e-9):. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = ImmersedBoundaryGrid on:; architecture: CPU(); grid: 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; with immersed: GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 256.442 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (317.156 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.252 seconds).; ┌ Info: Iteration: 1, time: 20 minutes, wall time: 1.258 seconds; │ ├── max(u): (7.36e-02, 5.18e-02, 7.93e-04) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 3.73e-01 m; ┌ Info: Iteration: 2, time: 40 minutes, wall time: 1.003 seconds; │ ├── max(u): (2.83e-01, 1.13e-01, 1.65e-03) m s⁻¹; │ ├── extrema(T): (-6.76, 50.82) ᵒC; └ └── max|η|: 8.05e-01 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iter",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807:2205,validat,validated,2205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807,1,['validat'],['validated']
Security,841d&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500309002248&tid=spdf-c9770d3b-56ff-4583-8351-378cc6cbd0d1&sid=93981d868accf8424519d9831bbc1028c2b5gxrqa&type=client); [Paper3](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500311X00082/1-s2.0-S1463500311000801/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEDQaCXVzLWVhc3QtMSJGMEQCIEQMBR002B0LthnumUbBVDoR4U3VR1%2BG2xH%2FbIDI1AFoAiAuoSQfiKqWKf3m%2FVE%2FTNJYYLsXkWY1mN6C20bNTWXrbyq9Awi9%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F8BEAMaDDA1OTAwMzU0Njg2NSIMv%2BDAm8ISlbHKF3xLKpED2bpaqVDlCq%2FGp3Dc9u5Zu5HLtx2oVIXcHmg%2FTY8WZmZ9N7cEwhcNyX8qTIQqVETB6a7wofc0JLX%2BnIscRSocQijV63Kn3N%2BIoojUYHSNuwuOBcx2J5subwAr8fzzOXkoFYw9nrd6y%2Bjx8t8ZkxhpAFa4WTZf0z8CWCNi059xlb20ESLxmGI2lGxglJK%2BDwLQub5TqE0fNqGjBUg6d2A7Uw9SgLQyhQGkB0DhCAGSbcskYQD2nlQcrJGiDFzXDDU6Z8u%2FeZiBvZFKr59%2F2l%2BZWAcaToBhjSNPbwZSKPJu0Il7192olWKVgcN%2FPV%2Ff69n9WRzSxUjzcTPeQeWHBcL6CqQSs74smvUq4Pps9wGacAXCYIITEJvNgLWJ3a8IPMogAr9T32a0v432lo4jKqxWoLaFN9utt9yTc9z05QEh6mh%2FUWs%2BWHNvxajljyqICd5vRgW9kfQ4rOGocjXbDJGWbvKsmEWC2cO42BTOOkAoTuZZHG61V2GBXmuuYprD%2FEENCU4yv0omCCorRGVj9fOwnLAwuvbuhAY67AFEMpZuxL1UHoFniFEKR%2B3JadvLhS03QquHGbY4m2mwchN96GFOgyaaISUwmAv8dSlX0eAKHqbAli90Bt%2BI761m0NTUUKF%2BxcPqtcNcaZr7nOZgUr8OjNP55mXnURmklGmB1NgYkgrYwe37IsYt1H5t4ii1ZmYHStJUGpL5nzv3OwLdsQsVit5xTsBGdGraNgsk%2F6fxNyUX8ZAO96BOnMEr4KfFLtXxOd3Cqd5rwf9%2FsUSRYUgEbMET2MFZE7LtoPrv9Y4YbnZZPuROvaePIFOVQL1lzBFEqwOL%2BAlsbBIO%2FTUEl4nkFuLft3wUJg%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20210512T124741Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYWCZJM4U7%2F20210512%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=78f17eb8a6139a663a8bce25fad0a2e3ce9da7be82563c990973904a96e0e4ea&hash=9376e9734a2dea82bcc8fb808ef803104cf448fd971c2d8d0c5c6776c8c920c1&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500311000801&tid=spdf-f5035413-aea3-427f-a9ac-13d0a85a5ca6&sid=93981d868accf8424519d9831bbc1028c2b5gxrqa&type=client),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602:4126,Secur,Security-Token,4126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602,2,"['Secur', 'hash']","['Security-Token', 'hash']"
Security,8424519d9831bbc1028c2b5gxrqa&type=client); [Paper2](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500310X00038/1-s2.0-S1463500309002248/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEDQaCXVzLWVhc3QtMSJHMEUCIFOWdyS3a22deEBXjBCSg9JkqHU7kKI82ao5VmOhVBCJAiEAkMrWigQVK4lU%2BXCC27bRmvm32M0zTk4bVzllPXcV16cqvQMIvP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARADGgwwNTkwMDM1NDY4NjUiDFW%2FMJYjQWUkPx9JGCqRA%2B2gfPEHupvIbgmLh8Ea3HcYZNAkacD7N0Bj1%2By4O8SRtGO1gVirrSZbMJOEuywRDXWbUVHyy7mqKd5c4noCV127vH97IoV6GNMzLS04SZzrHaxNf87iMHuvQSac1ryMPdyiRVXjGVKD%2FK9WUOD9pCuwkbJ1Xq9fIFUBDpIpf6YsziUbag80uMnrgLDdI4bi0Od%2BycFCl8l135%2BiBSJ1nXr2i1d0KoM%2FwxqRhZe3eJnFkqIjBKZMTnaYXcNkBQ4OnVMdp6iNwqDluofhE86ze0DxkmKmwDIlOY6BmAZldUxJNOtojkAkoK%2BggRqDF9RpNh7eUBfmpajcmW%2Fs93jRxiBwxtkolmdDmsSYNOZyJxHn1l9VX0PpWFmhvYuzxVIxKWwhDu2jq1JUO9HWjCSOb5cu4iXr%2FY6UtLVk0zBA%2FUhBFJvYBpTFKCB%2FTZ2nm1VQ05HIq0CdMWngU2%2BPGtb8boOqEZYSJuxcW9liUpegyLYEDrFuQ5zD1PokanBmvQb4nbl3JIfRff6RQTs7I39ruWFvMO3w7oQGOusBq4rh3NlN%2BL771IAdhwa5OXPw6Dtu1rnK8mq15ILN7oUZoGlSoGGHmC9iCauDZZ0S7JRYJvBBlp3zMbH5gPzKtgbHOcfreLqawi%2FXQsNSwLrv8kMK7xtgAtq9KwZNCba%2BezOii00IhPulhEgoRpf32NORW2hf9xvSrh6O7J%2BpFl13%2BgZGv2C9YWQFtiowI1giCVrkqvdAzLIQTemllWlG4BocEdlXsIPbMTqVRy%2BPJeOoDFCEJfa3GEulzYOD7wBM8Mzcs8oPGrs32RGTKanWlrNurlGoWt9LD1yRpHRBW0W3KGW77dYPRa9WMw%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20210512T124707Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYU4SXGKKT%2F20210512%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=61ac35b7b8d6de69c863c18a7ac278cfcfcba8c8e333851a5dc0b0fb1a0fec5d&hash=40f925060e5aa979f6c2f65ee083626803b350750f9d24f55b22337096ac841d&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500309002248&tid=spdf-c9770d3b-56ff-4583-8351-378cc6cbd0d1&sid=93981d868accf8424519d9831bbc1028c2b5gxrqa&type=client); [Paper3](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500311X00082/1-s2.0-S1463500311000801/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEDQaCXVzLWVhc3QtMSJGMEQ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602:2339,Secur,Security-Token,2339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839746602,2,"['Secur', 'hash']","['Security-Token', 'hash']"
Security,"::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fullscreen::Bool, monitor::Nothing, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:344; [4] GLMakie.Screen(; resolution::Tuple{Int64, Int64}, visible::Bool, title::String, kw_args::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:373; [5] Screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:345 [inlined]; [6] global_gl_screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:291 [inlined]; [7] global_gl_screen(resolution::Tuple{Int64, Int64}, visibility::Bool, tries::Int64); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:436; [8] global_gl_screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:435 [inlined]; [9] backend_display; @ ~/.julia/packages/GLMakie/XG7Hm/src/display.jl:2 [inlined]; [10] VideoStream(scene::Scene; framerate::Int64); @ Makie ~/.julia/packages/Makie/umL6V/src/display.jl:329; [11] #VideoStream#909; @ ~/.julia/packages/Makie/umL6V/src/display.jl:342 [inlined]; [12] Record(func::var""#5#10""{Observable{Int64}, Vector{Int64}}, scene::Figure, iter::Vector{Int64}; framerate::Int64); @ Makie ~/.julia/packages/Makie/umL6V/src/display.jl:589; [13] #record#915; @ ~/.julia/packages/Makie/umL6V/src/display.jl:584 [inlined]; [14] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:72; [15] top-level scope; @ ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:94; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:94; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:3346,validat,validation,3346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985,3,['validat'],['validation']
Security,"= (256, 64),; x = (-5kilometers, 15kilometers),; z = (-512, 0),; topology = (Periodic, Flat, Bounded)). model = NonhydrostaticModel(; grid, stokes_drift,; tracers = :b,; buoyancy = BuoyancyTracer(),; timestepper = :RungeKutta3). # Set Lagrangian-mean flow equal to uˢ,; uᵢ(x, z) = uˢ(x, z, 0). # And put in a stable stratification,; N² = 0; bᵢ(x, z) = N² * z; set!(model, u=uᵢ, b=bᵢ). Δx = xspacings(grid, Center()); Δt = 0.2 * Δx / cᵍ; simulation = Simulation(model; Δt, stop_iteration = 600). progress(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress, IterationInterval(10)). filename = ""surface_wave_induced_flow.jld2""; outputs = model.velocities; simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs; filename,; schedule = IterationInterval(10),; overwrite_existing = true). run!(simulation). ut = FieldTimeSeries(filename, ""u""); wt = FieldTimeSeries(filename, ""w""). times = ut.times; Nt = length(times). n = Observable(1). un = @lift interior(ut[$n], :, 1, :); wn = @lift interior(wt[$n], :, 1, :). xu, yu, zu = nodes(ut); xw, yw, zw = nodes(wt). fig = Figure(resolution=(800, 300)). axu = Axis(fig[1, 1], xlabel=""x (m)"", ylabel=""z (m)""); axw = Axis(fig[1, 2], xlabel=""x (m)"", ylabel=""z (m)""). heatmap!(axu, xu, zu, un); heatmap!(axw, xw, zw, wn). record(fig, ""surface_wave_induced_flow.mp4"", 1:Nt, framerate=12) do nn; n[] = nn; end; ```. The result is. https://github.com/CliMA/Oceananigans.jl/assets/15271942/643ca8b4-0943-461d-8016-08bbba24faad. where the left panel is `u` and the right panel is `w`. @BrodiePearson I don't think we should add a new example for this feature (examples are expensive, because they have to run every time we run CI / build the documentation). However, another avenue to keep some code around is to add a ""validation"" case. If you're up for that, I'll move your code there, along with the above example. Let me know and then we can possibly merge this great addition.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1832988085:3069,validat,validation,3069,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1832988085,1,['validat'],['validation']
Security,"=== true`. For example. ```; julia> f(a, first) = first ? a[1] : a[2]; f (generic function with 1 method). julia> a = rand(1); 1-element Vector{Float64}:; 0.6018054291910822. julia> f(a, true); 0.6018054291910822. julia> f(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] f(a::Vector{Float64}, first::Bool); @ Main ./REPL[7]:1; [3] top-level scope; @ REPL[10]:1; ```. The first call to `f(a, true)` executes without problems, because the second _branch_ isn't executed at all. On the other hand. ```julia; julia> g(a, first) = ifelse(first, a[1], a[2]); g (generic function with 1 method). julia> g(a, true); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If we use short-circuiting logic, then I guess many optimizations are not possible, because execution on one branch or another must be completely excluded. Some of this is discussed here: https://discourse.julialang.org/t/multiplying-by-booleans-faster-than-if-else/64117. > What about @inline?. This a little hazier. The compiler decides based on",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:1331,access,access,1331,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583,1,['access'],['access']
Security,"> ""Flattening"" the model setup section by bringing its sections out into the main list. I agree with absolutely everything except with this. Flattening out the sections makes it hard to situate yourself and find things in the docs. This isn't a problem if you're assuming that users will just read everything from beginning to end, but I think that happens very very rarely, and the overwhelming majority of accesses to the docs are just for consultation. I remember at some point reading about this and how some (non-rigorous) surveys/studies pointed out a preference for a few nested menus in websites, as opposed to a long flat list of sections. But I can't find it right now and until I can find it again you're free to take this as a personal preference :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879252108:408,access,accesses,408,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879252108,1,['access'],['accesses']
Security,"> #1900 brings the finite-volume discussion further up in the Docs/Numerical Implementations. I think that's a great idea. Also, it occurs to me that it would be nice to have another validation code for `ShallowWaterModel`. The Bickley jet example was good and we confirmed the growth rates, but perhaps a propagatoing equatorial Rossby wave would be fun. This is an exact solution to the equations and we can ensure that the phase speed matches that with theory. Maybe this would help us to ensure that all the integrals are done correctly. I don't think this would be interesting enough to become an example but it might interest some people.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886679071:183,validat,validation,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886679071,1,['validat'],['validation']
Security,"> (not sure where best to put this/if you'd want it in the examples folder). The right place would be `validation/`, as we only use `examples/` for features that are widely-used and well-tested (examples are expensive, because they have to run during CI).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239609992:103,validat,validation,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239609992,1,['validat'],['validation']
Security,"> * Implementation of zero laplacians on the immersed boundaries to allow a biharmonic closure with immersed boundaries. Do we also need to zero the Laplacian on _non-immersed_ (ie ordinary) boundaries?. Relatedly, I don't think we need to `@unroll` when we fill halos for `FluxBoundaryCondition`:. https://github.com/CliMA/Oceananigans.jl/blob/adffd0cb67373da364a54d7f300d1f33817539bd/src/BoundaryConditions/fill_halo_regions_flux.jl#L33. The only point of filling points _beyond_ the first halo point is for `AnisotropicBiharmonicDiffusivity`. So if we aren't using it we can get rid of `@unroll` and just fill the first halo point, I think. I think we also need to throw an error if the _only_ closure if `ScalarBiharmonicDiffusivity` and the boundary condition is anything _but_ `FluxBoundaryCondition`. It's kind of complex because it's still ok to have biharmonic and non-flux, provided that there's _another_ closure (in a closure tuple) present. Maybe we can just open an issue about validating boundary conditions + closures and figure out an algorithm there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1039857134:992,validat,validating,992,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1039857134,1,['validat'],['validating']
Security,"> 1. purpose of `Field`: data structure, plus infrastructure for building expression trees; > 2. `Field` basics; > ; > * The staggered grid, `Field` locations; > * Field size + data, staggered nodes, staggered spacings; > 3. AbstractOperations and expression trees; > ; > * The concept of a lazy operator; > * Arithmetic and derivatives; > * Difference between a Field and Operation; > * KernelFunctionOperation; > * what else?; > 4. Averaging, intergrals, and reduced fields; > ; > What else?; > ; > @navidcy @simone-silvestri. Visualization always helps, so I recommend adding plots of various grid types (periodic, non-periodic, stretched, etc.) directly below the corresponding code snippets that generate them. Additionally, it would be nice to illustrate how to access the different components of `Field`s and the output of abstract operations with code snippets.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3672#issuecomment-2263532747:768,access,access,768,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3672#issuecomment-2263532747,1,['access'],['access']
Security,"> > > > @glwagner any idea why `gpu-simulations-tests` fail?; > > > ; > > > ; > > > Which grid points are specifically failing in the test?; > > ; > > ; > > How does one go about and answers this question? The log is not informative... Shall I run the tests myself online and then printout the two arrays?; > ; > Yeah, that's what you have to do to determine it... not urgent though... I tried to do that but the HPC at ANU when I use a queue with GPU access it does not have internet access. So it stops at `include(""data_dependencies.jl"")` line...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928225330:452,access,access,452,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928225330,2,['access'],['access']
Security,"> > > > Hmm, I think my parameters are silly because they aren't hydrostatic, I don't think. Thinking rather than typing is needed now.; > > > ; > > > ; > > > Callum would know. I can ask him about parameters, dt, etc that should work OK.; > > ; > > ; > > I believe to be hydrostatic we need a small aspect ratio and forcing far from N.; > ; > Well Callum actually ran the simulation with the parameters above on MITgcm in hydrostatic mode.; > ; > I put it there because it might give a hint for something going wrong if, eg, you meed 100 times less `Δt` to get a stable simulation with everything else the same. Ah I missed the `Δt` --- is that maybe limited by advection / CFL? It's certainly very far from 1 / 12.421 hours... For my above example I realized I was also using `ExplicitFreeSurface` which I think was likely providing the time step restriction... I think for this validation case I will target a linear regime in which the time step is limited by the highest-frequency internal waves.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841704503:881,validat,validation,881,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841704503,1,['validat'],['validation']
Security,"> > > @iuryt can we do it in a new PR? I can get it started to illustrate, and you can help me by refining the implementation and getting the tests to pass. What do you think?; > > ; > > ; > > As this new PR will change this current PR, I will work on the new PR first and then come back here.; > ; > @glwagner Should I work on this PR first and then when make the new implementation update the validation scripts again?. Up to you but it seems like you will save yourself some effort if you first update the user interface, and then update the validation scripts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1915262473:395,validat,validation,395,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1915262473,2,['validat'],['validation']
Security,"> > > This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?; > > ; > > ; > > This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`.; > ; > Got it! Agreed. Should we test that `hydrostatic_pressure_anomaly` is either `CenterField(grid)` or `nothing` and throw a helpful error otherwise?. Sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088747422:422,access,access,422,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088747422,2,['access'],['access']
Security,"> > > in my opinion no, it's fine to have an `MPI.Init()` if the script directly uses MPI variables. It is more explicit.; > > > The other option to not use MPI variables is to hardcode the number of processors; > > ; > > This advice seems to contradict the goal of having scripts that can be changed from non-distributed to distributed with a single line.; > > ; > > I don't think user scripts should have to write `using MPI`. The API should have all the features necessary to support ""one-click"" distributed simulations. When we see `using MPI`, it measn that the API is incomplete and we have work to do.; > ; > Just to clarify, this is already possible, just by doing; > ```julia; > arch = Distributed(); > rank = arch.local_rank; > ```; > The script, on the other hand, explicitly uses the MPI module before constructing the architecture, for which it makes sense to have `using MPI; MPI.Init()`.; > . @iuryt this works already if you don't want to hardcore/import the MPI module. I would leave the validation case like this though",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895862613:1005,validat,validation,1005,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895862613,1,['validat'],['validation']
Security,"> > @elise-palethorpe also perhaps change the validation script name as @glwagner suggest?; > ; > Do we need the file at all? Can I just include mg preconditioner in `doubly_bounded_poisson.jl`. Yes, do that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1236213216:46,validat,validation,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1236213216,1,['validat'],['validation']
Security,"> > @fluidnumerics-joe the CI doesn't work... something's wrong with the Manifest you pushed.; > > It would be easier if you somehow allow maintainers to push. There is an option ""Allow edits and access to secrets by maintainers"" when you open a PR. Perhaps you disabled that?; > > Personally if I don't see the CI working (at least starting) then I feel it's a bit futile to comment on code that might be outdate or deprecated.; > ; > I'll check settings. Have you noticed your main branch fails CI?. Main branch doesn’t fail. It starts. Just the GPU server that we run CI was down yesterday. . The CI on this branch doesn’t even start. Not even the CPU CI.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936971094:196,access,access,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936971094,1,['access'],['access']
Security,"> > @glwagner, do you think a bit more elaborate validation test is in order?; > > I'll approve at this point and let this to your judgment.; > ; > I am currently working on a more elaborate validation / example (I'd like to implement an overturning, eddying channel example that uses this closure in a 3D setting) so I think we are ok to merge this PR now as is. Let's work on the eddying channel together!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1738#issuecomment-863628504:49,validat,validation,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1738#issuecomment-863628504,2,['validat'],['validation']
Security,"> > @iuryt can we do it in a new PR? I can get it started to illustrate, and you can help me by refining the implementation and getting the tests to pass. What do you think?; > ; > As this new PR will change this current PR, I will work on the new PR first and then come back here. @glwagner ; Should I work on this PR first and then when make the new implementation update the validation scripts again?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1915090633:378,validat,validation,378,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1915090633,1,['validat'],['validation']
Security,> > @iuryt do you want to help set up a validation case for this feature?; > ; > Yep. I will be working on the NP model with a P sinking velocity this week. Any idea for an experiment that changes MLD with time? Maybe making it 1D for simplicity? But I would like to test for 3D to make sure I am programming it correctly. Maybe buoyancy=nothing and diffuse a tanh-like temp profile? But would be better to have a shallowing mld instead. I think a 2D example with turbulence + reactions + sinking would be neat. Probably best to keep it simple and avoid an MLD calculation. Now I'm thinking maybe just a sinking tracer with a source near the surface would be good.. 🤔,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081819313:40,validat,validation,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081819313,2,['validat'],['validation']
Security,"> > @matinraayai I made a bunch of suggestions!; > > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > > ```julia; > > using Oceananigans; > > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > > model = NonhydrostaticModel(; grid, advection=WENO5()); > > ϵ(x, y, z) = 2rand() - 1; > > set!(model, u=ϵ, v=ϵ); > > simulation = Simulation(model; Δt=0.01, stop_time=4); > > run!(simulation); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > should be enough?; > ; > @glwagner I'm okay with that. I can take a look at this once this PR is accepted to `amdgpu`. @glwagner and @matinraayai focusing on `validation/` , `rectilinear`, `non hydrostatic` would work. ; I can set up some CI against the cluster machines we have. I am not sure if we would want it to run for all PRs yet, so I could try https://stackoverflow.com/questions/62325286/run-github-actions-when-pull-requests-have-a-specific-label",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787:286,validat,validation,286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787,3,['validat'],['validation']
Security,"> > @siddharthabishnu I pushed a clean version of the grid comparison at https://github.com/CliMA/Oceananigans.jl/blob/sb-ncc/cs-grid-metrics/validation/multi_region/multi_region_cubed_sphere_grid.jl; > > if I run this on this branch I get:; > > ```julia; > > julia> include(""multi_region_cubed_sphere.jl""); > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 1: 1.8471271253206468e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 2: 1.8471270881725844e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 3: 3.2442725228121196e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 4: 1.8471271544306945e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 5: 1.847127087195588e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 6: 3.244272524791092e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 1: 1.8471271253206468e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 2: 1.8471270881725844e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 3: 3.2442725228121196e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 4: 1.8471271544306945e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 5: 1.847127087195588e-7; > > [ Info: λᶜᶜᵃ_difference_MITgcm panel 6: 3.244272524791092e-7; > > [ Info: λᶠᶠᵃ_difference_MITgcm panel 1: 1.732365234564951e-7; > > [ Info: λᶠᶠᵃ_difference_MITgcm panel 2: 1.7323652025336144e-7; > > [ Info: λᶠᶠᵃ_difference_MITgcm panel 3: 0.05625027340835691; > > [ Info: λᶠᶠᵃ_difference_MITgcm panel 4: 1.7323652655498735e-7; > > [ Info: λᶠᶠᵃ_difference_MITgcm panel 5: 1.7323652008460754e-7; > > [ Info: λᶠᶠᵃ_difference_MITgcm panel 6: 0.0562502734083572; > > [ Info: φᶜᶜᵃ_difference_MITgcm panel 1: 1.570048120703993e-7; > > [ Info: φᶜᶜᵃ_difference_MITgcm panel 2: 1.5700481280397916e-7; > > [ Info: φᶜᶜᵃ_difference_MITgcm panel 3: 1.3603837144327004e-7; > > [ Info: φᶜᶜᵃ_difference_MITgcm panel 4: 1.5700481343680627e-7; > > [ Info: φᶜᶜᵃ_difference_MITgcm panel 5: 1.570048127987056e-7; > > [ Info: φᶜᶜᵃ_difference_MITgcm panel 6: 1.360383713455704e-7; > > [ Info: φᶠᶠᵃ_difference_MITgcm panel 1: 1.478470279652168e-7; > > [ Info: φᶠᶠᵃ_difference_MITg",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2015620980:142,validat,validation,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2015620980,1,['validat'],['validation']
Security,"> > @siddharthabishnu, `CUDA.@allowscalar` introduced by [3cdd470](https://github.com/CliMA/Oceananigans.jl/pull/3488/commits/3cdd4705fedf3238d8858bb0f56e9b27b01ba34a) is detrimental for performance. Like it induces O(10-100x) slowdown I think....; > > Is this a temporary solution?; > > cc @glwagner, @simone-silvestri; > ; > I think it is. We can try to see if this works on one GPU. If it does we can keep the allowscalar for the moment otherwise we can remove them. In the end all this will have to live in a kernel. Note that this will still not work on multiple GPUs as you cannot explicitly access one region from another one on a different GPU without switching to the device that holds the data. @simone-silvestri and @navidcy, I totally agree. I only introduced CUDA.@allowscalar under the impression it was necessary for certain GPU tests to pass. However, now understanding that isn’t the case, I've removed it in commit [7f54c3c](https://github.com/CliMA/Oceananigans.jl/pull/3488/commits/7f54c3c451c9753524056d45c6578a9cf865be68).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2035930379:598,access,access,598,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2035930379,1,['access'],['access']
Security,"> > @siddharthabishnu, how do we know that now the metrics are filled correctly? you were comparing with a grid from MITgcm?; > ; > Yes. Consider the following sources for the grid metrics:; > ; > 1. the `cs32` grid with one halo layer, used by:; > ; > * Ali for the Rossby-Haurwitz test case in Oceananigans v0.82.0; and; > * yourself to check the interior coordinates and grid metrics of the Oceananigans `cc32` grid;; > 2. the `cs32` grid with 4 halo layers created by @jm-c using MITgcm;; > 3. the `cc32` grid created by Oceananigans.; > ; > In the validation scripts for solid body rotation and the Rossby-Haurwitz wave within the `ncc-glw/cubed-sphere-dynamics` branch associated with PR #3306, I compared the metrics of grid (3) against both (1) and (2), and plotted their absolute and relative differences. With the latest modifications, these differences have been minimized though not entirely eliminated. OK, so the benchmark is the `cs32` grid by MITgcm. Can we do the comparison in this PR? I'd like to see a test ideally because otherwise how do we assess that the changes we are suggesting here are correct. I can also do that, just give me a code snippet that loads the two grids?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1978039025:553,validat,validation,553,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1978039025,1,['validat'],['validation']
Security,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:1438,validat,validation,1438,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586,2,['validat'],['validation']
Security,"> > Here is a simplified version of my code: https://github.com/jagoosw/OpenBoundaries.jl/blob/main/validation/bug_mwe.jl; > ; > Was curious to have a look but I think the link might be dead?. I forgot to make the repo public, it should work now",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2414305318:100,validat,validation,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2414305318,2,['validat'],['validation']
Security,"> > Here's a first attempt at Lagrangian-averaged dynamic Smagorinsky: https://github.com/CliMA/Oceananigans.jl/tree/ss-xk/dynamic-smagorinsky It doesn't run due to `StackOverflorError`, likely due to the way we are taking the averages. I think if we write custom functions to take each of the averages it would run, just haven't got to it yet.; > ; > Nice, I wasn't aware of that effort. I see you're starting with the scale-independent version, correct?; > ; > I think starting with the lagrangian-averaged version is bold though. From what I've seen the lagrangian vs directional averaged versions of the model are very close in results for most LES we run for the ocean (i.e. doubly periodic), but the lagrangian average can be significantly more expensive. So I think for most cases we'd actually prefer the directionally-averaged one in order to save on computational costs. The use cases where lagrangian average really shines are the heterogeneous flows (like with immersed boundaries) and laminar-turbulent transitions.; > ; > Also, if you open a PR I can help you guys with that. I think I caught a couple of typos in the `𝒥ᴿᴺ` and `𝒥ᴺᴺ` forcing functions for example. Why don't you implement `DynamicSmagorinsky` and abstract the notion of the `Averaging` to `LagrangianAveraging` and `DirectionalAveraging`. Note, you should expect to spend your time validating the closures by running simulations --- not software design and abstraction. If you're having difficulties with the software design I can help.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2189645959:1363,validat,validating,1363,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2189645959,1,['validat'],['validating']
Security,"> > I agree with these!; > > I think `filename` (including the extension) is a good choice. I also agree its convenient to use `dir` and `filename` rather than `filepath`.; > > For `JLD2`, we need to ""validate"" the `filename` to ensure that it ends in `jld2`. This is needed because we have to identify the ""prefix"" (the part without the extension) in order to do file splitting.; > ; > Ah, yes, I forgot about that...; > ; > So `JLD2` requires that the splitting is done with the `.jld2` extension, correct?. No, we don't have to require that. But we do need to know what the extension is in order to produce new filenames. We can either ""infer"" the extension, or assume that it's `.jld2`. Do we want to allow other extensions? What's the benefit of that? It might be nice to enforce uniformity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1090376967:201,validat,validate,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1090376967,1,['validat'],['validate']
Security,> > I have created a new validation script called `shallow_jet_topography.jl` that evolves the barotropically unstable jet (like in the shallow water example) but now over a shelflike topography. It can be found in `valiation/shallow_water`.; > ; > I don't see it; did you push?. Sorry! I have added it now. https://github.com/CliMA/Oceananigans.jl/blob/fp-ss/shallow-water-version2/validation/shallow_water_model/shallow_water_jet_topography.jl. One of my mitakes is that I didn't define the bathymetry. I need to figure out how to do that. Thanks for the very helpful feedback!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1975142954:25,validat,validation,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1975142954,4,['validat'],['validation']
Security,> > I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error.; > ; > That's indicative of a bug yes? This could lead to wrong behavior if the accessed memory does exist but is irrelevant (although I guess it depends whether the value is actually used or not). I guess this would be a bug in that scenario,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624023:53,access,access,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624023,2,['access'],"['access', 'accessed']"
Security,"> > I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.; > ; > I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :); > ; > We could you out regarding the troubles you've been having. I just did that, but here are so many problems I don't know where to start with. I will try to choose the one that seems easier and go for it. Haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237:569,access,access,569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062503237,2,['access'],['access']
Security,"> > I'm getting this error when trying to run my code on multiple GPUs (it works fine on CPUs):; > ; > Hmmmm it has to do with switching `stream` from your stream pool in the GPU you are in. That always worked for the clusters I tried. Any instance of `@apply_regionally` should fail for you. If you can give me a MWE I can take a look at it. Here's a MWE:. ```julia; using Oceananigans; using CUDA. if CUDA.has_cuda_gpu(); arch = GPU(); n_partitions = CUDA.ndevices(); else; arch = CPU(); n_partitions = 2; end . grid_base = RectilinearGrid(arch, size=(4, 4, 4), extent = (1,1,1)); grid = MultiRegionGrid(grid_base, partition = XPartition(n_partitions), devices = n_partitions). model = NonhydrostaticModel(grid = grid); ```. Running this on a CPU works, but on a GPU is throws me this error:. ```; ERROR: TaskFailedException. nested task error: BoundsError: attempt to access Tuple{Vector{CuStream}} at index [2]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base ./tuple.jl:29; [2] (::Oceananigans.Architectures.var""#3#6"")(); @ Oceananigans.Architectures /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Architectures.jl:26; [3] lock(f::Oceananigans.Architectures.var""#3#6"", l::ReentrantLock); @ Base ./lock.jl:185; [4] next_stream; @ /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Architectures.jl:24 [inlined]; [5] (::KernelAbstractions.Kernel{CUDAKernels.CUDADevice, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(2, 4)}, typeof(Oceananigans.BoundaryConditions.gpu__fill_bottom_and_top_halo!)})(::OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, ::Vararg{Any}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels /glade/work/tomasc/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:218; [6] launch!(::GPU, ::RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Flo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310844261:871,access,access,871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310844261,1,['access'],['access']
Security,"> > Is there any syntax change need to be made in; > > https://github.com/CliMA/Oceananigans.jl/blob/jsw/different-velocities/validation/lagrangian_particles/particles_in_convection.jl; > > I'm actually thinking now that if the name of the module didn't change, moving the module from `LagrangianParticleTracking` to `Models.LagrangianParticleTracking` might not imply any syntax change _given_ that the module name is exported.; > > @glwagner?; > ; > Does it run?. I see. The brute force approach. I'll try!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1533877371:126,validat,validation,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1533877371,1,['validat'],['validation']
Security,"> > It's something to do with GPU, maybe GPU reductions?; > > ```; > > [2023/05/24 21:41:15.102] INFO Testing grid utils on variably spaced grid....; > > --; > >   | Grid initialization: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_grids.jl:199; > >   | Expression: minimum_xspacing(grid) ≈ FT(π / 3); > >   | Evaluated: 0.0 ≈ 1.0471975511965976; > > ```; > ; > I see this error. But I can't reproduce it. On tartarus it's not happening and I don't have access to Svedrup. So I don't know what to do... :(. I guess its a CUDA version issue or something",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1567729329:526,access,access,526,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1567729329,1,['access'],['access']
Security,"> > Next week I will work on getting higher order methods working for ShallowWaterModels.; > ; > That would be awesome!; > ; > Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?; > ; > To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`. I think that getting some tests is a good next step. I'll see what kind of tests we have now for IncompressibleModel and will put together a few tests for ShallowWaterModel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132:177,validat,validation,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744073132,5,['validat'],"['validate', 'validation']"
Security,"> > Note to self: we should figure out an interface to help users access grid metrics. We shouldn't write things like `grid.Δxᵃᵃᶜ` in the examples.; > ; > Yes yes yes!; > ; > Can we have alias?. We need a function like `dx = grid_spacing(grid, 1)` or something which returns a number (if constant) or a field (if not).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967748805:66,access,access,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967748805,1,['access'],['access']
Security,"> > Test nonlinear advection for 2D/3D schemes; > ; > You mean, validate 2D/3D high-order momentum advection for flux form schemes?; > ; > Another issue with a vortex solution is that the momentum term is identically zero in the exact solution. So I'm not sure this test isolates convergence.; > ; > I believe inviscid Burgers will form a shock, and then be subject to numerical dissipation. If you add viscosity, then you are limited by the accuracy of the viscous term. So I'm not sure it even works to turn off the pressure gradient. That's not correct. The inviscid Burgers will form a shock (indeed!) and this will result in energy dissipation but that's *not* numerical dissipation but rather a physical one!. ![Burgers-anomalousdissipation-marker](https://user-images.githubusercontent.com/7112768/179238464-c9890412-59de-43bd-9a82-24f5c7982aa8.gif)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185575913:64,validat,validate,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185575913,1,['validat'],['validate']
Security,"> > Thanks @glwagner for merging main into this branch.; > > I have returned to the global simulations and have learned something.; > > Using all the same parameters as before, I get `NaNs` after just over an hour.; > > Upon closer inspection, I see that the height becomes negative after 56 minutes or so. I have tried reducing the time step by a factor of 20 and that didn't help.; > > Do you think I should play around with other advection schemes, say some high order upwinding schemes?; > ; > You need to make sure that `h` is never zero, that will give you a `NaN` because the forcing is divided by `h`. It is kind of annoying but you have to set a ""minimum height"" in the initial conditions (cannot start with `h = 0` somewhere). I remember setting `hmin = 10` was enough to get a stable simulation. Thanks @simone-silvestri. . The validation script was set up with `hmin = 10` and that did go unstable. I tried `20` and `30` and they both go unstable. I'm tring `40` and it seems better. I thought if this at least runs, and shows us the ACC going on the right direction, thsi would be a big leap forward. Then we can worry abou thow to minimize the minimum h, if we like. . I will keep you posted. Update: 50 is still unstable after just under 3 hours. I'm now going to try 100. It seems like a pretty big cushion but I am curious what it takes. . And 100 yields negative height after less than 4 hours. Not good.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1981444163:839,validat,validation,839,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1981444163,2,['validat'],['validation']
Security,"> > There is also already a 1D validation test for the immersed boundary --- I wonder if it also shows this bug:; > > https://github.com/CliMA/Oceananigans.jl/blob/master/validation/immersed_boundaries/immersed_hydrostatic_diffusion.jl; > ; > @glwagner I'm not sure. I tried running it, but got an method error on the `HydrostaticFreeSurfaceModel`: _FreeSurface( ...) is ambiguous_. Looks like that validation experiment is missing . ```julia; pushfirst!(LOAD_PATH, joinpath(@__DIR__, "".."", "".."")); ```. ~~so it may have been using an old version of Oceananigans in your global environment!~~ EDIT: even if this were the case, I still get the error after adding an appropriate `pushfirst!`. I'll try to fix this separate from this PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900465685:31,validat,validation,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900465685,3,['validat'],['validation']
Security,"> > This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?; > ; > This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`. Got it! Agreed. Should we test that `hydrostatic_pressure_anomaly` is either `CenterField(grid)` or `nothing` and throw a helpful error otherwise?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088696540:410,access,access,410,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088696540,2,['access'],['access']
Security,> > Usually restarting the test works for me to clear that error; > ; > Good to know. How can I do that?. I don't think you can because you need access to the Clima buildkite. But @simone-silvestri can do it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157917180:145,access,access,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157917180,2,['access'],['access']
Security,"> > We can delete this validation test too after this: https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/internal_tide.jl; > ; > The validation script includes a multi region example. Shall I still delete it? I could also clean it up and add toml files in the validation script directory (see #3076). Yeah, that's a random place for a multi region example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1577474331:23,validat,validation,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1577474331,4,['validat'],['validation']
Security,> > We might not. Where is interpolate used?; > ; > Its not used anywhere in the source code but in quite a few validation scripts. Can you point us to a few?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1371166618:112,validat,validation,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1371166618,1,['validat'],['validation']
Security,"> > You're gonna want to implement a struct that's someting like; > > ```julia; > > struct HaloFillingEvent; > > location; > > z_indices; > > from_side; > > to_side; > > field_id; > > end; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > and then a function; > > ```julia; > > mpi_tag(hfe::HaloFillingEvent) = # number; > > ```; > ; > I am not sure about this solution. The tag is used immediately (and only) where created, not recorded, and automatically destroyed by MPI after the communication is complete, so I do not immediately see the immediate utility of extra steps, or to save something in memory. A function that, given architecture, location, and side, spits out a unique tag seems sufficient for interpretability without having to record the output somewhere (it's a bit like a hash function, if you have function and inputs you have everything you need). There are a few purposes:. - Make it easier for a future developer to understand the code by using words rather than a digit code; - Make debugging possible; - Replace this:. ```; arch.active_requests[] += 1; ```. with an actual list of the active requests (rather than simply counting them --- eg `push!(active_events, new_event)`, and `pop!(active_events, finished_event)`. The objective is not to write the minimal code that will work, but to create a system that is human understandable. While a minimal functionality can be debugged and made to work once, it will be very brittle because if it breaks, it could shut down the whole system and prevent future development. Also `active_requests` used to be called `mpi_tag` and I don't understand the relationship between those two concepts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2298985401:821,hash,hash,821,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2298985401,2,['hash'],['hash']
Security,"> @ali-ramadhan, should we re-run the validation tests?. I'm sure they're fine. They passed earlier today: https://buildkite.com/clima/oceananigans-validation-experiments/builds/128. They take a while to run. And we'll know tomorrow morning if they fail! They're set to run nightly at 3am ET.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783657161:38,validat,validation,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783657161,2,['validat'],"['validation', 'validation-experiments']"
Security,"> @christophernhill do you think you could produce a script with non-trivial dynamics involving the `HydrostaticFreeSurfaceModel` and the implicit solver?; > ; > We should also come up with something that exercises the tridiagonal solver on a vertically-stretched grid. @glwagner @francispoulin and @hennyg888, we could start from https://github.com/CliMA/Oceananigans.jl/blob/master/validation/barotropic_gyre/barotropic_gyre.jl ? I'll check that it is still healthy. We can make the number of points bigger or smaller to look at problem size. Do we want to also try `RegularLatitudeLongitudeGrid` or should we do a box first . This also has an `ImmersedBoundaryGrid` bump in the domain - we can get rid of that for now, but could include that too down the road. . We should be able to add some vertical levels to this and turn on some implicit vertical diffusion - which is another tridiagonal solve?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894291059:384,validat,validation,384,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894291059,1,['validat'],['validation']
Security,> @elise-palethorpe also perhaps change the validation script name as @glwagner suggest?. Do we need the file at all? Can I just include mg preconditioner in `doubly_bounded_poisson.jl`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1236213039:44,validat,validation,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1236213039,1,['validat'],['validation']
Security,"> @fluidnumerics-joe the CI doesn't work... something's wrong with the Manifest you pushed.; > ; > It would be easier if you somehow allow maintainers to push. There is an option ""Allow edits and access to secrets by maintainers"" when you open a PR. Perhaps you disabled that?; > ; > Personally if I don't see the CI working (at least starting) then I feel it's a bit futile to comment on code that might be outdate or deprecated. I'll check settings. Have you noticed your main branch fails CI?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936969599:196,access,access,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936969599,1,['access'],['access']
Security,"> @francispoulin I noticed you are adding convergence tests. We also have convergence tests under `validation` here:; > ; > https://github.com/CliMA/Oceananigans.jl/tree/master/validation/convergence_tests; > ; > and it could make sense to contribute your convergence tests there.; > ; > The tests are used to generate figures for documentation:; > ; > https://clima.github.io/OceananigansDocumentation/stable/validation/convergence_tests/; > ; > @ali-ramadhan can comment on how convergence tests might be added to our CI / automated testing suite.; > ; > Is this PR just intended just to add advection schemes, or it is attempting to add higher-order operators for other terms as well? It'd be great to have higher-order finite volume operators for diffusion terms, for example. Does it make sense to contribute these in a separate PR and consider how they might be used in diffusion operators (for example)?. Thanks @glwagner for the post. I think it makes sense for this to just include updating the advection, since that's already a bit step. I am sorry for no doing this sooner. I got distracted thinking it would just be a little more but it turns out to be more than I thought. I will clean up the branch now and then maybe you can approve the update?. Next week I will work on getting higher order methods working for ShallowWaterModels.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743805478:99,validat,validation,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743805478,3,['validat'],['validation']
Security,"> @glwagner ,; > ; > So then, based on the code snippet given by @johnryantaylor and our discussion, this validation could be adapted to something like:; > ; > ```julia; > lamb = 1 # decay scale for slip velocity in meters; > @inline w(x,y,z,t) = (tanh(max(-z/lamb,0))*tanh(max((z+H)/lamb,0))); > sinking = SlipVelocity(WENO5(), w=w); > ```; > ; > The way the code is, does it accept functions for velocity inputs? Is that something I could do to help you?. You can do this a few ways:. ```julia; # Vertical velocity function; const lamb = # something; const H = # something; @inline w_func(x, y, z) = tanh(max(-z / lamb, 0.0)) * tanh(max((z + H) / lamb, 0.0)). # Field (allocates memory and precalculates w_func); w = ZFaceField(grid); set!(w, w_func); sinking = AdvectiveForcing(w = w). # Function field (avoids allocating memory but calls `w_func` every iteration); w = FunctionField{Center, Center, Face}(w_func, grid); sinking = AdvectiveForcing(w = w); ```. We could also add the feature to `AdvectiveForcing` that, if an input is a function, we assume it's a function of `x, y, z, t` and deal with it appropriately (by wrapping in a `FunctionField` and adding reference to the model `clock`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436:106,validat,validation,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436,1,['validat'],['validation']
Security,"> @glwagner and @simone-silvestri; > ; > Continuing the discussion. [#2788 (reply in thread)](https://github.com/CliMA/Oceananigans.jl/discussions/2788#discussioncomment-8101280); > ; > It looks like MPI needs to be initialized before accessing its communication variables.; > ; > Thus, despite calling `Distributed` initializes MPI, we need to access `Nranks = MPI.Comm_size(comm)` before to define `Partition`.; > ; > https://github.com/CliMA/Oceananigans.jl/blob/294602781e7a678ef3a662e1a31d2145d10d0800/validation/distributed_simulations/distributed_nonhydrostatic_turbulence.jl#L20-L22; > ; > Should we initialize MPI when importing DistributedComputations?. Either 1) explicitly invoke `MPI.Init()` or 2) move those lines to after the grid constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894650511:235,access,accessing,235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894650511,3,"['access', 'validat']","['access', 'accessing', 'validation']"
Security,"> @glwagner could I be added to the buildkite organisation so I can rerun the test please?. Unfortunately I think we have to limit access to that to Clima folks, but it affects all Clima software (not just Oceananigans). As an example, none of us have permissions to add people to the buildkite.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3441#issuecomment-1911171883:131,access,access,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3441#issuecomment-1911171883,1,['access'],['access']
Security,"> @glwagner, do you think a bit more elaborate validation test is in order?; > I'll approve at this point and let this to your judgment. I am currently working on a more elaborate validation / example (I'd like to implement an overturning, eddying channel example that uses this closure in a 3D setting) so I think we are ok to merge this PR now as is.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1738#issuecomment-863627568:47,validat,validation,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1738#issuecomment-863627568,2,['validat'],['validation']
Security,"> @glwagner, how can we avoid `collect`? E.g., at; > ; > https://github.com/CliMA/Oceananigans.jl/blob/d913858aa771f096e8ce48da132749361c8f1647/validation/elliptic_solvers/doubly_bounded_poisson.jl#L130; > ; > I tried `arch_array` but seems like we need to write some more methods for it?; > ; > ```julia; > julia> r_array = arch_array(arch, reshape(interior(r), Nx * Ny * Nz)); > ERROR: MethodError: no method matching arch_array(::CPU, ::Base.ReshapedArray{Float64, 1, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}); > Closest candidates are:; > arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; > arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; > arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; > ...; > Stacktrace:; > [1] top-level scope; > @ REPL[6]:1; > [2] top-level scope; > @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; > ; > julia> r_array = arch_array(arch, interior(r)); > ERROR: MethodError: no method matching arch_array(::CPU, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); > Closest candidates are:; > arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; > arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; > arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; > ...; > Stacktrace:; > [1] top-level scope; > @ REPL[7]:1; > [2] top-level scope; > @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; > ```. Why do you need to convert to architecture? Is it enough to use. ```julia; r_reshaped = reshape(interior(r), Nx * Ny * Nz); ```. ?. If you can't use that then I think y",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1163085492:144,validat,validation,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1163085492,1,['validat'],['validation']
Security,> @iuryt do you want to help set up a validation case for this feature?. Yep. I will be working on the NP model with a P sinking velocity this week. Any idea for an experiment that changes MLD with time? ; Maybe making it 1D for simplicity? But I would like to test for 3D to make sure I am programming it correctly. Maybe buoyancy=nothing and diffuse a tanh-like temp profile? But would be better to have a shallowing mld instead.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081795184:38,validat,validation,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081795184,2,['validat'],['validation']
Security,"> @matinraayai I made a bunch of suggestions!; > ; > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > ; > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > ; > ```julia; > using Oceananigans; > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > model = NonhydrostaticModel(; grid, advection=WENO5()); > ϵ(x, y, z) = 2rand() - 1; > set!(model, u=ϵ, v=ϵ); > simulation = Simulation(model; Δt=0.01, stop_time=4); > run!(simulation); > ```; > ; > should be enough?. @glwagner I'm okay with that. I can take a look at this once this PR is accepted to ```amdgpu```.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702:288,validat,validation,288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702,2,['validat'],['validation']
Security,"> @navidcy thanks for the commits. I am now testing the script against a free-explicit free surface and a MultiRegionGrid. @navidcy, as you may have anticipated, a MultiRegionGrid does not result in this error. Code Modification:; ```julia; #=; grid = ConformalCubedSphereGrid(; panel_size = (Nx, Ny, Nz),; z = (-1, 0),; radius = R,; horizontal_direction_halo = 6,; partition = CubedSpherePartition(; R = 1)); =#. latlongrid = LatitudeLongitudeGrid(size=(Nx, Ny, Nz),; longitude = (-90, 90),; latitude = (-45, 45),; z = (-1, 0)); grid = MultiRegionGrid(latlongrid, partition = XPartition(2)); ```; Terminal Output:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); ┌ Warning: MultiRegion functionalities are experimental: help the development by reporting bugs or non-implemented features!; └ @ Oceananigans.MultiRegion /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/MultiRegion/multi_region_grid.jl:102; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 7.722 days, wall time: 0 seconds; [ Info: ... simulation initialization complete (111.288 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (994.424 ms).; [ Info: Simulation is stopping after running for 0 seconds.; [ Info: Simulation time 628.319 ms equals or exceeds stop time 628.319 ms.; [ Info: Making an animation from the saved data...; ```; When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; ```julia; ERROR: LoadError: UndefVarError: `settings` not defined; ```; When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; ```julia; ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155:642,validat,validation,642,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155,1,['validat'],['validation']
Security,"> @siddharthabishnu I pushed a clean version of the grid comparison at https://github.com/CliMA/Oceananigans.jl/blob/sb-ncc/cs-grid-metrics/validation/multi_region/multi_region_cubed_sphere_grid.jl; > ; > if I run this on this branch I get:; > ; > ```julia; > julia> include(""multi_region_cubed_sphere.jl""); > [ Info: λᶜᶜᵃ_difference_MITgcm panel 1: 1.8471271253206468e-7; > [ Info: λᶜᶜᵃ_difference_MITgcm panel 2: 1.8471270881725844e-7; > [ Info: λᶜᶜᵃ_difference_MITgcm panel 3: 3.2442725228121196e-7; > [ Info: λᶜᶜᵃ_difference_MITgcm panel 4: 1.8471271544306945e-7; > [ Info: λᶜᶜᵃ_difference_MITgcm panel 5: 1.847127087195588e-7; > [ Info: λᶜᶜᵃ_difference_MITgcm panel 6: 3.244272524791092e-7; > [ Info: λᶜᶜᵃ_difference_MITgcm panel 1: 1.8471271253206468e-7; > [ Info: λᶜᶜᵃ_difference_MITgcm panel 2: 1.8471270881725844e-7; > [ Info: λᶜᶜᵃ_difference_MITgcm panel 3: 3.2442725228121196e-7; > [ Info: λᶜᶜᵃ_difference_MITgcm panel 4: 1.8471271544306945e-7; > [ Info: λᶜᶜᵃ_difference_MITgcm panel 5: 1.847127087195588e-7; > [ Info: λᶜᶜᵃ_difference_MITgcm panel 6: 3.244272524791092e-7; > [ Info: λᶠᶠᵃ_difference_MITgcm panel 1: 1.732365234564951e-7; > [ Info: λᶠᶠᵃ_difference_MITgcm panel 2: 1.7323652025336144e-7; > [ Info: λᶠᶠᵃ_difference_MITgcm panel 3: 0.05625027340835691; > [ Info: λᶠᶠᵃ_difference_MITgcm panel 4: 1.7323652655498735e-7; > [ Info: λᶠᶠᵃ_difference_MITgcm panel 5: 1.7323652008460754e-7; > [ Info: λᶠᶠᵃ_difference_MITgcm panel 6: 0.0562502734083572; > [ Info: φᶜᶜᵃ_difference_MITgcm panel 1: 1.570048120703993e-7; > [ Info: φᶜᶜᵃ_difference_MITgcm panel 2: 1.5700481280397916e-7; > [ Info: φᶜᶜᵃ_difference_MITgcm panel 3: 1.3603837144327004e-7; > [ Info: φᶜᶜᵃ_difference_MITgcm panel 4: 1.5700481343680627e-7; > [ Info: φᶜᶜᵃ_difference_MITgcm panel 5: 1.570048127987056e-7; > [ Info: φᶜᶜᵃ_difference_MITgcm panel 6: 1.360383713455704e-7; > [ Info: φᶠᶠᵃ_difference_MITgcm panel 1: 1.478470279652168e-7; > [ Info: φᶠᶠᵃ_difference_MITgcm panel 2: 1.4784702873954643e-7; > [ Info: φᶠᶠᵃ_di",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2013122448:140,validat,validation,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2013122448,1,['validat'],['validation']
Security,"> @siddharthabishnu, `CUDA.@allowscalar` introduced by [3cdd470](https://github.com/CliMA/Oceananigans.jl/pull/3488/commits/3cdd4705fedf3238d8858bb0f56e9b27b01ba34a) is detrimental for performance. Like it induces O(10-100x) slowdown I think....; > ; > Is this a temporary solution?; > ; > cc @glwagner, @simone-silvestri. I think it is. We can try to see if this works on one GPU. If it does we can keep the allowscalar for the moment otherwise we can remove them.; In the end all this will have to live in a kernel.; Note that this will still not work on multiple GPUs as you cannot explicitly access one region from another one on a different GPU without switching to the device that holds the data.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2034043615:596,access,access,596,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2034043615,1,['access'],['access']
Security,"> @siddharthabishnu, can you commit the steady-state validation script in this PR from #3302? We were trying to ensure that double halo passing occurs for velocities etc and these are probably also needed for #3302 so let's have both validation scripts in one place so we don't do double job?. Done. 😊",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1749381446:53,validat,validation,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1749381446,2,['validat'],['validation']
Security,"> @siddharthabishnu, how do we know that now the metrics are filled correctly? you were comparing with a grid from MITgcm?. Yes. Consider the following sources for the grid metrics:. 1. the `cs32` grid with one halo layer, used by:; - Ali for the Rossby-Haurwitz test case in Oceananigans v0.82.0; and; - yourself to check the interior coordinates and grid metrics of the Oceananigans `cc32` grid;; 2. the `cs32` grid with 4 halo layers created by @jm-c using MITgcm;; 3. the `cc32` grid created by Oceananigans. In the validation scripts for solid body rotation and the Rossby-Haurwitz wave within the `ncc-glw/cubed-sphere-dynamics` branch associated with PR #3306, I compared the metrics of grid (3) against both (1) and (2), and plotted their absolute and relative differences. With the latest modifications, these differences have been minimized though not entirely eliminated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1977945018:520,validat,validation,520,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1977945018,1,['validat'],['validation']
Security,"> @siddharthabishnu, perhaps it's simpler to try explicit free surface. Have a look, e.g., at; > ; > https://github.com/CliMA/Oceananigans.jl/blob/c9aa1b3b90c9775e4f3a98b7c67f916727830aee/validation/multi_region/cubed_sphere_momentum_dynamics.jl#L63. Thanks @navidcy. Switching to fully explicit free surface from the default implicit one resolved the boundary condition issue I mentioned in the beginning of this conversation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747675234:188,validat,validation,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747675234,2,['validat'],['validation']
Security,"> @tomchor I can't tell if the formula you've pasted is actually different from ours (or what the definition of |S| is). Where does it come from?. That was my bad, forgot to cite the source. It comes from [Chamecki et al. 2019](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/2019RG000655). But you're right that the definition is identical. I misinterpreted the code. > It'd be fine to change the constant because there's no validation test. I indeed think we should change constant default to match the most common value used in the literature. I'd also like to change the notation used in the code from `ς` to `\Upsilon`, so as to match [the docs](https://clima.github.io/OceananigansDocumentation/stable/physics/turbulence_closures/) (just to make the code easier for contributors). I'll open a PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889239321:434,validat,validation,434,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889239321,1,['validat'],['validation']
Security,"> @xkykai so you're saying the fix for the instability exists already and it's just a matter of implementing it in #3188? Is that right?. Yes, and it’s here at https://github.com/Yixiao-Zhang/Oceananigans.jl/commit/c7983b8002b91cd5939018a7c999eae77e2105ac. This should work and fix the numerical issues, but has not been extensively validated yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3677#issuecomment-2270195995:333,validat,validated,333,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3677#issuecomment-2270195995,1,['validat'],['validated']
Security,"> Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated).; > ; > There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one.; > ; > > if the name is changed to include Cartesian then we can merge this and discuss further in an issue.; > ; > Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here. For physics tests we can't avoid introducing an arbitrary tolerance. So its ok. That's one reason why physics tests in CI are a bit problematic and we also need validation tests analyzed by humans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957:1001,validat,validation,1001,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957,2,['validat'],['validation']
Security,"> Ah ok, thanks for that info! I guess that means this internal tide validation experiment wouldn't benefit from GPU parallelization?. Not at this stage but hopefully sometime soon.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-868677869:69,validat,validation,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-868677869,1,['validat'],['validation']
Security,"> All the tests seem to pass but I get two errors.; > ; > The first error is on a GPU, running `test_shallow_water_diffusion_cosine` on the field `u` using the `ConservativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?; > ; > ```; > [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; > [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; > ERROR: Scalar indexing is disallowed.; > Invocation of getindex resulted in scalar indexing of a GPU array.; > This is typically caused by calling an iterating implementation of a method.; > Such implementations *do not* execute on the GPU, but very slowly on the CPU,; > and therefore are only permitted from the REPL for prototyping purposes.; > If you did intend to index this array, annotate the caller with @allowscalar.; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] assertscalar(op::String); > @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; > [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); > @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; > [4] getindex; > @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; > [5] _getindex; > @ ./abstractarray.jl:1321 [inlined]; > [6] getindex; > @ ./abstractarray.jl:1288 [inlined]; > [7] getindex; > @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; > [8] _broadcast_getindex; > @ ./broadcast.jl:675 [inlined]; > [9] _getindex; > @ ./broadcast.jl:705 [inlined]; > [10] _broadcast_getindex; > @ ./broadcast.jl:681 [inlined]; > [11] getindex; > @ ./broadcast.jl:636 [inlined]; > [12] macro expansion; > @ ./broadcast.jl:1004 [inl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748:573,validat,validation,573,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1968123748,1,['validat'],['validation']
Security,"> Also one thing that is important to get right in multi-layer shallow water models is layer-wise conservation of mass and other properties (see _e.g._, https://aronnax.readthedocs.io/en/latest/verification.html and http://www.nordet.net/beom.html).; > ; > > Topography that can interact more than one layer is complicated because then we need wetting and drying, but it won't need immersed boundaries. At least i don't think so. Wetting and drying usually requires a positive preserving advection scheme. We have first-order upwinding (which I don't think anyone has every used), that is positive preserving and could do this. But it's not a great scheme. A limiter would be better. There are a lot of methods out thatk, but not the first thing to worry about. This if much longer term, I would say.; > ; > In addition to positive-preserving advection schemes, it seems one other way to deal with this is adding to the pressure gradients an extra term that prevents the thicknesses of outcropped/incropped layers from reaching zero following [Salmon (2002)](https://www.ingentaconnect.com/content/jmr/jmr/2002/00000060/00000004/art00004?token=005b148389c57630504c2a726e2d58464340592f713b672c57582a67232d45234a46246c6a4d2c3167732355e72). There is a deep discussion on the physics and practical implementation of this in different validation simulations in http://www.nordet.net/etc/doc_beom.pdf. Just wanted to put this out there, I don't have a good feel for which approach would be most desirable. Thanks for the reference @apaloczy ! I know of Rick's work but didn't know whether people were using it very much. The reference seems like it will shed some light on the matter. This might very well be worth playing with to see what approach we prefer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116110257:1330,validat,validation,1330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116110257,1,['validat'],['validation']
Security,"> Also, we need to be careful if the notation with superscripts are the default when writing to NetCDF. These ""uncommon"" unicode characters aren't very easy to access from a lot (most?) of programming languages. That's an interesting consideration. I believe MATLAB, Python, and Julia all support Unicode, but perhaps languages like R do not? This could be a thorny question...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799800872:160,access,access,160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799800872,1,['access'],['access']
Security,"> Another option is to pass FT=Float32 to the model and then let the constructor convert related components to Float32 (or Float64 if FT=Float64 is passed). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement. This could work but I'm wary of converting in general. When we convert, then identity is lost between whatever the `component` in the user script and `model.component`. This is an especially major problem for `grid`. But even if we implement this feature via the grid, there would be many other types like `FPlane(f=1)` for example which have the incorrect type. We can tell users that this is possible so they always need to use `model.coriolis`. But broadly I think this kind of design is a bit brittle; too easy for things to go wrong. > Actually, I think it would be better to define a function Oceananigans.set_default_number_type(FT) for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. I think that's a nice idea. It's also maybe more sensible syntax right now since there is only one default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389771263:915,access,access,915,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389771263,2,['access'],['access']
Security,"> Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... The CUDA.jl implementation is such an implementation: https://github.com/JuliaGPU/CUDA.jl/blob/2310b88738c11449867e6f37c5acbfcd453dc2c8/src/mapreduce.jl#L60-L69. It probably needs to be profiled and optimized if you really want to squeeze out performance, but it isn't a naive implementation either. It's exposed via `Base.mapreducedim` and friends.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152:638,expose,exposed,638,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152,1,['expose'],['exposed']
Security,> Are the artifacts downloaded even if we don't use them?. Yeah apparently so. I think for some reason CUDA artifacts are downloaded first but certain calls like `CUDA.versioninfo()` can trigger further artifact downloads of CUDNN and CUTENSOR. > I think the disadvantage of using artifacts is that we are a bit more exposed to bugs and I think that's the cause of at least some of our pain here. The advantage is that it's less work to maintain our local CUDA software and our test environment might be more realistic / relevant since users typically use artifacts (I think). The CUDA.jl docs recommend using artifacts (https://cuda.juliagpu.org/dev/installation/overview/#CUDA-toolkit) but this may be because new users are less likely to encounter issues if they use the artifacts (which usually work out of the box) instead of fidgeting with local installs especially on servers without root access. For CI maintaining a local toolkit installation may be better?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1799#issuecomment-872401461:317,expose,exposed,317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1799#issuecomment-872401461,2,"['access', 'expose']","['access', 'exposed']"
Security,"> But I do have one question: how are we supposed to treat open boundaries for quantities located at cell centers? I don't see any specific new code dealing with that. I see you used `GradientBoundaryCondition(0)` in your validation codes but, for example, for buoyancy that's not gonna cut it and will lead to reflections. For inlets a `ValueBoundaryCondition` or `GradientBoundaryCondition` works well. For outlets an Upwind advective boundary condition does the trick.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263400235:222,validat,validation,222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263400235,1,['validat'],['validation']
Security,"> But I do have one question: how are we supposed to treat open boundaries for quantities located at cell centers? I don't see any specific new code dealing with that. I see you used `GradientBoundaryCondition(0)` in your validation codes but, for example, for buoyancy that's not gonna cut it and will lead to reflections. The majority of the new code here deals with the fact that you can't update the boundary condition on wall normal velocities after the pressure correction step and maintain the interior domain to be physical and divergence-free, so we have a new function `_fill_X_open_halo!`, but there is nothing stopping you from also defining new methods for `_fill_west_halo!` which still acts before both the predictor and correct step and is what you would need to write for centre field OBCs. The reason I used `GradientBoundaryCondition(0)` in the validation case is that the literature suggests that it doesn't make much of a difference for the non-wall normal velocity component what boundary condition you use (e.g. https://doi.org/10.1002/fld.1650181006 ""(iii)&plat + Vacp/dn = 0, where V is ‘user-specified’, but cannot be zero, and should be positive if fluid is leaving the domain. (The average normal velocity through the boundary is a reasonable candidate.) This OBC may be gaining in popularity over acp/an = 0 for reasons which are not entirely clear to us.""), but I guess the reflection might be reduced by something else.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263595729:222,validat,validation,222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263595729,4,['validat'],['validation']
Security,"> But it's the same solver in the validations script also, right? The FFT solver... Is there any other difference?. not the implicit free surface solver, the vertical tridiagonal solver that solves for implicit diffusion of tracer and momentum in the vertical",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1486713707:34,validat,validations,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1486713707,1,['validat'],['validations']
Security,"> But who know how many other users are simply discouraged. Personally, if I download a code that includes non-working pieces of code I am very discouraged. That's something very important to consider, I think, and I totally agree. It seems like we're converging to the ""no code is better than broken code"" perspective. Here's my pitch for this PR:. - Remove the Lid-drive cavity and Couette flow from the docs; - Keep the Convergence tests (maybe move it to the Appendix to make for a cleaner left menu); - Remove the `validation` directory from the master branch as well (that's broken code for now and it prompts users to test them and get errors); - Open another issue/PR to discuss what we'll do with the validation scripts (maybe another repo is a good idea). Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873153475:520,validat,validation,520,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873153475,4,['validat'],['validation']
Security,> Can we wrap the reduced objects somehow so that the iterators for both objects match?. That should work. Could be done with a new `Field` type?. Would you object to merging this PR in it's current form though? It's an optional feature that works for curvilinear grids and is tested. It's been helpful for debugging cubed sphere validation experiments so I'm using it in PR #1522.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-816000984:330,validat,validation,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-816000984,1,['validat'],['validation']
Security,"> Can you put @inline in front of sponge_u_disc, etc?. Done. Same result. I also tried `ContinuousForcing` with `bottom_mask(x, y, z) = 1` and it's slower than its discrete counterpart. Apparently `DiscreteForcing` is a bit faster than `ContinuousForcing`, everything else being the same. > Again unsure if it affects performance but since rate is referenced as global it needs to be const; eg const rate = 1/10. Yes! That makes a big difference! I feel silly that I forgot that. With `const rate=1/10` and `DiscreteForcing` things are as fast as with no forcing. Using the same ""trick"" with `ContinuousForcing` doesn't change things though. So it does seem like the source of the issue is `ContinuousForcing`. I should say though, I'm having some trouble securing a GPU right now, so I haven't been able to run these tests on a GPU. Would a MWE help here?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875702050:756,secur,securing,756,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875702050,1,['secur'],['securing']
Security,"> Can't we add advective terms via the biogeochemical forcing term?; > ; > edit: I see you mentioned that, so I might be missing something... I'll take a look at your examples.; > ; > PS we should add those scripts to `validation/biogeochemistry/`. > I think we can impose a little more structure that eases biogeochemical model development.; > ; > One route is to build out a layer on top of `AbstractBiogeochemistry` for models with a common form, something like; > ; > ```julia; > struct TracerBasedBiogeochemistry; > biogeochemical_tracers; > drift_advection_schemes; > drift_velocities; > transitions; > auxiliary_fields; > end; > ```; > ; > and perhaps more properties. This is similar to how `SeawaterBuoyancy` works, in that it provides a concrete structure with a slot `equation_of_state` whereby ""external"" packages like `SeawaterPolynomials` can insert custom behavior.; > ; > Another possibility is to build out a new abstract type below `AbstractBiogeochemistry` with a function-based interface (somehow).; > ; > I was also thinking it would be nice to supply a ""continuous form"" interface, so that model developers can implement functions that look something like; > ; > ```julia; > biogeochemical_transition(x, y, z, t, N, P, Z, D, parameters); > ```; > ; > rather than having to use the ""discrete form"".; > ; > This sort of structure could also be provided by an external package. The advantage of including it here is that we get tighter coupling with Oceananigans development. This seems like a good idea, I will have a think and try and come up with something",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311545594:219,validat,validation,219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311545594,1,['validat'],['validation']
Security,"> Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient.; > ; > More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think. Yeah, if you think that's enough for CI then I'm definitely okay with that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027:341,validat,validation,341,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027,1,['validat'],['validation']
Security,"> Could you explain why using ifelse has better performance?; Is this because the ternary ? : is an alias for ifelse?. No, the ternary operator `a ? b : c` is shorthand for . ```julia; if a; b; else; c; end; ```. This `if`-statement (as well as the logicals `&&` and `||`) are _short-circuiting_. That is, `c` is guaranteed _not_ to run if `a === true`. For example. ```; julia> f(a, first) = first ? a[1] : a[2]; f (generic function with 1 method). julia> a = rand(1); 1-element Vector{Float64}:; 0.6018054291910822. julia> f(a, true); 0.6018054291910822. julia> f(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] f(a::Vector{Float64}, first::Bool); @ Main ./REPL[7]:1; [3] top-level scope; @ REPL[10]:1; ```. The first call to `f(a, true)` executes without problems, because the second _branch_ isn't executed at all. On the other hand. ```julia; julia> g(a, first) = ifelse(first, a[1], a[2]); g (generic function with 1 method). julia> g(a, true); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If w",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:608,access,access,608,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583,1,['access'],['access']
Security,"> Curious what's the status of this effort to add Metal support to Oceananigans. It's crazy how easy it is to add this support, but the major limitation is that Metal only supports Float32. There hasn't been much effort to validate anything for Float32, though this is a worthwhile goal... Also if we do refactor this PR, I think we should probably put the Metal functionality in an extension, much as #3468 does.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-2093736191:223,validat,validate,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-2093736191,1,['validat'],['validate']
Security,> Does CATKE modify the hydrostatic pressure integral?. No CATKE-specific change I know of. https://github.com/CliMA/Oceananigans.jl/blob/0c1f4fd5b34eb576e1f705c99672204e8288e6d4/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L12-L20. > Seeing that made me think that it wasn't the integral and that the illegal memory access happened elsewhere. I think that is possible since diffusivities are computed just prior to the pressure integral:. https://github.com/CliMA/Oceananigans.jl/blob/0c1f4fd5b34eb576e1f705c99672204e8288e6d4/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl#L82-L85,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2439685128:335,access,access,335,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2439685128,1,['access'],['access']
Security,"> Does `ImmersedBoundaryGrid` + `GridFittedBoundary` only work with `CenteredSecondOrder` advection for now? If so, is it worth adding a warning in case users accidently use higher-order advection schemes with immersed boundaries?. Unclear --- we need to validate that. You might be right that we need to short-circuit the advective fluxes to generalize to higher-order advection schemes, and/or limit to second-order differencing near an immersed boundary. (This is also the case for the existing implementation, if this restriction exists.). We should probably add a more general warning to _any_ usage of `ImmersedBoundaryGrid`. I'll do that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-843529391:255,validat,validate,255,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-843529391,1,['validat'],['validate']
Security,"> Expose the parallelism in RungeKutta3 timestepper and in the update_state! method. This is achieved by lumping together local function calls (all possible kernel calls such as calculate tendencies, rk substeps, etc) in outer functions and wrapping everything in @apply_regionally. This is not strictly necessary right? Just if we want to also support RungeKutta3.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118671032:2,Expose,Expose,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118671032,1,['Expose'],['Expose']
Security,"> Good idea! Does this mean tagging v0.94.0 (and one stop closer to v0.100) as it's a change to the public interface?. It's a very breaking change!. > Yeah I think I used that to debug cubed sphere stuff. Could easily be defined in a validation script though. This PR doesn't remove `StateChecker`, it just stops exporting it. > I use it in almost every script I write haha, but that's because I wrote it to my liking. Touche, but none of the examples use it so it isn't very visible. I'm not even quite sure what the application is, which might be part of the issue? Anyways the point is not to remove this functionality but just not stop exporting it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439770194:234,validat,validation,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439770194,1,['validat'],['validation']
Security,> Great job guys. @jagoosw have you been able to run this (https://github.com/CliMA/Oceananigans.jl/blob/19dac0b8f6b621057e250ecf0510b3c4c91915e9/validation/lagrangian_particles/particles_in_convection.jl#L30) on GPU?; > ; > . I haven't run that case on GPU but would have thought it will run if you change the grid architecture and adapt the initial particle positions (which is described in the simulation tips part of the docs). I can have a look later to see if I can run it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1590920430:146,validat,validation,146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1590920430,1,['validat'],['validation']
Security,> Here is a simplified version of my code: https://github.com/jagoosw/OpenBoundaries.jl/blob/main/validation/bug_mwe.jl. Was curious to have a look but I think the link might be dead?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2412518929:98,validat,validation,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2412518929,2,['validat'],['validation']
Security,"> Hmm. I think its value as a validation experiment really does depend on keeping it up to date with the current version of Oceananigans. What's really useful to people is the validation script that works for current Oceananigans that people can edit and modify, I think... otherwise it's more a discussion that second-order finite volume / difference methods can reproduce the driven cavity, I suppose.; > ; > I understand the point though that this work has value and it's a shame to hide it away. I think it might be nice to have a separate repository of ""cool setups"", each of which links to the specific Oceananigans version that it works with... I definitely see your point. But if that's true, then I think there's a deeper problem here which is that neither the validation scripts nor the benchmarks are kept up to date. (The benchmarks on the docs right now are done with v0.34.0!). I actually tried discussing this in https://github.com/CliMA/Oceananigans.jl/issues/1634, and even proposed a solution that should work. I think we have three options:. - We adopt the opinion that even though it's not ideal because it's out-of-date, we keep the validation experiments since they are cool set-ups that show that our code worked in the past (and supposedly should still be working now, although without proof); - We adopt the opinion that if it's not up-to-date, it's not desired. So we nuke the benchmarks and the validation experiments altogether; - We try to fix this issue and keep the validation experiments and benchmarks up-to-date. You [seem to agree](https://github.com/CliMA/Oceananigans.jl/issues/1634#issuecomment-832203095) that creating a separate repo for validation and relying on `CompatHelper` to automatically create PRs would work. I'd be happy to help implementing that, but I don't have access to a server with GPUs that I set-up the CI for (or enough knowledge of the CI tbh). Any one of those 3 options would work for me, but I think it would be good to make an explicit",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872363477:30,validat,validation,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872363477,3,['validat'],['validation']
Security,> How about #1696? There was never any substantial discussion about it (other than a thumbs up ;)). I wasn't aware of that one tbh. I'm okay with nuking everything except the convergence tests. But also we can approve and merge this one first (since it's obviously an improvement) and discuss what to do with the other validation after that. Both work for me.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-871874171:319,validat,validation,319,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-871874171,1,['validat'],['validation']
Security,> How permanent is the Bickley jet validation experiment? Is it worth adding to the validation experiment Buildkite pipeline in the future?. Let's hold off but discuss with @francispoulin about potentially turning it into something more quantitative (we can use [Poulin and Flierl (2003)](https://journals.ametsoc.org/view/journals/phoc/33/10/1520-0485_2003_033_2173_tneobu_2.0.co_2.xml) as a reference!),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1366#issuecomment-780567324:35,validat,validation,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1366#issuecomment-780567324,2,['validat'],['validation']
Security,> I agree that `HydrostaticLinearFreeSurfaceModel' does not. But should it in case the user specifies the wrong halos?. In that case users will get a segmentation fault. We've introduced a lot of new grids to be used with `HydrostaticFreeSurfaceModel` so I think this is just a matter of convenience for developers. We don't have any real validation experiments for `HydrostaticFreeSurfaceModel` so it's not really ready for general use yet... If people are using `HydrostaticFreeSurfaceModel` they should be setting up validation experiments!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844532819:339,validat,validation,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844532819,2,['validat'],['validation']
Security,"> I agree with docs changes. But it would disrupt a lot of important ongoing work to remove the `validation` directory from the repo without providing an alternative place / way to collaborate on new features. So I think we should leave the `validation` scripts in the repo and discuss what to do next before removing them. Is there ongoing work there? I thought all ongoing work was supposed to be confined to PRs. That's what I've been doing. If that's true and we need to keep the `validation` dir, then at the very least we should make it obvious that those scripts aren't ready for users. The name ""validation"" kinda implies that users can use those scripts to validate their installation, so it's not a surprise that a lot of newcomers try those scripts out and get error. Maybe rename that dir to `work_in_progress`? And then put a `README.md` file in it explaining that most of the scripts are out-of-date?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873213393:97,validat,validation,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873213393,5,['validat'],"['validate', 'validation']"
Security,"> I agree with these!; > ; > I think `filename` (including the extension) is a good choice. I also agree its convenient to use `dir` and `filename` rather than `filepath`.; > ; > For `JLD2`, we need to ""validate"" the `filename` to ensure that it ends in `jld2`. This is needed because we have to identify the ""prefix"" (the part without the extension) in order to do file splitting. Ah, yes, I forgot about that... So `JLD2` requires that the splitting is done with the `.jld2` extension, correct?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1090353935:203,validat,validate,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1090353935,1,['validat'],['validate']
Security,"> I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. That's where the chicken and egg problem comes from IMO. It's harder to have a mature, friendly user interface without exposing it to users and course-correcting from input. But that's only my personal opinion and that's obviously up for debate. I'll close this issue we apparently aren't ready for what I proposed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601137980:20,validat,validation,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601137980,1,['validat'],['validation']
Security,> I am happy to help fixing this (and other validations) but getting some help from someone who understands the script would be a lot faster. It'd be great to clean this up and I can help; we can zoom or you can ask questions here.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745300875:44,validat,validations,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745300875,1,['validat'],['validations']
Security,> I can adapt `GridFittedImmersedBoundary` for `IncompressibleModel` in a separate PR if that makes sense?. I think a separate PR is best. It's really a research PR since we don't have a recipe so the validation process will probably be more involved. It's not clear what algorithm we should choose for `IncompressibleModel`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-839931448:201,validat,validation,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-839931448,2,['validat'],['validation']
Security,"> I feel that labeling it ""weird"" is a harsh judgement. But I would say that using the word ""oceanic"" to describe software is ""quirky"". If folks prefer ""ocean-flavored"" (also quirky, just more characters), let's switch to that. Being ""flexible"" is probably one of our core philosophies as well so I agree with adding that. Sorry, didn't mean to sound harsh. I just really didn't know what other word to use. Also, @glwagner I don't think we have access to change that description. It probably needs to be someone from Clima.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945841241:446,access,access,446,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945841241,1,['access'],['access']
Security,"> I found that using --check-bounds=yes or running the code on a CPU cannot reproduce the error in the original script posted by me. Interesting --- does that mean that this is not an out-of-bounds issue?. > I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Are the NaNs appearing in the particle coordinates, or in the model velocity fields? The _default_ `NaNChecker` only checks the first entry in the model's prognostic field:. https://github.com/CliMA/Oceananigans.jl/blob/00006c17c2ede7f819e15ae14aabb14ab62a0136/src/Simulations/simulation.jl#L71. https://github.com/CliMA/Oceananigans.jl/blob/00006c17c2ede7f819e15ae14aabb14ab62a0136/src/Models/Models.jl#L163-L169. Note also that by default, the `NaNChecker` is only actuated every 100 iterations. You are free to use a different NaNChecker, however. The balance between the computational cost of checking NaNs / frequency of NaN checking and the cost of a time-step is use-case-specific. Can you clarify why you expect the model to abort itself when NaNs appear? Are you suggesting that we can improve the default NaN checker?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771382783:309,access,access,309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771382783,1,['access'],['access']
Security,> I have created a new validation script called `shallow_jet_topography.jl` that evolves the barotropically unstable jet (like in the shallow water example) but now over a shelflike topography. It can be found in `valiation/shallow_water`. I don't see it; did you push?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1975080077:23,validat,validation,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1975080077,1,['validat'],['validation']
Security,> I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error. That's indicative of a bug yes? This could lead to wrong behavior if the accessed memory does exist but is irrelevant (although I guess it depends whether the value is actually used or not),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751848980:51,access,access,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751848980,2,['access'],"['access', 'accessed']"
Security,"> I like @glwagner 's suggestions.; > ; > One question: if we remove examples can they still reside in tests of somewhere else where people can dig them up if they want to see them or will they disappear?. That's a great question, since there are really two points at stake here and there's more than one way to provide ""examples"" to users. In any case, providing ""assured"" examples required testing. That's perhaps why we're hesitant to advertise the huge amount of code in `validation` as a resource for users. It is a resource, but only if you know what you're doing, because the scripts often go stale and we don't have the mojo to test them all in CI right now. ""Examples"" are scripts that we'd like to offer to users as guaranteed-to-work pieces of code to get them started. Right now, we build all of our examples with `Documenter.jl`. This both tests that the examples work correctly, and also allows users to browse the examples in html (pretty sweet). But currently (and just because we haven't devoted time to cracking the problem) this means we have limited computational resources for examples. But another possible solution is to test examples in CI _without_ piping them through documenter. Those scripts would then be available for viewing on github (and we can link to them in the docs); it's just that we wouldn't get the pretty markdown / images / movies. If we don't use Documenter then we can run these tests like any others, and also test examples for GPU. We currently test just one script this way, namely the stratified couette flow validation test:. https://github.com/CliMA/Oceananigans.jl/blob/e796a5de99e791466ef43ab1ed8628b4c4d62f64/test/test_validation.jl#L13-L27",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462:476,validat,validation,476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062870462,2,['validat'],['validation']
Security,"> I seem to have a problem with the GPU cubed sphere tests; > ; > ```; > ERROR: Out-of-bounds array access.; > ERROR: a exception was thrown during kernel execution.; >   | Run Julia on debug level 2 for device stack traces.; > ```; > ; > When running the tests on tartarus, both normally and with debug level 2, I cannot reproduce the error. We've seen this issue before where sverdrup tests fail but tartarus passes. Can anyone remember where we saw that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115067071:100,access,access,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115067071,1,['access'],['access']
Security,"> I sent a flurry of updates once I had the validation case coded up! It should work now. Wait, what should I do to test that? haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082109978:44,validat,validation,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082109978,1,['validat'],['validation']
Security,"> I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc..; > ; > It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable.; > ; > I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc.; > ; > Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do. I hear ya. @glwagner suggested something interesting which is to leave a discussion open on installing Julia on HPCs where people could post their experiences and help each other. I quite like that idea and if you're willing to open a discussion you can be the first one to benefit from it :). We could you out regarding the troubles you've been having",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978:571,access,access,571,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062500978,2,['access'],['access']
Security,"> I think we should fix this problem first by generalizing the code so that explicit references to grid properties don't appear anywhere (instead we should use functions like all_x_nodes, etc). Changing the name of the grid property can come last (as a purely aesthetic improvement). Interesting consideration. I was gonna take a crack at fixing this in order to expedite my validation of the tilted buoyancy, but I think, given all the talks going on about the grids etc, I'm gonna let that one for you guys to solve. > Ah, I think you using IPython, rather than python, correct? I believe Jupyter notebooks support backslash / latex notation for expressing unicode, but IPython may not. Jupyter uses IPython for it's kernel (by default at least I think), so that ability comes from IPython. In any case, that doesn't work for all unicode characters. Just the ones that python can recognize as valid variable names (which I believe is [every unicode character that represents characters in written languages](https://python-3-for-scientists.readthedocs.io/en/latest/python3_features.html)). So all greek letters can be typed LaTeX style, but subscripts and supercripts can't, along with many other ones that are valid names in Julia. So if nothing is done to ""translate"" these variable names when writing NetCDF files, it's unfortunately going to be hard to deal with Oceananigans output outside of Julia.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799804731:375,validat,validation,375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799804731,1,['validat'],['validation']
Security,"> I tried to create a lat-lon grid that is flat in `z` but got this...; > ; > ```julia; > julia> grid = LatitudeLongitudeGrid(size=(36, 34), longitude = (-180, 180), latitude = (-85, 85), topology = (Bounded, Bounded, Flat)); > ERROR: BoundsError: attempt to access 0-element Vector{Any} at index [1]; > Stacktrace:; > [1] getindex(A::Vector{Any}, i1::Int64); > @ Base ./array.jl:805; > [2] generate_coordinate(FT::Type, topology::Type, N::Int64, H::Int64, coord::Nothing, arch::CPU); > @ Oceananigans.Grids ~/Research/OC.jl/src/Grids/grid_generation.jl:60; > [3] LatitudeLongitudeGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64}, longitude::Tuple{Int64, Int64}, latitude::Tuple{Int64, Int64}, z::Nothing, radius::Float64, topology::Tuple{DataType, DataType, DataType}, precompute_metrics::Bool, halo::Nothing); > @ Oceananigans.Grids ~/Research/OC.jl/src/Grids/latitude_longitude_grid.jl:195; > [4] top-level scope; > @ REPL[5]:1; > [5] top-level scope; > @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; > ```; > ; > @francispoulin, given that 3rd dimension needs to be flat, how were you running the SWE simulations on lat-lon grid?. Hmm, I have done this with help from @simone-silvestri . I'll go look at our example and get back with some details in a bit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143548669:259,access,access,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143548669,1,['access'],['access']
Security,"> I used `validation/mesoscale_turbulence/baroclinic_adjustment.jl` but I reduced the grid size. The big problem of main is the implicit solver, so if you don't use it you see only the difference given by the tracer tendencies, which is smaller. The results above, however, are obtained using exactly the same code you posted (on a mac M1 with one thread though, you use 6, so maybe that is the root cause of the difference). with one thread. ### on `main`; ```Julia; julia> include(""/Users/navid/Desktop/bench_BCI.jl""); [ Info: Running the simulation...; [ Info: Initializing simulation...; [00.00%] i: 0, t: 0 seconds, wall time: 7.775 seconds, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 5.500 minutes; [ Info: ... simulation initialization complete (3.851 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (18.536 seconds).; [01.17%] i: 100, t: 11.193 hours, wall time: 1.978 minutes, max(u): (6.965e-01, 3.325e-01, 3.423e-03) m/s, next Δt: 8.858 minutes; [03.04%] i: 200, t: 1.217 days, wall time: 1.597 minutes, max(u): (5.961e-01, 3.542e-01, 2.452e-03) m/s, next Δt: 14.266 minutes; [06.04%] i: 300, t: 2.415 days, wall time: 1.589 minutes, max(u): (5.953e-01, 2.532e-01, 1.842e-03) m/s, next Δt: 20 minutes; [09.51%] i: 400, t: 3.804 days, wall time: 1.582 minutes, max(u): (5.110e-01, 2.416e-01, 1.716e-03) m/s, next Δt: 20 minutes; ```. ### on v0.79.2 (with KernelAbstractions v0.7.2, CUDAKernels v0.3.3); ```Julia; julia> include(""/Users/navid/Desktop/bench_BCI.jl""); [ Info: Running the simulation...; [ Info: Initializing simulation...; [00.00%] i: 0, t: 0 seconds, wall time: 5.919 seconds, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 5.500 minutes; [ Info: ... simulation initialization complete (1.889 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (35.835 seconds).; [01.17%] i: 100, t: 11.193 hours, wall time: 1.815 minutes, max(u): (6.956e-01, 3.317e-01, 3.438e-03) m/s, next ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1486160028:10,validat,validation,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1486160028,1,['validat'],['validation']
Security,"> I was gonna take a crack at fixing this in order to expedite my validation of the tilted buoyancy, but I think, given all the talks going on about the grids etc, I'm gonna let that one for you guys to solve. I believe my suggestion regarding `default_dimensions` will solve one of the errors encountered in this issue, but I'm not sure about other similar errors.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799808900:66,validat,validation,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799808900,1,['validat'],['validation']
Security,"> I was having a play with preconditioning the CG solver with multigrid and found that I get considerably different results depending on whether I zero the initial guess to the preconditioner (see [here](https://github.com/CliMA/Oceananigans.jl/blob/0aee96a429332a48fc4b6252f450bf8b35137129/validation/elliptic_solvers/preconditioned_poisson_solver.jl)). When the initial guess is all 0s the `precondition!` method is called ~1/3 of the number to times it is called if the given initial guess is used. My understanding is that the initial guess is not specified by the algorithm in fig 2.5 [here](https://www.netlib.org/templates/templates.pdf) so am not sure whether this is a ""correct"" answer here but would like to know why the zeroing gives such a different result. Could it be because solving for a residual equation the answer should be close to all 0s so it is actually a good initial guess?. cc @glwagner",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175794799:291,validat,validation,291,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175794799,1,['validat'],['validation']
Security,"> I wasn't specific about time because I wasn't sure. I often find myself spending way longer on PRs than I initially anticipate so I'm generally not very good at assessing these things lol. ok ok! Here's a rule of thumb: a bugfix or refactor is the least committment, because you can get away with no new tests or docs. A new _feature_ takes more time because of documentation. One should expect to spend most of their time on docs and tests. If you're spending a lot of time implementing a feature, then either the feature is very complicated / hard, or your workflow can use some improvement. Among new features, different types of features require different amount of effort. This case is one of the easier cases --- it's extending functionality without changing existing functionality, also its fairly niche (at this point) so simple documentation will suffice. The work required to test the feature also has already been partially completed (the script you posted). Other features, like adding new _physics_ will take much longer, because often you'll have to run a full validation case + analysis to assess whether things work as expected. So even if the source code change is small to implement new physics, the validation will take a while and dominate the development effort. If a new feature also requires changing existing functionality / refactoring, that's going to take the most amount of time, because you will probably also have to change existing tests. And many tests are poorly written, so updating test code is a potential rabbit hole.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2093480258:1077,validat,validation,1077,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2093480258,4,['validat'],['validation']
Security,"> I've added a test for this in `test_dynamics` but not sure if that's the right place for it, or if we even want a test.; > ; > I haven't tried the test on GPU either so suspect it may fail. I think a validation case would be appropriate. Ideally we would run some kind of convergence test but we don't have capacity for that now I think. The validation case could go here: https://github.com/CliMA/Oceananigans.jl/tree/main/validation/advection",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1493405980:202,validat,validation,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1493405980,3,['validat'],['validation']
Security,"> If I want to test out multi-region nonhydrostatic simulations on a GPU cluster with immersed boundaries, is my best bet to start from [validation/multi_region/multi_region_les.jl](https://github.com/CliMA/Oceananigans.jl/blob/ss/multi-region-nonhydrostatic/validation/multi_region/multi_region_les.jl) in this PR and just add something like; > ; > ```julia; > grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBottom(bump)); > mrg_with_bump = MultiRegionGrid(grid_with_bump, partition=XPartition(2), devices=(0, 1)); > ```; > ; > from the hydrostatic multi-region internal tide validation to include immersed boundaries?; > ; > Like @mmr0, this is pretty much what I've been waiting for to go all in on Oceananigans 100. Yes, that's how I was able to get this working for me. One note is that `grid.Nx` must be even atm. Another note is that so far no `OutputWriter` works with this, so as far as I can tell the functionality here is very limited. @glwagner @simone-silvestri I tried to merge main here but couldn't really figure out the proper way to do it. Could any of you do it? I wanna try to at least get `NetCDFWriter` working so that I can write results with this PR and analyze them!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1367288146:137,validat,validation,137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1367288146,3,['validat'],['validation']
Security,"> If we are going to update this example, it's probably better to use `ImmersedBoundaryGrid` like in the other immersed boundary validation experiments... Good point and I can look into that before this is reviewed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1793#issuecomment-871638633:129,validat,validation,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1793#issuecomment-871638633,1,['validat'],['validation']
Security,"> Indeed, it seems like; > ; > ```; > @inline tank(x, y) = ifelse(radius(x, y) < L, -H, Float64(0.0)); > ```; > ; > clears the problem. Interesting... Do you guys have any idea why that could influence the `fill_halo_bottom`?. If there's a function that can return two possible types (which is inferred to a type `Union` I think) then this might propagate downstream in the compiled code (ie two possible scenarios must be maintained; one when the returned value is `Float64`, and another with different intrinsics for when the returned value is `Int`). I think in principle this can greatly complicate the kernel function for filling the boundary condition. Broadly speaking, for functions that must be inlined into complicated kernels, it's safest to use functions that can only return one type. But I don't have a good answer for why we get the specific error `an illegal memory access was encountered`. This could be a bug in `CUDA.jl`. However, we are using an old version of `CUDA.jl` so there's not much point in raising an issue. The behavior very well may be different in the latest version... Someone with deeper knowledge of the Julia compiler / compilation system might have a better answer too...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084049440:882,access,access,882,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367#issuecomment-1084049440,2,['access'],['access']
Security,"> Is the vertical velocity generated over the piecewise constant topogrpahy something that is of a concern? When I increased the resolution I believe I saw the vertical velocity generated increased as well. I agree with @glwagner that it's concerning at least for your current configuration. My guess is that with bottom drag and a more turbulent simulation that might not be a huge problem. But as it stands it's definitely affecting the dynamics. (Btw, I say that because I've run a fair amount of turbulent simulations with immersed boundaries at this point and I've never seen this being an issue in my simulations. But they are always turbulent.). > I think so! Is this with GridFittedBottom or PartialCellBottom? I feel like this motivated cut / shaved cells. @glwagner reading the code [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take1.jl) it seems that it's a `GridFittedBottom`. @francispoulin Like Greg mentioned, shaved cells would be ideal here, but since we don't have that yet, I'd suggest trying out the `PartialCellBottom`. I expect some improvement there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3526#issuecomment-2028920617:878,validat,validation,878,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3526#issuecomment-2028920617,1,['validat'],['validation']
Security,"> Is there any syntax change need to be made in; > ; > https://github.com/CliMA/Oceananigans.jl/blob/jsw/different-velocities/validation/lagrangian_particles/particles_in_convection.jl; > ; > I'm actually thinking now that if the name of the module didn't change, moving the module from `LagrangianParticleTracking` to `Models.LagrangianParticleTracking` might not imply any syntax change _given_ that the module name is exported.; > ; > @glwagner?. Does it run?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1533815468:126,validat,validation,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1533815468,1,['validat'],['validation']
Security,"> Is there ongoing work there? I thought all ongoing work was supposed to be confined to PRs. That's what I've been doing. Sometimes work spans multiple PRs, such as implementing a CubedSphere abstraction, or immersed boundaries. The validation experiments are being used to validate incremental advances in these features. The problem is not that the scripts aren't ready for users, but that the scripts grow stale as the API changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873253514:234,validat,validation,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873253514,2,['validat'],"['validate', 'validation']"
Security,"> It is what the right panel shows, if I am not mistaken. But the simulation crashed after thousands of iterations. I heard that the PCG solver in Oceananigans has not been widely tested, so that is why I turned to the HeptadiagonalIterativeSolver. Both of those solvers actually use the preconditioned conjugate gradient method. It's also not true --- the `PreconditionedConjugateGradientSolver` has been validated. I'm not even sure it's possible to use the FFT-based preconditioner with the heptadiagonal solver, they have different interfaces. Maybe you worked on that. It's not obvious how to generalize the `HeptadiagonalIterativeSolver` to support `Distributed` architecture, and its also likely more difficult to optimize for immersed boundary methods using an active cells map. We shouldn't waste our time with the `HeptadiagonalIterativeSolver`. If the `PreconditionedConjugateGradientSolver` has issues, we should fix them. It's a waste of energy to work on both.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071221835:406,validat,validated,406,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071221835,1,['validat'],['validated']
Security,"> It might be helpful to have a simpler interface for advection in biogeochemical models. Although a user could just add another forcing, I think the only way for a model to automatically add an advective forcing is how I've implimented it in the below example. I Think this works quite well since a lot of BGC models write the sinking terms with the other forcing terms, but its a little cumbersome to write e.g. sinking = div_Uc(i, j, k, grid, bgc.adv_scheme, bgc.u⃗ᵖ, fields.P), and model makers will need to do the setup stuff I've done to make the advective velocity fields. Can't we add advective terms via the biogeochemical forcing term?. edit: I see you mentioned that, so I might be missing something... I'll take a look at your examples. PS we should add those scripts to `validation/biogeochemistry/`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310890224:784,validat,validation,784,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310890224,2,['validat'],['validation']
Security,"> It's coming from the hydrostatic pressure integral. Does CATKE modify the hydrostatic pressure integral? Seeing that made me think that it wasn't the integral and that the illegal memory access happened elsewhere but was ""caught"" in the hydrostatic pressure integral kernel. Not sure if it'll be useful but I'll try prodding around the `model` to see if there's a `Float64` somewhere as a hint. > but you can confirm that it doesn't happen with `closure=nothing`?. I can confirm that this MWE works and does not produce an error:. ```julia; using Oceananigans; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = LatitudeLongitudeGrid(; GPU(),; Float32,; topology = (Bounded, Bounded, Bounded),; size = (16, 16, 16),; longitude = (0, 1),; latitude = (0, 1),; z = (-100, 0); ). model = HydrostaticFreeSurfaceModel(;; grid,; buoyancy = BuoyancyTracer(),; tracers = (:b, :e),; closure = nothing; ); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2439675501:189,access,access,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2439675501,1,['access'],['access']
Security,"> It's harder to have a mature, friendly user interface without exposing it to users and course-correcting from input. The process of setting up a validation test involves interacting with the interface as a user. So requiring a validation test _does_ expose an interface to users.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203:147,validat,validation,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601176203,3,"['expose', 'validat']","['expose', 'validation']"
Security,"> It's just a small detail...; > ; > if you had an `ImmersedBoundary` on the `GPU` and wanted to move it on the `CPU` (in case the immersed boundary was an abstractarray) the `immersed_boundary` would remain a `CuArray` even after calling `on_architecture(CPU(), ibg)`.; > ; > This was a small bug which never really affected us (you never really need to shift a grid from the `GPU` to the `CPU` in practice and most of the time that bottom is a function, not an array). On the other hand I needed this because when I do a `MultiRegionGrid` of a `ImmersedBoundary` and split the `bottom` in different `GPU`s, I need to pass that bottom correctly to the `CPU` otherwise we have `CUDA illegal access` problems (i.e. you cannot just split an array from one GPU to others without taking care of it adequately); > ; > So I was getting an error related to this when I wanted to split a simulation with ""realistic"" bathymetry onto 2 GPUs. Makes sense. Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2394#issuecomment-1084722001:691,access,access,691,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2394#issuecomment-1084722001,1,['access'],['access']
Security,"> It's ready @navidcy; > ; > @francispoulin right, that's why it's so hard to understand the problem. It only fails intermittently.; > ; > We have some validation of the shallow water model in the example. I propose that in order to move forward, we should generate a few additional validation tests including some with bathymetry. Once we have those and have analyzed them to ensure we are satisfied with the dynamics, we should then work on designing a better regression test --- one that won't ""pass"" when it should not. Then we can add that better regression test to our test suite, and remove the warning from the shallow water model constructor.; > ; > Probably best to also resolve the issue with the pressure gradient in presence of bathymetry. Maybe a topographic Rossby wave or some such would help build confidence that we are treating non-uniform bathymetry correctly with both of the formulations that we have. Thanks for the explanation. I agree that looking at a topographic Rossby wave is a good test to have. In the case of a small linear slope and small amplitude wave, it should be close to an exact solution so that will be easy. If we want more challenging tests, there are no shortage of those. Lots of tests have shocks and people like to test those but I would suggest avoiding those, as shocks mean the aspect ratio is order one or larger, and that violates the underyling hydrostatic assumption in the model. We could take the Bicklet jet example we have and put it over topography and compute the growth rates. There is a Poulin and Flierl (2005) in JPO that studies that and it would be easy enough to put to get linear stability code to compute the growth rates. That way we also have some theory to support the code. Also, we could look at a wind-driven gyre problem with and without topography. Not a simple test but would help to validate the global simulations that @simone-silvestri did a while ago with the shallow water model. Lots we can do!. I don't remember the ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1498158496:152,validat,validation,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1498158496,4,['validat'],['validation']
Security,"> It's something to do with GPU, maybe GPU reductions?; > ; > ```; > [2023/05/24 21:41:15.102] INFO Testing grid utils on variably spaced grid....; > --; >   | Grid initialization: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_grids.jl:199; >   | Expression: minimum_xspacing(grid) ≈ FT(π / 3); >   | Evaluated: 0.0 ≈ 1.0471975511965976; > ```. I see this error. But I can't reproduce it. On tartarus it's not happening and I don't have access to Svedrup. So I don't know what to do... :(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1566845080:508,access,access,508,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1566845080,1,['access'],['access']
Security,"> Luckily, I found a reliable way to get NaNs immediately is to set both reltol and abstol to zero and maxiter to more than a thousand. The purpose is to test the numerical stability of the iteration method. I think this makes sense. When the residual is reduced to near machine precision then I think this is when the present instability is exposed, which occurs when the search direction is essentially a constant. I wonder if its possible that the instability was observed in the original simulations when, for some random reason of the flow configuration, the CG solution converged especially fast (thereby exposing the instability).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2420734546:342,expose,exposed,342,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2420734546,1,['expose'],['exposed']
Security,"> Maybe (for debugging purposes) a function, which reverses the hash, i.e. given the tag spits out the inputs can be usefull. Yes but since the object I'm suggesting is even smaller in memory than an integer (almost 0 in size except for `field_id` and possibly `z_indices`), why would you skip the intermediate abstraction? You're thinking that an integer is ""simple"" but its not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2298991416:64,hash,hash,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2298991416,2,['hash'],['hash']
Security,"> My concern with associating it with the simulation was that, unless we pass the simulation to `time_step!` as well, the callback can't access it which might be confusing since normal callbacks are `func(sim)`. So I thought it may be clearer if callbacks associated with the model were `func(model)` instead. Not sure what the best solution is though?. Ah, I see your point and it's a good one! Let's see if anyone else has thoughts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271755659:137,access,access,137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271755659,2,['access'],['access']
Security,"> Next week I will work on getting higher order methods working for ShallowWaterModels. That would be awesome!. Does it also make sense to work on producing some validation tests for `ShallowWaterModel` for a next PR? While we can test that operators are implemented correctly in isolation, we won't understand whether everything is integrated into `ShallowWaterModel` until we have some dynamics tests and larger validation runs that reproduce results in the literature, right? Or do we need these higher-order operators to use `ShallowWaterModel` at all?. To validate the generic implementation of higher-order operators, I think we can implement high-order diffusion and reuse some of the convergence validation tests for `IncompressibleModel`, like the forced flow fixed slip test. When `ShallowWaterModel` has similar validation tests we can also do the same for `ShallowWaterModel`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928:162,validat,validation,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-744016928,5,['validat'],"['validate', 'validation']"
Security,"> Nice find! Fix makes sense to me so I'm approving.; > ; > If it's non-trivial to design a good test for these open boundary conditions, then to me it make sense to merge this obvious fix and discuss how to more thoroughly test in a separate issue or PR. I think creating a test is non-trivial, but modifying the existing validation script to be more expansive is trivial since I pretty much have the code ready. Should I just do that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3854#issuecomment-2430095333:323,validat,validation,323,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3854#issuecomment-2430095333,1,['validat'],['validation']
Security,"> Nope, that is without the halo (with_halo=False), when using with_halo=true the indexes passed are (Colon(), Colon(), Colon()) so there is no issue accessing the indexes of the output. Sorry, I meant `with_halo=false`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2018362902:150,access,accessing,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2018362902,1,['access'],['accessing']
Security,"> Not sure what ""squash and merge"" means . Ah it's one of the three merge options, e.g. ![image](https://user-images.githubusercontent.com/20099589/117980914-70e08180-b302-11eb-9179-9e8cbad457a3.png). where it combines all the commits into one commit then merges. Then intermediate changes (like a file that was created then deleted) do not enter git history. > I deleted the file locally and then wanted to push the change but couldn't. If someone can tell me how to delete it I'm happy to do it. That should be all it takes... What error does git produce? I can also try locally. > Also, I see that the tests pass so my use of `Polynomials` presumably worked?. Ah I don't think `plot_rates_convergence_advection.jl` is actually run as part of CI right now. We could add it in this PR if you're interested. I think we'd want to actually add it to the validation pipeline (not the main pipeline) so we would add a new test set in https://github.com/CliMA/Oceananigans.jl/blob/master/test/test_convergence.jl and add a new build step in https://github.com/CliMA/Oceananigans.jl/blob/master/.buildkite/validation-pipeline.yml then it would show up in these builds with plots, e.g.: https://buildkite.com/clima/oceananigans-validation-experiments/builds/208. > Anything else that people would like done before someone approves this PR?. I think it looks good to merge, just without the extra image file!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1650#issuecomment-839764128:852,validat,validation,852,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1650#issuecomment-839764128,3,['validat'],"['validation', 'validation-experiments', 'validation-pipeline']"
Security,> Note to self: we should figure out an interface to help users access grid metrics. We shouldn't write things like `grid.Δxᵃᵃᶜ` in the examples. Yes yes yes!. Can we have alias?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967726417:64,access,access,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967726417,1,['access'],['access']
Security,"> OK, perhaps I'm a bit oblivious to physics of tilted gravity etc. Are is the tilted gravity crucially important for this to occur?. Apparently yes. This doesn't happen when the buoyancy acceleration is aligned with the model's z-coordinate. > Also, is there an energy integral associated with these dynamics when there is a fixed imposed buoyancy? Even in the continuous case, before we go to discrete world, is there guarantee that E should decrease?. That's a good point and as far as I can tell this system should have a a finite, non-increasing total energy since the background buoyancy is stable. So the background buoyancy shouldn't be introducing any extra energy reservoirs (unlike, for example, an Eady set-up, which constantly injects energy into the system by imposing a horizontal buoyancy gradient). My understanding of this comes mainly from [Umlauf et al (2015)](https://journals.ametsoc.org/configurable/content/journals$002fphoc$002f45$002f12$002fjpo-d-15-0041.1.xml?t:ac=journals%24002fphoc%24002f45%24002f12%24002fjpo-d-15-0041.1.xml). Their equation (24) applied to the set-up above (i.e. without any boundary stresses and without applying a Reynolds decomposition) reads. ```math; \frac{d}{dt}\int_V \left[ \frac{u_i u_i}{2} + \frac{b^2}{2N^2} \right] dV = ; - \int_V \left[ ; \kappa \frac{\partial_j b \partial_j b}{N^2} ; + \nu {\partial_j u_i \partial_j u_i}; \right] dV \le 0; ```. Also it's worth noting that even in a `(Bounded, Flat, Bounded)` domain I still get an energy buildup, although in this case the KE stops growing after a while:. https://user-images.githubusercontent.com/13205162/228590310-51b59910-2550-48c9-93a7-f22d70c2474e.mp4. I say that because this may be a more familiar set-up and because sometimes a tilted, periodic domain might introduce some unexpected effects.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1488852882:740,inject,injects,740,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1488852882,1,['inject'],['injects']
Security,"> Okay finally tests passed!; > ; > @navidcy I tried restarting the tests over and over (honestly more than 10 times over the past few days) and they always failed. I could only make them pass this morning when I restarted them one at a time. That is, starting one, and only restarting the next failed test when the previous one had fully run.; > ; > So maybe the variability we see in tests has to do with different processes trying to access the same resources... ?. Yes it is a race condition",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2223710307:437,access,access,437,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2223710307,1,['access'],['access']
Security,"> Pardon if this question is naive but why is it important that users to exposed to the Field infrastructure?. Because that way they are prepared to do sophisticated post-processing! But I think you're right, maybe it's not a real ""downside"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036942707:73,expose,exposed,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036942707,1,['expose'],['exposed']
Security,"> Relative vorticity plot from before (with non-essential halos) ![vorticity](https://user-images.githubusercontent.com/12926768/276471090-687faff4-f50d-492e-a024-1e67c4e24da0.png); > ; > Relative vorticity plot now (with non-essential halos filled with NaNs) ![vorticity](https://user-images.githubusercontent.com/12926768/276471138-aa5fac3f-b948-429c-a3e1-4f33a75bd0f4.png); > ; > At least the south-east corners of the odd panels are incorrect. Based on discussion with @navidcy, I overwrote the vorticity computation at the corners of all panels using only interior values in the validation script validation/multi_region/cubed_sphere_vorticity.jl. The vorticity field looks better now. However, the source code still needs to be fixed. . ![vorticity](https://github.com/CliMA/Oceananigans.jl/assets/12926768/2f8a203f-08f4-4541-9022-388b58fcbd50)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1780283208:584,validat,validation,584,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1780283208,2,['validat'],['validation']
Security,"> Should we include the Stommel gyre? It seems there are simpler flow fields for an advection validation test (eg sin x sin y). How are we going to evaluate the thermal bubble validation? ""Not blowing up"" is pretty good, but I think we have decide that validation tests should be quantitative. Qualitative validation experiments can perhaps be put in `examples/`?. Yeah they're both ""temporary"" verification experiments that might be useful in the near future as we test advection schemes. Periodic advection is also a qualitative verification experiment. I think we should keep at least one interesting 2D advection verification to produce movies showing how different advection schemes behave. Hopefully we could embed all the movies in the docs so users can browse through them. I was thinking the Stommel gyre could be a good one (really I stole the idea from Glenn's animations) as the velocity does not go to zero at the western boundary/wall.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-699530922:94,validat,validation,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592#issuecomment-699530922,4,['validat'],['validation']
Security,"> Should we limit this discussion to the names of locations and grid spacings? The issue currently only refers to ""more bugs"" which could be a bit too open-ended to make useful progress on. That's a good point, and I apologize for being too general with the title. I still would like to solve that specific bug relatively soon since I want to validate the tilted buoyancy on a tilted bottom boundary layer soon. Should I create a separate issue for that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799796801:343,validat,validate,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799796801,1,['validat'],['validate']
Security,"> So I tried with SplitExplicit and 1) it's _much faster_ but 2) I see this very fast motion in the beginning...; > ; > Compare this; > ; > barotropic_tide_splitexplicit.mp4 ; > with the animation at the top of this PR.; > ; > I suppose it's the gravity waves... Are they implicitly filtered out with the implicit free surface solver at the top?. Yeah, the implicit solver diffuses out all the gravity waves while the split explicit ""resolves"" them. You can also check out the validation case in `validation/implicit_free_surface/geostrophic_adjustment_test.jl` that shows quite some difference in the dynamics using the implicit solver vs split explicit solver",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1575763281:477,validat,validation,477,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1575763281,2,['validat'],['validation']
Security,"> So far what we have only tested the case when there is buoyancy with no motion. It would be nice to have a problem with non-zero velocities work. Agreed. I most likely will be using IBMs starting now so I probably will be testing IBMs on a variety of settings. > I see there is this script [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) that we could play with but it does not seem like a minimal working example. Do you know of a simple script that looks at flow over a bump we could look at?. I don't have anything ready but that script looks pretty good to me. We just need to tweak it a bit? What would be the goal here as a validation script?. > @glwagner also suggested we test this with lat-lon grids and create tests. I think that should be the case for lat-lon and rectilinear grids, no? At the moment I think we're kinda limited with IBM tests:. ```; ~/repos/Oceananigans.jl/test $ grep -r ""\<Immersed"" * ; test_boundary_conditions_integration.jl: immersed_rectilinear_grid(topology) = ImmersedBoundaryGrid(RectilinearGrid(arch; topology, z=(-Lz, Lz), grid_kw...), ib); test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: if grid isa ImmersedBoundaryGrid && side == :bottom; test_boundary_conditions_integration.jl: # Omit ImmersedBoundaryGrid from vertically-periodic test; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; test_conditional_reductions.jl:using Oceananigans.ImmersedBoundaries: conditional_length; test_conditional_reductions.jl: @info "" Testing Reductions on Immersed fields""; test_conditional_reductions.jl: ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary((x, y, z) -> (x < 0.5))); test_dynamics.jl:using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, GridFittedBottom, mask_immersed_field!; test_dynamics.jl: grid = ImmersedBounda",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199:350,validat,validation,350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1126367199,4,['validat'],['validation']
Security,"> So it seems that execution does not have to hit the @warn for the reported failure. Also the stack trace indicates that the error happens when the macro is expanded. Precisely. > And maybe convenience interface for people who want to ignore it. That's a more robust interface for other reasons as well. Perhaps a positional argument to `lambertw`, either boolean or perhaps even better a type (to use multiple dispatch) to control behavior, things like. * `WarnFailures()` (throw warning for failures); * `MarkFailures(value=NaN)` (mark failures with a specific value, do not throw warning); * `IgnoreFailures()` ?; * `WithSolverInfo()` (return a type that contains the root, boolean `converged`, and possibly also number of iterations). > It would be nice if there were a way to redirect io or send it to dev null or otherwise disable everywhere when running on a GPU. It is interesting to consider auto-sanitization of GPU code...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1911517451:907,sanitiz,sanitization,907,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1911517451,1,['sanitiz'],['sanitization']
Security,"> Some of the validations are failing...?; > ; > What previously gave; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); > ERROR: ArgumentError: Must supply extent or x keyword when x-direction is Periodic; > Stacktrace:; > [1] validate_dimension_specification(T::Type, ξ::Nothing, dir::Symbol, N::Int64, FT::Type); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:70; > [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:98; > [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:293; > [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:268; > [5] top-level scope; > @ REPL[3]:1; > ```; > ; > now it goes through:; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); > 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [1.0, 1.0) variably spaced with min(Δx)=0.0, max(Δx)=0.0; > ├── Periodic y ∈ [1.0, 1.0) variably spaced with min(Δy)=0.0, max(Δy)=0.0; > └── Bounded z ∈ [-3.14159, 3.14159] regularly spaced with Δz=0.392699; > ```; > ; > Note that it creates an x and y coord `[1.0, 1.0)`!. I think I fixed it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762146968:14,validat,validations,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762146968,1,['validat'],['validations']
Security,"> Something is not right again.; > ; > There is a method `validate_closure`; seems like that's the place to put the error message?; > ; > My argument is just based on intuition from the method's name. This error seems part of the validation, right?. True, this would work for `NonhydrostaticModel`. https://github.com/CliMA/Oceananigans.jl/blob/b121003ef43e04d5792c6f0ca13cccc05f3d9385/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L168. but we have to make some changes to make this work for `HydrostaticFreeSurfaceModel` because `with_tracers` is called first. https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl#L163-L166. so either we need to call `validate_closure` first, or we need to put in a fallback for `with_tracers`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2327079994:230,validat,validation,230,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2327079994,2,['validat'],['validation']
Security,"> Sorry @glwagner Maybe I didn't express very well. I don't see any problem in split files and understand the importance in having that. What I meant is that we could access the rank id from Distributed output to use it on the output filename so that we don't need to explicitly import MPI. I was responding to @simone-silvestri !. In terms of user scripts, I certainly do think it's better to access the `rank_id` from the architecture. I think it's easier to read too, and it allows user scripts to depend on one fewer package. However, I think that the output writers should automatically change the filename when the simulation is distributed. This should be pretty easy and just involves adding the suffix `_rank$(rank_id)` to the filename for distributed architectures. We should also have an API for callbacks that are intended to only run on one rank (for example for printing stuff); eg a property `on_rank=0` which is used when `arch isa Distributed`. There's probably other useful things. `FieldTimeSeries` will have to be modified so that it can combine distributed files, for example. Probably, distributed output should also save some kind of ""meta"" file that contains information about the processor layout, to be used by `FieldTimeSeries`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896501329:167,access,access,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1896501329,2,['access'],['access']
Security,> Sorry validation pipeline was accidently triggered so I canceled it. Fixed it so shouldn't happen in the future. Does that mean it will retry the tests?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1325#issuecomment-769911007:8,validat,validation,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1325#issuecomment-769911007,1,['validat'],['validation']
Security,"> Sounds good to update the code! Perhaps we should also add a warning or note of some kind about the lack of validation (we've taken to doing this recently and I think it's a good thing).; > ; > @navidcy would be happy not to use `ς`!; > ; > `\Upsilon` is disturbingly similar to ""Y"":; > ; > ```julia; > julia> Υ = 1; > 1; > ```; > ; > maybe there's a better choice? We could also change the docs. Yeah, and I ended up realizing the same thing. I changed the docs instead.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889257253:110,validat,validation,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889257253,1,['validat'],['validation']
Security,"> Still the unit tests don't pass; something else is broken. Seems like some other validation is bypassed?; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size = (16, 16, 16), x = 1, y = 2, z = 3); > ERROR: MethodError: no method matching get_face_node(::Int64, ::Int64); > ; > Closest candidates are:; > get_face_node(::Function, ::Any); > @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:12; > get_face_node(::AbstractVector, ::Any); > @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:13; > get_face_node(::Nothing, ::Any); > @ Oceananigans ~/Research/OC5.jl/src/Grids/grid_generation.jl:11; > ; > Stacktrace:; > [1] generate_coordinate(FT::Type, topo::Periodic, N::Int64, H::Int64, node_generator::Int64, dir::Symbol, arch::CPU); > @ Oceananigans.Grids ~/Research/OC5.jl/src/Grids/grid_generation.jl:39; > [2] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Int64, y::Int64, z::Int64, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); > @ Oceananigans.Grids ~/Research/OC5.jl/src/Grids/rectilinear_grid.jl:273; > [3] top-level scope; > @ REPL[4]:1; > ```. I wanted to make it so that grid generators don't have to subtype functions. However, that doesn't support the kind of error checking that you're mentioning. I guess I'll go back to explicitly requiring somethign to be subtyped `Function`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762248344:83,validat,validation,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762248344,1,['validat'],['validation']
Security,"> Test nonlinear advection for 2D/3D schemes. You mean, validate 2D/3D high-order momentum advection for flux form schemes?. Another issue with a vortex solution is that the momentum term is identically zero in the exact solution. So I'm not sure this test isolates convergence. I believe inviscid Burgers will form a shock, and then be subject to numerical dissipation. If you add viscosity, then you are limited by the accuracy of the viscous term. So I'm not sure it even works to turn off the pressure gradient.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172727554:56,validat,validate,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172727554,1,['validat'],['validate']
Security,> Testing with validation/mesoscale/baroclinic_adjustment.jl seems to indicate that the race condition is eliminated from the changes to the fill_halo_region! function. Was there a race condition there?. Could you please point to the relevant issue describing the condition just for completeness?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920113136:15,validat,validation,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920113136,1,['validat'],['validation']
Security,"> Thanks @glwagner .; > ; > Yes, I am trying to get the same winds that the hydrostatic model uses. This used to be done on Oceananigans but now done in ClimaOcean.jl. However, that doesn't work either as the data has been removed.; > ; > I don't think this is essential to store here, but if we can find another way to access realistic winds that would certainly help me and others that are trying to use realistic winds. I have not used JRA-55 before but h appy to use that. If anyone has any sample scripts that they use in the hydrostatic model, I would be happy to see that and learna how to do the same. Ok but there is no ""one"" hydrostatic model. Also note that you are prescribing fluxes here, not wind. These are different because bulk formula typically use relative winds, and also because momentum fluxes depend on buoyancy fluxes. Can you state more clearly what you would like to do? It sounds like you want to run two simulations --- one hydrostatic, and one shallow water, which are forced similarly. Is that right? We have to set both of those up then.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2181263938:320,access,access,320,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2181263938,2,['access'],['access']
Security,"> That's true, such code has to be compiled away. However, the method that `forcing` uses is a little fragile and often fails to compile. We've just failed to come up with a better way for users to specify arbitrary forcings. But presumably you are doing something else, because otherwise your users could use `forcing`. That's why I'm asking: what outcome are you trying to achieve? Maybe we can come up with another design. Ah, I see. The problem is occurring where I've got this `update_state` for changing the negative tracers (as discussed in ). The code is currently:; https://github.com/OceanBioME/OceanBioME.jl/blob/ac8419a1ce5a06a82be31588583636b212c09598/src/Utils/negative_tracers.jl#L87-L118; But this doesn't work on GPU. The list of symbols is needed so that the group that the total is conserved in can be defined. An alternative I've thought of but not tested yet is to have functions like `conserved_tracers(bgc)` which can just return the list of symbols instead. . I currently can't access a GPU but will see if this works when I can. I'm sure I can find an alternative way todo this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1717609513:1002,access,access,1002,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1717609513,1,['access'],['access']
Security,"> The GPU validation should be identical. You just need to; > ; > 1. Make sure you have enough gpus and the MPI installation is cuda-aware (MPI.has_cuda() == true); > 2. Switch CPU to GPU in the script.; > ; > The rest of the script does not change. We still need actual, explicit code. That way you don't have to make this comment ""it doesn't change"" every time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-2088554792:10,validat,validation,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-2088554792,1,['validat'],['validation']
Security,"> The main downside I think is that the validation repo goes stale by design. Wouldn't JuliaRegistrator keep this from happening? ; If we list Oceananigans as a dependence, it'll create a new PR with the an updated version of Oceananigans everytime we update Oceananigans.jl, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1634#issuecomment-832153423:40,validat,validation,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1634#issuecomment-832153423,1,['validat'],['validation']
Security,"> There is also already a 1D validation test for the immersed boundary --- I wonder if it also shows this bug:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/master/validation/immersed_boundaries/immersed_hydrostatic_diffusion.jl. @glwagner I'm not sure. I tried running it, but got an method error on the `HydrostaticFreeSurfaceModel`: _FreeSurface( ...) is ambiguous_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900444098:29,validat,validation,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900444098,2,['validat'],['validation']
Security,"> There is definitely a wrong assumption somewhere in this pipeline.; > ; > Maybe we can focus on this:; > ; > > since it try to access the indexes (4:8, 4:8, 4:5) rather than (4:8, 4:8, 1:0). I had a typo here, the indexes that it tries to access are `(4:8, 4:8, 4:8)` as if the field was 3D (See the error below). > ; > First of all I think this means that we are using `with_halo=true`? Just want to confirm that. Nope, that is without the halo (`with_halo=False`), when using `with_halo=true` the indexes passed are `(Colon(), Colon(), Colon())` so there is no issue accessing the indexes of the `output`.; ; > Second there is a typo right @josuemtzmo ? You meant to say that the indices should be `(4:8, 4:8, 1:1)`?. When I print the indexes I get `(4:8, 4:8, 1:0)` but I agree that there is something strange, since I also expected what you said `(4:8, 4:8, 1:1)`.; ; > This is maybe where the incorrect assumption is. If we need `(4:8, 4:8, 1:1)`, then we are looking for the indices of the underlying _view_ --- but not the indices of the Field. Because, the indices of `eta` are definitely `(4:8, 4:8, 4:5)`. That's the whole point of the windowed fields abstraction is to be able to properly locate a field in the 3D index space. `eta` is the free surface, so it's indices are at the top of the domain. That's likely the case, since it seems that we are accessing the indexes of the __view__. For example, doing `eta.indices` I get `(Colon(), Colon(), 5:5)`. However, the only way I manage to make work `Field(eta, indices = indices)` is using `indices = (4:8,4:8,-2)`. I think the reason it only works by pass a `-2` (`z` index) results from the fact that the view uses `-2+3`, where 3 is the size of the halo. I've confirmed that changing the halo in the `RectilinearGrid`, changes the value of the (`z` index) to pass to access the `Field`. ```; julia> Field(eta, indices = (1:5,1:5,-2)); 5×5×1 Field{Center, Center, Face} on RectilinearGrid on CPU; ├── grid: 5×5×4 RectilinearGrid{Float6",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:129,access,access,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658,3,['access'],"['access', 'accessing']"
Security,> There is one that does a one-level near global ocean on a latitude-longitude grid. (in the near_global validation folder); > I haven't tried this particular script before. but that's not shallow water...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2985#issuecomment-1475428867:105,validat,validation,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2985#issuecomment-1475428867,1,['validat'],['validation']
Security,"> This came up on #2235.; > ; > The idea is to support syntax like; > ; > ```julia; > outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); > output_writer = JLD2OutputWriter(model, outputs, ... ); > ```; > ; > rather than requiring things to be wrapped in `Field` to work. I think this is certainly more intuitive for users!. > This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases.; > ; > I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though. Pardon if this question is naive but why is it important that users to exposed to the `Field` infrastructure?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103:691,expose,exposed,691,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242#issuecomment-1036800103,4,['expose'],['exposed']
Security,"> This is great! Have you started a PR already to support Sparse in AMDGPU proper?. @vchuravy yes here's the PR: https://github.com/JuliaGPU/AMDGPU.jl/pull/298. We're stuck for some time since we're getting some timing issues on a couple of tests; We get incorrect results depending on the timing of the operations. Even after adding synchronization after each operation, the error still persists. Other than that they seem to work fine. @jpsamaroo can update you on that. > So this PR is to merge something on an Oceananigans.jl branch, `amdgpu`. It modifies 482 files?!; > The `amdgpu` branch is waaay outdated so as a first step perhaps we need to bring that branch up to date? I'm wondering if the seemingly proposed changes to 482 files would be much reduced if we bring `amdgpu` up to date with `main`?. @navidcy @simone-silvestri I don't have write access to this branch so you can update the branch first before reviewing the PR. This work is not yet ready to be merged yet to the main branch so we decided in the past that this might be the place for it while we test it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1448414562:856,access,access,856,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1448414562,1,['access'],['access']
Security,"> This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?. This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088676711:402,access,access,402,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088676711,2,['access'],['access']
Security,"> Unfortunately I think we have to limit access to that to Clima folks, but it affects all Clima software (not just Oceananigans). As an example, none of us have permissions to add people to the buildkite. No worries makes sense!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3441#issuecomment-1911783084:41,access,access,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3441#issuecomment-1911783084,1,['access'],['access']
Security,"> We are in the process of implementing curvilinear grids, which require more specificity for the location of grid lengths, areas, and volumes. As a result we are attempting to standardize our notation, using three-letter codes to be completely explicit. These changes have been made in the vertically stretched grid and regular lat-lon grid, but not in the regular rectilinear grid yet. Would just a change from `xC` to `xᶜᵃᵃ` and so on in Regular grids do it?. Also, we need to be careful if the notation with superscripts are the default when writing to NetCDF. These ""uncommon"" unicode characters aren't very easy to access from a lot (most?) of programming languages. As an example, here's me trying to access an attribute named `u₀` using `xarray` in Python:. ```python; In [91]: vid.attrs; Out[91]: ; {'N2_inf': 4e-05,; 'f0': 0.0001,; 'σy': 1600,; 'z_0': -250.0,; 'u₀': -0.4,; 'N2_pyc': 4e-05,; 'schedule': 'TimeInterval',; 'name': 'CIintjet01',; 'interval': 5400.0,; 'Lz': 500,; 'Julia': 'This file was generated using Julia Version 1.5.2\nCommit 539f3ce (2020-09-23 23:17 UTC)\nPlatform Info:\n OS: Linux (x86_64-pc-linux-gnu)\n CPU: Intel(R) Xeon(R) Gold 6140 CPU @ 2.30GHz\n WORD_SIZE: 64\n LIBM: libopenlibm\n LLVM: libLLVM-9.0.1 (ORCJIT, skylake-avx512)\n GPU: Tesla V100-SXM2-32GB\n',; 'output time interval': 'Output was saved every 1.500 hours.',; 'T_inertial': 62831.85307179586,; 'σz': 80,; 'u_0': -0.4,; 'Nz': 512,; 'z₀': -250.0,; 'LES': 0,; 'Ny': 8192,; 'date': 'This file was generated on 2021-03-08T15:14:07.533.',; 'Ly': 15000,; 'b0': -4e-05,; 'y₀': 5000.0,; 'Oceananigans': 'This file was generated using Oceananigans v0.52.1',; 'y_0': 5000.0}. In [92]: vid.u₀; File ""<ipython-input-92-9d34f4e5eca9>"", line 1; vid.u₀; ^; SyntaxError: invalid character '₀' (U+2080). In [93]: vid.attrs[""u₀""]; Out[93]: -0.4; ```. So as you can see it's possible, but it definitely takes some extra effort (especially since you can't type `u₀` in Python and need to copy paste from somewhere else",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799798339:621,access,access,621,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799798339,2,['access'],['access']
Security,> We can delete this validation test too after this: https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/internal_tide.jl. The validation script includes a multi region example. Shall I still delete it?; I could also clean it up and add toml files in the validation script directory (see #3076).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1577433799:21,validat,validation,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1577433799,4,['validat'],['validation']
Security,> We might not. Where is interpolate used?. Its not used anywhere in the source code but in quite a few validation scripts,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370810049:104,validat,validation,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370810049,1,['validat'],['validation']
Security,"> What is the type of `tke_k`? With one exception it seems like there's an issue with two or more fields. Sorry, should have made it more clear. It's calculated with a `KernelComputedField`.; ; > I think it should access that condition `M * N` times, where `M` is the number of outputs being averaged. Okay, then I guess that part is fine.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873158382:214,access,access,214,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873158382,2,['access'],['access']
Security,"> Why don't you implement `DynamicSmagorinsky` and abstract the notion of the `Averaging` to `LagrangianAveraging` and `DirectionalAveraging`.; > ; > Note, you should expect to spend your time validating the closures by running simulations --- not software design and abstraction. If you're having difficulties with the software design I can help. I like this idea!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2190185027:193,validat,validating,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2190185027,1,['validat'],['validating']
Security,"> Yeah we don't use it here. I could add a simple choice e.g. boundary `value = (external state-internal state)/relaxing` time as an example?. Right. The validation is interesting. It shows that the code currently supports open boundaries. Presumably, the algorithms / matching schemes you have looked into serve some purpose. What is that purpose? Do they make the size of the sponge layer smaller?. Now that you have a basic example that illustrates an open boundary condition implementation with no matching scheme, you are in a position to implement a non-trivial matching scheme, and demonstrate its benefit. If the matching scheme has some benefit, then we are motivated to support it by adding source code and tests...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2021435396:154,validat,validation,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2021435396,2,['validat'],['validation']
Security,"> You're gonna want to implement a struct that's someting like; > ; > ```julia; > struct HaloFillingEvent; > location; > z_indices; > from_side; > to_side; > field_id; > end; > ```; > ; > and then a function; > ; > ```julia; > mpi_tag(hfe::HaloFillingEvent) = # number; > ```. I am not sure about this solution. The tag is used immediately (and only) where created, not recorded, and automatically destroyed by MPI after the communication is complete, so I do not immediately see the immediate utility of extra steps, or to save something in memory. A function that, given architecture, location, and side, spits out a unique tag seems sufficient for interpretability without having to record the output somewhere (it's a bit like a hash function, if you have function and inputs you have everything you need).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2298974417:733,hash,hash,733,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2298974417,1,['hash'],['hash']
Security,> closes #3681; > ; > We can probably use this PR to add also a validation for the `PartialCellBottom` and the bug-fixes in the implementation. What do people think?; > ; > cc @jm-c. presumably we should always use `PartialCellBottom` in examples with bathymetry. Is there a reason to ever use `GridFittedBottom`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2269888093:64,validat,validation,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2269888093,1,['validat'],['validation']
Security,"> only thought I had was: would it be too much work to add tests to CI that run the two new validation experiment? This would help ensure they don't go out of date and that we can easily run them on Buildkite. No, I think we should do this for the solid body validation experiment. I will implement this after I finish a quantitative analysis of the results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-786820370:92,validat,validation,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-786820370,2,['validat'],['validation']
Security,"> was [4b82c4c](https://github.com/CliMA/Oceananigans.jl/commit/4b82c4cc90a2d6a4b016149db0f75ad2ad2d43af) appropriate? perhaps I messed up?. I think this PR just added a validation tests? I'm not totally sure, but it's not super important either way since we don't really need such a validation test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1916#issuecomment-923634278:170,validat,validation,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1916#issuecomment-923634278,2,['validat'],['validation']
Security,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:595,validat,validation,595,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440,2,['validat'],['validation']
Security,"@Tinydog8 let me know if you're ok to convert this to discussion. Here's a sketch of how to accumulate `u_wm`:. ```julia; u_wall_model = XFaceField(grid, indices=(:, :, 1)) # It's purely a niceity to specify `indices` properly here --- the only thing we really need is a 2D array. # Also define other velocity components as needed; # Define drag boundary condition in terms of u_wall_model, other velocity components, etc using the `discrete_form=true`. # This function is meant to be used in a callback; function compute_wall_model_velocity!(sim); u, v, w = sim.model.velocities. filtering_time_scale = 1.0 # seconds --- for example; ϵ = sim.Δt / filtering_time_scale. u_wm = interior(u_wall_model, :, :, 1) # extract a view to broadcast over; u_LES = interior(u, :, :, 1) # a view into the LES velocity within the first grid cell; @. u_wm = (1 - ϵ) * u_wm + ϵ * u_LES. # Compute other components as needed; return nothing; end. simulation.callbacks[:wall_model] = Callback(compute_wall_model_velocity!); ```. An even more slick approach would build new auxiliary fields for the wall model velocities. In that case (if I'm not mistaken), then the wall model velocities are accessible from the argument to the boundary condition function (and don't have to be referenced as global variables).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1654114493:1174,access,accessible,1174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1654114493,1,['access'],['accessible']
Security,"@Yixiao-Zhang do you want to open a PR?. Sensible errors on GPU are a persistent problem... this seems like one of the trickiest though... I think the best easy thing we can do in this case is to add an article in our Wiki about how to debug `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`, making @simone-silvestri 's points. For documentation the error being referred to is. ```julia; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuMemcpyHtoDAsync_v2; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] #unsafe_copyto!#9; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:397 [inlined]; [5] (::CUDA.var""#1012#1013""{ComplexF64, CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, Int64, Vector{ComplexF64}, Int64, Int64})(); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:464; [6] #context!#887; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [7] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [8] unsafe_copyto!(dest::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, doffs::Int64, src::Vector{ComplexF64}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:457; [9] copyto!; @ ~/.julia/packages/CUDA/35NC6/src/array.jl:415 [inlined]; [10] setindex!(::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, ::ComplexF64, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:20; [11] setindex!; @ ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:24 [inlined]; [12] macro expansion; @ ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:136 [inlined]; [13] solve!(ϕ::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Boun",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332:273,access,access,273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332,2,['access'],['access']
Security,"@ali-ramadhan does this PR fix your issue? I will try the internal tide example on this PR, add some tests for `PartialCellBottom`, and then we can probably merge it. I am not sure whether this solves all the issues with PartialCellBottom, probably more validation is required, but this is a first step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2317976546:254,validat,validation,254,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2317976546,1,['validat'],['validation']
Security,@ali-ramadhan is there anything broken in validation exps in v0.53.0?. @maeckha if you try to run some example from the docs is it all ok or similar issues?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807433587:42,validat,validation,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807433587,1,['validat'],['validation']
Security,"@ali-ramadhan, should we re-run the validation tests?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783652567:36,validat,validation,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783652567,1,['validat'],['validation']
Security,@elise-palethorpe also perhaps change the validation script name as @glwagner suggest?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1236200350:42,validat,validation,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1236200350,1,['validat'],['validation']
Security,"@fadaie91 is going to run some more validation tests, but I think this PR is basically ready to go. @sandreza this may interest you as well for your 1 deg simulation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1117573124:36,validat,validation,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1117573124,1,['validat'],['validation']
Security,"@fluidnumerics-joe the CI doesn't work... something's wrong with the Manifest you pushed. It would be easier if you somehow allow maintainers to push. There is an option ""Allow edits and access to secrets by maintainers"" when you open a PR. Perhaps you disabled that?. Personally if I don't see the CI working (at least starting) then I feel it's a bit futile to comment on code that might be outdate or deprecated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936950079:187,access,access,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936950079,1,['access'],['access']
Security,"@francispoulin @glwagner ; > problem is that the velocity field is far from uniform at the outlet where a constant outflow of 1.0 is being prescribed. I wonder if this would cause numerical issues. To use `NormalFlow` we may either need a sponge layer, or to implement a more sophisticated outlet condition like an Orlanski condition. I have a version with a sponge layer I used for my own testing I could add. I updated the arbitrary grid branch to have the validation correct with normal flow's location specified, but the master version never got changed. > > If we are going to update this example, it's probably better to use `ImmersedBoundaryGrid` like in the other immersed boundary validation experiments...; > ; > Good point and I can look into that before this is reviewed. I was waiting for no-slip condition on the `ImmersedBoundaryGrid` before this validation is useful again, because otherwise you just get fun videos, but no actual validation. I have a work in progress script with a bunch of analysis I can add when we're ready to do so. Until then it might be best just to remove this file completely because it's so out of date.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1793#issuecomment-871667459:459,validat,validation,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1793#issuecomment-871667459,4,['validat'],['validation']
Security,"@francispoulin I do not know but I think it would be good to find out. `VerticallyImplicitTimeDiscretization`, despite being verbose, is actually too terse --- what we are really implementing is a _backwards_ vertically implicit time discretization. Our implementation in `QuasiAdamsBashforth2` is a first-order backwards approximation. Note that `QuasiAdamsBashforth2` is also first-order for explicit stepping, so this implementation should not change the accuracy of the scheme, I don't think. In `RungeKutta3` we implement a scheme that is backwards ""within stages"". This corresponds to some particular choice of Butcher tableau and I am not sure if it is formally 3rd order still. We might be able to develop a convergence test to an analytical solution to investigate this problem. It needs to be relatively high spatial resolution so that time-stepping errors are larger than spatial discretization errors. I propose we implement some validation tests and convergence tests in a future PR though to avoid bogging this PR down more...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1639#issuecomment-838806675:942,validat,validation,942,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1639#issuecomment-838806675,1,['validat'],['validation']
Security,"@francispoulin I noticed you are adding convergence tests. We also have convergence tests under `validation` here:. https://github.com/CliMA/Oceananigans.jl/tree/master/validation/convergence_tests. and it could make sense to contribute your convergence tests there. The tests are used to generate figures for documentation:. https://clima.github.io/OceananigansDocumentation/stable/validation/convergence_tests/. @ali-ramadhan can comment on how convergence tests might be added to our CI / automated testing suite. Is this PR just intended just to add advection schemes, or it is attempting to add higher-order operators for other terms as well? It'd be great to have higher-order finite volume operators for diffusion terms, for example. Does it make sense to contribute these in a separate PR and consider how they might be used in diffusion operators (for example)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743686982:97,validat,validation,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-743686982,3,['validat'],['validation']
Security,"@francispoulin yes, it is serial on the CPUs. The halos are indeed 3 for the `WENO5`, but if we use a vector invariant weno formulation (so we are interpolating vorticity) we need 4 halos because calculating vorticity itself requires one halo. @glwagner there is a type inference issue with `getregion(model, 1)` (you can see it in your validation test also). I think, solving that, the only overhead will be the `fill_halo` (and launching multiple kernels which maybe will not affect too much)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1108531966:337,validat,validation,337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1108531966,1,['validat'],['validation']
Security,"@glwagner ,. So then, based on the code snippet given by @johnryantaylor and our discussion, this validation could be adapted to something like:. ```julia; lamb = 1 # decay scale for slip velocity in meters; @inline w(x,y,z,t) = (tanh(max(-z/lamb,0))*tanh(max((z+H)/lamb,0))); sinking = SlipVelocity(WENO5(), w=w); ```. The way the code is, does it accept functions for velocity inputs?; Is that something I could do to help you?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083104129:98,validat,validation,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083104129,1,['validat'],['validation']
Security,"@glwagner ; Just to confirm, following #2384 , I will fork the main repo, then I switch to your branch, add a new example on `validation/`, then ; `julia --project`; and; `julia> include(""validation/source_sinking/source_sinking.jl"")`; or something like that, right?. Once it runs, I make a PR to your branch that will come back to here, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081877805:126,validat,validation,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081877805,2,['validat'],['validation']
Security,"@glwagner @simone-silvestri @jm-c - does this look OK for an approve 👍 ; Buildkite is back and happy now! . Its a validation update, but it will make it easier to do next steps (i.e. add new and improved immersed etc.. ) with some tests. . Thx,. Chris",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2170#issuecomment-1019292768:114,validat,validation,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2170#issuecomment-1019292768,1,['validat'],['validation']
Security,"@glwagner I have opened a PR with the branch sb/cut-cells-experiment, on which I have been working on implementing the cut cells. To summarize the progress:. - The two-dimensional [tracer advection test case](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/tracer_advection_over_bump.jl) over a Gaussian bump is run successfully using the low resolution from the [Adcroft](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml) paper and a relatively higher resolution. Both partial cells and full cells are used. Time evolution of the passive tracer concentration is visualized. - CutCellBottom is implemented in the ImmersedBoundary module similar to PartialCellBottom, and the tracer advection test case is repeated with cut cells. No noticeable difference in the results is detected so far (with the simulation using partial cells). So, tasks 1 (a) and 2 (b) have been completed so far. Tasks 2(b) and 2(c) are being worked on right now, after completion of which tasks 1 (b) and 3 will be initiated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3123#issuecomment-1592059402:260,validat,validation,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123#issuecomment-1592059402,1,['validat'],['validation']
Security,"@glwagner These changes look great!. I fixed some typos in the refactored file, which were terms that would not have affected your new validation case. I moved my original example to validation and provided some minor tweaks to your first validation case. I did not look much at the ``surface_wave_quasi_geostrophic_flow.jl`` case you created",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1836775430:135,validat,validation,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1836775430,3,['validat'],['validation']
Security,"@glwagner and @simone-silvestri . Continuing the discussion.; https://github.com/CliMA/Oceananigans.jl/discussions/2788#discussioncomment-8101280. It looks like MPI needs to be initialized before accessing its communication variables. Thus, despite calling `Distributed` initializes MPI, we need to access `Nranks = MPI.Comm_size(comm)` before to define `Partition`. https://github.com/CliMA/Oceananigans.jl/blob/294602781e7a678ef3a662e1a31d2145d10d0800/validation/distributed_simulations/distributed_nonhydrostatic_turbulence.jl#L20-L22. Should we initialize MPI when importing DistributedComputations?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890460124:196,access,accessing,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890460124,3,"['access', 'validat']","['access', 'accessing', 'validation']"
Security,"@glwagner and @simone-silvestri, thank you for the clarification. Indeed, this does not happen with `--check-bounds=yes`, as shown below:; ```julia; julia> my_field[-2, :, :]; ERROR: BoundsError: attempt to access 6×7×8 OffsetArray(::Array{Float64, 3}, -1:4, -1:5, -1:6) with eltype Float64 with indices -1:4×-1:5×-1:6 at index [-2, OffsetArrays.IdOffsetRange(values=-1:5, indices=-1:5), OffsetArrays.IdOffsetRange(values=-1:6, indices=-1:6)]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Base.Slice{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}}, Base.Slice{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] _getindex; @ ./multidimensional.jl:888 [inlined]; [4] getindex; @ ./abstractarray.jl:1291 [inlined]; [5] getindex(::Field{Center, Center, Center, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, ::Int64, ::Function, ::Function); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/main/src/Fields/field.jl:408; [6] top-level scope; @ REPL[23]:1; Some type information was truncated. Use `show(err)` to see complete types.; julia> my_field[:, -2, :]; ERROR: BoundsError: attempt to access 6×7×8 OffsetArray(::Array{Float64, 3}, -1:4, -1:5, -1:6) with eltype Float64 with indices -1:4×-1:5×-1:6 at index [OffsetArrays.IdOffsetRange(values=-1:4, indices=-1:4), -2, OffsetArrays.IdOffsetRange(values=-1:6, indices=-1:6)]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Base.Slice{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}}, Int64, Base.Slice{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] _ge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3615#issuecomment-2153291947:207,access,access,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3615#issuecomment-2153291947,1,['access'],['access']
Security,@glwagner could you run the `zonally_averaged_channel.jl`? I get an error I can't interpret. The error seems to be related to; https://github.com/CliMA/Oceananigans.jl/blob/c99e3e8b285d080016b84abc7c46cdb57ad823c1/validation/mesoscale_turbulence/zonally_averaged_channel.jl#L238-L273; because when I comment them out simulation runs!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-983330158:214,validat,validation,214,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-983330158,1,['validat'],['validation']
Security,@glwagner our lab at Northeastern and @christophernhill both have access to a set of MI50 and MI100 AMD GPUs. We're using them for now for our development code. I don't know the plan after we get the tests working.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112500783:66,access,access,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112500783,1,['access'],['access']
Security,"@glwagner, do you think a bit more elaborate validation test is in order?; I'll approve at this point and let this to your judgment.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1738#issuecomment-863627253:45,validat,validation,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1738#issuecomment-863627253,1,['validat'],['validation']
Security,"@glwagner, how can we avoid `collect`? E.g., at. https://github.com/CliMA/Oceananigans.jl/blob/d913858aa771f096e8ce48da132749361c8f1647/validation/elliptic_solvers/doubly_bounded_poisson.jl#L130. I tried `arch_array` but seems like we need to write some more methods for it?. ```julia; julia> r_array = arch_array(arch, reshape(interior(r), Nx * Ny * Nz)); ERROR: MethodError: no method matching arch_array(::CPU, ::Base.ReshapedArray{Float64, 1, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}); Closest candidates are:; arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; ...; Stacktrace:; [1] top-level scope; @ REPL[6]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52. julia> r_array = arch_array(arch, interior(r)); ERROR: MethodError: no method matching arch_array(::CPU, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); Closest candidates are:; arch_array(::CPU, ::Array) at /Users/navid/Research/OC.jl/src/Architectures.jl:102; arch_array(::CPU, ::CUDA.CuArray) at /Users/navid/Research/OC.jl/src/Architectures.jl:103; arch_array(::Any, ::AbstractRange) at /Users/navid/Research/OC.jl/src/Architectures.jl:107; ...; Stacktrace:; [1] top-level scope; @ REPL[7]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1162602827:136,validat,validation,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1162602827,1,['validat'],['validation']
Security,"@hengdiliang could be nice if you post results from a little validation test just to document that this not only runs, but runs correctly",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2385651669:61,validat,validation,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2385651669,1,['validat'],['validation']
Security,"@ilyascfd welcome and thanks for opening this issue, it's very helpful!. The problem here is that `Value` is not exported by default when we write `using Oceananigans` anymore. As a result, these lines:. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/validation/stratified_couette_flow/stratified_couette_flow.jl#L103-L110. do not work. . The recommended syntax nowadays is, for example,. ```; bc = ValueBoundaryCondition(0); ```. rather than `BoundaryCondition(Value, 0)`. This change was made to avoid name conflicts with some common names in the Julia ecosystem (like `Flux`). But, it looks like the validation script was not updated when this change was made to our exported names. I opened a PR to fix it in #1982. You can fix the script yourself as well by replacing `BoundaryCondition(Value, ` with `ValueBoundaryCondition(`. PS @ilyascfd here are a few tips for writing issues that will help us solve your problem as fast as possible; * Include links to the lines that are failing so we don't have to look for them ourselves. Github is really handy for this!; * When including code in an issue, please format it with triple backticks (```). Note: we run this script during CI, so at first I was surprised that we hadn't caught this yet. But when we run the tests, we do indeed import `Oceananigans.BoundaryConditions.Value` via. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/test/runtests.jl#L20. and. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/src/BoundaryConditions/BoundaryConditions.jl#L3-L4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1981#issuecomment-918194547:291,validat,validation,291,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1981#issuecomment-918194547,2,['validat'],['validation']
Security,@iuryt do you want to help set up a validation case for this feature?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081759825:36,validat,validation,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1081759825,1,['validat'],['validation']
Security,@maeckha I can reproduce your error when calling `simulate_lid_driven_cavity()`. I feel that this validation experiment was done with an older version of Oceananigans compared to the v0.53.0 are running and some things are deprecated. @ali-ramadhan might comment more on that perhaps. But the thermal bubble example from the Readme (just copy paste the code from there) runs just fine! Do you get an error with that also?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807466260:98,validat,validation,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807466260,1,['validat'],['validation']
Security,@maeckha do you have access to Oceananigas.jl? i.e. can you merge this PR yourself?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1789#issuecomment-872335304:21,access,access,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1789#issuecomment-872335304,1,['access'],['access']
Security,"@matinraayai I made a bunch of suggestions!. I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`. Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like. ```julia; using Oceananigans; grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO5()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ); simulation = Simulation(model; Δt=0.01, stop_time=4); run!(simulation); ```. should be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085:273,validat,validation,273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085,2,['validat'],['validation']
Security,"@michel2323 @vchuravy this looks like an error in KA indexing, which I recall you guys resolved previously? [and @glwagner there was that weird offset issue before iirc]. ```julia. Enzyme on advection and diffusion: Error During Test at /var/lib/buildkite-agent/builds/tartarus-3/clima/oceananigans/test/test_enzyme.jl:93; --;   | Got exception outside of a @test;   | BoundsError: attempt to access 16×16×1 Array{Tuple{Core.LLVMPtr{UInt64, 0}, Core.LLVMPtr{UInt64, 0}, Core.LLVMPtr{UInt64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{UInt64, 0}, Core.LLVMPtr{UInt64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{UInt64, 0}, Core.LLVMPtr{UInt64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{Float64, 0}, Core.LLVMPtr{UInt64, 0}}, 3} at index [1, 1, 2];   | Stacktrace:;   | [1] setindex!;   | @ ./array.jl:971 [inlined];   | [2] setindex!;   | @ ./multidimensional.jl:670 [inlined];   | [3] aug_fwd;   | @ /storage5/buildkite-agent/.julia-14477/packages/KernelAbstractions/WoCk1/ext/EnzymeExt.jl:20 [inlined];   | [4] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(64, 64, 8)}, typeof(EnzymeExt.aug_fwd)}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(4, 4, 8)}, KernelAbstractions.NDIte",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-1953382929:393,access,access,393,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-1953382929,1,['access'],['access']
Security,"@navidcy Good call! ; You can find here below the output of benchmarks/benchmark_advection_schemes.jl ran on main and this PR and adapted to test the new methods.; For validation, you can run validation/advection/validate_weno_schemes.jl to validate the methods on a 1D and 2D advection problem for different grids; (uniform and stretched). execution of benchmark_advection_schemes.jl on main; ```; ┌───────────────┬────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ Architectures │ Schemes │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼────────────────────────┼───────────┼───────────┼───────────┼───────────┼──────────┼────────┼─────────┤; │ CPU │ CenteredFourthOrder │ 1.779 s │ 1.789 s │ 1.794 s │ 1.814 s │ 1.05 MiB │ 1685 │ 3 │; │ CPU │ CenteredSecondOrder │ 1.018 s │ 1.066 s │ 1.061 s │ 1.090 s │ 1.05 MiB │ 1685 │ 5 │; │ CPU │ UpwindBiasedFifthOrder │ 2.467 s │ 2.505 s │ 2.505 s │ 2.544 s │ 1.05 MiB │ 1685 │ 2 │; │ CPU │ UpwindBiasedThirdOrder │ 1.808 s │ 1.877 s │ 1.862 s │ 1.903 s │ 1.05 MiB │ 1685 │ 3 │; │ CPU │ WENO5 │ 6.775 s │ 6.775 s │ 6.775 s │ 6.775 s │ 1.05 MiB │ 1685 │ 1 │; │ GPU │ CenteredFourthOrder │ 20.879 ms │ 20.970 ms │ 21.078 ms │ 21.874 ms │ 2.17 MiB │ 20610 │ 10 │; │ GPU │ CenteredSecondOrder │ 11.402 ms │ 15.533 ms │ 15.138 ms │ 15.680 ms │ 2.05 MiB │ 13147 │ 10 │; │ GPU │ UpwindBiasedFifthOrder │ 23.356 ms │ 23.498 ms │ 24.055 ms │ 29.246 ms │ 2.21 MiB │ 23281 │ 10 │; │ GPU │ UpwindBiasedThirdOrder │ 18.863 ms │ 19.027 ms │ 19.298 ms │ 21.745 ms │ 2.12 MiB │ 17945 │ 10 │; │ GPU │ WENO5 │ 23.234 ms │ 28.467 ms │ 27.982 ms │ 28.684 ms │ 2.30 MiB │ 29259 │ 10 │; └───────────────┴────────────────────────┴───────────┴───────────┴───────────┴───────────┴──────────┴────────┴─────────┘; ```; This PR same file, (WENO5 on uniform grids); ```; ┌───────────────┬────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ Architec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738:168,validat,validation,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738,3,['validat'],"['validate', 'validation']"
Security,"@navidcy I just did a lazy switch to CUDA 3.8.0 (and CUDAKernels 0.3.3) in my latest PR and it seems to be somewhat ok (for sure not all is required) but there are still some problems with `gpu_nonhydrostatic_regression` (an `device kernel invalid image`), `gpu_cubed_sphere`(an `out of bounds access`) (and for some weird reason distributed CPU??). I ll try to figure out a bit more... @francispoulin I don't have an indepth idea of the scaling but I with some basic trials I saw that the message passing is quite quick (the advantage is that is passes directly from GPU to GPU, which maybe is the same as cuda-aware MPI?). The advantage is surely the ease of implementing such a method",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044738495:294,access,access,294,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044738495,1,['access'],['access']
Security,"@navidcy, based on your comment [here](https://github.com/CliMA/Oceananigans.jl/pull/3087/commits/43723b6661ffeba0f7caf9320c8e3fb32c943f98), I have put the spaces between the hashes to restore the literation style of the examples.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3087#issuecomment-1572565458:175,hash,hashes,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3087#issuecomment-1572565458,1,['hash'],['hashes']
Security,"@siddharthabishnu I pushed a clean version of the grid comparison at https://github.com/CliMA/Oceananigans.jl/blob/sb-ncc/cs-grid-metrics/validation/multi_region/multi_region_cubed_sphere_grid.jl. if I run this on this branch I get:. ```Julia; julia> include(""multi_region_cubed_sphere.jl""); [ Info: λᶜᶜᵃ_difference_MITgcm panel 1: 1.8471271253206468e-7; [ Info: λᶜᶜᵃ_difference_MITgcm panel 2: 1.8471270881725844e-7; [ Info: λᶜᶜᵃ_difference_MITgcm panel 3: 3.2442725228121196e-7; [ Info: λᶜᶜᵃ_difference_MITgcm panel 4: 1.8471271544306945e-7; [ Info: λᶜᶜᵃ_difference_MITgcm panel 5: 1.847127087195588e-7; [ Info: λᶜᶜᵃ_difference_MITgcm panel 6: 3.244272524791092e-7; [ Info: λᶜᶜᵃ_difference_MITgcm panel 1: 1.8471271253206468e-7; [ Info: λᶜᶜᵃ_difference_MITgcm panel 2: 1.8471270881725844e-7; [ Info: λᶜᶜᵃ_difference_MITgcm panel 3: 3.2442725228121196e-7; [ Info: λᶜᶜᵃ_difference_MITgcm panel 4: 1.8471271544306945e-7; [ Info: λᶜᶜᵃ_difference_MITgcm panel 5: 1.847127087195588e-7; [ Info: λᶜᶜᵃ_difference_MITgcm panel 6: 3.244272524791092e-7; [ Info: λᶠᶠᵃ_difference_MITgcm panel 1: 1.732365234564951e-7; [ Info: λᶠᶠᵃ_difference_MITgcm panel 2: 1.7323652025336144e-7; [ Info: λᶠᶠᵃ_difference_MITgcm panel 3: 0.05625027340835691; [ Info: λᶠᶠᵃ_difference_MITgcm panel 4: 1.7323652655498735e-7; [ Info: λᶠᶠᵃ_difference_MITgcm panel 5: 1.7323652008460754e-7; [ Info: λᶠᶠᵃ_difference_MITgcm panel 6: 0.0562502734083572; [ Info: φᶜᶜᵃ_difference_MITgcm panel 1: 1.570048120703993e-7; [ Info: φᶜᶜᵃ_difference_MITgcm panel 2: 1.5700481280397916e-7; [ Info: φᶜᶜᵃ_difference_MITgcm panel 3: 1.3603837144327004e-7; [ Info: φᶜᶜᵃ_difference_MITgcm panel 4: 1.5700481343680627e-7; [ Info: φᶜᶜᵃ_difference_MITgcm panel 5: 1.570048127987056e-7; [ Info: φᶜᶜᵃ_difference_MITgcm panel 6: 1.360383713455704e-7; [ Info: φᶠᶠᵃ_difference_MITgcm panel 1: 1.478470279652168e-7; [ Info: φᶠᶠᵃ_difference_MITgcm panel 2: 1.4784702873954643e-7; [ Info: φᶠᶠᵃ_difference_MITgcm panel 3: 1.353035964424265e-7; [ Info: φᶠᶠᵃ_difference",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2012222484:138,validat,validation,138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2012222484,1,['validat'],['validation']
Security,"@siddharthabishnu can you post perhaps a shorter MWE-type code snippet that showcases this issue, e.g., for a `CenterField` and `XFaceField`?. After some investigation, I noticed that in the [script](https://github.com/CliMA/Oceananigans.jl/blob/60dde179a1851bcc47a55987478d825709e3e7c6/validation/multi_region/multi_region_cubed_sphere.jl) you pointed out the tracer-`CenterField` had its values filled via `set!` with an anonymous function:. https://github.com/CliMA/Oceananigans.jl/blob/60dde179a1851bcc47a55987478d825709e3e7c6/validation/multi_region/multi_region_cubed_sphere.jl#L152. The above does not fill any values in the halo regions! On the other hand, you were filling values for the `XFaceField` using a `for`-loop that was looping in the halo regions as well... https://github.com/CliMA/Oceananigans.jl/blob/60dde179a1851bcc47a55987478d825709e3e7c6/validation/multi_region/multi_region_cubed_sphere.jl#L193-L198. So this might be one reason for why the plots look different? I am not quite sure because the plots also don't include color bars so I'm not sure if the disagreement is a plotting issue or a combination of plotting + a bug. But let's strip down the script to the bare minimum showcasing the problem -- at the moment the script has a lot of if statements and seems to be used for many things, not just to showcase the issue discussed here. For example, running this ; ```julia; using Oceananigans; using Oceananigans.MultiRegion: getregion. grid = ConformalCubedSphereGrid(panel_size=(4 ,4, 1), z=(-1, 0), radius=1). u = XFaceField(grid); v = YFaceField(grid); c = CenterField(grid). set!(c, (λ, φ, z) -> φ); set!(u, (λ, φ, z) -> φ); set!(v, (λ, φ, z) -> φ). @info ""u values""; display(rotl90(view(getregion(u, 1).data, :, :, 1))). @info ""v values""; display(rotl90(view(getregion(v, 1).data, :, :, 1))). @info ""c values""; display(rotl90(view(getregion(c, 1).data, :, :, 1))); ```. gives. ```Julia; [ Info: u values; 6×6 OffsetArray(::Matrix{Float64}, 0:5, 0:5) with eltype Fl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1688294856:287,validat,validation,287,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1688294856,3,['validat'],['validation']
Security,"@siddharthabishnu, can you commit the steady-state validation script in this PR from #3302? We were trying to ensure that double halo passing occurs for velocities etc and these are probably also needed for #3302 so let's have both validation scripts in one place so we don't do double job?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1748724414:51,validat,validation,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1748724414,2,['validat'],['validation']
Security,"@siddharthabishnu, perhaps it's simpler to try explicit free surface. Have a look, e.g., at . https://github.com/CliMA/Oceananigans.jl/blob/c9aa1b3b90c9775e4f3a98b7c67f916727830aee/validation/multi_region/cubed_sphere_momentum_dynamics.jl#L63",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747351924:181,validat,validation,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747351924,2,['validat'],['validation']
Security,"@simone-silvestri I noticed that a few validation tests were changed to use `MultiRegion`. What do you think about adding a new category of validation tests, maybe `validation/multi_region/`, and leaving the existing validation tests unchanged? If you think this is a good idea, I'll copy the changed tests into a new directory, and revert the existing tests to their original form.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107933299:39,validat,validation,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107933299,4,['validat'],['validation']
Security,"@simone-silvestri I think another error has now come up with the original MWE in issue #3681. I tried the `main` branch and this branch on two different systems and I'm getting a different CUDA illegal memory access error. Since it's probably not related to this PR I'll open a new issue about it. I'm guessing something is out of bounds in an `@inbounds`. I'll try catching it with `--check-bounds=yes`. MWE:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); ```. Error:. ```julia; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/libcuda.jl:30; [2] check; @ ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/Tl08O/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_stru",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:209,access,access,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,2,['access'],['access']
Security,"@simone-silvestri could you point me to a test/validation that confirms 1) that the changes of the PR didn't have an effect on regular grids. Also, a benchmark to see how this PR might have speedup/slowed down things? There were some benchmarks in the first comment when the PR was opened but many changes were pursued after. Should we repeat those benchmarks or something along those lines?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974750814:47,validat,validation,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974750814,1,['validat'],['validation']
Security,@simone-silvestri you can run the GPU profiler on the `validation/elliptic_solvers/doubly_bounded_poisson.jl` on this branch. You can set `arch = GPU()` and it should work.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1242599636:55,validat,validation,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1242599636,1,['validat'],['validation']
Security,"@tomchor , thanks for the suggestion, but didn't have any access. @ali-ramadhan , thanks for merging!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1789#issuecomment-872727739:58,access,access,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1789#issuecomment-872727739,1,['access'],['access']
Security,@tomchor Ah are you okay with committing my suggestion before merging? . I think docs did get built and deployed:; https://buildkite.com/clima/oceananigans/builds/2048#0d49a5b8-1dec-4f7b-b82a-cf6f8809e234/40-574; https://clima.github.io/OceananigansDocumentation/previews/PR1543/simulation_tips/. Working on getting you guys access to Buildkite so you can control it as well. I'm not a Buildkite admin so I have to ask one to invite other people...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819560412:325,access,access,325,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819560412,1,['access'],['access']
Security,"@tomchor, let's do these in this PR:. > * Remove the Lid-drive cavity and Couette flow from the docs; > * Keep the Convergence tests (maybe move it to the Appendix to make for a cleaner left menu). and open issue/other PR for `validation` directory.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873257930:227,validat,validation,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873257930,1,['validat'],['validation']
Security,@xiaozhour @navidcy @sandreza are we ok to merge this PR without examples (since it has a lot of fixes) and continue working on 1) eddying channel example and 2) eddying channel validation test on new branches?. I'll work on getting tests to pass.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-890346316:178,validat,validation,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-890346316,1,['validat'],['validation']
Security,"@xiaozhour and I looked into some direct comparisons with MITgcm and found a few differences that we are continuing to investigate. One thing worth noting is that in the MITgcm computation the xz and yz components of the diffusivity tensor that act on vertical gradients are directly set to zero, whereas the zz component is treated implicitly. In the simulation below I increase the initial horizontal gradient by a factor of two and set the initial tracer to be constant. A numerical instability develops eventually leading to NaNs in the tracer field. By setting the Redi-component to zero the solution remains stable. The file is located here: https://github.com/CliMA/Oceananigans.jl/blob/glw-as/near-global-one-degree/validation/mesoscale_turbulence/modified_baroclinic_adjustment.jl. https://user-images.githubusercontent.com/22668662/165390858-211bce67-fb10-4ae4-8e60-3516b49e5031.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1110244312:724,validat,validation,724,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1110244312,1,['validat'],['validation']
Security,"A general question. In the tests a variable `results` is created, which is a mutable struct Dict. I see that map is a way to pick out elements of this object. When I ask for information on resutls I get something like this. ```julia> results; Dict{Any,Any} with 1 entry:; CenteredSecondOrder => fill((cx = (simulation = [-8.07688e-137, -2.28227e-125, -1.9026e-114, -4.67931e-104, -3.39525e-94, -7.26804e-…; ```. How do I get values from this object? . From looking in the scripts I gather that we need to use `map` but not sure what fields to get or how to get them. I found out that I can get a bit more inside using `results[CenteredSecondOrder]` but still not sure how to access the arrays.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745408363:675,access,access,675,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745408363,1,['access'],['access']
Security,"A git merge/rebase master might help with review, but only thought I had was: would it be too much work to add tests to CI that run the two new validation experiment? This would help ensure they don't go out of date and that we can easily run them on Buildkite.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-786816292:144,validat,validation,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404#issuecomment-786816292,1,['validat'],['validation']
Security,"A more hierarchical organization of the docs is. 1. Introduction; * What's Oceananigans?; * Installation; * Writing your first script; * Do you want to save the world? (by contributing to Oceananigans); - Contributing guide; - Features that need validating; - Features that need documenting and examples; * Gallery; 2. Examples; 3. Building models, running simulations, and post processing; * Grids and computer architectures; * Fields, BoundaryCondition, and AbstractOperations; * IncompressibleModel; * HydrostaticFreeSurfaceModel; * ShallowWaterModel; * Setting initial conditions; * Diffusion, viscosity, and TurbulenceClosures; * Forcing functions; * Coriolis forces; * Buoyancy forces; * Simulation; * OutputWriters; * OutputReaders, post-processing, and plotting; 5. Useful tips; * Using Graphics Processing Units (GPUs); * Common errors and performance pitfalls; 8. Fluid dynamics and ocean physics; * Navier-Stokes and tracer conservation equations; * The hydrostatic approximation and shallow water equations; * The Boussinesq approximation and equations of state for seawater; * Rotating domains and Coriolis forces; * Diffusion, hyperdiffusion, and parameterization of subgrid processes; - Basic models for diffusive processes; - Large eddy simulation; - Boundary layer parameterization; 9. Numerical implementation; * The finite volume discretization on a staggered grid; * Interpolation, differencing, and advection schemes; * Boundary conditions and immersed boundaries; * The pressure correction method for enforcing mass conservation; * Discretization of hydrostatic and non-hydrostatic pressure; * Implicit time-stepping; * Multi-domain simulations and the cubed sphere; 10. Developer guide; 11. Appendix; * References",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142:246,validat,validating,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142,2,['validat'],['validating']
Security,"A more minimal example:. ```Julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, PartialCellBottom. arch = CPU(). underlying_grid = RectilinearGrid(arch,; size=(128, 64), halo=(3, 3), ; y = (-1, 1),; z = (-1, 0),; topology=(Flat, Periodic, Bounded)). @inline seamount(x, y) = - 1 + 0.5 * exp(- y^2 / 0.25^2). minimum_fractional_Δz = 0.2. grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(seamount; minimum_fractional_Δz)). tracer_advection = CenteredSecondOrder(); momentum_advection = CenteredSecondOrder(). model = HydrostaticFreeSurfaceModel(; grid,; tracer_advection,; momentum_advection,; coriolis = FPlane(f=0.1),; tracers = :b,; buoyancy = BuoyancyTracer()); ```. ```julia; ERROR: TaskFailedException. nested task error: TaskFailedException. nested task error: BoundsError: attempt to access 1×134 OffsetArray(::Matrix{Float64}, 1:1, -2:131) with eltype Float64 with indices 1:1×-2:131 at index [0, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, I::Tuple{Int64, Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] getindex(::OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, ::Int64, ::Int64); @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:420 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:420 [inlined]; [6] overdub; @ ~/Research/OC2.jl/src/ImmersedBoundaries/partial_cell_immersed_boundaries.jl:49 [inlined]; [7] immersed_cell(::Int64, ::Int64, ::Int64, ::RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.Twi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2798#issuecomment-1302841826:840,access,access,840,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2798#issuecomment-1302841826,1,['access'],['access']
Security,"A quick fix is to change. https://github.com/CliMA/Oceananigans.jl/blob/f70d0949f7688df89a7f8a9e7d44177cde27091a/validation/immersed_boundaries/flow_over_hills.jl#L30. to . ```julia; underlying_grid = RectilinearGrid(architecture, size = (Nx, Nz), halo = (4, 4), ; ```. ie increase the number of halo points by 1. It does beg the question whether we should increase the number of default halo points to 4 from 3. Both #2989 and #2827 should increase the problem with cryptic errors.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2860#issuecomment-1480508282:113,validat,validation,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860#issuecomment-1480508282,1,['validat'],['validation']
Security,"Adding a Manifest + Project toml files in each validation scripts directory is a good idea!; However, if we do it while we are working on them in a PR, then the Manifest comes with an Oceananigans dependency that points to the branch, e.g.,. https://github.com/CliMA/Oceananigans.jl/blob/1c2a6f8752b6425bf30d856f8ba0aa681c0ab818/validation/stokes_drift/Manifest.toml#L1202. and the branch gets deleted after the PR is merged. . So what one would need to do is to make another PR with a Manifest pointing to the specific commit on `main` or to the next tagged release? Sounds like too much work to be sustainable...?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3076#issuecomment-1891870915:47,validat,validation,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076#issuecomment-1891870915,2,['validat'],['validation']
Security,"Agree that SI default makes sense for a code called ""Oceananigans"". Note that some of the examples are non-dimensional, so an SI default will indeed add code to those examples --- which are likely some of the most-read scripts in the Oceananigans-verse. I also think for accessibility it could make sense to prioritize ease-of-use in a classroom context, where non-dimensional runs are the norm.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791618889:271,access,accessibility,271,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791618889,1,['access'],['accessibility']
Security,"Agreed! I went back and see that things are much better on my cpu. There are a few warnings but then it gets down to business. I am estimating that it might take 14 hours, and now I believe that it is progressing (unlike before). On a future world, when one sees that things are taking a while, it would be nice to run things in parallel using distrubed version of the model. I see there are distributed models for IncompressibleModel and ShallowWater, but not HydrostaticModel, yet. . Maybe I'll create an issue since this is something that I presume we would like to have going forward. ```; ┌ Warning: ImmersedBoundaryGrid is unvalidated and may produce incorrect results. ; │ Don't hesitate to help validate ImmersedBoundaryGrid by reporting any bugs ; │ or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues; └ @ Oceananigans.ImmersedBoundaries ~/software/Second_Oceananigans/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:73; ┌ Warning: HydrostaticFreeSurfaceModel is experimental. Use with caution!; └ @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/software/Second_Oceananigans/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:106; ┌ Warning: Cannot save Function property into grid/immersed_boundary/mask; └ @ Oceananigans.OutputWriters ~/software/Second_Oceananigans/Oceananigans.jl/src/OutputWriters/output_writer_utils.jl:21; ┌ Warning: Could not initialize ./internal_tide.jld2: data may already be initialized.; └ @ Oceananigans.OutputWriters ~/software/Second_Oceananigans/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:193; [ Info: [0.06%], iteration: 100, time: 0.055, max|w|: 9.46e-06; [ Info: [0.11%], iteration: 200, time: 0.110, max|w|: 2.67e-05; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867970305:703,validat,validate,703,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867970305,1,['validat'],['validate']
Security,Ah I thought we could do something with abstract types for that but couldn't get it to work before. I'll try this on a GPU now if I can get one. And that makes sense for the validation.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1305857142:174,validat,validation,174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1305857142,1,['validat'],['validation']
Security,"Ah ok, thanks for that info! I guess that means this internal tide validation experiment wouldn't benefit from GPU parallelization?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-868667638:67,validat,validation,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-868667638,1,['validat'],['validation']
Security,"Ah we can figure out the best names in the future PR then?. > I still would like to solve that specific bug relatively soon since I want to validate the tilted buoyancy on a tilted bottom boundary layer soon. Should I create a separate issue for that?. Maybe the fastest thing to do for now would be to use `JLD2OutputWriter`? It should work with the grids no problem until we sort out `NetCDFOutputWriter`. I've been able to open JLD2 files in Python with h5py in the past if that's helpful, but yeah no xarray.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799835492:140,validat,validate,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799835492,1,['validat'],['validate']
Security,"Ah, I foolishly assumed it was running in CPUs but do see it's running on GPUs. I gather it's slow because the GPU I have on my desktop is poor. Maybe I'll kill it and run it on a CPU as that maybe faster on my local machine. One thing that should be changed, sometime, is the only output I see is a warning message. ```; ┌ Warning: ImmersedBoundaryGrid is unvalidated and may produce incorrect results. ; │ Don't hesitate to help validate ImmersedBoundaryGrid by reporting any bugs ; │ or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues; └ @ Oceananigans.ImmersedBoundaries ~/software/Second_Oceananigans/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:73; ┌ Warning: ImmersedBoundaryGrid is unvalidated and may produce incorrect results. ; │ Don't hesitate to help validate ImmersedBoundaryGrid by reporting any bugs ; │ or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues; └ @ Oceananigans.ImmersedBoundaries ~/software/Second_Oceananigans/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:73; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867923735:431,validat,validate,431,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867923735,2,['validat'],['validate']
Security,"Ah, I see. I thought it was validated. > Perhaps you can come up with a nice validation experiment that we can use to gain confidence that it works correctly, and then add some documentation?. It's hard for me to come up with a validation experiment for that I think. Are we testing that the viscosities are calculated and added correctly? (Thus a simple analytical example might suffice or an example where we just add two constant diffusities.) Or are we testing that the interface is working?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439:28,validat,validated,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439,6,['validat'],"['validated', 'validation']"
Security,"Ah, these experiments are the immersed Bickley jet but they use a one layer HydrostaticFreeSurfaceModel. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/bickley_jet/immersed_bickley_jet.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2985#issuecomment-1475449166:156,validat,validation,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2985#issuecomment-1475449166,1,['validat'],['validation']
Security,"Ali, can I think of this as a shallow water model that knows about reduced; gravity? John. On Wed, Apr 21, 2021, 1:45 PM Ali Ramadhan ***@***.***> wrote:. > This PR adds an eddying aquaplanet validation experiment that's still a; > work-in-progress (early stage PR).; >; > The idea is to force a HydrostaticFreeSurfaceModel on a CubedSphereGrid; > with a ""tradewind-like"" zonal wind stress pattern akin to Marshall et al.; > (2007); > <https://journals.ametsoc.org/view/journals/atsc/64/12/2007jas2226.1.xml>.; >; > This is figure 3 from the paper:; >; > [image: i1520-0469-64-12-4270-f03]; > <https://user-images.githubusercontent.com/20099589/115593956-293a7d00-a2a3-11eb-98cd-4874b6b3d638.gif>; >; > and this is the analytic formula I'm using to mimic it:; >; > [image: image]; > <https://user-images.githubusercontent.com/20099589/115593657-c8ab4000-a2a2-11eb-8090-b584e88b7e72.png>; >; > We integrate τ to obtain a streamfunction for the wind stress which we; > then use to diagnose the surface; > momentum fluxes on the cubed sphere. *I think I got the magnitude wrong; > so I fixed it with a scaling factor...*; >; > I tried adding a lot of noise to the initial velocities but the wind; > stress smoothed it away.; > cubed_sphere_eddying_aquaplanet.mp4; >; > @christophernhill <https://github.com/christophernhill> suggested adding; > some random noise to the wind stress as well. And we probably also need a; > mechanism to remove energy otherwise the wind stress keeps accelerating the; > fluid until the model blows up. Maybe we need some bottom drag even though; > we only have one vertical level?; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/CliMA/Oceananigans.jl/pull/1602; > Commit Summary; >; > - Regularize cubed sphere boundary conditions; > - First draft of eddying aquaplanet; > - Run with diffusion for 7 days and copy paste plotting script; >; > File Changes; >; > - *M* src/CubedSpheres/CubedSphere",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1602#issuecomment-824303767:192,validat,validation,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1602#issuecomment-824303767,1,['validat'],['validation']
Security,"All the tests seem to pass but I get two errors. The first error is on a GPU, running `test_shallow_water_diffusion_cosine` on the field `u` using the `ConservativeFormulation()`. When I run this in isolation I get the following error. Any suggestions on what to do here?. ```; [2024/02/27 10:33:43.977] INFO Testing ShallowWaterModel cosine viscous diffusion [u, ConservativeFormulation()]; [2024/02/27 10:33:43.977] WARN The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation. -@-> /home/fpoulin/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:103; [3] getindex(xs::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/indexing.jl:9; [4] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:438 [inlined]; [5] _getindex; @ ./abstractarray.jl:1321 [inlined]; [6] getindex; @ ./abstractarray.jl:1288 [inlined]; [7] getindex; @ ~/Software/Oceananigans.jl/src/Fields/field.jl:399 [inlined]; [8] _broadcast_getindex; @ ./broadcast.jl:675 [inlined]; [9] _getindex; @ ./broadcast.jl:705 [inlined]; [10] _broadcast_getindex; @ ./broadcast.jl:681 [inlined]; [11] getindex; @ ./broadcast.jl:636 [inlined]; [12] macro expansion; @ ./broadcast.jl:1004 [inlined]; [13] macro expansion; @ ./simdloop.jl:77 [inlined]; [14] copyto!; @ ./broa",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141:554,validat,validation,554,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394#issuecomment-1966839141,1,['validat'],['validation']
Security,"Also one thing that is important to get right in multi-layer shallow water models is layer-wise conservation of mass and other properties (see _e.g._, https://aronnax.readthedocs.io/en/latest/verification.html and http://www.nordet.net/beom.html). > Topography that can interact more than one layer is complicated because then we need wetting and drying, but it won't need immersed boundaries. At least i don't think so. Wetting and drying usually requires a positive preserving advection scheme. We have first-order upwinding (which I don't think anyone has every used), that is positive preserving and could do this. But it's not a great scheme. A limiter would be better. There are a lot of methods out thatk, but not the first thing to worry about. This if much longer term, I would say. In addition to positive-preserving advection schemes, it seems one other way to deal with this is adding to the pressure gradients an extra term that prevents the thicknesses of outcropped/incropped layers from reaching zero following [Salmon (2002)](https://www.ingentaconnect.com/content/jmr/jmr/2002/00000060/00000004/art00004?token=005b148389c57630504c2a726e2d58464340592f713b672c57582a67232d45234a46246c6a4d2c3167732355e72). There is a deep discussion on the physics and practical implementation of this in different validation simulations in http://www.nordet.net/etc/doc_beom.pdf. Just wanted to put this out there, I don't have a good feel for which approach would be most desirable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115738194:1314,validat,validation,1314,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115738194,1,['validat'],['validation']
Security,"Also update on correctness / testing: there are now tests that fluxes are correctly imposed:. https://github.com/CliMA/Oceananigans.jl/blob/22739d6a5d410317b0a6fa5cf538ba43dabe16bf/test/test_boundary_conditions_integration.jl#L226-L227. I don't believe there are any simple tests that `Value` / `Gradient` boundary conditions are imposed correctly --- even without an immersed boundary. Instead, we have relied on validation tests to check that. I think it does make sense though to have some tests in that direction... maybe something like a test that 1D couette flow is maintained (for momentum) and that a simple linear tracer gradient is maintained (for tracers). Those would go here: https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/test/test_dynamics.jl. Since we don't have that yet we should probably add in another PR. It'd be nice therefore to have a few validation experiments in hand before merging that indicate no-slip ""seems to work"". cc @raphaelouillon",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882:414,validat,validation,414,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1105451882,4,['validat'],['validation']
Security,"Also with `SumOfFields` we can put in proper support for other things. It can be an `AbstractField` and be used in operations (perhaps the biggest advantages because users will want to do diagnostics on the sum probably), we can give it a location and expose its grid, and we can support `fill_halo_regions` and `mask_immersed_field`. It's a decent idea provided that the normal way of summing fields that produces a `BinaryOperation` or `MultiaryOperation` won't work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2265995885:252,expose,expose,252,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2265995885,1,['expose'],['expose']
Security,"An easier course of action would be to forget about performance at first and just fill halos every substep.; This will be quite inefficient but will allow us to test open boundary conditions for the hydrostatic model and validate them first. There is an implementation of a split explicit free surface solver that does not require special operators (specifically for a multi region grid) in #3596 ; https://github.com/CliMA/Oceananigans.jl/blob/a6e9a465aa9528b5b3afd49737310e710e4681b0/src/MultiRegion/multi_region_split_explicit_free_surface.jl#L130-L170. We could adapt this implementation for normal grids by implementing a keyword argument in the `SpliExplicitFreeSurface` constructor. Something like the `extended_halos` that is mentioned here; https://github.com/CliMA/Oceananigans.jl/blob/a6e9a465aa9528b5b3afd49737310e710e4681b0/src/MultiRegion/multi_region_split_explicit_free_surface.jl#L19-L28. For serial grids, `extended_halos` is not the correct argument, though, because we do not extend halos (we do that only on distributed and multi region grids), so maybe something like `use_boundary_aware_operators.` . Once the numerics have been settled we can adapt the open boundary condition implementation to the special operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2399186268:221,validat,validate,221,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2399186268,1,['validat'],['validate']
Security,"Apologies - other urgent work and family needs have delayed me. I'm using; Julia 1.9.3; CairoMakie v0.9.4; and have in my status report; GLMakie v0.7.4 and Makie v0.18.4. I tried to use update with the pkg manager to no effect, but see I should be using CairoMakie@0.11, which I am now installing.; This was not successful. For example the file S7LmV_3TYIX.dll would not load giving a permission denied error, but my check of the properties/security did not reveal a deficiency. However, the example worked fine. Many thanks - Kevin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3442#issuecomment-1920152651:441,secur,security,441,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3442#issuecomment-1920152651,1,['secur'],['security']
Security,Are you running the pasted example or the code in `validation`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867911238:51,validat,validation,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867911238,1,['validat'],['validation']
Security,"As a user, I prefer an internal ""settings"" dictionary over an environment variable. Actually, I think it would be better to define a function `Oceananigans.set_default_number_type(FT)` for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. Another option is to pass `FT=Float32` to the model and then let the constructor convert related components to `Float32` \(or `Float64` if `FT=Float64` is passed\). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644:198,access,access,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644,2,['access'],['access']
Security,"As far as I can tell, I think this is related to the issue @jagoosw mentioned too, where the indices that the output is trying to access does not match the size of the sliced fields, similar to what we are seeing here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014619281:130,access,access,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014619281,1,['access'],['access']
Security,"As for issues with other topologies, we could possibly use the ""forced flow, fixed-slip"" convergence test with 2D slices oriented in various directions to uncover issues:. https://github.com/CliMA/Oceananigans.jl/blob/master/validation/convergence_tests/src/ForcedFlowFixedSlip.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-878312638:225,validat,validation,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-878312638,1,['validat'],['validation']
Security,"Bah sorry @francispoulin I meant to respond to your comment, but accidentally edited instead. Then I tried to delete my edit, but accidentally deleted the original comment! . Anyways... hopefully the info is clear:. The setup is here: https://github.com/CliMA/Oceananigans.jl/blob/glw-as/near-global-one-degree/validation/mesoscale_turbulence/coarse_lat_lon_baroclinic_adjustment.jl. It spans 10 deg from latitude 40-50. In one case the gradient is meridional, in the other, zonal.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107521777:311,validat,validation,311,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107521777,2,['validat'],['validation']
Security,"But I do have one question: how are we supposed to treat open boundaries for quantities located at cell centers? I don't see any specific new code dealing with that. I see you used `GradientBoundaryCondition(0)` in your validation codes but, for example, for buoyancy that's not gonna cut it and will lead to reflections.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2261913274:220,validat,validation,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2261913274,1,['validat'],['validation']
Security,"But it's the same solver in the validations script also, right? The FFT solver...; Is there any other difference?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1486161704:32,validat,validations,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1486161704,1,['validat'],['validations']
Security,"Can we start by refactoring this PR to implement this functionality in an example script? It could perhaps go in [`validation/biogeochemistry`](https://github.com/CliMA/Oceananigans.jl/tree/main/validation/biogeochemistry). Once we have that cleaned up, we might be able to see what parts of it belong in the source code versus left to users?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252870856:115,validat,validation,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252870856,2,['validat'],['validation']
Security,Can you do a validation case that has implicit vertical diffusion? Does it work in that case?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1965110912:13,validat,validation,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1965110912,1,['validat'],['validation']
Security,"Change. https://github.com/CliMA/Oceananigans.jl/blob/d4a462b259073b5c698f2cf9a8f419304f74262b/validation/mesoscale_turbulence/baroclinic_adjustment.jl#L51. to. ```julia; diffusive_closure = VerticalScalarDiffusivity(VerticallyImplicitTimeDiscretization(), ν = νz, κ = κz) ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2543#issuecomment-1122646996:95,validat,validation,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2543#issuecomment-1122646996,1,['validat'],['validation']
Security,"Click the link titled ""Details"". This will take you to build kite and, if you have authorization, you will see an button that says ""Rebuild"". You may have to navigate around the build kite site a bit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843336320:83,authoriz,authorization,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843336320,1,['authoriz'],['authorization']
Security,Could you comment on what version of Oceananigans you are using?. Perhaps we need to add a validation that spits out a meaningful warning to the user when this happens.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022623596:91,validat,validation,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022623596,1,['validat'],['validation']
Security,"Definitely in favor of an MPI example!. I think the point is that the script is not an example now, so it could make sense to put the script in `validation/` until it's ready / someone has time to write the example in Literate style and built into the documentation, and perhaps implement the suggested updates to the physics.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1658#issuecomment-842408398:145,validat,validation,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1658#issuecomment-842408398,1,['validat'],['validation']
Security,"Definitely looks good! I guess it belongs more in `validation/`?. We can eventually run it as part of the validation pipeline to generate the plot every night and make sure everything still converges. Also noticed that `examples/Inertial_Instability_2D_old.mp4` was somehow included in this PR (I thought `*.mp4` was in `.gitignore`). I think we'll want to remove it then make sure to ""squash and merge"" this PR so the mp4 file doesn't enter git history (and increase the repo size).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1648#issuecomment-839116955:51,validat,validation,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1648#issuecomment-839116955,2,['validat'],['validation']
Security,"Do we think maybe just extending the existing pattern of input validation functions (`validate_coriolis`, `validate_advection`, etc) is a good route?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796338057:63,validat,validation,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796338057,1,['validat'],['validation']
Security,"Do we want to have a goal of 100% reproducibility for the validation cases? I think their main purpose is expository, ie to show advanced usage of the code. Exact reproducibility isn't the highest priority for that purpose --- is it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3076#issuecomment-1895904765:58,validat,validation,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076#issuecomment-1895904765,1,['validat'],['validation']
Security,"Documents/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/compute_hydrostatic_free_surface_tendencies.jl:236; [7] gpu_compute_hydrostatic_free_surface_Gu!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:90; [8] gpu_compute_hydrostatic_free_surface_Gu!; @ ./none:0; Hint: catch this exception as `err` and call `code_typed(err; interactive = true)` to introspect the erronous code with Cthulhu.jl; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/validation.jl:147; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:440 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/RsWnF/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:439 [inlined]; [5] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:89; [6] emit_llvm; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:83 [inlined]; [7] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:129; [8] codegen; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:110 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:106; [10] compile; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:98 [inlined]; [11] #45; @ ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:57 [inlined]; [12] JuliaContext(f::Metal.var""#45#46""{GPUCompiler.CompilerJob{",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:36385,validat,validate,36385,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822,1,['validat'],['validate']
Security,Does anyone know if there is a way when we activate a project in Julia to preclude access to all packages in the general Julia `(v1.6)` environment? That would make this procedure smoother...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1772#issuecomment-869100541:83,access,access,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1772#issuecomment-869100541,1,['access'],['access']
Security,"During the coefficients down to 1e-9 (!!) allows 3 stable time steps _when continents / bathymetry are removed_:. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 226.942 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (288.084 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.446 seconds).; ┌ Info: Iteration: 1, time: 20 minutes, wall time: 1.452 seconds; │ ├── max(u): (1.32e-16, 5.40e-02, 6.44e-04) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 5.93e-01 m; ┌ Info: Iteration: 2, time: 40 minutes, wall time: 945.169 ms; │ ├── max(u): (1.39e-02, 1.06e-01, 1.05e-03) m s⁻¹; │ ├── extrema(T): (0.05, 30.00) ᵒC; └ └── max|η|: 1.33e+00 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 1 hour, wall time: 945.031 ms; │ ├── max(u): (3.55e-02, 1.52e-01, 1.37e-03) m s⁻¹; │ ├── extrema(T): (0.15, 30.00) ᵒC; └ └── max|η|: 2.08e+00 m; ```. But when they're put back, it still blows up (even with coefficients 1e-9):. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = ImmersedBoundaryGrid on:; architecture: CPU(); grid: 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bound",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807:597,validat,validated,597,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807,1,['validat'],['validated']
Security,"Even if the length is 1, you are missing these lines:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/validation/convergence_tests/ConvergenceTests/OneDimensionalUtils.jl#L60-L63",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483637:142,validat,validation,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483637,1,['validat'],['validation']
Security,"Executing the validation/multi_region/cubed_sphere_steady_state.jl file yields an error partially shown below:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 41.133 ms, wall time: 0 seconds; [ Info: ... simulation initialization complete (820.774 ms); [ Info: Executing initial time step...; ERROR: LoadError: MethodError: no method matching _fill_south_halo!(::Int64, ::Int64, ::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, NamedTuple{(:ξ, :η, :rotation), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}, Rotations.RotXY{Float64}}}, CPU}, ::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ::BoundaryCondition{Oceananigans.BoundaryConditions.MultiRegionCommunication, Oceananigans.MultiRegion.CubedSphereRegionalConnectivity{Oceananigans.MultiRegion.South, Oceananigans.MultiRegion.North, Nothing}}, ::Tuple{Center, Center, Face}). Closest candidates are:; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::BoundaryCondition{<:Oceananigans.BoundaryConditions.Open}, ::Any, ::Any...); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/BoundaryConditions/fill_halo_regions_open.jl:36; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::BoundaryCondition{<:Oceananigans.BoundaryConditions.Flux}, ::Any...); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/BoundaryConditions/fill_halo_regions_flux.jl:32; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::Union{BoundaryCondition{<:Oceananigans.BoundaryConditions.Value}, BoundaryCondition{<:Oceananigans.BoundaryCondition",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742355619:14,validat,validation,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742355619,2,['validat'],['validation']
Security,"First results from the ""stratified ocean remains at rest"" validation:. <img width=""394"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/162029258-21ef073b-62a1-47ae-8515-9fb7e2a7f377.png"">. Short answer --- with partial cells, a resting ocean does not remain at rest! So, we need to implement either the ""MITgcm method"" for hydrostatic pressure, or Lin 1997 (or both).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1090501309:58,validat,validation,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1090501309,1,['validat'],['validation']
Security,"Float64}, Int64}}, Nothing}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, SubArray{Float64, 1, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Tuple{UnitRange{Int64}}, true}}}}, args::LLVM.Module); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/validation.jl:141; [2] macro expansion; @ /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/driver.jl:418 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/.julia/packages/TimerOutputs/4yHI4/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/driver.jl:416 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/utils.jl:64; [6] cufunction_compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:354; [7] #224; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:347 [inlined]; [8] JuliaContext(f::CUDA.var""#224#225""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{typeof(Oceananigans.Fields.gpu__regrid!), Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Nothing, Nothing}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:4545,validat,validate,4545,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574,1,['validat'],['validate']
Security,"For a more complicated case on the cubed sphere, see https://github.com/CliMA/Oceananigans.jl/blob/main/validation/cubed_sphere_tracer_advection/cubed_sphere_tracer_advection.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2046#issuecomment-964617826:104,validat,validation,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2046#issuecomment-964617826,1,['validat'],['validation']
Security,"For future reference, I believe that updating the ssh deploy keys requires two things:. 1. Access to tartarus; 2. Admin privileges on the documentation repo, https://github.com/CliMA/OceananigansDocumentation. The [`Documenter.jl` documentation for generating deploy keys](https://juliadocs.github.io/Documenter.jl/stable/man/hosting/#travis-ssh) reads confusingly because we don't use Travis CI, but I do think we need to do something like what's outlined.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-899744147:91,Access,Access,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-899744147,1,['Access'],['Access']
Security,"For large complex domains, we can obtain an excellent speedup. In the case of the quarter-degree ocean (where the roughly 42% of the domain is immersed), the speedup is about 1.47X!. To document the speedup, here is the profile for the `validation/near_global_lat_lon/near_global_quarter_degree.jl` . On main:; <img width=""1512"" alt=""Screen Shot 2022-11-16 at 10 14 53 AM"" src=""https://user-images.githubusercontent.com/33547697/202219607-aa98d26d-6f6c-4c04-9692-cf9907ad14d6.png"">. On this branch:; <img width=""1512"" alt=""Screen Shot 2022-11-16 at 10 14 48 AM"" src=""https://user-images.githubusercontent.com/33547697/202219640-3476d0a0-e70d-4af8-aa95-f131c86d5379.png"">. The tendency calculations (the four large kernels in the profile) speedup of more than a factor 2!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2817#issuecomment-1317183274:237,validat,validation,237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2817#issuecomment-1317183274,1,['validat'],['validation']
Security,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575:618,access,accessed,618,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575,2,['access'],['accessed']
Security,"Good idea to do a partial cell Immersed boundary!. weird, from what I see here the `mask_immersed_field!` should work properly. have you tried to do ; ```; struct PartialCellBottom{B, E} <: AbstractGridFittedBoundary; bottom_height :: B; minimum_fractional_partial_Δz :: E; end; ```. Like that it seems to be working for me... ```; julia> grid = RectilinearGrid(size=(1, 1, 10), extent=(1, 1, 1)); 1×1×10 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, -1.29526e-16] regularly spaced with Δz=0.1. julia> ibg = ImmersedBoundaryGrid(grid, PartialCellBottom((x, y)-> -0.5, 1)); ┌ Warning: ImmersedBoundaryGrid is unvalidated and may produce incorrect results. Help validate ImmersedBoundaryGrid by reporting any bugs or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues.; └ @ Oceananigans.ImmersedBoundaries ~/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:110; ImmersedBoundaryGrid on: ; architecture: CPU(); grid: 1×1×10 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; with immersed: PartialCellBottom{var""#1#2"", Int64}. julia> c = CenterField(ibg); 1×1×10 Field{Center, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 1×1×10 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux; └── data: 3×3×12 OffsetArray(::Array{Float64, 3}, 0:2, 0:2, 0:11) with eltype Float64 with indices 0:2×0:2×0:11; └── max=0.0, min=0.0, mean=0.0. julia> fill!(c, 1); 3×3×12 Array{Float64, 3}:; [:, :, 1] =; 1.0 1.0 1.0; 1.0 1.0 1.0; 1.0 1.0 1.0. [:, :, 2] =; 1.0 1.0 1.0; 1.0 1.0 1.0; 1.0 1.0 1.0. [:, :, 3] =; 1.0 1.0 1.0; 1.0 1.0 1.0; 1.0 1.0 1.0. ;;; … . [:, :, 10] =; 1.0 1.0 1.0; 1.0 1.0 1.0; 1.0 1.0 1.0. [:,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042393276:831,validat,validate,831,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042393276,1,['validat'],['validate']
Security,"Good idea! Does this mean tagging v0.94.0 (and one stop closer to v0.100) as it's a change to the public interface?. > Remove `OceananigansLogger`: rarely used. I use it in almost every script I write haha, but that's because I wrote it to my liking. There's a strong argument to be made that a logger configuration does not belong in Oceananigans.jl. I feel it's similar to Oceananigans' decision to not provide a default progress callback seeing as each user will probably want a different one. > Remove `StateChecker`: not used as far as I know. Yeah I think I used that to debug cubed sphere stuff. Could easily be defined in a validation script though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439726627:632,validat,validation,632,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439726627,1,['validat'],['validation']
Security,Good idea. I will move it to validation in a new PR today then @ali-ramadhan and I can talk about turning this into a real example.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1658#issuecomment-842413805:29,validat,validation,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1658#issuecomment-842413805,1,['validat'],['validation']
Security,"Good news: shallow water tests pass!. Bad news: the halo tests now has 12 fails, of 600 in total. . ```; <div class=""JobLogOutputComponent"" style=""box-sizing: border-box; background: rgb(23, 23, 23); border-radius: 3px; min-height: 85px; color: white; font-size: 12px; padding: 0px 0px 15px; width: 1108px; font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Helvetica, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;""><div class=""JobLogOutputComponent__Body"" style=""box-sizing: border-box; font-family: SFMono-Regular, Monaco, Menlo, Consolas, &quot;Liberation Mono&quot;, Courier, monospace;"">; Oceananigans \| 818 12 830; --; &nbsp; | Distributed MPI Oceananigans \| 816 12 828; &nbsp; | Multi architectures rank connectivity \| 28 28; &nbsp; | Local grids for distributed models \| 24 24; &nbsp; | Injection of halo communication BCs \| 168 168; &nbsp; | Halo communication \| 588 12 600; &nbsp; | Time stepping IncompressibleModel \| 4 4; &nbsp; | Time stepping ShallowWaterModel \| 4 4; &nbsp; | Distributed FFT-based Poisson solver \| 2 2; &nbsp; | ERROR: ERROR: ERROR: ERROR: LoadError: LoadError: LoadError: LoadError: Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:1195,Inject,Injection,1195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,1,['Inject'],['Injection']
Security,Great job guys. @jagoosw have you been able to run this (https://github.com/CliMA/Oceananigans.jl/blob/19dac0b8f6b621057e250ecf0510b3c4c91915e9/validation/lagrangian_particles/particles_in_convection.jl#L30) on GPU?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1590505343:144,validat,validation,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1590505343,1,['validat'],['validation']
Security,Great. I'll have a look after the docs are build (and I have access to the preview). :),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-797021290:61,access,access,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-797021290,1,['access'],['access']
Security,"Greg, Ali, and what if we began to consider more complex geometries etc -; hard to resist going in that direction..... we'd have to change the solvers; - more MITgcm-like, congrad etc - but what would the implications be for; boundary conditions? More food for thought. John. On Sat, Mar 28, 2020 at 10:22 AM Gregory L. Wagner <notifications@github.com>; wrote:. > Mostly I am worried about scalability and sustainability in this design,; > or future designs.; >; > Currently our models are fairly simple, but its challenging to place; > bounds on potential future complexity. For example, models in the future; > may require additional fields associated with closures or; > parameterizations, such as (two-dimensional) boundary layer depth fields,; > plume quantities, mixing lengths and perhaps other auxiliary fields; > associated with various prognostic / diagnostic LES models. We probably; > can't plan to support setting boundary conditions on every possible field; > via the model constructor.; >; > With our current design we have essentially special-cased turbulent; > diffusivities because our focus is LES, turbulent diffusivities are; > relatively common, and it convenient for us. However doing this incurs some; > maintenance burden --- which will increase if we plan to hard-code; > validation and error checking.; >; > Food for thought.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/721#issuecomment-605453798>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQT642WME2EIX3DDSITRJYBYXANCNFSM4LVSZPAA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605455060:1299,validat,validation,1299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605455060,1,['validat'],['validation']
Security,"Greg, is this something to be be done now? Let's get what we have now; completed and out to the community, get feedback etc. Development will; continue but we need to engage users. John. On Fri, Oct 25, 2019, 1:25 AM Gregory L. Wagner <notifications@github.com>; wrote:. > We need better and more stable time-steppers. One option is to implement; > by hand a 3rd-order low storage Runge Kutta scheme.; >; > Another interesting avenue is to figure out how to integrate with; > DifferentialEquations.jl, which would give us access to a large number of; > new time-steppers.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/506?email_source=notifications&email_token=AKXUEQROLPK63OJDILUPELLQQI4IFA5CNFSM4JE5AV32YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4HUIGFOQ>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQRRJKIBWQ77UVXKGZDQQI4IFANCNFSM4JE5AV3Q>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/506#issuecomment-546217327:522,access,access,522,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/506#issuecomment-546217327,1,['access'],['access']
Security,Happy to approve this if there's unanimous consent. I guess we should tag v0.50.0 with this PR and get the pain of breaking changes out of the way?. Out of paranoia I'm also running the convergence tests for this PR manually: https://buildkite.com/clima/oceananigans-validation-experiments/builds/128,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783458149:267,validat,validation-experiments,267,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783458149,1,['validat'],['validation-experiments']
Security,"Happy to open an issue (or post to #1634) when I have the time to work on CI. What should we do with this PR? I think it's a net positive change so I'm happy to approve as long as the images aren't in git history. If we decide to nuke this part of the docs then I suppose this PR is moot and should be closed. > _when_ / _if_ somebody can take responsibility for maintaining it. I think responsibility for maintaining the pipeline should fall on all maintainers/developers, otherwise it's not sustainable. Ideally if you open a PR that breaks a validation experiment you should fix it. If done concurrently it should only consist of small changes so it should only be a small burden (although burdens to add up). I guess we don't run the validation CI on every PR since it's too expensive so maintenance is tough right now. Maybe we can run validation CI before every tagged release or something? Better infrastructure is needed I suppose.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872481889:545,validat,validation,545,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872481889,3,['validat'],['validation']
Security,"Heh, well the `stratified_fluid_remains_at_rest_with_tilted_gravity_temperature_tracer` test fails. The log suggests that the problem is confined to a few grid points, since the mean is correct:. ```; [2021/07/29 16:10:56.038] INFO Simulation is stopping. Model time 1 hour has hit or exceeded simulation stop time 1 hour.; --;   | [2021/07/29 16:10:57.288] INFO ∂T∂z * g̃[2] = 0.0001065658790393914, mean(∂y_T) = 0.0001065658790360618, Δ = 3.32959842423014e-15 at t = 1 hour with θ=1°;   | [2021/07/29 16:10:57.288] INFO ∂T∂z * g̃[3] = 0.006105155121314884, mean(∂z_T) = 0.006105155121314366, Δ = 5.178149575790769e-16 at t = 1 hour with θ=1°;   | Tilted gravity: Test Failed at /var/lib/buildkite-agent/builds/tartarus-5/clima/oceananigans/test/test_dynamics.jl:290;   | Expression: all(∂T∂z * g̃[2] .≈ interior(∂y_T)); ```. https://github.com/CliMA/Oceananigans.jl/blob/9ecddac3fe2666e05f21e51b81ec2c403094e5ea/test/test_dynamics.jl#L241. I am skeptical about the value of this test. In general, discretizations _do not necessarily_ represent the balance states of the continuous systems they approximate. Thus in general this test should fail! It will succeed of course in the case that the discrete system shares a balanced state with the continuous state. I think this is flawed as a _test_ because, while certainly formulating discrete systems that share balanced states with their continuous systems is _desirable_, I'm not sure it's something we want to guarantee via CI. We should be allowed to violate this prescription if the discrete system has other _more important_ desirable properties. It could be a nice validation test though. In this particular case, the nonhydrostatic useful is most often used for simulations of _vigorous_ turbulence in which weak flows induced by a violation of hydrostatic balance are likely irrelevant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453:1622,validat,validation,1622,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453,1,['validat'],['validation']
Security,"Here are some plots of longitudes at locations cca, fca and cfa with colorbars. They can be generated by running the script [multiregion_cubed_sphere.jl](https://github.com/CliMA/Oceananigans.jl/blob/623b6f5d4c230441871ac61ba55e27d379898ead/validation/multi_region/multi_region_cubed_sphere.jl) of the commit [623b6f5](https://github.com/CliMA/Oceananigans.jl/commit/623b6f5d4c230441871ac61ba55e27d379898ead) of the Oceananigans branch [sb-ncc-ss/cubed-sphere-tracer-advection](https://github.com/CliMA/Oceananigans.jl/tree/sb-ncc-ss/cubed-sphere-tracer-advection) with the specification test_multi_region_cubed_sphere_plots = true. Since these plots look fine to me, I guess the unusual nature of the previous plots can be attributed to a plotting artifact. So, I may be back to square one. . Using set! at location cca; ![longitude_panel_wise_visualization_c_set](https://github.com/CliMA/Oceananigans.jl/assets/12926768/3733da53-dde3-4ce2-9960-c0530d322ba3); Using λnodes at location cca; ![longitude_panel_wise_visualization_u_nodes](https://github.com/CliMA/Oceananigans.jl/assets/12926768/dbd1c4e3-506c-4a2e-b0af-b6a626205784). Using set! at location fca; ![longitude_panel_wise_visualization_u_set](https://github.com/CliMA/Oceananigans.jl/assets/12926768/66c57a6a-81e7-44af-a662-f0c4cc986783); Using λnodes at location fca; ![longitude_panel_wise_visualization_v_nodes](https://github.com/CliMA/Oceananigans.jl/assets/12926768/c6066339-af84-4ca7-a547-e98de9627ffc). Using set! at location cfa; ![longitude_panel_wise_visualization_v_set](https://github.com/CliMA/Oceananigans.jl/assets/12926768/e86ec39d-799a-4891-ad65-b436037e0c4c); Using λnodes at location cfa; ![longitude_panel_wise_visualization_c_nodes](https://github.com/CliMA/Oceananigans.jl/assets/12926768/7920da3c-96b9-41fc-bbab-14daa5665d90)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1689722400:241,validat,validation,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3217#issuecomment-1689722400,1,['validat'],['validation']
Security,"Here's a few idea:. 1. Write more constructors for `BoundaryCondition`. The simplest constructor is what we often use, when the boundary condition is a constant or array. But we should add more constructors that support specifying boundary condition parameters. We should assume that by default the user wants to use `BoundaryFunction`, rather than the current default assumption that the function being specified is low-level. We can have a public constructor for `BoundaryCondition` that takes the argument parameters, which is designed to work with what we currently call ""`BoundaryFunction`"". 2. Add support for a lower-level, non-default boundary condition function signature (the current default) that gives the user access to more of the model state, should they need it. 3. Never ask the user to tell `BoundaryCondition` what field / boundary is being used. Instead, add interpretation to `TracerBoundaryConditions`, `UVelocityBoundaryConditions`, etc that rebuilds the boundary conditions objects as needed. Use defaults in the `BoundaryCondition` constructor as temporary placeholders, and rewrap as needed in `TracerBoundaryConditions`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/769#issuecomment-645519660:723,access,access,723,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/769#issuecomment-645519660,1,['access'],['access']
Security,"Here's a new 1D validation case that tests a ""buoyant particle"" model using a dynamic slip velocity that depends on buoyancy. The particle concentration field migrates to it's neural buoyancy (here in the center of the domain), until the particle concentration reaches a steady-state in a competition between diffusion and buoyant slippage. https://user-images.githubusercontent.com/15271942/161167309-bfedffdb-6f2b-4552-8f49-1ec23ce7b4ed.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1085241172:16,validat,validation,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1085241172,1,['validat'],['validation']
Security,Here's a video from the `sediment_entrainment.jl` validation case:. https://user-images.githubusercontent.com/15271942/161605652-7e1596b0-f76e-4076-902f-6b4e7c78cfae.mp4,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1087864167:50,validat,validation,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1087864167,1,['validat'],['validation']
Security,"Here's a visualization from the new ""bumpy baroclinic adjustment"" validation case:. https://user-images.githubusercontent.com/15271942/162013972-d020b628-3f7b-4ce8-ac56-84c77a96bd42.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2412#issuecomment-1090354580:66,validat,validation,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412#issuecomment-1090354580,1,['validat'],['validation']
Security,"Here's an example:. ```; using Oceananigans; grid = RectilinearGrid(arch, size=(20, 20, 20), extent=(1, 1, 1)); a_field = Oceananigans.Fields.Field{Center, Center, Center}(grid; indices=(:, :, 1:1)); model = NonhydrostaticModel(grid = grid, auxiliary_fields=(;a_field)); simulation = Simulation(model, Δt=1.0, stop_iteration=1). simulation.output_writers[:a_field] = JLD2OutputWriter(model, (model.auxiliary_fields), filename=""example.jld2"", schedule=IterationInterval(1)); ```; And the error I get:; ```; ERROR: BoundsError: attempt to access 26×26×1 Array{Float64, 3} at index [4:23, 4:23, 4:23]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:691; [2] checkbounds; @ ./abstractarray.jl:656 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, indices::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/p4kDj/src/Fields/field.jl:227; [5] view; @ ~/.julia/packages/Oceananigans/p4kDj/src/Fields/field.jl:286 [inlined]; [6] construct_output; @ ~/.julia/packages/Oceananigans/p4kDj/src/OutputWriters/output_construction.jl:49 [inlined]; [7] construct_output(user_output::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeL",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268699061:537,access,access,537,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268699061,1,['access'],['access']
Security,"Here's some results for reference (flat bottom no slip), ""no slip"", ""free slip"", and ""bottom drag"" for fractional heights h=0.1 and h=0.2:. # h = 0.1; https://user-images.githubusercontent.com/15271942/164373427-e614311e-7ff0-492c-a0de-6156eadd24ae.mp4. # h = 0.2; https://user-images.githubusercontent.com/15271942/164373538-08dcc7ff-820c-4492-9a75-a4a406d2c416.mp4. Energy always decreases (rapidly). Momentum is more squirrely, but fortunately we do find that specifying drag / no-slip seems to extract more momentum than otherwise (eg than with free slip boundary conditions). The amount of momentum lost with a free-slip boundary condition and hills of size `h=0.2` is roughly equivalent to the flat bottom case with no-slip. There's also transient periods with `h=0.2` where the case with no-slip boundary conditions has more momentum than free-slip. I'm going to run a few more cases at higher resolution. We should also have a more quantitative validation test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104703550:953,validat,validation,953,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104703550,1,['validat'],['validation']
Security,"Here's some validation. The animation below is from a triply-periodic 3D simulation with an initial reasonably-resolved initial condition without any forcings. Note that the IC looks a bit weird right now (a couple of straight lines in strain) because I'm taking a shortcut in defining a well-resolved random IC, but I can easily change it later if necessary. Left panel shows the strain rate squared for the `SmagorinskyLilly` closure, while the one on the right shows results for the `ScaleInvarianteSmagorinsky` closure, implemented in this PR. The bottom panel shows the evolution of the dynamically-calculated Smagorinsky coefficient for the latter, in comparison with the constant value of 0.16 imposed on the former. Important here is that the value of 0.16 was analytically derived by Lilly by assuming an isotropic 3D turbulence, a Kolmogorovian energy cascade, and further assuming that the cut-off filter is in the inertial range. I think all these assumptions are valid in this simulation, so we expect the dynamically-calculated value of the Smagorinsky coefficient (the black line) to approach the value 0.16 as time goes on. https://github.com/CliMA/Oceananigans.jl/assets/13205162/4049e7cf-452e-4883-a709-a675cf12277c. Although the match is not exact (the value it approaches is ~0.17), I think this is close enough. That said, I'm planning on also implementing a boundary layer validation along similar lines, which we can use to validate the model in the same fashion as [Bou-Zeid et al. (2005)](https://dx.doi.org/10.1063/1.1839152). One thing to note is that the current implementation appears to be very slow. While the simulation with the `SmagorinskyLilly` closure runs on my laptop in 10 seconds, it takes 4 minutes for the simulation with the `ScaleInvariantSmagorinsky`. I know the dynamic model will be slower given the extra computations, but such a difference seems large to me, so I'm hoping something can be changed here to improve performance:. ```julia; ┌ Info: Runnin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2212623170:12,validat,validation,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2212623170,1,['validat'],['validation']
Security,"Here's what I got:. ![image](https://user-images.githubusercontent.com/15271942/156228448-7e02ebdb-4fa6-4e74-a495-0cd955927cb4.png). This seems sort of reasonable at moderate wind speeds. At low wind speeds it presumably doesn't make sense to have a peak period of 2.5s ... ? At the higher wind speeds peak periods of 25.5 s are maybe not impossible. It'd be nice to have a way of validating this. But maybe that's not easy short of actually running WW3. Notes... * The code to produce this is below; * Since Oceananigans doesn't yet have bulk formulae, we have to ""invert"" a toy bulk formula to obtain an ""expected air speed"" for a given kinematic momentum flux `τ`. I'm not sure whether it makes more sense to parameterize Stokes drift in terms of U10 or momentum flux (momentum fluxes saturate when waves stop growing at high wind speeds?); * If we want to re-parameterize this ""equilibrium Stokes drift"" in terms of momentum flux, we'll presumably have to run a sweep with WW3. ```julia; using SpecialFunctions; using GLMakie; using Printf. # Parameters; g = 9.81 # Gravitational acceleration for diagnostic wave property calculations; ρʷ = 1035 # Water density for toy bulk formula; ρᵃ = 1.225 # Air density for toy bulk formula; Cᵈ = 1e-3 # Drag coefficient for toy bulk formula; Ckᵖ = 0.167 # Peak wavenumber scaling parameter; Cuˢ = 0.016 # Scaling between wind stress and surface stokes drift; A_McWilliamsRestrepo = 5.1e-4 # parameter with units ""inverse acceleration""; # that relates wind stress to Stokes transport. # Peak wave number and surface Stokes drift calculation; U₁₀(τ) = sqrt(τ * ρʷ / (Cᵈ * ρᵃ)); surface_Stokes_drift(τ) = Cuˢ * U₁₀(τ); Stokes_transport(τ) = A_McWilliamsRestrepo * U₁₀(τ)^3. @inline function peak_wavenumber(τ); uˢ₀ = surface_Stokes_drift(τ); Vˢ = Stokes_transport(τ); return Ckᵖ * uˢ₀ / Vˢ; end. # Stokes drift profile calculation; T₁(k, z) = exp(2k * z); T₂(k, z) = sqrt(2π * k * abs(z)) * erfc(sqrt(2k * abs(z))). function Stokes_drift(τ, z); kᵖ = peak_waven",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055741685:381,validat,validating,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055741685,1,['validat'],['validating']
Security,"Hi @ali-ramadhan! I'm working on Lagrangian analysis tools for ocean model output. Our original code was written in Matlab (https://doi.org/10.1109/escience.2016.7870923), but since I've recently been learning more about Julia I would like to switch. Our goal is to provide easy community access to large data volume numerical ocean simulations, with ready-made and easy-to-use tools. For Eulerian analysis we've used Python (https://doi.org/10.21105/joss.01506); that package is up and running. I want to add Lagrangian analysis tools to this framework. I'd love to learn more about what you guys are up to!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-726211382:289,access,access,289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-726211382,1,['access'],['access']
Security,"Hi @iurt! Very nice that you are thinking to implement a new parametrization! . To start I would try to implement the additional prognostic equations, decoupled from the main solution. ; You can use the existing infrastructure for tracer evolution and modify the k or epsilon (or omega or whatever quantity you choose to evolve) ""specific"" dissipation terms in the TurbulenceClosures module. Once that is done and validated we can couple them to the momentum equations through the definition of a new ""eddy viscosity"" which uses values from the newly defined tracers",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051271554:414,validat,validated,414,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051271554,1,['validat'],['validated']
Security,Hi @maeckha sorry for the out-of-date scripts. I've been meaning to add the validation experiments to CI so this doesn't happen. I can open a PR later today with an updated lid-driven cavity script if that would be helpful.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-809320083:76,validat,validation,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-809320083,1,['validat'],['validation']
Security,Hi all! . Thank you for the helpful advice and sorry for my delayed response! I am using shared gpu resources on my school's HPC and have not been able to access any resources to test anything out yet so I will update here once I can get some testing done on my side. Thank you again for the help!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-812702328:155,access,access,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-812702328,1,['access'],['access']
Security,"Hi all,; Thank you very much for your quick response. But I run the above working sample with the following errors. I just updated Oceananigans this morning to v0.73.5 and then changed interpolate.jl as #2397 suggested. . The line number could be a little different than yours. So I attached my interpolate.jl. Thanks. . Best,; Si; [interpolate.zip](https://github.com/CliMA/Oceananigans.jl/files/8388789/interpolate.zip). <details open>; <summary>Error info after #2397 produced from the above Minimum Working Example</summary>. ```; TaskFailedException. nested task error: BoundsError: attempt to access 30-element OffsetArray(::Vector{Float64}, -2:27) with eltype Float64 with indices -2:27 at index [28]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:691; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:656 [inlined]; [4] getindex(::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, ::Int64); @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:425 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:425 [inlined]; [6] overdub; @ ~/.julia/packages/Oceananigans/Yz6ub/src/Fields/interpolate.jl:9 [inlined]; [7] fractional_z_index(::Float64, ::Center, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}); @ ~/.julia/packages/Oceananigans/Yz6ub/src/Fields/interpolate.jl:44 [inlined]; [8] overdub; @ ~/.julia/packages/Oceananigans/Yz6ub/src/Fields/interpolate.jl:44 [inlined]; [9] overdub; @ ~/.julia/package",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084429618:599,access,access,599,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395#issuecomment-1084429618,1,['access'],['access']
Security,"Hm, I see... you might be trying to run the one found inside the `validation` directory, right?. I suggest you start of by trying to run the scripts in the `examples` directory. They are continuously tested and should run with the latest version. We'll figure out though the issues and fix the problems for the scripts that live in the `validation` directory (if you are specifically interested on one of those).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807697594:66,validat,validation,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807697594,2,['validat'],['validation']
Security,"Hmm. I think given general `u, v` we need to solve an elliptic equation to find `psi`, eg `lap(psi) = dx v - dy u`. Then the geostrophic buoyancy field is `b = f * dz(psi)`. For some boundary conditions or assumptions of homogeneity, we can possibly simplify this procedure. One could in principle use the conjugate gradient solver to write a fully general utility, though. Hopefully this task will be taken up once the hydrostatic model is operational. Some care must be taken with the geostrophic mode / computation of the geostrophic free surface displacement for the hydrostatic model. Or, given a geostrophic buoyancy field we can integrate in `z` (eg summation of `b * dz`). This would be the intent of `IntegratedField`, but nobody has implemented that yet. Absent those techniques I think the best method for idealized problems is to use a geostrophic streamfunction. This is illustrated by the Eady turbulence example:. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L38-L41. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L151-L152. It's also used in a number of validation cases, but those aren't always useful for general audiences.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877480974:1209,validat,validation,1209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877480974,2,['validat'],['validation']
Security,"Hmm. I think its value as a validation experiment really does depend on keeping it up to date with the current version of Oceananigans. What's really useful to people is the validation script that works for current Oceananigans that people can edit and modify, I think... otherwise it's more a discussion that second-order finite volume / difference methods can reproduce the driven cavity, I suppose. I understand the point though that this work has value and it's a shame to hide it away. I think it might be nice to have a separate repository of ""cool setups"", each of which links to the specific Oceananigans version that it works with...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872347415:28,validat,validation,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872347415,2,['validat'],['validation']
Security,"Hmmm might be related to how the default boundary conditions are injected since specifying the proper default BCs for top/bottom and explicit BCs for east/west seems to work:. ```julia; using Oceananigans; using Oceananigans.BoundaryConditions: NoFluxBoundaryCondition, ImpenetrableBoundaryCondition. topo = (Bounded, Bounded, Bounded); domain = (x=(-1, 1), y=(-1, 1), z=(-1, 0)); grid = RectilinearGrid(CPU(); topology=topo, size=(8, 8, 8), domain...). v_bcs = FieldBoundaryConditions(grid,; east = ValueBoundaryCondition(0),; west = ValueBoundaryCondition(0),; bottom = NoFluxBoundaryCondition(),; top = NoFluxBoundaryCondition(); ). model = NonhydrostaticModel(; grid = grid,; boundary_conditions = (v=v_bcs,); ); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2768#issuecomment-1267074768:65,inject,injected,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2768#issuecomment-1267074768,1,['inject'],['injected']
Security,"However, the only way I manage to make work `Field(eta, indices = indices)` is using `indices = (4:8,4:8,-2)`. I think the reason it only works by pass a `-2` (`z` index) results from the fact that the view uses `-2+3`, where 3 is the size of the halo. I've confirmed that changing the halo in the `RectilinearGrid`, changes the value of the (`z` index) to pass to access the `Field`. ```; julia> Field(eta, indices = (1:5,1:5,-2)); 5×5×1 Field{Center, Center, Face} on RectilinearGrid on CPU; ├── grid: 5×5×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (1:5, 1:5, -2:-2); └── data: 5×5×1 OffsetArray(view(::Array{Float64, 3}, 4:8, 4:8, 1:1), 1:5, 1:5, -2:-2) with eltype Float64 with indices 1:5×1:5×-2:-2; └── max=1.0, min=0.0, mean=0.04; ```. Meanwhile if I set the indices to `(1:5,1:5,2)` to access the supposedly `eta.indices`, I get:. ```; Field(eta, indices = (1:5,1:5,2)); ERROR: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 5:5]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArrays.OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::UnitRange{Int64}, j::UnitRange{Int64}, k::Int64); @ Oceananigans.Fields ~/github/Oceananigans.jl/src/Fields/field.jl:316; [6] #Field#15; @ ~/github/Oceananigans.jl/src/Fi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658:2482,access,access,2482,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2014615658,1,['access'],['access']
Security,"HydrostaticFreeSurfaceModel does (after #3504). ```Julia; julia> model = HydrostaticFreeSurfaceModel(grid = RectilinearGrid(size = (4, 4, 4), extent = (1, 1, 1))); HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (T, S); ├── closure: Nothing; ├── buoyancy: SeawaterBuoyancy with g=9.80665 and LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078) with ĝ = NegativeZDirection(); ├── free surface: ImplicitFreeSurface with gravitational acceleration 9.80665 m s⁻²; │ └── solver: FFTImplicitFreeSurfaceSolver; ├── advection scheme:; │ ├── momentum: Centered reconstruction order 2; │ ├── T: Centered reconstruction order 2; │ └── S: Centered reconstruction order 2; └── coriolis: Nothing; ```. but not the shallow-water model. ```Julia; julia> model = ShallowWaterModel(grid = RectilinearGrid(size = (4, 4), extent = (1, 1), topology=(Periodic, Bounded, Flat)), gravitational_acceleration = 1); ┌ Warning: The ShallowWaterModel is currently unvalidated, subject to change, and should not be used for scientific research without adequate validation.; └ @ Oceananigans.Models.ShallowWaterModels ~/Research/OC11.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:129; ShallowWaterModel{typename(CPU), Float64}(time = 0 seconds, iteration = 0); ├── grid: 4×4×1 RectilinearGrid{Float64, Periodic, Bounded, Flat} on CPU with 3×3×0 halo; ├── tracers: (); └── coriolis: Nothing; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3534#issuecomment-2041019715:1250,validat,validation,1250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3534#issuecomment-2041019715,1,['validat'],['validation']
Security,"I add a bit of context here:. @Yixiao-Zhang is doing a non-hydrostatic simulation with an immersed boundary and he finds that the code crashes with the PCG solver. That is not necessarily connected with the PCG solver but it might be caused by simulation setup or other issues. Since the pressure solver used is experimental (from [this branch](https://github.com/CliMA/Oceananigans.jl/tree/glw-xk/divergence-free-immersed-velocity-field)), as a way to assess where the crashing comes from, I suggested using another method to see if the crash would also happen, which would validate or not the experimental pressure solver. @Yixiao-Zhang, optimizing GPU preconditioners is a quite difficult task as demonstrated by the preconditioners slowing down the simulation, and probably not a good use of time of trying to figure out a way to speed up these solvers that we are not sure we want to use. ; Since this simple attempt to have a simulation that runs (with another _correct_ solver) up to the crashing point does not work, I would suggest to just trying to use a (slightly non-correct) FFT pressure solver to see if the simulation still crashes.; If not, then we can assume the crashing occurs due to the PCG solver and try to catch the bug. ; This will probably be a better way to ""optimize"" the solver since we know that the PCG preconditioned with FFT is faster than these other methods.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2052606749:575,validat,validate,575,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2052606749,2,['validat'],['validate']
Security,"I added a script for looking at coarse, 3D baroclinic adjustment with GM starting with either a gradient in `y` or in `x`: https://github.com/CliMA/Oceananigans.jl/blob/0d04d4014c9ecc06deb158c42a2b3e3cd7699b31/validation/mesoscale_turbulence/coarse_baroclinic_adjustment.jl. It was tricky to get this to work in the first place; it seems we need diffusion to stabilize GM right now. I settled on adding biharmonic diffusivity with a time scale of 10 days. The script computes a mean in the direction perpendicular to the initial gradient. When the gradient is initially in `y`:. https://user-images.githubusercontent.com/15271942/164878441-a0660d6e-3241-4ec4-a473-cf0c65c70fa6.mp4. When the gradient is in `x`:. https://user-images.githubusercontent.com/15271942/164878658-18604606-9374-4008-894e-29ee7e49782a.mp4. From this it seems that the diffusivity is at least doing the right thing (but the stencil may still be non-optimal). We also need to test on a lat-lon grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107363713:210,validat,validation,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107363713,1,['validat'],['validation']
Security,I agree with docs changes. But it would disrupt a lot of important ongoing work to remove the `validation` directory from the repo without providing an alternative place / way to collaborate on new features. So I think we should leave the `validation` scripts in the repo and discuss what to do next before removing them.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873160439:95,validat,validation,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-873160439,2,['validat'],['validation']
Security,"I agree with these!. I think `filename` (including the extension) is a good choice. I also agree its convenient to use `dir` and `filename` rather than `filepath`. For `JLD2`, we need to ""validate"" the `filename` to ensure that it ends in `jld2`. This is needed because we have to identify the ""prefix"" (the part without the extension) in order to do file splitting.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1089701673:188,validat,validate,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416#issuecomment-1089701673,1,['validat'],['validate']
Security,"I also couldn't play the movies in the first comment. I suspect because they were created with `gif(anim, ""movie.mp4"", ...)`. I re-run the validation script and replaced them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975195410:139,validat,validation,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975195410,1,['validat'],['validation']
Security,I also improved the validation according to the discussion in #3241.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3240#issuecomment-1697337369:20,validat,validation,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3240#issuecomment-1697337369,1,['validat'],['validation']
Security,"I am able to run the validatoin example. Unfortunately, it produces `NaNs` after just over an hour. Sigh. Even if I reduce the time step from 20 seconds to 1 second, it still goes unstable at about the same time. I need to look more closely as to why this might be happening. I would share an animation but one hour doesn't seem to be enough time for much to happen so I don't see any changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973396835:21,validat,validatoin,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973396835,1,['validat'],['validatoin']
Security,I am happy to say that the `VectorInvariant` formulation yields similar growth rates `0.144` and `0.123`. Given the numerical methods are different I'm not bothered by this difference. They should converge with increased resolution. Any more questions/concerns on this simple validation problem before I return to the global one?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1976904533:276,validat,validation,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1976904533,2,['validat'],['validation']
Security,"I am still learning how to parse the output but this is what I get. ```julia> typeof(results[CenteredSecondOrder]); Array{NamedTuple{(:cx, :grid),Tuple{NamedTuple{(:simulation, :analytical, :L₁, :L∞),Tuple{Array{Float64,1},Array{Float64,1},Float64,Float64}},Oceananigans.Grids.RegularCartesianGrid{Float64,Oceananigans.Grids.Periodic,Oceananigans.Grids.Periodic,Oceananigans.Grids.Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}},0}; ```. Also, I found that I can use map in the following way. ```; julia> c_ana = map(r -> r.cx.analytical[:], results[CenteredSecondOrder]); 0-dimensional Array{Array{Float64,1},0}:; [8.339763449228298e-167, 9.289942488656767e-154, 3.0530062298945994e-141, 2.960041007581741e-129, 8.466874781928682e-118, 7.14502772471784e-107, 1.7788530458865225e-96, 1.3065667360543323e-86, 2.831251796148466e-77, 1.8100091259558352e-68 … 6.525187676003588e-221, 1.7125465800091643e-236, 1.3260110721966124e-252, 3.0290558443461884e-269, 2.0413749536348825e-286, 4.058762655833247e-304, 2.2e-322, 0.0, 0.0, 0.0]; ```. Then I can access the array using `c_ana[1]'. This seems strange to me but I guess this is what I need to be doing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745422185:1126,access,access,1126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745422185,2,['access'],['access']
Security,"I am trying to get back to the validation script and when I try accessing the data it gives me an error. Is this a known problem? @glwagner @simone-silvestri ?. ```; ┌ Info: Downloading; │ source = ""https://github.com/CliMA/OceananigansArtifacts.jl/raw/ss/new_hydrostatic_data_after_cleared_bugs/quarter_degree_near_global_input_data/tau_x-1440x600-latitude-75.jld2""; │ dest = ""/u/fpoulin/.julia/scratchspaces/124859b0-ceae-595e-8997-d05f6a7a8dfe/datadeps/quarter_degree_near_global_lat_lon/tau_x-1440x600-latitude-75.jld2""; │ progress = NaN; │ time_taken = ""0.07 s""; │ time_remaining = ""NaN s""; │ average_speed = ""3.493 MiB/s""; │ downloaded = ""250.411 KiB""; │ remaining = ""∞ B""; └ total = ""∞ B""; ERROR: HTTP.Exceptions.StatusError(404, ""GET"", ""/CliMA/OceananigansArtifacts.jl/raw/ss/new_hydrostatic_data_after_cleared_bugs/quarter_degree_near_global_input_data/tau_x-1440x600-latitude-75.jld2"", HTTP.Messages.Response:; """"""; HTTP/1.1 404 Not Found; Server: GitHub.com; Date: Thu, 20 Jun 2024 13:36:59 GMT; Content-Type: text/html; charset=utf-8; Vary: X-PJAX, X-PJAX-Container, Turbo-Visit, Turbo-Frame, Accept-Encoding, Accept, X-Requested-With; Cache-Control: no-cache; Strict-Transport-Security: max-age=31536000; includeSubdomains; preload; X-Frame-Options: deny; X-Content-Type-Options: nosniff; X-XSS-Protection: 0; Referrer-Policy: origin-when-cross-origin, strict-origin-when-cross-origin; Content-Security-Policy: default-src 'none'; base-uri 'self'; child-src github.com/assets-cdn/worker/ gist.github.com/assets-cdn/worker/; connect-src 'self' uploads.github.com www.githubstatus.com collector.github.com raw.githubusercontent.com api.github.com github-cloud.s3.amazonaws.com github-production-repository-file-5c1aeb.s3.amazonaws.com github-production-upload-manifest-file-7fdce7.s3.amazonaws.com github-production-user-asset-6210df.s3.amazonaws.com api.githubcopilot.com objects-origin.githubusercontent.com copilot-proxy.githubusercontent.com/v1/engines/github-completion/completions *.a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2180730454:31,validat,validation,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2180730454,2,"['access', 'validat']","['accessing', 'validation']"
Security,"I believe this smells like validation rather than an example. Examples are nice if they are simple yet interesting. This is complicated, but boring (but super useful for validation, obviously!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1570#issuecomment-820025945:27,validat,validation,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1570#issuecomment-820025945,4,['validat'],['validation']
Security,"I believe we also observed bigger speed ups for WENO when it was first implemented. This is plausible because WENO invokes the same memory access pattern as the UpwindBiasedFifthOrder scheme, but has much more compute, which gives the GPU more of an edge.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-862808760:139,access,access,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-862808760,1,['access'],['access']
Security,"I can take a stab at literate-ing a version of this validation experiment, although I suggest using scalings appropriate for the deep ocean. I think it would be nice to rework the experiment into something like this [example script](https://github.com/hdrake/internal-tide-mixing/blob/main/internal_tide_replicate-NL2010.jl), in which I essentially reproduce the MITgcm setup used in [Nikurashin and Legg (2011)](https://journals.ametsoc.org/view/journals/phoc/41/2/2010jpo4522.1.xml) and [Yi et al (2017)](https://www.mdpi.com/2311-5521/2/4/55). Here's a video showing the solution for ~20 M2 tidal cycles or so. https://user-images.githubusercontent.com/12971166/210029541-c3ffe93f-b972-491c-90b6-ab4955d99583.mov. Another idea is to do the simulation in the linear limit (very small topography) and validate some of the results with analytical solutions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1694#issuecomment-1367695388:52,validat,validation,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1694#issuecomment-1367695388,2,['validat'],"['validate', 'validation']"
Security,I can't re-run the tests but if someone with access can I think this PR should be done?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1511478135:45,access,access,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1511478135,1,['access'],['access']
Security,"I can't run the `validation/mesoscale_turbulence/zonally_averaged_baroclinic_adjustment.jl` script. At `run!(simulation)` I get:. ```Julia; julia> run!(simulation, pickup=false); [ Info: Initializing simulation...; [00.00%] i: 0, t: 0 seconds, wall time: 1.221 minutes, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 5.500 minutes; [ Info: ... simulation initialization complete (18.565 seconds); [ Info: Executing initial time step...; ERROR: TaskFailedException. nested task error: TaskFailedException. nested task error: BoundsError: attempt to access 1×135×46 OffsetArray(::Array{Float64, 3}, 1:1, -2:132, -2:43) with eltype Float64 with indices 1:1×-2:132×-2:43 at index [0, 2, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:651; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:616 [inlined]; [4] getindex(::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ::Int64, ::Int64, ::Int64); @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:410 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:410 [inlined]; [6] getindex(::Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Flat, Bounded, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054718902:17,validat,validation,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054718902,2,"['access', 'validat']","['access', 'validation']"
Security,"I checked and `interpolate(field, x, y, z)` isn't used anywhere in the source code but in a few validation experiment. It basically does the same thing, but extracts the fields location and grid. I've tried changing it to just be a wrapper for `interpolate(field, LX, LY, LZ, grid, x, y, z)` like:; ```julia; @inline interpolate(field::AbstractField{LX, LY, LZ, G, T, N}, x, y, z) where {LX, LY, LZ, G, T, N} = interpolate(field, LX(), LY(), LZ(), G, x, y, z); ```; but this fails as a dynamic funciton invocation. I also tried changing it to:; ```; @inline function interpolate(field, x, y, z); LX, LY, LZ = location(field); grid = field.grid; return interpolate(field, LX(), LY(), LZ(), grid, x, y, z); end; ```. but this errors with `Reason: unsupported call to an unknown function (call to jl_f_getfield)`, so I'm not sure its going to be straight forward or worthwhile trying to make the high level version work on GPU. Also, if we want to test interpolation, it always fails on GPU because of scalar indexing if called directly, but if wrapped in a kernel function is fine:; ```julia; @kernel function test!(field, grid, res, x, y, z); n = @index(Global); LX, LY, LZ = location(field); @inbounds res[n] = interpolate(field, Center(), Center(), Center(), grid, x[n], y[n], z[n]); end; ```; (If I put `grid = field.grid ` in the kernel function it also fails like above).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1367924689:96,validat,validation,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1367924689,1,['validat'],['validation']
Security,I compared them and I don't see anything that is in the validation that we don't have in the example. I am going to close this PR and create a new one that simply removes that file.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2545#issuecomment-1123086468:56,validat,validation,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2545#issuecomment-1123086468,2,['validat'],['validation']
Security,"I copied the output of pgk.status as per your request. The second part comes out when I am running lid_driven_cavity.jl. I run it in VS Codium. ```; julia> simulate_lid_driven_cavity(Re=100, N=128, end_time=15); ERROR: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_driven_cavity/lid_driven_cavity.jl:15; [6] top-level scope at REPL[2]:1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807393183:1336,validat,validation,1336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807393183,1,['validat'],['validation']
Security,I did not notice this problem. `ShallowWaterModel` (`Flat` in z) works with an `ImmersedBoundaryGrid`. An example can be found in `validation/shallow_water_model/near_global_shallow_water_quarter_degree.jl` . this video is the output. https://user-images.githubusercontent.com/33547697/200380534-7a4832d6-bdb4-4044-a019-d8d57e553e8a.mp4,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2301#issuecomment-1305977970:131,validat,validation,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2301#issuecomment-1305977970,1,['validat'],['validation']
Security,I don't think I have access to Sverdrup. Could I get access? I wanted to try to run the test there to see what's happening...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1544978864:21,access,access,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1544978864,2,['access'],['access']
Security,"I don't think I understand how this is ill-posed? It is over specified so will not produce physical results but I thought that without a radiating condition this should still not NaN straight away there should just be a lot of reflections from the boundaries?. Here is a simplified version of my code: https://github.com/jagoosw/OpenBoundaries.jl/blob/main/validation/bug_mwe.jl. I am using a matching scheme that advects the perturbation component (defined as the boundary adjacent minus imposed velocity) out of the domain, and relaxes to the imposed velocity at different rates depending on if it is an inflow or outflow (for the v component the timescale is Inf for outflows to allow it to maximally transmit information out). I can run it with no matching scheme but it needs tiny timesteps because the noise at the boundaries becomes massive. When I use the default pressure solver it kind of works. There are some bugs, for example, there is this weird jet generation on the southern inflowing boundary. I think these would be solved with relaxing regions. . https://github.com/user-attachments/assets/a85e66e2-3da7-402a-b546-57a3860cef9c. If I run with the CG solver it NaNs ""immediately"" and is doing ~800 iterations. If I restrict the iterations it doesn't NaN as fast, but generates very high velocities in a random place:. https://github.com/user-attachments/assets/d7ea836e-f69c-4f3a-9559-c64216e95cb0. I think there is also an issue with my model that its not respecting when a boundary adjacent cell is immersed so I'll fix that and get back to you. Perhaps the ""immediate"" NaNs are actually just from the timestep not being small enough as the reflections and bathymetry interactions make some very high velocities (in my case ~40x higher than the inflows)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2411422283:357,validat,validation,357,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2411422283,2,['validat'],['validation']
Security,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:199,validat,validation,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874,8,['validat'],"['validate', 'validated', 'validation']"
Security,"I don't think we should add a new example for this feature though. Perhaps we can include a script as a reference in `validation`? Another possibility is to include an example in the docstring that sets up the Stokes drift profile described here, which will preserve it for future generations as well.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3392#issuecomment-1813263507:118,validat,validation,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3392#issuecomment-1813263507,1,['validat'],['validation']
Security,"I figured out that the figures are all saved to a file and am including a couple of examples. I have a few thougths to share. - Updating plots shouldn't be difficult but don't know anything about the xticks mentioned above. - I think we have too many items in the legend. I think there should just be two sets of markers and the best fit. - Probably don't want to start at such a coarse grid as clearly we are far from convergence. - I think that UpwindBiasedFifthOrder just needs a little more effort to get the order. The curve seems to flatten out, which we all know should not happen. Maybe the time stepping error dominates and we need to reduce \Delta t?. I am happy to help fixing this (and other validations) but getting some help from someone who understands the script would be a lot faster. . ![one_dimensional_convergence_WENO5](https://user-images.githubusercontent.com/8239041/102221597-51a70a80-3eb0-11eb-8421-4a519d5bbfc9.png); ![one_dimensional_convergence_UpwindBiasedFifthOrder](https://user-images.githubusercontent.com/8239041/102221609-54096480-3eb0-11eb-92bf-ef35bb069c96.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745292444:704,validat,validations,704,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745292444,2,['validat'],['validations']
Security,"I found this in the validation script:; ```Julia; grid = LatitudeLongitudeGrid(size = (12, 14),; longitude = (-180, 180),; latitude = (-30, 30),; z = (0, 0),; halo = (4, 4),; topology = (Periodic, Bounded, Flat)); ```. Hm.... `z = (0, 0)` seems to be crucial! Removing it gives the error I posted above. But with `z`-dimension Flat then `z = (0, 0)` shouldn't be needed. We should fix the `LatitudeLongitudeGrid` constructor accordingly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143215355:20,validat,validation,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143215355,1,['validat'],['validation']
Security,"I guess I just read the first part ""no method matching PressureSolver"" and that made sense to me: there's no pressure solver for my input!. But you're right that you don't know which input is the problem (only I know that only the grid matters). So yeah, I think some input validation for `grid` would help in the `NonhydrostaticModel` constructor. We only support `RegRectilinearGrid` and `HRegRectilinearGrid`. All other grid types are invalid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022779778:274,validat,validation,274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022779778,1,['validat'],['validation']
Security,"I guess my opinion is that from an organizational and psychological point of view it makes the most sense to have ""real"" validation experiments and a validation pipeline _when / if_ somebody can take responsibility for maintaining it. At that time, I think that person will be showered with praise, making the job less thankless! I think this is the best strategy in the long run for eventually having legitimate validation experiments. Having them sitting around in a half-baked state could produce the false impression in a future collaborator that such a task does not remain to be done.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872406505:121,validat,validation,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872406505,3,['validat'],['validation']
Security,"I have created a branch and started to make changes to use Plots.jl. Attached are some not so excting plots that are the first of many to come. . ![test1](https://user-images.githubusercontent.com/8239041/102254504-ae1d2080-3ed6-11eb-855d-b79131a5a267.png). ![test2](https://user-images.githubusercontent.com/8239041/102254484-a52c4f00-3ed6-11eb-8354-1e0cdb835a30.png). I do have a question on how to do something. If you look in the code [here](https://github.com/CliMA/Oceananigans.jl/blob/1456cc68b0dd559f91d5ca3770bd123ff2f5eb3a/validation/convergence_tests/ConvergenceTests/OneDimensionalUtils.jl#L65) you will see that I need to put in the advection scheme for this to work. . My next step is to try looking over a couple of schemes, but can't do that using the current syntax. Any advice on what I need to change? The old code just had results, which I would like to have as well, but not sure why it's not working.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745469217:533,validat,validation,533,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745469217,1,['validat'],['validation']
Security,"I have created a new validation script called `shallow_jet_topography.jl` that evolves the barotropically unstable jet (like in the shallow water example) but now over a shelflike topography. It can be found in `valiation/shallow_water`. . Some preliminary results are shown below. First, this is the case with a flat bottom and it does produce the same results as what we have in the example. ![Geostrophic_State](https://github.com/CliMA/Oceananigans.jl/assets/8239041/3f8cc034-6764-4d3e-a7c1-510d7b55073d). Second, this is an example of prograde topography with the shallow water on the right of the propogating jet. ![Geostrophic_State](https://github.com/CliMA/Oceananigans.jl/assets/8239041/d262c028-1ea3-41b8-8573-8ab4419ed891). Third, this is an example of retrograde topopgraphy with the shallow water on the right of the propogating jet. ![Geostrophic_State](https://github.com/CliMA/Oceananigans.jl/assets/8239041/064ebf34-b8bf-4cca-9000-a9edb1bdfd94). The growth rates differ but I want to update my linear stability code to compute the growth rates so that we can validate that the results are quantitatively close. But for this case here the prograde case is slightly more unstable with the rettrograde case, which is qualitatively correct.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973911400:21,validat,validation,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973911400,2,['validat'],"['validate', 'validation']"
Security,"I have incurred a problem with our `ScalarDiffusivity`, which is exposed in enzyme tests. . The `N` parameter of `ScalarDiffusivity` and `ScalarBiharmonicDiffusivity`, which tells us how large the halo size has to be, was in the wrong position. I tried to fix this problem by switching a couple of parameters around (I need to add a unit test for that before this PR is merged), but this exposed a problem with the constructor that is not type-stable. We can pass any `required_halo_size,` and the resulting type will differ (which is quite fine code-wise but not for auto diff). I have changed the constructor to accept `Val(halo_size_required)` instead of an integer, and this fixes the tests, but I am not completely convinced with this solution (Why would we need to pass `Val(Int)` instead of an integer?). What would the options be here? Completely change where we store the buffer size (quite annoying because it is nice to abstract it away in the parameters of the type)? Is there a way to stabilize the constructor type without doing this hacky change to the UI?. I should probably open an issue so we can discuss this topic. We should not merge this PR until this is solved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3732#issuecomment-2327763947:65,expose,exposed,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3732#issuecomment-2327763947,2,['expose'],['exposed']
Security,I have seen particles cause out of bounds memory access errors on GPU before. I think it happens because the interpolation tries to index into the array at an index that does exist (because it's @inbounds 'ed) causing the error.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751625991:49,access,access,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1751625991,1,['access'],['access']
Security,"I have some validation scripts already that work on the CPU and indicate that the new closure is working. However, I can't make this work on the GPU. I keep getting this error:. ```; ERROR: LoadError: GPU compilation of MethodInstance for Oceananigans.TurbulenceClosures.gpu__compute_scale_invariant_smagorinsky_viscosity!(::KernelAbstractions.CompilerMetadata{…}, ::OffsetArrays.OffsetArray{…}, ::Field{…}, ::Field{…}, ::RectilinearGrid{…}, ::ScaleInvariantSmagorinsky{…}, ::Nothing, ::@NamedTuple{…}, ::@NamedTuple{}) failed; KernelError: passing and using non-bitstype argument. Argument 7 to your kernel function is of type ScaleInvariantSmagorinsky{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Oceananigans.TurbulenceClosures.DirectionalAveraging{Tuple{Int64, Int64}}, Float64, @NamedTuple{}, Integer}, which is not isbits:; .update_frequency is of type Integer which is not isbits.; ```. Reading up on the CUDA.jl docs I _think_ I understand where this error comes from (although I thought `update_frequency`, which is an `Integer`, should work, but it throws an error). Still couldn't figure out how to fix it in this case here. I assume it's not hard to fix though, so I was wondering if someone (I'm assuming @simone-silvestri or @glwagner) can please give me a hand or at least point me in the right direction?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2294992357:12,validat,validation,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2294992357,1,['validat'],['validation']
Security,"I have tried it on by completely removing lateral dissipation but unfortunately it crashes after 165 days of simulation with a time step of 6 minutes. This is the last snapshot I have of vertical vorticity compared to a run that starts at the same initial condition but with lateral dissipation and vector invariant scheme. Indeed the structures are much smaller (probably because of the fact that I completely removed horizontal dissipation, both laplacian and biharmonic for both tracers and velocity). On the other hand, there is also more noise, and something is happening in the Indian ocean that crashes the simulation. . The positive is that actually, for some weird reason, this scheme is a bit faster! (Maybe it has to do with how it interacts with the implicit solver?). I see a lot of wave propagation when I start the solution, maybe coming from adjustment to a zero-dissipation solution or maybe just because the numerical dissipation is not enough. I am trying to rerun it with a smaller timestep now to allow an adjustment period, maybe it helps? (or maybe the dream of running without explicit lateral dissipation is not attainable :sweat_smile:) . Also, I am _still_ not sure about this formulation on the sphere so trying it like this is kind of a hail Mary (@francispoulin I hope we can make it work on the`ShallowWaterModel` to validate it would be great). In particular I am not sure what to do with `Coriolis`, which we treat separately but I suspect has to be lumped in into the advection formulation. Also, I am not sure I am treating the immersed boundary conditions correctly. ![global](https://user-images.githubusercontent.com/33547697/157757996-da2a42c4-d822-4ab3-a721-82c8e8721ddb.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064523603:1348,validat,validate,1348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064523603,1,['validat'],['validate']
Security,"I have written a script, with much help from @ali-ramadhan and @glwagner , that computes the rates of convergence for the one dimensinal constant advection case using two approaches: the 1st to 6th order schemes that I mentioned before, and the 2nd to 5th order schemes that are in Oceananigans. The results are shown below. ![convergence_rates_all](https://user-images.githubusercontent.com/8239041/102648898-511fa580-4136-11eb-99c9-a02b85465c96.png). ![convergence_rates_Oceananigans](https://user-images.githubusercontent.com/8239041/102648908-5381ff80-4136-11eb-8feb-de736ec30438.png). **Good news:** Oceananigams produces the correct slopes within error for all the cases. **Next problem:** Figure out why we didn't get the right slope in the other calculation from before and fix whatever the bug might be. You can find the code [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/update-convergence-tests/validation/new_framework/rates_of_convergence.jl)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-748252029:917,validat,validation,917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-748252029,1,['validat'],['validation']
Security,"I implemented a simple new validation test that runs a two-dimensional barotropic turbulence problem with `ExplicitFreeSurface`: https://github.com/CliMA/Oceananigans.jl/blob/ss/multi_region/validation/multi_region/multi_region_turbulence.jl. Here's some miscellaneous notes:. * `WENO5(vector_invariant=VelocityStencil())` is faster than `WENO5()`. Note that when we write ""WENO5(vector_invariant=stencil)"" we mean that we are using the vector invariant formulation of momentum with a WENO reconstruction for vorticity, using either ""velocity"" or ""vorticity"" in the WENO smoothness metric. The ""WENO, Vector Invariant"" scheme is probably faster because it has fewer WENO interpolations (just one per momentum component rather than 2).; * `WENO5(vector_invariant=VelocityStencil())` blows up with `MultiRegionGrid`. Some timings:. | Resolution | Grid | Advection scheme | Wall time for 1000 time steps |; | ------------- | ------------- | -- | -- |; | 128^2 | `RegularRectilinearGrid` | `WENO5()` | 3.9 s |; | 128^2 | `MultiRegionGrid` | `WENO5()` | 7.4 s |; | 128^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 2.8 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5()` | 14.3 s |; | 256^2 | `MultiRegionGrid ` | `WENO5()` | 18.9 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 10.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5()` | 56.3 s |; | 512^2 | `MultiRegionGrid ` | `WENO5()` | 62.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 40.3 s |. I propose that we. 1) Close the gap between multi-region and single-region performance?; 2) Understand why WENO vector invariant blows up on a multi region grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730:27,validat,validation,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730,4,['validat'],['validation']
Security,"I just thought I'd drop by with my point of view as user and (for now) not a developer. Talking with other people who have tried Oceananigans, the most important thing from our point of view may be the MPI parallelism. I know there is some debate to be had in this topic (I've had a couple discussions with @glwagner myself), but for now my understanding is that it's much easier to have access to CPUs then GPUs. Also if I understand correctly that would allow the model to be run on multiple GPUs, which will allow for some really big simulations resolving a huge array of scales. I bet there's new physics to be found there among the nonlinear interactions between all these scales!. From my point of view (now without talking to other users) #1241 seems like a pretty big issue. It's hard to use Oceananigans if you're not sure you're going to be able to calculate the statistics you need to do your science straightforwardly. For what I want right now it seems like I can use `LESbrary.jl`, but that might not always be the case. I'd definitely put that in the list of issues to be resolved asap. From a user perspective I think #890 is also important. I've suffered the consequences of lack of attention to BCs already and it'd be nice to have the model check those for me. I also think #471 would be nice to have. I agree with @navidcy that it's not a deal breaker, but it would save computation and (if I understand correctly) all the hard work for that has been done already, no?. Anyway, I'm still learning about Oceananigans and might be kind of naive in relation to some of the model's particularities. So please that fact into consideration when assessing my suggestions! . Cheers",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1234#issuecomment-738133452:388,access,access,388,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1234#issuecomment-738133452,1,['access'],['access']
Security,I ll try to produce a profile of `validation/elliptic_solvers/doubly_bounded_poisson.jl` with nsys and post it here,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2728#issuecomment-1238094553:34,validat,validation,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2728#issuecomment-1238094553,1,['validat'],['validation']
Security,I pushed some minor edits to the validation script.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975190722:33,validat,validation,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975190722,1,['validat'],['validation']
Security,"I ran a few tests using the [Bickley Jet](https://github.com/CliMA/Oceananigans.jl/blob/glw-vw/grid-fitted-incompressible-model/validation/immersed_boundaries/immersed_bickley_jet.jl) with an immersed top wall from the validation script. . ### Surface Normal Velocity; We can easily look at the surface normal velocity of the immersed wall (which should be zero) with increased resolution and see that it is converging nicely, as this method should be exact except for the pressure correction, which will scale. ![Bickley_normal](https://user-images.githubusercontent.com/67593861/122986244-2e807a80-d36d-11eb-924a-074ca0ad127c.png). ### Tracer Conservation; We can also look at tracer conservation. The initial concentration is sinusoidal, so the area integrated concentration is zero over the domain initially. I've plotted both the IBM and non-IBM (lighter colors) results to see the differences. This one is on a log plot. You can see that leakage is happening in the IBM versions. It's hard to say how bad the leakage is here, and it'll probably be better to consider an initial constant concentration rather than sinusoidal to see how much leakage is occurring due to the immersed solid. ![volint_Concentration_log](https://user-images.githubusercontent.com/67593861/122986580-a058c400-d36d-11eb-9a7c-e3e8d2a7367e.png). It might be easier to see what is going on in the IBM cases without the log scaling:. ![volint_Concentration](https://user-images.githubusercontent.com/67593861/122989251-984e5380-d370-11eb-88cc-ccf4444fb331.png). ### Integrated Boundary Stress; Finally, I looked at the integrated boundary stress along the top wall. The error between the nonIBM and IBM versions at these same grid sizes are below. Unfortunately this is not getting better with increased resolution. This could be due to base state changes causing the stress to change and not necessarily something wrong with the method. It might take better refinement than 256 x 256 to really see a trend here. ![Bickley_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866285588:128,validat,validation,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866285588,2,['validat'],['validation']
Security,"I refactored the interface significantly. Now instead of using a model property `immersed_boundary`, I've introduced a new grid ""wrapper"" called `ImmersedBoundaryGrid`. This new grid wrapper replicates the behavior of the underlying or ""primary"" grid, except where functions are overridden. This allows functions like `diffusive_flux_x` to be extended without touching model time-stepping code. The main motivation for this change is to make it easy to implement more sophisticated immersed boundary methods such as partial cells and shaved cells. In those methods, the presence of the immersed boundary is felt at a fundamental level during the calculation of grid areas and volumes. The `internal_tide.jl` validation experiment has also been refactored and now reads:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; using Plots. grid = RegularRectilinearGrid(size=(256, 256), x=(-10, 10), z=(0, 5), topology=(Periodic, Flat, Bounded)). # Gaussian bump of width ""1""; bump(x, y, z) = z < exp(-x^2). grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)). # Tidal forcing; tidal_forcing(x, y, z, t) = 1e-4 * cos(t). model = HydrostaticFreeSurfaceModel(grid = grid_with_bump,; momentum_advection = CenteredSecondOrder(),; free_surface = ExplicitFreeSurface(gravitational_acceleration=4),; closure = IsotropicDiffusivity(ν=1e-4, κ=1e-4),; tracers = :b, ; buoyancy = BuoyancyTracer(),; coriolis = FPlane(f=sqrt(0.5)),; forcing = (u = tidal_forcing,)). # Linear stratification; set!(model, b = (x, y, z) -> 2 * z). progress(s) = @info ""Time = $(s.model.clock.time), max|w|: $(maximum(abs, model.velocities.w))""; ; simulation = Simulation(model, Δt = 1e-3, stop_time = 10, progress = progress, iteration_interval = 10) ; ; run!(simulation). xu, yu, zu = nodes(model.velocities.u); u = interior(model.velocities.u)[:, 1, :]. umax = maximum(abs, u); ulim = umax / 2 ; ulevels = vcat(-[umax], range(-ulim, stop=ulim, length=30), [u",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841751305:708,validat,validation,708,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841751305,1,['validat'],['validation']
Security,"I removed `show_axis=false` and it still produces an error, see below. . ```; fpoulin@pop-os:~/Software/Oceananigans.jl/validation/barotropic_gyre$ julia visualize_barotropic_gyre.jl ; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fulls",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:120,validat,validation,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985,1,['validat'],['validation']
Security,"I removed that because in master the length of results is just 1, so there is nothing to look over. . In `one_dimensional_gaussian_advection_diffusion.jl` at this [line](https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/validation/convergence_tests/one_dimensional_gaussian_advection_diffusion.jl#L46) it forms all_results by combining different results and I don't believe that I do that in this code. I just have their version of advection_results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745482196:257,validat,validation,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745482196,1,['validat'],['validation']
Security,"I see it like this: Tartarus is a shared system with very small limitations so it is quite difficult to prevent people from running on GPU 0 (I do not think we have the ability to implement a scheduler), so there is more possibility to incur in downtime due to users running on GPU 0. The Caltech cluster might be slower but is much more reliable because it has a professionally maintained slurm scheduler that prevents these types of problems. I tend to prefer having reliability over a modest speedup for these cases, but I am ok with other solutions. One solution would be to routinely kill the jobs on tartarus running on GPU 0 without warning, that would be possible only for people with access on tartarus though. I am ok following that route (I just killed a couple of jobs now 😅). It would be nice to find a more permanent solution though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356610587:693,access,access,693,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356610587,1,['access'],['access']
Security,"I seem to have a problem with the GPU cubed sphere tests; ```; ERROR: Out-of-bounds array access.; ERROR: a exception was thrown during kernel execution.;   | Run Julia on debug level 2 for device stack traces.; ```; When running the tests on tartarus, both normally and with debug level 2, I cannot reproduce the error",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115031875:90,access,access,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1115031875,1,['access'],['access']
Security,I sent a flurry of updates once I had the validation case coded up! It should work now,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082107314:42,validat,validation,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082107314,1,['validat'],['validation']
Security,"I started tackling this issue in ClimaAtmos last week. I wrote a module, `OutputPathGenerator`, in a separate utilities package ([documentation](https://clima.github.io/ClimaUtilities.jl/dev/outputpathgenerator/)). This module defines an object, `OutputPathGenerator` that can be extended with different `OutputPathGeneratorStyle`s. ; The `OutputPathGenerator` is used in a `generate_output_path` function that takes the base output dir and the style.; The simplest of such styles is ""overwrite"". . The style that is currently being used in Atmos is `ActiveLinkStyle`. Citing from the docs:; > This style provides a more convenient and non-destructive approach. It manages a sequence of subfolders within the base directory specified by `output_path`. It also creates a symbolic link named `output_active` that points to the current active subfolder. This allows you to easily access the latest simulation results with a predictable path. > Example:; > Let's assume your output_path is set to data.; > If data doesn't exist, the module creates it and returns data/output_active. This link points to the newly created subfolder data/output_0000.; > If data exists and contains an output_active link pointing to data/output_0005, the module creates a new subfolder data/output_0006 and updates output_active to point to it.; > If data exists with or without an output_active link, the module checks for existing subfolders named data/output_XXXX (with XXXX a number). If none are found, it creates data/output_0000 and a link data/output_active pointing to it. Atmos uses `OutputPathGenerator` internally. My vision is that end users would be providing the base path and possibly choosing a `Style` if they don't want the default behavior (which is the ActiveLinkStyle). `Styles` are Julia objects and new ones can be defined in scripts by implementing a method for the function `generate_output_path`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041168662:877,access,access,877,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041168662,2,['access'],['access']
Security,"I think I actually never posted the result. It is wrong (the ocean is not barotropic) but it is sure mesmerizing. https://user-images.githubusercontent.com/33547697/226215545-c6f34133-6ce4-456c-8430-4f2ced3587eb.mp4. > > There is one that does a one-level near global ocean on a latitude-longitude grid. (in the near_global validation folder); > > I haven't tried this particular script before; > ; > but that's not shallow water... sorry, wrong folder:; https://github.com/CliMA/Oceananigans.jl/blob/main/validation/shallow_water_model/near_global_shallow_water_quarter_degree.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2985#issuecomment-1475429283:324,validat,validation,324,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2985#issuecomment-1475429283,2,['validat'],['validation']
Security,"I think a single `advection` kwarg would make for a cleaner UI, since there are already lots of model kwargs. I agree it's a bit messier to parse and validate but the parsing and validation can be done by small functions in a separate file.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1349#issuecomment-776789031:150,validat,validate,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1349#issuecomment-776789031,2,['validat'],"['validate', 'validation']"
Security,"I think its correct that `Periodic` boundary conditions have `condition=nothing`. . Shouldn't we fill halos in all 3 directions? That way everything is neat and simple and there's no special directions. It will also allow us to easily implement `Periodic` in the z direction at some point in the future, which may be useful for both science and validating the model against established results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/288#issuecomment-505396066:345,validat,validating,345,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/288#issuecomment-505396066,1,['validat'],['validating']
Security,"I think more validation is great. Integrated cases are split into three categories:. 1. Tests (eg the stuff in `test_dynamics.jl` for NonhydrostaticModel). These run during CI.; 2. `validation/`. These are scientific validation cases that often require scientific interpretation or are expensive. These are similar to ""Tests"" but may lack a quantitative metric of success.; 3. `examples/`. These are intended to showcase the API and library usage to users. They should not be used as tests, because they are very expensive to run (via Documenter) and to maintain (for one because they have a high standard for code quality). I suggest adding bona fide Tests and validation, rather than examples, if we are interested in determining the correctness of the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305:13,validat,validation,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305,4,['validat'],['validation']
Security,"I think pressure gradient errors would still creep in to such a problem, but maybe using this technique with pressure gradients ""turned off"" (one way or another, perhaps using `ShallowWaterModel`) can produce a viable validation test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172731603:218,validat,validation,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172731603,1,['validat'],['validation']
Security,I think the disadvantage of using artifacts is that we are a bit more exposed to bugs and I think that's the cause of at least some of our pain here. The advantage is that it's less work to maintain our local CUDA software and our test environment might be more realistic / relevant since users typically use artifacts (I think).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1799#issuecomment-872395555:70,expose,exposed,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1799#issuecomment-872395555,1,['expose'],['exposed']
Security,"I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc.. . It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable. I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc. . Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328:557,access,access,557,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328,2,['access'],['access']
Security,I think the latitude range validation should occur regardless of topology... right?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3241#issuecomment-1697301358:27,validat,validation,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3241#issuecomment-1697301358,1,['validat'],['validation']
Security,"I think the simulation is ready and physically/numerically correct. I ran a high-reynolds-number version of this simulation and results look like those from the original paper (even quantitatively). Here's what the v-velocity and the y-vorticity look like (in this current resolution):. https://user-images.githubusercontent.com/13205162/138630652-3c1f3180-793a-42f4-8402-8ad2a921e2d7.mp4. https://user-images.githubusercontent.com/13205162/138630663-abcc59cd-0334-4037-ae92-1ece165a3536.mp4. Now the question is what to do with this. My idea was to transform this into a docs example, but I can also leave it as a validation. If it were a docs example I think this would then teach users how to:. - use the `Buoyancy()` constructor with a specified vertical direction; - use `ConstantCoriolis`, also with a specified vertical direction (these last two are mostly useful for tilted domains I think); - Possibly also how to use NetCDF output writers, which no example does for now. A few ideas that I had for the docs example which might be controversial are. - Use Oceanostics.jl for the progress messenger and a couple of diagnostics (basically this would teach users that we can use external tools). If we can use some functionality of LESbrary.jl it would be nice too (although probably not possible here, since this isn't an LES).; - Use Python/xarrray to read and plot the data. The major downside of these (especially the python one) is that it would add dependencies to the docs environment. Eager to hear some thoughts. CC: @glwagner @navidcy @francispoulin @wenegrat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-950502676:615,validat,validation,615,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-950502676,1,['validat'],['validation']
Security,I think these are the only two instances. https://github.com/CliMA/Oceananigans.jl/blob/7debded91d24520d72857c120303bcd22b805104/validation/immersed_boundaries/cylinder_flow_with_tracer.jl#L243-L250. https://github.com/CliMA/Oceananigans.jl/blob/7debded91d24520d72857c120303bcd22b805104/validation/near_global_lat_lon/cyclic_interpolate_utils.jl#L18-L30,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1372326567:129,validat,validation,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1372326567,2,['validat'],['validation']
Security,"I think these lines should be using `ξnode`, `ηnode`, and `rnode`:. https://github.com/CliMA/Oceananigans.jl/blob/7cbf013cb6bed2bd7cef0f4d8e5f04c078e50ee0/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L136-L142. I'll open a PR with a fix tomorrow. Should probably also add a test for particle advection on a lat-lon grid. ---. Some debug printing inside `advect_particle` with 1 particle:. ```; [ Info: Iteration 1...; [ Info: X=(1.0, -1.5, -10.0), I=(47, 109, 53); [ Info: (before) X⁺=(1.0, -1.5, -10.0); (iᴿ, jᴿ, kᴿ) = (101, 201, 61); (xᴸ, yᴸ, zᴸ) = (87813.63270401207, -217942.05622333512, -100.0); (xᴿ, yᴿ, zᴿ) = (136722.49142523398, -124538.3178419058, 0.0); (x⁺, y⁺, z⁺) = (175626.26540802413, -249075.1356838116, -10.0); [ Info: (after) X⁺=(175626.26540802413, -249075.1356838116, -10.0); [ Info: Iteration 2...; [ Info: X=(175626.26540802413, -249075.1356838116, -10.0), I=(39914880, -59303137, 53); ERROR: LoadError: BoundsError: attempt to access 109×208×68 OffsetArray(::Array{Float64, 3}, -3:105, -3:204, -3:64) with eltype Float64 with indices -3:105×-3:204×-3:64 at index [39914881, -59303136, 54]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852#issuecomment-2428098528:975,access,access,975,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852#issuecomment-2428098528,1,['access'],['access']
Security,"I think this is a better MWE:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(3, 3, 1), x=(0, 1), y=(0, 1), z=(0, 1));. julia> model = HydrostaticFreeSurfaceModel(; grid);. julia> view(model.free_surface.η, :, :, 2:2); ERROR: BoundsError: attempt to access 9×9×1 Array{Float64, 3} at index [1:9, 1:9, 3:3]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}); @ Base ./abstractarray.jl:734; [2] checkbounds; @ ./abstractarray.jl:699 [inlined]; [3] view; @ ./subarray.jl:179 [inlined]; [4] offset_windowed_data(data::OffsetArray{Float64, 3, Array{…}}, Loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{…}, OffsetVector{…}, OffsetVector{…}, CPU}, indices::Tuple{Colon, Colon, UnitRange{…}}); @ Oceananigans.Fields ~/Projects/Oceananigans.jl/src/Fields/field.jl:248; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{…}, Tuple{…}, OffsetArray{…}, Float64, FieldBoundaryConditions{…}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{…}}, i::Function, j::Function, k::UnitRange{Int64}); @ Oceananigans.Fields ~/Projects/Oceananigans.jl/src/Fields/field.jl:316; [6] top-level scope; @ REPL[6]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. We should be able to call `view(model.free_surface.η, :, :, 2:2)` since the free surface is a windowed field with vertical indices `2:2` (the index slice corresponding to the top surface of the model...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3572#issuecomment-2088756852:276,access,access,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3572#issuecomment-2088756852,1,['access'],['access']
Security,"I think we can hide GPU 0. I suspect the tartarus CPU is much faster. This problem only arose because I exposed GPU 0 to the docs build. . The slurm stuff is just maintained by us, so if we are all professionals, we are professionals...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356625573:104,expose,exposed,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356625573,1,['expose'],['exposed']
Security,I think we can merge now. Maybe it'd be nice to have the realistic case in a similar file as `one_degree_setups/idealized_near_global_one_degree.jl` (if it isn't there already)?. https://github.com/CliMA/Oceananigans.jl/blob/glw-as/near-global-one-degree/validation/near_global_lat_lon/one_degree_setups/idealized_near_global_one_degree.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1119869105:255,validat,validation,255,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1119869105,1,['validat'],['validation']
Security,I think we can't move forward with this until we have a working validation script that uses it. So let's wait until #3306 is merged.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3325#issuecomment-1756201850:64,validat,validation,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3325#issuecomment-1756201850,1,['validat'],['validation']
Security,"I think we should delete the regression test and put a warning in the model constructor ""The ShallowWaterModel has not been validated"". It's a shame we've put so much time into the regression test as it is. I think the model likely has a few bugs to be ironed out. I'm also not convinced that we have all the numerical methods (ie vanishing layers, positive preserving advection) that would be needed to advertise the model as ""production-ready""). One could argue that the regression test is misleading in that it gives the false impression that the model is in a state that shouldn't change.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3049#issuecomment-1496736100:124,validat,validated,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3049#issuecomment-1496736100,1,['validat'],['validated']
Security,I think we should just remove these validation experiments since we have ClimaOcean now...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2690#issuecomment-1480019689:36,validat,validation,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2690#issuecomment-1480019689,1,['validat'],['validation']
Security,"I tried to create a lat-lon grid that is flat in `z` but got this... ```Julia; julia> grid = LatitudeLongitudeGrid(size=(36, 34), longitude = (-180, 180), latitude = (-85, 85), topology = (Bounded, Bounded, Flat)); ERROR: BoundsError: attempt to access 0-element Vector{Any} at index [1]; Stacktrace:; [1] getindex(A::Vector{Any}, i1::Int64); @ Base ./array.jl:805; [2] generate_coordinate(FT::Type, topology::Type, N::Int64, H::Int64, coord::Nothing, arch::CPU); @ Oceananigans.Grids ~/Research/OC.jl/src/Grids/grid_generation.jl:60; [3] LatitudeLongitudeGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64}, longitude::Tuple{Int64, Int64}, latitude::Tuple{Int64, Int64}, z::Nothing, radius::Float64, topology::Tuple{DataType, DataType, DataType}, precompute_metrics::Bool, halo::Nothing); @ Oceananigans.Grids ~/Research/OC.jl/src/Grids/latitude_longitude_grid.jl:195; [4] top-level scope; @ REPL[5]:1; [5] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; ```. @francispoulin, given that 3rd dimension needs to be flat, how were you running the SWE simulations on lat-lon grid?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143210094:246,access,access,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143210094,1,['access'],['access']
Security,"I tried to use CUDA's [`compute-sanitizer`](https://cuda.juliagpu.org/stable/development/debugging/#compute-sanitizer) to debug the memory issue, but couldn't get anything useful out of it so I went back to debug print statements lol. I printed out the value of `maximum(CuArray(randn(100)))` which should error after the illegal memory access occurs. So I peppered these statements around to try and find where the error happens. The issue happens somewhere here:. https://github.com/CliMA/Oceananigans.jl/blob/d66ed9b8b7c4def36260fccf94725c20106029e4/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl#L246-L252. Adding. ```julia; κu★ = convert(eltype(grid), κu★); κc★ = convert(eltype(grid), κc★); κe★ = convert(eltype(grid), κe★); ```. causes the MWE to work, which is weird because `@show` on the CPU tells me that they are `Float32` anyways. And I'm not sure on the GPU because `@cushow` can't show strings. Commenting out. ```julia; # κu★ = mask_diffusivity(i, j, k, grid, κu★); # κc★ = mask_diffusivity(i, j, k, grid, κc★); # κe★ = mask_diffusivity(i, j, k, grid, κe★); ```. also causes the MWE to work. I haven't been able to isolate the problematic line/operation yet. And as far as I can tell, the code used to compute `κuᶜᶜᶠ`, `κcᶜᶜᶠ`, and `κeᶜᶜᶠ` is all type-safe. Will continue later.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2439779361:32,sanitiz,sanitizer,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2439779361,3,"['access', 'sanitiz']","['access', 'sanitizer']"
Security,"I used `validation/mesoscale_turbulence/baroclinic_adjustment.jl` but I reduced the grid size. The big problem of main is the implicit solver, so if you don't use it you see only the difference given by the tracer tendencies, which is smaller. The results above, however, are obtained using exactly the same code you posted (on a mac M1 with one thread though, you use 6, so maybe that is the root cause of the difference)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1486143133:8,validat,validation,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1486143133,1,['validat'],['validation']
Security,"I was having a play with preconditioning the CG solver with multigrid and found that I get considerably different results depending on whether I zero the initial guess to the preconditioner (see [here](https://github.com/CliMA/Oceananigans.jl/blob/0aee96a429332a48fc4b6252f450bf8b35137129/validation/elliptic_solvers/preconditioned_poisson_solver.jl)). When the initial guess is all 0s the `precondition!` method is called ~1/3 of the number to times it is called if the given initial guess is used. My understanding is that the initial guess is not specified by the algorithm in fig 2.5 [here](https://www.netlib.org/templates/templates.pdf) so am not sure whether this is a ""correct"" answer here but would like to know why the zeroing gives such a different result. Could it be because solving for a residual equation the answer should be close to all 0s so it is actually a good initial guess?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175761857:289,validat,validation,289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175761857,1,['validat'],['validation']
Security,I was trying to run `validation/immersed_boundaries/flow_over_hills.jl` and all simulations except the ref one are NaNing pretty quickly. On `main` it works!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3092#issuecomment-1528946599:21,validat,validation,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3092#issuecomment-1528946599,1,['validat'],['validation']
Security,"I went back to check your script and you should not expect NaNs in this simulation.; The model is initiated only with a u-velocity which is constant in x, there are no x-gradients, the grid is periodic in x and there are no boundary conditions nor viscosity that could affect the velocity field, thus the flow field is steady, and would not change also with much higher CFL numbers.; There are no tracers, so no possible NaNs there as well. Particles are lagrangian, they cannot NaN because they do not undergo numerical instability, the only thing that can happen is that they are shot in the x direction way beyond the periodic x-domain which will understandably produce out-of-bounds results when trying to interpolate the location in the grid. I believe that If you find NaNs there is a bug because that simulation should not produce any. You can set debugging level 2 in the Julia invocation (`julia -g2 --check-bounds=yes`) to have access to a more detailed stack trace on the GPU. ; https://cuda.juliagpu.org/stable/development/debugging/; Note that you need CUDA version 11.5 or higher to have access to a detailed stack trace",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771934998:938,access,access,938,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771934998,2,['access'],['access']
Security,I would like to suggest the following checklist moving forward. - [ ] Decide whether we like the structure of the script `new_rates_of_convergence.jl`. How can we might improve it?; - [ ] Find where the bottleneck is in Oceanangans to make things globally single precision.; - [ ] Adapt this approach to the other validation cases that currently exist.; - [ ] Make `UpwindFirstOrderBiased()` advection scheme.; - [ ] Make `CenteredSixthOrder()` advection scheme.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750476313:314,validat,validation,314,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750476313,1,['validat'],['validation']
Security,"I wrote some validation scripts and I think the model is working, but I'd appreciate some feedback. First, this animation shows two 3D decaying turbulence simulations, one with `SmagorinskyLilly` and another with the `ScaleInvSmag`. I'm also plotting the value of the Smagorinsky constant from the dynamic model. For similar conditions (3D homogeneous tubrulence), Lilly assumed a sharp spectral filter in the inertial subrange, matched the SGS dissipation rate to the TKE dissipation rate and obtained the theoretical value of the Smag constant of $c_s$ ≈ 0.165. I think these assumptions should be roughly valid in this validation script, and indeed the value that we obtain for $c_s$ is kinda close:. https://github.com/user-attachments/assets/f210d18b-82bf-4e9e-bb26-58bbd4251820. Although to be honest I expected the value to be closer. That said, I believe Lilly also assumed a _stationary_ turbulent flow (although I'd have to double check that), which is not the case here and may be affecting the coefficient value. Btw, I had posted a similar video before but I made some modifications to the model since then. I also reproduced the first test simulation in the original Bou-Zeid (2005) paper: namely a channel flow forced by a pressure gradient, with a Monin-Obukhov-compliant bottom drag. I couldn't reproduce the simulation perfectly (for example, they use a pseudo-spectral scheme in the horizontal directions, force their drag with a horizontal average, and modify the `SmagLilly` constant slightly) so the results are a bit different from what's in their paper, but I think that's okay. Let me know if anyone thinks otherwise. Importantly, the `ScaleInvSmag` shows an improvement over the `SmagLilly`, with the later being expectedly overly diffusive and pretty much killing any turbulence at this resolution:. https://github.com/user-attachments/assets/6440450d-52f4-43ef-9ad5-0f8fcd9993d5. For reference, this is what similar plots from the paper look like (the equivalent for us her",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2417879667:13,validat,validation,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2417879667,4,['validat'],['validation']
Security,"I""m going to shift this fork to a personal account so that I can enable push access. This will require me to close this PR in favor of that one.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936996887:77,access,access,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936996887,1,['access'],['access']
Security,"I'd be in favor of always emitting a warning for `ImmersedBoundaryCondition` that it's experimental (no published papers, few validation tests)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1613499377:126,validat,validation,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3142#issuecomment-1613499377,1,['validat'],['validation']
Security,"I'm a bit confused, I managed to solve the issue by changing manually the grid passed to `output_indices` at:; https://github.com/CliMA/Oceananigans.jl/blob/e243e5b44ea0c4570ae427bdce1d68dc29594f24/src/OutputWriters/output_construction.jl#L32-L42; For example, in the example provided by @navidcy:; ```; julia> size(grid); (5, 5, 4); ```; That is passed to the `output_indices` function that outputs the indices `(1:5, 1:5, 1:5)` or `(4:8, 4:8, 4:8)` once the halos are taken into account. ; The way I managed to save $\eta$ in a hacky way was by changing the `size(grid)` to (5, 5, -1), so it outputs the surface index in `z`, since the `size(eta)` is `(5, 5, 1)`; My two ideas on how to fixing this are:; - Rather than using the `size(grid)`, use `size(output)`, however using `size(eta)` still crashes, since it try to access the indexes `(4:8, 4:8, 4:5)` rather than `(4:8, 4:8, 1:0)`; - Check if there is a `Face` in the `z` direction of the `location(output)`, and then force the last index to be `-1`. . Before I do any of this changes, I don't understand how are the halos (applied in all directions) implemented in a surface such as $\eta$? I guess the same will apply to any flux at the surface right? . Do you have any other way to fix this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2012871651:822,access,access,822,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2012871651,1,['access'],['access']
Security,"I'm getting this error when trying to run my code on multiple GPUs (it works fine on CPUs):. ```julia; ERROR: LoadError: BoundsError: attempt to access Tuple{Vector{CuStream}} at index [2]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base ./tuple.jl:29; [2] (::Oceananigans.Architectures.var""#3#6"")(); @ Oceananigans.Architectures /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Architectures.jl:26; [3] lock(f::Oceananigans.Architectures.var""#3#6"", l::ReentrantLock); @ Base ./lock.jl:185; [4] next_stream; @ /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Architectures.jl:24 [inlined]; [5] (::KernelAbstractions.Kernel{CUDAKernels.CUDADevice, KernelAbstractions.NDIteration.StaticSize{(1, 36)}, KernelAbstractions.NDIteration.StaticSize{(36, 1)}, typeof(Oceananigans.BoundaryConditions.gpu_fill_periodic_south_and_north_halo!)})(::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, ::Vararg{Any}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels /glade/work/tomasc/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:218; [6] launch!(::GPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, ::Tuple{Int64, Int64}, ::typeof(Oceananigans.BoundaryConditions.fill_periodic_south_and_north_halo!), ::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, ::Vararg{Any}; dependencies::CUDAKernels.CudaEvent, include_right_boundaries::Bool, reduced_dimensions::Tuple{Int64}, location::Nothing, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils /gl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310681185:145,access,access,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310681185,1,['access'],['access']
Security,I'm going to clean up the validation experiments for the new syntax and then this is ready.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1843#issuecomment-879853229:26,validat,validation,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1843#issuecomment-879853229,1,['validat'],['validation']
Security,"I'm going to try and put some some into this, but I'm a bit unsure of what to do. First, to summarize what the current state on `main` is. Taking a `RectilinearGrid` and `zspacing` at the `Center` as an example. ---. ### Current behavior for `RectilinearGrid`. Without immersed boundaries, this is pretty straightforward. The call to `zspacings()` dispatches to . https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Grids/rectilinear_grid.jl#L477-L478. which directly accesses the `grid`'s `Δzᵃᵃᶜ` property. The call to `zspacing()` goes through some metaprogramming [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L247-L269) but ultimately also directly accesses the `grid`'s `Δzᵃᵃᶜ` property here:. https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L104-L112. ---. ### Current behavior for `ImmersedBoundaryGrid`. For the same grid wrapped around an `ImmersedBoundaryGrid` on `main`, when calling `zspacings()` we get the error at the top comment (`MethodError: no method matching`; which this PR aims to fix). The call to `zspacing()` works the same way as with `RectilinearGrid`, with the exception of an extra dispatch [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/ImmersedBoundaries/immersed_grid_metrics.jl#L16-L31). ---. ### Summary of the PR as of this post. This PR is originally trying to fix the issue with `zspacings(::IBG)` simply by adding. ```julia; zspacings(grid::IBG, args...; kwargs...) = zspacings(grid.underlying_grid, args...; kwargs...); ```. If I understand correctly, @glwagner's point is that this is wrong in cases where cells have a fraction of ""wet"" volume and a fraction of ""immersed solid"" volume. (For now the two such cases in sight are `PartialCellBottom` and `CutCellBottom` (for which there's o",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041:507,access,accesses,507,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041,4,['access'],['accesses']
